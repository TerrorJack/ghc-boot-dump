
==================== Output Cmm ====================
2018-03-16 16:08:43.435046953 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:43.43611363 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec2_closure" {
     Data.Functor.Classes.liftShowsPrec2_closure:
         const Data.Functor.Classes.liftShowsPrec2_info;
 },
 Data.Functor.Classes.liftShowsPrec2_entry() //  [R2]
         { info_tbl: [(cdyN8,
                       label: Data.Functor.Classes.liftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyN8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyN9; else goto cdyNa;
       cdyN9: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyNa: // global
           I64[Sp - 8] = block_cdyN5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyNe; else goto cdyN6;
       udyNe: // global
           call _cdyN5(R1) args: 0, res: 0, upd: 0;
       cdyN6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyN5() //  [R1]
         { info_tbl: [(cdyN5,
                       label: block_cdyN5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyN5: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.437502746 UTC

[section ""data" . Data.Functor.Classes.liftShowList2_closure" {
     Data.Functor.Classes.liftShowList2_closure:
         const Data.Functor.Classes.liftShowList2_info;
 },
 Data.Functor.Classes.liftShowList2_entry() //  [R2]
         { info_tbl: [(cdyNm,
                       label: Data.Functor.Classes.liftShowList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyNn; else goto cdyNo;
       cdyNn: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyNo: // global
           I64[Sp - 8] = block_cdyNj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyNs; else goto cdyNk;
       udyNs: // global
           call _cdyNj(R1) args: 0, res: 0, upd: 0;
       cdyNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyNj() //  [R1]
         { info_tbl: [(cdyNj,
                       label: block_cdyNj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNj: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.438706339 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec2_closure" {
     Data.Functor.Classes.liftReadsPrec2_closure:
         const Data.Functor.Classes.liftReadsPrec2_info;
 },
 Data.Functor.Classes.liftReadsPrec2_entry() //  [R2]
         { info_tbl: [(cdyNA,
                       label: Data.Functor.Classes.liftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyNB; else goto cdyNC;
       cdyNB: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyNC: // global
           I64[Sp - 8] = block_cdyNx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyNG; else goto cdyNy;
       udyNG: // global
           call _cdyNx(R1) args: 0, res: 0, upd: 0;
       cdyNy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyNx() //  [R1]
         { info_tbl: [(cdyNx,
                       label: block_cdyNx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNx: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.439950201 UTC

[section ""data" . Data.Functor.Classes.liftReadList2_closure" {
     Data.Functor.Classes.liftReadList2_closure:
         const Data.Functor.Classes.liftReadList2_info;
 },
 Data.Functor.Classes.liftReadList2_entry() //  [R2]
         { info_tbl: [(cdyNO,
                       label: Data.Functor.Classes.liftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyNP; else goto cdyNQ;
       cdyNP: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyNQ: // global
           I64[Sp - 8] = block_cdyNL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyNU; else goto cdyNM;
       udyNU: // global
           call _cdyNL(R1) args: 0, res: 0, upd: 0;
       cdyNM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyNL() //  [R1]
         { info_tbl: [(cdyNL,
                       label: block_cdyNL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNL: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.441217448 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec2_closure" {
     Data.Functor.Classes.liftReadPrec2_closure:
         const Data.Functor.Classes.liftReadPrec2_info;
 },
 Data.Functor.Classes.liftReadPrec2_entry() //  [R2]
         { info_tbl: [(cdyO2,
                       label: Data.Functor.Classes.liftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyO2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyO3; else goto cdyO4;
       cdyO3: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyO4: // global
           I64[Sp - 8] = block_cdyNZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyO8; else goto cdyO0;
       udyO8: // global
           call _cdyNZ(R1) args: 0, res: 0, upd: 0;
       cdyO0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyNZ() //  [R1]
         { info_tbl: [(cdyNZ,
                       label: block_cdyNZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyNZ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.442462502 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2_closure" {
     Data.Functor.Classes.liftReadListPrec2_closure:
         const Data.Functor.Classes.liftReadListPrec2_info;
 },
 Data.Functor.Classes.liftReadListPrec2_entry() //  [R2]
         { info_tbl: [(cdyOg,
                       label: Data.Functor.Classes.liftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyOh; else goto cdyOi;
       cdyOh: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyOi: // global
           I64[Sp - 8] = block_cdyOd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyOm; else goto cdyOe;
       udyOm: // global
           call _cdyOd(R1) args: 0, res: 0, upd: 0;
       cdyOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyOd() //  [R1]
         { info_tbl: [(cdyOd,
                       label: block_cdyOd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOd: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.44477517 UTC

[section ""data" . Data.Functor.Classes.$p1Ord2_closure" {
     Data.Functor.Classes.$p1Ord2_closure:
         const Data.Functor.Classes.$p1Ord2_info;
 },
 Data.Functor.Classes.$p1Ord2_entry() //  [R2]
         { info_tbl: [(cdyOu,
                       label: Data.Functor.Classes.$p1Ord2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyOv; else goto cdyOw;
       cdyOv: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyOw: // global
           I64[Sp - 8] = block_cdyOr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyOA; else goto cdyOs;
       udyOA: // global
           call _cdyOr(R1) args: 0, res: 0, upd: 0;
       cdyOs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyOr() //  [R1]
         { info_tbl: [(cdyOr,
                       label: block_cdyOr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOr: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.445950594 UTC

[section ""data" . Data.Functor.Classes.liftCompare2_closure" {
     Data.Functor.Classes.liftCompare2_closure:
         const Data.Functor.Classes.liftCompare2_info;
 },
 Data.Functor.Classes.liftCompare2_entry() //  [R2]
         { info_tbl: [(cdyOI,
                       label: Data.Functor.Classes.liftCompare2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyOJ; else goto cdyOK;
       cdyOJ: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyOK: // global
           I64[Sp - 8] = block_cdyOF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyOO; else goto cdyOG;
       udyOO: // global
           call _cdyOF(R1) args: 0, res: 0, upd: 0;
       cdyOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyOF() //  [R1]
         { info_tbl: [(cdyOF,
                       label: block_cdyOF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOF: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.447019797 UTC

[section ""data" . Data.Functor.Classes.liftEq2_closure" {
     Data.Functor.Classes.liftEq2_closure:
         const Data.Functor.Classes.liftEq2_info;
 },
 Data.Functor.Classes.liftEq2_entry() //  [R2]
         { info_tbl: [(cdyOT,
                       label: Data.Functor.Classes.liftEq2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyOT: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.447910052 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec_closure" {
     Data.Functor.Classes.liftShowsPrec_closure:
         const Data.Functor.Classes.liftShowsPrec_info;
 },
 Data.Functor.Classes.liftShowsPrec_entry() //  [R2]
         { info_tbl: [(cdyP3,
                       label: Data.Functor.Classes.liftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyP3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyP4; else goto cdyP5;
       cdyP4: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyP5: // global
           I64[Sp - 8] = block_cdyP0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyP9; else goto cdyP1;
       udyP9: // global
           call _cdyP0(R1) args: 0, res: 0, upd: 0;
       cdyP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyP0() //  [R1]
         { info_tbl: [(cdyP0,
                       label: block_cdyP0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyP0: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.449038725 UTC

[section ""data" . Data.Functor.Classes.liftShowList_closure" {
     Data.Functor.Classes.liftShowList_closure:
         const Data.Functor.Classes.liftShowList_info;
 },
 Data.Functor.Classes.liftShowList_entry() //  [R2]
         { info_tbl: [(cdyPh,
                       label: Data.Functor.Classes.liftShowList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyPi; else goto cdyPj;
       cdyPi: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyPj: // global
           I64[Sp - 8] = block_cdyPe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyPn; else goto cdyPf;
       udyPn: // global
           call _cdyPe(R1) args: 0, res: 0, upd: 0;
       cdyPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyPe() //  [R1]
         { info_tbl: [(cdyPe,
                       label: block_cdyPe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPe: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.450198225 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec_closure" {
     Data.Functor.Classes.liftReadsPrec_closure:
         const Data.Functor.Classes.liftReadsPrec_info;
 },
 Data.Functor.Classes.liftReadsPrec_entry() //  [R2]
         { info_tbl: [(cdyPv,
                       label: Data.Functor.Classes.liftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyPw; else goto cdyPx;
       cdyPw: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyPx: // global
           I64[Sp - 8] = block_cdyPs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyPB; else goto cdyPt;
       udyPB: // global
           call _cdyPs(R1) args: 0, res: 0, upd: 0;
       cdyPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyPs() //  [R1]
         { info_tbl: [(cdyPs,
                       label: block_cdyPs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPs: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.451311965 UTC

[section ""data" . Data.Functor.Classes.liftReadList_closure" {
     Data.Functor.Classes.liftReadList_closure:
         const Data.Functor.Classes.liftReadList_info;
 },
 Data.Functor.Classes.liftReadList_entry() //  [R2]
         { info_tbl: [(cdyPJ,
                       label: Data.Functor.Classes.liftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyPK; else goto cdyPL;
       cdyPK: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyPL: // global
           I64[Sp - 8] = block_cdyPG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyPP; else goto cdyPH;
       udyPP: // global
           call _cdyPG(R1) args: 0, res: 0, upd: 0;
       cdyPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyPG() //  [R1]
         { info_tbl: [(cdyPG,
                       label: block_cdyPG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPG: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.452437028 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec_closure" {
     Data.Functor.Classes.liftReadPrec_closure:
         const Data.Functor.Classes.liftReadPrec_info;
 },
 Data.Functor.Classes.liftReadPrec_entry() //  [R2]
         { info_tbl: [(cdyPX,
                       label: Data.Functor.Classes.liftReadPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyPY; else goto cdyPZ;
       cdyPY: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyPZ: // global
           I64[Sp - 8] = block_cdyPU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyQ3; else goto cdyPV;
       udyQ3: // global
           call _cdyPU(R1) args: 0, res: 0, upd: 0;
       cdyPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyPU() //  [R1]
         { info_tbl: [(cdyPU,
                       label: block_cdyPU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyPU: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.453606947 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec_closure" {
     Data.Functor.Classes.liftReadListPrec_closure:
         const Data.Functor.Classes.liftReadListPrec_info;
 },
 Data.Functor.Classes.liftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdyQb,
                       label: Data.Functor.Classes.liftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyQc; else goto cdyQd;
       cdyQc: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyQd: // global
           I64[Sp - 8] = block_cdyQ8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyQh; else goto cdyQ9;
       udyQh: // global
           call _cdyQ8(R1) args: 0, res: 0, upd: 0;
       cdyQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyQ8() //  [R1]
         { info_tbl: [(cdyQ8,
                       label: block_cdyQ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQ8: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.454729794 UTC

[section ""data" . Data.Functor.Classes.$p1Ord1_closure" {
     Data.Functor.Classes.$p1Ord1_closure:
         const Data.Functor.Classes.$p1Ord1_info;
 },
 Data.Functor.Classes.$p1Ord1_entry() //  [R2]
         { info_tbl: [(cdyQp,
                       label: Data.Functor.Classes.$p1Ord1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyQq; else goto cdyQr;
       cdyQq: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyQr: // global
           I64[Sp - 8] = block_cdyQm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyQv; else goto cdyQn;
       udyQv: // global
           call _cdyQm(R1) args: 0, res: 0, upd: 0;
       cdyQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyQm() //  [R1]
         { info_tbl: [(cdyQm,
                       label: block_cdyQm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQm: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.455886746 UTC

[section ""data" . Data.Functor.Classes.liftCompare_closure" {
     Data.Functor.Classes.liftCompare_closure:
         const Data.Functor.Classes.liftCompare_info;
 },
 Data.Functor.Classes.liftCompare_entry() //  [R2]
         { info_tbl: [(cdyQD,
                       label: Data.Functor.Classes.liftCompare_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdyQE; else goto cdyQF;
       cdyQE: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyQF: // global
           I64[Sp - 8] = block_cdyQA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyQJ; else goto cdyQB;
       udyQJ: // global
           call _cdyQA(R1) args: 0, res: 0, upd: 0;
       cdyQB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyQA() //  [R1]
         { info_tbl: [(cdyQA,
                       label: block_cdyQA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQA: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.456937523 UTC

[section ""data" . Data.Functor.Classes.liftEq_closure" {
     Data.Functor.Classes.liftEq_closure:
         const Data.Functor.Classes.liftEq_info;
 },
 Data.Functor.Classes.liftEq_entry() //  [R2]
         { info_tbl: [(cdyQO,
                       label: Data.Functor.Classes.liftEq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.45766738 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const1_closure" {
     Data.Functor.Classes.$fRead1Const1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.458251403 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Const4_bytes" {
     Data.Functor.Classes.$fRead1Const4_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.459035626 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const3_closure" {
     Data.Functor.Classes.$fRead1Const3_closure:
         const Data.Functor.Classes.$fRead1Const3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const3_entry() //  [R1]
         { info_tbl: [(cdyQX,
                       label: Data.Functor.Classes.$fRead1Const3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyQX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdyQY; else goto cdyQZ;
       cdyQY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdyQZ: // global
           (_cdyQU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdyQU::I64 == 0) goto cdyQW; else goto cdyQV;
       cdyQW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdyQV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdyQU::I64;
           R2 = Data.Functor.Classes.$fRead1Const4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.459982908 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const2_closure" {
     Data.Functor.Classes.$fRead1Const2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.461582019 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadPrec1_info;
         const 0;
 },
 sat_sdyo7_entry() //  [R1, R2]
         { info_tbl: [(cdyRs,
                       label: sat_sdyo7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyRs: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyo8_entry() //  [R1, R2]
         { info_tbl: [(cdyRv,
                       label: sat_sdyo8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyRv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyRz; else goto cdyRy;
       cdyRz: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyRy: // global
           _sdynX::P64 = P64[R1 + 7];
           _sdyo1::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyo7_info;
           P64[Hp] = _sdyo1::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdynX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyob_entry() //  [R1, R2, R3]
         { info_tbl: [(cdyRA,
                       label: sat_sdyob_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyRA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdyRB; else goto cdyRC;
       cdyRB: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyRC: // global
           I64[Sp - 24] = block_cdyR9_info;
           _sdynX::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdynX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udyRP; else goto cdyRa;
       udyRP: // global
           call _cdyR9(R1) args: 0, res: 0, upd: 0;
       cdyRa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyR9() //  [R1]
         { info_tbl: [(cdyR9,
                       label: block_cdyR9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyR9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdyRF; else goto cdyRE;
       cdyRF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyRE: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdyRH; else goto cdyRL;
       cdyRH: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdyRL: // global
           I64[Hp - 16] = sat_sdyo8_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdyRI_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdyRI() //  [R1]
         { info_tbl: [(cdyRI,
                       label: block_cdyRI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyRI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyRO; else goto cdyRN;
       cdyRO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyRN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyRQ,
                       label: Data.Functor.Classes.$w$cliftReadPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyRQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyRU; else goto cdyRT;
       cdyRU: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyRT: // global
           I64[Hp - 8] = sat_sdyob_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.463972296 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const6_closure" {
     Data.Functor.Classes.$fRead1Const6_closure:
         const Data.Functor.Classes.$fRead1Const6_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const6_entry() //  [R2, R6]
         { info_tbl: [(cdyS0,
                       label: Data.Functor.Classes.$fRead1Const6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyS0: // global
           R4 = P64[Sp];
           R3 = R6;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.465020445 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyoo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdySc,
                       label: sat_sdyoo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdySc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdySf,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdySf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdySj; else goto cdySi;
       cdySj: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdySi: // global
           I64[Hp - 8] = sat_sdyoo_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.467601668 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec7_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec7_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec7_info;
         const 0;
 },
 lvl3_sdyor_entry() //  [R1]
         { info_tbl: [(cdySw,
                       label: lvl3_sdyor_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdySw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdySx; else goto cdySy;
       cdySx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdySy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyoz_entry() //  [R1, R2]
         { info_tbl: [(cdySX,
                       label: sat_sdyoz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdySX: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoC_entry() //  [R1, R2]
         { info_tbl: [(cdyT3,
                       label: sat_sdyoC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyT3: // global
           _sdyox::P64 = R2;
           _sdyoC::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdyT4; else goto cdyT5;
       cdyT5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyT7; else goto cdyT6;
       cdyT7: // global
           HpAlloc = 16;
           goto cdyT4;
       cdyT4: // global
           R2 = _sdyox::P64;
           R1 = _sdyoC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyT6: // global
           _sdyor::P64 = P64[_sdyoC::P64 + 7];
           _sdyot::P64 = P64[_sdyoC::P64 + 15];
           I64[Hp - 8] = sat_sdyoz_info;
           P64[Hp] = _sdyot::P64;
           I64[Sp - 8] = block_cdyT0_info;
           R3 = Hp - 7;
           R2 = _sdyor::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdyT0() //  [R1]
         { info_tbl: [(cdyT0,
                       label: block_cdyT0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyT0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyTa; else goto cdyT9;
       cdyTa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyT9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoF_entry() //  [R1, R2, R3]
         { info_tbl: [(cdyTb,
                       label: sat_sdyoF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdyTc; else goto cdyTd;
       cdyTc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyTd: // global
           I64[Sp - 24] = block_cdySE_info;
           _sdyor::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyor::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udyTq; else goto cdySF;
       udyTq: // global
           call _cdySE(R1) args: 0, res: 0, upd: 0;
       cdySF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdySE() //  [R1]
         { info_tbl: [(cdySE,
                       label: block_cdySE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdySE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdyTg; else goto cdyTf;
       cdyTg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyTf: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdyTi; else goto cdyTm;
       cdyTi: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdyTm: // global
           I64[Hp - 16] = sat_sdyoC_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdyTj_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdyTj() //  [R1]
         { info_tbl: [(cdyTj,
                       label: block_cdyTj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyTp; else goto cdyTo;
       cdyTp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyTo: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoG_entry() //  [R1]
         { info_tbl: [(cdyTr,
                       label: sat_sdyoG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTr: // global
           _sdyoG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdyTs; else goto cdyTt;
       cdyTt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdyTv; else goto cdyTu;
       cdyTv: // global
           HpAlloc = 40;
           goto cdyTs;
       cdyTs: // global
           R1 = _sdyoG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdyTu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyoG::P64;
           _sdyop::P64 = P64[_sdyoG::P64 + 16];
           _sdyoq::P64 = P64[_sdyoG::P64 + 24];
           I64[Hp - 32] = lvl3_sdyor_info;
           P64[Hp - 16] = _sdyop::P64;
           I64[Hp - 8] = sat_sdyoF_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyoq::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec7_entry() //  [R2, R3]
         { info_tbl: [(cdyTw,
                       label: Data.Functor.Classes.$w$cliftReadsPrec7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdyTA; else goto cdyTz;
       cdyTA: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyTz: // global
           I64[Hp - 24] = sat_sdyoG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.470782387 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_entry() //  [R2,
                                                                 R6]
         { info_tbl: [(cdyTF,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTF: // global
           R3 = R6;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec7_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.471537101 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either3_bytes" {
     Data.Functor.Classes.$fRead1Either3_bytes:
         I8[] [82,105,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.47228897 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either2_closure" {
     Data.Functor.Classes.$fRead1Either2_closure:
         const Data.Functor.Classes.$fRead1Either2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either2_entry() //  [R1]
         { info_tbl: [(cdyTO,
                       label: Data.Functor.Classes.$fRead1Either2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdyTP; else goto cdyTQ;
       cdyTP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdyTQ: // global
           (_cdyTL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdyTL::I64 == 0) goto cdyTN; else goto cdyTM;
       cdyTN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdyTM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdyTL::I64;
           R2 = Data.Functor.Classes.$fRead1Either3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.473193289 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either1_closure" {
     Data.Functor.Classes.$fRead1Either1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.473823994 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either6_bytes" {
     Data.Functor.Classes.$fRead1Either6_bytes:
         I8[] [76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.474591032 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either5_closure" {
     Data.Functor.Classes.$fRead1Either5_closure:
         const Data.Functor.Classes.$fRead1Either5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either5_entry() //  [R1]
         { info_tbl: [(cdyTX,
                       label: Data.Functor.Classes.$fRead1Either5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyTX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdyTY; else goto cdyTZ;
       cdyTY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdyTZ: // global
           (_cdyTU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdyTU::I64 == 0) goto cdyTW; else goto cdyTV;
       cdyTW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdyTV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdyTU::I64;
           R2 = Data.Functor.Classes.$fRead1Either6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.475502422 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either4_closure" {
     Data.Functor.Classes.$fRead1Either4_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.477739614 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadPrec3_info;
         const 0;
 },
 sat_sdyoY_entry() //  [R1, R2]
         { info_tbl: [(cdyUt,
                       label: sat_sdyoY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyUt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyUx; else goto cdyUw;
       cdyUx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyUw: // global
           _sdyoR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sdyoR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoZ_entry() //  [R1, R2]
         { info_tbl: [(cdyUy,
                       label: sat_sdyoZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyUy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyUC; else goto cdyUB;
       cdyUC: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyUB: // global
           _sdyoM::P64 = P64[R1 + 7];
           _sdyoR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyoY_info;
           P64[Hp] = _sdyoR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyoM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyp6_entry() //  [R1, R2]
         { info_tbl: [(cdyUU,
                       label: sat_sdyp6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyUY; else goto cdyUX;
       cdyUY: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyUX: // global
           _sdyoR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdyoR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyp7_entry() //  [R1, R2]
         { info_tbl: [(cdyUZ,
                       label: sat_sdyp7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyUZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyV3; else goto cdyV2;
       cdyV3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdyV2: // global
           _sdyoN::P64 = P64[R1 + 7];
           _sdyoR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyp6_info;
           P64[Hp] = _sdyoR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyoN::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdypa_entry() //  [R1]
         { info_tbl: [(cdyV7,
                       label: sat_sdypa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyV7: // global
           _sdypa::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdyV8; else goto cdyV9;
       cdyV9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdyVb; else goto cdyVa;
       cdyVb: // global
           HpAlloc = 24;
           goto cdyV8;
       cdyV8: // global
           R1 = _sdypa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdyVa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdypa::P64;
           _sdyoN::P64 = P64[_sdypa::P64 + 16];
           _sdyoR::P64 = P64[_sdypa::P64 + 24];
           I64[Hp - 16] = sat_sdyp7_info;
           P64[Hp - 8] = _sdyoN::P64;
           P64[Hp] = _sdyoR::P64;
           I64[Sp - 24] = block_cdyV4_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either1_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdyV4() //  [R1]
         { info_tbl: [(cdyV4,
                       label: block_cdyV4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyV4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdyVe; else goto cdyVd;
       cdyVe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdyVd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdypb_entry() //  [R1, R2, R3]
         { info_tbl: [(cdyVf,
                       label: sat_sdypb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyVf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdyVg; else goto cdyVh;
       cdyVg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyVh: // global
           I64[Sp - 32] = block_cdyU9_info;
           _sdyoM::P64 = P64[R1 + 6];
           _sdyoN::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdyoM::P64;
           P64[Sp - 16] = _sdyoN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udyVs; else goto cdyUa;
       udyVs: // global
           call _cdyU9(R1) args: 0, res: 0, upd: 0;
       cdyUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyU9() //  [R1]
         { info_tbl: [(cdyU9,
                       label: block_cdyU9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyU9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdyVk; else goto cdyVj;
       cdyVk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyVj: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdyVm; else goto cdyVo;
       cdyVm: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdyVo: // global
           I64[Hp - 16] = sat_sdyoZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 8] = block_cdyUD_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either4_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdyUD() //  [R1]
         { info_tbl: [(cdyUD,
                       label: block_cdyUD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyUD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdyVr; else goto cdyVq;
       cdyVr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdyVq: // global
           I64[Hp - 40] = sat_sdypa_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdyVt,
                       label: Data.Functor.Classes.$w$cliftReadPrec3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyVt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdyVx; else goto cdyVw;
       cdyVx: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyVw: // global
           I64[Hp - 16] = sat_sdypb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyoO::P64 = R4;
           R4 = R5;
           R3 = _sdyoO::P64;
           R2 = Hp - 14;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.481825404 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either8_closure" {
     Data.Functor.Classes.$fRead1Either8_closure:
         const Data.Functor.Classes.$fRead1Either8_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either8_entry() //  [R2, R4, R6]
         { info_tbl: [(cdyVC,
                       label: Data.Functor.Classes.$fRead1Either8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyVC: // global
           R5 = P64[Sp];
           _sdype::P64 = R4;
           R4 = R6;
           R3 = _sdype::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.482969721 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdypo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdyVO,
                       label: sat_sdypo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyVO: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdyVR,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyVR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdyVV; else goto cdyVU;
       cdyVV: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyVU: // global
           I64[Hp - 16] = sat_sdypo_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.484684447 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec8_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec8_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec8_info;
         const 0;
 },
 sat_sdypt_entry() //  [R1, R2]
         { info_tbl: [(cdyW9,
                       label: sat_sdypt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyW9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyps_entry() //  [R1, R2]
         { info_tbl: [(cdyWh,
                       label: sat_sdyps_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdypu_entry() //  [R1]
         { info_tbl: [(cdyWk,
                       label: sat_sdypu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWk: // global
           _sdypu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdyWl; else goto cdyWm;
       cdyWm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdyWo; else goto cdyWn;
       cdyWo: // global
           HpAlloc = 32;
           goto cdyWl;
       cdyWl: // global
           R1 = _sdypu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdyWn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdypu::P64;
           _sdypp::P64 = P64[_sdypu::P64 + 16];
           _sdypq::P64 = P64[_sdypu::P64 + 24];
           _sdypr::P64 = P64[_sdypu::P64 + 32];
           I64[Hp - 24] = sat_sdypt_info;
           P64[Hp - 16] = _sdypq::P64;
           I64[Hp - 8] = sat_sdyps_info;
           P64[Hp] = _sdypp::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdypr::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec8_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyWp,
                       label: Data.Functor.Classes.$w$cliftReadsPrec8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdyWt; else goto cdyWs;
       cdyWt: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyWs: // global
           I64[Hp - 32] = sat_sdypu_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.486494453 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_entry() //  [R2,
                                                                  R4, R6]
         { info_tbl: [(cdyWy,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWy: // global
           _sdypx::P64 = R4;
           R4 = R6;
           R3 = _sdypx::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec8_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.487895689 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyWM,
                       label: Data.Functor.Classes.$fEq1Maybe_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdyWN; else goto cdyWO;
       cdyWN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyWO: // global
           I64[Sp - 24] = block_cdyWF_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udyXp; else goto cdyWG;
       udyXp: // global
           call _cdyWF(R1) args: 0, res: 0, upd: 0;
       cdyWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyWF() //  [R1]
         { info_tbl: [(cdyWF,
                       label: block_cdyWF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWF: // global
           _sdypC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdyWJ; else goto cdyWK;
       cdyWJ: // global
           I64[Sp + 16] = block_cdyWR_info;
           R1 = _sdypC::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udyXn; else goto cdyWT;
       udyXn: // global
           call _cdyWR(R1) args: 0, res: 0, upd: 0;
       cdyWT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdyWK: // global
           I64[Sp] = block_cdyX6_info;
           _sdypG::P64 = P64[R1 + 6];
           R1 = _sdypC::P64;
           P64[Sp + 16] = _sdypG::P64;
           if (R1 & 7 != 0) goto udyXo; else goto cdyX8;
       udyXo: // global
           call _cdyX6(R1) args: 0, res: 0, upd: 0;
       cdyX8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyWR() //  [R1]
         { info_tbl: [(cdyWR,
                       label: block_cdyWR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyWR: // global
           if (R1 & 7 == 1) goto cdyWZ; else goto udyXm;
       cdyWZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udyXm: // global
           Sp = Sp + 8;
           call _cdyXe() args: 0, res: 0, upd: 0;
     }
 },
 _cdyX6() //  [R1]
         { info_tbl: [(cdyX6,
                       label: block_cdyX6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyX6: // global
           if (R1 & 7 == 1) goto udyXl; else goto cdyXi;
       udyXl: // global
           Sp = Sp + 24;
           call _cdyXe() args: 0, res: 0, upd: 0;
       cdyXi: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdyXe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyXe: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.489845445 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_closure" {
     Data.Functor.Classes.$fEq1Maybe_closure:
         const Data.Functor.Classes.$fEq1Maybe_info;
 },
 Data.Functor.Classes.$fEq1Maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyXw,
                       label: Data.Functor.Classes.$fEq1Maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyXw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.491402316 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdyXK,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyXK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdyXL; else goto udyYv;
       cdyXL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udyYv: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdyXA() args: 0, res: 0, upd: 0;
     }
 },
 _cdyXA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyXA: // global
           I64[Sp - 8] = block_cdyXD_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyYA; else goto cdyXE;
       udyYA: // global
           call _cdyXD(R1) args: 0, res: 0, upd: 0;
       cdyXE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyXD() //  [R1]
         { info_tbl: [(cdyXD,
                       label: block_cdyXD_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyXD: // global
           _sdypL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdyXH; else goto cdyXI;
       cdyXH: // global
           I64[Sp + 24] = block_cdyXP_info;
           R1 = _sdypL::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udyYB; else goto cdyXR;
       udyYB: // global
           call _cdyXP(R1) args: 0, res: 0, upd: 0;
       cdyXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdyXI: // global
           I64[Sp] = block_cdyY4_info;
           _sdypQ::P64 = P64[R1 + 6];
           _sdypR::P64 = P64[R1 + 14];
           R1 = _sdypL::P64;
           P64[Sp + 16] = _sdypR::P64;
           P64[Sp + 24] = _sdypQ::P64;
           if (R1 & 7 != 0) goto udyYC; else goto cdyY6;
       udyYC: // global
           call _cdyY4(R1) args: 0, res: 0, upd: 0;
       cdyY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyXP() //  [R1]
         { info_tbl: [(cdyXP,
                       label: block_cdyXP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyXP: // global
           if (R1 & 7 == 1) goto cdyXX; else goto udyYz;
       cdyXX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udyYz: // global
           Sp = Sp + 8;
           call _cdyYn() args: 0, res: 0, upd: 0;
     }
 },
 _cdyY4() //  [R1]
         { info_tbl: [(cdyY4,
                       label: block_cdyY4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyY4: // global
           if (R1 & 7 == 1) goto udyYw; else goto cdyYh;
       udyYw: // global
           Sp = Sp + 32;
           call _cdyYn() args: 0, res: 0, upd: 0;
       cdyYh: // global
           I64[Sp] = block_cdyYf_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdypU::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdypU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyYf() //  [R1]
         { info_tbl: [(cdyYf,
                       label: block_cdyYf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyYf: // global
           if (R1 & 7 == 1) goto udyYx; else goto cdyYr;
       udyYx: // global
           Sp = Sp + 32;
           call _cdyYn() args: 0, res: 0, upd: 0;
       cdyYr: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdyXA() args: 0, res: 0, upd: 0;
     }
 },
 _cdyYn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyYn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.493693713 UTC

[section ""data" . Data.Functor.Classes.$fEq1[]_closure" {
     Data.Functor.Classes.$fEq1[]_closure:
         const Data.Functor.Classes.$fEq1[]_info;
 },
 Data.Functor.Classes.$fEq1[]_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyYM,
                       label: Data.Functor.Classes.$fEq1[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyYM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.494818893 UTC

[section ""data" . Data.Functor.Classes.$w$cliftEq_closure" {
     Data.Functor.Classes.$w$cliftEq_closure:
         const Data.Functor.Classes.$w$cliftEq_info;
 },
 Data.Functor.Classes.$w$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdyYZ,
                       label: Data.Functor.Classes.$w$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyYZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdyZ0; else goto cdyZ1;
       cdyZ0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyZ1: // global
           I64[Sp - 32] = block_cdyYT_info;
           _sdypX::P64 = R3;
           R3 = R5;
           _sdypW::P64 = R2;
           R2 = _sdypX::P64;
           R1 = _sdypW::P64;
           P64[Sp - 24] = _sdypW::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyYT() //  [R1]
         { info_tbl: [(cdyYT,
                       label: block_cdyYT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyYT: // global
           if (R1 & 7 == 1) goto cdyYW; else goto cdyYX;
       cdyYW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdyYX: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.497702976 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdyZf,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdyZj; else goto cdyZk;
       cdyZj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyZk: // global
           I64[Sp - 24] = block_cdyZc_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udyZs; else goto cdyZd;
       udyZs: // global
           call _cdyZc(R1) args: 0, res: 0, upd: 0;
       cdyZd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyZc() //  [R1]
         { info_tbl: [(cdyZc,
                       label: block_cdyZc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZc: // global
           I64[Sp - 8] = block_cdyZi_info;
           _sdyq6::P64 = P64[R1 + 7];
           _sdyq7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdyq7::P64;
           P64[Sp + 16] = _sdyq6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udyZr; else goto cdyZm;
       udyZr: // global
           call _cdyZi(R1) args: 0, res: 0, upd: 0;
       cdyZm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyZi() //  [R1]
         { info_tbl: [(cdyZi,
                       label: block_cdyZi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZi: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftEq_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.499131784 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyZx,
                       label: Data.Functor.Classes.$fEq1NonEmpty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.499943288 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Identity_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Identity_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdyZE,
                       label: Data.Functor.Classes.$fEq1Identity_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZE: // global
           _sdyqc::P64 = R3;
           R3 = R4;
           _sdyqb::P64 = R2;
           R2 = _sdyqc::P64;
           R1 = _sdyqb::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.500801994 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_closure" {
     Data.Functor.Classes.$fEq1Identity_closure:
         const Data.Functor.Classes.$fEq1Identity_info;
 },
 Data.Functor.Classes.$fEq1Identity_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyZL,
                       label: Data.Functor.Classes.$fEq1Identity_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Identity_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.501670391 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry() //  []
         { info_tbl: [(cdyZS,
                       label: Data.Functor.Classes.$fEq1Proxy_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZS: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.502490669 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_closure" {
     Data.Functor.Classes.$fEq1Proxy_closure:
         const Data.Functor.Classes.$fEq1Proxy_info;
 },
 Data.Functor.Classes.$fEq1Proxy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdyZZ,
                       label: Data.Functor.Classes.$fEq1Proxy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyZZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.503714776 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdz0d,
                       label: Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz0d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdz0e; else goto cdz0f;
       cdz0e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz0f: // global
           I64[Sp - 24] = block_cdz06_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udz0O; else goto cdz07;
       udz0O: // global
           call _cdz06(R1) args: 0, res: 0, upd: 0;
       cdz07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz06() //  [R1]
         { info_tbl: [(cdz06,
                       label: block_cdz06_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz06: // global
           _sdyqj::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdz0a; else goto cdz0b;
       cdz0a: // global
           I64[Sp + 16] = block_cdz0i_info;
           R1 = _sdyqj::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udz0M; else goto cdz0k;
       udz0M: // global
           call _cdz0i(R1) args: 0, res: 0, upd: 0;
       cdz0k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdz0b: // global
           I64[Sp] = block_cdz0x_info;
           _sdyqn::P64 = P64[R1 + 6];
           R1 = _sdyqj::P64;
           P64[Sp + 16] = _sdyqn::P64;
           if (R1 & 7 != 0) goto udz0N; else goto cdz0z;
       udz0N: // global
           call _cdz0x(R1) args: 0, res: 0, upd: 0;
       cdz0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz0i() //  [R1]
         { info_tbl: [(cdz0i,
                       label: block_cdz0i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz0i: // global
           if (R1 & 7 == 1) goto cdz0q; else goto cdz0u;
       cdz0q: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz0u: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdz0x() //  [R1]
         { info_tbl: [(cdz0x,
                       label: block_cdz0x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz0x: // global
           if (R1 & 7 == 1) goto cdz0F; else goto cdz0J;
       cdz0F: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz0J: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.505551632 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_closure" {
     Data.Functor.Classes.$fOrd1Maybe_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.506969667 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdz10,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz10: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz11; else goto udz1Q;
       cdz11: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udz1Q: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdz0Q() args: 0, res: 0, upd: 0;
     }
 },
 _cdz0Q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz0Q: // global
           I64[Sp - 8] = block_cdz0T_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udz1W; else goto cdz0U;
       udz1W: // global
           call _cdz0T(R1) args: 0, res: 0, upd: 0;
       cdz0U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz0T() //  [R1]
         { info_tbl: [(cdz0T,
                       label: block_cdz0T_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz0T: // global
           _sdyqs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdz0X; else goto cdz0Y;
       cdz0X: // global
           I64[Sp + 24] = block_cdz15_info;
           R1 = _sdyqs::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udz1X; else goto cdz17;
       udz1X: // global
           call _cdz15(R1) args: 0, res: 0, upd: 0;
       cdz17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdz0Y: // global
           I64[Sp] = block_cdz1k_info;
           _sdyqx::P64 = P64[R1 + 6];
           _sdyqy::P64 = P64[R1 + 14];
           R1 = _sdyqs::P64;
           P64[Sp + 16] = _sdyqy::P64;
           P64[Sp + 24] = _sdyqx::P64;
           if (R1 & 7 != 0) goto udz1Y; else goto cdz1m;
       udz1Y: // global
           call _cdz1k(R1) args: 0, res: 0, upd: 0;
       cdz1m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz15() //  [R1]
         { info_tbl: [(cdz15,
                       label: block_cdz15_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz15: // global
           if (R1 & 7 == 1) goto cdz1d; else goto udz1V;
       cdz1d: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udz1V: // global
           Sp = Sp + 8;
           call _cdz1D() args: 0, res: 0, upd: 0;
     }
 },
 _cdz1k() //  [R1]
         { info_tbl: [(cdz1k,
                       label: block_cdz1k_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz1k: // global
           if (R1 & 7 == 1) goto udz1R; else goto cdz1x;
       udz1R: // global
           Sp = Sp + 32;
           call _cdz1L() args: 0, res: 0, upd: 0;
       cdz1x: // global
           I64[Sp] = block_cdz1v_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdyqB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdyqB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz1v() //  [R1]
         { info_tbl: [(cdz1v,
                       label: block_cdz1v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz1v: // global
           _cdz1N::P64 = R1 & 7;
           if (_cdz1N::P64 < 3) goto udz1P; else goto udz1S;
       udz1P: // global
           if (_cdz1N::P64 < 2) goto udz1T; else goto cdz1H;
       udz1T: // global
           Sp = Sp + 32;
           call _cdz1D() args: 0, res: 0, upd: 0;
       cdz1H: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdz0Q() args: 0, res: 0, upd: 0;
       udz1S: // global
           Sp = Sp + 32;
           call _cdz1L() args: 0, res: 0, upd: 0;
     }
 },
 _cdz1D() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz1D: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdz1L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz1L: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.509093411 UTC

[section ""data" . Data.Functor.Classes.$fOrd1[]_closure" {
     Data.Functor.Classes.$fOrd1[]_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.510046172 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare1_closure" {
     Data.Functor.Classes.$w$cliftCompare1_closure:
         const Data.Functor.Classes.$w$cliftCompare1_info;
 },
 Data.Functor.Classes.$w$cliftCompare1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdz2g,
                       label: Data.Functor.Classes.$w$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz2g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz2h; else goto cdz2i;
       cdz2h: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz2i: // global
           I64[Sp - 32] = block_cdz29_info;
           _sdyqE::P64 = R3;
           R3 = R5;
           _sdyqD::P64 = R2;
           R2 = _sdyqE::P64;
           R1 = _sdyqD::P64;
           P64[Sp - 24] = _sdyqD::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz29() //  [R1]
         { info_tbl: [(cdz29,
                       label: block_cdz29_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz29: // global
           _cdz2f::P64 = R1 & 7;
           if (_cdz2f::P64 < 3) goto udz2s; else goto cdz2e;
       udz2s: // global
           if (_cdz2f::P64 < 2) goto cdz2c; else goto cdz2d;
       cdz2c: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz2d: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       cdz2e: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.511571175 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdz2A,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz2A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz2E; else goto cdz2F;
       cdz2E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz2F: // global
           I64[Sp - 24] = block_cdz2x_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udz2N; else goto cdz2y;
       udz2N: // global
           call _cdz2x(R1) args: 0, res: 0, upd: 0;
       cdz2y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz2x() //  [R1]
         { info_tbl: [(cdz2x,
                       label: block_cdz2x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz2x: // global
           I64[Sp - 8] = block_cdz2D_info;
           _sdyqN::P64 = P64[R1 + 7];
           _sdyqO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdyqO::P64;
           P64[Sp + 16] = _sdyqN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udz2M; else goto cdz2H;
       udz2M: // global
           call _cdz2D(R1) args: 0, res: 0, upd: 0;
       cdz2H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz2D() //  [R1]
         { info_tbl: [(cdz2D,
                       label: block_cdz2D_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz2D: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.512828965 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.513568065 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Identity_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdz2S,
                       label: Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz2S: // global
           _sdyqT::P64 = R3;
           R3 = R4;
           _sdyqS::P64 = R2;
           R2 = _sdyqT::P64;
           R1 = _sdyqS::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.514331972 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_closure" {
     Data.Functor.Classes.$fOrd1Identity_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.515061819 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_entry() //  []
         { info_tbl: [(cdz2Z,
                       label: Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz2Z: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.515807627 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_closure" {
     Data.Functor.Classes.$fOrd1Proxy_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.516535425 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadPrec_entry() //  [R3]
         { info_tbl: [(cdz36,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz36: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.517202157 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1NonEmpty4_bytes" {
     Data.Functor.Classes.$fRead1NonEmpty4_bytes:
         I8[] [58,124]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.518360824 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty3_closure" {
     Data.Functor.Classes.$fRead1NonEmpty3_closure:
         const Data.Functor.Classes.$fRead1NonEmpty3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty3_entry() //  [R1]
         { info_tbl: [(cdz3f,
                       label: Data.Functor.Classes.$fRead1NonEmpty3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdz3g; else goto cdz3h;
       cdz3g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz3h: // global
           (_cdz3c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdz3c::I64 == 0) goto cdz3e; else goto cdz3d;
       cdz3e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdz3d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdz3c::I64;
           R2 = Data.Functor.Classes.$fRead1NonEmpty4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.519265517 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty2_closure" {
     Data.Functor.Classes.$fRead1NonEmpty2_closure:
         const GHC.Types.I#_con_info;
         const 6;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.522044543 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec5_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec5_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec5_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3j: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sdyrn_entry() //  [R1, R2]
         { info_tbl: [(cdz4c,
                       label: go2_sdyrn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz4c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz4d; else goto cdz4e;
       cdz4d: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdz4e: // global
           I64[Sp - 32] = block_cdz45_info;
           _sdyrn::P64 = R1;
           _sdyra::P64 = P64[R1 + 7];
           _sdyrm::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdyra::P64;
           P64[Sp - 16] = _sdyrm::P64;
           P64[Sp - 8] = _sdyrn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udz4y; else goto cdz46;
       udz4y: // global
           call _cdz45(R1) args: 0, res: 0, upd: 0;
       cdz46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz45() //  [R1]
         { info_tbl: [(cdz45,
                       label: block_cdz45_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz45: // global
           if (R1 & 7 == 1) goto cdz49; else goto cdz4a;
       cdz49: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdz4a: // global
           I64[Sp] = block_cdz4k_info;
           _sdyrr::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdyrr::P64;
           if (R1 & 7 != 0) goto udz4x; else goto cdz4l;
       udz4x: // global
           call _cdz4k(R1) args: 0, res: 0, upd: 0;
       cdz4l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz4k() //  [R1]
         { info_tbl: [(cdz4k,
                       label: block_cdz4k_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz4k: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdz4w; else goto cdz4v;
       cdz4w: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdz4v: // global
           _sdyrt::P64 = P64[R1 + 7];
           _sdyru::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_2_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = GHC.Base.:|_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sdyrt::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = _sdyru::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sdyrd_entry() //  [R1, R2]
         { info_tbl: [(cdz4D,
                       label: go1_sdyrd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz4D: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdz4E; else goto udz4Y;
       cdz4E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udz4Y: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdz3G() args: 0, res: 0, upd: 0;
     }
 },
 _cdz3G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3G: // global
           I64[Sp - 24] = block_cdz3J_info;
           R1 = P64[Sp + 8];
           _sdyrd::P64 = P64[Sp];
           P64[Sp - 16] = P64[_sdyrd::P64 + 15];
           P64[Sp - 8] = P64[_sdyrd::P64 + 23];
           P64[Sp + 8] = P64[_sdyrd::P64 + 7];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udz50; else goto cdz3K;
       udz50: // global
           call _cdz3J(R1) args: 0, res: 0, upd: 0;
       cdz3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz3J() //  [R1]
         { info_tbl: [(cdz3J,
                       label: block_cdz3J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3J: // global
           if (R1 & 7 == 1) goto cdz4A; else goto cdz4B;
       cdz4A: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdz4B: // global
           I64[Sp] = block_cdz3P_info;
           _sdyrh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdyrh::P64;
           if (R1 & 7 != 0) goto udz51; else goto cdz3Q;
       udz51: // global
           call _cdz3P(R1) args: 0, res: 0, upd: 0;
       cdz3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz3P() //  [R1]
         { info_tbl: [(cdz3P,
                       label: block_cdz3P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3P: // global
           I64[Sp - 8] = block_cdz3U_info;
           R3 = Data.Functor.Classes.$fRead1NonEmpty3_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdz3U() //  [R1]
         { info_tbl: [(cdz3U,
                       label: block_cdz3U_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3U: // global
           _sdyrh::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdz4N; else goto cdz4P;
       cdz4N: // global
           P64[Sp + 40] = _sdyrh::P64;
           Sp = Sp + 32;
           call _cdz3G() args: 0, res: 0, upd: 0;
       cdz4P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdz4S; else goto cdz4R;
       cdz4S: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdz4R: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdyrh::P64;
           I64[Hp - 16] = go2_sdyrn_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           I64[Sp + 32] = block_cdz4O_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz4O() //  [R1]
         { info_tbl: [(cdz4O,
                       label: block_cdz4O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz4O: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_sdyrn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyr4_entry() //  [R1, R2]
         { info_tbl: [(cdz58,
                       label: go_sdyr4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz58: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz59; else goto cdz5a;
       cdz59: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdz5a: // global
           I64[Sp - 24] = block_cdz3s_info;
           _sdyr4::P64 = R1;
           _sdyr1::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyr1::P64;
           P64[Sp - 8] = _sdyr4::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udz5n; else goto cdz3t;
       udz5n: // global
           call _cdz3s(R1) args: 0, res: 0, upd: 0;
       cdz3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz3s() //  [R1]
         { info_tbl: [(cdz3s,
                       label: block_cdz3s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3s: // global
           if (R1 & 7 == 1) goto cdz55; else goto cdz56;
       cdz55: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz56: // global
           I64[Sp - 8] = block_cdz3y_info;
           _sdyr8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyr8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udz5m; else goto cdz3z;
       udz5m: // global
           call _cdz3y(R1) args: 0, res: 0, upd: 0;
       cdz3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz3y() //  [R1]
         { info_tbl: [(cdz3y,
                       label: block_cdz3y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz3y: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdz5h; else goto cdz5g;
       cdz5h: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdz5g: // global
           _sdyra::P64 = P64[R1 + 7];
           _sdyrb::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyrd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _sdyra::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 16] = block_cdz5d_info;
           R3 = _sdyrb::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdz5d() //  [R1]
         { info_tbl: [(cdz5d,
                       label: block_cdz5d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz5d: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyrd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyrE_entry() //  [R1, R2]
         { info_tbl: [(cdz5v,
                       label: sat_sdyrE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdz5w; else goto cdz5x;
       cdz5w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdz5x: // global
           I64[Sp - 16] = block_cdz5t_info;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           _sdyr4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdyr4::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz5t() //  [R1]
         { info_tbl: [(cdz5t,
                       label: block_cdz5t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz5t: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyr4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdz5D,
                       label: Data.Functor.Classes.$w$cliftReadsPrec5_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz5D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdz5H; else goto cdz5G;
       cdz5H: // global
           HpAlloc = 40;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec5_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdz5G: // global
           I64[Hp - 32] = go_sdyr4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdyrE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 31;
           _sdyrB::P64 = I64[(%MO_S_Gt_W64(R4,
                                           5) << 3) + GHC.Types.Bool_closure_tbl];
           R4 = R5;
           R3 = Hp - 15;
           R2 = _sdyrB::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.527410297 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdz5P,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz5P: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz5Q; else goto cdz5R;
       cdz5Q: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz5R: // global
           I64[Sp - 32] = block_cdz5M_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udz5V; else goto cdz5N;
       udz5V: // global
           call _cdz5M(R1) args: 0, res: 0, upd: 0;
       cdz5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz5M() //  [R1]
         { info_tbl: [(cdz5M,
                       label: block_cdz5M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz5M: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.52857092 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Proxy4_bytes" {
     Data.Functor.Classes.$fRead1Proxy4_bytes:
         I8[] [80,114,111,120,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.529317586 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy3_closure" {
     Data.Functor.Classes.$fRead1Proxy3_closure:
         const Data.Functor.Classes.$fRead1Proxy3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy3_entry() //  [R1]
         { info_tbl: [(cdz62,
                       label: Data.Functor.Classes.$fRead1Proxy3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz62: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdz63; else goto cdz64;
       cdz63: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz64: // global
           (_cdz5Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdz5Z::I64 == 0) goto cdz61; else goto cdz60;
       cdz61: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdz60: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdz5Z::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.530236104 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_lexeme_closure" {
     Data.Functor.Classes.$fRead1Proxy_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.531191263 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy2_closure" {
     Data.Functor.Classes.$fRead1Proxy2_closure:
         const Data.Functor.Classes.$fRead1Proxy2_info;
         const 0;
 },
 sat_sdyrO_entry() //  [R1]
         { info_tbl: [(cdz6e,
                       label: sat_sdyrO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6e: // global
           R2 = Data.Proxy.Proxy_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Proxy2_entry() //  [R2, R3]
         { info_tbl: [(cdz6k,
                       label: Data.Functor.Classes.$fRead1Proxy2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6k: // global
           _sdyrM::P64 = R3;
           _sdyrL::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdz6l; else goto cdz6m;
       cdz6m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdz6o; else goto cdz6n;
       cdz6o: // global
           HpAlloc = 16;
           goto cdz6l;
       cdz6l: // global
           R3 = _sdyrM::P64;
           R2 = _sdyrL::P64;
           R1 = Data.Functor.Classes.$fRead1Proxy2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz6n: // global
           I64[Hp - 8] = sat_sdyrO_info;
           P64[Hp] = _sdyrM::P64;
           I64[Sp - 8] = block_cdz6h_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Proxy_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdz6h() //  [R1]
         { info_tbl: [(cdz6h,
                       label: block_cdz6h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdz6r; else goto cdz6q;
       cdz6r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdz6q: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.532651515 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy1_closure" {
     Data.Functor.Classes.$fRead1Proxy1_closure:
         const Data.Functor.Classes.$fRead1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy1_entry() //  [R2, R3]
         { info_tbl: [(cdz6w,
                       label: Data.Functor.Classes.$fRead1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6w: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.533811631 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy5_closure" {
     Data.Functor.Classes.$fRead1Proxy5_closure:
         const Data.Functor.Classes.$fRead1Proxy5_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy5_entry() //  [R4, R5]
         { info_tbl: [(cdz6D,
                       label: Data.Functor.Classes.$fRead1Proxy5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6D: // global
           R3 = R5;
           R2 = R4;
           call Data.Functor.Classes.$fRead1Proxy1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.534670973 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_entry() //  [R3]
         { info_tbl: [(cdz6K,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6K: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.535380792 UTC

[section ""cstring" . Data.Functor.Classes.$fShow1NonEmpty1_bytes" {
     Data.Functor.Classes.$fShow1NonEmpty1_bytes:
         I8[] [32,58,124,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.537465613 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec1_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec1_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec1_info;
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6O: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 f_sdys1_entry() //  [R1]
         { info_tbl: [(cdz6W,
                       label: f_sdys1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz6W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdz6X; else goto cdz6Y;
       cdz6X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz6Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdys6_entry() //  [R1]
         { info_tbl: [(cdz7d,
                       label: sat_sdys6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz7d: // global
           _sdys6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdz7e; else goto cdz7f;
       cdz7f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdz7h; else goto cdz7g;
       cdz7h: // global
           HpAlloc = 32;
           goto cdz7e;
       cdz7e: // global
           R1 = _sdys6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz7g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdys6::P64;
           _sdys2::P64 = P64[_sdys6::P64 + 16];
           _sdys4::P64 = P64[_sdys6::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys4::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdys7_entry() //  [R1, R2]
         { info_tbl: [(cdz7i,
                       label: sat_sdys7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz7i: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdz7m; else goto cdz7l;
       cdz7m: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdz7l: // global
           _sdys1::P64 = P64[R1 + 7];
           _sdys2::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdys6_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdys1::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdysa_entry() //  [R1]
         { info_tbl: [(cdz7G,
                       label: sat_sdysa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz7G: // global
           _sdysa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdz7H; else goto cdz7I;
       cdz7I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdz7K; else goto cdz7J;
       cdz7K: // global
           HpAlloc = 24;
           goto cdz7H;
       cdz7H: // global
           R1 = _sdysa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz7J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysa::P64;
           _sdys2::P64 = P64[_sdysa::P64 + 16];
           _sdys8::P64 = P64[_sdysa::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdys8::P64;
           R2 = Hp - 14;
           R1 = _sdys2::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysb_entry() //  [R1]
         { info_tbl: [(cdz7L,
                       label: sat_sdysb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz7L: // global
           _sdysb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdz7M; else goto cdz7N;
       cdz7N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdz7P; else goto cdz7O;
       cdz7P: // global
           HpAlloc = 32;
           goto cdz7M;
       cdz7M: // global
           R1 = _sdysb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz7O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysb::P64;
           _sdys2::P64 = P64[_sdysb::P64 + 16];
           _sdys8::P64 = P64[_sdysb::P64 + 24];
           I64[Hp - 24] = sat_sdysa_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys8::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysc_entry() //  [R1]
         { info_tbl: [(cdz7Q,
                       label: sat_sdysc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz7Q: // global
           _sdysc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdz7R; else goto cdz7S;
       cdz7S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdz7U; else goto cdz7T;
       cdz7U: // global
           HpAlloc = 32;
           goto cdz7R;
       cdz7R: // global
           R1 = _sdysc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdz7T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysc::P64;
           _sdys1::P64 = P64[_sdysc::P64 + 16];
           _sdys2::P64 = P64[_sdysc::P64 + 24];
           _sdys8::P64 = P64[_sdysc::P64 + 32];
           I64[Hp - 24] = sat_sdysb_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys8::P64;
           R2 = Hp - 24;
           R1 = _sdys1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysd_entry() //  [R1, R2]
         { info_tbl: [(cdz7W,
                       label: sat_sdysd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz7W: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdz80; else goto cdz7Z;
       cdz80: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdz7Z: // global
           _sdys1::P64 = P64[R1 + 7];
           _sdys2::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdysc_info;
           P64[Hp - 40] = _sdys1::P64;
           P64[Hp - 32] = _sdys2::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cdz84,
                       label: Data.Functor.Classes.$w$cliftShowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz84: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdz88; else goto cdz87;
       cdz88: // global
           HpAlloc = 88;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdz87: // global
           I64[Hp - 80] = f_sdys1_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdz6S::P64 = Hp - 80;
           _cdz6Z::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 5)) goto cdz82; else goto cdz83;
       cdz82: // global
           I64[Hp - 16] = sat_sdys7_info;
           P64[Hp - 8] = _cdz6S::P64;
           P64[Hp] = _cdz6Z::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz83: // global
           I64[Hp - 16] = sat_sdysd_info;
           P64[Hp - 8] = _cdz6S::P64;
           P64[Hp] = _cdz6Z::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.541545386 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdz8g,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdz8k; else goto cdz8l;
       cdz8k: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz8l: // global
           I64[Sp - 32] = block_cdz8d_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udz8t; else goto cdz8e;
       udz8t: // global
           call _cdz8d(R1) args: 0, res: 0, upd: 0;
       cdz8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz8d() //  [R1]
         { info_tbl: [(cdz8d,
                       label: block_cdz8d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8d: // global
           I64[Sp] = block_cdz8j_info;
           _sdysj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sdysj::I64;
           if (R1 & 7 != 0) goto udz8s; else goto cdz8n;
       udz8s: // global
           call _cdz8j(R1) args: 0, res: 0, upd: 0;
       cdz8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz8j() //  [R1]
         { info_tbl: [(cdz8j,
                       label: block_cdz8j_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8j: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.54308821 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy2_closure" {
     Data.Functor.Classes.$fShow1Proxy2_closure:
         const Data.Functor.Classes.$fShow1Proxy2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy2_entry() //  [R2]
         { info_tbl: [(cdz8y,
                       label: Data.Functor.Classes.$fShow1Proxy2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8y: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.544003859 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_entry() //  [R6]
         { info_tbl: [(cdz8F,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8F: // global
           R2 = R6;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.545276153 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdz8P,
                       label: Data.Functor.Classes.$fEq2(,)_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8P: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdz8T; else goto cdz8U;
       cdz8T: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz8U: // global
           I64[Sp - 32] = block_cdz8M_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udz9e; else goto cdz8N;
       udz9e: // global
           call _cdz8M(R1) args: 0, res: 0, upd: 0;
       cdz8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz8M() //  [R1]
         { info_tbl: [(cdz8M,
                       label: block_cdz8M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8M: // global
           I64[Sp - 8] = block_cdz8S_info;
           _sdysw::P64 = P64[R1 + 7];
           _sdysx::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdysx::P64;
           P64[Sp + 24] = _sdysw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udz9d; else goto cdz8W;
       udz9d: // global
           call _cdz8S(R1) args: 0, res: 0, upd: 0;
       cdz8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz8S() //  [R1]
         { info_tbl: [(cdz8S,
                       label: block_cdz8S_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz8S: // global
           I64[Sp] = block_cdz90_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdysA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdysA::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz90() //  [R1]
         { info_tbl: [(cdz90,
                       label: block_cdz90_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz90: // global
           if (R1 & 7 == 1) goto cdz97; else goto cdz9b;
       cdz97: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz9b: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.548666341 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_closure" {
     Data.Functor.Classes.$fEq2(,)_closure:
         const Data.Functor.Classes.$fEq2(,)_info;
 },
 Data.Functor.Classes.$fEq2(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdz9j,
                       label: Data.Functor.Classes.$fEq2(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz9j: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.549921711 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1(,)_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1(,)_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1(,)_$cliftEq_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdz9t,
                       label: Data.Functor.Classes.$fEq1(,)_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz9t: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdz9x; else goto cdz9y;
       cdz9x: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1(,)_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz9y: // global
           I64[Sp - 32] = block_cdz9q_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udz9S; else goto cdz9r;
       udz9S: // global
           call _cdz9q(R1) args: 0, res: 0, upd: 0;
       cdz9r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz9q() //  [R1]
         { info_tbl: [(cdz9q,
                       label: block_cdz9q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz9q: // global
           I64[Sp - 8] = block_cdz9w_info;
           _sdysH::P64 = P64[R1 + 7];
           _sdysI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdysI::P64;
           P64[Sp + 24] = _sdysH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udz9R; else goto cdz9A;
       udz9R: // global
           call _cdz9w(R1) args: 0, res: 0, upd: 0;
       cdz9A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdz9w() //  [R1]
         { info_tbl: [(cdz9w,
                       label: block_cdz9w_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz9w: // global
           I64[Sp] = block_cdz9E_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdz9E() //  [R1]
         { info_tbl: [(cdz9E,
                       label: block_cdz9E_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz9E: // global
           if (R1 & 7 == 1) goto cdz9L; else goto cdz9P;
       cdz9L: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdz9P: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.551606454 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_closure" {
     Data.Functor.Classes.$fEq1(,)_closure:
         const Data.Functor.Classes.$fEq1(,)_info;
 },
 Data.Functor.Classes.$fEq1(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdz9X,
                       label: Data.Functor.Classes.$fEq1(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz9X: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1(,)_$cliftEq_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.552971859 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Either_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Either_$cliftEq2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdzab,
                       label: Data.Functor.Classes.$fEq2Either_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzab: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzac; else goto cdzad;
       cdzac: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2Either_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzad: // global
           I64[Sp - 32] = block_cdza4_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzaO; else goto cdza5;
       udzaO: // global
           call _cdza4(R1) args: 0, res: 0, upd: 0;
       cdza5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdza4() //  [R1]
         { info_tbl: [(cdza4,
                       label: block_cdza4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdza4: // global
           _sdysQ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdza8; else goto cdza9;
       cdza8: // global
           I64[Sp] = block_cdzag_info;
           _sdysS::P64 = P64[R1 + 7];
           R1 = _sdysQ::P64;
           P64[Sp + 24] = _sdysS::P64;
           if (R1 & 7 != 0) goto udzaM; else goto cdzai;
       udzaM: // global
           call _cdzag(R1) args: 0, res: 0, upd: 0;
       cdzai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdza9: // global
           I64[Sp + 8] = block_cdzav_info;
           _sdysW::P64 = P64[R1 + 6];
           R1 = _sdysQ::P64;
           P64[Sp + 24] = _sdysW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udzaN; else goto cdzax;
       udzaN: // global
           call _cdzav(R1) args: 0, res: 0, upd: 0;
       cdzax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzag() //  [R1]
         { info_tbl: [(cdzag,
                       label: block_cdzag_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzag: // global
           if (R1 & 7 == 1) goto cdzao; else goto udzaL;
       cdzao: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       udzaL: // global
           Sp = Sp + 32;
           call _cdzaD() args: 0, res: 0, upd: 0;
     }
 },
 _cdzav() //  [R1]
         { info_tbl: [(cdzav,
                       label: block_cdzav_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzav: // global
           if (R1 & 7 == 1) goto udzaK; else goto cdzaH;
       udzaK: // global
           Sp = Sp + 24;
           call _cdzaD() args: 0, res: 0, upd: 0;
       cdzaH: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdzaD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzaD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.55515404 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_closure" {
     Data.Functor.Classes.$fEq2Either_closure:
         const Data.Functor.Classes.$fEq2Either_info;
 },
 Data.Functor.Classes.$fEq2Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzaV,
                       label: Data.Functor.Classes.$fEq2Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzaV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Either_$cliftEq2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.556509793 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Either_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Either_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Either_$cliftEq_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdzb9,
                       label: Data.Functor.Classes.$fEq1Either_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzb9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzba; else goto cdzbb;
       cdzba: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Either_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzbb: // global
           I64[Sp - 32] = block_cdzb2_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzbM; else goto cdzb3;
       udzbM: // global
           call _cdzb2(R1) args: 0, res: 0, upd: 0;
       cdzb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzb2() //  [R1]
         { info_tbl: [(cdzb2,
                       label: block_cdzb2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzb2: // global
           _sdyt3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdzb6; else goto cdzb7;
       cdzb6: // global
           I64[Sp] = block_cdzbe_info;
           _sdyt5::P64 = P64[R1 + 7];
           R1 = _sdyt3::P64;
           P64[Sp + 24] = _sdyt5::P64;
           if (R1 & 7 != 0) goto udzbK; else goto cdzbg;
       udzbK: // global
           call _cdzbe(R1) args: 0, res: 0, upd: 0;
       cdzbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdzb7: // global
           I64[Sp + 8] = block_cdzbt_info;
           _sdyt9::P64 = P64[R1 + 6];
           R1 = _sdyt3::P64;
           P64[Sp + 24] = _sdyt9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udzbL; else goto cdzbv;
       udzbL: // global
           call _cdzbt(R1) args: 0, res: 0, upd: 0;
       cdzbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzbe() //  [R1]
         { info_tbl: [(cdzbe,
                       label: block_cdzbe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzbe: // global
           if (R1 & 7 == 1) goto cdzbm; else goto udzbJ;
       cdzbm: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
       udzbJ: // global
           Sp = Sp + 32;
           call _cdzbB() args: 0, res: 0, upd: 0;
     }
 },
 _cdzbt() //  [R1]
         { info_tbl: [(cdzbt,
                       label: block_cdzbt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzbt: // global
           if (R1 & 7 == 1) goto udzbI; else goto cdzbF;
       udzbI: // global
           Sp = Sp + 24;
           call _cdzbB() args: 0, res: 0, upd: 0;
       cdzbF: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdzbB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzbB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.55840349 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_closure" {
     Data.Functor.Classes.$fEq1Either_closure:
         const Data.Functor.Classes.$fEq1Either_info;
 },
 Data.Functor.Classes.$fEq1Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzbT,
                       label: Data.Functor.Classes.$fEq1Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzbT: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Either_$cliftEq_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.559286217 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Const_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Const_$cliftEq2_entry() //  [R2, R4, R5]
         { info_tbl: [(cdzc0,
                       label: Data.Functor.Classes.$fEq2Const_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzc0: // global
           R3 = R5;
           _sdytd::P64 = R2;
           R2 = R4;
           R1 = _sdytd::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.560179646 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_closure" {
     Data.Functor.Classes.$fEq2Const_closure:
         const Data.Functor.Classes.$fEq2Const_info;
 },
 Data.Functor.Classes.$fEq2Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzc7,
                       label: Data.Functor.Classes.$fEq2Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzc7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Const_$cliftEq2_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.561114957 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Const_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Const_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Const_$cliftEq_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdzce,
                       label: Data.Functor.Classes.$fEq1Const_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzce: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzcf; else goto cdzcg;
       cdzcf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Const_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzcg: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.5621621 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_closure" {
     Data.Functor.Classes.$fEq1Const_closure:
         const Data.Functor.Classes.$fEq1Const_info;
 },
 Data.Functor.Classes.$fEq1Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzcl,
                       label: Data.Functor.Classes.$fEq1Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzcl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Const_$cliftEq_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.563391141 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdzcv,
                       label: Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzcv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzcz; else goto cdzcA;
       cdzcz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzcA: // global
           I64[Sp - 32] = block_cdzcs_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzcZ; else goto cdzct;
       udzcZ: // global
           call _cdzcs(R1) args: 0, res: 0, upd: 0;
       cdzct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzcs() //  [R1]
         { info_tbl: [(cdzcs,
                       label: block_cdzcs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzcs: // global
           I64[Sp - 8] = block_cdzcy_info;
           _sdytq::P64 = P64[R1 + 7];
           _sdytr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdytr::P64;
           P64[Sp + 24] = _sdytq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzcY; else goto cdzcC;
       udzcY: // global
           call _cdzcy(R1) args: 0, res: 0, upd: 0;
       cdzcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzcy() //  [R1]
         { info_tbl: [(cdzcy,
                       label: block_cdzcy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzcy: // global
           I64[Sp] = block_cdzcG_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdytu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdytu::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzcG() //  [R1]
         { info_tbl: [(cdzcG,
                       label: block_cdzcG_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzcG: // global
           _cdzcW::P64 = R1 & 7;
           if (_cdzcW::P64 < 3) goto udzcX; else goto cdzcV;
       udzcX: // global
           if (_cdzcW::P64 < 2) goto cdzcN; else goto cdzcR;
       cdzcN: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzcR: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzcV: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.565018693 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_closure" {
     Data.Functor.Classes.$fOrd2(,)_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.566186871 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare_closure" {
     Data.Functor.Classes.$w$cliftCompare_closure:
         const Data.Functor.Classes.$w$cliftCompare_info;
 },
 Data.Functor.Classes.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdzdb,
                       label: Data.Functor.Classes.$w$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzdb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdzdc; else goto cdzdd;
       cdzdc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdzdd: // global
           I64[Sp - 24] = block_cdzd4_info;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = R4;
           P64[Sp - 32] = R6;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdzd4() //  [R1]
         { info_tbl: [(cdzd4,
                       label: block_cdzd4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzd4: // global
           _cdzda::P64 = R1 & 7;
           if (_cdzda::P64 < 3) goto udzdn; else goto cdzd9;
       udzdn: // global
           if (_cdzda::P64 < 2) goto cdzd7; else goto cdzd8;
       cdzd7: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzd8: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzd9: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.567746839 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdzdv,
                       label: Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzdv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzdz; else goto cdzdA;
       cdzdz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzdA: // global
           I64[Sp - 32] = block_cdzds_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzdI; else goto cdzdt;
       udzdI: // global
           call _cdzds(R1) args: 0, res: 0, upd: 0;
       cdzdt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzds() //  [R1]
         { info_tbl: [(cdzds,
                       label: block_cdzds_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzds: // global
           I64[Sp - 8] = block_cdzdy_info;
           _sdytI::P64 = P64[R1 + 7];
           _sdytJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdytJ::P64;
           P64[Sp + 24] = _sdytI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzdH; else goto cdzdC;
       udzdH: // global
           call _cdzdy(R1) args: 0, res: 0, upd: 0;
       cdzdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzdy() //  [R1]
         { info_tbl: [(cdzdy,
                       label: block_cdzdy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzdy: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.569527953 UTC

[section ""data" . Data.Functor.Classes.$w$cp1Ord1_closure" {
     Data.Functor.Classes.$w$cp1Ord1_closure:
         const Data.Functor.Classes.$w$cp1Ord1_info;
 },
 Data.Functor.Classes.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzdP,
                       label: Data.Functor.Classes.$w$cp1Ord1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzdP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdzdQ; else goto cdzdR;
       cdzdQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cp1Ord1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdzdR: // global
           I64[Sp - 40] = block_cdzdN_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzdN() //  [R1]
         { info_tbl: [(cdzdN,
                       label: block_cdzdN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzdN: // global
           I64[Sp] = block_cdzdU_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdzdU() //  [R1]
         { info_tbl: [(cdzdU,
                       label: block_cdzdU_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzdU: // global
           if (R1 & 7 == 1) goto cdze1; else goto cdze5;
       cdze1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdze5: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.571156287 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)1_closure" {
     Data.Functor.Classes.$fOrd1(,)1_closure:
         const Data.Functor.Classes.$fOrd1(,)1_info;
 },
 Data.Functor.Classes.$fOrd1(,)1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzee,
                       label: Data.Functor.Classes.$fOrd1(,)1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzee: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzei; else goto cdzej;
       cdzei: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzej: // global
           I64[Sp - 32] = block_cdzeb_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzer; else goto cdzec;
       udzer: // global
           call _cdzeb(R1) args: 0, res: 0, upd: 0;
       cdzec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzeb() //  [R1]
         { info_tbl: [(cdzeb,
                       label: block_cdzeb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzeb: // global
           I64[Sp - 8] = block_cdzeh_info;
           _sdyu0::P64 = P64[R1 + 7];
           _sdyu1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdyu1::P64;
           P64[Sp + 24] = _sdyu0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzeq; else goto cdzel;
       udzeq: // global
           call _cdzeh(R1) args: 0, res: 0, upd: 0;
       cdzel: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzeh() //  [R1]
         { info_tbl: [(cdzeh,
                       label: block_cdzeh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzeh: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.572924242 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_closure" {
     Data.Functor.Classes.$fOrd1(,)_closure:
         const Data.Functor.Classes.$fOrd1(,)_info;
 },
 sat_sdyu7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdzeB,
                       label: sat_sdyu7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzeB: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyu6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdzeJ,
                       label: sat_sdyu6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzeJ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1(,)_entry() //  [R2]
         { info_tbl: [(cdzeN,
                       label: Data.Functor.Classes.$fOrd1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzeN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzeR; else goto cdzeQ;
       cdzeR: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzeQ: // global
           I64[Hp - 48] = sat_sdyu7_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyu6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.574766965 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Either_$cliftCompare2_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdzf3,
                       label: Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzf3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzf4; else goto cdzf5;
       cdzf4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzf5: // global
           I64[Sp - 32] = block_cdzeW_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzfE; else goto cdzeX;
       udzfE: // global
           call _cdzeW(R1) args: 0, res: 0, upd: 0;
       cdzeX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzeW() //  [R1]
         { info_tbl: [(cdzeW,
                       label: block_cdzeW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzeW: // global
           _sdyub::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdzf0; else goto cdzf1;
       cdzf0: // global
           I64[Sp] = block_cdzf8_info;
           _sdyud::P64 = P64[R1 + 7];
           R1 = _sdyub::P64;
           P64[Sp + 24] = _sdyud::P64;
           if (R1 & 7 != 0) goto udzfC; else goto cdzfa;
       udzfC: // global
           call _cdzf8(R1) args: 0, res: 0, upd: 0;
       cdzfa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdzf1: // global
           I64[Sp + 8] = block_cdzfn_info;
           _sdyuh::P64 = P64[R1 + 6];
           R1 = _sdyub::P64;
           P64[Sp + 24] = _sdyuh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udzfD; else goto cdzfp;
       udzfD: // global
           call _cdzfn(R1) args: 0, res: 0, upd: 0;
       cdzfp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzf8() //  [R1]
         { info_tbl: [(cdzf8,
                       label: block_cdzf8_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzf8: // global
           if (R1 & 7 == 1) goto cdzfg; else goto cdzfk;
       cdzfg: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzfk: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdzfn() //  [R1]
         { info_tbl: [(cdzfn,
                       label: block_cdzfn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzfn: // global
           if (R1 & 7 == 1) goto cdzfv; else goto cdzfz;
       cdzfv: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzfz: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.576518749 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_closure" {
     Data.Functor.Classes.$fOrd2Either_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.577747629 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Either_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdzfQ,
                       label: Data.Functor.Classes.$fOrd1Either_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzfQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzfR; else goto cdzfS;
       cdzfR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzfS: // global
           I64[Sp - 32] = block_cdzfJ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzgr; else goto cdzfK;
       udzgr: // global
           call _cdzfJ(R1) args: 0, res: 0, upd: 0;
       cdzfK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzfJ() //  [R1]
         { info_tbl: [(cdzfJ,
                       label: block_cdzfJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzfJ: // global
           _sdyuo::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdzfN; else goto cdzfO;
       cdzfN: // global
           I64[Sp] = block_cdzfV_info;
           _sdyuq::P64 = P64[R1 + 7];
           R1 = _sdyuo::P64;
           P64[Sp + 24] = _sdyuq::P64;
           if (R1 & 7 != 0) goto udzgp; else goto cdzfX;
       udzgp: // global
           call _cdzfV(R1) args: 0, res: 0, upd: 0;
       cdzfX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdzfO: // global
           I64[Sp + 8] = block_cdzga_info;
           _sdyuu::P64 = P64[R1 + 6];
           R1 = _sdyuo::P64;
           P64[Sp + 24] = _sdyuu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udzgq; else goto cdzgc;
       udzgq: // global
           call _cdzga(R1) args: 0, res: 0, upd: 0;
       cdzgc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzfV() //  [R1]
         { info_tbl: [(cdzfV,
                       label: block_cdzfV_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzfV: // global
           if (R1 & 7 == 1) goto cdzg3; else goto cdzg7;
       cdzg3: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
       cdzg7: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdzga() //  [R1]
         { info_tbl: [(cdzga,
                       label: block_cdzga_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzga: // global
           if (R1 & 7 == 1) goto cdzgi; else goto cdzgm;
       cdzgi: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzgm: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.580190404 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either1_closure" {
     Data.Functor.Classes.$fOrd1Either1_closure:
         const Data.Functor.Classes.$fOrd1Either1_info;
 },
 Data.Functor.Classes.$fOrd1Either1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzgD,
                       label: Data.Functor.Classes.$fOrd1Either1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzgD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzgE; else goto cdzgF;
       cdzgE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzgF: // global
           I64[Sp - 32] = block_cdzgw_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzhl; else goto cdzgx;
       udzhl: // global
           call _cdzgw(R1) args: 0, res: 0, upd: 0;
       cdzgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzgw() //  [R1]
         { info_tbl: [(cdzgw,
                       label: block_cdzgw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzgw: // global
           _sdyuB::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdzgA; else goto cdzgB;
       cdzgA: // global
           I64[Sp] = block_cdzgI_info;
           _sdyuD::P64 = P64[R1 + 7];
           R1 = _sdyuB::P64;
           P64[Sp + 24] = _sdyuD::P64;
           if (R1 & 7 != 0) goto udzhj; else goto cdzgK;
       udzhj: // global
           call _cdzgI(R1) args: 0, res: 0, upd: 0;
       cdzgK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdzgB: // global
           I64[Sp + 8] = block_cdzh2_info;
           _sdyuI::P64 = P64[R1 + 6];
           R1 = _sdyuB::P64;
           P64[Sp + 24] = _sdyuI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udzhk; else goto cdzh4;
       udzhk: // global
           call _cdzh2(R1) args: 0, res: 0, upd: 0;
       cdzh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzgI() //  [R1]
         { info_tbl: [(cdzgI,
                       label: block_cdzgI_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzgI: // global
           if (R1 & 7 == 1) goto cdzgR; else goto udzhi;
       cdzgR: // global
           _sdyuy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdzgO_info;
           R2 = _sdyuy::P64;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       udzhi: // global
           Sp = Sp + 32;
           call _cdzha() args: 0, res: 0, upd: 0;
     }
 },
 _cdzgO() //  [R1]
         { info_tbl: [(cdzgO,
                       label: block_cdzgO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzgO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sdyuF::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sdyuF::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdzh2() //  [R1]
         { info_tbl: [(cdzh2,
                       label: block_cdzh2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzh2: // global
           if (R1 & 7 == 1) goto udzhh; else goto cdzhe;
       udzhh: // global
           Sp = Sp + 24;
           call _cdzha() args: 0, res: 0, upd: 0;
       cdzhe: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdzha() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzha: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.582596623 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_closure" {
     Data.Functor.Classes.$fOrd1Either_closure:
         const Data.Functor.Classes.$fOrd1Either_info;
 },
 sat_sdyuO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdzhx,
                       label: sat_sdyuO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzhx: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyuN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdzhF,
                       label: sat_sdyuN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzhF: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Either_entry() //  [R2]
         { info_tbl: [(cdzhJ,
                       label: Data.Functor.Classes.$fOrd1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzhJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzhN; else goto cdzhM;
       cdzhN: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzhM: // global
           I64[Hp - 48] = sat_sdyuO_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyuN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.584011149 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Const_$cliftCompare2_entry() //  [R2,
                                                              R4, R5]
         { info_tbl: [(cdzhS,
                       label: Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzhS: // global
           R3 = R5;
           _sdyuP::P64 = R2;
           R2 = R4;
           R1 = _sdyuP::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.58480267 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_closure" {
     Data.Functor.Classes.$fOrd2Const_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.585628781 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const1_closure" {
     Data.Functor.Classes.$fOrd1Const1_closure:
         const Data.Functor.Classes.$fOrd1Const1_info;
 },
 Data.Functor.Classes.$fOrd1Const1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzi1,
                       label: Data.Functor.Classes.$fOrd1Const1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzi1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzi2; else goto cdzi3;
       cdzi2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzi3: // global
           I64[Sp - 24] = block_cdzhZ_info;
           R2 = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzhZ() //  [R1]
         { info_tbl: [(cdzhZ,
                       label: block_cdzhZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzhZ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.587084984 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const_closure" {
     Data.Functor.Classes.$fOrd1Const_closure:
         const Data.Functor.Classes.$fOrd1Const_info;
 },
 sat_sdyv3_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdzig,
                       label: sat_sdyv3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzig: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzih; else goto cdzii;
       cdzih: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzii: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdyuZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdzio,
                       label: sat_sdyuZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzio: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Const1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Const_entry() //  [R2]
         { info_tbl: [(cdzis,
                       label: Data.Functor.Classes.$fOrd1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzis: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdziw; else goto cdziv;
       cdziw: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdziv: // global
           I64[Hp - 48] = sat_sdyv3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyuZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.588460332 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1(,)5_bytes" {
     Data.Functor.Classes.$fRead1(,)5_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.589296186 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)4_closure" {
     Data.Functor.Classes.$fRead1(,)4_closure:
         const Data.Functor.Classes.$fRead1(,)4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)4_entry() //  [R1]
         { info_tbl: [(cdziD,
                       label: Data.Functor.Classes.$fRead1(,)4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdziD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdziE; else goto cdziF;
       cdziE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdziF: // global
           (_cdziA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdziA::I64 == 0) goto cdziC; else goto cdziB;
       cdziC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdziB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdziA::I64;
           R2 = Data.Functor.Classes.$fRead1(,)5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.590294185 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)3_closure" {
     Data.Functor.Classes.$fRead1(,)3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Functor.Classes.$fRead1(,)4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.592420768 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadPrec2_info;
         const 0;
 },
 sat_sdyvf_entry() //  [R1, R2]
         { info_tbl: [(cdzj5,
                       label: sat_sdyvf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzj5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzj9; else goto cdzj8;
       cdzj9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzj8: // global
           _sdyva::P64 = P64[R1 + 7];
           _sdyvb::P64 = P64[R1 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sdyvb::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sdyva::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvg_entry() //  [R1, R2]
         { info_tbl: [(cdzja,
                       label: sat_sdyvg_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzja: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzje; else goto cdzjd;
       cdzje: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzjd: // global
           _sdyv5::P64 = P64[R1 + 7];
           _sdyv9::P64 = P64[R1 + 15];
           _sdyva::P64 = P64[R1 + 23];
           _sdyvb::P64 = P64[R1 + 31];
           I64[Hp - 16] = sat_sdyvf_info;
           P64[Hp - 8] = _sdyva::P64;
           P64[Hp] = _sdyvb::P64;
           R3 = Hp - 15;
           R2 = _sdyv9::P64;
           R1 = _sdyv5::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvj_entry() //  [R1, R2]
         { info_tbl: [(cdzji,
                       label: sat_sdyvj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzji: // global
           _sdyvb::P64 = R2;
           _sdyvj::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdzjj; else goto cdzjk;
       cdzjk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzjm; else goto cdzjl;
       cdzjm: // global
           HpAlloc = 40;
           goto cdzjj;
       cdzjj: // global
           R2 = _sdyvb::P64;
           R1 = _sdyvj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzjl: // global
           _sdyv5::P64 = P64[_sdyvj::P64 + 7];
           _sdyv9::P64 = P64[_sdyvj::P64 + 15];
           _sdyva::P64 = P64[_sdyvj::P64 + 23];
           I64[Hp - 32] = sat_sdyvg_info;
           P64[Hp - 24] = _sdyv5::P64;
           P64[Hp - 16] = _sdyv9::P64;
           P64[Hp - 8] = _sdyva::P64;
           P64[Hp] = _sdyvb::P64;
           I64[Sp - 8] = block_cdzjf_info;
           R3 = Hp - 31;
           R2 = Data.Functor.Classes.$fRead1(,)3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzjf() //  [R1]
         { info_tbl: [(cdzjf,
                       label: block_cdzjf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzjp; else goto cdzjo;
       cdzjp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzjo: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 p_sdyv8_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzjq,
                       label: p_sdyv8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzju; else goto cdzjt;
       cdzju: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzjt: // global
           _sdyv4::P64 = P64[R1 + 6];
           _sdyv5::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sdyvj_info;
           P64[Hp - 16] = _sdyv5::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 23;
           R2 = R2;
           R1 = _sdyv4::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl3_sdyvk_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzjD,
                       label: lvl3_sdyvk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzjE; else goto cdzjF;
       cdzjE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzjF: // global
           I64[Sp - 8] = block_cdzjA_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wparen'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzjA() //  [R1]
         { info_tbl: [(cdzjA,
                       label: block_cdzjA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzjI; else goto cdzjH;
       cdzjI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzjH: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvt_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzjR,
                       label: sat_sdyvt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzjS; else goto cdzjT;
       cdzjS: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzjT: // global
           I64[Sp - 8] = block_cdzjO_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wskipSpacesThenP_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzjO() //  [R1]
         { info_tbl: [(cdzjO,
                       label: block_cdzjO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzjW; else goto cdzjV;
       cdzjW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzjV: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzjX,
                       label: Data.Functor.Classes.$w$cliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzjX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzk1; else goto cdzk0;
       cdzk1: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzk0: // global
           I64[Hp - 48] = p_sdyv8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = lvl3_sdyvk_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sdyvt_info;
           P64[Hp] = Hp - 22;
           _sdyv6::P64 = R4;
           R4 = R5;
           R3 = _sdyv6::P64;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.596265531 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)2_closure" {
     Data.Functor.Classes.$fRead1(,)2_closure:
         const Data.Functor.Classes.$fRead1(,)2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)2_entry() //  [R2, R4, R6]
         { info_tbl: [(cdzk6,
                       label: Data.Functor.Classes.$fRead1(,)2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzk6: // global
           R5 = P64[Sp];
           _sdyvw::P64 = R4;
           R4 = R6;
           R3 = _sdyvw::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.599861943 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec6_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec6_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec6_info;
         const 0;
 },
 sat_sdyvE_entry() //  [R1, R2]
         { info_tbl: [(cdzkm,
                       label: sat_sdyvE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzkm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvD_entry() //  [R1, R2]
         { info_tbl: [(cdzku,
                       label: sat_sdyvD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzku: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvF_entry() //  [R1]
         { info_tbl: [(cdzkx,
                       label: sat_sdyvF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzkx: // global
           _sdyvF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzky; else goto cdzkz;
       cdzkz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzkB; else goto cdzkA;
       cdzkB: // global
           HpAlloc = 32;
           goto cdzky;
       cdzky: // global
           R1 = _sdyvF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzkA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyvF::P64;
           _sdyvA::P64 = P64[_sdyvF::P64 + 16];
           _sdyvB::P64 = P64[_sdyvF::P64 + 24];
           _sdyvC::P64 = P64[_sdyvF::P64 + 32];
           I64[Hp - 24] = sat_sdyvE_info;
           P64[Hp - 16] = _sdyvB::P64;
           I64[Hp - 8] = sat_sdyvD_info;
           P64[Hp] = _sdyvA::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyvC::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec6_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzkC,
                       label: Data.Functor.Classes.$w$cliftReadsPrec6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzkC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzkG; else goto cdzkF;
       cdzkG: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzkF: // global
           I64[Hp - 32] = sat_sdyvF_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.601576716 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_entry() //  [R2,
                                                               R4, R6]
         { info_tbl: [(cdzkL,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzkL: // global
           _sdyvI::P64 = R4;
           R4 = R6;
           R3 = _sdyvI::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec6_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.602676275 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyvR_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzkX,
                       label: sat_sdyvR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzkX: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdzl0,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzl0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzl4; else goto cdzl3;
       cdzl4: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzl3: // global
           I64[Hp - 16] = sat_sdyvR_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.603689474 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)3_closure" {
     Data.Functor.Classes.$fShow1(,)3_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.604269634 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity5_closure" {
     Data.Functor.Classes.$fRead1Identity5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.604889405 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)2_closure" {
     Data.Functor.Classes.$fShow1(,)2_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.605522066 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)1_closure" {
     Data.Functor.Classes.$fShow1(,)1_closure:
         const GHC.Types.C#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.607023159 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec2_info;
 },
 f_sdyvW_entry() //  [R1]
         { info_tbl: [(cdzld,
                       label: f_sdyvW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzld: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzle; else goto cdzlf;
       cdzle: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzlf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdyvX_entry() //  [R1]
         { info_tbl: [(cdzlk,
                       label: f1_sdyvX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzlk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzll; else goto cdzlm;
       cdzll: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzlm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw0_entry() //  [R1]
         { info_tbl: [(cdzlB,
                       label: sat_sdyw0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzlB: // global
           _sdyw0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzlC; else goto cdzlD;
       cdzlD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzlF; else goto cdzlE;
       cdzlF: // global
           HpAlloc = 24;
           goto cdzlC;
       cdzlC: // global
           R1 = _sdyw0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzlE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyw0::P64;
           _sdyvX::P64 = P64[_sdyw0::P64 + 16];
           _sdyvY::P64 = P64[_sdyw0::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdyvY::P64;
           R2 = Hp - 14;
           R1 = _sdyvX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw2_entry() //  [R1]
         { info_tbl: [(cdzlH,
                       label: sat_sdyw2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzlH: // global
           _sdyw2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzlI; else goto cdzlJ;
       cdzlJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzlL; else goto cdzlK;
       cdzlL: // global
           HpAlloc = 56;
           goto cdzlI;
       cdzlI: // global
           R1 = _sdyw2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzlK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyw2::P64;
           _sdyvW::P64 = P64[_sdyw2::P64 + 16];
           _sdyvX::P64 = P64[_sdyw2::P64 + 24];
           _sdyvY::P64 = P64[_sdyw2::P64 + 32];
           I64[Hp - 48] = sat_sdyw0_info;
           P64[Hp - 32] = _sdyvX::P64;
           P64[Hp - 24] = _sdyvY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyvW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw3_entry() //  [R1, R2]
         { info_tbl: [(cdzlN,
                       label: sat_sdyw3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzlN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzlR; else goto cdzlQ;
       cdzlR: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzlQ: // global
           _sdyvW::P64 = P64[R1 + 7];
           _sdyvX::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyw2_info;
           P64[Hp - 40] = _sdyvW::P64;
           P64[Hp - 32] = _sdyvX::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdzlS,
                       label: Data.Functor.Classes.$w$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzlS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdzlW; else goto cdzlV;
       cdzlW: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzlV: // global
           I64[Hp - 80] = f_sdyvW_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = f1_sdyvX_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdyw3_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.610018118 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdzm4,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzm4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzm5; else goto cdzm6;
       cdzm5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdzm6: // global
           I64[Sp - 16] = block_cdzm1_info;
           R1 = P64[Sp];
           P64[Sp - 8] = R4;
           P64[Sp] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udzma; else goto cdzm2;
       udzma: // global
           call _cdzm1(R1) args: 0, res: 0, upd: 0;
       cdzm2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzm1() //  [R1]
         { info_tbl: [(cdzm1,
                       label: block_cdzm1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzm1: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.611515746 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList2_closure" {
     Data.Functor.Classes.$dmliftShowList2_closure:
         const Data.Functor.Classes.$dmliftShowList2_info;
 },
 sat_sdywi_entry() //  [R1]
         { info_tbl: [(cdzmj,
                       label: sat_sdywi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzmj: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdzmk; else goto cdzml;
       cdzmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzml: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 24];
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdzmm,
                       label: Data.Functor.Classes.$dmliftShowList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzmm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzmq; else goto cdzmp;
       cdzmq: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzmp: // global
           I64[Hp - 48] = sat_sdywi_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.613597767 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList3_closure" {
     Data.Functor.Classes.$w$cliftShowList3_closure:
         const Data.Functor.Classes.$w$cliftShowList3_info;
 },
 sat_sdywt_entry() //  [R1]
         { info_tbl: [(cdzmO,
                       label: sat_sdywt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzmO: // global
           _sdywt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzmP; else goto cdzmQ;
       cdzmQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzmS; else goto cdzmR;
       cdzmS: // global
           HpAlloc = 24;
           goto cdzmP;
       cdzmP: // global
           R1 = _sdywt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzmR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywt::P64;
           _sdywk::P64 = P64[_sdywt::P64 + 16];
           _sdywo::P64 = P64[_sdywt::P64 + 24];
           _sdywr::P64 = P64[_sdywt::P64 + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdywo::P64;
           R4 = Hp - 14;
           R3 = _sdywr::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdywk::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywv_entry() //  [R1]
         { info_tbl: [(cdzmU,
                       label: sat_sdywv_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzmU: // global
           _sdywv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzmV; else goto cdzmW;
       cdzmW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzmY; else goto cdzmX;
       cdzmY: // global
           HpAlloc = 64;
           goto cdzmV;
       cdzmV: // global
           R1 = _sdywv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzmX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywv::P64;
           _sdywj::P64 = P64[_sdywv::P64 + 16];
           _sdywk::P64 = P64[_sdywv::P64 + 24];
           _sdywo::P64 = P64[_sdywv::P64 + 32];
           _sdywq::P64 = P64[_sdywv::P64 + 40];
           _sdywr::P64 = P64[_sdywv::P64 + 48];
           I64[Hp - 56] = sat_sdywt_info;
           P64[Hp - 40] = _sdywk::P64;
           P64[Hp - 32] = _sdywo::P64;
           P64[Hp - 24] = _sdywr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 56;
           R4 = Hp - 14;
           R3 = _sdywq::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdywj::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyww_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzmZ,
                       label: sat_sdyww_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzmZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzn1; else goto cdzn2;
       cdzn1: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzn2: // global
           I64[Sp - 32] = block_cdzmA_info;
           _sdywj::P64 = P64[R1 + 6];
           _sdywk::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdywj::P64;
           P64[Sp - 16] = _sdywk::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzn6; else goto cdzmB;
       udzn6: // global
           call _cdzmA(R1) args: 0, res: 0, upd: 0;
       cdzmB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzmA() //  [R1]
         { info_tbl: [(cdzmA,
                       label: block_cdzmA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzmA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdzn5; else goto cdzn4;
       cdzn5: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzn4: // global
           _sdywq::P64 = P64[R1 + 7];
           _sdywr::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sdywv_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sdywq::P64;
           P64[Hp - 24] = _sdywr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdzn7,
                       label: Data.Functor.Classes.$w$cliftShowList3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzn7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdznb; else goto cdzna;
       cdznb: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzna: // global
           I64[Hp - 16] = sat_sdyww_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdywl::P64 = R4;
           R4 = R5;
           R3 = _sdywl::P64;
           R2 = Hp - 14;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.616091215 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info;
 },
 Data.Functor.Classes.$fShow2(,)_$cliftShowList2_entry() //  [R2,
                                                              R4, R6]
         { info_tbl: [(cdzng,
                       label: Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzng: // global
           R5 = P64[Sp];
           _sdywz::P64 = R4;
           R4 = R6;
           R3 = _sdywz::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.616886437 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_closure" {
     Data.Functor.Classes.$fShow2(,)_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.61796613 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info;
 },
 sat_sdywL_entry() //  [R1]
         { info_tbl: [(cdznw,
                       label: sat_sdywL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdznw: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cdznz,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdznz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdznA; else goto cdznB;
       cdznA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdznB: // global
           I64[Sp - 24] = block_cdznn_info;
           R1 = R6;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udznF; else goto cdzno;
       udznF: // global
           call _cdznn(R1) args: 0, res: 0, upd: 0;
       cdzno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdznn() //  [R1]
         { info_tbl: [(cdznn,
                       label: block_cdznn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdznn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdznE; else goto cdznD;
       cdznE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdznD: // global
           _sdywJ::P64 = P64[R1 + 7];
           _sdywK::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdywL_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdywK::P64;
           R4 = _sdywJ::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.620578928 UTC

[section ""data" . $w$dmliftReadListPrec2_rdymu_closure" {
     $w$dmliftReadListPrec2_rdymu_closure:
         const $w$dmliftReadListPrec2_rdymu_info;
 },
 sat_sdywW_entry() //  [R1]
         { info_tbl: [(cdznS,
                       label: sat_sdywW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdznS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdznT; else goto cdznU;
       cdznT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdznU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywX_entry() //  [R1, R2]
         { info_tbl: [(cdzo0,
                       label: sat_sdywX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzo0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywV_entry() //  [R1, R2]
         { info_tbl: [(cdzo8,
                       label: sat_sdywV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzo8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywT_entry() //  [R1]
         { info_tbl: [(cdzof,
                       label: sat_sdywT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzog; else goto cdzoh;
       cdzog: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzoh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywU_entry() //  [R1, R2]
         { info_tbl: [(cdzon,
                       label: sat_sdywU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzon: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywS_entry() //  [R1, R2]
         { info_tbl: [(cdzov,
                       label: sat_sdywS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzov: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w5_sdywR_entry() //  [R1]
         { info_tbl: [(cdzoy,
                       label: w5_sdywR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzoy: // global
           _sdywR::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzoz; else goto cdzoA;
       cdzoA: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdzoC; else goto cdzoB;
       cdzoC: // global
           HpAlloc = 112;
           goto cdzoz;
       cdzoz: // global
           R1 = _sdywR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzoB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywR::P64;
           _sdywM::P64 = P64[_sdywR::P64 + 16];
           _sdywN::P64 = P64[_sdywR::P64 + 24];
           _sdywO::P64 = P64[_sdywR::P64 + 32];
           _sdywP::P64 = P64[_sdywR::P64 + 40];
           _sdywQ::P64 = P64[_sdywR::P64 + 48];
           I64[Hp - 104] = sat_sdywW_info;
           P64[Hp - 88] = _sdywQ::P64;
           I64[Hp - 80] = sat_sdywX_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdywV_info;
           P64[Hp - 56] = _sdywP::P64;
           I64[Hp - 48] = sat_sdywT_info;
           P64[Hp - 32] = _sdywO::P64;
           I64[Hp - 24] = sat_sdywU_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdywS_info;
           P64[Hp] = _sdywN::P64;
           R2 = _sdywM::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadList2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyx1_entry() //  [R1, R2]
         { info_tbl: [(cdzoL,
                       label: sat_sdyx1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzoL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzoM; else goto cdzoN;
       cdzoM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzoN: // global
           I64[Sp - 8] = block_cdzoI_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzoI() //  [R1]
         { info_tbl: [(cdzoI,
                       label: block_cdzoI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzoI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzoQ; else goto cdzoP;
       cdzoQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzoP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec2_rdymu_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzoR,
                       label: $w$dmliftReadListPrec2_rdymu_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzoR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdzoV; else goto cdzoU;
       cdzoV: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec2_rdymu_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzoU: // global
           I64[Hp - 64] = w5_sdywR_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyx1_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.62386585 UTC

[section ""data" . $dmliftReadListPrec1_rdymv_closure" {
     $dmliftReadListPrec1_rdymv_closure:
         const $dmliftReadListPrec1_rdymv_info;
 },
 $dmliftReadListPrec1_rdymv_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzp0,
                       label: $dmliftReadListPrec1_rdymv_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzp0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call $w$dmliftReadListPrec2_rdymu_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.624764316 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec2_closure" {
     Data.Functor.Classes.$dmliftReadListPrec2_closure:
         const Data.Functor.Classes.$dmliftReadListPrec2_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec2_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdzp7,
                       label: Data.Functor.Classes.$dmliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzp7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec1_rdymv_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.62698628 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec2_closure" {
     Data.Functor.Classes.$dmliftReadPrec2_closure:
         const Data.Functor.Classes.$dmliftReadPrec2_info;
 },
 sat_sdyxi_entry() //  [R1]
         { info_tbl: [(cdzpm,
                       label: sat_sdyxi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzpm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzpn; else goto cdzpo;
       cdzpn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzpo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyxj_entry() //  [R1, R2]
         { info_tbl: [(cdzpu,
                       label: sat_sdyxj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzpu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxh_entry() //  [R1, R2]
         { info_tbl: [(cdzpC,
                       label: sat_sdyxh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzpC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxf_entry() //  [R1]
         { info_tbl: [(cdzpJ,
                       label: sat_sdyxf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzpK; else goto cdzpL;
       cdzpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzpL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyxg_entry() //  [R1, R2]
         { info_tbl: [(cdzpR,
                       label: sat_sdyxg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzpR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxe_entry() //  [R1, R2]
         { info_tbl: [(cdzpZ,
                       label: sat_sdyxe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzpZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyxd_entry() //  [R1]
         { info_tbl: [(cdzq2,
                       label: f1_sdyxd_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzq2: // global
           _sdyxd::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzq3; else goto cdzq4;
       cdzq4: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdzq6; else goto cdzq5;
       cdzq6: // global
           HpAlloc = 112;
           goto cdzq3;
       cdzq3: // global
           R1 = _sdyxd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzq5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxd::P64;
           _sdyx8::P64 = P64[_sdyxd::P64 + 16];
           _sdyx9::P64 = P64[_sdyxd::P64 + 24];
           _sdyxa::P64 = P64[_sdyxd::P64 + 32];
           _sdyxb::P64 = P64[_sdyxd::P64 + 40];
           _sdyxc::P64 = P64[_sdyxd::P64 + 48];
           I64[Hp - 104] = sat_sdyxi_info;
           P64[Hp - 88] = _sdyxc::P64;
           I64[Hp - 80] = sat_sdyxj_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdyxh_info;
           P64[Hp - 56] = _sdyxb::P64;
           I64[Hp - 48] = sat_sdyxf_info;
           P64[Hp - 32] = _sdyxa::P64;
           I64[Hp - 24] = sat_sdyxg_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyxe_info;
           P64[Hp] = _sdyx9::P64;
           R2 = _sdyx8::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyxp_entry() //  [R1, R2]
         { info_tbl: [(cdzql,
                       label: sat_sdyxp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzql: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzqm; else goto cdzqn;
       cdzqm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzqn: // global
           I64[Sp - 8] = block_cdzqi_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzqi() //  [R1]
         { info_tbl: [(cdzqi,
                       label: block_cdzqi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzqi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzqq; else goto cdzqp;
       cdzqq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzqp: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxq_entry() //  [R1, R2]
         { info_tbl: [(cdzqr,
                       label: sat_sdyxq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzqr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzqv; else goto cdzqu;
       cdzqv: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzqu: // global
           _sdyxd::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdyxd::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyxp_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdzqw,
                       label: Data.Functor.Classes.$dmliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzqw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdzqA; else goto cdzqz;
       cdzqA: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzqz: // global
           I64[Hp - 64] = f1_sdyxd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyxq_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.631517025 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList2_closure" {
     Data.Functor.Classes.$dmliftReadList2_closure:
         const Data.Functor.Classes.$dmliftReadList2_info;
         const 0;
 },
 sat_sdyxH_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzqV,
                       label: sat_sdyxH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzqV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzqW; else goto cdzqX;
       cdzqW: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzqX: // global
           I64[Sp - 8] = block_cdzqS_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzqS() //  [R1]
         { info_tbl: [(cdzqS,
                       label: block_cdzqS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzqS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzr0; else goto cdzqZ;
       cdzr0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzqZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxC_entry() //  [R1, R2]
         { info_tbl: [(cdzr6,
                       label: sat_sdyxC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzr6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzrh,
                       label: sat_sdyxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzrh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzri; else goto cdzrj;
       cdzri: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzrj: // global
           I64[Sp - 8] = block_cdzre_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzre() //  [R1]
         { info_tbl: [(cdzre,
                       label: block_cdzre_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzre: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzrm; else goto cdzrl;
       cdzrm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzrl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxw_entry() //  [R1, R2]
         { info_tbl: [(cdzrs,
                       label: sat_sdyxw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzrs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxI_entry() //  [R1]
         { info_tbl: [(cdzrv,
                       label: sat_sdyxI_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzrv: // global
           _sdyxI::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzrw; else goto cdzrx;
       cdzrx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzrz; else goto cdzry;
       cdzrz: // global
           HpAlloc = 64;
           goto cdzrw;
       cdzrw: // global
           R1 = _sdyxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzry: // global
           _sdyxr::P64 = P64[_sdyxI::P64 + 16];
           _sdyxs::P64 = P64[_sdyxI::P64 + 24];
           _sdyxt::P64 = P64[_sdyxI::P64 + 32];
           _sdyxu::P64 = P64[_sdyxI::P64 + 40];
           _sdyxv::P64 = P64[_sdyxI::P64 + 48];
           I64[Hp - 56] = sat_sdyxH_info;
           P64[Hp - 48] = _sdyxv::P64;
           I64[Hp - 40] = sat_sdyxC_info;
           P64[Hp - 32] = _sdyxu::P64;
           I64[Hp - 24] = sat_sdyxB_info;
           P64[Hp - 16] = _sdyxt::P64;
           I64[Hp - 8] = sat_sdyxw_info;
           P64[Hp] = _sdyxs::P64;
           R2 = _sdyxr::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 54;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sdyxJ_entry() //  [R1]
         { info_tbl: [(cdzrA,
                       label: sat_sdyxJ_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzrA: // global
           _sdyxJ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzrB; else goto cdzrC;
       cdzrC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzrE; else goto cdzrD;
       cdzrE: // global
           HpAlloc = 56;
           goto cdzrB;
       cdzrB: // global
           R1 = _sdyxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzrD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxJ::P64;
           _sdyxr::P64 = P64[_sdyxJ::P64 + 16];
           _sdyxs::P64 = P64[_sdyxJ::P64 + 24];
           _sdyxt::P64 = P64[_sdyxJ::P64 + 32];
           _sdyxu::P64 = P64[_sdyxJ::P64 + 40];
           _sdyxv::P64 = P64[_sdyxJ::P64 + 48];
           I64[Hp - 48] = sat_sdyxI_info;
           P64[Hp - 32] = _sdyxr::P64;
           P64[Hp - 24] = _sdyxs::P64;
           P64[Hp - 16] = _sdyxt::P64;
           P64[Hp - 8] = _sdyxu::P64;
           P64[Hp] = _sdyxv::P64;
           R2 = Hp - 48;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdzrF,
                       label: Data.Functor.Classes.$dmliftReadList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzrF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzrJ; else goto cdzrI;
       cdzrJ: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzrI: // global
           I64[Hp - 48] = sat_sdyxJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.63614469 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec2_closure" {
     Data.Functor.Classes.$dmliftReadsPrec2_closure:
         const Data.Functor.Classes.$dmliftReadsPrec2_info;
 },
 sat_sdyy1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzs0,
                       label: sat_sdyy1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzs0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzs1; else goto cdzs2;
       cdzs1: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzs2: // global
           I64[Sp - 8] = block_cdzrX_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzrX() //  [R1]
         { info_tbl: [(cdzrX,
                       label: block_cdzrX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzrX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzs5; else goto cdzs4;
       cdzs5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzs4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxW_entry() //  [R1, R2]
         { info_tbl: [(cdzsb,
                       label: sat_sdyxW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxV_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzsm,
                       label: sat_sdyxV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzsn; else goto cdzso;
       cdzsn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzso: // global
           I64[Sp - 8] = block_cdzsj_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzsj() //  [R1]
         { info_tbl: [(cdzsj,
                       label: block_cdzsj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzsr; else goto cdzsq;
       cdzsr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzsq: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxQ_entry() //  [R1, R2]
         { info_tbl: [(cdzsx,
                       label: sat_sdyxQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsx: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdyxP_entry() //  [R1]
         { info_tbl: [(cdzsA,
                       label: ds_sdyxP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsA: // global
           _sdyxP::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzsB; else goto cdzsC;
       cdzsC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzsE; else goto cdzsD;
       cdzsE: // global
           HpAlloc = 64;
           goto cdzsB;
       cdzsB: // global
           R1 = _sdyxP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzsD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxP::P64;
           _sdyxK::P64 = P64[_sdyxP::P64 + 16];
           _sdyxL::P64 = P64[_sdyxP::P64 + 24];
           _sdyxM::P64 = P64[_sdyxP::P64 + 32];
           _sdyxN::P64 = P64[_sdyxP::P64 + 40];
           _sdyxO::P64 = P64[_sdyxP::P64 + 48];
           I64[Hp - 56] = sat_sdyy1_info;
           P64[Hp - 48] = _sdyxO::P64;
           I64[Hp - 40] = sat_sdyxW_info;
           P64[Hp - 32] = _sdyxN::P64;
           I64[Hp - 24] = sat_sdyxV_info;
           P64[Hp - 16] = _sdyxM::P64;
           I64[Hp - 8] = sat_sdyxQ_info;
           P64[Hp] = _sdyxL::P64;
           R2 = _sdyxK::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Hp - 39;
           P64[Sp - 24] = Hp - 54;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyy3_entry() //  [R1]
         { info_tbl: [(cdzsO,
                       label: sat_sdyy3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzsP; else goto cdzsQ;
       cdzsP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzsQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyy4_entry() //  [R1, R2]
         { info_tbl: [(cdzsR,
                       label: sat_sdyy4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzsV; else goto cdzsU;
       cdzsV: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzsU: // global
           _sdyxP::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyy3_info;
           P64[Hp - 8] = _sdyxP::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdzsW,
                       label: Data.Functor.Classes.$dmliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzsW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdzt0; else goto cdzsZ;
       cdzt0: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzsZ: // global
           I64[Hp - 64] = ds_sdyxP_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyy4_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.639633982 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList_closure" {
     Data.Functor.Classes.$dmliftShowList_closure:
         const Data.Functor.Classes.$dmliftShowList_info;
 },
 sat_sdyy8_entry() //  [R1]
         { info_tbl: [(cdzt9,
                       label: sat_sdyy8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzt9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdzta; else goto cdztb;
       cdzta: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdztb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 48;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdztc,
                       label: Data.Functor.Classes.$dmliftShowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdztc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdztg; else goto cdztf;
       cdztg: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdztf: // global
           I64[Hp - 32] = sat_sdyy8_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.641421894 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList_closure" {
     Data.Functor.Classes.$w$cliftShowList_closure:
         const Data.Functor.Classes.$w$cliftShowList_info;
 },
 lvl3_sdyyd_entry() //  [R1]
         { info_tbl: [(cdztp,
                       label: lvl3_sdyyd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdztp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdztq; else goto cdztr;
       cdztq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdztr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyyi_entry() //  [R1, R2]
         { info_tbl: [(cdztA,
                       label: sat_sdyyi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdztA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdztB; else goto cdztC;
       cdztB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdztC: // global
           I64[Sp - 24] = block_cdztx_info;
           _sdyya::P64 = P64[R1 + 7];
           _sdyyd::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyya::P64;
           P64[Sp - 8] = _sdyyd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udztG; else goto cdzty;
       udztG: // global
           call _cdztx(R1) args: 0, res: 0, upd: 0;
       cdzty: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdztx() //  [R1]
         { info_tbl: [(cdztx,
                       label: block_cdztx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdztx: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdztH,
                       label: Data.Functor.Classes.$w$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdztH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdztL; else goto cdztK;
       cdztL: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdztK: // global
           I64[Hp - 40] = lvl3_sdyyd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyyi_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdyyb::P64 = R4;
           R4 = R5;
           R3 = _sdyyb::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.643228337 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowList_entry() //  [R2, R3,
                                                             R5, R6]
         { info_tbl: [(cdztQ,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdztQ: // global
           _sdyym::P64 = R5;
           R5 = R6;
           R4 = _sdyym::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.644508101 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_closure" {
     Data.Functor.Classes.$fShow1(,)_closure:
         const Data.Functor.Classes.$fShow1(,)_info;
 },
 sat_sdyyu_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdzu2,
                       label: sat_sdyyu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzu2: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyyp_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdzua,
                       label: sat_sdyyp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzua: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_entry() //  [R2]
         { info_tbl: [(cdzue,
                       label: Data.Functor.Classes.$fShow1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzue: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzui; else goto cdzuh;
       cdzui: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzuh: // global
           I64[Hp - 48] = sat_sdyyu_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyyp_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.646085204 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy1_closure" {
     Data.Functor.Classes.$fShow1Proxy1_closure:
         const Data.Functor.Classes.$fShow1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy1_entry() //  [R3]
         { info_tbl: [(cdzun,
                       label: Data.Functor.Classes.$fShow1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzun: // global
           R2 = R3;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.64698349 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowList_entry() //  [R4,
                                                               R5]
         { info_tbl: [(cdzuu,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzuu: // global
           _sdyyy::P64 = R4;
           R4 = R5;
           R3 = _sdyyy::P64;
           R2 = Data.Functor.Classes.$fShow1Proxy1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.647803093 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_closure" {
     Data.Functor.Classes.$fShow1Proxy_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure+5;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.648905787 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info;
 },
 sat_sdyyI_entry() //  [R1, R2]
         { info_tbl: [(cdzuJ,
                       label: sat_sdyyI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzuJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzuK; else goto cdzuL;
       cdzuK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzuL: // global
           I64[Sp - 24] = block_cdzuG_info;
           _sdyyA::P64 = P64[R1 + 7];
           _sdyyB::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyyA::P64;
           P64[Sp - 8] = _sdyyB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udzuP; else goto cdzuH;
       udzuP: // global
           call _cdzuG(R1) args: 0, res: 0, upd: 0;
       cdzuH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzuG() //  [R1]
         { info_tbl: [(cdzuG,
                       label: block_cdzuG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzuG: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdzuQ,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzuQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzuU; else goto cdzuT;
       cdzuU: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzuT: // global
           I64[Hp - 16] = sat_sdyyI_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyyC::P64 = R4;
           R4 = R5;
           R3 = _sdyyC::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.652079083 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.652787741 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowList_entry() //  [R3, R4,
                                                            R5]
         { info_tbl: [(cdzuZ,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzuZ: // global
           _B2::P64 = R4;
           R4 = R5;
           _sdyyK::P64 = R3;
           R3 = _B2::P64;
           R2 = _sdyyK::P64;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.653598686 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_closure" {
     Data.Functor.Classes.$fShow1[]_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure+3;
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.655062693 UTC

[section ""data" . $w$dmliftReadListPrec_rdymw_closure" {
     $w$dmliftReadListPrec_rdymw_closure:
         const $w$dmliftReadListPrec_rdymw_info;
 },
 sat_sdyyQ_entry() //  [R1]
         { info_tbl: [(cdzve,
                       label: sat_sdyyQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzvf; else goto cdzvg;
       cdzvf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzvg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyyR_entry() //  [R1, R2]
         { info_tbl: [(cdzvm,
                       label: sat_sdyyR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyyP_entry() //  [R1, R2]
         { info_tbl: [(cdzvu,
                       label: sat_sdyyP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w3_sdyyO_entry() //  [R1]
         { info_tbl: [(cdzvx,
                       label: w3_sdyyO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvx: // global
           _sdyyO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzvy; else goto cdzvz;
       cdzvz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzvB; else goto cdzvA;
       cdzvB: // global
           HpAlloc = 56;
           goto cdzvy;
       cdzvy: // global
           R1 = _sdyyO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzvA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyyO::P64;
           _sdyyL::P64 = P64[_sdyyO::P64 + 16];
           _sdyyM::P64 = P64[_sdyyO::P64 + 24];
           _sdyyN::P64 = P64[_sdyyO::P64 + 32];
           I64[Hp - 48] = sat_sdyyQ_info;
           P64[Hp - 32] = _sdyyN::P64;
           I64[Hp - 24] = sat_sdyyR_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyyP_info;
           P64[Hp] = _sdyyM::P64;
           R2 = _sdyyL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyyV_entry() //  [R1, R2]
         { info_tbl: [(cdzvK,
                       label: sat_sdyyV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzvL; else goto cdzvM;
       cdzvL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzvM: // global
           I64[Sp - 8] = block_cdzvH_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzvH() //  [R1]
         { info_tbl: [(cdzvH,
                       label: block_cdzvH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzvP; else goto cdzvO;
       cdzvP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzvO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec_rdymw_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzvQ,
                       label: $w$dmliftReadListPrec_rdymw_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzvU; else goto cdzvT;
       cdzvU: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec_rdymw_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzvT: // global
           I64[Hp - 48] = w3_sdyyO_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyyV_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.657470432 UTC

[section ""data" . $dmliftReadListPrec3_rdymx_closure" {
     $dmliftReadListPrec3_rdymx_closure:
         const $dmliftReadListPrec3_rdymx_info;
 },
 $dmliftReadListPrec3_rdymx_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzvZ,
                       label: $dmliftReadListPrec3_rdymx_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzvZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $w$dmliftReadListPrec_rdymw_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.658305721 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec_closure" {
     Data.Functor.Classes.$dmliftReadListPrec_closure:
         const Data.Functor.Classes.$dmliftReadListPrec_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdzw6,
                       label: Data.Functor.Classes.$dmliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzw6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec3_rdymx_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.660101422 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec_closure" {
     Data.Functor.Classes.$dmliftReadPrec_closure:
         const Data.Functor.Classes.$dmliftReadPrec_info;
 },
 sat_sdyz5_entry() //  [R1]
         { info_tbl: [(cdzwl,
                       label: sat_sdyz5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzwl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzwm; else goto cdzwn;
       cdzwm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzwn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyz6_entry() //  [R1, R2]
         { info_tbl: [(cdzwt,
                       label: sat_sdyz6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzwt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyz4_entry() //  [R1, R2]
         { info_tbl: [(cdzwB,
                       label: sat_sdyz4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzwB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyz3_entry() //  [R1]
         { info_tbl: [(cdzwE,
                       label: f1_sdyz3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzwE: // global
           _sdyz3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzwF; else goto cdzwG;
       cdzwG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzwI; else goto cdzwH;
       cdzwI: // global
           HpAlloc = 56;
           goto cdzwF;
       cdzwF: // global
           R1 = _sdyz3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzwH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyz3::P64;
           _sdyz0::P64 = P64[_sdyz3::P64 + 16];
           _sdyz1::P64 = P64[_sdyz3::P64 + 24];
           _sdyz2::P64 = P64[_sdyz3::P64 + 32];
           I64[Hp - 48] = sat_sdyz5_info;
           P64[Hp - 32] = _sdyz2::P64;
           I64[Hp - 24] = sat_sdyz6_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyz4_info;
           P64[Hp] = _sdyz1::P64;
           R2 = _sdyz0::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyzc_entry() //  [R1, R2]
         { info_tbl: [(cdzwX,
                       label: sat_sdyzc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzwX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzwY; else goto cdzwZ;
       cdzwY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzwZ: // global
           I64[Sp - 8] = block_cdzwU_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzwU() //  [R1]
         { info_tbl: [(cdzwU,
                       label: block_cdzwU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzwU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzx2; else goto cdzx1;
       cdzx2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzx1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzd_entry() //  [R1, R2]
         { info_tbl: [(cdzx3,
                       label: sat_sdyzd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzx3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzx7; else goto cdzx6;
       cdzx7: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzx6: // global
           _sdyz3::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdyz3::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyzc_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzx8,
                       label: Data.Functor.Classes.$dmliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzx8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzxc; else goto cdzxb;
       cdzxc: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzxb: // global
           I64[Hp - 48] = f1_sdyz3_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyzd_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.663514714 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList_closure" {
     Data.Functor.Classes.$dmliftReadList_closure:
         const Data.Functor.Classes.$dmliftReadList_info;
         const 0;
 },
 sat_sdyzm_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzxx,
                       label: sat_sdyzm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzxx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzxy; else goto cdzxz;
       cdzxy: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzxz: // global
           I64[Sp - 8] = block_cdzxu_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzxu() //  [R1]
         { info_tbl: [(cdzxu,
                       label: block_cdzxu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzxu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzxC; else goto cdzxB;
       cdzxC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzxB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzh_entry() //  [R1, R2]
         { info_tbl: [(cdzxI,
                       label: sat_sdyzh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzxI: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzn_entry() //  [R1]
         { info_tbl: [(cdzxL,
                       label: sat_sdyzn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzxL: // global
           _sdyzn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzxM; else goto cdzxN;
       cdzxN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzxP; else goto cdzxO;
       cdzxP: // global
           HpAlloc = 32;
           goto cdzxM;
       cdzxM: // global
           R1 = _sdyzn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzxO: // global
           _sdyze::P64 = P64[_sdyzn::P64 + 16];
           _sdyzf::P64 = P64[_sdyzn::P64 + 24];
           _sdyzg::P64 = P64[_sdyzn::P64 + 32];
           I64[Hp - 24] = sat_sdyzm_info;
           P64[Hp - 16] = _sdyzg::P64;
           I64[Hp - 8] = sat_sdyzh_info;
           P64[Hp] = _sdyzf::P64;
           R2 = _sdyze::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdyzo_entry() //  [R1]
         { info_tbl: [(cdzxQ,
                       label: sat_sdyzo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzxQ: // global
           _sdyzo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzxR; else goto cdzxS;
       cdzxS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzxU; else goto cdzxT;
       cdzxU: // global
           HpAlloc = 40;
           goto cdzxR;
       cdzxR: // global
           R1 = _sdyzo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzxT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzo::P64;
           _sdyze::P64 = P64[_sdyzo::P64 + 16];
           _sdyzf::P64 = P64[_sdyzo::P64 + 24];
           _sdyzg::P64 = P64[_sdyzo::P64 + 32];
           I64[Hp - 32] = sat_sdyzn_info;
           P64[Hp - 16] = _sdyze::P64;
           P64[Hp - 8] = _sdyzf::P64;
           P64[Hp] = _sdyzg::P64;
           R2 = Hp - 32;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzxV,
                       label: Data.Functor.Classes.$dmliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzxV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzxZ; else goto cdzxY;
       cdzxZ: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzxY: // global
           I64[Hp - 32] = sat_sdyzo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.66694526 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info;
         const 0;
 },
 f_sdyzr_entry() //  [R1, R2]
         { info_tbl: [(cdzy9,
                       label: f_sdyzr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzy9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyzs_entry() //  [R1]
         { info_tbl: [(cdzyg,
                       label: f1_sdyzs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzyh; else goto cdzyi;
       cdzyh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzyi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdyzt_entry() //  [R1, R2]
         { info_tbl: [(cdzyo,
                       label: f2_sdyzt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyo: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzz_entry() //  [R1, R2]
         { info_tbl: [(cdzyE,
                       label: sat_sdyzz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzyF; else goto cdzyG;
       cdzyF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzyG: // global
           I64[Sp - 32] = block_cdzyB_info;
           _sdyzr::P64 = P64[R1 + 7];
           _sdyzt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdyzr::P64;
           P64[Sp - 16] = _sdyzt::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzyK; else goto cdzyC;
       udzyK: // global
           call _cdzyB(R1) args: 0, res: 0, upd: 0;
       cdzyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzyB() //  [R1]
         { info_tbl: [(cdzyB,
                       label: block_cdzyB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyB: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzyO,
                       label: sat_sdyzC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyO: // global
           _sdyzv::P64 = R3;
           _sdyzu::P64 = R2;
           _sdyzC::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdzyP; else goto cdzyQ;
       cdzyQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzyS; else goto cdzyR;
       cdzyS: // global
           HpAlloc = 32;
           goto cdzyP;
       cdzyP: // global
           R3 = _sdyzv::P64;
           R2 = _sdyzu::P64;
           R1 = _sdyzC::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzyR: // global
           _sdyzr::P64 = P64[_sdyzC::P64 + 6];
           _sdyzt::P64 = P64[_sdyzC::P64 + 14];
           I64[Hp - 24] = sat_sdyzz_info;
           P64[Hp - 16] = _sdyzr::P64;
           P64[Hp - 8] = _sdyzt::P64;
           P64[Hp] = _sdyzu::P64;
           I64[Sp - 8] = block_cdzyL_info;
           R3 = _sdyzv::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzyL() //  [R1]
         { info_tbl: [(cdzyL,
                       label: block_cdzyL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzyV; else goto cdzyU;
       cdzyV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzyU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdzyW,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzyW: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdzz0; else goto cdzyZ;
       cdzz0: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzyZ: // global
           I64[Hp - 72] = f_sdyzr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = f1_sdyzs_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = f2_sdyzt_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdyzC_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.671039318 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info;
         const 0;
 },
 sat_sdyzK_entry() //  [R1]
         { info_tbl: [(cdzzm,
                       label: sat_sdyzK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzzm: // global
           _sdyzK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzzn; else goto cdzzo;
       cdzzo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzzq; else goto cdzzp;
       cdzzq: // global
           HpAlloc = 32;
           goto cdzzn;
       cdzzn: // global
           R1 = _sdyzK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzzp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzK::P64;
           _sdyzD::P64 = P64[_sdyzK::P64 + 16];
           _sdyzG::P64 = P64[_sdyzK::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdyzD::P64;
           P64[Hp] = _sdyzG::P64;
           I64[Sp - 24] = block_cdzzj_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdzzj() //  [R1]
         { info_tbl: [(cdzzj,
                       label: block_cdzzj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzzj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzzt; else goto cdzzs;
       cdzzt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdzzs: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f_sdyzF_entry() //  [R1, R2]
         { info_tbl: [(cdzzu,
                       label: f_sdyzF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzzu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzzy; else goto cdzzx;
       cdzzy: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzzx: // global
           _sdyzD::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyzK_info;
           P64[Hp - 8] = _sdyzD::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyzL_entry() //  [R1]
         { info_tbl: [(cdzzG,
                       label: f1_sdyzL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzzG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzzH; else goto cdzzI;
       cdzzH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzzI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdzzD_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdzzD() //  [R1]
         { info_tbl: [(cdzzD,
                       label: block_cdzzD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzzD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzzL; else goto cdzzK;
       cdzzL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdzzK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdyzO_entry() //  [R1, R2]
         { info_tbl: [(cdzzR,
                       label: f2_sdyzO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzzR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzU_entry() //  [R1, R2]
         { info_tbl: [(cdzA7,
                       label: sat_sdyzU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzA7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzA8; else goto cdzA9;
       cdzA8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzA9: // global
           I64[Sp - 32] = block_cdzA4_info;
           _sdyzF::P64 = P64[R1 + 7];
           _sdyzO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdyzF::P64;
           P64[Sp - 16] = _sdyzO::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udzAd; else goto cdzA5;
       udzAd: // global
           call _cdzA4(R1) args: 0, res: 0, upd: 0;
       cdzA5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzA4() //  [R1]
         { info_tbl: [(cdzA4,
                       label: block_cdzA4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzA4: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzAh,
                       label: sat_sdyzX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzAh: // global
           _sdyzQ::P64 = R3;
           _sdyzP::P64 = R2;
           _sdyzX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdzAi; else goto cdzAj;
       cdzAj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzAl; else goto cdzAk;
       cdzAl: // global
           HpAlloc = 32;
           goto cdzAi;
       cdzAi: // global
           R3 = _sdyzQ::P64;
           R2 = _sdyzP::P64;
           R1 = _sdyzX::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzAk: // global
           _sdyzF::P64 = P64[_sdyzX::P64 + 6];
           _sdyzO::P64 = P64[_sdyzX::P64 + 14];
           I64[Hp - 24] = sat_sdyzU_info;
           P64[Hp - 16] = _sdyzF::P64;
           P64[Hp - 8] = _sdyzO::P64;
           P64[Hp] = _sdyzP::P64;
           I64[Sp - 8] = block_cdzAe_info;
           R3 = _sdyzQ::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzAe() //  [R1]
         { info_tbl: [(cdzAe,
                       label: block_cdzAe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzAe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzAo; else goto cdzAn;
       cdzAo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzAn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzY_entry() //  [R1]
         { info_tbl: [(cdzAp,
                       label: sat_sdyzY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzAp: // global
           _sdyzY::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzAq; else goto cdzAr;
       cdzAr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdzAt; else goto cdzAs;
       cdzAt: // global
           HpAlloc = 80;
           goto cdzAq;
       cdzAq: // global
           R1 = _sdyzY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzAs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzY::P64;
           _sdyzD::P64 = P64[_sdyzY::P64 + 16];
           _sdyzE::P64 = P64[_sdyzY::P64 + 24];
           I64[Hp - 72] = f_sdyzF_info;
           P64[Hp - 64] = _sdyzD::P64;
           I64[Hp - 56] = f1_sdyzL_info;
           P64[Hp - 40] = _sdyzE::P64;
           I64[Hp - 32] = f2_sdyzO_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdyzX_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R2 = Hp - 14;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdzAu,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzAu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzAy; else goto cdzAx;
       cdzAy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzAx: // global
           I64[Hp - 24] = sat_sdyzY_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.675734488 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyA3_entry() //  [R1]
         { info_tbl: [(cdzAL,
                       label: sat_sdyA3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzAL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzAM; else goto cdzAN;
       cdzAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyA4_entry() //  [R1, R2]
         { info_tbl: [(cdzAT,
                       label: sat_sdyA4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzAT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyA2_entry() //  [R1, R2]
         { info_tbl: [(cdzB1,
                       label: sat_sdyA2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzB1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w2_sdyA1_entry() //  [R1]
         { info_tbl: [(cdzB4,
                       label: w2_sdyA1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzB4: // global
           _sdyA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzB5; else goto cdzB6;
       cdzB6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzB8; else goto cdzB7;
       cdzB8: // global
           HpAlloc = 56;
           goto cdzB5;
       cdzB5: // global
           R1 = _sdyA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzB7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyA1::P64;
           _sdyzZ::P64 = P64[_sdyA1::P64 + 16];
           _sdyA0::P64 = P64[_sdyA1::P64 + 24];
           I64[Hp - 48] = sat_sdyA3_info;
           P64[Hp - 32] = _sdyA0::P64;
           I64[Hp - 24] = sat_sdyA4_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyA2_info;
           P64[Hp] = _sdyzZ::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyA8_entry() //  [R1, R2]
         { info_tbl: [(cdzBh,
                       label: sat_sdyA8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzBh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzBi; else goto cdzBj;
       cdzBi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzBj: // global
           I64[Sp - 8] = block_cdzBe_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzBe() //  [R1]
         { info_tbl: [(cdzBe,
                       label: block_cdzBe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzBe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzBm; else goto cdzBl;
       cdzBm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzBl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec2_entry() //  [R2, R3]
         { info_tbl: [(cdzBn,
                       label: Data.Functor.Classes.$w$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzBn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzBr; else goto cdzBq;
       cdzBr: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzBq: // global
           I64[Hp - 40] = w2_sdyA1_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdyA8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.678064207 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty1_closure" {
     Data.Functor.Classes.$fRead1NonEmpty1_closure:
         const Data.Functor.Classes.$fRead1NonEmpty1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(cdzBw,
                       label: Data.Functor.Classes.$fRead1NonEmpty1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzBw: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec2_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.678823854 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure+4;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.680419424 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec_closure" {
     Data.Functor.Classes.$dmliftReadsPrec_closure:
         const Data.Functor.Classes.$dmliftReadsPrec_info;
 },
 sat_sdyAl_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzBP,
                       label: sat_sdyAl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzBP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzBQ; else goto cdzBR;
       cdzBQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzBR: // global
           I64[Sp - 8] = block_cdzBM_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzBM() //  [R1]
         { info_tbl: [(cdzBM,
                       label: block_cdzBM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzBM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzBU; else goto cdzBT;
       cdzBU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzBT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyAg_entry() //  [R1, R2]
         { info_tbl: [(cdzC0,
                       label: sat_sdyAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzC0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdyAf_entry() //  [R1]
         { info_tbl: [(cdzC3,
                       label: ds_sdyAf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzC3: // global
           _sdyAf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzC4; else goto cdzC5;
       cdzC5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzC7; else goto cdzC6;
       cdzC7: // global
           HpAlloc = 32;
           goto cdzC4;
       cdzC4: // global
           R1 = _sdyAf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzC6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyAf::P64;
           _sdyAc::P64 = P64[_sdyAf::P64 + 16];
           _sdyAd::P64 = P64[_sdyAf::P64 + 24];
           _sdyAe::P64 = P64[_sdyAf::P64 + 32];
           I64[Hp - 24] = sat_sdyAl_info;
           P64[Hp - 16] = _sdyAe::P64;
           I64[Hp - 8] = sat_sdyAg_info;
           P64[Hp] = _sdyAd::P64;
           R2 = _sdyAc::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyAn_entry() //  [R1]
         { info_tbl: [(cdzCh,
                       label: sat_sdyAn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzCi; else goto cdzCj;
       cdzCi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzCj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAo_entry() //  [R1, R2]
         { info_tbl: [(cdzCk,
                       label: sat_sdyAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzCo; else goto cdzCn;
       cdzCo: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzCn: // global
           _sdyAf::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyAn_info;
           P64[Hp - 8] = _sdyAf::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzCp,
                       label: Data.Functor.Classes.$dmliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzCt; else goto cdzCs;
       cdzCt: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzCs: // global
           I64[Hp - 48] = ds_sdyAf_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyAo_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.683440344 UTC

[section ""data" . Data.Functor.Classes.eq1_closure" {
     Data.Functor.Classes.eq1_closure:
         const Data.Functor.Classes.eq1_info;
 },
 sat_sdyAr_entry() //  [R1]
         { info_tbl: [(cdzCC,
                       label: sat_sdyAr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzCD; else goto cdzCE;
       cdzCD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzCE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq1_entry() //  [R2, R3]
         { info_tbl: [(cdzCF,
                       label: Data.Functor.Classes.eq1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzCJ; else goto cdzCI;
       cdzCJ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzCI: // global
           I64[Hp - 16] = sat_sdyAr_info;
           P64[Hp] = R3;
           _sdyAp::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdyAp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.684810577 UTC

[section ""data" . Data.Functor.Classes.compare1_closure" {
     Data.Functor.Classes.compare1_closure:
         const Data.Functor.Classes.compare1_info;
 },
 sat_sdyAu_entry() //  [R1]
         { info_tbl: [(cdzCS,
                       label: sat_sdyAu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzCT; else goto cdzCU;
       cdzCT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzCU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare1_entry() //  [R2, R3]
         { info_tbl: [(cdzCV,
                       label: Data.Functor.Classes.compare1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzCV: // global
           _sdyAt::P64 = R3;
           _sdyAs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzCW; else goto cdzCX;
       cdzCX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzCZ; else goto cdzCY;
       cdzCZ: // global
           HpAlloc = 24;
           goto cdzCW;
       cdzCW: // global
           R3 = _sdyAt::P64;
           R2 = _sdyAs::P64;
           R1 = Data.Functor.Classes.compare1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzCY: // global
           I64[Hp - 16] = sat_sdyAu_info;
           P64[Hp] = _sdyAt::P64;
           R2 = _sdyAs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.686390518 UTC

[section ""data" . Data.Functor.Classes.readsPrec1_closure" {
     Data.Functor.Classes.readsPrec1_closure:
         const Data.Functor.Classes.readsPrec1_info;
 },
 sat_sdyAy_entry() //  [R1]
         { info_tbl: [(cdzD8,
                       label: sat_sdyAy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzD8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzD9; else goto cdzDa;
       cdzD9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzDa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAx_entry() //  [R1]
         { info_tbl: [(cdzDf,
                       label: sat_sdyAx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzDf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzDg; else goto cdzDh;
       cdzDg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzDh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdzDi,
                       label: Data.Functor.Classes.readsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzDi: // global
           _sdyAw::P64 = R3;
           _sdyAv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzDj; else goto cdzDk;
       cdzDk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzDm; else goto cdzDl;
       cdzDm: // global
           HpAlloc = 48;
           goto cdzDj;
       cdzDj: // global
           R3 = _sdyAw::P64;
           R2 = _sdyAv::P64;
           R1 = Data.Functor.Classes.readsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzDl: // global
           I64[Hp - 40] = sat_sdyAy_info;
           P64[Hp - 24] = _sdyAw::P64;
           I64[Hp - 16] = sat_sdyAx_info;
           P64[Hp] = _sdyAw::P64;
           R2 = _sdyAv::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.688932899 UTC

[section ""data" . Data.Functor.Classes.readsUnary1_closure" {
     Data.Functor.Classes.readsUnary1_closure:
         const Data.Functor.Classes.readsUnary1_info;
 },
 go_sdyAG_entry() //  [R1, R2]
         { info_tbl: [(cdzDI,
                       label: go_sdyAG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzDI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzDJ; else goto cdzDK;
       cdzDJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzDK: // global
           I64[Sp - 24] = block_cdzDB_info;
           _sdyAG::P64 = R1;
           _sdyAC::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyAC::P64;
           P64[Sp - 8] = _sdyAG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udzE4; else goto cdzDC;
       udzE4: // global
           call _cdzDB(R1) args: 0, res: 0, upd: 0;
       cdzDC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzDB() //  [R1]
         { info_tbl: [(cdzDB,
                       label: block_cdzDB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzDB: // global
           if (R1 & 7 == 1) goto cdzDF; else goto cdzDG;
       cdzDF: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzDG: // global
           I64[Sp - 8] = block_cdzDQ_info;
           _sdyAK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyAK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzE3; else goto cdzDR;
       udzE3: // global
           call _cdzDQ(R1) args: 0, res: 0, upd: 0;
       cdzDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzDQ() //  [R1]
         { info_tbl: [(cdzDQ,
                       label: block_cdzDQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzDQ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdzE2; else goto cdzE1;
       cdzE2: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzE1: // global
           _sdyAM::P64 = P64[R1 + 7];
           _sdyAN::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyAM::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyAN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyAS_entry() //  [R1]
         { info_tbl: [(cdzE9,
                       label: sat_sdyAS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzE9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzEa; else goto cdzEb;
       cdzEa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzEb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAR_entry() //  [R1]
         { info_tbl: [(cdzEg,
                       label: sat_sdyAR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzEh; else goto cdzEi;
       cdzEh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzEi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzEn,
                       label: Data.Functor.Classes.readsUnary1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdzEo; else goto cdzEp;
       cdzEo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdzEp: // global
           I64[Sp - 32] = block_cdzDr_info;
           _sdyAA::P64 = R3;
           R3 = R4;
           _sdyAz::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdyAz::P64;
           P64[Sp - 16] = _sdyAA::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzDr() //  [R1]
         { info_tbl: [(cdzDr,
                       label: block_cdzDr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzDr: // global
           if (R1 & 7 == 1) goto cdzEk; else goto cdzEl;
       cdzEk: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzEl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzEv; else goto cdzEu;
       cdzEv: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzEu: // global
           I64[Hp - 56] = go_sdyAG_info;
           P64[Hp - 48] = P64[Sp + 24];
           I64[Hp - 40] = sat_sdyAS_info;
           _sdyAA::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sdyAA::P64;
           I64[Hp - 16] = sat_sdyAR_info;
           P64[Hp] = _sdyAA::P64;
           I64[Sp + 24] = block_cdzEs_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           P64[Sp + 8] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 55;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdzEs() //  [R1]
         { info_tbl: [(cdzEs,
                       label: block_cdzEs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEs: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyAG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.693840471 UTC

[section ""data" . Data.Functor.Classes.readsBinary1_closure" {
     Data.Functor.Classes.readsBinary1_closure:
         const Data.Functor.Classes.readsBinary1_info;
 },
 Data.Functor.Classes.readsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.readsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 lvl3_sdyB2_entry() //  [R1]
         { info_tbl: [(cdzEO,
                       label: lvl3_sdyB2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzEP; else goto cdzEQ;
       cdzEP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzEQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl4_sdyB3_entry() //  [R1]
         { info_tbl: [(cdzEV,
                       label: lvl4_sdyB3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzEW; else goto cdzEX;
       cdzEW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzEX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_sdyBd_entry() //  [R1, R2]
         { info_tbl: [(cdzFr,
                       label: go1_sdyBd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzFr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzFs; else goto cdzFt;
       cdzFs: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzFt: // global
           I64[Sp - 40] = block_cdzFk_info;
           _sdyBd::P64 = R1;
           _sdyAY::P64 = P64[R1 + 7];
           _sdyBa::P64 = P64[R1 + 15];
           _sdyBc::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdyAY::P64;
           P64[Sp - 24] = _sdyBa::P64;
           P64[Sp - 16] = _sdyBc::P64;
           P64[Sp - 8] = _sdyBd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udzFN; else goto cdzFl;
       udzFN: // global
           call _cdzFk(R1) args: 0, res: 0, upd: 0;
       cdzFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzFk() //  [R1]
         { info_tbl: [(cdzFk,
                       label: block_cdzFk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzFk: // global
           if (R1 & 7 == 1) goto cdzFo; else goto cdzFp;
       cdzFo: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdzFp: // global
           I64[Sp] = block_cdzFz_info;
           _sdyBh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdyBh::P64;
           if (R1 & 7 != 0) goto udzFM; else goto cdzFA;
       udzFM: // global
           call _cdzFz(R1) args: 0, res: 0, upd: 0;
       cdzFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzFz() //  [R1]
         { info_tbl: [(cdzFz,
                       label: block_cdzFz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzFz: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdzFL; else goto cdzFK;
       cdzFL: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzFK: // global
           _sdyBj::P64 = P64[R1 + 7];
           _sdyBk::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyBj::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdyBk::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyB4_entry() //  [R1, R2]
         { info_tbl: [(cdzFS,
                       label: go_sdyB4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzFS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdzFT; else goto cdzFU;
       cdzFT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzFU: // global
           I64[Sp - 48] = block_cdzF3_info;
           _sdyB4::P64 = R1;
           _sdyAV::P64 = P64[R1 + 7];
           _sdyAY::P64 = P64[R1 + 15];
           _sdyB2::P64 = P64[R1 + 23];
           _sdyB3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _sdyAV::P64;
           P64[Sp - 32] = _sdyAY::P64;
           P64[Sp - 24] = _sdyB2::P64;
           P64[Sp - 16] = _sdyB3::P64;
           P64[Sp - 8] = _sdyB4::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto udzG7; else goto cdzF4;
       udzG7: // global
           call _cdzF3(R1) args: 0, res: 0, upd: 0;
       cdzF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzF3() //  [R1]
         { info_tbl: [(cdzF3,
                       label: block_cdzF3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzF3: // global
           if (R1 & 7 == 1) goto cdzFP; else goto cdzFQ;
       cdzFP: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzFQ: // global
           I64[Sp - 8] = block_cdzF9_info;
           _sdyB8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyB8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzG6; else goto cdzFa;
       udzG6: // global
           call _cdzF9(R1) args: 0, res: 0, upd: 0;
       cdzFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzF9() //  [R1]
         { info_tbl: [(cdzF9,
                       label: block_cdzF9_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzF9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzG1; else goto cdzG0;
       cdzG1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzG0: // global
           _sdyBa::P64 = P64[R1 + 7];
           _sdyBb::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyBd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdyBa::P64;
           P64[Hp] = Hp - 56;
           _sdyB3::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdzFX_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = P64[Sp + 32];
           P64[Sp + 16] = _sdyB3::P64;
           P64[Sp + 24] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 32] = _sdyBb::P64;
           P64[Sp + 48] = Hp - 23;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdzFX() //  [R1]
         { info_tbl: [(cdzFX,
                       label: block_cdzFX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzFX: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyBd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzGc,
                       label: Data.Functor.Classes.readsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzGc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzGd; else goto cdzGe;
       cdzGd: // global
           R1 = Data.Functor.Classes.readsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdzGe: // global
           I64[Sp - 32] = block_cdzEF_info;
           _sdyAV::P64 = R3;
           R3 = R5;
           _sdyAU::P64 = R2;
           R2 = P64[Sp];
           P64[Sp - 24] = _sdyAV::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = _sdyAU::P64;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzEF() //  [R1]
         { info_tbl: [(cdzEF,
                       label: block_cdzEF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzEF: // global
           if (R1 & 7 == 1) goto cdzG9; else goto cdzGa;
       cdzG9: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzGa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdzGk; else goto cdzGj;
       cdzGk: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzGj: // global
           I64[Hp - 80] = lvl3_sdyB2_info;
           _sdyAW::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sdyAW::P64;
           I64[Hp - 56] = lvl4_sdyB3_info;
           P64[Hp - 40] = _sdyAW::P64;
           I64[Hp - 32] = go_sdyB4_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           _cdzEK::P64 = Hp - 80;
           P64[Hp - 8] = _cdzEK::P64;
           _cdzER::P64 = Hp - 56;
           P64[Hp] = _cdzER::P64;
           _sdyAU::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cdzGh_info;
           R2 = _sdyAU::P64;
           I64[Sp - 8] = stg_ap_pppp_info;
           P64[Sp] = _cdzEK::P64;
           P64[Sp + 8] = _cdzER::P64;
           P64[Sp + 16] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 24] = P64[Sp + 40];
           P64[Sp + 40] = Hp - 31;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdzGh() //  [R1]
         { info_tbl: [(cdzGh,
                       label: block_cdzGh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzGh: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyB4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.69885057 UTC

[section ""data" . Data.Functor.Classes.readPrec1_closure" {
     Data.Functor.Classes.readPrec1_closure:
         const Data.Functor.Classes.readPrec1_info;
 },
 sat_sdyBt_entry() //  [R1]
         { info_tbl: [(cdzGx,
                       label: sat_sdyBt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzGx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzGy; else goto cdzGz;
       cdzGy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzGz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyBs_entry() //  [R1]
         { info_tbl: [(cdzGE,
                       label: sat_sdyBs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzGE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzGF; else goto cdzGG;
       cdzGF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzGG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdzGH,
                       label: Data.Functor.Classes.readPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzGH: // global
           _sdyBr::P64 = R3;
           _sdyBq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzGI; else goto cdzGJ;
       cdzGJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzGL; else goto cdzGK;
       cdzGL: // global
           HpAlloc = 48;
           goto cdzGI;
       cdzGI: // global
           R3 = _sdyBr::P64;
           R2 = _sdyBq::P64;
           R1 = Data.Functor.Classes.readPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzGK: // global
           I64[Hp - 40] = sat_sdyBt_info;
           P64[Hp - 24] = _sdyBr::P64;
           I64[Hp - 16] = sat_sdyBs_info;
           P64[Hp] = _sdyBr::P64;
           R2 = _sdyBq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.701006608 UTC

[section ""data" . Data.Functor.Classes.liftReadListDefault_closure" {
     Data.Functor.Classes.liftReadListDefault_closure:
         const Data.Functor.Classes.liftReadListDefault_info;
 },
 sat_sdyBC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzH2,
                       label: sat_sdyBC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzH2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzH3; else goto cdzH4;
       cdzH3: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzH4: // global
           I64[Sp - 8] = block_cdzGZ_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzGZ() //  [R1]
         { info_tbl: [(cdzGZ,
                       label: block_cdzGZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzGZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzH7; else goto cdzH6;
       cdzH7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzH6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyBx_entry() //  [R1, R2]
         { info_tbl: [(cdzHd,
                       label: sat_sdyBx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyBD_entry() //  [R1]
         { info_tbl: [(cdzHg,
                       label: sat_sdyBD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHg: // global
           _sdyBD::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzHh; else goto cdzHi;
       cdzHi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzHk; else goto cdzHj;
       cdzHk: // global
           HpAlloc = 32;
           goto cdzHh;
       cdzHh: // global
           R1 = _sdyBD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyBD::P64;
           _sdyBu::P64 = P64[_sdyBD::P64 + 16];
           _sdyBv::P64 = P64[_sdyBD::P64 + 24];
           _sdyBw::P64 = P64[_sdyBD::P64 + 32];
           I64[Hp - 24] = sat_sdyBC_info;
           P64[Hp - 16] = _sdyBw::P64;
           I64[Hp - 8] = sat_sdyBx_info;
           P64[Hp] = _sdyBv::P64;
           R2 = _sdyBu::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadListDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzHl,
                       label: Data.Functor.Classes.liftReadListDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzHp; else goto cdzHo;
       cdzHp: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzHo: // global
           I64[Hp - 32] = sat_sdyBD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.703381524 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrecDefault_closure" {
     Data.Functor.Classes.liftReadListPrecDefault_closure:
         const Data.Functor.Classes.liftReadListPrecDefault_info;
         const 0;
 },
 sat_sdyBH_entry() //  [R1]
         { info_tbl: [(cdzHy,
                       label: sat_sdyBH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzHz; else goto cdzHA;
       cdzHz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzHA: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrecDefault_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdzHB,
                       label: Data.Functor.Classes.liftReadListPrecDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzHF; else goto cdzHE;
       cdzHF: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrecDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzHE: // global
           I64[Hp - 32] = sat_sdyBH_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.706488562 UTC

[section ""data" . lvl_rdymy_closure" {
     lvl_rdymy_closure:
         const lvl_rdymy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rdymy_entry() //  [R1]
         { info_tbl: [(cdzHM,
                       label: lvl_rdymy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzHN; else goto cdzHO;
       cdzHN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzHO: // global
           (_cdzHJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdzHJ::I64 == 0) goto cdzHL; else goto cdzHK;
       cdzHL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdzHK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdzHJ::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.707555321 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_entry() //  []
         { info_tbl: [(cdzHT,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzHT: // global
           R1 = lvl_rdymy_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.708595714 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info;
         const 0;
 },
 sat_sdyBN_entry() //  [R1]
         { info_tbl: [(cdzI4,
                       label: sat_sdyBN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzI5; else goto cdzI6;
       cdzI5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzI6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udzIc_srtd" {
     udzIc_srtd:
         const SdyRV_srt+16;
         const 34;
         const 8590000129;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdzI7,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzI7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzIb; else goto cdzIa;
       cdzIb: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzIa: // global
           I64[Hp - 16] = sat_sdyBN_info;
           P64[Hp] = R4;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.710075841 UTC

[section ""data" . lvl1_rdymz_closure" {
     lvl1_rdymz_closure:
         const lvl1_rdymz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdymz_entry() //  [R1]
         { info_tbl: [(cdzIj,
                       label: lvl1_rdymz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzIk; else goto cdzIl;
       cdzIk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzIl: // global
           (_cdzIg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdzIg::I64 == 0) goto cdzIi; else goto cdzIh;
       cdzIi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdzIh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdzIg::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.711138996 UTC

[section ""data" . lvl2_rdymA_closure" {
     lvl2_rdymA_closure:
         const lvl2_rdymA_info;
         const 0;
 },
 lvl2_rdymA_entry() //  [R2]
         { info_tbl: [(cdzIq,
                       label: lvl2_rdymA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIq: // global
           R3 = R2;
           R2 = lvl1_rdymz_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.71198007 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadList_entry() //  [R4]
         { info_tbl: [(cdzIx,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIx: // global
           R2 = R4;
           call lvl2_rdymA_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.712681352 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_closure" {
     Data.Functor.Classes.$fRead1Proxy_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure+3;
         const Data.Functor.Classes.$fRead1Proxy5_closure+4;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.713405725 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_entry() //  [R3]
         { info_tbl: [(cdzIE,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIE: // global
           R2 = R3;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.714541988 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info;
 },
 sat_sdyBX_entry() //  [R1]
         { info_tbl: [(cdzIS,
                       label: sat_sdyBX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzIT; else goto cdzIU;
       cdzIT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzIU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdzIP_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdzIP() //  [R1]
         { info_tbl: [(cdzIP,
                       label: block_cdzIP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzIX; else goto cdzIW;
       cdzIX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdzIW: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdzIY,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzIY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzJ2; else goto cdzJ1;
       cdzJ2: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzJ1: // global
           I64[Hp - 16] = sat_sdyBX_info;
           P64[Hp] = R3;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.716386373 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList2_closure" {
     Data.Functor.Classes.$w$cliftReadList2_closure:
         const Data.Functor.Classes.$w$cliftReadList2_info;
         const 0;
 },
 sat_sdyC3_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzJj,
                       label: sat_sdyC3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzJk; else goto cdzJl;
       cdzJk: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzJl: // global
           I64[Sp - 8] = block_cdzJg_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzJg() //  [R1]
         { info_tbl: [(cdzJg,
                       label: block_cdzJg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzJo; else goto cdzJn;
       cdzJo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzJn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyC4_entry() //  [R1]
         { info_tbl: [(cdzJp,
                       label: sat_sdyC4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJp: // global
           _sdyC4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzJq; else goto cdzJr;
       cdzJr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzJt; else goto cdzJs;
       cdzJt: // global
           HpAlloc = 16;
           goto cdzJq;
       cdzJq: // global
           R1 = _sdyC4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzJs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyC4::P64;
           _sdyBY::P64 = P64[_sdyC4::P64 + 16];
           I64[Hp - 8] = sat_sdyC3_info;
           P64[Hp] = _sdyBY::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadList2_entry() //  [R2]
         { info_tbl: [(cdzJu,
                       label: Data.Functor.Classes.$w$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzJy; else goto cdzJx;
       cdzJy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzJx: // global
           I64[Hp - 16] = sat_sdyC4_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.718170771 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadList_entry() //  [R3]
         { info_tbl: [(cdzJD,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJD: // global
           R2 = R3;
           call Data.Functor.Classes.$w$cliftReadList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.718917836 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_closure" {
     Data.Functor.Classes.$fRead1[]_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.719912503 UTC

[section ""data" . Data.Functor.Classes.showsPrec1_closure" {
     Data.Functor.Classes.showsPrec1_closure:
         const Data.Functor.Classes.showsPrec1_info;
 },
 sat_sdyCa_entry() //  [R1]
         { info_tbl: [(cdzJO,
                       label: sat_sdyCa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzJP; else goto cdzJQ;
       cdzJP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzJQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyC9_entry() //  [R1]
         { info_tbl: [(cdzJV,
                       label: sat_sdyC9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzJW; else goto cdzJX;
       cdzJW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzJX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdzJY,
                       label: Data.Functor.Classes.showsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzJY: // global
           _sdyC8::P64 = R3;
           _sdyC7::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzJZ; else goto cdzK0;
       cdzK0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzK2; else goto cdzK1;
       cdzK2: // global
           HpAlloc = 48;
           goto cdzJZ;
       cdzJZ: // global
           R3 = _sdyC8::P64;
           R2 = _sdyC7::P64;
           R1 = Data.Functor.Classes.showsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzK1: // global
           I64[Hp - 40] = sat_sdyCa_info;
           P64[Hp - 24] = _sdyC8::P64;
           I64[Hp - 16] = sat_sdyC9_info;
           P64[Hp] = _sdyC8::P64;
           R2 = _sdyC7::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.721282193 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith1_closure" {
     Data.Functor.Classes.showsUnaryWith1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.723321836 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary1_closure" {
     Data.Functor.Classes.$wshowsUnary1_closure:
         const Data.Functor.Classes.$wshowsUnary1_info;
 },
 Data.Functor.Classes.$wshowsUnary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzK4: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCi_entry() //  [R1]
         { info_tbl: [(cdzKg,
                       label: sat_sdyCi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzKg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzKh; else goto cdzKi;
       cdzKh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzKi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCh_entry() //  [R1]
         { info_tbl: [(cdzKn,
                       label: sat_sdyCh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzKo; else goto cdzKp;
       cdzKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdyCg_entry() //  [R1]
         { info_tbl: [(cdzKq,
                       label: g_sdyCg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzKq: // global
           _sdyCg::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzKr; else goto cdzKs;
       cdzKs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzKu; else goto cdzKt;
       cdzKu: // global
           HpAlloc = 48;
           goto cdzKr;
       cdzKr: // global
           R1 = _sdyCg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzKt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCg::P64;
           _sdyCb::P64 = P64[_sdyCg::P64 + 16];
           _sdyCc::P64 = P64[_sdyCg::P64 + 24];
           _sdyCf::P64 = P64[_sdyCg::P64 + 32];
           I64[Hp - 40] = sat_sdyCi_info;
           P64[Hp - 24] = _sdyCc::P64;
           I64[Hp - 16] = sat_sdyCh_info;
           P64[Hp] = _sdyCc::P64;
           R2 = _sdyCb::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCf::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCn_entry() //  [R1, R2]
         { info_tbl: [(cdzKF,
                       label: sat_sdyCn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzKF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzKJ; else goto cdzKI;
       cdzKJ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzKI: // global
           _sdyCd::P64 = P64[R1 + 7];
           _sdyCg::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyCd::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCq_entry() //  [R1]
         { info_tbl: [(cdzKZ,
                       label: sat_sdyCq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzKZ: // global
           _sdyCq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzL0; else goto cdzL1;
       cdzL1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzL3; else goto cdzL2;
       cdzL3: // global
           HpAlloc = 24;
           goto cdzL0;
       cdzL0: // global
           R1 = _sdyCq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzL2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCq::P64;
           _sdyCg::P64 = P64[_sdyCq::P64 + 16];
           _sdyCo::P64 = P64[_sdyCq::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyCo::P64;
           R2 = Hp - 14;
           R1 = _sdyCg::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCs_entry() //  [R1]
         { info_tbl: [(cdzL5,
                       label: sat_sdyCs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzL5: // global
           _sdyCs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzL6; else goto cdzL7;
       cdzL7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzL9; else goto cdzL8;
       cdzL9: // global
           HpAlloc = 56;
           goto cdzL6;
       cdzL6: // global
           R1 = _sdyCs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCs::P64;
           _sdyCd::P64 = P64[_sdyCs::P64 + 16];
           _sdyCg::P64 = P64[_sdyCs::P64 + 24];
           _sdyCo::P64 = P64[_sdyCs::P64 + 32];
           I64[Hp - 48] = sat_sdyCq_info;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = _sdyCo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyCd::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCt_entry() //  [R1, R2]
         { info_tbl: [(cdzLb,
                       label: sat_sdyCt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzLf; else goto cdzLe;
       cdzLf: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzLe: // global
           _sdyCd::P64 = P64[R1 + 7];
           _sdyCg::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyCs_info;
           P64[Hp - 40] = _sdyCd::P64;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzLj,
                       label: Data.Functor.Classes.$wshowsUnary1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzLn; else goto cdzLm;
       cdzLn: // global
           HpAlloc = 64;
           R1 = Data.Functor.Classes.$wshowsUnary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdzLm: // global
           I64[Hp - 56] = g_sdyCg_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdzK8::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdzLh; else goto cdzLi;
       cdzLh: // global
           I64[Hp - 16] = sat_sdyCn_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdzK8::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzLi: // global
           I64[Hp - 16] = sat_sdyCt_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdzK8::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.727236848 UTC

[section ""data" . Data.Functor.Classes.showsUnary1_closure" {
     Data.Functor.Classes.showsUnary1_closure:
         const Data.Functor.Classes.showsUnary1_info;
 },
 Data.Functor.Classes.showsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzLv,
                       label: Data.Functor.Classes.showsUnary1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzLw; else goto cdzLx;
       cdzLw: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzLx: // global
           I64[Sp - 40] = block_cdzLs_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udzLB; else goto cdzLt;
       udzLB: // global
           call _cdzLs(R1) args: 0, res: 0, upd: 0;
       cdzLt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzLs() //  [R1]
         { info_tbl: [(cdzLs,
                       label: block_cdzLs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLs: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.730558251 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinary1_closure" {
     Data.Functor.Classes.$wshowsBinary1_closure:
         const Data.Functor.Classes.$wshowsBinary1_info;
 },
 Data.Functor.Classes.$wshowsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLD: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdyCK_entry() //  [R1]
         { info_tbl: [(cdzLP,
                       label: sat_sdyCK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzLQ; else goto cdzLR;
       cdzLQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzLR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCJ_entry() //  [R1]
         { info_tbl: [(cdzLW,
                       label: sat_sdyCJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzLX; else goto cdzLY;
       cdzLX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzLY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdyCI_entry() //  [R1]
         { info_tbl: [(cdzLZ,
                       label: f1_sdyCI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzLZ: // global
           _sdyCI::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzM0; else goto cdzM1;
       cdzM1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzM3; else goto cdzM2;
       cdzM3: // global
           HpAlloc = 48;
           goto cdzM0;
       cdzM0: // global
           R1 = _sdyCI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzM2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCI::P64;
           _sdyCB::P64 = P64[_sdyCI::P64 + 16];
           _sdyCD::P64 = P64[_sdyCI::P64 + 24];
           _sdyCG::P64 = P64[_sdyCI::P64 + 32];
           I64[Hp - 40] = sat_sdyCK_info;
           P64[Hp - 24] = _sdyCD::P64;
           I64[Hp - 16] = sat_sdyCJ_info;
           P64[Hp] = _sdyCD::P64;
           R2 = _sdyCB::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCG::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCN_entry() //  [R1]
         { info_tbl: [(cdzMc,
                       label: sat_sdyCN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzMc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzMd; else goto cdzMe;
       cdzMd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzMe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCM_entry() //  [R1]
         { info_tbl: [(cdzMj,
                       label: sat_sdyCM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzMj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzMk; else goto cdzMl;
       cdzMk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzMl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g1_sdyCL_entry() //  [R1]
         { info_tbl: [(cdzMm,
                       label: g1_sdyCL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzMm: // global
           _sdyCL::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdzMn; else goto cdzMo;
       cdzMo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzMq; else goto cdzMp;
       cdzMq: // global
           HpAlloc = 48;
           goto cdzMn;
       cdzMn: // global
           R1 = _sdyCL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCL::P64;
           _sdyCC::P64 = P64[_sdyCL::P64 + 16];
           _sdyCD::P64 = P64[_sdyCL::P64 + 24];
           _sdyCH::P64 = P64[_sdyCL::P64 + 32];
           I64[Hp - 40] = sat_sdyCN_info;
           P64[Hp - 24] = _sdyCD::P64;
           I64[Hp - 16] = sat_sdyCM_info;
           P64[Hp] = _sdyCD::P64;
           R2 = _sdyCC::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCH::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCS_entry() //  [R1]
         { info_tbl: [(cdzMF,
                       label: sat_sdyCS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzMF: // global
           _sdyCS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzMG; else goto cdzMH;
       cdzMH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzMJ; else goto cdzMI;
       cdzMJ: // global
           HpAlloc = 56;
           goto cdzMG;
       cdzMG: // global
           R1 = _sdyCS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzMI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCS::P64;
           _sdyCI::P64 = P64[_sdyCS::P64 + 16];
           _sdyCL::P64 = P64[_sdyCS::P64 + 24];
           _sdyCP::P64 = P64[_sdyCS::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyCI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCU_entry() //  [R1, R2]
         { info_tbl: [(cdzML,
                       label: sat_sdyCU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzML: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzMP; else goto cdzMO;
       cdzMP: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzMO: // global
           _sdyCE::P64 = P64[R1 + 7];
           _sdyCI::P64 = P64[R1 + 15];
           _sdyCL::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdyCS_info;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyCE::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCX_entry() //  [R1]
         { info_tbl: [(cdzN9,
                       label: sat_sdyCX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzN9: // global
           _sdyCX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzNa; else goto cdzNb;
       cdzNb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzNd; else goto cdzNc;
       cdzNd: // global
           HpAlloc = 24;
           goto cdzNa;
       cdzNa: // global
           R1 = _sdyCX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzNc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCX::P64;
           _sdyCL::P64 = P64[_sdyCX::P64 + 16];
           _sdyCV::P64 = P64[_sdyCX::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyCV::P64;
           R2 = Hp - 14;
           R1 = _sdyCL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCZ_entry() //  [R1]
         { info_tbl: [(cdzNf,
                       label: sat_sdyCZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNf: // global
           _sdyCZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzNg; else goto cdzNh;
       cdzNh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzNj; else goto cdzNi;
       cdzNj: // global
           HpAlloc = 56;
           goto cdzNg;
       cdzNg: // global
           R1 = _sdyCZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzNi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCZ::P64;
           _sdyCI::P64 = P64[_sdyCZ::P64 + 16];
           _sdyCL::P64 = P64[_sdyCZ::P64 + 24];
           _sdyCV::P64 = P64[_sdyCZ::P64 + 32];
           I64[Hp - 48] = sat_sdyCX_info;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyCI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyD1_entry() //  [R1]
         { info_tbl: [(cdzNl,
                       label: sat_sdyD1_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNl: // global
           _sdyD1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzNm; else goto cdzNn;
       cdzNn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzNp; else goto cdzNo;
       cdzNp: // global
           HpAlloc = 64;
           goto cdzNm;
       cdzNm: // global
           R1 = _sdyD1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzNo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyD1::P64;
           _sdyCE::P64 = P64[_sdyD1::P64 + 16];
           _sdyCI::P64 = P64[_sdyD1::P64 + 24];
           _sdyCL::P64 = P64[_sdyD1::P64 + 32];
           _sdyCV::P64 = P64[_sdyD1::P64 + 40];
           I64[Hp - 56] = sat_sdyCZ_info;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyCE::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyD2_entry() //  [R1, R2]
         { info_tbl: [(cdzNr,
                       label: sat_sdyD2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdzNv; else goto cdzNu;
       cdzNv: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzNu: // global
           _sdyCE::P64 = P64[R1 + 7];
           _sdyCI::P64 = P64[R1 + 15];
           _sdyCL::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdyD1_info;
           P64[Hp - 48] = _sdyCE::P64;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinary1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdzNz,
                       label: Data.Functor.Classes.$wshowsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNz: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdzND; else goto cdzNC;
       cdzND: // global
           HpAlloc = 112;
           R1 = Data.Functor.Classes.$wshowsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdzNC: // global
           I64[Hp - 104] = f1_sdyCI_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = P64[Sp];
           I64[Hp - 64] = g1_sdyCL_info;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = P64[Sp + 8];
           _cdzLH::P64 = Hp - 104;
           _cdzM4::P64 = Hp - 64;
           if (%MO_S_Le_W64(R6, 10)) goto cdzNx; else goto cdzNy;
       cdzNx: // global
           I64[Hp - 24] = sat_sdyCU_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdzLH::P64;
           P64[Hp] = _cdzM4::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzNy: // global
           I64[Hp - 24] = sat_sdyD2_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdzLH::P64;
           P64[Hp] = _cdzM4::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.736167817 UTC

[section ""data" . Data.Functor.Classes.showsBinary1_closure" {
     Data.Functor.Classes.showsBinary1_closure:
         const Data.Functor.Classes.showsBinary1_info;
 },
 Data.Functor.Classes.showsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNF: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.showsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.showsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzNM,
                       label: Data.Functor.Classes.showsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzNN; else goto cdzNO;
       cdzNN: // global
           R1 = Data.Functor.Classes.showsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdzNO: // global
           I64[Sp - 40] = block_cdzNJ_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udzNS; else goto cdzNK;
       udzNS: // global
           call _cdzNJ(R1) args: 0, res: 0, upd: 0;
       cdzNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzNJ() //  [R1]
         { info_tbl: [(cdzNJ,
                       label: block_cdzNJ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzNJ: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.738033927 UTC

[section ""data" . Data.Functor.Classes.eq2_closure" {
     Data.Functor.Classes.eq2_closure:
         const Data.Functor.Classes.eq2_info;
 },
 sat_sdyDg_entry() //  [R1]
         { info_tbl: [(cdzO1,
                       label: sat_sdyDg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzO1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzO2; else goto cdzO3;
       cdzO2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzO3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDf_entry() //  [R1]
         { info_tbl: [(cdzO8,
                       label: sat_sdyDf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzO8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzO9; else goto cdzOa;
       cdzO9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzOa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzOb,
                       label: Data.Functor.Classes.eq2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzOf; else goto cdzOe;
       cdzOf: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzOe: // global
           I64[Hp - 40] = sat_sdyDg_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdyDf_info;
           P64[Hp] = R3;
           R3 = Hp - 40;
           _sdyDc::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdyDc::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.739814056 UTC

[section ""data" . Data.Functor.Classes.compare2_closure" {
     Data.Functor.Classes.compare2_closure:
         const Data.Functor.Classes.compare2_info;
 },
 sat_sdyDl_entry() //  [R1]
         { info_tbl: [(cdzOo,
                       label: sat_sdyDl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzOp; else goto cdzOq;
       cdzOp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzOq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDk_entry() //  [R1]
         { info_tbl: [(cdzOv,
                       label: sat_sdyDk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzOw; else goto cdzOx;
       cdzOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzOy,
                       label: Data.Functor.Classes.compare2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOy: // global
           _sdyDj::P64 = R4;
           _sdyDi::P64 = R3;
           _sdyDh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzOz; else goto cdzOA;
       cdzOA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzOC; else goto cdzOB;
       cdzOC: // global
           HpAlloc = 48;
           goto cdzOz;
       cdzOz: // global
           R4 = _sdyDj::P64;
           R3 = _sdyDi::P64;
           R2 = _sdyDh::P64;
           R1 = Data.Functor.Classes.compare2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzOB: // global
           I64[Hp - 40] = sat_sdyDl_info;
           P64[Hp - 24] = _sdyDj::P64;
           I64[Hp - 16] = sat_sdyDk_info;
           P64[Hp] = _sdyDi::P64;
           R2 = _sdyDh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftCompare2_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.741866797 UTC

[section ""data" . Data.Functor.Classes.readsPrec2_closure" {
     Data.Functor.Classes.readsPrec2_closure:
         const Data.Functor.Classes.readsPrec2_info;
 },
 sat_sdyDs_entry() //  [R1]
         { info_tbl: [(cdzOL,
                       label: sat_sdyDs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzOM; else goto cdzON;
       cdzOM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDr_entry() //  [R1]
         { info_tbl: [(cdzOS,
                       label: sat_sdyDr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzOT; else goto cdzOU;
       cdzOT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzOU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDq_entry() //  [R1]
         { info_tbl: [(cdzOZ,
                       label: sat_sdyDq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzOZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzP0; else goto cdzP1;
       cdzP0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzP1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDp_entry() //  [R1]
         { info_tbl: [(cdzP6,
                       label: sat_sdyDp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzP6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzP7; else goto cdzP8;
       cdzP7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzP8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzP9,
                       label: Data.Functor.Classes.readsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzP9: // global
           _sdyDo::P64 = R4;
           _sdyDn::P64 = R3;
           _sdyDm::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzPa; else goto cdzPb;
       cdzPb: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdzPd; else goto cdzPc;
       cdzPd: // global
           HpAlloc = 96;
           goto cdzPa;
       cdzPa: // global
           R4 = _sdyDo::P64;
           R3 = _sdyDn::P64;
           R2 = _sdyDm::P64;
           R1 = Data.Functor.Classes.readsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzPc: // global
           I64[Hp - 88] = sat_sdyDs_info;
           P64[Hp - 72] = _sdyDo::P64;
           I64[Hp - 64] = sat_sdyDr_info;
           P64[Hp - 48] = _sdyDo::P64;
           I64[Hp - 40] = sat_sdyDq_info;
           P64[Hp - 24] = _sdyDn::P64;
           I64[Hp - 16] = sat_sdyDp_info;
           P64[Hp] = _sdyDn::P64;
           R2 = _sdyDm::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.744423101 UTC

[section ""data" . Data.Functor.Classes.readPrec2_closure" {
     Data.Functor.Classes.readPrec2_closure:
         const Data.Functor.Classes.readPrec2_info;
 },
 sat_sdyDz_entry() //  [R1]
         { info_tbl: [(cdzPm,
                       label: sat_sdyDz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzPm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzPn; else goto cdzPo;
       cdzPn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDy_entry() //  [R1]
         { info_tbl: [(cdzPt,
                       label: sat_sdyDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzPt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzPu; else goto cdzPv;
       cdzPu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzPv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDx_entry() //  [R1]
         { info_tbl: [(cdzPA,
                       label: sat_sdyDx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzPA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzPB; else goto cdzPC;
       cdzPB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzPC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDw_entry() //  [R1]
         { info_tbl: [(cdzPH,
                       label: sat_sdyDw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzPH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzPI; else goto cdzPJ;
       cdzPI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzPJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzPK,
                       label: Data.Functor.Classes.readPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzPK: // global
           _sdyDv::P64 = R4;
           _sdyDu::P64 = R3;
           _sdyDt::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzPL; else goto cdzPM;
       cdzPM: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdzPO; else goto cdzPN;
       cdzPO: // global
           HpAlloc = 96;
           goto cdzPL;
       cdzPL: // global
           R4 = _sdyDv::P64;
           R3 = _sdyDu::P64;
           R2 = _sdyDt::P64;
           R1 = Data.Functor.Classes.readPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzPN: // global
           I64[Hp - 88] = sat_sdyDz_info;
           P64[Hp - 72] = _sdyDv::P64;
           I64[Hp - 64] = sat_sdyDy_info;
           P64[Hp - 48] = _sdyDv::P64;
           I64[Hp - 40] = sat_sdyDx_info;
           P64[Hp - 24] = _sdyDu::P64;
           I64[Hp - 16] = sat_sdyDw_info;
           P64[Hp] = _sdyDu::P64;
           R2 = _sdyDt::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.747734999 UTC

[section ""data" . Data.Functor.Classes.liftReadList2Default_closure" {
     Data.Functor.Classes.liftReadList2Default_closure:
         const Data.Functor.Classes.liftReadList2Default_info;
 },
 sat_sdyDQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzQ5,
                       label: sat_sdyDQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQ5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzQ6; else goto cdzQ7;
       cdzQ6: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzQ7: // global
           I64[Sp - 8] = block_cdzQ2_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzQ2() //  [R1]
         { info_tbl: [(cdzQ2,
                       label: block_cdzQ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQ2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzQa; else goto cdzQ9;
       cdzQa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzQ9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDL_entry() //  [R1, R2]
         { info_tbl: [(cdzQg,
                       label: sat_sdyDL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQg: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDK_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzQr,
                       label: sat_sdyDK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzQs; else goto cdzQt;
       cdzQs: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzQt: // global
           I64[Sp - 8] = block_cdzQo_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzQo() //  [R1]
         { info_tbl: [(cdzQo,
                       label: block_cdzQo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzQw; else goto cdzQv;
       cdzQw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzQv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDF_entry() //  [R1, R2]
         { info_tbl: [(cdzQC,
                       label: sat_sdyDF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDR_entry() //  [R1]
         { info_tbl: [(cdzQF,
                       label: sat_sdyDR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQF: // global
           _sdyDR::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto cdzQG; else goto cdzQH;
       cdzQH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdzQJ; else goto cdzQI;
       cdzQJ: // global
           HpAlloc = 64;
           goto cdzQG;
       cdzQG: // global
           R1 = _sdyDR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzQI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyDR::P64;
           _sdyDA::P64 = P64[_sdyDR::P64 + 16];
           _sdyDB::P64 = P64[_sdyDR::P64 + 24];
           _sdyDC::P64 = P64[_sdyDR::P64 + 32];
           _sdyDD::P64 = P64[_sdyDR::P64 + 40];
           _sdyDE::P64 = P64[_sdyDR::P64 + 48];
           I64[Hp - 56] = sat_sdyDQ_info;
           P64[Hp - 48] = _sdyDE::P64;
           I64[Hp - 40] = sat_sdyDL_info;
           P64[Hp - 32] = _sdyDD::P64;
           I64[Hp - 24] = sat_sdyDK_info;
           P64[Hp - 16] = _sdyDC::P64;
           I64[Hp - 8] = sat_sdyDF_info;
           P64[Hp] = _sdyDB::P64;
           R2 = _sdyDA::P64;
           I64[Sp - 72] = stg_ap_pppppp_info;
           P64[Sp - 64] = Hp - 7;
           P64[Sp - 56] = Hp - 22;
           P64[Sp - 48] = Hp - 39;
           P64[Sp - 40] = Hp - 54;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 72;
           call Data.Functor.Classes.liftReadListPrec2_entry(R2) args: 80, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadList2Default_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdzQK,
                       label: Data.Functor.Classes.liftReadList2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzQO; else goto cdzQN;
       cdzQO: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzQN: // global
           I64[Hp - 48] = sat_sdyDR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.750696048 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_closure" {
     Data.Functor.Classes.$fRead2Either_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Either8_closure+6;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadList2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdzQT,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQT: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Either_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.751770972 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_closure" {
     Data.Functor.Classes.$fRead2Const_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Const6_closure+6;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadList2_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdzR0,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzR0: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Const_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.752819641 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_closure" {
     Data.Functor.Classes.$fRead2(,)_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1(,)2_closure+6;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadList2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdzR7,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzR7: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2(,)_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.754147823 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2Default_closure" {
     Data.Functor.Classes.liftReadListPrec2Default_closure:
         const Data.Functor.Classes.liftReadListPrec2Default_info;
         const 0;
 },
 sat_sdyDX_entry() //  [R1]
         { info_tbl: [(cdzRi,
                       label: sat_sdyDX_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzRi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdzRj; else goto cdzRk;
       cdzRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzRk: // global
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           P64[Sp - 16] = P64[R1 + 40];
           P64[Sp - 8] = P64[R1 + 48];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrec2Default_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cdzRl,
                       label: Data.Functor.Classes.liftReadListPrec2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzRl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzRp; else goto cdzRo;
       cdzRp: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzRo: // global
           I64[Hp - 48] = sat_sdyDX_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.755730577 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)1_closure" {
     Data.Functor.Classes.$fRead1(,)1_closure:
         const Data.Functor.Classes.$fRead1(,)1_info;
         const 0;
 },
 sat_sdyE3_entry() //  [R1]
         { info_tbl: [(cdzRy,
                       label: sat_sdyE3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzRy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzRz; else goto cdzRA;
       cdzRz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzRA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzRB,
                       label: Data.Functor.Classes.$fRead1(,)1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzRB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzRF; else goto cdzRE;
       cdzRF: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzRE: // global
           I64[Hp - 16] = sat_sdyE3_info;
           P64[Hp] = R2;
           _sdyE1::P64 = R5;
           R5 = R6;
           R4 = _sdyE1::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.759418314 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec_info;
         const 0;
 },
 sat_sdyE8_entry() //  [R1, R2]
         { info_tbl: [(cdzRT,
                       label: sat_sdyE8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzRT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyE7_entry() //  [R1]
         { info_tbl: [(cdzS0,
                       label: sat_sdyE7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzS0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzS1; else goto cdzS2;
       cdzS1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzS2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyE9_entry() //  [R1]
         { info_tbl: [(cdzS3,
                       label: sat_sdyE9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzS3: // global
           _sdyE9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzS4; else goto cdzS5;
       cdzS5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzS7; else goto cdzS6;
       cdzS7: // global
           HpAlloc = 40;
           goto cdzS4;
       cdzS4: // global
           R1 = _sdyE9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzS6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyE9::P64;
           _sdyE4::P64 = P64[_sdyE9::P64 + 16];
           _sdyE5::P64 = P64[_sdyE9::P64 + 24];
           _sdyE6::P64 = P64[_sdyE9::P64 + 32];
           I64[Hp - 32] = sat_sdyE8_info;
           P64[Hp - 24] = _sdyE5::P64;
           I64[Hp - 16] = sat_sdyE7_info;
           P64[Hp] = _sdyE4::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyE6::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzS8,
                       label: Data.Functor.Classes.$w$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzS8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzSc; else goto cdzSb;
       cdzSc: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzSb: // global
           I64[Hp - 32] = sat_sdyE9_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.761260055 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_entry() //  [R2,
                                                              R3, R5]
         { info_tbl: [(cdzSh,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzSh: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.76234262 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyEh_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzSt,
                       label: sat_sdyEh_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzSt: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdzSw,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzSw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzSA; else goto cdzSz;
       cdzSA: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzSz: // global
           I64[Hp - 24] = sat_sdyEh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 22;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.764365642 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_closure" {
     Data.Functor.Classes.$fRead1(,)_closure:
         const Data.Functor.Classes.$fRead1(,)_info;
         const 0;
 },
 sat_sdyEp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzSK,
                       label: sat_sdyEp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzSK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEo_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdzSS,
                       label: sat_sdyEo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzSS: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEn_entry() //  [R1]
         { info_tbl: [(cdzSZ,
                       label: sat_sdyEn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzSZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzT0; else goto cdzT1;
       cdzT0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzT1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEm_entry() //  [R1, R2, R4]
         { info_tbl: [(cdzT7,
                       label: sat_sdyEm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzT7: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_entry() //  [R2]
         { info_tbl: [(cdzTb,
                       label: Data.Functor.Classes.$fRead1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTb: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdzTf; else goto cdzTe;
       cdzTf: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzTe: // global
           I64[Hp - 104] = sat_sdyEp_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdyEo_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyEn_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyEm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_info;
         const 0;
 },
 sat_sdyEr_entry() //  [R1]
         { info_tbl: [(cdzTo,
                       label: sat_sdyEr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzTp; else goto cdzTq;
       cdzTp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzTq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdzTr,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzTv; else goto cdzTu;
       cdzTv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzTu: // global
           I64[Hp - 16] = sat_sdyEr_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.767438093 UTC

[section ""data" . Data.Functor.Classes.showsPrec2_closure" {
     Data.Functor.Classes.showsPrec2_closure:
         const Data.Functor.Classes.showsPrec2_info;
 },
 sat_sdyEy_entry() //  [R1]
         { info_tbl: [(cdzTE,
                       label: sat_sdyEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzTF; else goto cdzTG;
       cdzTF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzTG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEx_entry() //  [R1]
         { info_tbl: [(cdzTL,
                       label: sat_sdyEx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzTM; else goto cdzTN;
       cdzTM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzTN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEw_entry() //  [R1]
         { info_tbl: [(cdzTS,
                       label: sat_sdyEw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzTT; else goto cdzTU;
       cdzTT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzTU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEv_entry() //  [R1]
         { info_tbl: [(cdzTZ,
                       label: sat_sdyEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzTZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzU0; else goto cdzU1;
       cdzU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzU1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzU2,
                       label: Data.Functor.Classes.showsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzU2: // global
           _sdyEu::P64 = R4;
           _sdyEt::P64 = R3;
           _sdyEs::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdzU3; else goto cdzU4;
       cdzU4: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdzU6; else goto cdzU5;
       cdzU6: // global
           HpAlloc = 96;
           goto cdzU3;
       cdzU3: // global
           R4 = _sdyEu::P64;
           R3 = _sdyEt::P64;
           R2 = _sdyEs::P64;
           R1 = Data.Functor.Classes.showsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzU5: // global
           I64[Hp - 88] = sat_sdyEy_info;
           P64[Hp - 72] = _sdyEu::P64;
           I64[Hp - 64] = sat_sdyEx_info;
           P64[Hp - 48] = _sdyEu::P64;
           I64[Hp - 40] = sat_sdyEw_info;
           P64[Hp - 24] = _sdyEt::P64;
           I64[Hp - 16] = sat_sdyEv_info;
           P64[Hp] = _sdyEt::P64;
           R2 = _sdyEs::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.770595203 UTC

[section ""data" . Data.Functor.Classes.$wreadsData_closure" {
     Data.Functor.Classes.$wreadsData_closure:
         const Data.Functor.Classes.$wreadsData_info;
         const 0;
 },
 sat_sdyEL_entry() //  [R1]
         { info_tbl: [(cdzUv,
                       label: sat_sdyEL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUv: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sdyEC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyEC_entry() //  [R1, R2]
         { info_tbl: [(cdzUC,
                       label: go_sdyEC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzUD; else goto cdzUE;
       cdzUD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzUE: // global
           I64[Sp - 24] = block_cdzUg_info;
           _sdyEC::P64 = R1;
           _sdyEz::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyEz::P64;
           P64[Sp - 8] = _sdyEC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udzUR; else goto cdzUh;
       udzUR: // global
           call _cdzUg(R1) args: 0, res: 0, upd: 0;
       cdzUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzUg() //  [R1]
         { info_tbl: [(cdzUg,
                       label: block_cdzUg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUg: // global
           if (R1 & 7 == 1) goto cdzUz; else goto cdzUA;
       cdzUz: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzUA: // global
           I64[Sp - 8] = block_cdzUm_info;
           _sdyEG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyEG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzUQ; else goto cdzUn;
       udzUQ: // global
           call _cdzUm(R1) args: 0, res: 0, upd: 0;
       cdzUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzUm() //  [R1]
         { info_tbl: [(cdzUm,
                       label: block_cdzUm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzUL; else goto cdzUK;
       cdzUL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzUK: // global
           _sdyEI::P64 = P64[R1 + 7];
           _sdyEJ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdyEL_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _sdyEz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdzUH_info;
           R3 = _sdyEJ::P64;
           R2 = _sdyEI::P64;
           R1 = _sdyEz::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzUH() //  [R1]
         { info_tbl: [(cdzUH,
                       label: block_cdzUH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUH: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEQ_entry() //  [R1, R2]
         { info_tbl: [(cdzUZ,
                       label: sat_sdyEQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzV0; else goto cdzV1;
       cdzV0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzV1: // global
           I64[Sp - 16] = block_cdzUX_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzUX() //  [R1]
         { info_tbl: [(cdzUX,
                       label: block_cdzUX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzUX: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyEC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udzVc_srtd" {
     udzVc_srtd:
         const SdyRV_srt+120;
         const 36;
         const 51539607553;
 },
 Data.Functor.Classes.$wreadsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzV7,
                       label: Data.Functor.Classes.$wreadsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzV7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzVb; else goto cdzVa;
       cdzVb: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzVa: // global
           I64[Hp - 24] = go_sdyEC_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyEQ_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sdyEN::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sdyEN::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.773571054 UTC

[section ""data" . Data.Functor.Classes.readsData_closure" {
     Data.Functor.Classes.readsData_closure:
         const Data.Functor.Classes.readsData_info;
         const 0;
 },
 Data.Functor.Classes.readsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzVk,
                       label: Data.Functor.Classes.readsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzVk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzVl; else goto cdzVm;
       cdzVl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzVm: // global
           I64[Sp - 24] = block_cdzVh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udzVq; else goto cdzVi;
       udzVq: // global
           call _cdzVh(R1) args: 0, res: 0, upd: 0;
       cdzVi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzVh() //  [R1]
         { info_tbl: [(cdzVh,
                       label: block_cdzVh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzVh: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wreadsData_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.774632796 UTC

[section ""data" . Data.Functor.Classes.readData2_closure" {
     Data.Functor.Classes.readData2_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.775837175 UTC

[section ""data" . Data.Functor.Classes.readData1_closure" {
     Data.Functor.Classes.readData1_closure:
         const Data.Functor.Classes.readData1_info;
         const 0;
 },
 lvl3_sdyEZ_entry() //  [R1]
         { info_tbl: [(cdzVz,
                       label: lvl3_sdyEZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzVz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzVA; else goto cdzVB;
       cdzVA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzVB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.readData2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyF4_entry() //  [R1, R2]
         { info_tbl: [(cdzVK,
                       label: sat_sdyF4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzVK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzVL; else goto cdzVM;
       cdzVL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzVM: // global
           I64[Sp - 16] = block_cdzVH_info;
           _sdyEZ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdyEZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udzVV; else goto cdzVI;
       udzVV: // global
           call _cdzVH(R1) args: 0, res: 0, upd: 0;
       cdzVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzVH() //  [R1]
         { info_tbl: [(cdzVH,
                       label: block_cdzVH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzVH: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdzVT; else goto cdzVU;
       cdzVT: // global
           R1 = Text.ParserCombinators.ReadP.$fAlternativeReadP4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzVU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readData1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzVW,
                       label: Data.Functor.Classes.readData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzVW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzW0; else goto cdzVZ;
       cdzW0: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readData1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzVZ: // global
           I64[Hp - 32] = lvl3_sdyEZ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyF4_info;
           P64[Hp] = Hp - 32;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.77760249 UTC

[section ""data" . Data.Functor.Classes.readData_closure" {
     Data.Functor.Classes.readData_closure:
         const Data.Functor.Classes.readData_info;
         const 0;
 },
 Data.Functor.Classes.readData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzW5,
                       label: Data.Functor.Classes.readData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzW5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readData1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.779225661 UTC

[section ""data" . Data.Functor.Classes.readsUnaryWith_closure" {
     Data.Functor.Classes.readsUnaryWith_closure:
         const Data.Functor.Classes.readsUnaryWith_info;
 },
 go_sdyFb_entry() //  [R1, R2]
         { info_tbl: [(cdzWt,
                       label: go_sdyFb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzWt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzWu; else goto cdzWv;
       cdzWu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzWv: // global
           I64[Sp - 24] = block_cdzWm_info;
           _sdyFb::P64 = R1;
           _sdyF7::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyF7::P64;
           P64[Sp - 8] = _sdyFb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udzWP; else goto cdzWn;
       udzWP: // global
           call _cdzWm(R1) args: 0, res: 0, upd: 0;
       cdzWn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzWm() //  [R1]
         { info_tbl: [(cdzWm,
                       label: block_cdzWm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzWm: // global
           if (R1 & 7 == 1) goto cdzWq; else goto cdzWr;
       cdzWq: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzWr: // global
           I64[Sp - 8] = block_cdzWB_info;
           _sdyFf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyFf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udzWO; else goto cdzWC;
       udzWO: // global
           call _cdzWB(R1) args: 0, res: 0, upd: 0;
       cdzWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzWB() //  [R1]
         { info_tbl: [(cdzWB,
                       label: block_cdzWB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzWB: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdzWN; else goto cdzWM;
       cdzWN: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzWM: // global
           _sdyFh::P64 = P64[R1 + 7];
           _sdyFi::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyFh::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyFi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdzWU,
                       label: Data.Functor.Classes.readsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzWU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdzWV; else goto cdzWW;
       cdzWV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzWW: // global
           I64[Sp - 32] = block_cdzWc_info;
           R3 = R3;
           _sdyF5::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdyF5::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzWc() //  [R1]
         { info_tbl: [(cdzWc,
                       label: block_cdzWc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzWc: // global
           if (R1 & 7 == 1) goto cdzWR; else goto cdzWS;
       cdzWR: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdzWS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzX2; else goto cdzX1;
       cdzX2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzX1: // global
           I64[Hp - 8] = go_sdyFb_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdzWZ_info;
           R3 = P64[Sp + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdzWZ() //  [R1]
         { info_tbl: [(cdzWZ,
                       label: block_cdzWZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzWZ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyFb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.782389039 UTC

[section ""data" . Data.Functor.Classes.$wreadUnaryWith_closure" {
     Data.Functor.Classes.$wreadUnaryWith_closure:
         const Data.Functor.Classes.$wreadUnaryWith_info;
         const 0;
 },
 sat_sdyFA_entry() //  [R1, R2]
         { info_tbl: [(cdzXm,
                       label: sat_sdyFA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzXm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzXq; else goto cdzXp;
       cdzXq: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzXp: // global
           _sdyFp::P64 = P64[R1 + 7];
           _sdyFr::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdyFp::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdyFr::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyFx_entry() //  [R1]
         { info_tbl: [(cdzXy,
                       label: sat_sdyFx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzXy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdzXF; else goto cdzXG;
       cdzXF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzXG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdzXv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udzXK; else goto cdzXw;
       udzXK: // global
           call _cdzXv(R1) args: 0, res: 0, upd: 0;
       cdzXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdzXv() //  [R1]
         { info_tbl: [(cdzXv,
                       label: block_cdzXv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzXv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzXJ; else goto cdzXI;
       cdzXJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdzXI: // global
           _sdyFw::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdyFw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyFB_entry() //  [R1, R2]
         { info_tbl: [(cdzXL,
                       label: sat_sdyFB_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzXL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdzXP; else goto cdzXO;
       cdzXP: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzXO: // global
           _sdyFn::P64 = P64[R1 + 7];
           _sdyFp::P64 = P64[R1 + 15];
           _sdyFq::P64 = P64[R1 + 23];
           _sdyFr::P64 = P64[R1 + 31];
           I64[Hp - 40] = sat_sdyFA_info;
           P64[Hp - 32] = _sdyFp::P64;
           P64[Hp - 24] = _sdyFr::P64;
           I64[Hp - 16] = sat_sdyFx_info;
           P64[Hp] = _sdyFq::P64;
           R3 = Hp - 39;
           R2 = Hp - 16;
           R1 = _sdyFn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadUnaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdzXR,
                       label: Data.Functor.Classes.$wreadUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzXR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdzXV; else goto cdzXU;
       cdzXV: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzXU: // global
           I64[Hp - 48] = sat_sdyFB_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R3;
           R3 = Hp - 47;
           R2 = Hp - 4;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.784736637 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith1_closure" {
     Data.Functor.Classes.readUnaryWith1_closure:
         const Data.Functor.Classes.readUnaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdzY3,
                       label: Data.Functor.Classes.readUnaryWith1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzY3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdzY4; else goto cdzY5;
       cdzY4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readUnaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzY5: // global
           I64[Sp - 8] = block_cdzY0_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadUnaryWith_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdzY0() //  [R1]
         { info_tbl: [(cdzY0,
                       label: block_cdzY0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzY0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdzY8; else goto cdzY7;
       cdzY8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdzY7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.78618855 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith_closure" {
     Data.Functor.Classes.readUnaryWith_closure:
         const Data.Functor.Classes.readUnaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzYd,
                       label: Data.Functor.Classes.readUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readUnaryWith1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.78729513 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const5_closure" {
     Data.Functor.Classes.$fRead1Const5_closure:
         const Data.Functor.Classes.$fRead1Const5_info;
         const 0;
 },
 sat_sdyFO_entry() //  [R1]
         { info_tbl: [(cdzYo,
                       label: sat_sdyFO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzYp; else goto cdzYq;
       cdzYp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzYq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdzYr,
                       label: Data.Functor.Classes.$fRead1Const5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzYv; else goto cdzYu;
       cdzYv: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzYu: // global
           I64[Hp - 16] = sat_sdyFO_info;
           P64[Hp] = R2;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.788894052 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec1_info;
         const 0;
 },
 sat_sdyFR_entry() //  [R1]
         { info_tbl: [(cdzYI,
                       label: sat_sdyFR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzYJ; else goto cdzYK;
       cdzYJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzYK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyFS_entry() //  [R1]
         { info_tbl: [(cdzYL,
                       label: sat_sdyFS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYL: // global
           _sdyFS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzYM; else goto cdzYN;
       cdzYN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzYP; else goto cdzYO;
       cdzYP: // global
           HpAlloc = 24;
           goto cdzYM;
       cdzYM: // global
           R1 = _sdyFS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzYO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyFS::P64;
           _sdyFP::P64 = P64[_sdyFS::P64 + 16];
           _sdyFQ::P64 = P64[_sdyFS::P64 + 24];
           I64[Hp - 16] = sat_sdyFR_info;
           P64[Hp] = _sdyFP::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyFQ::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdzYQ,
                       label: Data.Functor.Classes.$w$cliftReadsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzYU; else goto cdzYT;
       cdzYU: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzYT: // global
           I64[Hp - 24] = sat_sdyFS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.79056009 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_entry() //  [R2,
                                                                R5]
         { info_tbl: [(cdzYZ,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzYZ: // global
           R3 = R5;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.791753341 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec_info;
         const 0;
 },
 w1_sdyFY_entry() //  [R1]
         { info_tbl: [(cdzZa,
                       label: w1_sdyFY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzZb; else goto cdzZc;
       cdzZb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzZc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyG1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdzZi,
                       label: sat_sdyG1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdzZl,
                       label: Data.Functor.Classes.$w$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdzZp; else goto cdzZo;
       cdzZp: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzZo: // global
           I64[Hp - 32] = w1_sdyFY_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyG1_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.793188979 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdzZu,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZu: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.794966124 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_closure" {
     Data.Functor.Classes.$fRead1Const_closure:
         const Data.Functor.Classes.$fRead1Const_info;
         const 0;
 },
 lvl3_sdyG6_entry() //  [R1]
         { info_tbl: [(cdzZF,
                       label: lvl3_sdyG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdzZG; else goto cdzZH;
       cdzZG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdzZH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGf_entry() //  [R1]
         { info_tbl: [(cdzZN,
                       label: sat_sdyGf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZN: // global
           R1 = P64[R1 + 6];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGc_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdzZV,
                       label: sat_sdyGc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzZV: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Const5_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGb_entry() //  [R1]
         { info_tbl: [(cdA02,
                       label: sat_sdyGb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA02: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA03; else goto cdA04;
       cdA03: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA04: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGa_entry() //  [R1, R4]
         { info_tbl: [(cdA0a,
                       label: sat_sdyGa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA0a: // global
           R3 = R4;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Const_entry() //  [R2]
         { info_tbl: [(cdA0e,
                       label: Data.Functor.Classes.$fRead1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA0e: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdA0i; else goto cdA0h;
       cdA0i: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA0h: // global
           I64[Hp - 128] = lvl3_sdyG6_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sdyGf_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sdyGc_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyGb_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyGa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_info;
         const 0;
 },
 sat_sdyGh_entry() //  [R1]
         { info_tbl: [(cdA0r,
                       label: sat_sdyGh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA0r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA0s; else goto cdA0t;
       cdA0s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA0t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdA0u,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA0u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA0y; else goto cdA0x;
       cdA0y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA0x: // global
           I64[Hp - 16] = sat_sdyGh_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.797913161 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either7_closure" {
     Data.Functor.Classes.$fRead1Either7_closure:
         const Data.Functor.Classes.$fRead1Either7_info;
         const 0;
 },
 sat_sdyGn_entry() //  [R1]
         { info_tbl: [(cdA0H,
                       label: sat_sdyGn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA0H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA0I; else goto cdA0J;
       cdA0I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA0J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either7_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdA0K,
                       label: Data.Functor.Classes.$fRead1Either7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA0K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA0O; else goto cdA0N;
       cdA0O: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either7_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA0N: // global
           I64[Hp - 16] = sat_sdyGn_info;
           P64[Hp] = R2;
           _sdyGl::P64 = R5;
           R5 = R6;
           R4 = _sdyGl::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.799711615 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec2_info;
         const 0;
 },
 sat_sdyGs_entry() //  [R1, R2]
         { info_tbl: [(cdA12,
                       label: sat_sdyGs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA12: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGr_entry() //  [R1]
         { info_tbl: [(cdA19,
                       label: sat_sdyGr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA19: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA1a; else goto cdA1b;
       cdA1a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA1b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGt_entry() //  [R1]
         { info_tbl: [(cdA1c,
                       label: sat_sdyGt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1c: // global
           _sdyGt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdA1d; else goto cdA1e;
       cdA1e: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdA1g; else goto cdA1f;
       cdA1g: // global
           HpAlloc = 40;
           goto cdA1d;
       cdA1d: // global
           R1 = _sdyGt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA1f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyGt::P64;
           _sdyGo::P64 = P64[_sdyGt::P64 + 16];
           _sdyGp::P64 = P64[_sdyGt::P64 + 24];
           _sdyGq::P64 = P64[_sdyGt::P64 + 32];
           I64[Hp - 32] = sat_sdyGs_info;
           P64[Hp - 24] = _sdyGp::P64;
           I64[Hp - 16] = sat_sdyGr_info;
           P64[Hp] = _sdyGo::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyGq::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdA1h,
                       label: Data.Functor.Classes.$w$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1h: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdA1l; else goto cdA1k;
       cdA1l: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA1k: // global
           I64[Hp - 32] = sat_sdyGt_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.80155175 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_entry() //  [R2,
                                                                 R3, R5]
         { info_tbl: [(cdA1q,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1q: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.802753238 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec1_info;
         const 0;
 },
 w2_sdyGA_entry() //  [R1]
         { info_tbl: [(cdA1B,
                       label: w2_sdyGA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA1C; else goto cdA1D;
       cdA1C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA1D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA1J,
                       label: sat_sdyGD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1J: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdA1M,
                       label: Data.Functor.Classes.$w$cliftReadListPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1M: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdA1Q; else goto cdA1P;
       cdA1Q: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA1P: // global
           I64[Hp - 40] = w2_sdyGA_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyGD_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.804257064 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cdA1V,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA1V: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.805995017 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_closure" {
     Data.Functor.Classes.$fRead1Either_closure:
         const Data.Functor.Classes.$fRead1Either_info;
         const 0;
 },
 sat_sdyGQ_entry() //  [R1, R2]
         { info_tbl: [(cdA27,
                       label: sat_sdyGQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA27: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGN_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdA2f,
                       label: sat_sdyGN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2f: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Either7_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGM_entry() //  [R1]
         { info_tbl: [(cdA2m,
                       label: sat_sdyGM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA2n; else goto cdA2o;
       cdA2n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA2o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGL_entry() //  [R1, R2, R4]
         { info_tbl: [(cdA2u,
                       label: sat_sdyGL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2u: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Either_entry() //  [R2]
         { info_tbl: [(cdA2y,
                       label: Data.Functor.Classes.$fRead1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2y: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdA2C; else goto cdA2B;
       cdA2C: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA2B: // global
           I64[Hp - 104] = sat_sdyGQ_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdyGN_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyGM_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyGL_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_info;
         const 0;
 },
 sat_sdyGS_entry() //  [R1]
         { info_tbl: [(cdA2L,
                       label: sat_sdyGS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA2M; else goto cdA2N;
       cdA2M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA2N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdA2O,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA2S; else goto cdA2R;
       cdA2S: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA2R: // global
           I64[Hp - 16] = sat_sdyGS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.808359798 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Identity4_bytes" {
     Data.Functor.Classes.$fRead1Identity4_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.809173488 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity3_closure" {
     Data.Functor.Classes.$fRead1Identity3_closure:
         const Data.Functor.Classes.$fRead1Identity3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity3_entry() //  [R1]
         { info_tbl: [(cdA2Z,
                       label: Data.Functor.Classes.$fRead1Identity3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA2Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA30; else goto cdA31;
       cdA30: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA31: // global
           (_cdA2W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdA2W::I64 == 0) goto cdA2Y; else goto cdA2X;
       cdA2Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdA2X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdA2W::I64;
           R2 = Data.Functor.Classes.$fRead1Identity4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.810328715 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity2_closure" {
     Data.Functor.Classes.$fRead1Identity2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.813715725 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec_closure" {
     Data.Functor.Classes.$w$cliftReadPrec_closure:
         const Data.Functor.Classes.$w$cliftReadPrec_info;
         const 0;
 },
 sat_sdyH3_entry() //  [R1, R2]
         { info_tbl: [(cdA3u,
                       label: sat_sdyH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA3u: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyH4_entry() //  [R1, R2]
         { info_tbl: [(cdA3x,
                       label: sat_sdyH4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA3x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA3B; else goto cdA3A;
       cdA3B: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA3A: // global
           _sdyGT::P64 = P64[R1 + 7];
           _sdyGX::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyH3_info;
           P64[Hp] = _sdyGX::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyGT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyH7_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA3C,
                       label: sat_sdyH7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA3C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdA3D; else goto cdA3E;
       cdA3D: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA3E: // global
           I64[Sp - 24] = block_cdA3b_info;
           _sdyGT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyGT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udA3R; else goto cdA3c;
       udA3R: // global
           call _cdA3b(R1) args: 0, res: 0, upd: 0;
       cdA3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdA3b() //  [R1]
         { info_tbl: [(cdA3b,
                       label: block_cdA3b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA3b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA3H; else goto cdA3G;
       cdA3H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA3G: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdA3J; else goto cdA3N;
       cdA3J: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdA3N: // global
           I64[Hp - 16] = sat_sdyH4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdA3K_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdA3K() //  [R1]
         { info_tbl: [(cdA3K,
                       label: block_cdA3K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA3K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA3Q; else goto cdA3P;
       cdA3Q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA3P: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdA3S,
                       label: Data.Functor.Classes.$w$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA3S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA3W; else goto cdA3V;
       cdA3W: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA3V: // global
           I64[Hp - 8] = sat_sdyH7_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.816078964 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity1_closure" {
     Data.Functor.Classes.$fRead1Identity1_closure:
         const Data.Functor.Classes.$fRead1Identity1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdA41,
                       label: Data.Functor.Classes.$fRead1Identity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA41: // global
           _sdyHa::P64 = R4;
           R4 = R5;
           R3 = _sdyHa::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.818896764 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec3_info;
         const 0;
 },
 lvl3_sdyHe_entry() //  [R1]
         { info_tbl: [(cdA4g,
                       label: lvl3_sdyHe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA4g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA4h; else goto cdA4i;
       cdA4h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA4i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyHm_entry() //  [R1, R2]
         { info_tbl: [(cdA4H,
                       label: sat_sdyHm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA4H: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHp_entry() //  [R1, R2]
         { info_tbl: [(cdA4N,
                       label: sat_sdyHp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA4N: // global
           _sdyHk::P64 = R2;
           _sdyHp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdA4O; else goto cdA4P;
       cdA4P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA4R; else goto cdA4Q;
       cdA4R: // global
           HpAlloc = 16;
           goto cdA4O;
       cdA4O: // global
           R2 = _sdyHk::P64;
           R1 = _sdyHp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA4Q: // global
           _sdyHe::P64 = P64[_sdyHp::P64 + 7];
           _sdyHg::P64 = P64[_sdyHp::P64 + 15];
           I64[Hp - 8] = sat_sdyHm_info;
           P64[Hp] = _sdyHg::P64;
           I64[Sp - 8] = block_cdA4K_info;
           R3 = Hp - 7;
           R2 = _sdyHe::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdA4K() //  [R1]
         { info_tbl: [(cdA4K,
                       label: block_cdA4K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA4U; else goto cdA4T;
       cdA4U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA4T: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA4V,
                       label: sat_sdyHs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA4V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdA4W; else goto cdA4X;
       cdA4W: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA4X: // global
           I64[Sp - 24] = block_cdA4o_info;
           _sdyHe::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyHe::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udA5a; else goto cdA4p;
       udA5a: // global
           call _cdA4o(R1) args: 0, res: 0, upd: 0;
       cdA4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdA4o() //  [R1]
         { info_tbl: [(cdA4o,
                       label: block_cdA4o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA4o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA50; else goto cdA4Z;
       cdA50: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA4Z: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdA52; else goto cdA56;
       cdA52: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdA56: // global
           I64[Hp - 16] = sat_sdyHp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdA53_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdA53() //  [R1]
         { info_tbl: [(cdA53,
                       label: block_cdA53_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA53: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA59; else goto cdA58;
       cdA59: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA58: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHt_entry() //  [R1]
         { info_tbl: [(cdA5b,
                       label: sat_sdyHt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA5b: // global
           _sdyHt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdA5c; else goto cdA5d;
       cdA5d: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdA5f; else goto cdA5e;
       cdA5f: // global
           HpAlloc = 40;
           goto cdA5c;
       cdA5c: // global
           R1 = _sdyHt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA5e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyHt::P64;
           _sdyHc::P64 = P64[_sdyHt::P64 + 16];
           _sdyHd::P64 = P64[_sdyHt::P64 + 24];
           I64[Hp - 32] = lvl3_sdyHe_info;
           P64[Hp - 16] = _sdyHc::P64;
           I64[Hp - 8] = sat_sdyHs_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyHd::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec3_entry() //  [R2, R3]
         { info_tbl: [(cdA5g,
                       label: Data.Functor.Classes.$w$cliftReadsPrec3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA5g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdA5k; else goto cdA5j;
       cdA5k: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA5j: // global
           I64[Hp - 24] = sat_sdyHt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.824659588 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_entry() //  [R2,
                                                                   R4]
         { info_tbl: [(cdA5p,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA5p: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec3_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.826310466 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyHB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA5B,
                       label: sat_sdyHB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA5B: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udA5J_srtd" {
     udA5J_srtd:
         const SdyRV_srt+304;
         const 35;
         const 21474836481;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_entry() //  [R2,
                                                                      R3]
         { info_tbl: [(cdA5E,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA5E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA5I; else goto cdA5H;
       cdA5I: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA5H: // global
           I64[Hp - 8] = sat_sdyHB_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.828956375 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList_closure" {
     Data.Functor.Classes.$w$cliftReadList_closure:
         const Data.Functor.Classes.$w$cliftReadList_info;
         const 0;
 },
 w1_sdyHD_entry() //  [R1, R2]
         { info_tbl: [(cdA5X,
                       label: w1_sdyHD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA5X: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHG_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA65,
                       label: sat_sdyHG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA65: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udA6i_srtd" {
     udA6i_srtd:
         const SdyRV_srt+304;
         const 33;
         const 4294967297;
 },
 sat_sdyHH_entry() //  [R1]
         { info_tbl: [(cdA68,
                       label: sat_sdyHH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA68: // global
           _sdyHH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdA69; else goto cdA6a;
       cdA6a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdA6c; else goto cdA6b;
       cdA6c: // global
           HpAlloc = 32;
           goto cdA69;
       cdA69: // global
           R1 = _sdyHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyHH::P64;
           _sdyHC::P64 = P64[_sdyHH::P64 + 16];
           I64[Hp - 24] = w1_sdyHD_info;
           P64[Hp - 16] = _sdyHC::P64;
           I64[Hp - 8] = sat_sdyHG_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udA6j_srtd" {
     udA6j_srtd:
         const SdyRV_srt+304;
         const 36;
         const 38654705665;
 },
 Data.Functor.Classes.$w$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdA6d,
                       label: Data.Functor.Classes.$w$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA6d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA6h; else goto cdA6g;
       cdA6h: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA6g: // global
           I64[Hp - 16] = sat_sdyHH_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.831997038 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdA6o,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA6o: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.833127868 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_closure" {
     Data.Functor.Classes.$fRead1Identity_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Identity1_closure+4;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.834120629 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe7_bytes" {
     Data.Functor.Classes.$fRead1Maybe7_bytes:
         I8[] [78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.835242365 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe6_closure" {
     Data.Functor.Classes.$fRead1Maybe6_closure:
         const Data.Functor.Classes.$fRead1Maybe6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe6_entry() //  [R1]
         { info_tbl: [(cdA6x,
                       label: Data.Functor.Classes.$fRead1Maybe6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA6x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA6y; else goto cdA6z;
       cdA6y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA6z: // global
           (_cdA6u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdA6u::I64 == 0) goto cdA6w; else goto cdA6v;
       cdA6w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdA6v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdA6u::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.83673193 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_lexeme_closure" {
     Data.Functor.Classes.$fRead1Maybe_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.838206457 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe5_closure" {
     Data.Functor.Classes.$fRead1Maybe5_closure:
         const Data.Functor.Classes.$fRead1Maybe5_info;
         const 0;
 },
 sat_sdyHN_entry() //  [R1]
         { info_tbl: [(cdA6J,
                       label: sat_sdyHN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA6J: // global
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Maybe5_entry() //  [R2, R3]
         { info_tbl: [(cdA6P,
                       label: Data.Functor.Classes.$fRead1Maybe5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA6P: // global
           _sdyHL::P64 = R3;
           _sdyHK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdA6Q; else goto cdA6R;
       cdA6R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA6T; else goto cdA6S;
       cdA6T: // global
           HpAlloc = 16;
           goto cdA6Q;
       cdA6Q: // global
           R3 = _sdyHL::P64;
           R2 = _sdyHK::P64;
           R1 = Data.Functor.Classes.$fRead1Maybe5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA6S: // global
           I64[Hp - 8] = sat_sdyHN_info;
           P64[Hp] = _sdyHL::P64;
           I64[Sp - 8] = block_cdA6M_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Maybe_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdA6M() //  [R1]
         { info_tbl: [(cdA6M,
                       label: block_cdA6M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA6M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA6W; else goto cdA6V;
       cdA6W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA6V: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.840454634 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe4_bytes" {
     Data.Functor.Classes.$fRead1Maybe4_bytes:
         I8[] [74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.841641923 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe3_closure" {
     Data.Functor.Classes.$fRead1Maybe3_closure:
         const Data.Functor.Classes.$fRead1Maybe3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe3_entry() //  [R1]
         { info_tbl: [(cdA73,
                       label: Data.Functor.Classes.$fRead1Maybe3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA73: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdA74; else goto cdA75;
       cdA74: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA75: // global
           (_cdA70::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdA70::I64 == 0) goto cdA72; else goto cdA71;
       cdA72: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdA71: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdA70::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.843135803 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe2_closure" {
     Data.Functor.Classes.$fRead1Maybe2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.846220664 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadPrec4_info;
         const 0;
 },
 sat_sdyI2_entry() //  [R1, R2]
         { info_tbl: [(cdA7D,
                       label: sat_sdyI2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA7D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA7H; else goto cdA7G;
       cdA7H: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA7G: // global
           _sdyHV::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdyHV::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI3_entry() //  [R1, R2]
         { info_tbl: [(cdA7I,
                       label: sat_sdyI3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA7I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA7M; else goto cdA7L;
       cdA7M: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA7L: // global
           _sdyHQ::P64 = P64[R1 + 7];
           _sdyHV::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyI2_info;
           P64[Hp] = _sdyHV::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyHQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI6_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA7N,
                       label: sat_sdyI6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA7N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdA7O; else goto cdA7P;
       cdA7O: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA7P: // global
           I64[Sp - 24] = block_cdA7j_info;
           _sdyHQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyHQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udA82; else goto cdA7k;
       udA82: // global
           call _cdA7j(R1) args: 0, res: 0, upd: 0;
       cdA7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdA7j() //  [R1]
         { info_tbl: [(cdA7j,
                       label: block_cdA7j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA7j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA7S; else goto cdA7R;
       cdA7S: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA7R: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdA7U; else goto cdA7Y;
       cdA7U: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdA7Y: // global
           I64[Hp - 16] = sat_sdyI3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdA7V_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Maybe2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdA7V() //  [R1]
         { info_tbl: [(cdA7V,
                       label: block_cdA7V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA7V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA81; else goto cdA80;
       cdA81: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdA80: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI7_entry() //  [R1]
         { info_tbl: [(cdA83,
                       label: sat_sdyI7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA83: // global
           _sdyI7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdA84; else goto cdA85;
       cdA85: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA87; else goto cdA86;
       cdA87: // global
           HpAlloc = 16;
           goto cdA84;
       cdA84: // global
           R1 = _sdyI7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA86: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyI7::P64;
           _sdyHQ::P64 = P64[_sdyI7::P64 + 16];
           _sdyHR::P64 = P64[_sdyI7::P64 + 24];
           _sdyHS::P64 = P64[_sdyI7::P64 + 32];
           I64[Hp - 8] = sat_sdyI6_info;
           P64[Hp] = _sdyHQ::P64;
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udA8i_srtd" {
     udA8i_srtd:
         const SdyRV_srt+64;
         const 70;
         const 175921860444161;
         const 52;
 },
 Data.Functor.Classes.$w$cliftReadPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(cdA8a,
                       label: Data.Functor.Classes.$w$cliftReadPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA8a: // global
           _sdyHS::P64 = R4;
           _sdyHR::P64 = R3;
           _sdyHQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdA8b; else goto cdA8c;
       cdA8c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdA8e; else goto cdA8d;
       cdA8e: // global
           HpAlloc = 40;
           goto cdA8b;
       cdA8b: // global
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = _sdyHQ::P64;
           R1 = Data.Functor.Classes.$w$cliftReadPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA8d: // global
           I64[Hp - 32] = sat_sdyI7_info;
           P64[Hp - 16] = _sdyHQ::P64;
           P64[Hp - 8] = _sdyHR::P64;
           P64[Hp] = _sdyHS::P64;
           I64[Sp - 16] = block_cdA88_info;
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = Data.Functor.Classes.$fRead1Maybe5_closure+2;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdA88() //  [R1]
         { info_tbl: [(cdA88,
                       label: block_cdA88_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA88: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.851841377 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe1_closure" {
     Data.Functor.Classes.$fRead1Maybe1_closure:
         const Data.Functor.Classes.$fRead1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdA8n,
                       label: Data.Functor.Classes.$fRead1Maybe1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA8n: // global
           _sdyIa::P64 = R4;
           R4 = R5;
           R3 = _sdyIa::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.853641842 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec4_info;
         const 0;
 },
 sat_sdyIe_entry() //  [R1, R2]
         { info_tbl: [(cdA8D,
                       label: sat_sdyIe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA8D: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyIf_entry() //  [R1]
         { info_tbl: [(cdA8G,
                       label: sat_sdyIf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA8G: // global
           _sdyIf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdA8H; else goto cdA8I;
       cdA8I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA8K; else goto cdA8J;
       cdA8K: // global
           HpAlloc = 16;
           goto cdA8H;
       cdA8H: // global
           R1 = _sdyIf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA8J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyIf::P64;
           _sdyIc::P64 = P64[_sdyIf::P64 + 16];
           _sdyId::P64 = P64[_sdyIf::P64 + 24];
           I64[Hp - 8] = sat_sdyIe_info;
           P64[Hp] = _sdyIc::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyId::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec4_entry() //  [R2, R3]
         { info_tbl: [(cdA8L,
                       label: Data.Functor.Classes.$w$cliftReadsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA8L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdA8P; else goto cdA8O;
       cdA8P: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA8O: // global
           I64[Hp - 24] = sat_sdyIf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.855215053 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_entry() //  [R2,
                                                                R4]
         { info_tbl: [(cdA8U,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA8U: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec4_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.856293624 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyIn_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA96,
                       label: sat_sdyIn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA96: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udA9e_srtd" {
     udA9e_srtd:
         const SdyRV_srt+304;
         const 43;
         const 4947802324993;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cdA99,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA99: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdA9d; else goto cdA9c;
       cdA9d: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdA9c: // global
           I64[Hp - 8] = sat_sdyIn_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.858002519 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList1_closure" {
     Data.Functor.Classes.$w$cliftReadList1_closure:
         const Data.Functor.Classes.$w$cliftReadList1_info;
         const 0;
 },
 w1_sdyIp_entry() //  [R1, R2]
         { info_tbl: [(cdA9s,
                       label: w1_sdyIp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA9s: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyIs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdA9A,
                       label: sat_sdyIs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA9A: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udA9N_srtd" {
     udA9N_srtd:
         const SdyRV_srt+304;
         const 40;
         const 549755813889;
 },
 sat_sdyIt_entry() //  [R1]
         { info_tbl: [(cdA9D,
                       label: sat_sdyIt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA9D: // global
           _sdyIt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdA9E; else goto cdA9F;
       cdA9F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdA9H; else goto cdA9G;
       cdA9H: // global
           HpAlloc = 32;
           goto cdA9E;
       cdA9E: // global
           R1 = _sdyIt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdA9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyIt::P64;
           _sdyIo::P64 = P64[_sdyIt::P64 + 16];
           I64[Hp - 24] = w1_sdyIp_info;
           P64[Hp - 16] = _sdyIo::P64;
           I64[Hp - 8] = sat_sdyIs_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udA9O_srtd" {
     udA9O_srtd:
         const SdyRV_srt+304;
         const 44;
         const 9345848836097;
 },
 Data.Functor.Classes.$w$cliftReadList1_entry() //  [R2]
         { info_tbl: [(cdA9I,
                       label: Data.Functor.Classes.$w$cliftReadList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA9I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdA9M; else goto cdA9L;
       cdA9M: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdA9L: // global
           I64[Hp - 16] = sat_sdyIt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.859780041 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdA9T,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdA9T: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.860559953 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_closure" {
     Data.Functor.Classes.$fRead1Maybe_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Maybe1_closure+4;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.862978174 UTC

[section ""data" . Data.Functor.Classes.readsBinaryWith_closure" {
     Data.Functor.Classes.readsBinaryWith_closure:
         const Data.Functor.Classes.readsBinaryWith_info;
 },
 go1_sdyIM_entry() //  [R1, R2]
         { info_tbl: [(cdAay,
                       label: go1_sdyIM_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAay: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAaz; else goto cdAaA;
       cdAaz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAaA: // global
           I64[Sp - 40] = block_cdAar_info;
           _sdyIM::P64 = R1;
           _sdyIz::P64 = P64[R1 + 7];
           _sdyIJ::P64 = P64[R1 + 15];
           _sdyIL::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdyIz::P64;
           P64[Sp - 24] = _sdyIJ::P64;
           P64[Sp - 16] = _sdyIL::P64;
           P64[Sp - 8] = _sdyIM::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udAaU; else goto cdAas;
       udAaU: // global
           call _cdAar(R1) args: 0, res: 0, upd: 0;
       cdAas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAar() //  [R1]
         { info_tbl: [(cdAar,
                       label: block_cdAar_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAar: // global
           if (R1 & 7 == 1) goto cdAav; else goto cdAaw;
       cdAav: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdAaw: // global
           I64[Sp] = block_cdAaG_info;
           _sdyIQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdyIQ::P64;
           if (R1 & 7 != 0) goto udAaT; else goto cdAaH;
       udAaT: // global
           call _cdAaG(R1) args: 0, res: 0, upd: 0;
       cdAaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAaG() //  [R1]
         { info_tbl: [(cdAaG,
                       label: block_cdAaG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAaG: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdAaS; else goto cdAaR;
       cdAaS: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAaR: // global
           _sdyIS::P64 = P64[R1 + 7];
           _sdyIT::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyIS::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdyIT::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyID_entry() //  [R1, R2]
         { info_tbl: [(cdAaZ,
                       label: go_sdyID_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAaZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAb0; else goto cdAb1;
       cdAb0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAb1: // global
           I64[Sp - 32] = block_cdAaa_info;
           _sdyID::P64 = R1;
           _sdyIx::P64 = P64[R1 + 7];
           _sdyIz::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdyIx::P64;
           P64[Sp - 16] = _sdyIz::P64;
           P64[Sp - 8] = _sdyID::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAbe; else goto cdAab;
       udAbe: // global
           call _cdAaa(R1) args: 0, res: 0, upd: 0;
       cdAab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAaa() //  [R1]
         { info_tbl: [(cdAaa,
                       label: block_cdAaa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAaa: // global
           if (R1 & 7 == 1) goto cdAaW; else goto cdAaX;
       cdAaW: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAaX: // global
           I64[Sp - 8] = block_cdAag_info;
           _sdyIH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyIH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAbd; else goto cdAah;
       udAbd: // global
           call _cdAag(R1) args: 0, res: 0, upd: 0;
       cdAah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAag() //  [R1]
         { info_tbl: [(cdAag,
                       label: block_cdAag_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAag: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAb8; else goto cdAb7;
       cdAb8: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAb7: // global
           _sdyIJ::P64 = P64[R1 + 7];
           _sdyIK::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyIM_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdyIJ::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 24] = block_cdAb4_info;
           R3 = _sdyIK::P64;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = Hp - 23;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAb4() //  [R1]
         { info_tbl: [(cdAb4,
                       label: block_cdAb4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAb4: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyIM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdAbj,
                       label: Data.Functor.Classes.readsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAbj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAbk; else goto cdAbl;
       cdAbk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAbl: // global
           I64[Sp - 32] = block_cdAa0_info;
           _sdyIx::P64 = R3;
           R3 = R4;
           _sdyIw::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdyIw::P64;
           P64[Sp - 16] = _sdyIx::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAa0() //  [R1]
         { info_tbl: [(cdAa0,
                       label: block_cdAa0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAa0: // global
           if (R1 & 7 == 1) goto cdAbg; else goto cdAbh;
       cdAbg: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAbh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAbr; else goto cdAbq;
       cdAbr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAbq: // global
           I64[Hp - 16] = go_sdyID_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdAbo_info;
           R3 = P64[Sp + 32];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAbo() //  [R1]
         { info_tbl: [(cdAbo,
                       label: block_cdAbo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAbo: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyID_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.86777593 UTC

[section ""data" . Data.Functor.Classes.$wreadBinaryWith_closure" {
     Data.Functor.Classes.$wreadBinaryWith_closure:
         const Data.Functor.Classes.$wreadBinaryWith_info;
         const 0;
 },
 lvl3_sdyJ7_entry() //  [R1]
         { info_tbl: [(cdAbM,
                       label: lvl3_sdyJ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAbM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAbT; else goto cdAbU;
       cdAbT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAbU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdAbJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAbY; else goto cdAbK;
       udAbY: // global
           call _cdAbJ(R1) args: 0, res: 0, upd: 0;
       cdAbK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdAbJ() //  [R1]
         { info_tbl: [(cdAbJ,
                       label: block_cdAbJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAbJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAbX; else goto cdAbW;
       cdAbX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdAbW: // global
           _sdyJa::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdyJa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJe_entry() //  [R1, R2]
         { info_tbl: [(cdAca,
                       label: sat_sdyJe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAca: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAce; else goto cdAcd;
       cdAce: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAcd: // global
           _sdyJ2::P64 = P64[R1 + 7];
           _sdyJ4::P64 = P64[R1 + 15];
           _sdyJb::P64 = P64[R1 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJb::P64;
           P64[Hp] = R2;
           R2 = Hp - 32;
           R1 = _sdyJ4::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJf_entry() //  [R1, R2]
         { info_tbl: [(cdAcf,
                       label: sat_sdyJf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAcj; else goto cdAci;
       cdAcj: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAci: // global
           _sdyJ0::P64 = P64[R1 + 7];
           _sdyJ2::P64 = P64[R1 + 15];
           _sdyJ4::P64 = P64[R1 + 23];
           _sdyJ7::P64 = P64[R1 + 31];
           I64[Hp - 24] = sat_sdyJe_info;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJ4::P64;
           P64[Hp] = R2;
           R3 = Hp - 23;
           R2 = _sdyJ7::P64;
           R1 = _sdyJ0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJg_entry() //  [R1, R2]
         { info_tbl: [(cdAck,
                       label: sat_sdyJg_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAck: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAco; else goto cdAcn;
       cdAco: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAcn: // global
           _sdyIZ::P64 = P64[R1 + 7];
           _sdyJ0::P64 = P64[R1 + 15];
           _sdyJ2::P64 = P64[R1 + 23];
           _sdyJ3::P64 = P64[R1 + 31];
           _sdyJ4::P64 = P64[R1 + 39];
           I64[Hp - 56] = lvl3_sdyJ7_info;
           P64[Hp - 40] = _sdyJ3::P64;
           I64[Hp - 32] = sat_sdyJf_info;
           P64[Hp - 24] = _sdyJ0::P64;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJ4::P64;
           _cdAbF::P64 = Hp - 56;
           P64[Hp] = _cdAbF::P64;
           R3 = Hp - 31;
           R2 = _cdAbF::P64;
           R1 = _sdyIZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadBinaryWith_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdAcq,
                       label: Data.Functor.Classes.$wreadBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAcu; else goto cdAct;
       cdAcu: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAct: // global
           I64[Hp - 56] = sat_sdyJg_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R4;
           R3 = Hp - 55;
           R2 = Hp - 4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.870749941 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith1_closure" {
     Data.Functor.Classes.readBinaryWith1_closure:
         const Data.Functor.Classes.readBinaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith1_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdAcC,
                       label: Data.Functor.Classes.readBinaryWith1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAcD; else goto cdAcE;
       cdAcD: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readBinaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAcE: // global
           _sdyJm::P64 = P64[Sp];
           I64[Sp] = block_cdAcz_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _sdyJm::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadBinaryWith_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _cdAcz() //  [R1]
         { info_tbl: [(cdAcz,
                       label: block_cdAcz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAcH; else goto cdAcG;
       cdAcH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAcG: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.872165364 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith_closure" {
     Data.Functor.Classes.readBinaryWith_closure:
         const Data.Functor.Classes.readBinaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdAcM,
                       label: Data.Functor.Classes.readBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readBinaryWith1_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.874499686 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnaryWith_closure" {
     Data.Functor.Classes.$wshowsUnaryWith_closure:
         const Data.Functor.Classes.$wshowsUnaryWith_info;
 },
 Data.Functor.Classes.$wshowsUnaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcQ: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdyJt_entry() //  [R1]
         { info_tbl: [(cdAcY,
                       label: g_sdyJt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAcY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAcZ; else goto cdAd0;
       cdAcZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAd0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJy_entry() //  [R1, R2]
         { info_tbl: [(cdAdb,
                       label: sat_sdyJy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAdb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAdf; else goto cdAde;
       cdAdf: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAde: // global
           _sdyJq::P64 = P64[R1 + 7];
           _sdyJt::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyJq::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJB_entry() //  [R1]
         { info_tbl: [(cdAdv,
                       label: sat_sdyJB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAdv: // global
           _sdyJB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAdw; else goto cdAdx;
       cdAdx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAdz; else goto cdAdy;
       cdAdz: // global
           HpAlloc = 24;
           goto cdAdw;
       cdAdw: // global
           R1 = _sdyJB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAdy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyJB::P64;
           _sdyJt::P64 = P64[_sdyJB::P64 + 16];
           _sdyJz::P64 = P64[_sdyJB::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyJz::P64;
           R2 = Hp - 14;
           R1 = _sdyJt::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJD_entry() //  [R1]
         { info_tbl: [(cdAdB,
                       label: sat_sdyJD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAdB: // global
           _sdyJD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAdC; else goto cdAdD;
       cdAdD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAdF; else goto cdAdE;
       cdAdF: // global
           HpAlloc = 56;
           goto cdAdC;
       cdAdC: // global
           R1 = _sdyJD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAdE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyJD::P64;
           _sdyJq::P64 = P64[_sdyJD::P64 + 16];
           _sdyJt::P64 = P64[_sdyJD::P64 + 24];
           _sdyJz::P64 = P64[_sdyJD::P64 + 32];
           I64[Hp - 48] = sat_sdyJB_info;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = _sdyJz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyJq::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJE_entry() //  [R1, R2]
         { info_tbl: [(cdAdH,
                       label: sat_sdyJE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAdH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAdL; else goto cdAdK;
       cdAdL: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAdK: // global
           _sdyJq::P64 = P64[R1 + 7];
           _sdyJt::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyJD_info;
           P64[Hp - 40] = _sdyJq::P64;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAdP,
                       label: Data.Functor.Classes.$wshowsUnaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAdP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAdT; else goto cdAdS;
       cdAdT: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnaryWith_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdAdS: // global
           I64[Hp - 48] = g_sdyJt_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdAcU::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdAdN; else goto cdAdO;
       cdAdN: // global
           I64[Hp - 16] = sat_sdyJy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdAcU::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAdO: // global
           I64[Hp - 16] = sat_sdyJE_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdAcU::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.87789051 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith_closure" {
     Data.Functor.Classes.showsUnaryWith_closure:
         const Data.Functor.Classes.showsUnaryWith_info;
 },
 Data.Functor.Classes.showsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAe1,
                       label: Data.Functor.Classes.showsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAe1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAe2; else goto cdAe3;
       cdAe2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnaryWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAe3: // global
           I64[Sp - 32] = block_cdAdY_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAe7; else goto cdAdZ;
       udAe7: // global
           call _cdAdY(R1) args: 0, res: 0, upd: 0;
       cdAdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAdY() //  [R1]
         { info_tbl: [(cdAdY,
                       label: block_cdAdY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAdY: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.881187901 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdAef,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAef: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAeg; else goto cdAeh;
       cdAeg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAeh: // global
           I64[Sp - 16] = block_cdAec_info;
           R1 = R6;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udAel; else goto cdAed;
       udAel: // global
           call _cdAec(R1) args: 0, res: 0, upd: 0;
       cdAed: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAec() //  [R1]
         { info_tbl: [(cdAec,
                       label: block_cdAec_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAec: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.882724317 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_info;
         const 0;
 },
 sat_sdyK0_entry() //  [R1, R2]
         { info_tbl: [(cdAev,
                       label: sat_sdyK0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAev: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowList2_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdAey,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAey: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAeC; else goto cdAeB;
       cdAeC: // global
           HpAlloc = 16;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAeB: // global
           I64[Hp - 8] = sat_sdyK0_info;
           P64[Hp] = R2;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.883889023 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_closure" {
     Data.Functor.Classes.$fShow2Const_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.88494889 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info;
         const 0;
 },
 sat_sdyK8_entry() //  [R1]
         { info_tbl: [(cdAeQ,
                       label: sat_sdyK8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAeQ: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdAeT,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAeT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAeU; else goto cdAeV;
       cdAeU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAeV: // global
           I64[Sp - 24] = block_cdAeH_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R6;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAeZ; else goto cdAeI;
       udAeZ: // global
           call _cdAeH(R1) args: 0, res: 0, upd: 0;
       cdAeI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAeH() //  [R1]
         { info_tbl: [(cdAeH,
                       label: block_cdAeH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAeH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAeY; else goto cdAeX;
       cdAeY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAeX: // global
           _sdyK7::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sdyK8_info;
           P64[Hp] = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = _sdyK7::I64;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.886947665 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_info;
         const 0;
 },
 lvl3_sdyKe_entry() //  [R1]
         { info_tbl: [(cdAf8,
                       label: lvl3_sdyKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAf8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAf9; else goto cdAfa;
       cdAf9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAfa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyKg_entry() //  [R1, R2]
         { info_tbl: [(cdAfg,
                       label: sat_sdyKg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfg: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowList_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdAfj,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAfn; else goto cdAfm;
       cdAfn: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAfm: // global
           I64[Hp - 32] = lvl3_sdyKe_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyKg_info;
           P64[Hp] = Hp - 32;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.888706998 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_closure" {
     Data.Functor.Classes.$fShow1Const_closure:
         const Data.Functor.Classes.$fShow1Const_info;
         const 0;
 },
 sat_sdyKj_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdAfx,
                       label: sat_sdyKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfx: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowList_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyKi_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdAfF,
                       label: sat_sdyKi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfF: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_entry() //  [R2]
         { info_tbl: [(cdAfJ,
                       label: Data.Functor.Classes.$fShow1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAfN; else goto cdAfM;
       cdAfN: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAfM: // global
           I64[Hp - 48] = sat_sdyKj_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyKi_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.890585567 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cdAfZ,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAg0; else goto cdAg1;
       cdAg0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAg1: // global
           I64[Sp - 24] = block_cdAfS_info;
           R1 = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAgm; else goto cdAfT;
       udAgm: // global
           call _cdAfS(R1) args: 0, res: 0, upd: 0;
       cdAfT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAfS() //  [R1]
         { info_tbl: [(cdAfS,
                       label: block_cdAfS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAfS: // global
           _sdyKo::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdAfW; else goto cdAfX;
       cdAfW: // global
           I64[Sp + 8] = block_cdAg4_info;
           _sdyKr::P64 = P64[R1 + 7];
           R1 = _sdyKo::P64;
           P64[Sp + 16] = _sdyKr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udAgk; else goto cdAg6;
       udAgk: // global
           call _cdAg4(R1) args: 0, res: 0, upd: 0;
       cdAg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdAfX: // global
           I64[Sp] = block_cdAgd_info;
           _sdyKu::P64 = P64[R1 + 6];
           R1 = _sdyKo::P64;
           P64[Sp + 24] = _sdyKu::P64;
           if (R1 & 7 != 0) goto udAgl; else goto cdAgf;
       udAgl: // global
           call _cdAgd(R1) args: 0, res: 0, upd: 0;
       cdAgf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAg4() //  [R1]
         { info_tbl: [(cdAg4,
                       label: block_cdAg4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAg4: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 _cdAgd() //  [R1]
         { info_tbl: [(cdAgd,
                       label: block_cdAgd_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAgd: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.892722118 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList4_closure" {
     Data.Functor.Classes.$w$cliftShowList4_closure:
         const Data.Functor.Classes.$w$cliftShowList4_info;
         const 0;
 },
 sat_sdyKF_entry() //  [R1, R2]
         { info_tbl: [(cdAgD,
                       label: sat_sdyKF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAgD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAgE; else goto cdAgF;
       cdAgE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAgF: // global
           I64[Sp - 24] = block_cdAgw_info;
           _sdyKx::P64 = P64[R1 + 7];
           _sdyKy::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyKx::P64;
           P64[Sp - 8] = _sdyKy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAgM; else goto cdAgx;
       udAgM: // global
           call _cdAgw(R1) args: 0, res: 0, upd: 0;
       cdAgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAgw() //  [R1]
         { info_tbl: [(cdAgw,
                       label: block_cdAgw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAgw: // global
           if (R1 & 7 == 1) goto cdAgA; else goto cdAgB;
       cdAgA: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdAgB: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAgN,
                       label: Data.Functor.Classes.$w$cliftShowList4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAgN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAgR; else goto cdAgQ;
       cdAgR: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAgQ: // global
           I64[Hp - 16] = sat_sdyKF_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyKz::P64 = R4;
           R4 = R5;
           R3 = _sdyKz::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.894456798 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowList2_entry() //  [R2,
                                                                 R4, R6]
         { info_tbl: [(cdAgW,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAgW: // global
           R5 = P64[Sp];
           _sdyKI::P64 = R4;
           R4 = R6;
           R3 = _sdyKI::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList4_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.895278474 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_closure" {
     Data.Functor.Classes.$fShow2Either_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.896469863 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAh0: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyKS_entry() //  [R1]
         { info_tbl: [(cdAhd,
                       label: sat_sdyKS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAhd: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAhk,
                       label: Data.Functor.Classes.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAhk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAhl; else goto cdAhm;
       cdAhl: // global
           R1 = Data.Functor.Classes.$w$cliftShowsPrec_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdAhm: // global
           I64[Sp - 32] = block_cdAh4_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAht; else goto cdAh5;
       udAht: // global
           call _cdAh4(R1) args: 0, res: 0, upd: 0;
       cdAh5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAh4() //  [R1]
         { info_tbl: [(cdAh4,
                       label: block_cdAh4_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAh4: // global
           _sdyKO::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cdAhh; else goto cdAhi;
       cdAhh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAhp; else goto cdAho;
       cdAhp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAho: // global
           _sdyKR::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sdyKS_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdyKR::P64;
           R4 = _sdyKO::I64;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = Hp - 16;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdAhi: // global
           R5 = P64[R1 + 6];
           R4 = _sdyKO::I64;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.898651114 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdAhB,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAhB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAhC; else goto cdAhD;
       cdAhC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAhD: // global
           I64[Sp - 32] = block_cdAhy_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAhH; else goto cdAhz;
       udAhH: // global
           call _cdAhy(R1) args: 0, res: 0, upd: 0;
       cdAhz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAhy() //  [R1]
         { info_tbl: [(cdAhy,
                       label: block_cdAhy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAhy: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.900399595 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList1_closure" {
     Data.Functor.Classes.$w$cliftShowList1_closure:
         const Data.Functor.Classes.$w$cliftShowList1_info;
         const 0;
 },
 lvl3_sdyL5_entry() //  [R1]
         { info_tbl: [(cdAhQ,
                       label: lvl3_sdyL5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAhQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAhR; else goto cdAhS;
       cdAhR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAhS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyLa_entry() //  [R1, R2]
         { info_tbl: [(cdAi5,
                       label: sat_sdyLa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAi5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAi6; else goto cdAi7;
       cdAi6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAi7: // global
           I64[Sp - 24] = block_cdAhY_info;
           _sdyL2::P64 = P64[R1 + 7];
           _sdyL5::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyL2::P64;
           P64[Sp - 8] = _sdyL5::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAie; else goto cdAhZ;
       udAie: // global
           call _cdAhY(R1) args: 0, res: 0, upd: 0;
       cdAhZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAhY() //  [R1]
         { info_tbl: [(cdAhY,
                       label: block_cdAhY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAhY: // global
           if (R1 & 7 == 1) goto cdAi2; else goto cdAi3;
       cdAi2: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdAi3: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAif,
                       label: Data.Functor.Classes.$w$cliftShowList1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAif: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdAij; else goto cdAii;
       cdAij: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAii: // global
           I64[Hp - 40] = lvl3_sdyL5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyLa_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdyL3::P64 = R4;
           R4 = R5;
           R3 = _sdyL3::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.902382138 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowList_entry() //  [R2,
                                                                R3, R5, R6]
         { info_tbl: [(cdAio,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAio: // global
           _sdyLe::P64 = R5;
           R5 = R6;
           R4 = _sdyLe::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.903564619 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_closure" {
     Data.Functor.Classes.$fShow1Either_closure:
         const Data.Functor.Classes.$fShow1Either_info;
         const 0;
 },
 sat_sdyLm_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdAiA,
                       label: sat_sdyLm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAiA: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyLh_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdAiI,
                       label: sat_sdyLh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAiI: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Either_entry() //  [R2]
         { info_tbl: [(cdAiM,
                       label: Data.Functor.Classes.$fShow1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAiM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAiQ; else goto cdAiP;
       cdAiQ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAiP: // global
           I64[Hp - 48] = sat_sdyLm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyLh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.905119468 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdAiY,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAiY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAiZ; else goto cdAj0;
       cdAiZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAj0: // global
           I64[Sp - 24] = block_cdAiV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAj4; else goto cdAiW;
       udAj4: // global
           call _cdAiV(R1) args: 0, res: 0, upd: 0;
       cdAiW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAiV() //  [R1]
         { info_tbl: [(cdAiV,
                       label: block_cdAiV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAiV: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.906631391 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_info;
         const 0;
 },
 sat_sdyLy_entry() //  [R1, R2]
         { info_tbl: [(cdAje,
                       label: sat_sdyLy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAje: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdAjh,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAjh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAjl; else goto cdAjk;
       cdAjl: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAjk: // global
           I64[Hp - 8] = sat_sdyLy_info;
           P64[Hp] = R2;
           _sdyLv::P64 = R4;
           R4 = R5;
           R3 = _sdyLv::P64;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.907747266 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_closure" {
     Data.Functor.Classes.$fShow1Identity_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.908520904 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe1_closure" {
     Data.Functor.Classes.$fShow1Maybe1_closure:
         const Data.Functor.Classes.$fShow1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe1_entry() //  [R2]
         { info_tbl: [(cdAjq,
                       label: Data.Functor.Classes.$fShow1Maybe1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAjq: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Maybe6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.909923085 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdAjE,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAjE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAjF; else goto cdAjG;
       cdAjF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAjG: // global
           I64[Sp - 24] = block_cdAjx_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAjU; else goto cdAjy;
       udAjU: // global
           call _cdAjx(R1) args: 0, res: 0, upd: 0;
       cdAjy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAjx() //  [R1]
         { info_tbl: [(cdAjx,
                       label: block_cdAjx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAjx: // global
           if (R1 & 7 == 1) goto cdAjB; else goto cdAjC;
       cdAjB: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAjC: // global
           I64[Sp] = block_cdAjM_info;
           _sdyLE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdyLE::P64;
           if (R1 & 7 != 0) goto udAjT; else goto cdAjO;
       udAjT: // global
           call _cdAjM(R1) args: 0, res: 0, upd: 0;
       cdAjO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAjM() //  [R1]
         { info_tbl: [(cdAjM,
                       label: block_cdAjM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAjM: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.911797043 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList2_closure" {
     Data.Functor.Classes.$w$cliftShowList2_closure:
         const Data.Functor.Classes.$w$cliftShowList2_info;
         const 0;
 },
 sat_sdyLN_entry() //  [R1, R2]
         { info_tbl: [(cdAkb,
                       label: sat_sdyLN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAkb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAkc; else goto cdAkd;
       cdAkc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAkd: // global
           I64[Sp - 16] = block_cdAk4_info;
           _sdyLH::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdyLH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udAkk; else goto cdAk5;
       udAkk: // global
           call _cdAk4(R1) args: 0, res: 0, upd: 0;
       cdAk5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAk4() //  [R1]
         { info_tbl: [(cdAk4,
                       label: block_cdAk4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAk4: // global
           if (R1 & 7 == 1) goto cdAk8; else goto cdAk9;
       cdAk8: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAk9: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAkl,
                       label: Data.Functor.Classes.$w$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAkl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAkp; else goto cdAko;
       cdAkp: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAko: // global
           I64[Hp - 8] = sat_sdyLN_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.913481927 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowList_entry() //  [R2,
                                                               R4, R5]
         { info_tbl: [(cdAku,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAku: // global
           _sdyLQ::P64 = R4;
           R4 = R5;
           R3 = _sdyLQ::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.914312051 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_closure" {
     Data.Functor.Classes.$fShow1Maybe_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.916646604 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinaryWith_closure" {
     Data.Functor.Classes.$wshowsBinaryWith_closure:
         const Data.Functor.Classes.$wshowsBinaryWith_info;
 },
 Data.Functor.Classes.$wshowsBinaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAky: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 f_sdyLY_entry() //  [R1]
         { info_tbl: [(cdAkG,
                       label: f_sdyLY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAkH; else goto cdAkI;
       cdAkH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAkI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sdyLZ_entry() //  [R1]
         { info_tbl: [(cdAkN,
                       label: g_sdyLZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAkN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAkO; else goto cdAkP;
       cdAkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAkP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyM4_entry() //  [R1]
         { info_tbl: [(cdAl4,
                       label: sat_sdyM4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAl4: // global
           _sdyM4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAl5; else goto cdAl6;
       cdAl6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAl8; else goto cdAl7;
       cdAl8: // global
           HpAlloc = 56;
           goto cdAl5;
       cdAl5: // global
           R1 = _sdyM4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyM4::P64;
           _sdyLY::P64 = P64[_sdyM4::P64 + 16];
           _sdyLZ::P64 = P64[_sdyM4::P64 + 24];
           _sdyM1::P64 = P64[_sdyM4::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM1::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyLY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyM6_entry() //  [R1, R2]
         { info_tbl: [(cdAla,
                       label: sat_sdyM6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAla: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAle; else goto cdAld;
       cdAle: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAld: // global
           _sdyLU::P64 = P64[R1 + 7];
           _sdyLY::P64 = P64[R1 + 15];
           _sdyLZ::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdyM4_info;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyLU::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyM9_entry() //  [R1]
         { info_tbl: [(cdAly,
                       label: sat_sdyM9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAly: // global
           _sdyM9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAlz; else goto cdAlA;
       cdAlA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAlC; else goto cdAlB;
       cdAlC: // global
           HpAlloc = 24;
           goto cdAlz;
       cdAlz: // global
           R1 = _sdyM9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAlB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyM9::P64;
           _sdyLZ::P64 = P64[_sdyM9::P64 + 16];
           _sdyM7::P64 = P64[_sdyM9::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyM7::P64;
           R2 = Hp - 14;
           R1 = _sdyLZ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMb_entry() //  [R1]
         { info_tbl: [(cdAlE,
                       label: sat_sdyMb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAlE: // global
           _sdyMb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAlF; else goto cdAlG;
       cdAlG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAlI; else goto cdAlH;
       cdAlI: // global
           HpAlloc = 56;
           goto cdAlF;
       cdAlF: // global
           R1 = _sdyMb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAlH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMb::P64;
           _sdyLY::P64 = P64[_sdyMb::P64 + 16];
           _sdyLZ::P64 = P64[_sdyMb::P64 + 24];
           _sdyM7::P64 = P64[_sdyMb::P64 + 32];
           I64[Hp - 48] = sat_sdyM9_info;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyLY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMd_entry() //  [R1]
         { info_tbl: [(cdAlK,
                       label: sat_sdyMd_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAlK: // global
           _sdyMd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAlL; else goto cdAlM;
       cdAlM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAlO; else goto cdAlN;
       cdAlO: // global
           HpAlloc = 64;
           goto cdAlL;
       cdAlL: // global
           R1 = _sdyMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAlN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMd::P64;
           _sdyLU::P64 = P64[_sdyMd::P64 + 16];
           _sdyLY::P64 = P64[_sdyMd::P64 + 24];
           _sdyLZ::P64 = P64[_sdyMd::P64 + 32];
           _sdyM7::P64 = P64[_sdyMd::P64 + 40];
           I64[Hp - 56] = sat_sdyMb_info;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyLU::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMe_entry() //  [R1, R2]
         { info_tbl: [(cdAlQ,
                       label: sat_sdyMe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAlQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdAlU; else goto cdAlT;
       cdAlU: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAlT: // global
           _sdyLU::P64 = P64[R1 + 7];
           _sdyLY::P64 = P64[R1 + 15];
           _sdyLZ::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdyMd_info;
           P64[Hp - 48] = _sdyLU::P64;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdAlY,
                       label: Data.Functor.Classes.$wshowsBinaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAlY: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdAm2; else goto cdAm1;
       cdAm2: // global
           HpAlloc = 96;
           R1 = Data.Functor.Classes.$wshowsBinaryWith_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cdAm1: // global
           I64[Hp - 88] = f_sdyLY_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R6;
           I64[Hp - 56] = g_sdyLZ_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = P64[Sp];
           _cdAkC::P64 = Hp - 88;
           _cdAkJ::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdAlW; else goto cdAlX;
       cdAlW: // global
           I64[Hp - 24] = sat_sdyM6_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdAkC::P64;
           P64[Hp] = _cdAkJ::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAlX: // global
           I64[Hp - 24] = sat_sdyMe_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdAkC::P64;
           P64[Hp] = _cdAkJ::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.921184877 UTC

[section ""data" . Data.Functor.Classes.showsBinaryWith_closure" {
     Data.Functor.Classes.showsBinaryWith_closure:
         const Data.Functor.Classes.showsBinaryWith_info;
 },
 Data.Functor.Classes.showsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdAma,
                       label: Data.Functor.Classes.showsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAma: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAmb; else goto cdAmc;
       cdAmb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAmc: // global
           I64[Sp - 40] = block_cdAm7_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udAmg; else goto cdAm8;
       udAmg: // global
           call _cdAm7(R1) args: 0, res: 0, upd: 0;
       cdAm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAm7() //  [R1]
         { info_tbl: [(cdAm7,
                       label: block_cdAm7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAm7: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.924759372 UTC

[section ""data" . Data.Functor.Classes.readsUnary_closure" {
     Data.Functor.Classes.readsUnary_closure:
         const Data.Functor.Classes.readsUnary_info;
 },
 go_sdyMt_entry() //  [R1, R2]
         { info_tbl: [(cdAmC,
                       label: go_sdyMt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAmC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAmD; else goto cdAmE;
       cdAmD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAmE: // global
           I64[Sp - 24] = block_cdAmv_info;
           _sdyMt::P64 = R1;
           _sdyMp::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyMp::P64;
           P64[Sp - 8] = _sdyMt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAmY; else goto cdAmw;
       udAmY: // global
           call _cdAmv(R1) args: 0, res: 0, upd: 0;
       cdAmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAmv() //  [R1]
         { info_tbl: [(cdAmv,
                       label: block_cdAmv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAmv: // global
           if (R1 & 7 == 1) goto cdAmz; else goto cdAmA;
       cdAmz: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAmA: // global
           I64[Sp - 8] = block_cdAmK_info;
           _sdyMx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyMx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAmX; else goto cdAmL;
       udAmX: // global
           call _cdAmK(R1) args: 0, res: 0, upd: 0;
       cdAmL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAmK() //  [R1]
         { info_tbl: [(cdAmK,
                       label: block_cdAmK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAmK: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdAmW; else goto cdAmV;
       cdAmW: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAmV: // global
           _sdyMz::P64 = P64[R1 + 7];
           _sdyMA::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyMz::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyMA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnary_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdAn3,
                       label: Data.Functor.Classes.readsUnary_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAn3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAn4; else goto cdAn5;
       cdAn4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAn5: // global
           I64[Sp - 32] = block_cdAml_info;
           R3 = R3;
           _sdyMn::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdyMn::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAml() //  [R1]
         { info_tbl: [(cdAml,
                       label: block_cdAml_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAml: // global
           if (R1 & 7 == 1) goto cdAn0; else goto cdAn1;
       cdAn0: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAn1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAnb; else goto cdAna;
       cdAnb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAna: // global
           I64[Hp - 8] = go_sdyMt_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdAn8_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdAn8() //  [R1]
         { info_tbl: [(cdAn8,
                       label: block_cdAn8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAn8: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyMt_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.928846235 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary_closure" {
     Data.Functor.Classes.$wshowsUnary_closure:
         const Data.Functor.Classes.$wshowsUnary_info;
 },
 Data.Functor.Classes.$wshowsUnary_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAnh: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdyMJ_entry() //  [R1]
         { info_tbl: [(cdAnp,
                       label: g_sdyMJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAnp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAnq; else goto cdAnr;
       cdAnq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAnr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyMO_entry() //  [R1, R2]
         { info_tbl: [(cdAnC,
                       label: sat_sdyMO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAnC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAnG; else goto cdAnF;
       cdAnG: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAnF: // global
           _sdyMG::P64 = P64[R1 + 7];
           _sdyMJ::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyMG::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyMR_entry() //  [R1]
         { info_tbl: [(cdAnW,
                       label: sat_sdyMR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAnW: // global
           _sdyMR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAnX; else goto cdAnY;
       cdAnY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAo0; else goto cdAnZ;
       cdAo0: // global
           HpAlloc = 24;
           goto cdAnX;
       cdAnX: // global
           R1 = _sdyMR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAnZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMR::P64;
           _sdyMJ::P64 = P64[_sdyMR::P64 + 16];
           _sdyMP::P64 = P64[_sdyMR::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyMP::P64;
           R2 = Hp - 14;
           R1 = _sdyMJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMT_entry() //  [R1]
         { info_tbl: [(cdAo2,
                       label: sat_sdyMT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAo2: // global
           _sdyMT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAo3; else goto cdAo4;
       cdAo4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAo6; else goto cdAo5;
       cdAo6: // global
           HpAlloc = 56;
           goto cdAo3;
       cdAo3: // global
           R1 = _sdyMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAo5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMT::P64;
           _sdyMG::P64 = P64[_sdyMT::P64 + 16];
           _sdyMJ::P64 = P64[_sdyMT::P64 + 24];
           _sdyMP::P64 = P64[_sdyMT::P64 + 32];
           I64[Hp - 48] = sat_sdyMR_info;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = _sdyMP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyMG::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMU_entry() //  [R1, R2]
         { info_tbl: [(cdAo8,
                       label: sat_sdyMU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAo8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAoc; else goto cdAob;
       cdAoc: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAob: // global
           _sdyMG::P64 = P64[R1 + 7];
           _sdyMJ::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyMT_info;
           P64[Hp - 40] = _sdyMG::P64;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAog,
                       label: Data.Functor.Classes.$wshowsUnary_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAog: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAok; else goto cdAoj;
       cdAok: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnary_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdAoj: // global
           I64[Hp - 48] = g_sdyMJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdAnl::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdAoe; else goto cdAof;
       cdAoe: // global
           I64[Hp - 16] = sat_sdyMO_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdAnl::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAof: // global
           I64[Hp - 16] = sat_sdyMU_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdAnl::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.932308971 UTC

[section ""data" . Data.Functor.Classes.showsUnary_closure" {
     Data.Functor.Classes.showsUnary_closure:
         const Data.Functor.Classes.showsUnary_info;
 },
 Data.Functor.Classes.showsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAos,
                       label: Data.Functor.Classes.showsUnary_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAos: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAot; else goto cdAou;
       cdAot: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAou: // global
           I64[Sp - 32] = block_cdAop_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAoy; else goto cdAoq;
       udAoy: // global
           call _cdAop(R1) args: 0, res: 0, upd: 0;
       cdAoq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAop() //  [R1]
         { info_tbl: [(cdAop,
                       label: block_cdAop_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAop: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.933646011 UTC

[section ""cstring" . Data.Functor.Classes.$trModule4_bytes" {
     Data.Functor.Classes.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.936236195 UTC

[section ""data" . Data.Functor.Classes.$trModule3_closure" {
     Data.Functor.Classes.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.936841494 UTC

[section ""cstring" . Data.Functor.Classes.$trModule2_bytes" {
     Data.Functor.Classes.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.937494435 UTC

[section ""data" . Data.Functor.Classes.$trModule1_closure" {
     Data.Functor.Classes.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.938059868 UTC

[section ""data" . Data.Functor.Classes.$trModule_closure" {
     Data.Functor.Classes.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Classes.$trModule3_closure+1;
         const Data.Functor.Classes.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.938710286 UTC

[section ""data" . $krep_rdymB_closure" {
     $krep_rdymB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.93932954 UTC

[section ""data" . Data.Functor.Classes.$tcEq4_closure" {
     Data.Functor.Classes.$tcEq4_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.939902419 UTC

[section ""data" . Data.Functor.Classes.$tcEq7_closure" {
     Data.Functor.Classes.$tcEq7_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.94056905 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq6_bytes" {
     Data.Functor.Classes.$tcEq6_bytes:
         I8[] [69,113,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.941134198 UTC

[section ""data" . Data.Functor.Classes.$tcEq5_closure" {
     Data.Functor.Classes.$tcEq5_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.941933266 UTC

[section ""data" . Data.Functor.Classes.$tcEq1_closure" {
     Data.Functor.Classes.$tcEq1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq5_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 71749974434880567;
         const 7233443027070644957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.942548386 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd5_bytes" {
     Data.Functor.Classes.$tcOrd5_bytes:
         I8[] [79,114,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.943157797 UTC

[section ""data" . Data.Functor.Classes.$tcOrd4_closure" {
     Data.Functor.Classes.$tcOrd4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.943800376 UTC

[section ""data" . Data.Functor.Classes.$tcOrd1_closure" {
     Data.Functor.Classes.$tcOrd1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 11825914698899667233;
         const 4554948325937498991;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.944408239 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead5_bytes" {
     Data.Functor.Classes.$tcRead5_bytes:
         I8[] [82,101,97,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.94499812 UTC

[section ""data" . Data.Functor.Classes.$tcRead4_closure" {
     Data.Functor.Classes.$tcRead4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.945677698 UTC

[section ""data" . Data.Functor.Classes.$tcRead1_closure" {
     Data.Functor.Classes.$tcRead1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 14547308444716217043;
         const 925634574698086715;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.946313859 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow5_bytes" {
     Data.Functor.Classes.$tcShow5_bytes:
         I8[] [83,104,111,119,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.946928995 UTC

[section ""data" . Data.Functor.Classes.$tcShow4_closure" {
     Data.Functor.Classes.$tcShow4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.947535615 UTC

[section ""data" . Data.Functor.Classes.$tcShow1_closure" {
     Data.Functor.Classes.$tcShow1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 4743290066722511112;
         const 6779909240154408836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.948153578 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq9_bytes" {
     Data.Functor.Classes.$tcEq9_bytes:
         I8[] [69,113,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.948749995 UTC

[section ""data" . Data.Functor.Classes.$tcEq8_closure" {
     Data.Functor.Classes.$tcEq8_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.949389317 UTC

[section ""data" . Data.Functor.Classes.$tcEq2_closure" {
     Data.Functor.Classes.$tcEq2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq8_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 16920549266159426738;
         const 13264288076834164909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.950023153 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd7_bytes" {
     Data.Functor.Classes.$tcOrd7_bytes:
         I8[] [79,114,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.950634062 UTC

[section ""data" . Data.Functor.Classes.$tcOrd6_closure" {
     Data.Functor.Classes.$tcOrd6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.951238611 UTC

[section ""data" . Data.Functor.Classes.$tcOrd2_closure" {
     Data.Functor.Classes.$tcOrd2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 4167316048525678806;
         const 17649124474771181823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.951893485 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead7_bytes" {
     Data.Functor.Classes.$tcRead7_bytes:
         I8[] [82,101,97,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.952464479 UTC

[section ""data" . Data.Functor.Classes.$tcRead6_closure" {
     Data.Functor.Classes.$tcRead6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.953021494 UTC

[section ""data" . Data.Functor.Classes.$tcRead2_closure" {
     Data.Functor.Classes.$tcRead2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 615267248700376470;
         const 8978126042197021701;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.953768459 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow7_bytes" {
     Data.Functor.Classes.$tcShow7_bytes:
         I8[] [83,104,111,119,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.954371892 UTC

[section ""data" . Data.Functor.Classes.$tcShow6_closure" {
     Data.Functor.Classes.$tcShow6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.954962524 UTC

[section ""data" . Data.Functor.Classes.$tcShow2_closure" {
     Data.Functor.Classes.$tcShow2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 11321900378419812635;
         const 1323607160578303441;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.955924224 UTC

[section ""data" . Data.Functor.Classes.C:Show2_closure" {
     Data.Functor.Classes.C:Show2_closure:
         const Data.Functor.Classes.C:Show2_info;
 },
 Data.Functor.Classes.C:Show2_entry() //  [R2, R3]
         { info_tbl: [(cdAoE,
                       label: Data.Functor.Classes.C:Show2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAoE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAoI; else goto cdAoH;
       cdAoI: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAoH: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.957076203 UTC

[section ""data" . Data.Functor.Classes.C:Read2_closure" {
     Data.Functor.Classes.C:Read2_closure:
         const Data.Functor.Classes.C:Read2_info;
 },
 Data.Functor.Classes.C:Read2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAoO,
                       label: Data.Functor.Classes.C:Read2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAoO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAoS; else goto cdAoR;
       cdAoS: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAoR: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read2_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.958322837 UTC

[section ""data" . Data.Functor.Classes.C:Ord2_closure" {
     Data.Functor.Classes.C:Ord2_closure:
         const Data.Functor.Classes.C:Ord2_info;
 },
 Data.Functor.Classes.C:Ord2_entry() //  [R2, R3]
         { info_tbl: [(cdAoY,
                       label: Data.Functor.Classes.C:Ord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAoY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAp2; else goto cdAp1;
       cdAp2: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAp1: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.959388376 UTC

[section ""data" . Data.Functor.Classes.C:Show1_closure" {
     Data.Functor.Classes.C:Show1_closure:
         const Data.Functor.Classes.C:Show1_info;
 },
 Data.Functor.Classes.C:Show1_entry() //  [R2, R3]
         { info_tbl: [(cdAp8,
                       label: Data.Functor.Classes.C:Show1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAp8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdApc; else goto cdApb;
       cdApc: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdApb: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.960489627 UTC

[section ""data" . Data.Functor.Classes.C:Read1_closure" {
     Data.Functor.Classes.C:Read1_closure:
         const Data.Functor.Classes.C:Read1_info;
 },
 Data.Functor.Classes.C:Read1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdApi,
                       label: Data.Functor.Classes.C:Read1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdApm; else goto cdApl;
       cdApm: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdApl: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.961679418 UTC

[section ""data" . Data.Functor.Classes.C:Ord1_closure" {
     Data.Functor.Classes.C:Ord1_closure:
         const Data.Functor.Classes.C:Ord1_info;
 },
 Data.Functor.Classes.C:Ord1_entry() //  [R2, R3]
         { info_tbl: [(cdAps,
                       label: Data.Functor.Classes.C:Ord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAps: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdApw; else goto cdApv;
       cdApw: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdApv: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.962611842 UTC

[Data.Functor.Classes.C:Show2_con_entry() //  [R1]
         { info_tbl: [(cdApx,
                       label: Data.Functor.Classes.C:Show2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApx: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.963420372 UTC

[Data.Functor.Classes.C:Read2_con_entry() //  [R1]
         { info_tbl: [(cdApy,
                       label: Data.Functor.Classes.C:Read2_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApy: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.964177657 UTC

[Data.Functor.Classes.C:Ord2_con_entry() //  [R1]
         { info_tbl: [(cdApz,
                       label: Data.Functor.Classes.C:Ord2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApz: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.964958427 UTC

[Data.Functor.Classes.C:Show1_con_entry() //  [R1]
         { info_tbl: [(cdApA,
                       label: Data.Functor.Classes.C:Show1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApA: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.96580142 UTC

[Data.Functor.Classes.C:Read1_con_entry() //  [R1]
         { info_tbl: [(cdApB,
                       label: Data.Functor.Classes.C:Read1_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApB: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.967668565 UTC

[Data.Functor.Classes.C:Ord1_con_entry() //  [R1]
         { info_tbl: [(cdApC,
                       label: Data.Functor.Classes.C:Ord1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.968383508 UTC

[section ""relreadonly" . SdyRV_srt" {
     SdyRV_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.$fRead1Const2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec7_closure;
         const Data.Functor.Classes.$fRead1Either1_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$fRead1Either4_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec8_closure;
         const Data.Functor.Classes.$fRead1NonEmpty3_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec5_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1Proxy2_closure;
         const Data.Functor.Classes.$fRead1Proxy_lexeme_closure;
         const Data.Functor.Classes.$fRead1Proxy1_closure;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const Data.Functor.Classes.$fShow1Proxy2_closure;
         const Data.Functor.Classes.$fRead1(,)3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec6_closure;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$dmliftReadList2_closure;
         const Data.Functor.Classes.$fShow1Proxy1_closure;
         const Data.Functor.Classes.$dmliftReadList_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec2_closure;
         const Data.Functor.Classes.liftReadListPrecDefault_closure;
         const lvl_rdymy_closure;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
         const lvl1_rdymz_closure;
         const lvl2_rdymA_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$w$cliftReadList2_closure;
         const Data.Functor.Classes.$fRead2Either_closure;
         const Data.Functor.Classes.$fRead2Const_closure;
         const Data.Functor.Classes.$fRead2(,)_closure;
         const Data.Functor.Classes.liftReadListPrec2Default_closure;
         const Data.Functor.Classes.$fRead1(,)1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1(,)_closure;
         const GHC.Read.lex1_closure;
         const Data.Functor.Classes.$wreadsData_closure;
         const Data.Functor.Classes.readsData_closure;
         const Data.Functor.Classes.readData1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$wreadUnaryWith_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.readUnaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const5_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Const_closure;
         const Data.Functor.Classes.$fRead1Either7_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec1_closure;
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Either_closure;
         const Data.Functor.Classes.$fRead1Identity2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec3_closure;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Maybe5_closure;
         const Data.Functor.Classes.$fRead1Maybe_lexeme_closure;
         const Data.Functor.Classes.$fRead1Maybe2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec4_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec4_closure;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList1_closure;
         const Data.Functor.Classes.$wreadBinaryWith_closure;
         const Data.Functor.Classes.readBinaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
         const Data.Functor.Classes.$fShow1Const_closure;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$w$cliftShowList4_closure;
         const Data.Functor.Classes.$w$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList1_closure;
         const Data.Functor.Classes.$fShow1Either_closure;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const Data.Functor.Classes.$fShow1Maybe1_closure;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.969973584 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:43.970809675 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec2_closure" {
     Data.Functor.Classes.liftShowsPrec2_closure:
         const Data.Functor.Classes.liftShowsPrec2_info;
 },
 Data.Functor.Classes.liftShowsPrec2_entry() //  [R2]
         { info_tbl: [(cdApK,
                       label: Data.Functor.Classes.liftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdApL; else goto cdApM;
       cdApL: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdApM: // global
           I64[Sp - 8] = block_cdApH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udApQ; else goto cdApI;
       udApQ: // global
           call _cdApH(R1) args: 0, res: 0, upd: 0;
       cdApI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdApH() //  [R1]
         { info_tbl: [(cdApH,
                       label: block_cdApH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApH: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.972013305 UTC

[section ""data" . Data.Functor.Classes.liftShowList2_closure" {
     Data.Functor.Classes.liftShowList2_closure:
         const Data.Functor.Classes.liftShowList2_info;
 },
 Data.Functor.Classes.liftShowList2_entry() //  [R2]
         { info_tbl: [(cdApY,
                       label: Data.Functor.Classes.liftShowList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdApZ; else goto cdAq0;
       cdApZ: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAq0: // global
           I64[Sp - 8] = block_cdApV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAq4; else goto cdApW;
       udAq4: // global
           call _cdApV(R1) args: 0, res: 0, upd: 0;
       cdApW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdApV() //  [R1]
         { info_tbl: [(cdApV,
                       label: block_cdApV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdApV: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.973184255 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec2_closure" {
     Data.Functor.Classes.liftReadsPrec2_closure:
         const Data.Functor.Classes.liftReadsPrec2_info;
 },
 Data.Functor.Classes.liftReadsPrec2_entry() //  [R2]
         { info_tbl: [(cdAqc,
                       label: Data.Functor.Classes.liftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAqd; else goto cdAqe;
       cdAqd: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAqe: // global
           I64[Sp - 8] = block_cdAq9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAqi; else goto cdAqa;
       udAqi: // global
           call _cdAq9(R1) args: 0, res: 0, upd: 0;
       cdAqa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAq9() //  [R1]
         { info_tbl: [(cdAq9,
                       label: block_cdAq9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAq9: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.974453921 UTC

[section ""data" . Data.Functor.Classes.liftReadList2_closure" {
     Data.Functor.Classes.liftReadList2_closure:
         const Data.Functor.Classes.liftReadList2_info;
 },
 Data.Functor.Classes.liftReadList2_entry() //  [R2]
         { info_tbl: [(cdAqq,
                       label: Data.Functor.Classes.liftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAqr; else goto cdAqs;
       cdAqr: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAqs: // global
           I64[Sp - 8] = block_cdAqn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAqw; else goto cdAqo;
       udAqw: // global
           call _cdAqn(R1) args: 0, res: 0, upd: 0;
       cdAqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAqn() //  [R1]
         { info_tbl: [(cdAqn,
                       label: block_cdAqn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqn: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.975662492 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec2_closure" {
     Data.Functor.Classes.liftReadPrec2_closure:
         const Data.Functor.Classes.liftReadPrec2_info;
 },
 Data.Functor.Classes.liftReadPrec2_entry() //  [R2]
         { info_tbl: [(cdAqE,
                       label: Data.Functor.Classes.liftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAqF; else goto cdAqG;
       cdAqF: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAqG: // global
           I64[Sp - 8] = block_cdAqB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAqK; else goto cdAqC;
       udAqK: // global
           call _cdAqB(R1) args: 0, res: 0, upd: 0;
       cdAqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAqB() //  [R1]
         { info_tbl: [(cdAqB,
                       label: block_cdAqB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqB: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.976823865 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2_closure" {
     Data.Functor.Classes.liftReadListPrec2_closure:
         const Data.Functor.Classes.liftReadListPrec2_info;
 },
 Data.Functor.Classes.liftReadListPrec2_entry() //  [R2]
         { info_tbl: [(cdAqS,
                       label: Data.Functor.Classes.liftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAqT; else goto cdAqU;
       cdAqT: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAqU: // global
           I64[Sp - 8] = block_cdAqP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAqY; else goto cdAqQ;
       udAqY: // global
           call _cdAqP(R1) args: 0, res: 0, upd: 0;
       cdAqQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAqP() //  [R1]
         { info_tbl: [(cdAqP,
                       label: block_cdAqP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAqP: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.978084122 UTC

[section ""data" . Data.Functor.Classes.$p1Ord2_closure" {
     Data.Functor.Classes.$p1Ord2_closure:
         const Data.Functor.Classes.$p1Ord2_info;
 },
 Data.Functor.Classes.$p1Ord2_entry() //  [R2]
         { info_tbl: [(cdAr6,
                       label: Data.Functor.Classes.$p1Ord2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAr6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAr7; else goto cdAr8;
       cdAr7: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAr8: // global
           I64[Sp - 8] = block_cdAr3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udArc; else goto cdAr4;
       udArc: // global
           call _cdAr3(R1) args: 0, res: 0, upd: 0;
       cdAr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAr3() //  [R1]
         { info_tbl: [(cdAr3,
                       label: block_cdAr3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAr3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.97925178 UTC

[section ""data" . Data.Functor.Classes.liftCompare2_closure" {
     Data.Functor.Classes.liftCompare2_closure:
         const Data.Functor.Classes.liftCompare2_info;
 },
 Data.Functor.Classes.liftCompare2_entry() //  [R2]
         { info_tbl: [(cdArk,
                       label: Data.Functor.Classes.liftCompare2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdArl; else goto cdArm;
       cdArl: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdArm: // global
           I64[Sp - 8] = block_cdArh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udArq; else goto cdAri;
       udArq: // global
           call _cdArh(R1) args: 0, res: 0, upd: 0;
       cdAri: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdArh() //  [R1]
         { info_tbl: [(cdArh,
                       label: block_cdArh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArh: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.980328318 UTC

[section ""data" . Data.Functor.Classes.liftEq2_closure" {
     Data.Functor.Classes.liftEq2_closure:
         const Data.Functor.Classes.liftEq2_info;
 },
 Data.Functor.Classes.liftEq2_entry() //  [R2]
         { info_tbl: [(cdArv,
                       label: Data.Functor.Classes.liftEq2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArv: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.981322885 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec_closure" {
     Data.Functor.Classes.liftShowsPrec_closure:
         const Data.Functor.Classes.liftShowsPrec_info;
 },
 Data.Functor.Classes.liftShowsPrec_entry() //  [R2]
         { info_tbl: [(cdArF,
                       label: Data.Functor.Classes.liftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdArG; else goto cdArH;
       cdArG: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdArH: // global
           I64[Sp - 8] = block_cdArC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udArL; else goto cdArD;
       udArL: // global
           call _cdArC(R1) args: 0, res: 0, upd: 0;
       cdArD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdArC() //  [R1]
         { info_tbl: [(cdArC,
                       label: block_cdArC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArC: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.982535673 UTC

[section ""data" . Data.Functor.Classes.liftShowList_closure" {
     Data.Functor.Classes.liftShowList_closure:
         const Data.Functor.Classes.liftShowList_info;
 },
 Data.Functor.Classes.liftShowList_entry() //  [R2]
         { info_tbl: [(cdArT,
                       label: Data.Functor.Classes.liftShowList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdArU; else goto cdArV;
       cdArU: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdArV: // global
           I64[Sp - 8] = block_cdArQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udArZ; else goto cdArR;
       udArZ: // global
           call _cdArQ(R1) args: 0, res: 0, upd: 0;
       cdArR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdArQ() //  [R1]
         { info_tbl: [(cdArQ,
                       label: block_cdArQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdArQ: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.983708189 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec_closure" {
     Data.Functor.Classes.liftReadsPrec_closure:
         const Data.Functor.Classes.liftReadsPrec_info;
 },
 Data.Functor.Classes.liftReadsPrec_entry() //  [R2]
         { info_tbl: [(cdAs7,
                       label: Data.Functor.Classes.liftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAs7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAs8; else goto cdAs9;
       cdAs8: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAs9: // global
           I64[Sp - 8] = block_cdAs4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAsd; else goto cdAs5;
       udAsd: // global
           call _cdAs4(R1) args: 0, res: 0, upd: 0;
       cdAs5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAs4() //  [R1]
         { info_tbl: [(cdAs4,
                       label: block_cdAs4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAs4: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.984911839 UTC

[section ""data" . Data.Functor.Classes.liftReadList_closure" {
     Data.Functor.Classes.liftReadList_closure:
         const Data.Functor.Classes.liftReadList_info;
 },
 Data.Functor.Classes.liftReadList_entry() //  [R2]
         { info_tbl: [(cdAsl,
                       label: Data.Functor.Classes.liftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAsm; else goto cdAsn;
       cdAsm: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAsn: // global
           I64[Sp - 8] = block_cdAsi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAsr; else goto cdAsj;
       udAsr: // global
           call _cdAsi(R1) args: 0, res: 0, upd: 0;
       cdAsj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAsi() //  [R1]
         { info_tbl: [(cdAsi,
                       label: block_cdAsi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsi: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.986197279 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec_closure" {
     Data.Functor.Classes.liftReadPrec_closure:
         const Data.Functor.Classes.liftReadPrec_info;
 },
 Data.Functor.Classes.liftReadPrec_entry() //  [R2]
         { info_tbl: [(cdAsz,
                       label: Data.Functor.Classes.liftReadPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAsA; else goto cdAsB;
       cdAsA: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAsB: // global
           I64[Sp - 8] = block_cdAsw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAsF; else goto cdAsx;
       udAsF: // global
           call _cdAsw(R1) args: 0, res: 0, upd: 0;
       cdAsx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAsw() //  [R1]
         { info_tbl: [(cdAsw,
                       label: block_cdAsw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsw: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.987395748 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec_closure" {
     Data.Functor.Classes.liftReadListPrec_closure:
         const Data.Functor.Classes.liftReadListPrec_info;
 },
 Data.Functor.Classes.liftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdAsN,
                       label: Data.Functor.Classes.liftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAsO; else goto cdAsP;
       cdAsO: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAsP: // global
           I64[Sp - 8] = block_cdAsK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAsT; else goto cdAsL;
       udAsT: // global
           call _cdAsK(R1) args: 0, res: 0, upd: 0;
       cdAsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAsK() //  [R1]
         { info_tbl: [(cdAsK,
                       label: block_cdAsK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsK: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.988543293 UTC

[section ""data" . Data.Functor.Classes.$p1Ord1_closure" {
     Data.Functor.Classes.$p1Ord1_closure:
         const Data.Functor.Classes.$p1Ord1_info;
 },
 Data.Functor.Classes.$p1Ord1_entry() //  [R2]
         { info_tbl: [(cdAt1,
                       label: Data.Functor.Classes.$p1Ord1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAt1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAt2; else goto cdAt3;
       cdAt2: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAt3: // global
           I64[Sp - 8] = block_cdAsY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAt7; else goto cdAsZ;
       udAt7: // global
           call _cdAsY(R1) args: 0, res: 0, upd: 0;
       cdAsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAsY() //  [R1]
         { info_tbl: [(cdAsY,
                       label: block_cdAsY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAsY: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.989912725 UTC

[section ""data" . Data.Functor.Classes.liftCompare_closure" {
     Data.Functor.Classes.liftCompare_closure:
         const Data.Functor.Classes.liftCompare_info;
 },
 Data.Functor.Classes.liftCompare_entry() //  [R2]
         { info_tbl: [(cdAtf,
                       label: Data.Functor.Classes.liftCompare_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAtf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAtg; else goto cdAth;
       cdAtg: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAth: // global
           I64[Sp - 8] = block_cdAtc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAtl; else goto cdAtd;
       udAtl: // global
           call _cdAtc(R1) args: 0, res: 0, upd: 0;
       cdAtd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAtc() //  [R1]
         { info_tbl: [(cdAtc,
                       label: block_cdAtc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAtc: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.990995931 UTC

[section ""data" . Data.Functor.Classes.liftEq_closure" {
     Data.Functor.Classes.liftEq_closure:
         const Data.Functor.Classes.liftEq_info;
 },
 Data.Functor.Classes.liftEq_entry() //  [R2]
         { info_tbl: [(cdAtq,
                       label: Data.Functor.Classes.liftEq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAtq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.99172257 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const1_closure" {
     Data.Functor.Classes.$fRead1Const1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.992286274 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Const4_bytes" {
     Data.Functor.Classes.$fRead1Const4_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.993050421 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const3_closure" {
     Data.Functor.Classes.$fRead1Const3_closure:
         const Data.Functor.Classes.$fRead1Const3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const3_entry() //  [R1]
         { info_tbl: [(cdAtz,
                       label: Data.Functor.Classes.$fRead1Const3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAtz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAtA; else goto cdAtB;
       cdAtA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAtB: // global
           (_cdAtw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdAtw::I64 == 0) goto cdAty; else goto cdAtx;
       cdAty: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdAtx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdAtw::I64;
           R2 = Data.Functor.Classes.$fRead1Const4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.994856215 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const2_closure" {
     Data.Functor.Classes.$fRead1Const2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.996457147 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadPrec1_info;
         const 0;
 },
 sat_sdyo7_entry() //  [R1, R2]
         { info_tbl: [(cdAu4,
                       label: sat_sdyo7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAu4: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyo8_entry() //  [R1, R2]
         { info_tbl: [(cdAu7,
                       label: sat_sdyo8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAu7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAub; else goto cdAua;
       cdAub: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAua: // global
           _sdynX::P64 = P64[R1 + 7];
           _sdyo1::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyo7_info;
           P64[Hp] = _sdyo1::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdynX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyob_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAuc,
                       label: sat_sdyob_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAuc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAud; else goto cdAue;
       cdAud: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAue: // global
           I64[Sp - 24] = block_cdAtL_info;
           _sdynX::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdynX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAur; else goto cdAtM;
       udAur: // global
           call _cdAtL(R1) args: 0, res: 0, upd: 0;
       cdAtM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAtL() //  [R1]
         { info_tbl: [(cdAtL,
                       label: block_cdAtL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAtL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAuh; else goto cdAug;
       cdAuh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAug: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdAuj; else goto cdAun;
       cdAuj: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAun: // global
           I64[Hp - 16] = sat_sdyo8_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdAuk_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAuk() //  [R1]
         { info_tbl: [(cdAuk,
                       label: block_cdAuk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAuk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAuq; else goto cdAup;
       cdAuq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAup: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAus,
                       label: Data.Functor.Classes.$w$cliftReadPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAus: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAuw; else goto cdAuv;
       cdAuw: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAuv: // global
           I64[Hp - 8] = sat_sdyob_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:43.999029221 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const6_closure" {
     Data.Functor.Classes.$fRead1Const6_closure:
         const Data.Functor.Classes.$fRead1Const6_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const6_entry() //  [R2, R6]
         { info_tbl: [(cdAuB,
                       label: Data.Functor.Classes.$fRead1Const6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAuB: // global
           R4 = P64[Sp];
           R3 = R6;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.000099275 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyoo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAuN,
                       label: sat_sdyoo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAuN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdAuQ,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAuQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAuU; else goto cdAuT;
       cdAuU: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAuT: // global
           I64[Hp - 8] = sat_sdyoo_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.002507832 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec7_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec7_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec7_info;
         const 0;
 },
 lvl3_sdyor_entry() //  [R1]
         { info_tbl: [(cdAv7,
                       label: lvl3_sdyor_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAv7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAv8; else goto cdAv9;
       cdAv8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyoz_entry() //  [R1, R2]
         { info_tbl: [(cdAvy,
                       label: sat_sdyoz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAvy: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoC_entry() //  [R1, R2]
         { info_tbl: [(cdAvE,
                       label: sat_sdyoC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAvE: // global
           _sdyox::P64 = R2;
           _sdyoC::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdAvF; else goto cdAvG;
       cdAvG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAvI; else goto cdAvH;
       cdAvI: // global
           HpAlloc = 16;
           goto cdAvF;
       cdAvF: // global
           R2 = _sdyox::P64;
           R1 = _sdyoC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAvH: // global
           _sdyor::P64 = P64[_sdyoC::P64 + 7];
           _sdyot::P64 = P64[_sdyoC::P64 + 15];
           I64[Hp - 8] = sat_sdyoz_info;
           P64[Hp] = _sdyot::P64;
           I64[Sp - 8] = block_cdAvB_info;
           R3 = Hp - 7;
           R2 = _sdyor::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAvB() //  [R1]
         { info_tbl: [(cdAvB,
                       label: block_cdAvB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAvB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAvL; else goto cdAvK;
       cdAvL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAvK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoF_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAvM,
                       label: sat_sdyoF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAvM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAvN; else goto cdAvO;
       cdAvN: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAvO: // global
           I64[Sp - 24] = block_cdAvf_info;
           _sdyor::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyor::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAw1; else goto cdAvg;
       udAw1: // global
           call _cdAvf(R1) args: 0, res: 0, upd: 0;
       cdAvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAvf() //  [R1]
         { info_tbl: [(cdAvf,
                       label: block_cdAvf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAvf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAvR; else goto cdAvQ;
       cdAvR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAvQ: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdAvT; else goto cdAvX;
       cdAvT: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAvX: // global
           I64[Hp - 16] = sat_sdyoC_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdAvU_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAvU() //  [R1]
         { info_tbl: [(cdAvU,
                       label: block_cdAvU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAvU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAw0; else goto cdAvZ;
       cdAw0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAvZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoG_entry() //  [R1]
         { info_tbl: [(cdAw2,
                       label: sat_sdyoG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAw2: // global
           _sdyoG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAw3; else goto cdAw4;
       cdAw4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAw6; else goto cdAw5;
       cdAw6: // global
           HpAlloc = 40;
           goto cdAw3;
       cdAw3: // global
           R1 = _sdyoG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAw5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyoG::P64;
           _sdyop::P64 = P64[_sdyoG::P64 + 16];
           _sdyoq::P64 = P64[_sdyoG::P64 + 24];
           I64[Hp - 32] = lvl3_sdyor_info;
           P64[Hp - 16] = _sdyop::P64;
           I64[Hp - 8] = sat_sdyoF_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyoq::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec7_entry() //  [R2, R3]
         { info_tbl: [(cdAw7,
                       label: Data.Functor.Classes.$w$cliftReadsPrec7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAw7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAwb; else goto cdAwa;
       cdAwb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAwa: // global
           I64[Hp - 24] = sat_sdyoG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.00583132 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_entry() //  [R2,
                                                                 R6]
         { info_tbl: [(cdAwg,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAwg: // global
           R3 = R6;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec7_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.006575154 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either3_bytes" {
     Data.Functor.Classes.$fRead1Either3_bytes:
         I8[] [82,105,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.007344111 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either2_closure" {
     Data.Functor.Classes.$fRead1Either2_closure:
         const Data.Functor.Classes.$fRead1Either2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either2_entry() //  [R1]
         { info_tbl: [(cdAwp,
                       label: Data.Functor.Classes.$fRead1Either2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAwp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAwq; else goto cdAwr;
       cdAwq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAwr: // global
           (_cdAwm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdAwm::I64 == 0) goto cdAwo; else goto cdAwn;
       cdAwo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdAwn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdAwm::I64;
           R2 = Data.Functor.Classes.$fRead1Either3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.008235266 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either1_closure" {
     Data.Functor.Classes.$fRead1Either1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.008836415 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either6_bytes" {
     Data.Functor.Classes.$fRead1Either6_bytes:
         I8[] [76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.00961502 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either5_closure" {
     Data.Functor.Classes.$fRead1Either5_closure:
         const Data.Functor.Classes.$fRead1Either5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either5_entry() //  [R1]
         { info_tbl: [(cdAwy,
                       label: Data.Functor.Classes.$fRead1Either5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAwy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAwz; else goto cdAwA;
       cdAwz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAwA: // global
           (_cdAwv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdAwv::I64 == 0) goto cdAwx; else goto cdAww;
       cdAwx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdAww: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdAwv::I64;
           R2 = Data.Functor.Classes.$fRead1Either6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.010519207 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either4_closure" {
     Data.Functor.Classes.$fRead1Either4_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.012798992 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadPrec3_info;
         const 0;
 },
 sat_sdyoY_entry() //  [R1, R2]
         { info_tbl: [(cdAx4,
                       label: sat_sdyoY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAx4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAx8; else goto cdAx7;
       cdAx8: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAx7: // global
           _sdyoR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sdyoR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoZ_entry() //  [R1, R2]
         { info_tbl: [(cdAx9,
                       label: sat_sdyoZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAx9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAxd; else goto cdAxc;
       cdAxd: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAxc: // global
           _sdyoM::P64 = P64[R1 + 7];
           _sdyoR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyoY_info;
           P64[Hp] = _sdyoR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyoM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyp6_entry() //  [R1, R2]
         { info_tbl: [(cdAxv,
                       label: sat_sdyp6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAxv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAxz; else goto cdAxy;
       cdAxz: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAxy: // global
           _sdyoR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdyoR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyp7_entry() //  [R1, R2]
         { info_tbl: [(cdAxA,
                       label: sat_sdyp7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAxA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAxE; else goto cdAxD;
       cdAxE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAxD: // global
           _sdyoN::P64 = P64[R1 + 7];
           _sdyoR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyp6_info;
           P64[Hp] = _sdyoR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyoN::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdypa_entry() //  [R1]
         { info_tbl: [(cdAxI,
                       label: sat_sdypa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAxI: // global
           _sdypa::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdAxJ; else goto cdAxK;
       cdAxK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAxM; else goto cdAxL;
       cdAxM: // global
           HpAlloc = 24;
           goto cdAxJ;
       cdAxJ: // global
           R1 = _sdypa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdypa::P64;
           _sdyoN::P64 = P64[_sdypa::P64 + 16];
           _sdyoR::P64 = P64[_sdypa::P64 + 24];
           I64[Hp - 16] = sat_sdyp7_info;
           P64[Hp - 8] = _sdyoN::P64;
           P64[Hp] = _sdyoR::P64;
           I64[Sp - 24] = block_cdAxF_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either1_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdAxF() //  [R1]
         { info_tbl: [(cdAxF,
                       label: block_cdAxF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAxF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAxP; else goto cdAxO;
       cdAxP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdAxO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdypb_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAxQ,
                       label: sat_sdypb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAxQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAxR; else goto cdAxS;
       cdAxR: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAxS: // global
           I64[Sp - 32] = block_cdAwK_info;
           _sdyoM::P64 = P64[R1 + 6];
           _sdyoN::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdyoM::P64;
           P64[Sp - 16] = _sdyoN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAy3; else goto cdAwL;
       udAy3: // global
           call _cdAwK(R1) args: 0, res: 0, upd: 0;
       cdAwL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAwK() //  [R1]
         { info_tbl: [(cdAwK,
                       label: block_cdAwK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAwK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAxV; else goto cdAxU;
       cdAxV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAxU: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdAxX; else goto cdAxZ;
       cdAxX: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAxZ: // global
           I64[Hp - 16] = sat_sdyoZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 8] = block_cdAxe_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either4_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAxe() //  [R1]
         { info_tbl: [(cdAxe,
                       label: block_cdAxe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAxe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdAy2; else goto cdAy1;
       cdAy2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAy1: // global
           I64[Hp - 40] = sat_sdypa_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAy4,
                       label: Data.Functor.Classes.$w$cliftReadPrec3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAy4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAy8; else goto cdAy7;
       cdAy8: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAy7: // global
           I64[Hp - 16] = sat_sdypb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyoO::P64 = R4;
           R4 = R5;
           R3 = _sdyoO::P64;
           R2 = Hp - 14;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.016938007 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either8_closure" {
     Data.Functor.Classes.$fRead1Either8_closure:
         const Data.Functor.Classes.$fRead1Either8_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either8_entry() //  [R2, R4, R6]
         { info_tbl: [(cdAyd,
                       label: Data.Functor.Classes.$fRead1Either8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAyd: // global
           R5 = P64[Sp];
           _sdype::P64 = R4;
           R4 = R6;
           R3 = _sdype::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.018392548 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdypo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAyp,
                       label: sat_sdypo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAyp: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdAys,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAys: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAyw; else goto cdAyv;
       cdAyw: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAyv: // global
           I64[Hp - 16] = sat_sdypo_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.020136026 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec8_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec8_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec8_info;
         const 0;
 },
 sat_sdypt_entry() //  [R1, R2]
         { info_tbl: [(cdAyK,
                       label: sat_sdypt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAyK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyps_entry() //  [R1, R2]
         { info_tbl: [(cdAyS,
                       label: sat_sdyps_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAyS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdypu_entry() //  [R1]
         { info_tbl: [(cdAyV,
                       label: sat_sdypu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAyV: // global
           _sdypu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAyW; else goto cdAyX;
       cdAyX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAyZ; else goto cdAyY;
       cdAyZ: // global
           HpAlloc = 32;
           goto cdAyW;
       cdAyW: // global
           R1 = _sdypu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdypu::P64;
           _sdypp::P64 = P64[_sdypu::P64 + 16];
           _sdypq::P64 = P64[_sdypu::P64 + 24];
           _sdypr::P64 = P64[_sdypu::P64 + 32];
           I64[Hp - 24] = sat_sdypt_info;
           P64[Hp - 16] = _sdypq::P64;
           I64[Hp - 8] = sat_sdyps_info;
           P64[Hp] = _sdypp::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdypr::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec8_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAz0,
                       label: Data.Functor.Classes.$w$cliftReadsPrec8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAz0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAz4; else goto cdAz3;
       cdAz4: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAz3: // global
           I64[Hp - 32] = sat_sdypu_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.023836251 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_entry() //  [R2,
                                                                  R4, R6]
         { info_tbl: [(cdAz9,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAz9: // global
           _sdypx::P64 = R4;
           R4 = R6;
           R3 = _sdypx::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec8_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.025553572 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAzn,
                       label: Data.Functor.Classes.$fEq1Maybe_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAzn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAzo; else goto cdAzp;
       cdAzo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAzp: // global
           I64[Sp - 24] = block_cdAzg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAA0; else goto cdAzh;
       udAA0: // global
           call _cdAzg(R1) args: 0, res: 0, upd: 0;
       cdAzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAzg() //  [R1]
         { info_tbl: [(cdAzg,
                       label: block_cdAzg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAzg: // global
           _sdypC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdAzk; else goto cdAzl;
       cdAzk: // global
           I64[Sp + 16] = block_cdAzs_info;
           R1 = _sdypC::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udAzY; else goto cdAzu;
       udAzY: // global
           call _cdAzs(R1) args: 0, res: 0, upd: 0;
       cdAzu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdAzl: // global
           I64[Sp] = block_cdAzH_info;
           _sdypG::P64 = P64[R1 + 6];
           R1 = _sdypC::P64;
           P64[Sp + 16] = _sdypG::P64;
           if (R1 & 7 != 0) goto udAzZ; else goto cdAzJ;
       udAzZ: // global
           call _cdAzH(R1) args: 0, res: 0, upd: 0;
       cdAzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAzs() //  [R1]
         { info_tbl: [(cdAzs,
                       label: block_cdAzs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAzs: // global
           if (R1 & 7 == 1) goto cdAzA; else goto udAzX;
       cdAzA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udAzX: // global
           Sp = Sp + 8;
           call _cdAzP() args: 0, res: 0, upd: 0;
     }
 },
 _cdAzH() //  [R1]
         { info_tbl: [(cdAzH,
                       label: block_cdAzH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAzH: // global
           if (R1 & 7 == 1) goto udAzW; else goto cdAzT;
       udAzW: // global
           Sp = Sp + 24;
           call _cdAzP() args: 0, res: 0, upd: 0;
       cdAzT: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdAzP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAzP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.027496432 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_closure" {
     Data.Functor.Classes.$fEq1Maybe_closure:
         const Data.Functor.Classes.$fEq1Maybe_info;
 },
 Data.Functor.Classes.$fEq1Maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAA7,
                       label: Data.Functor.Classes.$fEq1Maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAA7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.029109135 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdAAl,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAAm; else goto udAB6;
       cdAAm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udAB6: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdAAb() args: 0, res: 0, upd: 0;
     }
 },
 _cdAAb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAb: // global
           I64[Sp - 8] = block_cdAAe_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udABb; else goto cdAAf;
       udABb: // global
           call _cdAAe(R1) args: 0, res: 0, upd: 0;
       cdAAf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAAe() //  [R1]
         { info_tbl: [(cdAAe,
                       label: block_cdAAe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAe: // global
           _sdypL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdAAi; else goto cdAAj;
       cdAAi: // global
           I64[Sp + 24] = block_cdAAq_info;
           R1 = _sdypL::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udABc; else goto cdAAs;
       udABc: // global
           call _cdAAq(R1) args: 0, res: 0, upd: 0;
       cdAAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdAAj: // global
           I64[Sp] = block_cdAAF_info;
           _sdypQ::P64 = P64[R1 + 6];
           _sdypR::P64 = P64[R1 + 14];
           R1 = _sdypL::P64;
           P64[Sp + 16] = _sdypR::P64;
           P64[Sp + 24] = _sdypQ::P64;
           if (R1 & 7 != 0) goto udABd; else goto cdAAH;
       udABd: // global
           call _cdAAF(R1) args: 0, res: 0, upd: 0;
       cdAAH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAAq() //  [R1]
         { info_tbl: [(cdAAq,
                       label: block_cdAAq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAq: // global
           if (R1 & 7 == 1) goto cdAAy; else goto udABa;
       cdAAy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udABa: // global
           Sp = Sp + 8;
           call _cdAAY() args: 0, res: 0, upd: 0;
     }
 },
 _cdAAF() //  [R1]
         { info_tbl: [(cdAAF,
                       label: block_cdAAF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAF: // global
           if (R1 & 7 == 1) goto udAB7; else goto cdAAS;
       udAB7: // global
           Sp = Sp + 32;
           call _cdAAY() args: 0, res: 0, upd: 0;
       cdAAS: // global
           I64[Sp] = block_cdAAQ_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdypU::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdypU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAAQ() //  [R1]
         { info_tbl: [(cdAAQ,
                       label: block_cdAAQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAQ: // global
           if (R1 & 7 == 1) goto udAB8; else goto cdAB2;
       udAB8: // global
           Sp = Sp + 32;
           call _cdAAY() args: 0, res: 0, upd: 0;
       cdAB2: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdAAb() args: 0, res: 0, upd: 0;
     }
 },
 _cdAAY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAAY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.031423765 UTC

[section ""data" . Data.Functor.Classes.$fEq1[]_closure" {
     Data.Functor.Classes.$fEq1[]_closure:
         const Data.Functor.Classes.$fEq1[]_info;
 },
 Data.Functor.Classes.$fEq1[]_entry() //  [R2, R3, R4]
         { info_tbl: [(cdABn,
                       label: Data.Functor.Classes.$fEq1[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdABn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.032551941 UTC

[section ""data" . Data.Functor.Classes.$w$cliftEq_closure" {
     Data.Functor.Classes.$w$cliftEq_closure:
         const Data.Functor.Classes.$w$cliftEq_info;
 },
 Data.Functor.Classes.$w$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdABA,
                       label: Data.Functor.Classes.$w$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdABA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdABB; else goto cdABC;
       cdABB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdABC: // global
           I64[Sp - 32] = block_cdABu_info;
           _sdypX::P64 = R3;
           R3 = R5;
           _sdypW::P64 = R2;
           R2 = _sdypX::P64;
           R1 = _sdypW::P64;
           P64[Sp - 24] = _sdypW::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdABu() //  [R1]
         { info_tbl: [(cdABu,
                       label: block_cdABu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdABu: // global
           if (R1 & 7 == 1) goto cdABx; else goto cdABy;
       cdABx: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdABy: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.03416246 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdABQ,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdABQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdABU; else goto cdABV;
       cdABU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdABV: // global
           I64[Sp - 24] = block_cdABN_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAC3; else goto cdABO;
       udAC3: // global
           call _cdABN(R1) args: 0, res: 0, upd: 0;
       cdABO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdABN() //  [R1]
         { info_tbl: [(cdABN,
                       label: block_cdABN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdABN: // global
           I64[Sp - 8] = block_cdABT_info;
           _sdyq6::P64 = P64[R1 + 7];
           _sdyq7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdyq7::P64;
           P64[Sp + 16] = _sdyq6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAC2; else goto cdABX;
       udAC2: // global
           call _cdABT(R1) args: 0, res: 0, upd: 0;
       cdABX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdABT() //  [R1]
         { info_tbl: [(cdABT,
                       label: block_cdABT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdABT: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftEq_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.035716446 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAC8,
                       label: Data.Functor.Classes.$fEq1NonEmpty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAC8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.036629159 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Identity_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Identity_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdACf,
                       label: Data.Functor.Classes.$fEq1Identity_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACf: // global
           _sdyqc::P64 = R3;
           R3 = R4;
           _sdyqb::P64 = R2;
           R2 = _sdyqc::P64;
           R1 = _sdyqb::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.037593028 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_closure" {
     Data.Functor.Classes.$fEq1Identity_closure:
         const Data.Functor.Classes.$fEq1Identity_info;
 },
 Data.Functor.Classes.$fEq1Identity_entry() //  [R2, R3, R4]
         { info_tbl: [(cdACm,
                       label: Data.Functor.Classes.$fEq1Identity_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Identity_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.038511025 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry() //  []
         { info_tbl: [(cdACt,
                       label: Data.Functor.Classes.$fEq1Proxy_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACt: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.039396339 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_closure" {
     Data.Functor.Classes.$fEq1Proxy_closure:
         const Data.Functor.Classes.$fEq1Proxy_info;
 },
 Data.Functor.Classes.$fEq1Proxy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdACA,
                       label: Data.Functor.Classes.$fEq1Proxy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.040765967 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdACO,
                       label: Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdACP; else goto cdACQ;
       cdACP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdACQ: // global
           I64[Sp - 24] = block_cdACH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udADp; else goto cdACI;
       udADp: // global
           call _cdACH(R1) args: 0, res: 0, upd: 0;
       cdACI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdACH() //  [R1]
         { info_tbl: [(cdACH,
                       label: block_cdACH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACH: // global
           _sdyqj::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdACL; else goto cdACM;
       cdACL: // global
           I64[Sp + 16] = block_cdACT_info;
           R1 = _sdyqj::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udADn; else goto cdACV;
       udADn: // global
           call _cdACT(R1) args: 0, res: 0, upd: 0;
       cdACV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdACM: // global
           I64[Sp] = block_cdAD8_info;
           _sdyqn::P64 = P64[R1 + 6];
           R1 = _sdyqj::P64;
           P64[Sp + 16] = _sdyqn::P64;
           if (R1 & 7 != 0) goto udADo; else goto cdADa;
       udADo: // global
           call _cdAD8(R1) args: 0, res: 0, upd: 0;
       cdADa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdACT() //  [R1]
         { info_tbl: [(cdACT,
                       label: block_cdACT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdACT: // global
           if (R1 & 7 == 1) goto cdAD1; else goto cdAD5;
       cdAD1: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAD5: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdAD8() //  [R1]
         { info_tbl: [(cdAD8,
                       label: block_cdAD8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAD8: // global
           if (R1 & 7 == 1) goto cdADg; else goto cdADk;
       cdADg: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdADk: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.042579096 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_closure" {
     Data.Functor.Classes.$fOrd1Maybe_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.044122519 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdADB,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdADB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdADC; else goto udAEr;
       cdADC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udAEr: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdADr() args: 0, res: 0, upd: 0;
     }
 },
 _cdADr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdADr: // global
           I64[Sp - 8] = block_cdADu_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAEx; else goto cdADv;
       udAEx: // global
           call _cdADu(R1) args: 0, res: 0, upd: 0;
       cdADv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdADu() //  [R1]
         { info_tbl: [(cdADu,
                       label: block_cdADu_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdADu: // global
           _sdyqs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdADy; else goto cdADz;
       cdADy: // global
           I64[Sp + 24] = block_cdADG_info;
           R1 = _sdyqs::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udAEy; else goto cdADI;
       udAEy: // global
           call _cdADG(R1) args: 0, res: 0, upd: 0;
       cdADI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdADz: // global
           I64[Sp] = block_cdADV_info;
           _sdyqx::P64 = P64[R1 + 6];
           _sdyqy::P64 = P64[R1 + 14];
           R1 = _sdyqs::P64;
           P64[Sp + 16] = _sdyqy::P64;
           P64[Sp + 24] = _sdyqx::P64;
           if (R1 & 7 != 0) goto udAEz; else goto cdADX;
       udAEz: // global
           call _cdADV(R1) args: 0, res: 0, upd: 0;
       cdADX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdADG() //  [R1]
         { info_tbl: [(cdADG,
                       label: block_cdADG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdADG: // global
           if (R1 & 7 == 1) goto cdADO; else goto udAEw;
       cdADO: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udAEw: // global
           Sp = Sp + 8;
           call _cdAEe() args: 0, res: 0, upd: 0;
     }
 },
 _cdADV() //  [R1]
         { info_tbl: [(cdADV,
                       label: block_cdADV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdADV: // global
           if (R1 & 7 == 1) goto udAEs; else goto cdAE8;
       udAEs: // global
           Sp = Sp + 32;
           call _cdAEm() args: 0, res: 0, upd: 0;
       cdAE8: // global
           I64[Sp] = block_cdAE6_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdyqB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdyqB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAE6() //  [R1]
         { info_tbl: [(cdAE6,
                       label: block_cdAE6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAE6: // global
           _cdAEo::P64 = R1 & 7;
           if (_cdAEo::P64 < 3) goto udAEq; else goto udAEt;
       udAEq: // global
           if (_cdAEo::P64 < 2) goto udAEu; else goto cdAEi;
       udAEu: // global
           Sp = Sp + 32;
           call _cdAEe() args: 0, res: 0, upd: 0;
       cdAEi: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdADr() args: 0, res: 0, upd: 0;
       udAEt: // global
           Sp = Sp + 32;
           call _cdAEm() args: 0, res: 0, upd: 0;
     }
 },
 _cdAEe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAEe: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdAEm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAEm: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.046476621 UTC

[section ""data" . Data.Functor.Classes.$fOrd1[]_closure" {
     Data.Functor.Classes.$fOrd1[]_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.047465953 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare1_closure" {
     Data.Functor.Classes.$w$cliftCompare1_closure:
         const Data.Functor.Classes.$w$cliftCompare1_info;
 },
 Data.Functor.Classes.$w$cliftCompare1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdAER,
                       label: Data.Functor.Classes.$w$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAER: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAES; else goto cdAET;
       cdAES: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAET: // global
           I64[Sp - 32] = block_cdAEK_info;
           _sdyqE::P64 = R3;
           R3 = R5;
           _sdyqD::P64 = R2;
           R2 = _sdyqE::P64;
           R1 = _sdyqD::P64;
           P64[Sp - 24] = _sdyqD::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAEK() //  [R1]
         { info_tbl: [(cdAEK,
                       label: block_cdAEK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAEK: // global
           _cdAEQ::P64 = R1 & 7;
           if (_cdAEQ::P64 < 3) goto udAF3; else goto cdAEP;
       udAF3: // global
           if (_cdAEQ::P64 < 2) goto cdAEN; else goto cdAEO;
       cdAEN: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAEO: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       cdAEP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.049129591 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdAFb,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAFf; else goto cdAFg;
       cdAFf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAFg: // global
           I64[Sp - 24] = block_cdAF8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAFo; else goto cdAF9;
       udAFo: // global
           call _cdAF8(R1) args: 0, res: 0, upd: 0;
       cdAF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAF8() //  [R1]
         { info_tbl: [(cdAF8,
                       label: block_cdAF8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAF8: // global
           I64[Sp - 8] = block_cdAFe_info;
           _sdyqN::P64 = P64[R1 + 7];
           _sdyqO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdyqO::P64;
           P64[Sp + 16] = _sdyqN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAFn; else goto cdAFi;
       udAFn: // global
           call _cdAFe(R1) args: 0, res: 0, upd: 0;
       cdAFi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAFe() //  [R1]
         { info_tbl: [(cdAFe,
                       label: block_cdAFe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFe: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.050618942 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.05138549 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Identity_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdAFt,
                       label: Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFt: // global
           _sdyqT::P64 = R3;
           R3 = R4;
           _sdyqS::P64 = R2;
           R2 = _sdyqT::P64;
           R1 = _sdyqS::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.052205843 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_closure" {
     Data.Functor.Classes.$fOrd1Identity_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.053015725 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_entry() //  []
         { info_tbl: [(cdAFA,
                       label: Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFA: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.053863801 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_closure" {
     Data.Functor.Classes.$fOrd1Proxy_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.054672346 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadPrec_entry() //  [R3]
         { info_tbl: [(cdAFH,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFH: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.055445837 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1NonEmpty4_bytes" {
     Data.Functor.Classes.$fRead1NonEmpty4_bytes:
         I8[] [58,124]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.056507732 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty3_closure" {
     Data.Functor.Classes.$fRead1NonEmpty3_closure:
         const Data.Functor.Classes.$fRead1NonEmpty3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty3_entry() //  [R1]
         { info_tbl: [(cdAFQ,
                       label: Data.Functor.Classes.$fRead1NonEmpty3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAFR; else goto cdAFS;
       cdAFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAFS: // global
           (_cdAFN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdAFN::I64 == 0) goto cdAFP; else goto cdAFO;
       cdAFP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdAFO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdAFN::I64;
           R2 = Data.Functor.Classes.$fRead1NonEmpty4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.057554388 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty2_closure" {
     Data.Functor.Classes.$fRead1NonEmpty2_closure:
         const GHC.Types.I#_con_info;
         const 6;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.060448627 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec5_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec5_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec5_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAFU: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sdyrn_entry() //  [R1, R2]
         { info_tbl: [(cdAGN,
                       label: go2_sdyrn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAGO; else goto cdAGP;
       cdAGO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAGP: // global
           I64[Sp - 32] = block_cdAGG_info;
           _sdyrn::P64 = R1;
           _sdyra::P64 = P64[R1 + 7];
           _sdyrm::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdyra::P64;
           P64[Sp - 16] = _sdyrm::P64;
           P64[Sp - 8] = _sdyrn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAH9; else goto cdAGH;
       udAH9: // global
           call _cdAGG(R1) args: 0, res: 0, upd: 0;
       cdAGH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAGG() //  [R1]
         { info_tbl: [(cdAGG,
                       label: block_cdAGG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGG: // global
           if (R1 & 7 == 1) goto cdAGK; else goto cdAGL;
       cdAGK: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdAGL: // global
           I64[Sp] = block_cdAGV_info;
           _sdyrr::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdyrr::P64;
           if (R1 & 7 != 0) goto udAH8; else goto cdAGW;
       udAH8: // global
           call _cdAGV(R1) args: 0, res: 0, upd: 0;
       cdAGW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAGV() //  [R1]
         { info_tbl: [(cdAGV,
                       label: block_cdAGV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGV: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdAH7; else goto cdAH6;
       cdAH7: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAH6: // global
           _sdyrt::P64 = P64[R1 + 7];
           _sdyru::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_2_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = GHC.Base.:|_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sdyrt::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = _sdyru::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sdyrd_entry() //  [R1, R2]
         { info_tbl: [(cdAHe,
                       label: go1_sdyrd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAHe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdAHf; else goto udAHz;
       cdAHf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udAHz: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdAGh() args: 0, res: 0, upd: 0;
     }
 },
 _cdAGh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGh: // global
           I64[Sp - 24] = block_cdAGk_info;
           R1 = P64[Sp + 8];
           _sdyrd::P64 = P64[Sp];
           P64[Sp - 16] = P64[_sdyrd::P64 + 15];
           P64[Sp - 8] = P64[_sdyrd::P64 + 23];
           P64[Sp + 8] = P64[_sdyrd::P64 + 7];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAHB; else goto cdAGl;
       udAHB: // global
           call _cdAGk(R1) args: 0, res: 0, upd: 0;
       cdAGl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAGk() //  [R1]
         { info_tbl: [(cdAGk,
                       label: block_cdAGk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGk: // global
           if (R1 & 7 == 1) goto cdAHb; else goto cdAHc;
       cdAHb: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdAHc: // global
           I64[Sp] = block_cdAGq_info;
           _sdyrh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdyrh::P64;
           if (R1 & 7 != 0) goto udAHC; else goto cdAGr;
       udAHC: // global
           call _cdAGq(R1) args: 0, res: 0, upd: 0;
       cdAGr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAGq() //  [R1]
         { info_tbl: [(cdAGq,
                       label: block_cdAGq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGq: // global
           I64[Sp - 8] = block_cdAGv_info;
           R3 = Data.Functor.Classes.$fRead1NonEmpty3_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAGv() //  [R1]
         { info_tbl: [(cdAGv,
                       label: block_cdAGv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAGv: // global
           _sdyrh::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdAHo; else goto cdAHq;
       cdAHo: // global
           P64[Sp + 40] = _sdyrh::P64;
           Sp = Sp + 32;
           call _cdAGh() args: 0, res: 0, upd: 0;
       cdAHq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAHt; else goto cdAHs;
       cdAHt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAHs: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdyrh::P64;
           I64[Hp - 16] = go2_sdyrn_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           I64[Sp + 32] = block_cdAHp_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAHp() //  [R1]
         { info_tbl: [(cdAHp,
                       label: block_cdAHp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAHp: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_sdyrn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyr4_entry() //  [R1, R2]
         { info_tbl: [(cdAHJ,
                       label: go_sdyr4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAHJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAHK; else goto cdAHL;
       cdAHK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAHL: // global
           I64[Sp - 24] = block_cdAG3_info;
           _sdyr4::P64 = R1;
           _sdyr1::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyr1::P64;
           P64[Sp - 8] = _sdyr4::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udAHY; else goto cdAG4;
       udAHY: // global
           call _cdAG3(R1) args: 0, res: 0, upd: 0;
       cdAG4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAG3() //  [R1]
         { info_tbl: [(cdAG3,
                       label: block_cdAG3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAG3: // global
           if (R1 & 7 == 1) goto cdAHG; else goto cdAHH;
       cdAHG: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAHH: // global
           I64[Sp - 8] = block_cdAG9_info;
           _sdyr8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyr8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAHX; else goto cdAGa;
       udAHX: // global
           call _cdAG9(R1) args: 0, res: 0, upd: 0;
       cdAGa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAG9() //  [R1]
         { info_tbl: [(cdAG9,
                       label: block_cdAG9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAG9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAHS; else goto cdAHR;
       cdAHS: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAHR: // global
           _sdyra::P64 = P64[R1 + 7];
           _sdyrb::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyrd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _sdyra::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 16] = block_cdAHO_info;
           R3 = _sdyrb::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAHO() //  [R1]
         { info_tbl: [(cdAHO,
                       label: block_cdAHO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAHO: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyrd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyrE_entry() //  [R1, R2]
         { info_tbl: [(cdAI6,
                       label: sat_sdyrE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAI6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAI7; else goto cdAI8;
       cdAI7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAI8: // global
           I64[Sp - 16] = block_cdAI4_info;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           _sdyr4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdyr4::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAI4() //  [R1]
         { info_tbl: [(cdAI4,
                       label: block_cdAI4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAI4: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyr4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdAIe,
                       label: Data.Functor.Classes.$w$cliftReadsPrec5_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAIe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAIi; else goto cdAIh;
       cdAIi: // global
           HpAlloc = 40;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec5_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdAIh: // global
           I64[Hp - 32] = go_sdyr4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdyrE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 31;
           _sdyrB::P64 = I64[(%MO_S_Gt_W64(R4,
                                           5) << 3) + GHC.Types.Bool_closure_tbl];
           R4 = R5;
           R3 = Hp - 15;
           R2 = _sdyrB::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.066185634 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdAIq,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAIq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAIr; else goto cdAIs;
       cdAIr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAIs: // global
           I64[Sp - 32] = block_cdAIn_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAIw; else goto cdAIo;
       udAIw: // global
           call _cdAIn(R1) args: 0, res: 0, upd: 0;
       cdAIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAIn() //  [R1]
         { info_tbl: [(cdAIn,
                       label: block_cdAIn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAIn: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.067453396 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Proxy4_bytes" {
     Data.Functor.Classes.$fRead1Proxy4_bytes:
         I8[] [80,114,111,120,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.068297828 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy3_closure" {
     Data.Functor.Classes.$fRead1Proxy3_closure:
         const Data.Functor.Classes.$fRead1Proxy3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy3_entry() //  [R1]
         { info_tbl: [(cdAID,
                       label: Data.Functor.Classes.$fRead1Proxy3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAID: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAIE; else goto cdAIF;
       cdAIE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAIF: // global
           (_cdAIA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdAIA::I64 == 0) goto cdAIC; else goto cdAIB;
       cdAIC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdAIB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdAIA::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.069311871 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_lexeme_closure" {
     Data.Functor.Classes.$fRead1Proxy_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.070373724 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy2_closure" {
     Data.Functor.Classes.$fRead1Proxy2_closure:
         const Data.Functor.Classes.$fRead1Proxy2_info;
         const 0;
 },
 sat_sdyrO_entry() //  [R1]
         { info_tbl: [(cdAIP,
                       label: sat_sdyrO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAIP: // global
           R2 = Data.Proxy.Proxy_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Proxy2_entry() //  [R2, R3]
         { info_tbl: [(cdAIV,
                       label: Data.Functor.Classes.$fRead1Proxy2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAIV: // global
           _sdyrM::P64 = R3;
           _sdyrL::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdAIW; else goto cdAIX;
       cdAIX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAIZ; else goto cdAIY;
       cdAIZ: // global
           HpAlloc = 16;
           goto cdAIW;
       cdAIW: // global
           R3 = _sdyrM::P64;
           R2 = _sdyrL::P64;
           R1 = Data.Functor.Classes.$fRead1Proxy2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAIY: // global
           I64[Hp - 8] = sat_sdyrO_info;
           P64[Hp] = _sdyrM::P64;
           I64[Sp - 8] = block_cdAIS_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Proxy_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAIS() //  [R1]
         { info_tbl: [(cdAIS,
                       label: block_cdAIS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAIS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAJ2; else goto cdAJ1;
       cdAJ2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAJ1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.071939838 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy1_closure" {
     Data.Functor.Classes.$fRead1Proxy1_closure:
         const Data.Functor.Classes.$fRead1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy1_entry() //  [R2, R3]
         { info_tbl: [(cdAJ7,
                       label: Data.Functor.Classes.$fRead1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJ7: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.072912004 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy5_closure" {
     Data.Functor.Classes.$fRead1Proxy5_closure:
         const Data.Functor.Classes.$fRead1Proxy5_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy5_entry() //  [R4, R5]
         { info_tbl: [(cdAJe,
                       label: Data.Functor.Classes.$fRead1Proxy5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJe: // global
           R3 = R5;
           R2 = R4;
           call Data.Functor.Classes.$fRead1Proxy1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.073872649 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_entry() //  [R3]
         { info_tbl: [(cdAJl,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJl: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.076358146 UTC

[section ""cstring" . Data.Functor.Classes.$fShow1NonEmpty1_bytes" {
     Data.Functor.Classes.$fShow1NonEmpty1_bytes:
         I8[] [32,58,124,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.078470598 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec1_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec1_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec1_info;
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJp: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 f_sdys1_entry() //  [R1]
         { info_tbl: [(cdAJx,
                       label: f_sdys1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAJy; else goto cdAJz;
       cdAJy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAJz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdys6_entry() //  [R1]
         { info_tbl: [(cdAJO,
                       label: sat_sdys6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJO: // global
           _sdys6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAJP; else goto cdAJQ;
       cdAJQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAJS; else goto cdAJR;
       cdAJS: // global
           HpAlloc = 32;
           goto cdAJP;
       cdAJP: // global
           R1 = _sdys6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAJR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdys6::P64;
           _sdys2::P64 = P64[_sdys6::P64 + 16];
           _sdys4::P64 = P64[_sdys6::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys4::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdys7_entry() //  [R1, R2]
         { info_tbl: [(cdAJT,
                       label: sat_sdys7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAJT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAJX; else goto cdAJW;
       cdAJX: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAJW: // global
           _sdys1::P64 = P64[R1 + 7];
           _sdys2::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdys6_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdys1::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdysa_entry() //  [R1]
         { info_tbl: [(cdAKh,
                       label: sat_sdysa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKh: // global
           _sdysa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAKi; else goto cdAKj;
       cdAKj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAKl; else goto cdAKk;
       cdAKl: // global
           HpAlloc = 24;
           goto cdAKi;
       cdAKi: // global
           R1 = _sdysa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAKk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysa::P64;
           _sdys2::P64 = P64[_sdysa::P64 + 16];
           _sdys8::P64 = P64[_sdysa::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdys8::P64;
           R2 = Hp - 14;
           R1 = _sdys2::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysb_entry() //  [R1]
         { info_tbl: [(cdAKm,
                       label: sat_sdysb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKm: // global
           _sdysb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAKn; else goto cdAKo;
       cdAKo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAKq; else goto cdAKp;
       cdAKq: // global
           HpAlloc = 32;
           goto cdAKn;
       cdAKn: // global
           R1 = _sdysb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysb::P64;
           _sdys2::P64 = P64[_sdysb::P64 + 16];
           _sdys8::P64 = P64[_sdysb::P64 + 24];
           I64[Hp - 24] = sat_sdysa_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys8::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysc_entry() //  [R1]
         { info_tbl: [(cdAKr,
                       label: sat_sdysc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKr: // global
           _sdysc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAKs; else goto cdAKt;
       cdAKt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAKv; else goto cdAKu;
       cdAKv: // global
           HpAlloc = 32;
           goto cdAKs;
       cdAKs: // global
           R1 = _sdysc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAKu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysc::P64;
           _sdys1::P64 = P64[_sdysc::P64 + 16];
           _sdys2::P64 = P64[_sdysc::P64 + 24];
           _sdys8::P64 = P64[_sdysc::P64 + 32];
           I64[Hp - 24] = sat_sdysb_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys8::P64;
           R2 = Hp - 24;
           R1 = _sdys1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysd_entry() //  [R1, R2]
         { info_tbl: [(cdAKx,
                       label: sat_sdysd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAKB; else goto cdAKA;
       cdAKB: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAKA: // global
           _sdys1::P64 = P64[R1 + 7];
           _sdys2::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdysc_info;
           P64[Hp - 40] = _sdys1::P64;
           P64[Hp - 32] = _sdys2::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cdAKF,
                       label: Data.Functor.Classes.$w$cliftShowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdAKJ; else goto cdAKI;
       cdAKJ: // global
           HpAlloc = 88;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdAKI: // global
           I64[Hp - 80] = f_sdys1_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdAJt::P64 = Hp - 80;
           _cdAJA::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 5)) goto cdAKD; else goto cdAKE;
       cdAKD: // global
           I64[Hp - 16] = sat_sdys7_info;
           P64[Hp - 8] = _cdAJt::P64;
           P64[Hp] = _cdAJA::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAKE: // global
           I64[Hp - 16] = sat_sdysd_info;
           P64[Hp - 8] = _cdAJt::P64;
           P64[Hp] = _cdAJA::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.082407637 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdAKR,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAKV; else goto cdAKW;
       cdAKV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAKW: // global
           I64[Sp - 32] = block_cdAKO_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAL4; else goto cdAKP;
       udAL4: // global
           call _cdAKO(R1) args: 0, res: 0, upd: 0;
       cdAKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAKO() //  [R1]
         { info_tbl: [(cdAKO,
                       label: block_cdAKO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKO: // global
           I64[Sp] = block_cdAKU_info;
           _sdysj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sdysj::I64;
           if (R1 & 7 != 0) goto udAL3; else goto cdAKY;
       udAL3: // global
           call _cdAKU(R1) args: 0, res: 0, upd: 0;
       cdAKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAKU() //  [R1]
         { info_tbl: [(cdAKU,
                       label: block_cdAKU_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAKU: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.083854904 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy2_closure" {
     Data.Functor.Classes.$fShow1Proxy2_closure:
         const Data.Functor.Classes.$fShow1Proxy2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy2_entry() //  [R2]
         { info_tbl: [(cdAL9,
                       label: Data.Functor.Classes.$fShow1Proxy2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAL9: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.084718275 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_entry() //  [R6]
         { info_tbl: [(cdALg,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdALg: // global
           R2 = R6;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.085929697 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdALq,
                       label: Data.Functor.Classes.$fEq2(,)_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdALq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdALu; else goto cdALv;
       cdALu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdALv: // global
           I64[Sp - 32] = block_cdALn_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udALP; else goto cdALo;
       udALP: // global
           call _cdALn(R1) args: 0, res: 0, upd: 0;
       cdALo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdALn() //  [R1]
         { info_tbl: [(cdALn,
                       label: block_cdALn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdALn: // global
           I64[Sp - 8] = block_cdALt_info;
           _sdysw::P64 = P64[R1 + 7];
           _sdysx::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdysx::P64;
           P64[Sp + 24] = _sdysw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udALO; else goto cdALx;
       udALO: // global
           call _cdALt(R1) args: 0, res: 0, upd: 0;
       cdALx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdALt() //  [R1]
         { info_tbl: [(cdALt,
                       label: block_cdALt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdALt: // global
           I64[Sp] = block_cdALB_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdysA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdysA::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdALB() //  [R1]
         { info_tbl: [(cdALB,
                       label: block_cdALB_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdALB: // global
           if (R1 & 7 == 1) goto cdALI; else goto cdALM;
       cdALI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdALM: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.087676469 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_closure" {
     Data.Functor.Classes.$fEq2(,)_closure:
         const Data.Functor.Classes.$fEq2(,)_info;
 },
 Data.Functor.Classes.$fEq2(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdALU,
                       label: Data.Functor.Classes.$fEq2(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdALU: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.08892328 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1(,)_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1(,)_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1(,)_$cliftEq_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAM4,
                       label: Data.Functor.Classes.$fEq1(,)_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAM4: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdAM8; else goto cdAM9;
       cdAM8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1(,)_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAM9: // global
           I64[Sp - 32] = block_cdAM1_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAMt; else goto cdAM2;
       udAMt: // global
           call _cdAM1(R1) args: 0, res: 0, upd: 0;
       cdAM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAM1() //  [R1]
         { info_tbl: [(cdAM1,
                       label: block_cdAM1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAM1: // global
           I64[Sp - 8] = block_cdAM7_info;
           _sdysH::P64 = P64[R1 + 7];
           _sdysI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdysI::P64;
           P64[Sp + 24] = _sdysH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAMs; else goto cdAMb;
       udAMs: // global
           call _cdAM7(R1) args: 0, res: 0, upd: 0;
       cdAMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAM7() //  [R1]
         { info_tbl: [(cdAM7,
                       label: block_cdAM7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAM7: // global
           I64[Sp] = block_cdAMf_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdAMf() //  [R1]
         { info_tbl: [(cdAMf,
                       label: block_cdAMf_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAMf: // global
           if (R1 & 7 == 1) goto cdAMm; else goto cdAMq;
       cdAMm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAMq: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.090797732 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_closure" {
     Data.Functor.Classes.$fEq1(,)_closure:
         const Data.Functor.Classes.$fEq1(,)_info;
 },
 Data.Functor.Classes.$fEq1(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAMy,
                       label: Data.Functor.Classes.$fEq1(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAMy: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1(,)_$cliftEq_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.092163282 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Either_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Either_$cliftEq2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdAMM,
                       label: Data.Functor.Classes.$fEq2Either_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAMM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAMN; else goto cdAMO;
       cdAMN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2Either_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAMO: // global
           I64[Sp - 32] = block_cdAMF_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udANp; else goto cdAMG;
       udANp: // global
           call _cdAMF(R1) args: 0, res: 0, upd: 0;
       cdAMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAMF() //  [R1]
         { info_tbl: [(cdAMF,
                       label: block_cdAMF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAMF: // global
           _sdysQ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdAMJ; else goto cdAMK;
       cdAMJ: // global
           I64[Sp] = block_cdAMR_info;
           _sdysS::P64 = P64[R1 + 7];
           R1 = _sdysQ::P64;
           P64[Sp + 24] = _sdysS::P64;
           if (R1 & 7 != 0) goto udANn; else goto cdAMT;
       udANn: // global
           call _cdAMR(R1) args: 0, res: 0, upd: 0;
       cdAMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdAMK: // global
           I64[Sp + 8] = block_cdAN6_info;
           _sdysW::P64 = P64[R1 + 6];
           R1 = _sdysQ::P64;
           P64[Sp + 24] = _sdysW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udANo; else goto cdAN8;
       udANo: // global
           call _cdAN6(R1) args: 0, res: 0, upd: 0;
       cdAN8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAMR() //  [R1]
         { info_tbl: [(cdAMR,
                       label: block_cdAMR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAMR: // global
           if (R1 & 7 == 1) goto cdAMZ; else goto udANm;
       cdAMZ: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       udANm: // global
           Sp = Sp + 32;
           call _cdANe() args: 0, res: 0, upd: 0;
     }
 },
 _cdAN6() //  [R1]
         { info_tbl: [(cdAN6,
                       label: block_cdAN6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAN6: // global
           if (R1 & 7 == 1) goto udANl; else goto cdANi;
       udANl: // global
           Sp = Sp + 24;
           call _cdANe() args: 0, res: 0, upd: 0;
       cdANi: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdANe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdANe: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.094103586 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_closure" {
     Data.Functor.Classes.$fEq2Either_closure:
         const Data.Functor.Classes.$fEq2Either_info;
 },
 Data.Functor.Classes.$fEq2Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdANw,
                       label: Data.Functor.Classes.$fEq2Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdANw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Either_$cliftEq2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.095526688 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Either_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Either_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Either_$cliftEq_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdANK,
                       label: Data.Functor.Classes.$fEq1Either_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdANK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdANL; else goto cdANM;
       cdANL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Either_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdANM: // global
           I64[Sp - 32] = block_cdAND_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAOn; else goto cdANE;
       udAOn: // global
           call _cdAND(R1) args: 0, res: 0, upd: 0;
       cdANE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAND() //  [R1]
         { info_tbl: [(cdAND,
                       label: block_cdAND_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAND: // global
           _sdyt3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdANH; else goto cdANI;
       cdANH: // global
           I64[Sp] = block_cdANP_info;
           _sdyt5::P64 = P64[R1 + 7];
           R1 = _sdyt3::P64;
           P64[Sp + 24] = _sdyt5::P64;
           if (R1 & 7 != 0) goto udAOl; else goto cdANR;
       udAOl: // global
           call _cdANP(R1) args: 0, res: 0, upd: 0;
       cdANR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdANI: // global
           I64[Sp + 8] = block_cdAO4_info;
           _sdyt9::P64 = P64[R1 + 6];
           R1 = _sdyt3::P64;
           P64[Sp + 24] = _sdyt9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udAOm; else goto cdAO6;
       udAOm: // global
           call _cdAO4(R1) args: 0, res: 0, upd: 0;
       cdAO6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdANP() //  [R1]
         { info_tbl: [(cdANP,
                       label: block_cdANP_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdANP: // global
           if (R1 & 7 == 1) goto cdANX; else goto udAOk;
       cdANX: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
       udAOk: // global
           Sp = Sp + 32;
           call _cdAOc() args: 0, res: 0, upd: 0;
     }
 },
 _cdAO4() //  [R1]
         { info_tbl: [(cdAO4,
                       label: block_cdAO4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAO4: // global
           if (R1 & 7 == 1) goto udAOj; else goto cdAOg;
       udAOj: // global
           Sp = Sp + 24;
           call _cdAOc() args: 0, res: 0, upd: 0;
       cdAOg: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdAOc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAOc: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.097462814 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_closure" {
     Data.Functor.Classes.$fEq1Either_closure:
         const Data.Functor.Classes.$fEq1Either_info;
 },
 Data.Functor.Classes.$fEq1Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAOu,
                       label: Data.Functor.Classes.$fEq1Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAOu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Either_$cliftEq_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.098378245 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Const_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Const_$cliftEq2_entry() //  [R2, R4, R5]
         { info_tbl: [(cdAOB,
                       label: Data.Functor.Classes.$fEq2Const_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAOB: // global
           R3 = R5;
           _sdytd::P64 = R2;
           R2 = R4;
           R1 = _sdytd::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.099260644 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_closure" {
     Data.Functor.Classes.$fEq2Const_closure:
         const Data.Functor.Classes.$fEq2Const_info;
 },
 Data.Functor.Classes.$fEq2Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAOI,
                       label: Data.Functor.Classes.$fEq2Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAOI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Const_$cliftEq2_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.100174998 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Const_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Const_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Const_$cliftEq_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdAOP,
                       label: Data.Functor.Classes.$fEq1Const_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAOP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAOQ; else goto cdAOR;
       cdAOQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Const_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAOR: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.101197816 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_closure" {
     Data.Functor.Classes.$fEq1Const_closure:
         const Data.Functor.Classes.$fEq1Const_info;
 },
 Data.Functor.Classes.$fEq1Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAOW,
                       label: Data.Functor.Classes.$fEq1Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAOW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Const_$cliftEq_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.102799879 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdAP6,
                       label: Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAP6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAPa; else goto cdAPb;
       cdAPa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAPb: // global
           I64[Sp - 32] = block_cdAP3_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAPA; else goto cdAP4;
       udAPA: // global
           call _cdAP3(R1) args: 0, res: 0, upd: 0;
       cdAP4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAP3() //  [R1]
         { info_tbl: [(cdAP3,
                       label: block_cdAP3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAP3: // global
           I64[Sp - 8] = block_cdAP9_info;
           _sdytq::P64 = P64[R1 + 7];
           _sdytr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdytr::P64;
           P64[Sp + 24] = _sdytq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAPz; else goto cdAPd;
       udAPz: // global
           call _cdAP9(R1) args: 0, res: 0, upd: 0;
       cdAPd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAP9() //  [R1]
         { info_tbl: [(cdAP9,
                       label: block_cdAP9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAP9: // global
           I64[Sp] = block_cdAPh_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdytu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdytu::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAPh() //  [R1]
         { info_tbl: [(cdAPh,
                       label: block_cdAPh_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAPh: // global
           _cdAPx::P64 = R1 & 7;
           if (_cdAPx::P64 < 3) goto udAPy; else goto cdAPw;
       udAPy: // global
           if (_cdAPx::P64 < 2) goto cdAPo; else goto cdAPs;
       cdAPo: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAPs: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAPw: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.104507457 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_closure" {
     Data.Functor.Classes.$fOrd2(,)_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.105522489 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare_closure" {
     Data.Functor.Classes.$w$cliftCompare_closure:
         const Data.Functor.Classes.$w$cliftCompare_info;
 },
 Data.Functor.Classes.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdAPM,
                       label: Data.Functor.Classes.$w$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAPM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdAPN; else goto cdAPO;
       cdAPN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAPO: // global
           I64[Sp - 24] = block_cdAPF_info;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = R4;
           P64[Sp - 32] = R6;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdAPF() //  [R1]
         { info_tbl: [(cdAPF,
                       label: block_cdAPF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAPF: // global
           _cdAPL::P64 = R1 & 7;
           if (_cdAPL::P64 < 3) goto udAPY; else goto cdAPK;
       udAPY: // global
           if (_cdAPL::P64 < 2) goto cdAPI; else goto cdAPJ;
       cdAPI: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAPJ: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAPK: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.107102845 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdAQ6,
                       label: Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQ6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAQa; else goto cdAQb;
       cdAQa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAQb: // global
           I64[Sp - 32] = block_cdAQ3_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAQj; else goto cdAQ4;
       udAQj: // global
           call _cdAQ3(R1) args: 0, res: 0, upd: 0;
       cdAQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAQ3() //  [R1]
         { info_tbl: [(cdAQ3,
                       label: block_cdAQ3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQ3: // global
           I64[Sp - 8] = block_cdAQ9_info;
           _sdytI::P64 = P64[R1 + 7];
           _sdytJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdytJ::P64;
           P64[Sp + 24] = _sdytI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAQi; else goto cdAQd;
       udAQi: // global
           call _cdAQ9(R1) args: 0, res: 0, upd: 0;
       cdAQd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAQ9() //  [R1]
         { info_tbl: [(cdAQ9,
                       label: block_cdAQ9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQ9: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.108793659 UTC

[section ""data" . Data.Functor.Classes.$w$cp1Ord1_closure" {
     Data.Functor.Classes.$w$cp1Ord1_closure:
         const Data.Functor.Classes.$w$cp1Ord1_info;
 },
 Data.Functor.Classes.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdAQq,
                       label: Data.Functor.Classes.$w$cp1Ord1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQq: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdAQr; else goto cdAQs;
       cdAQr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cp1Ord1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAQs: // global
           I64[Sp - 40] = block_cdAQo_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAQo() //  [R1]
         { info_tbl: [(cdAQo,
                       label: block_cdAQo_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQo: // global
           I64[Sp] = block_cdAQv_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdAQv() //  [R1]
         { info_tbl: [(cdAQv,
                       label: block_cdAQv_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQv: // global
           if (R1 & 7 == 1) goto cdAQC; else goto cdAQG;
       cdAQC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdAQG: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.110710511 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)1_closure" {
     Data.Functor.Classes.$fOrd1(,)1_closure:
         const Data.Functor.Classes.$fOrd1(,)1_info;
 },
 Data.Functor.Classes.$fOrd1(,)1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAQP,
                       label: Data.Functor.Classes.$fOrd1(,)1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdAQT; else goto cdAQU;
       cdAQT: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAQU: // global
           I64[Sp - 32] = block_cdAQM_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAR2; else goto cdAQN;
       udAR2: // global
           call _cdAQM(R1) args: 0, res: 0, upd: 0;
       cdAQN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAQM() //  [R1]
         { info_tbl: [(cdAQM,
                       label: block_cdAQM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQM: // global
           I64[Sp - 8] = block_cdAQS_info;
           _sdyu0::P64 = P64[R1 + 7];
           _sdyu1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdyu1::P64;
           P64[Sp + 24] = _sdyu0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udAR1; else goto cdAQW;
       udAR1: // global
           call _cdAQS(R1) args: 0, res: 0, upd: 0;
       cdAQW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAQS() //  [R1]
         { info_tbl: [(cdAQS,
                       label: block_cdAQS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAQS: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.112504343 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_closure" {
     Data.Functor.Classes.$fOrd1(,)_closure:
         const Data.Functor.Classes.$fOrd1(,)_info;
 },
 sat_sdyu7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdARc,
                       label: sat_sdyu7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARc: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyu6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdARk,
                       label: sat_sdyu6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARk: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1(,)_entry() //  [R2]
         { info_tbl: [(cdARo,
                       label: Data.Functor.Classes.$fOrd1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdARs; else goto cdARr;
       cdARs: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdARr: // global
           I64[Hp - 48] = sat_sdyu7_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyu6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.114359952 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Either_$cliftCompare2_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdARE,
                       label: Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdARF; else goto cdARG;
       cdARF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdARG: // global
           I64[Sp - 32] = block_cdARx_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udASf; else goto cdARy;
       udASf: // global
           call _cdARx(R1) args: 0, res: 0, upd: 0;
       cdARy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdARx() //  [R1]
         { info_tbl: [(cdARx,
                       label: block_cdARx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARx: // global
           _sdyub::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdARB; else goto cdARC;
       cdARB: // global
           I64[Sp] = block_cdARJ_info;
           _sdyud::P64 = P64[R1 + 7];
           R1 = _sdyub::P64;
           P64[Sp + 24] = _sdyud::P64;
           if (R1 & 7 != 0) goto udASd; else goto cdARL;
       udASd: // global
           call _cdARJ(R1) args: 0, res: 0, upd: 0;
       cdARL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdARC: // global
           I64[Sp + 8] = block_cdARY_info;
           _sdyuh::P64 = P64[R1 + 6];
           R1 = _sdyub::P64;
           P64[Sp + 24] = _sdyuh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udASe; else goto cdAS0;
       udASe: // global
           call _cdARY(R1) args: 0, res: 0, upd: 0;
       cdAS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdARJ() //  [R1]
         { info_tbl: [(cdARJ,
                       label: block_cdARJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARJ: // global
           if (R1 & 7 == 1) goto cdARR; else goto cdARV;
       cdARR: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdARV: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdARY() //  [R1]
         { info_tbl: [(cdARY,
                       label: block_cdARY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdARY: // global
           if (R1 & 7 == 1) goto cdAS6; else goto cdASa;
       cdAS6: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdASa: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.116111243 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_closure" {
     Data.Functor.Classes.$fOrd2Either_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.117373895 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Either_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdASr,
                       label: Data.Functor.Classes.$fOrd1Either_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdASr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdASs; else goto cdASt;
       cdASs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdASt: // global
           I64[Sp - 32] = block_cdASk_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAT2; else goto cdASl;
       udAT2: // global
           call _cdASk(R1) args: 0, res: 0, upd: 0;
       cdASl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdASk() //  [R1]
         { info_tbl: [(cdASk,
                       label: block_cdASk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdASk: // global
           _sdyuo::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdASo; else goto cdASp;
       cdASo: // global
           I64[Sp] = block_cdASw_info;
           _sdyuq::P64 = P64[R1 + 7];
           R1 = _sdyuo::P64;
           P64[Sp + 24] = _sdyuq::P64;
           if (R1 & 7 != 0) goto udAT0; else goto cdASy;
       udAT0: // global
           call _cdASw(R1) args: 0, res: 0, upd: 0;
       cdASy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdASp: // global
           I64[Sp + 8] = block_cdASL_info;
           _sdyuu::P64 = P64[R1 + 6];
           R1 = _sdyuo::P64;
           P64[Sp + 24] = _sdyuu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udAT1; else goto cdASN;
       udAT1: // global
           call _cdASL(R1) args: 0, res: 0, upd: 0;
       cdASN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdASw() //  [R1]
         { info_tbl: [(cdASw,
                       label: block_cdASw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdASw: // global
           if (R1 & 7 == 1) goto cdASE; else goto cdASI;
       cdASE: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
       cdASI: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdASL() //  [R1]
         { info_tbl: [(cdASL,
                       label: block_cdASL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdASL: // global
           if (R1 & 7 == 1) goto cdAST; else goto cdASX;
       cdAST: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdASX: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.119907397 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either1_closure" {
     Data.Functor.Classes.$fOrd1Either1_closure:
         const Data.Functor.Classes.$fOrd1Either1_info;
 },
 Data.Functor.Classes.$fOrd1Either1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdATe,
                       label: Data.Functor.Classes.$fOrd1Either1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdATe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdATf; else goto cdATg;
       cdATf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdATg: // global
           I64[Sp - 32] = block_cdAT7_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udATW; else goto cdAT8;
       udATW: // global
           call _cdAT7(R1) args: 0, res: 0, upd: 0;
       cdAT8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAT7() //  [R1]
         { info_tbl: [(cdAT7,
                       label: block_cdAT7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAT7: // global
           _sdyuB::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdATb; else goto cdATc;
       cdATb: // global
           I64[Sp] = block_cdATj_info;
           _sdyuD::P64 = P64[R1 + 7];
           R1 = _sdyuB::P64;
           P64[Sp + 24] = _sdyuD::P64;
           if (R1 & 7 != 0) goto udATU; else goto cdATl;
       udATU: // global
           call _cdATj(R1) args: 0, res: 0, upd: 0;
       cdATl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdATc: // global
           I64[Sp + 8] = block_cdATD_info;
           _sdyuI::P64 = P64[R1 + 6];
           R1 = _sdyuB::P64;
           P64[Sp + 24] = _sdyuI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udATV; else goto cdATF;
       udATV: // global
           call _cdATD(R1) args: 0, res: 0, upd: 0;
       cdATF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdATj() //  [R1]
         { info_tbl: [(cdATj,
                       label: block_cdATj_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdATj: // global
           if (R1 & 7 == 1) goto cdATs; else goto udATT;
       cdATs: // global
           _sdyuy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdATp_info;
           R2 = _sdyuy::P64;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       udATT: // global
           Sp = Sp + 32;
           call _cdATL() args: 0, res: 0, upd: 0;
     }
 },
 _cdATp() //  [R1]
         { info_tbl: [(cdATp,
                       label: block_cdATp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdATp: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sdyuF::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sdyuF::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdATD() //  [R1]
         { info_tbl: [(cdATD,
                       label: block_cdATD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdATD: // global
           if (R1 & 7 == 1) goto udATS; else goto cdATP;
       udATS: // global
           Sp = Sp + 24;
           call _cdATL() args: 0, res: 0, upd: 0;
       cdATP: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdATL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdATL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.122426997 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_closure" {
     Data.Functor.Classes.$fOrd1Either_closure:
         const Data.Functor.Classes.$fOrd1Either_info;
 },
 sat_sdyuO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdAU8,
                       label: sat_sdyuO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAU8: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyuN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdAUg,
                       label: sat_sdyuN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUg: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Either_entry() //  [R2]
         { info_tbl: [(cdAUk,
                       label: Data.Functor.Classes.$fOrd1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAUo; else goto cdAUn;
       cdAUo: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAUn: // global
           I64[Hp - 48] = sat_sdyuO_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyuN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.123888835 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Const_$cliftCompare2_entry() //  [R2,
                                                              R4, R5]
         { info_tbl: [(cdAUt,
                       label: Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUt: // global
           R3 = R5;
           _sdyuP::P64 = R2;
           R2 = R4;
           R1 = _sdyuP::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.12469556 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_closure" {
     Data.Functor.Classes.$fOrd2Const_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.125641784 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const1_closure" {
     Data.Functor.Classes.$fOrd1Const1_closure:
         const Data.Functor.Classes.$fOrd1Const1_info;
 },
 Data.Functor.Classes.$fOrd1Const1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAUC,
                       label: Data.Functor.Classes.$fOrd1Const1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAUD; else goto cdAUE;
       cdAUD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAUE: // global
           I64[Sp - 24] = block_cdAUA_info;
           R2 = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAUA() //  [R1]
         { info_tbl: [(cdAUA,
                       label: block_cdAUA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUA: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.128831568 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const_closure" {
     Data.Functor.Classes.$fOrd1Const_closure:
         const Data.Functor.Classes.$fOrd1Const_info;
 },
 sat_sdyv3_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdAUR,
                       label: sat_sdyv3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAUS; else goto cdAUT;
       cdAUS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAUT: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdyuZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdAUZ,
                       label: sat_sdyuZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAUZ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Const1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Const_entry() //  [R2]
         { info_tbl: [(cdAV3,
                       label: Data.Functor.Classes.$fOrd1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAV3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAV7; else goto cdAV6;
       cdAV7: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAV6: // global
           I64[Hp - 48] = sat_sdyv3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyuZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.130156319 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1(,)5_bytes" {
     Data.Functor.Classes.$fRead1(,)5_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.130968001 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)4_closure" {
     Data.Functor.Classes.$fRead1(,)4_closure:
         const Data.Functor.Classes.$fRead1(,)4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)4_entry() //  [R1]
         { info_tbl: [(cdAVe,
                       label: Data.Functor.Classes.$fRead1(,)4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAVe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAVf; else goto cdAVg;
       cdAVf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAVg: // global
           (_cdAVb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdAVb::I64 == 0) goto cdAVd; else goto cdAVc;
       cdAVd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdAVc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdAVb::I64;
           R2 = Data.Functor.Classes.$fRead1(,)5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.131900844 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)3_closure" {
     Data.Functor.Classes.$fRead1(,)3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Functor.Classes.$fRead1(,)4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.133975786 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadPrec2_info;
         const 0;
 },
 sat_sdyvf_entry() //  [R1, R2]
         { info_tbl: [(cdAVG,
                       label: sat_sdyvf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAVG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAVK; else goto cdAVJ;
       cdAVK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAVJ: // global
           _sdyva::P64 = P64[R1 + 7];
           _sdyvb::P64 = P64[R1 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sdyvb::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sdyva::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvg_entry() //  [R1, R2]
         { info_tbl: [(cdAVL,
                       label: sat_sdyvg_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAVL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAVP; else goto cdAVO;
       cdAVP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAVO: // global
           _sdyv5::P64 = P64[R1 + 7];
           _sdyv9::P64 = P64[R1 + 15];
           _sdyva::P64 = P64[R1 + 23];
           _sdyvb::P64 = P64[R1 + 31];
           I64[Hp - 16] = sat_sdyvf_info;
           P64[Hp - 8] = _sdyva::P64;
           P64[Hp] = _sdyvb::P64;
           R3 = Hp - 15;
           R2 = _sdyv9::P64;
           R1 = _sdyv5::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvj_entry() //  [R1, R2]
         { info_tbl: [(cdAVT,
                       label: sat_sdyvj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAVT: // global
           _sdyvb::P64 = R2;
           _sdyvj::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdAVU; else goto cdAVV;
       cdAVV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAVX; else goto cdAVW;
       cdAVX: // global
           HpAlloc = 40;
           goto cdAVU;
       cdAVU: // global
           R2 = _sdyvb::P64;
           R1 = _sdyvj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAVW: // global
           _sdyv5::P64 = P64[_sdyvj::P64 + 7];
           _sdyv9::P64 = P64[_sdyvj::P64 + 15];
           _sdyva::P64 = P64[_sdyvj::P64 + 23];
           I64[Hp - 32] = sat_sdyvg_info;
           P64[Hp - 24] = _sdyv5::P64;
           P64[Hp - 16] = _sdyv9::P64;
           P64[Hp - 8] = _sdyva::P64;
           P64[Hp] = _sdyvb::P64;
           I64[Sp - 8] = block_cdAVQ_info;
           R3 = Hp - 31;
           R2 = Data.Functor.Classes.$fRead1(,)3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAVQ() //  [R1]
         { info_tbl: [(cdAVQ,
                       label: block_cdAVQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAVQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAW0; else goto cdAVZ;
       cdAW0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAVZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 p_sdyv8_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAW1,
                       label: p_sdyv8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAW1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAW5; else goto cdAW4;
       cdAW5: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAW4: // global
           _sdyv4::P64 = P64[R1 + 6];
           _sdyv5::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sdyvj_info;
           P64[Hp - 16] = _sdyv5::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 23;
           R2 = R2;
           R1 = _sdyv4::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl3_sdyvk_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAWe,
                       label: lvl3_sdyvk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAWf; else goto cdAWg;
       cdAWf: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAWg: // global
           I64[Sp - 8] = block_cdAWb_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wparen'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAWb() //  [R1]
         { info_tbl: [(cdAWb,
                       label: block_cdAWb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAWj; else goto cdAWi;
       cdAWj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAWi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvt_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAWs,
                       label: sat_sdyvt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdAWt; else goto cdAWu;
       cdAWt: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAWu: // global
           I64[Sp - 8] = block_cdAWp_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wskipSpacesThenP_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdAWp() //  [R1]
         { info_tbl: [(cdAWp,
                       label: block_cdAWp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdAWx; else goto cdAWw;
       cdAWx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAWw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAWy,
                       label: Data.Functor.Classes.$w$cliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAWC; else goto cdAWB;
       cdAWC: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAWB: // global
           I64[Hp - 48] = p_sdyv8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = lvl3_sdyvk_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sdyvt_info;
           P64[Hp] = Hp - 22;
           _sdyv6::P64 = R4;
           R4 = R5;
           R3 = _sdyv6::P64;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.137864988 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)2_closure" {
     Data.Functor.Classes.$fRead1(,)2_closure:
         const Data.Functor.Classes.$fRead1(,)2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)2_entry() //  [R2, R4, R6]
         { info_tbl: [(cdAWH,
                       label: Data.Functor.Classes.$fRead1(,)2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWH: // global
           R5 = P64[Sp];
           _sdyvw::P64 = R4;
           R4 = R6;
           R3 = _sdyvw::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.139235799 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec6_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec6_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec6_info;
         const 0;
 },
 sat_sdyvE_entry() //  [R1, R2]
         { info_tbl: [(cdAWX,
                       label: sat_sdyvE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAWX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvD_entry() //  [R1, R2]
         { info_tbl: [(cdAX5,
                       label: sat_sdyvD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAX5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvF_entry() //  [R1]
         { info_tbl: [(cdAX8,
                       label: sat_sdyvF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAX8: // global
           _sdyvF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAX9; else goto cdAXa;
       cdAXa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdAXc; else goto cdAXb;
       cdAXc: // global
           HpAlloc = 32;
           goto cdAX9;
       cdAX9: // global
           R1 = _sdyvF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAXb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyvF::P64;
           _sdyvA::P64 = P64[_sdyvF::P64 + 16];
           _sdyvB::P64 = P64[_sdyvF::P64 + 24];
           _sdyvC::P64 = P64[_sdyvF::P64 + 32];
           I64[Hp - 24] = sat_sdyvE_info;
           P64[Hp - 16] = _sdyvB::P64;
           I64[Hp - 8] = sat_sdyvD_info;
           P64[Hp] = _sdyvA::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyvC::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec6_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAXd,
                       label: Data.Functor.Classes.$w$cliftReadsPrec6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAXd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAXh; else goto cdAXg;
       cdAXh: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAXg: // global
           I64[Hp - 32] = sat_sdyvF_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.140989196 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_entry() //  [R2,
                                                               R4, R6]
         { info_tbl: [(cdAXm,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAXm: // global
           _sdyvI::P64 = R4;
           R4 = R6;
           R3 = _sdyvI::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec6_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.142107677 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyvR_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAXy,
                       label: sat_sdyvR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAXy: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdAXB,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAXB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAXF; else goto cdAXE;
       cdAXF: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAXE: // global
           I64[Hp - 16] = sat_sdyvR_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.143223568 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)3_closure" {
     Data.Functor.Classes.$fShow1(,)3_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.143772198 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity5_closure" {
     Data.Functor.Classes.$fRead1Identity5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.144342901 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)2_closure" {
     Data.Functor.Classes.$fShow1(,)2_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.144924702 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)1_closure" {
     Data.Functor.Classes.$fShow1(,)1_closure:
         const GHC.Types.C#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.146500249 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec2_info;
 },
 f_sdyvW_entry() //  [R1]
         { info_tbl: [(cdAXO,
                       label: f_sdyvW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAXO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAXP; else goto cdAXQ;
       cdAXP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAXQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdyvX_entry() //  [R1]
         { info_tbl: [(cdAXV,
                       label: f1_sdyvX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAXV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAXW; else goto cdAXX;
       cdAXW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAXX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw0_entry() //  [R1]
         { info_tbl: [(cdAYc,
                       label: sat_sdyw0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYc: // global
           _sdyw0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAYd; else goto cdAYe;
       cdAYe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAYg; else goto cdAYf;
       cdAYg: // global
           HpAlloc = 24;
           goto cdAYd;
       cdAYd: // global
           R1 = _sdyw0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAYf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyw0::P64;
           _sdyvX::P64 = P64[_sdyw0::P64 + 16];
           _sdyvY::P64 = P64[_sdyw0::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdyvY::P64;
           R2 = Hp - 14;
           R1 = _sdyvX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw2_entry() //  [R1]
         { info_tbl: [(cdAYi,
                       label: sat_sdyw2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYi: // global
           _sdyw2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAYj; else goto cdAYk;
       cdAYk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAYm; else goto cdAYl;
       cdAYm: // global
           HpAlloc = 56;
           goto cdAYj;
       cdAYj: // global
           R1 = _sdyw2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAYl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyw2::P64;
           _sdyvW::P64 = P64[_sdyw2::P64 + 16];
           _sdyvX::P64 = P64[_sdyw2::P64 + 24];
           _sdyvY::P64 = P64[_sdyw2::P64 + 32];
           I64[Hp - 48] = sat_sdyw0_info;
           P64[Hp - 32] = _sdyvX::P64;
           P64[Hp - 24] = _sdyvY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyvW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw3_entry() //  [R1, R2]
         { info_tbl: [(cdAYo,
                       label: sat_sdyw3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAYs; else goto cdAYr;
       cdAYs: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdAYr: // global
           _sdyvW::P64 = P64[R1 + 7];
           _sdyvX::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyw2_info;
           P64[Hp - 40] = _sdyvW::P64;
           P64[Hp - 32] = _sdyvX::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdAYt,
                       label: Data.Functor.Classes.$w$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdAYx; else goto cdAYw;
       cdAYx: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAYw: // global
           I64[Hp - 80] = f_sdyvW_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = f1_sdyvX_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdyw3_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.149428816 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdAYF,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdAYG; else goto cdAYH;
       cdAYG: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdAYH: // global
           I64[Sp - 16] = block_cdAYC_info;
           R1 = P64[Sp];
           P64[Sp - 8] = R4;
           P64[Sp] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udAYL; else goto cdAYD;
       udAYL: // global
           call _cdAYC(R1) args: 0, res: 0, upd: 0;
       cdAYD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAYC() //  [R1]
         { info_tbl: [(cdAYC,
                       label: block_cdAYC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYC: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.150900358 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList2_closure" {
     Data.Functor.Classes.$dmliftShowList2_closure:
         const Data.Functor.Classes.$dmliftShowList2_info;
 },
 sat_sdywi_entry() //  [R1]
         { info_tbl: [(cdAYU,
                       label: sat_sdywi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdAYV; else goto cdAYW;
       cdAYV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAYW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 24];
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdAYX,
                       label: Data.Functor.Classes.$dmliftShowList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAYX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdAZ1; else goto cdAZ0;
       cdAZ1: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAZ0: // global
           I64[Hp - 48] = sat_sdywi_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.152975241 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList3_closure" {
     Data.Functor.Classes.$w$cliftShowList3_closure:
         const Data.Functor.Classes.$w$cliftShowList3_info;
 },
 sat_sdywt_entry() //  [R1]
         { info_tbl: [(cdAZp,
                       label: sat_sdywt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZp: // global
           _sdywt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAZq; else goto cdAZr;
       cdAZr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAZt; else goto cdAZs;
       cdAZt: // global
           HpAlloc = 24;
           goto cdAZq;
       cdAZq: // global
           R1 = _sdywt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAZs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywt::P64;
           _sdywk::P64 = P64[_sdywt::P64 + 16];
           _sdywo::P64 = P64[_sdywt::P64 + 24];
           _sdywr::P64 = P64[_sdywt::P64 + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdywo::P64;
           R4 = Hp - 14;
           R3 = _sdywr::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdywk::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywv_entry() //  [R1]
         { info_tbl: [(cdAZv,
                       label: sat_sdywv_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZv: // global
           _sdywv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdAZw; else goto cdAZx;
       cdAZx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdAZz; else goto cdAZy;
       cdAZz: // global
           HpAlloc = 64;
           goto cdAZw;
       cdAZw: // global
           R1 = _sdywv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdAZy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywv::P64;
           _sdywj::P64 = P64[_sdywv::P64 + 16];
           _sdywk::P64 = P64[_sdywv::P64 + 24];
           _sdywo::P64 = P64[_sdywv::P64 + 32];
           _sdywq::P64 = P64[_sdywv::P64 + 40];
           _sdywr::P64 = P64[_sdywv::P64 + 48];
           I64[Hp - 56] = sat_sdywt_info;
           P64[Hp - 40] = _sdywk::P64;
           P64[Hp - 32] = _sdywo::P64;
           P64[Hp - 24] = _sdywr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 56;
           R4 = Hp - 14;
           R3 = _sdywq::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdywj::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyww_entry() //  [R1, R2, R3]
         { info_tbl: [(cdAZA,
                       label: sat_sdyww_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdAZC; else goto cdAZD;
       cdAZC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAZD: // global
           I64[Sp - 32] = block_cdAZb_info;
           _sdywj::P64 = P64[R1 + 6];
           _sdywk::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdywj::P64;
           P64[Sp - 16] = _sdywk::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udAZH; else goto cdAZc;
       udAZH: // global
           call _cdAZb(R1) args: 0, res: 0, upd: 0;
       cdAZc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAZb() //  [R1]
         { info_tbl: [(cdAZb,
                       label: block_cdAZb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdAZG; else goto cdAZF;
       cdAZG: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAZF: // global
           _sdywq::P64 = P64[R1 + 7];
           _sdywr::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sdywv_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sdywq::P64;
           P64[Hp - 24] = _sdywr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdAZI,
                       label: Data.Functor.Classes.$w$cliftShowList3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdAZM; else goto cdAZL;
       cdAZM: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAZL: // global
           I64[Hp - 16] = sat_sdyww_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdywl::P64 = R4;
           R4 = R5;
           R3 = _sdywl::P64;
           R2 = Hp - 14;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.155597818 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info;
 },
 Data.Functor.Classes.$fShow2(,)_$cliftShowList2_entry() //  [R2,
                                                              R4, R6]
         { info_tbl: [(cdAZR,
                       label: Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZR: // global
           R5 = P64[Sp];
           _sdywz::P64 = R4;
           R4 = R6;
           R3 = _sdywz::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.156400848 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_closure" {
     Data.Functor.Classes.$fShow2(,)_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.15746403 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info;
 },
 sat_sdywL_entry() //  [R1]
         { info_tbl: [(cdB07,
                       label: sat_sdywL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB07: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cdB0a,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB0a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdB0b; else goto cdB0c;
       cdB0b: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB0c: // global
           I64[Sp - 24] = block_cdAZY_info;
           R1 = R6;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udB0g; else goto cdAZZ;
       udB0g: // global
           call _cdAZY(R1) args: 0, res: 0, upd: 0;
       cdAZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAZY() //  [R1]
         { info_tbl: [(cdAZY,
                       label: block_cdAZY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAZY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdB0f; else goto cdB0e;
       cdB0f: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB0e: // global
           _sdywJ::P64 = P64[R1 + 7];
           _sdywK::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdywL_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdywK::P64;
           R4 = _sdywJ::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.160150508 UTC

[section ""data" . $w$dmliftReadListPrec2_rdymu_closure" {
     $w$dmliftReadListPrec2_rdymu_closure:
         const $w$dmliftReadListPrec2_rdymu_info;
 },
 sat_sdywW_entry() //  [R1]
         { info_tbl: [(cdB0t,
                       label: sat_sdywW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB0t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB0u; else goto cdB0v;
       cdB0u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB0v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywX_entry() //  [R1, R2]
         { info_tbl: [(cdB0B,
                       label: sat_sdywX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB0B: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywV_entry() //  [R1, R2]
         { info_tbl: [(cdB0J,
                       label: sat_sdywV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB0J: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywT_entry() //  [R1]
         { info_tbl: [(cdB0Q,
                       label: sat_sdywT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB0Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB0R; else goto cdB0S;
       cdB0R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB0S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywU_entry() //  [R1, R2]
         { info_tbl: [(cdB0Y,
                       label: sat_sdywU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB0Y: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywS_entry() //  [R1, R2]
         { info_tbl: [(cdB16,
                       label: sat_sdywS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB16: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w5_sdywR_entry() //  [R1]
         { info_tbl: [(cdB19,
                       label: w5_sdywR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB19: // global
           _sdywR::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdB1a; else goto cdB1b;
       cdB1b: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdB1d; else goto cdB1c;
       cdB1d: // global
           HpAlloc = 112;
           goto cdB1a;
       cdB1a: // global
           R1 = _sdywR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB1c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywR::P64;
           _sdywM::P64 = P64[_sdywR::P64 + 16];
           _sdywN::P64 = P64[_sdywR::P64 + 24];
           _sdywO::P64 = P64[_sdywR::P64 + 32];
           _sdywP::P64 = P64[_sdywR::P64 + 40];
           _sdywQ::P64 = P64[_sdywR::P64 + 48];
           I64[Hp - 104] = sat_sdywW_info;
           P64[Hp - 88] = _sdywQ::P64;
           I64[Hp - 80] = sat_sdywX_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdywV_info;
           P64[Hp - 56] = _sdywP::P64;
           I64[Hp - 48] = sat_sdywT_info;
           P64[Hp - 32] = _sdywO::P64;
           I64[Hp - 24] = sat_sdywU_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdywS_info;
           P64[Hp] = _sdywN::P64;
           R2 = _sdywM::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadList2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyx1_entry() //  [R1, R2]
         { info_tbl: [(cdB1m,
                       label: sat_sdyx1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB1m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB1n; else goto cdB1o;
       cdB1n: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB1o: // global
           I64[Sp - 8] = block_cdB1j_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB1j() //  [R1]
         { info_tbl: [(cdB1j,
                       label: block_cdB1j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB1j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB1r; else goto cdB1q;
       cdB1r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB1q: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec2_rdymu_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdB1s,
                       label: $w$dmliftReadListPrec2_rdymu_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB1s: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdB1w; else goto cdB1v;
       cdB1w: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec2_rdymu_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB1v: // global
           I64[Hp - 64] = w5_sdywR_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyx1_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.163371524 UTC

[section ""data" . $dmliftReadListPrec1_rdymv_closure" {
     $dmliftReadListPrec1_rdymv_closure:
         const $dmliftReadListPrec1_rdymv_info;
 },
 $dmliftReadListPrec1_rdymv_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdB1B,
                       label: $dmliftReadListPrec1_rdymv_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB1B: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call $w$dmliftReadListPrec2_rdymu_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.164323259 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec2_closure" {
     Data.Functor.Classes.$dmliftReadListPrec2_closure:
         const Data.Functor.Classes.$dmliftReadListPrec2_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec2_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdB1I,
                       label: Data.Functor.Classes.$dmliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB1I: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec1_rdymv_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.166616112 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec2_closure" {
     Data.Functor.Classes.$dmliftReadPrec2_closure:
         const Data.Functor.Classes.$dmliftReadPrec2_info;
 },
 sat_sdyxi_entry() //  [R1]
         { info_tbl: [(cdB1X,
                       label: sat_sdyxi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB1X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB1Y; else goto cdB1Z;
       cdB1Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB1Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyxj_entry() //  [R1, R2]
         { info_tbl: [(cdB25,
                       label: sat_sdyxj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB25: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxh_entry() //  [R1, R2]
         { info_tbl: [(cdB2d,
                       label: sat_sdyxh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2d: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxf_entry() //  [R1]
         { info_tbl: [(cdB2k,
                       label: sat_sdyxf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB2l; else goto cdB2m;
       cdB2l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB2m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyxg_entry() //  [R1, R2]
         { info_tbl: [(cdB2s,
                       label: sat_sdyxg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2s: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxe_entry() //  [R1, R2]
         { info_tbl: [(cdB2A,
                       label: sat_sdyxe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2A: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyxd_entry() //  [R1]
         { info_tbl: [(cdB2D,
                       label: f1_sdyxd_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2D: // global
           _sdyxd::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdB2E; else goto cdB2F;
       cdB2F: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdB2H; else goto cdB2G;
       cdB2H: // global
           HpAlloc = 112;
           goto cdB2E;
       cdB2E: // global
           R1 = _sdyxd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB2G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxd::P64;
           _sdyx8::P64 = P64[_sdyxd::P64 + 16];
           _sdyx9::P64 = P64[_sdyxd::P64 + 24];
           _sdyxa::P64 = P64[_sdyxd::P64 + 32];
           _sdyxb::P64 = P64[_sdyxd::P64 + 40];
           _sdyxc::P64 = P64[_sdyxd::P64 + 48];
           I64[Hp - 104] = sat_sdyxi_info;
           P64[Hp - 88] = _sdyxc::P64;
           I64[Hp - 80] = sat_sdyxj_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdyxh_info;
           P64[Hp - 56] = _sdyxb::P64;
           I64[Hp - 48] = sat_sdyxf_info;
           P64[Hp - 32] = _sdyxa::P64;
           I64[Hp - 24] = sat_sdyxg_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyxe_info;
           P64[Hp] = _sdyx9::P64;
           R2 = _sdyx8::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyxp_entry() //  [R1, R2]
         { info_tbl: [(cdB2W,
                       label: sat_sdyxp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB2X; else goto cdB2Y;
       cdB2X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB2Y: // global
           I64[Sp - 8] = block_cdB2T_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB2T() //  [R1]
         { info_tbl: [(cdB2T,
                       label: block_cdB2T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB2T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB31; else goto cdB30;
       cdB31: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB30: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxq_entry() //  [R1, R2]
         { info_tbl: [(cdB32,
                       label: sat_sdyxq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB32: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdB36; else goto cdB35;
       cdB36: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB35: // global
           _sdyxd::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdyxd::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyxp_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdB37,
                       label: Data.Functor.Classes.$dmliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB37: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdB3b; else goto cdB3a;
       cdB3b: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB3a: // global
           I64[Hp - 64] = f1_sdyxd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyxq_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.171254386 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList2_closure" {
     Data.Functor.Classes.$dmliftReadList2_closure:
         const Data.Functor.Classes.$dmliftReadList2_info;
         const 0;
 },
 sat_sdyxH_entry() //  [R1, R2, R3]
         { info_tbl: [(cdB3w,
                       label: sat_sdyxH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB3w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB3x; else goto cdB3y;
       cdB3x: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB3y: // global
           I64[Sp - 8] = block_cdB3t_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB3t() //  [R1]
         { info_tbl: [(cdB3t,
                       label: block_cdB3t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB3t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB3B; else goto cdB3A;
       cdB3B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB3A: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxC_entry() //  [R1, R2]
         { info_tbl: [(cdB3H,
                       label: sat_sdyxC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB3H: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdB3S,
                       label: sat_sdyxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB3S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB3T; else goto cdB3U;
       cdB3T: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB3U: // global
           I64[Sp - 8] = block_cdB3P_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB3P() //  [R1]
         { info_tbl: [(cdB3P,
                       label: block_cdB3P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB3P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB3X; else goto cdB3W;
       cdB3X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB3W: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxw_entry() //  [R1, R2]
         { info_tbl: [(cdB43,
                       label: sat_sdyxw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB43: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxI_entry() //  [R1]
         { info_tbl: [(cdB46,
                       label: sat_sdyxI_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB46: // global
           _sdyxI::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdB47; else goto cdB48;
       cdB48: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdB4a; else goto cdB49;
       cdB4a: // global
           HpAlloc = 64;
           goto cdB47;
       cdB47: // global
           R1 = _sdyxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB49: // global
           _sdyxr::P64 = P64[_sdyxI::P64 + 16];
           _sdyxs::P64 = P64[_sdyxI::P64 + 24];
           _sdyxt::P64 = P64[_sdyxI::P64 + 32];
           _sdyxu::P64 = P64[_sdyxI::P64 + 40];
           _sdyxv::P64 = P64[_sdyxI::P64 + 48];
           I64[Hp - 56] = sat_sdyxH_info;
           P64[Hp - 48] = _sdyxv::P64;
           I64[Hp - 40] = sat_sdyxC_info;
           P64[Hp - 32] = _sdyxu::P64;
           I64[Hp - 24] = sat_sdyxB_info;
           P64[Hp - 16] = _sdyxt::P64;
           I64[Hp - 8] = sat_sdyxw_info;
           P64[Hp] = _sdyxs::P64;
           R2 = _sdyxr::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 54;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sdyxJ_entry() //  [R1]
         { info_tbl: [(cdB4b,
                       label: sat_sdyxJ_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4b: // global
           _sdyxJ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdB4c; else goto cdB4d;
       cdB4d: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB4f; else goto cdB4e;
       cdB4f: // global
           HpAlloc = 56;
           goto cdB4c;
       cdB4c: // global
           R1 = _sdyxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB4e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxJ::P64;
           _sdyxr::P64 = P64[_sdyxJ::P64 + 16];
           _sdyxs::P64 = P64[_sdyxJ::P64 + 24];
           _sdyxt::P64 = P64[_sdyxJ::P64 + 32];
           _sdyxu::P64 = P64[_sdyxJ::P64 + 40];
           _sdyxv::P64 = P64[_sdyxJ::P64 + 48];
           I64[Hp - 48] = sat_sdyxI_info;
           P64[Hp - 32] = _sdyxr::P64;
           P64[Hp - 24] = _sdyxs::P64;
           P64[Hp - 16] = _sdyxt::P64;
           P64[Hp - 8] = _sdyxu::P64;
           P64[Hp] = _sdyxv::P64;
           R2 = Hp - 48;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdB4g,
                       label: Data.Functor.Classes.$dmliftReadList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4g: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB4k; else goto cdB4j;
       cdB4k: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB4j: // global
           I64[Hp - 48] = sat_sdyxJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.176048169 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec2_closure" {
     Data.Functor.Classes.$dmliftReadsPrec2_closure:
         const Data.Functor.Classes.$dmliftReadsPrec2_info;
 },
 sat_sdyy1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdB4B,
                       label: sat_sdyy1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB4C; else goto cdB4D;
       cdB4C: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB4D: // global
           I64[Sp - 8] = block_cdB4y_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB4y() //  [R1]
         { info_tbl: [(cdB4y,
                       label: block_cdB4y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB4G; else goto cdB4F;
       cdB4G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB4F: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxW_entry() //  [R1, R2]
         { info_tbl: [(cdB4M,
                       label: sat_sdyxW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4M: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxV_entry() //  [R1, R2, R3]
         { info_tbl: [(cdB4X,
                       label: sat_sdyxV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB4Y; else goto cdB4Z;
       cdB4Y: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB4Z: // global
           I64[Sp - 8] = block_cdB4U_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB4U() //  [R1]
         { info_tbl: [(cdB4U,
                       label: block_cdB4U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB4U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB52; else goto cdB51;
       cdB52: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB51: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxQ_entry() //  [R1, R2]
         { info_tbl: [(cdB58,
                       label: sat_sdyxQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB58: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdyxP_entry() //  [R1]
         { info_tbl: [(cdB5b,
                       label: ds_sdyxP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB5b: // global
           _sdyxP::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdB5c; else goto cdB5d;
       cdB5d: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdB5f; else goto cdB5e;
       cdB5f: // global
           HpAlloc = 64;
           goto cdB5c;
       cdB5c: // global
           R1 = _sdyxP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB5e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxP::P64;
           _sdyxK::P64 = P64[_sdyxP::P64 + 16];
           _sdyxL::P64 = P64[_sdyxP::P64 + 24];
           _sdyxM::P64 = P64[_sdyxP::P64 + 32];
           _sdyxN::P64 = P64[_sdyxP::P64 + 40];
           _sdyxO::P64 = P64[_sdyxP::P64 + 48];
           I64[Hp - 56] = sat_sdyy1_info;
           P64[Hp - 48] = _sdyxO::P64;
           I64[Hp - 40] = sat_sdyxW_info;
           P64[Hp - 32] = _sdyxN::P64;
           I64[Hp - 24] = sat_sdyxV_info;
           P64[Hp - 16] = _sdyxM::P64;
           I64[Hp - 8] = sat_sdyxQ_info;
           P64[Hp] = _sdyxL::P64;
           R2 = _sdyxK::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Hp - 39;
           P64[Sp - 24] = Hp - 54;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyy3_entry() //  [R1]
         { info_tbl: [(cdB5p,
                       label: sat_sdyy3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB5p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB5q; else goto cdB5r;
       cdB5q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB5r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyy4_entry() //  [R1, R2]
         { info_tbl: [(cdB5s,
                       label: sat_sdyy4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB5s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdB5w; else goto cdB5v;
       cdB5w: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB5v: // global
           _sdyxP::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyy3_info;
           P64[Hp - 8] = _sdyxP::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdB5x,
                       label: Data.Functor.Classes.$dmliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB5x: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdB5B; else goto cdB5A;
       cdB5B: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB5A: // global
           I64[Hp - 64] = ds_sdyxP_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyy4_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.182110143 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList_closure" {
     Data.Functor.Classes.$dmliftShowList_closure:
         const Data.Functor.Classes.$dmliftShowList_info;
 },
 sat_sdyy8_entry() //  [R1]
         { info_tbl: [(cdB5K,
                       label: sat_sdyy8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB5K: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdB5L; else goto cdB5M;
       cdB5L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB5M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 48;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdB5N,
                       label: Data.Functor.Classes.$dmliftShowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB5N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdB5R; else goto cdB5Q;
       cdB5R: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB5Q: // global
           I64[Hp - 32] = sat_sdyy8_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.184341668 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList_closure" {
     Data.Functor.Classes.$w$cliftShowList_closure:
         const Data.Functor.Classes.$w$cliftShowList_info;
 },
 lvl3_sdyyd_entry() //  [R1]
         { info_tbl: [(cdB60,
                       label: lvl3_sdyyd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB60: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB61; else goto cdB62;
       cdB61: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB62: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyyi_entry() //  [R1, R2]
         { info_tbl: [(cdB6b,
                       label: sat_sdyyi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdB6c; else goto cdB6d;
       cdB6c: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB6d: // global
           I64[Sp - 24] = block_cdB68_info;
           _sdyya::P64 = P64[R1 + 7];
           _sdyyd::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyya::P64;
           P64[Sp - 8] = _sdyyd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udB6h; else goto cdB69;
       udB6h: // global
           call _cdB68(R1) args: 0, res: 0, upd: 0;
       cdB69: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdB68() //  [R1]
         { info_tbl: [(cdB68,
                       label: block_cdB68_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB68: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdB6i,
                       label: Data.Functor.Classes.$w$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6i: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdB6m; else goto cdB6l;
       cdB6m: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB6l: // global
           I64[Hp - 40] = lvl3_sdyyd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyyi_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdyyb::P64 = R4;
           R4 = R5;
           R3 = _sdyyb::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.186334477 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowList_entry() //  [R2, R3,
                                                             R5, R6]
         { info_tbl: [(cdB6r,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6r: // global
           _sdyym::P64 = R5;
           R5 = R6;
           R4 = _sdyym::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.187607969 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_closure" {
     Data.Functor.Classes.$fShow1(,)_closure:
         const Data.Functor.Classes.$fShow1(,)_info;
 },
 sat_sdyyu_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdB6D,
                       label: sat_sdyyu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6D: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyyp_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdB6L,
                       label: sat_sdyyp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6L: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_entry() //  [R2]
         { info_tbl: [(cdB6P,
                       label: Data.Functor.Classes.$fShow1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB6T; else goto cdB6S;
       cdB6T: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB6S: // global
           I64[Hp - 48] = sat_sdyyu_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyyp_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.189109266 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy1_closure" {
     Data.Functor.Classes.$fShow1Proxy1_closure:
         const Data.Functor.Classes.$fShow1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy1_entry() //  [R3]
         { info_tbl: [(cdB6Y,
                       label: Data.Functor.Classes.$fShow1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB6Y: // global
           R2 = R3;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.190040407 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowList_entry() //  [R4,
                                                               R5]
         { info_tbl: [(cdB75,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB75: // global
           _sdyyy::P64 = R4;
           R4 = R5;
           R3 = _sdyyy::P64;
           R2 = Data.Functor.Classes.$fShow1Proxy1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.190862707 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_closure" {
     Data.Functor.Classes.$fShow1Proxy_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure+5;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.191967367 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info;
 },
 sat_sdyyI_entry() //  [R1, R2]
         { info_tbl: [(cdB7k,
                       label: sat_sdyyI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB7k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdB7l; else goto cdB7m;
       cdB7l: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB7m: // global
           I64[Sp - 24] = block_cdB7h_info;
           _sdyyA::P64 = P64[R1 + 7];
           _sdyyB::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyyA::P64;
           P64[Sp - 8] = _sdyyB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udB7q; else goto cdB7i;
       udB7q: // global
           call _cdB7h(R1) args: 0, res: 0, upd: 0;
       cdB7i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdB7h() //  [R1]
         { info_tbl: [(cdB7h,
                       label: block_cdB7h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB7h: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdB7r,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB7r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdB7v; else goto cdB7u;
       cdB7v: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB7u: // global
           I64[Hp - 16] = sat_sdyyI_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyyC::P64 = R4;
           R4 = R5;
           R3 = _sdyyC::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.193556989 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.194336494 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowList_entry() //  [R3, R4,
                                                            R5]
         { info_tbl: [(cdB7A,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB7A: // global
           _B2::P64 = R4;
           R4 = R5;
           _sdyyK::P64 = R3;
           R3 = _B2::P64;
           R2 = _sdyyK::P64;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.195134305 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_closure" {
     Data.Functor.Classes.$fShow1[]_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure+3;
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.196699027 UTC

[section ""data" . $w$dmliftReadListPrec_rdymw_closure" {
     $w$dmliftReadListPrec_rdymw_closure:
         const $w$dmliftReadListPrec_rdymw_info;
 },
 sat_sdyyQ_entry() //  [R1]
         { info_tbl: [(cdB7P,
                       label: sat_sdyyQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB7P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB7Q; else goto cdB7R;
       cdB7Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB7R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyyR_entry() //  [R1, R2]
         { info_tbl: [(cdB7X,
                       label: sat_sdyyR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB7X: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyyP_entry() //  [R1, R2]
         { info_tbl: [(cdB85,
                       label: sat_sdyyP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB85: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w3_sdyyO_entry() //  [R1]
         { info_tbl: [(cdB88,
                       label: w3_sdyyO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB88: // global
           _sdyyO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdB89; else goto cdB8a;
       cdB8a: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB8c; else goto cdB8b;
       cdB8c: // global
           HpAlloc = 56;
           goto cdB89;
       cdB89: // global
           R1 = _sdyyO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB8b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyyO::P64;
           _sdyyL::P64 = P64[_sdyyO::P64 + 16];
           _sdyyM::P64 = P64[_sdyyO::P64 + 24];
           _sdyyN::P64 = P64[_sdyyO::P64 + 32];
           I64[Hp - 48] = sat_sdyyQ_info;
           P64[Hp - 32] = _sdyyN::P64;
           I64[Hp - 24] = sat_sdyyR_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyyP_info;
           P64[Hp] = _sdyyM::P64;
           R2 = _sdyyL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyyV_entry() //  [R1, R2]
         { info_tbl: [(cdB8l,
                       label: sat_sdyyV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB8l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB8m; else goto cdB8n;
       cdB8m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB8n: // global
           I64[Sp - 8] = block_cdB8i_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB8i() //  [R1]
         { info_tbl: [(cdB8i,
                       label: block_cdB8i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB8i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB8q; else goto cdB8p;
       cdB8q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB8p: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec_rdymw_entry() //  [R2, R3, R4]
         { info_tbl: [(cdB8r,
                       label: $w$dmliftReadListPrec_rdymw_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB8r: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB8v; else goto cdB8u;
       cdB8v: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec_rdymw_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB8u: // global
           I64[Hp - 48] = w3_sdyyO_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyyV_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.19939937 UTC

[section ""data" . $dmliftReadListPrec3_rdymx_closure" {
     $dmliftReadListPrec3_rdymx_closure:
         const $dmliftReadListPrec3_rdymx_info;
 },
 $dmliftReadListPrec3_rdymx_entry() //  [R2, R3, R4]
         { info_tbl: [(cdB8A,
                       label: $dmliftReadListPrec3_rdymx_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB8A: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $w$dmliftReadListPrec_rdymw_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.20032804 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec_closure" {
     Data.Functor.Classes.$dmliftReadListPrec_closure:
         const Data.Functor.Classes.$dmliftReadListPrec_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdB8H,
                       label: Data.Functor.Classes.$dmliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB8H: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec3_rdymx_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.202285146 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec_closure" {
     Data.Functor.Classes.$dmliftReadPrec_closure:
         const Data.Functor.Classes.$dmliftReadPrec_info;
 },
 sat_sdyz5_entry() //  [R1]
         { info_tbl: [(cdB8W,
                       label: sat_sdyz5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB8W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdB8X; else goto cdB8Y;
       cdB8X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB8Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyz6_entry() //  [R1, R2]
         { info_tbl: [(cdB94,
                       label: sat_sdyz6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB94: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyz4_entry() //  [R1, R2]
         { info_tbl: [(cdB9c,
                       label: sat_sdyz4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB9c: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyz3_entry() //  [R1]
         { info_tbl: [(cdB9f,
                       label: f1_sdyz3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB9f: // global
           _sdyz3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdB9g; else goto cdB9h;
       cdB9h: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB9j; else goto cdB9i;
       cdB9j: // global
           HpAlloc = 56;
           goto cdB9g;
       cdB9g: // global
           R1 = _sdyz3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdB9i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyz3::P64;
           _sdyz0::P64 = P64[_sdyz3::P64 + 16];
           _sdyz1::P64 = P64[_sdyz3::P64 + 24];
           _sdyz2::P64 = P64[_sdyz3::P64 + 32];
           I64[Hp - 48] = sat_sdyz5_info;
           P64[Hp - 32] = _sdyz2::P64;
           I64[Hp - 24] = sat_sdyz6_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyz4_info;
           P64[Hp] = _sdyz1::P64;
           R2 = _sdyz0::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyzc_entry() //  [R1, R2]
         { info_tbl: [(cdB9y,
                       label: sat_sdyzc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdB9z; else goto cdB9A;
       cdB9z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB9A: // global
           I64[Sp - 8] = block_cdB9v_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdB9v() //  [R1]
         { info_tbl: [(cdB9v,
                       label: block_cdB9v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB9v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdB9D; else goto cdB9C;
       cdB9D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdB9C: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzd_entry() //  [R1, R2]
         { info_tbl: [(cdB9E,
                       label: sat_sdyzd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB9E: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdB9I; else goto cdB9H;
       cdB9I: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdB9H: // global
           _sdyz3::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdyz3::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyzc_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdB9J,
                       label: Data.Functor.Classes.$dmliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdB9J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdB9N; else goto cdB9M;
       cdB9N: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdB9M: // global
           I64[Hp - 48] = f1_sdyz3_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyzd_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.206089981 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList_closure" {
     Data.Functor.Classes.$dmliftReadList_closure:
         const Data.Functor.Classes.$dmliftReadList_info;
         const 0;
 },
 sat_sdyzm_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBa8,
                       label: sat_sdyzm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBa8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBa9; else goto cdBaa;
       cdBa9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBaa: // global
           I64[Sp - 8] = block_cdBa5_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBa5() //  [R1]
         { info_tbl: [(cdBa5,
                       label: block_cdBa5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBa5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBad; else goto cdBac;
       cdBad: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBac: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzh_entry() //  [R1, R2]
         { info_tbl: [(cdBaj,
                       label: sat_sdyzh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBaj: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzn_entry() //  [R1]
         { info_tbl: [(cdBam,
                       label: sat_sdyzn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBam: // global
           _sdyzn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBan; else goto cdBao;
       cdBao: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBaq; else goto cdBap;
       cdBaq: // global
           HpAlloc = 32;
           goto cdBan;
       cdBan: // global
           R1 = _sdyzn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBap: // global
           _sdyze::P64 = P64[_sdyzn::P64 + 16];
           _sdyzf::P64 = P64[_sdyzn::P64 + 24];
           _sdyzg::P64 = P64[_sdyzn::P64 + 32];
           I64[Hp - 24] = sat_sdyzm_info;
           P64[Hp - 16] = _sdyzg::P64;
           I64[Hp - 8] = sat_sdyzh_info;
           P64[Hp] = _sdyzf::P64;
           R2 = _sdyze::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdyzo_entry() //  [R1]
         { info_tbl: [(cdBar,
                       label: sat_sdyzo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBar: // global
           _sdyzo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBas; else goto cdBat;
       cdBat: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBav; else goto cdBau;
       cdBav: // global
           HpAlloc = 40;
           goto cdBas;
       cdBas: // global
           R1 = _sdyzo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBau: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzo::P64;
           _sdyze::P64 = P64[_sdyzo::P64 + 16];
           _sdyzf::P64 = P64[_sdyzo::P64 + 24];
           _sdyzg::P64 = P64[_sdyzo::P64 + 32];
           I64[Hp - 32] = sat_sdyzn_info;
           P64[Hp - 16] = _sdyze::P64;
           P64[Hp - 8] = _sdyzf::P64;
           P64[Hp] = _sdyzg::P64;
           R2 = Hp - 32;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBaw,
                       label: Data.Functor.Classes.$dmliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBaw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBaA; else goto cdBaz;
       cdBaA: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBaz: // global
           I64[Hp - 32] = sat_sdyzo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.209740886 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info;
         const 0;
 },
 f_sdyzr_entry() //  [R1, R2]
         { info_tbl: [(cdBaK,
                       label: f_sdyzr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBaK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyzs_entry() //  [R1]
         { info_tbl: [(cdBaR,
                       label: f1_sdyzs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBaR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBaS; else goto cdBaT;
       cdBaS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBaT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdyzt_entry() //  [R1, R2]
         { info_tbl: [(cdBaZ,
                       label: f2_sdyzt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBaZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzz_entry() //  [R1, R2]
         { info_tbl: [(cdBbf,
                       label: sat_sdyzz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBbg; else goto cdBbh;
       cdBbg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBbh: // global
           I64[Sp - 32] = block_cdBbc_info;
           _sdyzr::P64 = P64[R1 + 7];
           _sdyzt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdyzr::P64;
           P64[Sp - 16] = _sdyzt::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udBbl; else goto cdBbd;
       udBbl: // global
           call _cdBbc(R1) args: 0, res: 0, upd: 0;
       cdBbd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBbc() //  [R1]
         { info_tbl: [(cdBbc,
                       label: block_cdBbc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbc: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBbp,
                       label: sat_sdyzC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbp: // global
           _sdyzv::P64 = R3;
           _sdyzu::P64 = R2;
           _sdyzC::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdBbq; else goto cdBbr;
       cdBbr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBbt; else goto cdBbs;
       cdBbt: // global
           HpAlloc = 32;
           goto cdBbq;
       cdBbq: // global
           R3 = _sdyzv::P64;
           R2 = _sdyzu::P64;
           R1 = _sdyzC::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBbs: // global
           _sdyzr::P64 = P64[_sdyzC::P64 + 6];
           _sdyzt::P64 = P64[_sdyzC::P64 + 14];
           I64[Hp - 24] = sat_sdyzz_info;
           P64[Hp - 16] = _sdyzr::P64;
           P64[Hp - 8] = _sdyzt::P64;
           P64[Hp] = _sdyzu::P64;
           I64[Sp - 8] = block_cdBbm_info;
           R3 = _sdyzv::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBbm() //  [R1]
         { info_tbl: [(cdBbm,
                       label: block_cdBbm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBbw; else goto cdBbv;
       cdBbw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBbv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdBbx,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdBbB; else goto cdBbA;
       cdBbB: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBbA: // global
           I64[Hp - 72] = f_sdyzr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = f1_sdyzs_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = f2_sdyzt_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdyzC_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.214731522 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info;
         const 0;
 },
 sat_sdyzK_entry() //  [R1]
         { info_tbl: [(cdBbX,
                       label: sat_sdyzK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbX: // global
           _sdyzK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBbY; else goto cdBbZ;
       cdBbZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBc1; else goto cdBc0;
       cdBc1: // global
           HpAlloc = 32;
           goto cdBbY;
       cdBbY: // global
           R1 = _sdyzK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBc0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzK::P64;
           _sdyzD::P64 = P64[_sdyzK::P64 + 16];
           _sdyzG::P64 = P64[_sdyzK::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdyzD::P64;
           P64[Hp] = _sdyzG::P64;
           I64[Sp - 24] = block_cdBbU_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdBbU() //  [R1]
         { info_tbl: [(cdBbU,
                       label: block_cdBbU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBbU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBc4; else goto cdBc3;
       cdBc4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdBc3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f_sdyzF_entry() //  [R1, R2]
         { info_tbl: [(cdBc5,
                       label: f_sdyzF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBc5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBc9; else goto cdBc8;
       cdBc9: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBc8: // global
           _sdyzD::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyzK_info;
           P64[Hp - 8] = _sdyzD::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyzL_entry() //  [R1]
         { info_tbl: [(cdBch,
                       label: f1_sdyzL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBch: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBci; else goto cdBcj;
       cdBci: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBcj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdBce_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdBce() //  [R1]
         { info_tbl: [(cdBce,
                       label: block_cdBce_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBce: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBcm; else goto cdBcl;
       cdBcm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdBcl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdyzO_entry() //  [R1, R2]
         { info_tbl: [(cdBcs,
                       label: f2_sdyzO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBcs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzU_entry() //  [R1, R2]
         { info_tbl: [(cdBcI,
                       label: sat_sdyzU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBcI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBcJ; else goto cdBcK;
       cdBcJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBcK: // global
           I64[Sp - 32] = block_cdBcF_info;
           _sdyzF::P64 = P64[R1 + 7];
           _sdyzO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdyzF::P64;
           P64[Sp - 16] = _sdyzO::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udBcO; else goto cdBcG;
       udBcO: // global
           call _cdBcF(R1) args: 0, res: 0, upd: 0;
       cdBcG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBcF() //  [R1]
         { info_tbl: [(cdBcF,
                       label: block_cdBcF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBcF: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBcS,
                       label: sat_sdyzX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBcS: // global
           _sdyzQ::P64 = R3;
           _sdyzP::P64 = R2;
           _sdyzX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdBcT; else goto cdBcU;
       cdBcU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBcW; else goto cdBcV;
       cdBcW: // global
           HpAlloc = 32;
           goto cdBcT;
       cdBcT: // global
           R3 = _sdyzQ::P64;
           R2 = _sdyzP::P64;
           R1 = _sdyzX::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBcV: // global
           _sdyzF::P64 = P64[_sdyzX::P64 + 6];
           _sdyzO::P64 = P64[_sdyzX::P64 + 14];
           I64[Hp - 24] = sat_sdyzU_info;
           P64[Hp - 16] = _sdyzF::P64;
           P64[Hp - 8] = _sdyzO::P64;
           P64[Hp] = _sdyzP::P64;
           I64[Sp - 8] = block_cdBcP_info;
           R3 = _sdyzQ::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBcP() //  [R1]
         { info_tbl: [(cdBcP,
                       label: block_cdBcP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBcP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBcZ; else goto cdBcY;
       cdBcZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBcY: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzY_entry() //  [R1]
         { info_tbl: [(cdBd0,
                       label: sat_sdyzY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBd0: // global
           _sdyzY::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBd1; else goto cdBd2;
       cdBd2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdBd4; else goto cdBd3;
       cdBd4: // global
           HpAlloc = 80;
           goto cdBd1;
       cdBd1: // global
           R1 = _sdyzY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBd3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzY::P64;
           _sdyzD::P64 = P64[_sdyzY::P64 + 16];
           _sdyzE::P64 = P64[_sdyzY::P64 + 24];
           I64[Hp - 72] = f_sdyzF_info;
           P64[Hp - 64] = _sdyzD::P64;
           I64[Hp - 56] = f1_sdyzL_info;
           P64[Hp - 40] = _sdyzE::P64;
           I64[Hp - 32] = f2_sdyzO_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdyzX_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R2 = Hp - 14;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdBd5,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBd5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBd9; else goto cdBd8;
       cdBd9: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBd8: // global
           I64[Hp - 24] = sat_sdyzY_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.220050223 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyA3_entry() //  [R1]
         { info_tbl: [(cdBdm,
                       label: sat_sdyA3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBdn; else goto cdBdo;
       cdBdn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBdo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyA4_entry() //  [R1, R2]
         { info_tbl: [(cdBdu,
                       label: sat_sdyA4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyA2_entry() //  [R1, R2]
         { info_tbl: [(cdBdC,
                       label: sat_sdyA2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w2_sdyA1_entry() //  [R1]
         { info_tbl: [(cdBdF,
                       label: w2_sdyA1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdF: // global
           _sdyA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBdG; else goto cdBdH;
       cdBdH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBdJ; else goto cdBdI;
       cdBdJ: // global
           HpAlloc = 56;
           goto cdBdG;
       cdBdG: // global
           R1 = _sdyA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyA1::P64;
           _sdyzZ::P64 = P64[_sdyA1::P64 + 16];
           _sdyA0::P64 = P64[_sdyA1::P64 + 24];
           I64[Hp - 48] = sat_sdyA3_info;
           P64[Hp - 32] = _sdyA0::P64;
           I64[Hp - 24] = sat_sdyA4_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyA2_info;
           P64[Hp] = _sdyzZ::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyA8_entry() //  [R1, R2]
         { info_tbl: [(cdBdS,
                       label: sat_sdyA8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBdT; else goto cdBdU;
       cdBdT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBdU: // global
           I64[Sp - 8] = block_cdBdP_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBdP() //  [R1]
         { info_tbl: [(cdBdP,
                       label: block_cdBdP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBdX; else goto cdBdW;
       cdBdX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBdW: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec2_entry() //  [R2, R3]
         { info_tbl: [(cdBdY,
                       label: Data.Functor.Classes.$w$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBdY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBe2; else goto cdBe1;
       cdBe2: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBe1: // global
           I64[Hp - 40] = w2_sdyA1_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdyA8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.222665871 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty1_closure" {
     Data.Functor.Classes.$fRead1NonEmpty1_closure:
         const Data.Functor.Classes.$fRead1NonEmpty1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(cdBe7,
                       label: Data.Functor.Classes.$fRead1NonEmpty1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBe7: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec2_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.223492435 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure+4;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.225209307 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec_closure" {
     Data.Functor.Classes.$dmliftReadsPrec_closure:
         const Data.Functor.Classes.$dmliftReadsPrec_info;
 },
 sat_sdyAl_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBeq,
                       label: sat_sdyAl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBeq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBer; else goto cdBes;
       cdBer: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBes: // global
           I64[Sp - 8] = block_cdBen_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBen() //  [R1]
         { info_tbl: [(cdBen,
                       label: block_cdBen_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBen: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBev; else goto cdBeu;
       cdBev: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBeu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyAg_entry() //  [R1, R2]
         { info_tbl: [(cdBeB,
                       label: sat_sdyAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBeB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdyAf_entry() //  [R1]
         { info_tbl: [(cdBeE,
                       label: ds_sdyAf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBeE: // global
           _sdyAf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBeF; else goto cdBeG;
       cdBeG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBeI; else goto cdBeH;
       cdBeI: // global
           HpAlloc = 32;
           goto cdBeF;
       cdBeF: // global
           R1 = _sdyAf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBeH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyAf::P64;
           _sdyAc::P64 = P64[_sdyAf::P64 + 16];
           _sdyAd::P64 = P64[_sdyAf::P64 + 24];
           _sdyAe::P64 = P64[_sdyAf::P64 + 32];
           I64[Hp - 24] = sat_sdyAl_info;
           P64[Hp - 16] = _sdyAe::P64;
           I64[Hp - 8] = sat_sdyAg_info;
           P64[Hp] = _sdyAd::P64;
           R2 = _sdyAc::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyAn_entry() //  [R1]
         { info_tbl: [(cdBeS,
                       label: sat_sdyAn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBeS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBeT; else goto cdBeU;
       cdBeT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBeU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAo_entry() //  [R1, R2]
         { info_tbl: [(cdBeV,
                       label: sat_sdyAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBeV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBeZ; else goto cdBeY;
       cdBeZ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBeY: // global
           _sdyAf::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyAn_info;
           P64[Hp - 8] = _sdyAf::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBf0,
                       label: Data.Functor.Classes.$dmliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBf0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBf4; else goto cdBf3;
       cdBf4: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBf3: // global
           I64[Hp - 48] = ds_sdyAf_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyAo_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.228659952 UTC

[section ""data" . Data.Functor.Classes.eq1_closure" {
     Data.Functor.Classes.eq1_closure:
         const Data.Functor.Classes.eq1_info;
 },
 sat_sdyAr_entry() //  [R1]
         { info_tbl: [(cdBfd,
                       label: sat_sdyAr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBfd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBfe; else goto cdBff;
       cdBfe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBff: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq1_entry() //  [R2, R3]
         { info_tbl: [(cdBfg,
                       label: Data.Functor.Classes.eq1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBfg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBfk; else goto cdBfj;
       cdBfk: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBfj: // global
           I64[Hp - 16] = sat_sdyAr_info;
           P64[Hp] = R3;
           _sdyAp::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdyAp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.230780548 UTC

[section ""data" . Data.Functor.Classes.compare1_closure" {
     Data.Functor.Classes.compare1_closure:
         const Data.Functor.Classes.compare1_info;
 },
 sat_sdyAu_entry() //  [R1]
         { info_tbl: [(cdBft,
                       label: sat_sdyAu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBft: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBfu; else goto cdBfv;
       cdBfu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBfv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare1_entry() //  [R2, R3]
         { info_tbl: [(cdBfw,
                       label: Data.Functor.Classes.compare1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBfw: // global
           _sdyAt::P64 = R3;
           _sdyAs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBfx; else goto cdBfy;
       cdBfy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBfA; else goto cdBfz;
       cdBfA: // global
           HpAlloc = 24;
           goto cdBfx;
       cdBfx: // global
           R3 = _sdyAt::P64;
           R2 = _sdyAs::P64;
           R1 = Data.Functor.Classes.compare1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBfz: // global
           I64[Hp - 16] = sat_sdyAu_info;
           P64[Hp] = _sdyAt::P64;
           R2 = _sdyAs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.232409058 UTC

[section ""data" . Data.Functor.Classes.readsPrec1_closure" {
     Data.Functor.Classes.readsPrec1_closure:
         const Data.Functor.Classes.readsPrec1_info;
 },
 sat_sdyAy_entry() //  [R1]
         { info_tbl: [(cdBfJ,
                       label: sat_sdyAy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBfJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBfK; else goto cdBfL;
       cdBfK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBfL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAx_entry() //  [R1]
         { info_tbl: [(cdBfQ,
                       label: sat_sdyAx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBfQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBfR; else goto cdBfS;
       cdBfR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBfS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdBfT,
                       label: Data.Functor.Classes.readsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBfT: // global
           _sdyAw::P64 = R3;
           _sdyAv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBfU; else goto cdBfV;
       cdBfV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBfX; else goto cdBfW;
       cdBfX: // global
           HpAlloc = 48;
           goto cdBfU;
       cdBfU: // global
           R3 = _sdyAw::P64;
           R2 = _sdyAv::P64;
           R1 = Data.Functor.Classes.readsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBfW: // global
           I64[Hp - 40] = sat_sdyAy_info;
           P64[Hp - 24] = _sdyAw::P64;
           I64[Hp - 16] = sat_sdyAx_info;
           P64[Hp] = _sdyAw::P64;
           R2 = _sdyAv::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.235272666 UTC

[section ""data" . Data.Functor.Classes.readsUnary1_closure" {
     Data.Functor.Classes.readsUnary1_closure:
         const Data.Functor.Classes.readsUnary1_info;
 },
 go_sdyAG_entry() //  [R1, R2]
         { info_tbl: [(cdBgj,
                       label: go_sdyAG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBgj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBgk; else goto cdBgl;
       cdBgk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBgl: // global
           I64[Sp - 24] = block_cdBgc_info;
           _sdyAG::P64 = R1;
           _sdyAC::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyAC::P64;
           P64[Sp - 8] = _sdyAG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBgF; else goto cdBgd;
       udBgF: // global
           call _cdBgc(R1) args: 0, res: 0, upd: 0;
       cdBgd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBgc() //  [R1]
         { info_tbl: [(cdBgc,
                       label: block_cdBgc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBgc: // global
           if (R1 & 7 == 1) goto cdBgg; else goto cdBgh;
       cdBgg: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBgh: // global
           I64[Sp - 8] = block_cdBgr_info;
           _sdyAK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyAK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udBgE; else goto cdBgs;
       udBgE: // global
           call _cdBgr(R1) args: 0, res: 0, upd: 0;
       cdBgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBgr() //  [R1]
         { info_tbl: [(cdBgr,
                       label: block_cdBgr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBgr: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdBgD; else goto cdBgC;
       cdBgD: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBgC: // global
           _sdyAM::P64 = P64[R1 + 7];
           _sdyAN::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyAM::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyAN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyAS_entry() //  [R1]
         { info_tbl: [(cdBgK,
                       label: sat_sdyAS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBgK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBgL; else goto cdBgM;
       cdBgL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAR_entry() //  [R1]
         { info_tbl: [(cdBgR,
                       label: sat_sdyAR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBgR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBgS; else goto cdBgT;
       cdBgS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBgY,
                       label: Data.Functor.Classes.readsUnary1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBgY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdBgZ; else goto cdBh0;
       cdBgZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBh0: // global
           I64[Sp - 32] = block_cdBg2_info;
           _sdyAA::P64 = R3;
           R3 = R4;
           _sdyAz::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdyAz::P64;
           P64[Sp - 16] = _sdyAA::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBg2() //  [R1]
         { info_tbl: [(cdBg2,
                       label: block_cdBg2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBg2: // global
           if (R1 & 7 == 1) goto cdBgV; else goto cdBgW;
       cdBgV: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBgW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBh6; else goto cdBh5;
       cdBh6: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBh5: // global
           I64[Hp - 56] = go_sdyAG_info;
           P64[Hp - 48] = P64[Sp + 24];
           I64[Hp - 40] = sat_sdyAS_info;
           _sdyAA::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sdyAA::P64;
           I64[Hp - 16] = sat_sdyAR_info;
           P64[Hp] = _sdyAA::P64;
           I64[Sp + 24] = block_cdBh3_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           P64[Sp + 8] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 55;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdBh3() //  [R1]
         { info_tbl: [(cdBh3,
                       label: block_cdBh3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBh3: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyAG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.242271727 UTC

[section ""data" . Data.Functor.Classes.readsBinary1_closure" {
     Data.Functor.Classes.readsBinary1_closure:
         const Data.Functor.Classes.readsBinary1_info;
 },
 Data.Functor.Classes.readsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhc: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.readsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 lvl3_sdyB2_entry() //  [R1]
         { info_tbl: [(cdBhp,
                       label: lvl3_sdyB2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBhq; else goto cdBhr;
       cdBhq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBhr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl4_sdyB3_entry() //  [R1]
         { info_tbl: [(cdBhw,
                       label: lvl4_sdyB3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBhx; else goto cdBhy;
       cdBhx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBhy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_sdyBd_entry() //  [R1, R2]
         { info_tbl: [(cdBi2,
                       label: go1_sdyBd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBi2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBi3; else goto cdBi4;
       cdBi3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBi4: // global
           I64[Sp - 40] = block_cdBhV_info;
           _sdyBd::P64 = R1;
           _sdyAY::P64 = P64[R1 + 7];
           _sdyBa::P64 = P64[R1 + 15];
           _sdyBc::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdyAY::P64;
           P64[Sp - 24] = _sdyBa::P64;
           P64[Sp - 16] = _sdyBc::P64;
           P64[Sp - 8] = _sdyBd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udBio; else goto cdBhW;
       udBio: // global
           call _cdBhV(R1) args: 0, res: 0, upd: 0;
       cdBhW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBhV() //  [R1]
         { info_tbl: [(cdBhV,
                       label: block_cdBhV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhV: // global
           if (R1 & 7 == 1) goto cdBhZ; else goto cdBi0;
       cdBhZ: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdBi0: // global
           I64[Sp] = block_cdBia_info;
           _sdyBh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdyBh::P64;
           if (R1 & 7 != 0) goto udBin; else goto cdBib;
       udBin: // global
           call _cdBia(R1) args: 0, res: 0, upd: 0;
       cdBib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBia() //  [R1]
         { info_tbl: [(cdBia,
                       label: block_cdBia_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBia: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdBim; else goto cdBil;
       cdBim: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBil: // global
           _sdyBj::P64 = P64[R1 + 7];
           _sdyBk::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyBj::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdyBk::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyB4_entry() //  [R1, R2]
         { info_tbl: [(cdBit,
                       label: go_sdyB4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBit: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdBiu; else goto cdBiv;
       cdBiu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBiv: // global
           I64[Sp - 48] = block_cdBhE_info;
           _sdyB4::P64 = R1;
           _sdyAV::P64 = P64[R1 + 7];
           _sdyAY::P64 = P64[R1 + 15];
           _sdyB2::P64 = P64[R1 + 23];
           _sdyB3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _sdyAV::P64;
           P64[Sp - 32] = _sdyAY::P64;
           P64[Sp - 24] = _sdyB2::P64;
           P64[Sp - 16] = _sdyB3::P64;
           P64[Sp - 8] = _sdyB4::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto udBiI; else goto cdBhF;
       udBiI: // global
           call _cdBhE(R1) args: 0, res: 0, upd: 0;
       cdBhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBhE() //  [R1]
         { info_tbl: [(cdBhE,
                       label: block_cdBhE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhE: // global
           if (R1 & 7 == 1) goto cdBiq; else goto cdBir;
       cdBiq: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBir: // global
           I64[Sp - 8] = block_cdBhK_info;
           _sdyB8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyB8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udBiH; else goto cdBhL;
       udBiH: // global
           call _cdBhK(R1) args: 0, res: 0, upd: 0;
       cdBhL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBhK() //  [R1]
         { info_tbl: [(cdBhK,
                       label: block_cdBhK_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBiC; else goto cdBiB;
       cdBiC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBiB: // global
           _sdyBa::P64 = P64[R1 + 7];
           _sdyBb::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyBd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdyBa::P64;
           P64[Hp] = Hp - 56;
           _sdyB3::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdBiy_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = P64[Sp + 32];
           P64[Sp + 16] = _sdyB3::P64;
           P64[Sp + 24] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 32] = _sdyBb::P64;
           P64[Sp + 48] = Hp - 23;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdBiy() //  [R1]
         { info_tbl: [(cdBiy,
                       label: block_cdBiy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBiy: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyBd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBiN,
                       label: Data.Functor.Classes.readsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBiN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBiO; else goto cdBiP;
       cdBiO: // global
           R1 = Data.Functor.Classes.readsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdBiP: // global
           I64[Sp - 32] = block_cdBhg_info;
           _sdyAV::P64 = R3;
           R3 = R5;
           _sdyAU::P64 = R2;
           R2 = P64[Sp];
           P64[Sp - 24] = _sdyAV::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = _sdyAU::P64;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBhg() //  [R1]
         { info_tbl: [(cdBhg,
                       label: block_cdBhg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBhg: // global
           if (R1 & 7 == 1) goto cdBiK; else goto cdBiL;
       cdBiK: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBiL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdBiV; else goto cdBiU;
       cdBiV: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBiU: // global
           I64[Hp - 80] = lvl3_sdyB2_info;
           _sdyAW::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sdyAW::P64;
           I64[Hp - 56] = lvl4_sdyB3_info;
           P64[Hp - 40] = _sdyAW::P64;
           I64[Hp - 32] = go_sdyB4_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           _cdBhl::P64 = Hp - 80;
           P64[Hp - 8] = _cdBhl::P64;
           _cdBhs::P64 = Hp - 56;
           P64[Hp] = _cdBhs::P64;
           _sdyAU::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cdBiS_info;
           R2 = _sdyAU::P64;
           I64[Sp - 8] = stg_ap_pppp_info;
           P64[Sp] = _cdBhl::P64;
           P64[Sp + 8] = _cdBhs::P64;
           P64[Sp + 16] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 24] = P64[Sp + 40];
           P64[Sp + 40] = Hp - 31;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdBiS() //  [R1]
         { info_tbl: [(cdBiS,
                       label: block_cdBiS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBiS: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyB4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.247361659 UTC

[section ""data" . Data.Functor.Classes.readPrec1_closure" {
     Data.Functor.Classes.readPrec1_closure:
         const Data.Functor.Classes.readPrec1_info;
 },
 sat_sdyBt_entry() //  [R1]
         { info_tbl: [(cdBj8,
                       label: sat_sdyBt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBj8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBj9; else goto cdBja;
       cdBj9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBja: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyBs_entry() //  [R1]
         { info_tbl: [(cdBjf,
                       label: sat_sdyBs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBjf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBjg; else goto cdBjh;
       cdBjg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBjh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdBji,
                       label: Data.Functor.Classes.readPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBji: // global
           _sdyBr::P64 = R3;
           _sdyBq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBjj; else goto cdBjk;
       cdBjk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBjm; else goto cdBjl;
       cdBjm: // global
           HpAlloc = 48;
           goto cdBjj;
       cdBjj: // global
           R3 = _sdyBr::P64;
           R2 = _sdyBq::P64;
           R1 = Data.Functor.Classes.readPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBjl: // global
           I64[Hp - 40] = sat_sdyBt_info;
           P64[Hp - 24] = _sdyBr::P64;
           I64[Hp - 16] = sat_sdyBs_info;
           P64[Hp] = _sdyBr::P64;
           R2 = _sdyBq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.249538703 UTC

[section ""data" . Data.Functor.Classes.liftReadListDefault_closure" {
     Data.Functor.Classes.liftReadListDefault_closure:
         const Data.Functor.Classes.liftReadListDefault_info;
 },
 sat_sdyBC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBjD,
                       label: sat_sdyBC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBjD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBjE; else goto cdBjF;
       cdBjE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBjF: // global
           I64[Sp - 8] = block_cdBjA_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBjA() //  [R1]
         { info_tbl: [(cdBjA,
                       label: block_cdBjA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBjA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBjI; else goto cdBjH;
       cdBjI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBjH: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyBx_entry() //  [R1, R2]
         { info_tbl: [(cdBjO,
                       label: sat_sdyBx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBjO: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyBD_entry() //  [R1]
         { info_tbl: [(cdBjR,
                       label: sat_sdyBD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBjR: // global
           _sdyBD::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdBjS; else goto cdBjT;
       cdBjT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBjV; else goto cdBjU;
       cdBjV: // global
           HpAlloc = 32;
           goto cdBjS;
       cdBjS: // global
           R1 = _sdyBD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBjU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyBD::P64;
           _sdyBu::P64 = P64[_sdyBD::P64 + 16];
           _sdyBv::P64 = P64[_sdyBD::P64 + 24];
           _sdyBw::P64 = P64[_sdyBD::P64 + 32];
           I64[Hp - 24] = sat_sdyBC_info;
           P64[Hp - 16] = _sdyBw::P64;
           I64[Hp - 8] = sat_sdyBx_info;
           P64[Hp] = _sdyBv::P64;
           R2 = _sdyBu::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadListDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBjW,
                       label: Data.Functor.Classes.liftReadListDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBjW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBk0; else goto cdBjZ;
       cdBk0: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBjZ: // global
           I64[Hp - 32] = sat_sdyBD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.251904555 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrecDefault_closure" {
     Data.Functor.Classes.liftReadListPrecDefault_closure:
         const Data.Functor.Classes.liftReadListPrecDefault_info;
         const 0;
 },
 sat_sdyBH_entry() //  [R1]
         { info_tbl: [(cdBk9,
                       label: sat_sdyBH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBk9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBka; else goto cdBkb;
       cdBka: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBkb: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrecDefault_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdBkc,
                       label: Data.Functor.Classes.liftReadListPrecDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBkc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBkg; else goto cdBkf;
       cdBkg: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrecDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBkf: // global
           I64[Hp - 32] = sat_sdyBH_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.253203534 UTC

[section ""data" . lvl_rdymy_closure" {
     lvl_rdymy_closure:
         const lvl_rdymy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rdymy_entry() //  [R1]
         { info_tbl: [(cdBkn,
                       label: lvl_rdymy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBkn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBko; else goto cdBkp;
       cdBko: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBkp: // global
           (_cdBkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdBkk::I64 == 0) goto cdBkm; else goto cdBkl;
       cdBkm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdBkl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdBkk::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.254445723 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_entry() //  []
         { info_tbl: [(cdBku,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBku: // global
           R1 = lvl_rdymy_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.255482256 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info;
         const 0;
 },
 sat_sdyBN_entry() //  [R1]
         { info_tbl: [(cdBkF,
                       label: sat_sdyBN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBkF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBkG; else goto cdBkH;
       cdBkG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBkH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udBkN_srtd" {
     udBkN_srtd:
         const SdyRV_srt+16;
         const 34;
         const 8590000129;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdBkI,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBkI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBkM; else goto cdBkL;
       cdBkM: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBkL: // global
           I64[Hp - 16] = sat_sdyBN_info;
           P64[Hp] = R4;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.256835406 UTC

[section ""data" . lvl1_rdymz_closure" {
     lvl1_rdymz_closure:
         const lvl1_rdymz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdymz_entry() //  [R1]
         { info_tbl: [(cdBkU,
                       label: lvl1_rdymz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBkU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBkV; else goto cdBkW;
       cdBkV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBkW: // global
           (_cdBkR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdBkR::I64 == 0) goto cdBkT; else goto cdBkS;
       cdBkT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdBkS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdBkR::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.258001427 UTC

[section ""data" . lvl2_rdymA_closure" {
     lvl2_rdymA_closure:
         const lvl2_rdymA_info;
         const 0;
 },
 lvl2_rdymA_entry() //  [R2]
         { info_tbl: [(cdBl1,
                       label: lvl2_rdymA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBl1: // global
           R3 = R2;
           R2 = lvl1_rdymz_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.258910275 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadList_entry() //  [R4]
         { info_tbl: [(cdBl8,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBl8: // global
           R2 = R4;
           call lvl2_rdymA_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.259629574 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_closure" {
     Data.Functor.Classes.$fRead1Proxy_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure+3;
         const Data.Functor.Classes.$fRead1Proxy5_closure+4;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.260412379 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_entry() //  [R3]
         { info_tbl: [(cdBlf,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBlf: // global
           R2 = R3;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.261603828 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info;
 },
 sat_sdyBX_entry() //  [R1]
         { info_tbl: [(cdBlt,
                       label: sat_sdyBX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBlt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBlu; else goto cdBlv;
       cdBlu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBlv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdBlq_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdBlq() //  [R1]
         { info_tbl: [(cdBlq,
                       label: block_cdBlq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBlq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBly; else goto cdBlx;
       cdBly: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdBlx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdBlz,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBlz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBlD; else goto cdBlC;
       cdBlD: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBlC: // global
           I64[Hp - 16] = sat_sdyBX_info;
           P64[Hp] = R3;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.26349711 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList2_closure" {
     Data.Functor.Classes.$w$cliftReadList2_closure:
         const Data.Functor.Classes.$w$cliftReadList2_info;
         const 0;
 },
 sat_sdyC3_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBlU,
                       label: sat_sdyC3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBlU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBlV; else goto cdBlW;
       cdBlV: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBlW: // global
           I64[Sp - 8] = block_cdBlR_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBlR() //  [R1]
         { info_tbl: [(cdBlR,
                       label: block_cdBlR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBlR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBlZ; else goto cdBlY;
       cdBlZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBlY: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyC4_entry() //  [R1]
         { info_tbl: [(cdBm0,
                       label: sat_sdyC4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBm0: // global
           _sdyC4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBm1; else goto cdBm2;
       cdBm2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBm4; else goto cdBm3;
       cdBm4: // global
           HpAlloc = 16;
           goto cdBm1;
       cdBm1: // global
           R1 = _sdyC4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBm3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyC4::P64;
           _sdyBY::P64 = P64[_sdyC4::P64 + 16];
           I64[Hp - 8] = sat_sdyC3_info;
           P64[Hp] = _sdyBY::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadList2_entry() //  [R2]
         { info_tbl: [(cdBm5,
                       label: Data.Functor.Classes.$w$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBm5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBm9; else goto cdBm8;
       cdBm9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBm8: // global
           I64[Hp - 16] = sat_sdyC4_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.265344663 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadList_entry() //  [R3]
         { info_tbl: [(cdBme,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBme: // global
           R2 = R3;
           call Data.Functor.Classes.$w$cliftReadList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.266081363 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_closure" {
     Data.Functor.Classes.$fRead1[]_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.267126366 UTC

[section ""data" . Data.Functor.Classes.showsPrec1_closure" {
     Data.Functor.Classes.showsPrec1_closure:
         const Data.Functor.Classes.showsPrec1_info;
 },
 sat_sdyCa_entry() //  [R1]
         { info_tbl: [(cdBmp,
                       label: sat_sdyCa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBmp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBmq; else goto cdBmr;
       cdBmq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBmr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyC9_entry() //  [R1]
         { info_tbl: [(cdBmw,
                       label: sat_sdyC9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBmw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBmx; else goto cdBmy;
       cdBmx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBmy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdBmz,
                       label: Data.Functor.Classes.showsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBmz: // global
           _sdyC8::P64 = R3;
           _sdyC7::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBmA; else goto cdBmB;
       cdBmB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBmD; else goto cdBmC;
       cdBmD: // global
           HpAlloc = 48;
           goto cdBmA;
       cdBmA: // global
           R3 = _sdyC8::P64;
           R2 = _sdyC7::P64;
           R1 = Data.Functor.Classes.showsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBmC: // global
           I64[Hp - 40] = sat_sdyCa_info;
           P64[Hp - 24] = _sdyC8::P64;
           I64[Hp - 16] = sat_sdyC9_info;
           P64[Hp] = _sdyC8::P64;
           R2 = _sdyC7::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.268576688 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith1_closure" {
     Data.Functor.Classes.showsUnaryWith1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.270958017 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary1_closure" {
     Data.Functor.Classes.$wshowsUnary1_closure:
         const Data.Functor.Classes.$wshowsUnary1_info;
 },
 Data.Functor.Classes.$wshowsUnary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBmF: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCi_entry() //  [R1]
         { info_tbl: [(cdBmR,
                       label: sat_sdyCi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBmR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBmS; else goto cdBmT;
       cdBmS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBmT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCh_entry() //  [R1]
         { info_tbl: [(cdBmY,
                       label: sat_sdyCh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBmY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBmZ; else goto cdBn0;
       cdBmZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBn0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdyCg_entry() //  [R1]
         { info_tbl: [(cdBn1,
                       label: g_sdyCg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBn1: // global
           _sdyCg::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdBn2; else goto cdBn3;
       cdBn3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBn5; else goto cdBn4;
       cdBn5: // global
           HpAlloc = 48;
           goto cdBn2;
       cdBn2: // global
           R1 = _sdyCg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBn4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCg::P64;
           _sdyCb::P64 = P64[_sdyCg::P64 + 16];
           _sdyCc::P64 = P64[_sdyCg::P64 + 24];
           _sdyCf::P64 = P64[_sdyCg::P64 + 32];
           I64[Hp - 40] = sat_sdyCi_info;
           P64[Hp - 24] = _sdyCc::P64;
           I64[Hp - 16] = sat_sdyCh_info;
           P64[Hp] = _sdyCc::P64;
           R2 = _sdyCb::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCf::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCn_entry() //  [R1, R2]
         { info_tbl: [(cdBng,
                       label: sat_sdyCn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBng: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBnk; else goto cdBnj;
       cdBnk: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBnj: // global
           _sdyCd::P64 = P64[R1 + 7];
           _sdyCg::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyCd::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCq_entry() //  [R1]
         { info_tbl: [(cdBnA,
                       label: sat_sdyCq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBnA: // global
           _sdyCq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBnB; else goto cdBnC;
       cdBnC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBnE; else goto cdBnD;
       cdBnE: // global
           HpAlloc = 24;
           goto cdBnB;
       cdBnB: // global
           R1 = _sdyCq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBnD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCq::P64;
           _sdyCg::P64 = P64[_sdyCq::P64 + 16];
           _sdyCo::P64 = P64[_sdyCq::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyCo::P64;
           R2 = Hp - 14;
           R1 = _sdyCg::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCs_entry() //  [R1]
         { info_tbl: [(cdBnG,
                       label: sat_sdyCs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBnG: // global
           _sdyCs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBnH; else goto cdBnI;
       cdBnI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBnK; else goto cdBnJ;
       cdBnK: // global
           HpAlloc = 56;
           goto cdBnH;
       cdBnH: // global
           R1 = _sdyCs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBnJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCs::P64;
           _sdyCd::P64 = P64[_sdyCs::P64 + 16];
           _sdyCg::P64 = P64[_sdyCs::P64 + 24];
           _sdyCo::P64 = P64[_sdyCs::P64 + 32];
           I64[Hp - 48] = sat_sdyCq_info;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = _sdyCo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyCd::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCt_entry() //  [R1, R2]
         { info_tbl: [(cdBnM,
                       label: sat_sdyCt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBnM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBnQ; else goto cdBnP;
       cdBnQ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBnP: // global
           _sdyCd::P64 = P64[R1 + 7];
           _sdyCg::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyCs_info;
           P64[Hp - 40] = _sdyCd::P64;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBnU,
                       label: Data.Functor.Classes.$wshowsUnary1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBnU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBnY; else goto cdBnX;
       cdBnY: // global
           HpAlloc = 64;
           R1 = Data.Functor.Classes.$wshowsUnary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdBnX: // global
           I64[Hp - 56] = g_sdyCg_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdBmJ::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdBnS; else goto cdBnT;
       cdBnS: // global
           I64[Hp - 16] = sat_sdyCn_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdBmJ::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBnT: // global
           I64[Hp - 16] = sat_sdyCt_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdBmJ::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.274947293 UTC

[section ""data" . Data.Functor.Classes.showsUnary1_closure" {
     Data.Functor.Classes.showsUnary1_closure:
         const Data.Functor.Classes.showsUnary1_info;
 },
 Data.Functor.Classes.showsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBo6,
                       label: Data.Functor.Classes.showsUnary1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBo6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBo7; else goto cdBo8;
       cdBo7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBo8: // global
           I64[Sp - 40] = block_cdBo3_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udBoc; else goto cdBo4;
       udBoc: // global
           call _cdBo3(R1) args: 0, res: 0, upd: 0;
       cdBo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBo3() //  [R1]
         { info_tbl: [(cdBo3,
                       label: block_cdBo3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBo3: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.278410065 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinary1_closure" {
     Data.Functor.Classes.$wshowsBinary1_closure:
         const Data.Functor.Classes.$wshowsBinary1_info;
 },
 Data.Functor.Classes.$wshowsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBoe: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdyCK_entry() //  [R1]
         { info_tbl: [(cdBoq,
                       label: sat_sdyCK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBoq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBor; else goto cdBos;
       cdBor: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBos: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCJ_entry() //  [R1]
         { info_tbl: [(cdBox,
                       label: sat_sdyCJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBoy; else goto cdBoz;
       cdBoy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBoz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdyCI_entry() //  [R1]
         { info_tbl: [(cdBoA,
                       label: f1_sdyCI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBoA: // global
           _sdyCI::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdBoB; else goto cdBoC;
       cdBoC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBoE; else goto cdBoD;
       cdBoE: // global
           HpAlloc = 48;
           goto cdBoB;
       cdBoB: // global
           R1 = _sdyCI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBoD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCI::P64;
           _sdyCB::P64 = P64[_sdyCI::P64 + 16];
           _sdyCD::P64 = P64[_sdyCI::P64 + 24];
           _sdyCG::P64 = P64[_sdyCI::P64 + 32];
           I64[Hp - 40] = sat_sdyCK_info;
           P64[Hp - 24] = _sdyCD::P64;
           I64[Hp - 16] = sat_sdyCJ_info;
           P64[Hp] = _sdyCD::P64;
           R2 = _sdyCB::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCG::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCN_entry() //  [R1]
         { info_tbl: [(cdBoN,
                       label: sat_sdyCN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBoO; else goto cdBoP;
       cdBoO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBoP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCM_entry() //  [R1]
         { info_tbl: [(cdBoU,
                       label: sat_sdyCM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBoU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBoV; else goto cdBoW;
       cdBoV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBoW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g1_sdyCL_entry() //  [R1]
         { info_tbl: [(cdBoX,
                       label: g1_sdyCL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBoX: // global
           _sdyCL::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdBoY; else goto cdBoZ;
       cdBoZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBp1; else goto cdBp0;
       cdBp1: // global
           HpAlloc = 48;
           goto cdBoY;
       cdBoY: // global
           R1 = _sdyCL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBp0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCL::P64;
           _sdyCC::P64 = P64[_sdyCL::P64 + 16];
           _sdyCD::P64 = P64[_sdyCL::P64 + 24];
           _sdyCH::P64 = P64[_sdyCL::P64 + 32];
           I64[Hp - 40] = sat_sdyCN_info;
           P64[Hp - 24] = _sdyCD::P64;
           I64[Hp - 16] = sat_sdyCM_info;
           P64[Hp] = _sdyCD::P64;
           R2 = _sdyCC::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCH::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCS_entry() //  [R1]
         { info_tbl: [(cdBpg,
                       label: sat_sdyCS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBpg: // global
           _sdyCS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBph; else goto cdBpi;
       cdBpi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBpk; else goto cdBpj;
       cdBpk: // global
           HpAlloc = 56;
           goto cdBph;
       cdBph: // global
           R1 = _sdyCS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBpj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCS::P64;
           _sdyCI::P64 = P64[_sdyCS::P64 + 16];
           _sdyCL::P64 = P64[_sdyCS::P64 + 24];
           _sdyCP::P64 = P64[_sdyCS::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyCI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCU_entry() //  [R1, R2]
         { info_tbl: [(cdBpm,
                       label: sat_sdyCU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBpm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBpq; else goto cdBpp;
       cdBpq: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBpp: // global
           _sdyCE::P64 = P64[R1 + 7];
           _sdyCI::P64 = P64[R1 + 15];
           _sdyCL::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdyCS_info;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyCE::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCX_entry() //  [R1]
         { info_tbl: [(cdBpK,
                       label: sat_sdyCX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBpK: // global
           _sdyCX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBpL; else goto cdBpM;
       cdBpM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBpO; else goto cdBpN;
       cdBpO: // global
           HpAlloc = 24;
           goto cdBpL;
       cdBpL: // global
           R1 = _sdyCX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBpN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCX::P64;
           _sdyCL::P64 = P64[_sdyCX::P64 + 16];
           _sdyCV::P64 = P64[_sdyCX::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyCV::P64;
           R2 = Hp - 14;
           R1 = _sdyCL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCZ_entry() //  [R1]
         { info_tbl: [(cdBpQ,
                       label: sat_sdyCZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBpQ: // global
           _sdyCZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBpR; else goto cdBpS;
       cdBpS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBpU; else goto cdBpT;
       cdBpU: // global
           HpAlloc = 56;
           goto cdBpR;
       cdBpR: // global
           R1 = _sdyCZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBpT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCZ::P64;
           _sdyCI::P64 = P64[_sdyCZ::P64 + 16];
           _sdyCL::P64 = P64[_sdyCZ::P64 + 24];
           _sdyCV::P64 = P64[_sdyCZ::P64 + 32];
           I64[Hp - 48] = sat_sdyCX_info;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyCI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyD1_entry() //  [R1]
         { info_tbl: [(cdBpW,
                       label: sat_sdyD1_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBpW: // global
           _sdyD1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBpX; else goto cdBpY;
       cdBpY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBq0; else goto cdBpZ;
       cdBq0: // global
           HpAlloc = 64;
           goto cdBpX;
       cdBpX: // global
           R1 = _sdyD1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBpZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyD1::P64;
           _sdyCE::P64 = P64[_sdyD1::P64 + 16];
           _sdyCI::P64 = P64[_sdyD1::P64 + 24];
           _sdyCL::P64 = P64[_sdyD1::P64 + 32];
           _sdyCV::P64 = P64[_sdyD1::P64 + 40];
           I64[Hp - 56] = sat_sdyCZ_info;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyCE::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyD2_entry() //  [R1, R2]
         { info_tbl: [(cdBq2,
                       label: sat_sdyD2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBq2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdBq6; else goto cdBq5;
       cdBq6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBq5: // global
           _sdyCE::P64 = P64[R1 + 7];
           _sdyCI::P64 = P64[R1 + 15];
           _sdyCL::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdyD1_info;
           P64[Hp - 48] = _sdyCE::P64;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinary1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdBqa,
                       label: Data.Functor.Classes.$wshowsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqa: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdBqe; else goto cdBqd;
       cdBqe: // global
           HpAlloc = 112;
           R1 = Data.Functor.Classes.$wshowsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdBqd: // global
           I64[Hp - 104] = f1_sdyCI_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = P64[Sp];
           I64[Hp - 64] = g1_sdyCL_info;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = P64[Sp + 8];
           _cdBoi::P64 = Hp - 104;
           _cdBoF::P64 = Hp - 64;
           if (%MO_S_Le_W64(R6, 10)) goto cdBq8; else goto cdBq9;
       cdBq8: // global
           I64[Hp - 24] = sat_sdyCU_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdBoi::P64;
           P64[Hp] = _cdBoF::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBq9: // global
           I64[Hp - 24] = sat_sdyD2_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdBoi::P64;
           P64[Hp] = _cdBoF::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.284456328 UTC

[section ""data" . Data.Functor.Classes.showsBinary1_closure" {
     Data.Functor.Classes.showsBinary1_closure:
         const Data.Functor.Classes.showsBinary1_info;
 },
 Data.Functor.Classes.showsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.showsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.showsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBqn,
                       label: Data.Functor.Classes.showsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBqo; else goto cdBqp;
       cdBqo: // global
           R1 = Data.Functor.Classes.showsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdBqp: // global
           I64[Sp - 40] = block_cdBqk_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udBqt; else goto cdBql;
       udBqt: // global
           call _cdBqk(R1) args: 0, res: 0, upd: 0;
       cdBql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBqk() //  [R1]
         { info_tbl: [(cdBqk,
                       label: block_cdBqk_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqk: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.28684093 UTC

[section ""data" . Data.Functor.Classes.eq2_closure" {
     Data.Functor.Classes.eq2_closure:
         const Data.Functor.Classes.eq2_info;
 },
 sat_sdyDg_entry() //  [R1]
         { info_tbl: [(cdBqC,
                       label: sat_sdyDg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBqD; else goto cdBqE;
       cdBqD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBqE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDf_entry() //  [R1]
         { info_tbl: [(cdBqJ,
                       label: sat_sdyDf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBqK; else goto cdBqL;
       cdBqK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBqL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBqM,
                       label: Data.Functor.Classes.eq2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBqQ; else goto cdBqP;
       cdBqQ: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBqP: // global
           I64[Hp - 40] = sat_sdyDg_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdyDf_info;
           P64[Hp] = R3;
           R3 = Hp - 40;
           _sdyDc::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdyDc::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.288757583 UTC

[section ""data" . Data.Functor.Classes.compare2_closure" {
     Data.Functor.Classes.compare2_closure:
         const Data.Functor.Classes.compare2_info;
 },
 sat_sdyDl_entry() //  [R1]
         { info_tbl: [(cdBqZ,
                       label: sat_sdyDl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBqZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBr0; else goto cdBr1;
       cdBr0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBr1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDk_entry() //  [R1]
         { info_tbl: [(cdBr6,
                       label: sat_sdyDk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBr6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBr7; else goto cdBr8;
       cdBr7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBr8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBr9,
                       label: Data.Functor.Classes.compare2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBr9: // global
           _sdyDj::P64 = R4;
           _sdyDi::P64 = R3;
           _sdyDh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBra; else goto cdBrb;
       cdBrb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBrd; else goto cdBrc;
       cdBrd: // global
           HpAlloc = 48;
           goto cdBra;
       cdBra: // global
           R4 = _sdyDj::P64;
           R3 = _sdyDi::P64;
           R2 = _sdyDh::P64;
           R1 = Data.Functor.Classes.compare2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBrc: // global
           I64[Hp - 40] = sat_sdyDl_info;
           P64[Hp - 24] = _sdyDj::P64;
           I64[Hp - 16] = sat_sdyDk_info;
           P64[Hp] = _sdyDi::P64;
           R2 = _sdyDh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftCompare2_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.290942803 UTC

[section ""data" . Data.Functor.Classes.readsPrec2_closure" {
     Data.Functor.Classes.readsPrec2_closure:
         const Data.Functor.Classes.readsPrec2_info;
 },
 sat_sdyDs_entry() //  [R1]
         { info_tbl: [(cdBrm,
                       label: sat_sdyDs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBrm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBrn; else goto cdBro;
       cdBrn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDr_entry() //  [R1]
         { info_tbl: [(cdBrt,
                       label: sat_sdyDr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBrt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBru; else goto cdBrv;
       cdBru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBrv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDq_entry() //  [R1]
         { info_tbl: [(cdBrA,
                       label: sat_sdyDq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBrA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBrB; else goto cdBrC;
       cdBrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDp_entry() //  [R1]
         { info_tbl: [(cdBrH,
                       label: sat_sdyDp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBrH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBrI; else goto cdBrJ;
       cdBrI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBrJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBrK,
                       label: Data.Functor.Classes.readsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBrK: // global
           _sdyDo::P64 = R4;
           _sdyDn::P64 = R3;
           _sdyDm::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBrL; else goto cdBrM;
       cdBrM: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdBrO; else goto cdBrN;
       cdBrO: // global
           HpAlloc = 96;
           goto cdBrL;
       cdBrL: // global
           R4 = _sdyDo::P64;
           R3 = _sdyDn::P64;
           R2 = _sdyDm::P64;
           R1 = Data.Functor.Classes.readsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBrN: // global
           I64[Hp - 88] = sat_sdyDs_info;
           P64[Hp - 72] = _sdyDo::P64;
           I64[Hp - 64] = sat_sdyDr_info;
           P64[Hp - 48] = _sdyDo::P64;
           I64[Hp - 40] = sat_sdyDq_info;
           P64[Hp - 24] = _sdyDn::P64;
           I64[Hp - 16] = sat_sdyDp_info;
           P64[Hp] = _sdyDn::P64;
           R2 = _sdyDm::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.29546625 UTC

[section ""data" . Data.Functor.Classes.readPrec2_closure" {
     Data.Functor.Classes.readPrec2_closure:
         const Data.Functor.Classes.readPrec2_info;
 },
 sat_sdyDz_entry() //  [R1]
         { info_tbl: [(cdBrX,
                       label: sat_sdyDz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBrX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBrY; else goto cdBrZ;
       cdBrY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBrZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDy_entry() //  [R1]
         { info_tbl: [(cdBs4,
                       label: sat_sdyDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBs4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBs5; else goto cdBs6;
       cdBs5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBs6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDx_entry() //  [R1]
         { info_tbl: [(cdBsb,
                       label: sat_sdyDx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBsc; else goto cdBsd;
       cdBsc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBsd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDw_entry() //  [R1]
         { info_tbl: [(cdBsi,
                       label: sat_sdyDw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBsj; else goto cdBsk;
       cdBsj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBsk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBsl,
                       label: Data.Functor.Classes.readPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsl: // global
           _sdyDv::P64 = R4;
           _sdyDu::P64 = R3;
           _sdyDt::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBsm; else goto cdBsn;
       cdBsn: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdBsp; else goto cdBso;
       cdBsp: // global
           HpAlloc = 96;
           goto cdBsm;
       cdBsm: // global
           R4 = _sdyDv::P64;
           R3 = _sdyDu::P64;
           R2 = _sdyDt::P64;
           R1 = Data.Functor.Classes.readPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBso: // global
           I64[Hp - 88] = sat_sdyDz_info;
           P64[Hp - 72] = _sdyDv::P64;
           I64[Hp - 64] = sat_sdyDy_info;
           P64[Hp - 48] = _sdyDv::P64;
           I64[Hp - 40] = sat_sdyDx_info;
           P64[Hp - 24] = _sdyDu::P64;
           I64[Hp - 16] = sat_sdyDw_info;
           P64[Hp] = _sdyDu::P64;
           R2 = _sdyDt::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.298487058 UTC

[section ""data" . Data.Functor.Classes.liftReadList2Default_closure" {
     Data.Functor.Classes.liftReadList2Default_closure:
         const Data.Functor.Classes.liftReadList2Default_info;
 },
 sat_sdyDQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBsG,
                       label: sat_sdyDQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBsH; else goto cdBsI;
       cdBsH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBsI: // global
           I64[Sp - 8] = block_cdBsD_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBsD() //  [R1]
         { info_tbl: [(cdBsD,
                       label: block_cdBsD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBsL; else goto cdBsK;
       cdBsL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBsK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDL_entry() //  [R1, R2]
         { info_tbl: [(cdBsR,
                       label: sat_sdyDL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDK_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBt2,
                       label: sat_sdyDK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBt2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBt3; else goto cdBt4;
       cdBt3: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBt4: // global
           I64[Sp - 8] = block_cdBsZ_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBsZ() //  [R1]
         { info_tbl: [(cdBsZ,
                       label: block_cdBsZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBsZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBt7; else goto cdBt6;
       cdBt7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBt6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDF_entry() //  [R1, R2]
         { info_tbl: [(cdBtd,
                       label: sat_sdyDF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDR_entry() //  [R1]
         { info_tbl: [(cdBtg,
                       label: sat_sdyDR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtg: // global
           _sdyDR::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto cdBth; else goto cdBti;
       cdBti: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBtk; else goto cdBtj;
       cdBtk: // global
           HpAlloc = 64;
           goto cdBth;
       cdBth: // global
           R1 = _sdyDR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBtj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyDR::P64;
           _sdyDA::P64 = P64[_sdyDR::P64 + 16];
           _sdyDB::P64 = P64[_sdyDR::P64 + 24];
           _sdyDC::P64 = P64[_sdyDR::P64 + 32];
           _sdyDD::P64 = P64[_sdyDR::P64 + 40];
           _sdyDE::P64 = P64[_sdyDR::P64 + 48];
           I64[Hp - 56] = sat_sdyDQ_info;
           P64[Hp - 48] = _sdyDE::P64;
           I64[Hp - 40] = sat_sdyDL_info;
           P64[Hp - 32] = _sdyDD::P64;
           I64[Hp - 24] = sat_sdyDK_info;
           P64[Hp - 16] = _sdyDC::P64;
           I64[Hp - 8] = sat_sdyDF_info;
           P64[Hp] = _sdyDB::P64;
           R2 = _sdyDA::P64;
           I64[Sp - 72] = stg_ap_pppppp_info;
           P64[Sp - 64] = Hp - 7;
           P64[Sp - 56] = Hp - 22;
           P64[Sp - 48] = Hp - 39;
           P64[Sp - 40] = Hp - 54;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 72;
           call Data.Functor.Classes.liftReadListPrec2_entry(R2) args: 80, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadList2Default_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdBtl,
                       label: Data.Functor.Classes.liftReadList2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBtp; else goto cdBto;
       cdBtp: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBto: // global
           I64[Hp - 48] = sat_sdyDR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.301380375 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_closure" {
     Data.Functor.Classes.$fRead2Either_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Either8_closure+6;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadList2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdBtu,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtu: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Either_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.302393211 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_closure" {
     Data.Functor.Classes.$fRead2Const_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Const6_closure+6;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadList2_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdBtB,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtB: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Const_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.30342338 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_closure" {
     Data.Functor.Classes.$fRead2(,)_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1(,)2_closure+6;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadList2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdBtI,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtI: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2(,)_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.304692407 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2Default_closure" {
     Data.Functor.Classes.liftReadListPrec2Default_closure:
         const Data.Functor.Classes.liftReadListPrec2Default_info;
         const 0;
 },
 sat_sdyDX_entry() //  [R1]
         { info_tbl: [(cdBtT,
                       label: sat_sdyDX_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBtU; else goto cdBtV;
       cdBtU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBtV: // global
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           P64[Sp - 16] = P64[R1 + 40];
           P64[Sp - 8] = P64[R1 + 48];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrec2Default_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cdBtW,
                       label: Data.Functor.Classes.liftReadListPrec2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBtW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBu0; else goto cdBtZ;
       cdBu0: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBtZ: // global
           I64[Hp - 48] = sat_sdyDX_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.306244712 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)1_closure" {
     Data.Functor.Classes.$fRead1(,)1_closure:
         const Data.Functor.Classes.$fRead1(,)1_info;
         const 0;
 },
 sat_sdyE3_entry() //  [R1]
         { info_tbl: [(cdBu9,
                       label: sat_sdyE3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBu9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBua; else goto cdBub;
       cdBua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBuc,
                       label: Data.Functor.Classes.$fRead1(,)1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBuc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBug; else goto cdBuf;
       cdBug: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBuf: // global
           I64[Hp - 16] = sat_sdyE3_info;
           P64[Hp] = R2;
           _sdyE1::P64 = R5;
           R5 = R6;
           R4 = _sdyE1::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.307957213 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec_info;
         const 0;
 },
 sat_sdyE8_entry() //  [R1, R2]
         { info_tbl: [(cdBuu,
                       label: sat_sdyE8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBuu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyE7_entry() //  [R1]
         { info_tbl: [(cdBuB,
                       label: sat_sdyE7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBuB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBuC; else goto cdBuD;
       cdBuC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBuD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyE9_entry() //  [R1]
         { info_tbl: [(cdBuE,
                       label: sat_sdyE9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBuE: // global
           _sdyE9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBuF; else goto cdBuG;
       cdBuG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBuI; else goto cdBuH;
       cdBuI: // global
           HpAlloc = 40;
           goto cdBuF;
       cdBuF: // global
           R1 = _sdyE9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBuH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyE9::P64;
           _sdyE4::P64 = P64[_sdyE9::P64 + 16];
           _sdyE5::P64 = P64[_sdyE9::P64 + 24];
           _sdyE6::P64 = P64[_sdyE9::P64 + 32];
           I64[Hp - 32] = sat_sdyE8_info;
           P64[Hp - 24] = _sdyE5::P64;
           I64[Hp - 16] = sat_sdyE7_info;
           P64[Hp] = _sdyE4::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyE6::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBuJ,
                       label: Data.Functor.Classes.$w$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBuJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBuN; else goto cdBuM;
       cdBuN: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBuM: // global
           I64[Hp - 32] = sat_sdyE9_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.309965742 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_entry() //  [R2,
                                                              R3, R5]
         { info_tbl: [(cdBuS,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBuS: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.311055037 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyEh_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBv4,
                       label: sat_sdyEh_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBv4: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdBv7,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBv7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBvb; else goto cdBva;
       cdBvb: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBva: // global
           I64[Hp - 24] = sat_sdyEh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 22;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.313141309 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_closure" {
     Data.Functor.Classes.$fRead1(,)_closure:
         const Data.Functor.Classes.$fRead1(,)_info;
         const 0;
 },
 sat_sdyEp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBvl,
                       label: sat_sdyEp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBvl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEo_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdBvt,
                       label: sat_sdyEo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBvt: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEn_entry() //  [R1]
         { info_tbl: [(cdBvA,
                       label: sat_sdyEn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBvA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBvB; else goto cdBvC;
       cdBvB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEm_entry() //  [R1, R2, R4]
         { info_tbl: [(cdBvI,
                       label: sat_sdyEm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBvI: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_entry() //  [R2]
         { info_tbl: [(cdBvM,
                       label: Data.Functor.Classes.$fRead1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBvM: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdBvQ; else goto cdBvP;
       cdBvQ: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBvP: // global
           I64[Hp - 104] = sat_sdyEp_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdyEo_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyEn_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyEm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_info;
         const 0;
 },
 sat_sdyEr_entry() //  [R1]
         { info_tbl: [(cdBvZ,
                       label: sat_sdyEr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBvZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBw0; else goto cdBw1;
       cdBw0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBw1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdBw2,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBw2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBw6; else goto cdBw5;
       cdBw6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBw5: // global
           I64[Hp - 16] = sat_sdyEr_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.31594626 UTC

[section ""data" . Data.Functor.Classes.showsPrec2_closure" {
     Data.Functor.Classes.showsPrec2_closure:
         const Data.Functor.Classes.showsPrec2_info;
 },
 sat_sdyEy_entry() //  [R1]
         { info_tbl: [(cdBwf,
                       label: sat_sdyEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBwg; else goto cdBwh;
       cdBwg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBwh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEx_entry() //  [R1]
         { info_tbl: [(cdBwm,
                       label: sat_sdyEx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBwn; else goto cdBwo;
       cdBwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEw_entry() //  [R1]
         { info_tbl: [(cdBwt,
                       label: sat_sdyEw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBwu; else goto cdBwv;
       cdBwu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBwv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEv_entry() //  [R1]
         { info_tbl: [(cdBwA,
                       label: sat_sdyEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBwB; else goto cdBwC;
       cdBwB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBwC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBwD,
                       label: Data.Functor.Classes.showsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwD: // global
           _sdyEu::P64 = R4;
           _sdyEt::P64 = R3;
           _sdyEs::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBwE; else goto cdBwF;
       cdBwF: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdBwH; else goto cdBwG;
       cdBwH: // global
           HpAlloc = 96;
           goto cdBwE;
       cdBwE: // global
           R4 = _sdyEu::P64;
           R3 = _sdyEt::P64;
           R2 = _sdyEs::P64;
           R1 = Data.Functor.Classes.showsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBwG: // global
           I64[Hp - 88] = sat_sdyEy_info;
           P64[Hp - 72] = _sdyEu::P64;
           I64[Hp - 64] = sat_sdyEx_info;
           P64[Hp - 48] = _sdyEu::P64;
           I64[Hp - 40] = sat_sdyEw_info;
           P64[Hp - 24] = _sdyEt::P64;
           I64[Hp - 16] = sat_sdyEv_info;
           P64[Hp] = _sdyEt::P64;
           R2 = _sdyEs::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.318960993 UTC

[section ""data" . Data.Functor.Classes.$wreadsData_closure" {
     Data.Functor.Classes.$wreadsData_closure:
         const Data.Functor.Classes.$wreadsData_info;
         const 0;
 },
 sat_sdyEL_entry() //  [R1]
         { info_tbl: [(cdBx6,
                       label: sat_sdyEL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBx6: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sdyEC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyEC_entry() //  [R1, R2]
         { info_tbl: [(cdBxd,
                       label: go_sdyEC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBxe; else goto cdBxf;
       cdBxe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBxf: // global
           I64[Sp - 24] = block_cdBwR_info;
           _sdyEC::P64 = R1;
           _sdyEz::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyEz::P64;
           P64[Sp - 8] = _sdyEC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBxs; else goto cdBwS;
       udBxs: // global
           call _cdBwR(R1) args: 0, res: 0, upd: 0;
       cdBwS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBwR() //  [R1]
         { info_tbl: [(cdBwR,
                       label: block_cdBwR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwR: // global
           if (R1 & 7 == 1) goto cdBxa; else goto cdBxb;
       cdBxa: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBxb: // global
           I64[Sp - 8] = block_cdBwX_info;
           _sdyEG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyEG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udBxr; else goto cdBwY;
       udBxr: // global
           call _cdBwX(R1) args: 0, res: 0, upd: 0;
       cdBwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBwX() //  [R1]
         { info_tbl: [(cdBwX,
                       label: block_cdBwX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBwX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBxm; else goto cdBxl;
       cdBxm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBxl: // global
           _sdyEI::P64 = P64[R1 + 7];
           _sdyEJ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdyEL_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _sdyEz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdBxi_info;
           R3 = _sdyEJ::P64;
           R2 = _sdyEI::P64;
           R1 = _sdyEz::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBxi() //  [R1]
         { info_tbl: [(cdBxi,
                       label: block_cdBxi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxi: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEQ_entry() //  [R1, R2]
         { info_tbl: [(cdBxA,
                       label: sat_sdyEQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBxB; else goto cdBxC;
       cdBxB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBxC: // global
           I64[Sp - 16] = block_cdBxy_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBxy() //  [R1]
         { info_tbl: [(cdBxy,
                       label: block_cdBxy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxy: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyEC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udBxN_srtd" {
     udBxN_srtd:
         const SdyRV_srt+120;
         const 36;
         const 51539607553;
 },
 Data.Functor.Classes.$wreadsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBxI,
                       label: Data.Functor.Classes.$wreadsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBxM; else goto cdBxL;
       cdBxM: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBxL: // global
           I64[Hp - 24] = go_sdyEC_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyEQ_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sdyEN::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sdyEN::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.321898034 UTC

[section ""data" . Data.Functor.Classes.readsData_closure" {
     Data.Functor.Classes.readsData_closure:
         const Data.Functor.Classes.readsData_info;
         const 0;
 },
 Data.Functor.Classes.readsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBxV,
                       label: Data.Functor.Classes.readsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBxW; else goto cdBxX;
       cdBxW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBxX: // global
           I64[Sp - 24] = block_cdBxS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBy1; else goto cdBxT;
       udBy1: // global
           call _cdBxS(R1) args: 0, res: 0, upd: 0;
       cdBxT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBxS() //  [R1]
         { info_tbl: [(cdBxS,
                       label: block_cdBxS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBxS: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wreadsData_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.323011577 UTC

[section ""data" . Data.Functor.Classes.readData2_closure" {
     Data.Functor.Classes.readData2_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.324271192 UTC

[section ""data" . Data.Functor.Classes.readData1_closure" {
     Data.Functor.Classes.readData1_closure:
         const Data.Functor.Classes.readData1_info;
         const 0;
 },
 lvl3_sdyEZ_entry() //  [R1]
         { info_tbl: [(cdBya,
                       label: lvl3_sdyEZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBya: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdByb; else goto cdByc;
       cdByb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdByc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.readData2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyF4_entry() //  [R1, R2]
         { info_tbl: [(cdByl,
                       label: sat_sdyF4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdByl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBym; else goto cdByn;
       cdBym: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdByn: // global
           I64[Sp - 16] = block_cdByi_info;
           _sdyEZ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdyEZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udByw; else goto cdByj;
       udByw: // global
           call _cdByi(R1) args: 0, res: 0, upd: 0;
       cdByj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdByi() //  [R1]
         { info_tbl: [(cdByi,
                       label: block_cdByi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdByi: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdByu; else goto cdByv;
       cdByu: // global
           R1 = Text.ParserCombinators.ReadP.$fAlternativeReadP4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdByv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readData1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdByx,
                       label: Data.Functor.Classes.readData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdByx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdByB; else goto cdByA;
       cdByB: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readData1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdByA: // global
           I64[Hp - 32] = lvl3_sdyEZ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyF4_info;
           P64[Hp] = Hp - 32;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.326288567 UTC

[section ""data" . Data.Functor.Classes.readData_closure" {
     Data.Functor.Classes.readData_closure:
         const Data.Functor.Classes.readData_info;
         const 0;
 },
 Data.Functor.Classes.readData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdByG,
                       label: Data.Functor.Classes.readData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdByG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readData1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.328047027 UTC

[section ""data" . Data.Functor.Classes.readsUnaryWith_closure" {
     Data.Functor.Classes.readsUnaryWith_closure:
         const Data.Functor.Classes.readsUnaryWith_info;
 },
 go_sdyFb_entry() //  [R1, R2]
         { info_tbl: [(cdBz4,
                       label: go_sdyFb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBz4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBz5; else goto cdBz6;
       cdBz5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBz6: // global
           I64[Sp - 24] = block_cdByX_info;
           _sdyFb::P64 = R1;
           _sdyF7::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyF7::P64;
           P64[Sp - 8] = _sdyFb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBzq; else goto cdByY;
       udBzq: // global
           call _cdByX(R1) args: 0, res: 0, upd: 0;
       cdByY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdByX() //  [R1]
         { info_tbl: [(cdByX,
                       label: block_cdByX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdByX: // global
           if (R1 & 7 == 1) goto cdBz1; else goto cdBz2;
       cdBz1: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBz2: // global
           I64[Sp - 8] = block_cdBzc_info;
           _sdyFf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyFf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udBzp; else goto cdBzd;
       udBzp: // global
           call _cdBzc(R1) args: 0, res: 0, upd: 0;
       cdBzd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBzc() //  [R1]
         { info_tbl: [(cdBzc,
                       label: block_cdBzc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBzc: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdBzo; else goto cdBzn;
       cdBzo: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBzn: // global
           _sdyFh::P64 = P64[R1 + 7];
           _sdyFi::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyFh::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyFi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdBzv,
                       label: Data.Functor.Classes.readsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBzv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBzw; else goto cdBzx;
       cdBzw: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBzx: // global
           I64[Sp - 32] = block_cdByN_info;
           R3 = R3;
           _sdyF5::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdyF5::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdByN() //  [R1]
         { info_tbl: [(cdByN,
                       label: block_cdByN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdByN: // global
           if (R1 & 7 == 1) goto cdBzs; else goto cdBzt;
       cdBzs: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBzt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBzD; else goto cdBzC;
       cdBzD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBzC: // global
           I64[Hp - 8] = go_sdyFb_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdBzA_info;
           R3 = P64[Sp + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBzA() //  [R1]
         { info_tbl: [(cdBzA,
                       label: block_cdBzA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBzA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyFb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.331369381 UTC

[section ""data" . Data.Functor.Classes.$wreadUnaryWith_closure" {
     Data.Functor.Classes.$wreadUnaryWith_closure:
         const Data.Functor.Classes.$wreadUnaryWith_info;
         const 0;
 },
 sat_sdyFA_entry() //  [R1, R2]
         { info_tbl: [(cdBzX,
                       label: sat_sdyFA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBzX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBA1; else goto cdBA0;
       cdBA1: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBA0: // global
           _sdyFp::P64 = P64[R1 + 7];
           _sdyFr::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdyFp::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdyFr::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyFx_entry() //  [R1]
         { info_tbl: [(cdBA9,
                       label: sat_sdyFx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBA9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBAg; else goto cdBAh;
       cdBAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBAh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdBA6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBAl; else goto cdBA7;
       udBAl: // global
           call _cdBA6(R1) args: 0, res: 0, upd: 0;
       cdBA7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdBA6() //  [R1]
         { info_tbl: [(cdBA6,
                       label: block_cdBA6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBA6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBAk; else goto cdBAj;
       cdBAk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdBAj: // global
           _sdyFw::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdyFw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyFB_entry() //  [R1, R2]
         { info_tbl: [(cdBAm,
                       label: sat_sdyFB_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBAm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBAq; else goto cdBAp;
       cdBAq: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBAp: // global
           _sdyFn::P64 = P64[R1 + 7];
           _sdyFp::P64 = P64[R1 + 15];
           _sdyFq::P64 = P64[R1 + 23];
           _sdyFr::P64 = P64[R1 + 31];
           I64[Hp - 40] = sat_sdyFA_info;
           P64[Hp - 32] = _sdyFp::P64;
           P64[Hp - 24] = _sdyFr::P64;
           I64[Hp - 16] = sat_sdyFx_info;
           P64[Hp] = _sdyFq::P64;
           R3 = Hp - 39;
           R2 = Hp - 16;
           R1 = _sdyFn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadUnaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdBAs,
                       label: Data.Functor.Classes.$wreadUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBAs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBAw; else goto cdBAv;
       cdBAw: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBAv: // global
           I64[Hp - 48] = sat_sdyFB_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R3;
           R3 = Hp - 47;
           R2 = Hp - 4;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.33380024 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith1_closure" {
     Data.Functor.Classes.readUnaryWith1_closure:
         const Data.Functor.Classes.readUnaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdBAE,
                       label: Data.Functor.Classes.readUnaryWith1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBAE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBAF; else goto cdBAG;
       cdBAF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readUnaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBAG: // global
           I64[Sp - 8] = block_cdBAB_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadUnaryWith_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBAB() //  [R1]
         { info_tbl: [(cdBAB,
                       label: block_cdBAB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBAB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBAJ; else goto cdBAI;
       cdBAJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBAI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.33510006 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith_closure" {
     Data.Functor.Classes.readUnaryWith_closure:
         const Data.Functor.Classes.readUnaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBAO,
                       label: Data.Functor.Classes.readUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBAO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readUnaryWith1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.336261676 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const5_closure" {
     Data.Functor.Classes.$fRead1Const5_closure:
         const Data.Functor.Classes.$fRead1Const5_info;
         const 0;
 },
 sat_sdyFO_entry() //  [R1]
         { info_tbl: [(cdBAZ,
                       label: sat_sdyFO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBB0; else goto cdBB1;
       cdBB0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBB1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBB2,
                       label: Data.Functor.Classes.$fRead1Const5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBB2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBB6; else goto cdBB5;
       cdBB6: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBB5: // global
           I64[Hp - 16] = sat_sdyFO_info;
           P64[Hp] = R2;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.338007044 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec1_info;
         const 0;
 },
 sat_sdyFR_entry() //  [R1]
         { info_tbl: [(cdBBj,
                       label: sat_sdyFR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBBk; else goto cdBBl;
       cdBBk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBBl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyFS_entry() //  [R1]
         { info_tbl: [(cdBBm,
                       label: sat_sdyFS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBm: // global
           _sdyFS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBBn; else goto cdBBo;
       cdBBo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBBq; else goto cdBBp;
       cdBBq: // global
           HpAlloc = 24;
           goto cdBBn;
       cdBBn: // global
           R1 = _sdyFS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBBp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyFS::P64;
           _sdyFP::P64 = P64[_sdyFS::P64 + 16];
           _sdyFQ::P64 = P64[_sdyFS::P64 + 24];
           I64[Hp - 16] = sat_sdyFR_info;
           P64[Hp] = _sdyFP::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyFQ::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdBBr,
                       label: Data.Functor.Classes.$w$cliftReadsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBBv; else goto cdBBu;
       cdBBv: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBBu: // global
           I64[Hp - 24] = sat_sdyFS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.339720593 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_entry() //  [R2,
                                                                R5]
         { info_tbl: [(cdBBA,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBA: // global
           R3 = R5;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.340904263 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec_info;
         const 0;
 },
 w1_sdyFY_entry() //  [R1]
         { info_tbl: [(cdBBL,
                       label: w1_sdyFY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBBM; else goto cdBBN;
       cdBBM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBBN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyG1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBBT,
                       label: sat_sdyG1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdBBW,
                       label: Data.Functor.Classes.$w$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBBW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBC0; else goto cdBBZ;
       cdBC0: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBBZ: // global
           I64[Hp - 32] = w1_sdyFY_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyG1_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.342544852 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdBC5,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBC5: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.344337279 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_closure" {
     Data.Functor.Classes.$fRead1Const_closure:
         const Data.Functor.Classes.$fRead1Const_info;
         const 0;
 },
 lvl3_sdyG6_entry() //  [R1]
         { info_tbl: [(cdBCg,
                       label: lvl3_sdyG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBCg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBCh; else goto cdBCi;
       cdBCh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBCi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGf_entry() //  [R1]
         { info_tbl: [(cdBCo,
                       label: sat_sdyGf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBCo: // global
           R1 = P64[R1 + 6];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGc_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdBCw,
                       label: sat_sdyGc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBCw: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Const5_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGb_entry() //  [R1]
         { info_tbl: [(cdBCD,
                       label: sat_sdyGb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBCD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBCE; else goto cdBCF;
       cdBCE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBCF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGa_entry() //  [R1, R4]
         { info_tbl: [(cdBCL,
                       label: sat_sdyGa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBCL: // global
           R3 = R4;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Const_entry() //  [R2]
         { info_tbl: [(cdBCP,
                       label: Data.Functor.Classes.$fRead1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBCP: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdBCT; else goto cdBCS;
       cdBCT: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBCS: // global
           I64[Hp - 128] = lvl3_sdyG6_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sdyGf_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sdyGc_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyGb_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyGa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_info;
         const 0;
 },
 sat_sdyGh_entry() //  [R1]
         { info_tbl: [(cdBD2,
                       label: sat_sdyGh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBD2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBD3; else goto cdBD4;
       cdBD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdBD5,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBD5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBD9; else goto cdBD8;
       cdBD9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBD8: // global
           I64[Hp - 16] = sat_sdyGh_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.349175859 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either7_closure" {
     Data.Functor.Classes.$fRead1Either7_closure:
         const Data.Functor.Classes.$fRead1Either7_info;
         const 0;
 },
 sat_sdyGn_entry() //  [R1]
         { info_tbl: [(cdBDi,
                       label: sat_sdyGn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBDi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBDj; else goto cdBDk;
       cdBDj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either7_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdBDl,
                       label: Data.Functor.Classes.$fRead1Either7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBDl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBDp; else goto cdBDo;
       cdBDp: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either7_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBDo: // global
           I64[Hp - 16] = sat_sdyGn_info;
           P64[Hp] = R2;
           _sdyGl::P64 = R5;
           R5 = R6;
           R4 = _sdyGl::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.351026626 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec2_info;
         const 0;
 },
 sat_sdyGs_entry() //  [R1, R2]
         { info_tbl: [(cdBDD,
                       label: sat_sdyGs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBDD: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGr_entry() //  [R1]
         { info_tbl: [(cdBDK,
                       label: sat_sdyGr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBDL; else goto cdBDM;
       cdBDL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBDM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGt_entry() //  [R1]
         { info_tbl: [(cdBDN,
                       label: sat_sdyGt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBDN: // global
           _sdyGt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBDO; else goto cdBDP;
       cdBDP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBDR; else goto cdBDQ;
       cdBDR: // global
           HpAlloc = 40;
           goto cdBDO;
       cdBDO: // global
           R1 = _sdyGt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBDQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyGt::P64;
           _sdyGo::P64 = P64[_sdyGt::P64 + 16];
           _sdyGp::P64 = P64[_sdyGt::P64 + 24];
           _sdyGq::P64 = P64[_sdyGt::P64 + 32];
           I64[Hp - 32] = sat_sdyGs_info;
           P64[Hp - 24] = _sdyGp::P64;
           I64[Hp - 16] = sat_sdyGr_info;
           P64[Hp] = _sdyGo::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyGq::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBDS,
                       label: Data.Functor.Classes.$w$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBDS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBDW; else goto cdBDV;
       cdBDW: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBDV: // global
           I64[Hp - 32] = sat_sdyGt_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.352888222 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_entry() //  [R2,
                                                                 R3, R5]
         { info_tbl: [(cdBE1,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBE1: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.354044608 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec1_info;
         const 0;
 },
 w2_sdyGA_entry() //  [R1]
         { info_tbl: [(cdBEc,
                       label: w2_sdyGA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBEd; else goto cdBEe;
       cdBEd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBEe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBEk,
                       label: sat_sdyGD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEk: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdBEn,
                       label: Data.Functor.Classes.$w$cliftReadListPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBEr; else goto cdBEq;
       cdBEr: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBEq: // global
           I64[Hp - 40] = w2_sdyGA_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyGD_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.355472944 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cdBEw,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEw: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.357085225 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_closure" {
     Data.Functor.Classes.$fRead1Either_closure:
         const Data.Functor.Classes.$fRead1Either_info;
         const 0;
 },
 sat_sdyGQ_entry() //  [R1, R2]
         { info_tbl: [(cdBEI,
                       label: sat_sdyGQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEI: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGN_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdBEQ,
                       label: sat_sdyGN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEQ: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Either7_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGM_entry() //  [R1]
         { info_tbl: [(cdBEX,
                       label: sat_sdyGM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBEX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBEY; else goto cdBEZ;
       cdBEY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBEZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGL_entry() //  [R1, R2, R4]
         { info_tbl: [(cdBF5,
                       label: sat_sdyGL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBF5: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Either_entry() //  [R2]
         { info_tbl: [(cdBF9,
                       label: Data.Functor.Classes.$fRead1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBF9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdBFd; else goto cdBFc;
       cdBFd: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBFc: // global
           I64[Hp - 104] = sat_sdyGQ_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdyGN_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyGM_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyGL_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_info;
         const 0;
 },
 sat_sdyGS_entry() //  [R1]
         { info_tbl: [(cdBFm,
                       label: sat_sdyGS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBFm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBFn; else goto cdBFo;
       cdBFn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBFo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdBFp,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBFp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBFt; else goto cdBFs;
       cdBFt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBFs: // global
           I64[Hp - 16] = sat_sdyGS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.359444406 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Identity4_bytes" {
     Data.Functor.Classes.$fRead1Identity4_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.360217804 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity3_closure" {
     Data.Functor.Classes.$fRead1Identity3_closure:
         const Data.Functor.Classes.$fRead1Identity3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity3_entry() //  [R1]
         { info_tbl: [(cdBFA,
                       label: Data.Functor.Classes.$fRead1Identity3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBFA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBFB; else goto cdBFC;
       cdBFB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBFC: // global
           (_cdBFx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdBFx::I64 == 0) goto cdBFz; else goto cdBFy;
       cdBFz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdBFy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdBFx::I64;
           R2 = Data.Functor.Classes.$fRead1Identity4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.361126094 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity2_closure" {
     Data.Functor.Classes.$fRead1Identity2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.36276009 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec_closure" {
     Data.Functor.Classes.$w$cliftReadPrec_closure:
         const Data.Functor.Classes.$w$cliftReadPrec_info;
         const 0;
 },
 sat_sdyH3_entry() //  [R1, R2]
         { info_tbl: [(cdBG5,
                       label: sat_sdyH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBG5: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyH4_entry() //  [R1, R2]
         { info_tbl: [(cdBG8,
                       label: sat_sdyH4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBG8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBGc; else goto cdBGb;
       cdBGc: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBGb: // global
           _sdyGT::P64 = P64[R1 + 7];
           _sdyGX::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyH3_info;
           P64[Hp] = _sdyGX::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyGT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyH7_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBGd,
                       label: sat_sdyH7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBGd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBGe; else goto cdBGf;
       cdBGe: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBGf: // global
           I64[Sp - 24] = block_cdBFM_info;
           _sdyGT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyGT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBGs; else goto cdBFN;
       udBGs: // global
           call _cdBFM(R1) args: 0, res: 0, upd: 0;
       cdBFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBFM() //  [R1]
         { info_tbl: [(cdBFM,
                       label: block_cdBFM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBFM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBGi; else goto cdBGh;
       cdBGi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBGh: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdBGk; else goto cdBGo;
       cdBGk: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBGo: // global
           I64[Hp - 16] = sat_sdyH4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdBGl_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBGl() //  [R1]
         { info_tbl: [(cdBGl,
                       label: block_cdBGl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBGl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBGr; else goto cdBGq;
       cdBGr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBGq: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBGt,
                       label: Data.Functor.Classes.$w$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBGt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBGx; else goto cdBGw;
       cdBGx: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBGw: // global
           I64[Hp - 8] = sat_sdyH7_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.365195332 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity1_closure" {
     Data.Functor.Classes.$fRead1Identity1_closure:
         const Data.Functor.Classes.$fRead1Identity1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdBGC,
                       label: Data.Functor.Classes.$fRead1Identity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBGC: // global
           _sdyHa::P64 = R4;
           R4 = R5;
           R3 = _sdyHa::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.367250738 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec3_info;
         const 0;
 },
 lvl3_sdyHe_entry() //  [R1]
         { info_tbl: [(cdBGR,
                       label: lvl3_sdyHe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBGR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBGS; else goto cdBGT;
       cdBGS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBGT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyHm_entry() //  [R1, R2]
         { info_tbl: [(cdBHi,
                       label: sat_sdyHm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHi: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHp_entry() //  [R1, R2]
         { info_tbl: [(cdBHo,
                       label: sat_sdyHp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHo: // global
           _sdyHk::P64 = R2;
           _sdyHp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdBHp; else goto cdBHq;
       cdBHq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBHs; else goto cdBHr;
       cdBHs: // global
           HpAlloc = 16;
           goto cdBHp;
       cdBHp: // global
           R2 = _sdyHk::P64;
           R1 = _sdyHp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBHr: // global
           _sdyHe::P64 = P64[_sdyHp::P64 + 7];
           _sdyHg::P64 = P64[_sdyHp::P64 + 15];
           I64[Hp - 8] = sat_sdyHm_info;
           P64[Hp] = _sdyHg::P64;
           I64[Sp - 8] = block_cdBHl_info;
           R3 = Hp - 7;
           R2 = _sdyHe::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBHl() //  [R1]
         { info_tbl: [(cdBHl,
                       label: block_cdBHl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBHv; else goto cdBHu;
       cdBHv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBHu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBHw,
                       label: sat_sdyHs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBHx; else goto cdBHy;
       cdBHx: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBHy: // global
           I64[Sp - 24] = block_cdBGZ_info;
           _sdyHe::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyHe::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBHL; else goto cdBH0;
       udBHL: // global
           call _cdBGZ(R1) args: 0, res: 0, upd: 0;
       cdBH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBGZ() //  [R1]
         { info_tbl: [(cdBGZ,
                       label: block_cdBGZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBGZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBHB; else goto cdBHA;
       cdBHB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBHA: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdBHD; else goto cdBHH;
       cdBHD: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBHH: // global
           I64[Hp - 16] = sat_sdyHp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdBHE_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBHE() //  [R1]
         { info_tbl: [(cdBHE,
                       label: block_cdBHE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBHK; else goto cdBHJ;
       cdBHK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBHJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHt_entry() //  [R1]
         { info_tbl: [(cdBHM,
                       label: sat_sdyHt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHM: // global
           _sdyHt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBHN; else goto cdBHO;
       cdBHO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBHQ; else goto cdBHP;
       cdBHQ: // global
           HpAlloc = 40;
           goto cdBHN;
       cdBHN: // global
           R1 = _sdyHt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBHP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyHt::P64;
           _sdyHc::P64 = P64[_sdyHt::P64 + 16];
           _sdyHd::P64 = P64[_sdyHt::P64 + 24];
           I64[Hp - 32] = lvl3_sdyHe_info;
           P64[Hp - 16] = _sdyHc::P64;
           I64[Hp - 8] = sat_sdyHs_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyHd::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec3_entry() //  [R2, R3]
         { info_tbl: [(cdBHR,
                       label: Data.Functor.Classes.$w$cliftReadsPrec3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBHR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBHV; else goto cdBHU;
       cdBHV: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBHU: // global
           I64[Hp - 24] = sat_sdyHt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.371727116 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_entry() //  [R2,
                                                                   R4]
         { info_tbl: [(cdBI0,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBI0: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec3_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.372770155 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyHB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBIc,
                       label: sat_sdyHB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udBIk_srtd" {
     udBIk_srtd:
         const SdyRV_srt+304;
         const 35;
         const 21474836481;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_entry() //  [R2,
                                                                      R3]
         { info_tbl: [(cdBIf,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBIj; else goto cdBIi;
       cdBIj: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBIi: // global
           I64[Hp - 8] = sat_sdyHB_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.374446194 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList_closure" {
     Data.Functor.Classes.$w$cliftReadList_closure:
         const Data.Functor.Classes.$w$cliftReadList_info;
         const 0;
 },
 w1_sdyHD_entry() //  [R1, R2]
         { info_tbl: [(cdBIy,
                       label: w1_sdyHD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHG_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBIG,
                       label: sat_sdyHG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udBIT_srtd" {
     udBIT_srtd:
         const SdyRV_srt+304;
         const 33;
         const 4294967297;
 },
 sat_sdyHH_entry() //  [R1]
         { info_tbl: [(cdBIJ,
                       label: sat_sdyHH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIJ: // global
           _sdyHH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBIK; else goto cdBIL;
       cdBIL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBIN; else goto cdBIM;
       cdBIN: // global
           HpAlloc = 32;
           goto cdBIK;
       cdBIK: // global
           R1 = _sdyHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBIM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyHH::P64;
           _sdyHC::P64 = P64[_sdyHH::P64 + 16];
           I64[Hp - 24] = w1_sdyHD_info;
           P64[Hp - 16] = _sdyHC::P64;
           I64[Hp - 8] = sat_sdyHG_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udBIU_srtd" {
     udBIU_srtd:
         const SdyRV_srt+304;
         const 36;
         const 38654705665;
 },
 Data.Functor.Classes.$w$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdBIO,
                       label: Data.Functor.Classes.$w$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBIS; else goto cdBIR;
       cdBIS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBIR: // global
           I64[Hp - 16] = sat_sdyHH_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.376265515 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdBIZ,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBIZ: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.377033404 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_closure" {
     Data.Functor.Classes.$fRead1Identity_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Identity1_closure+4;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.377707531 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe7_bytes" {
     Data.Functor.Classes.$fRead1Maybe7_bytes:
         I8[] [78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.378480721 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe6_closure" {
     Data.Functor.Classes.$fRead1Maybe6_closure:
         const Data.Functor.Classes.$fRead1Maybe6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe6_entry() //  [R1]
         { info_tbl: [(cdBJ8,
                       label: Data.Functor.Classes.$fRead1Maybe6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBJ9; else goto cdBJa;
       cdBJ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBJa: // global
           (_cdBJ5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdBJ5::I64 == 0) goto cdBJ7; else goto cdBJ6;
       cdBJ7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdBJ6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdBJ5::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.379433078 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_lexeme_closure" {
     Data.Functor.Classes.$fRead1Maybe_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.380490341 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe5_closure" {
     Data.Functor.Classes.$fRead1Maybe5_closure:
         const Data.Functor.Classes.$fRead1Maybe5_info;
         const 0;
 },
 sat_sdyHN_entry() //  [R1]
         { info_tbl: [(cdBJk,
                       label: sat_sdyHN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJk: // global
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Maybe5_entry() //  [R2, R3]
         { info_tbl: [(cdBJq,
                       label: Data.Functor.Classes.$fRead1Maybe5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJq: // global
           _sdyHL::P64 = R3;
           _sdyHK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdBJr; else goto cdBJs;
       cdBJs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBJu; else goto cdBJt;
       cdBJu: // global
           HpAlloc = 16;
           goto cdBJr;
       cdBJr: // global
           R3 = _sdyHL::P64;
           R2 = _sdyHK::P64;
           R1 = Data.Functor.Classes.$fRead1Maybe5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBJt: // global
           I64[Hp - 8] = sat_sdyHN_info;
           P64[Hp] = _sdyHL::P64;
           I64[Sp - 8] = block_cdBJn_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Maybe_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBJn() //  [R1]
         { info_tbl: [(cdBJn,
                       label: block_cdBJn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBJx; else goto cdBJw;
       cdBJx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBJw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.381985656 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe4_bytes" {
     Data.Functor.Classes.$fRead1Maybe4_bytes:
         I8[] [74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.382798272 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe3_closure" {
     Data.Functor.Classes.$fRead1Maybe3_closure:
         const Data.Functor.Classes.$fRead1Maybe3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe3_entry() //  [R1]
         { info_tbl: [(cdBJE,
                       label: Data.Functor.Classes.$fRead1Maybe3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBJF; else goto cdBJG;
       cdBJF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBJG: // global
           (_cdBJB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdBJB::I64 == 0) goto cdBJD; else goto cdBJC;
       cdBJD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdBJC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdBJB::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.383757198 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe2_closure" {
     Data.Functor.Classes.$fRead1Maybe2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.385682699 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadPrec4_info;
         const 0;
 },
 sat_sdyI2_entry() //  [R1, R2]
         { info_tbl: [(cdBKe,
                       label: sat_sdyI2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBKi; else goto cdBKh;
       cdBKi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBKh: // global
           _sdyHV::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdyHV::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI3_entry() //  [R1, R2]
         { info_tbl: [(cdBKj,
                       label: sat_sdyI3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBKn; else goto cdBKm;
       cdBKn: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBKm: // global
           _sdyHQ::P64 = P64[R1 + 7];
           _sdyHV::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyI2_info;
           P64[Hp] = _sdyHV::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyHQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI6_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBKo,
                       label: sat_sdyI6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBKp; else goto cdBKq;
       cdBKp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBKq: // global
           I64[Sp - 24] = block_cdBJU_info;
           _sdyHQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyHQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBKD; else goto cdBJV;
       udBKD: // global
           call _cdBJU(R1) args: 0, res: 0, upd: 0;
       cdBJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBJU() //  [R1]
         { info_tbl: [(cdBJU,
                       label: block_cdBJU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBKt; else goto cdBKs;
       cdBKt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBKs: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdBKv; else goto cdBKz;
       cdBKv: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBKz: // global
           I64[Hp - 16] = sat_sdyI3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdBKw_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Maybe2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBKw() //  [R1]
         { info_tbl: [(cdBKw,
                       label: block_cdBKw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBKC; else goto cdBKB;
       cdBKC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBKB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI7_entry() //  [R1]
         { info_tbl: [(cdBKE,
                       label: sat_sdyI7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKE: // global
           _sdyI7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBKF; else goto cdBKG;
       cdBKG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBKI; else goto cdBKH;
       cdBKI: // global
           HpAlloc = 16;
           goto cdBKF;
       cdBKF: // global
           R1 = _sdyI7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBKH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyI7::P64;
           _sdyHQ::P64 = P64[_sdyI7::P64 + 16];
           _sdyHR::P64 = P64[_sdyI7::P64 + 24];
           _sdyHS::P64 = P64[_sdyI7::P64 + 32];
           I64[Hp - 8] = sat_sdyI6_info;
           P64[Hp] = _sdyHQ::P64;
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udBKT_srtd" {
     udBKT_srtd:
         const SdyRV_srt+64;
         const 70;
         const 175921860444161;
         const 52;
 },
 Data.Functor.Classes.$w$cliftReadPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBKL,
                       label: Data.Functor.Classes.$w$cliftReadPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKL: // global
           _sdyHS::P64 = R4;
           _sdyHR::P64 = R3;
           _sdyHQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBKM; else goto cdBKN;
       cdBKN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBKP; else goto cdBKO;
       cdBKP: // global
           HpAlloc = 40;
           goto cdBKM;
       cdBKM: // global
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = _sdyHQ::P64;
           R1 = Data.Functor.Classes.$w$cliftReadPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBKO: // global
           I64[Hp - 32] = sat_sdyI7_info;
           P64[Hp - 16] = _sdyHQ::P64;
           P64[Hp - 8] = _sdyHR::P64;
           P64[Hp] = _sdyHS::P64;
           I64[Sp - 16] = block_cdBKJ_info;
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = Data.Functor.Classes.$fRead1Maybe5_closure+2;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBKJ() //  [R1]
         { info_tbl: [(cdBKJ,
                       label: block_cdBKJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKJ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.389078337 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe1_closure" {
     Data.Functor.Classes.$fRead1Maybe1_closure:
         const Data.Functor.Classes.$fRead1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdBKY,
                       label: Data.Functor.Classes.$fRead1Maybe1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBKY: // global
           _sdyIa::P64 = R4;
           R4 = R5;
           R3 = _sdyIa::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.390586078 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec4_info;
         const 0;
 },
 sat_sdyIe_entry() //  [R1, R2]
         { info_tbl: [(cdBLe,
                       label: sat_sdyIe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBLe: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyIf_entry() //  [R1]
         { info_tbl: [(cdBLh,
                       label: sat_sdyIf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBLh: // global
           _sdyIf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBLi; else goto cdBLj;
       cdBLj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBLl; else goto cdBLk;
       cdBLl: // global
           HpAlloc = 16;
           goto cdBLi;
       cdBLi: // global
           R1 = _sdyIf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBLk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyIf::P64;
           _sdyIc::P64 = P64[_sdyIf::P64 + 16];
           _sdyId::P64 = P64[_sdyIf::P64 + 24];
           I64[Hp - 8] = sat_sdyIe_info;
           P64[Hp] = _sdyIc::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyId::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec4_entry() //  [R2, R3]
         { info_tbl: [(cdBLm,
                       label: Data.Functor.Classes.$w$cliftReadsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBLm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBLq; else goto cdBLp;
       cdBLq: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBLp: // global
           I64[Hp - 24] = sat_sdyIf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.392221158 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_entry() //  [R2,
                                                                R4]
         { info_tbl: [(cdBLv,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBLv: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec4_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.393341942 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyIn_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBLH,
                       label: sat_sdyIn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBLH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udBLP_srtd" {
     udBLP_srtd:
         const SdyRV_srt+304;
         const 43;
         const 4947802324993;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cdBLK,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBLK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBLO; else goto cdBLN;
       cdBLO: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBLN: // global
           I64[Hp - 8] = sat_sdyIn_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.395080686 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList1_closure" {
     Data.Functor.Classes.$w$cliftReadList1_closure:
         const Data.Functor.Classes.$w$cliftReadList1_info;
         const 0;
 },
 w1_sdyIp_entry() //  [R1, R2]
         { info_tbl: [(cdBM3,
                       label: w1_sdyIp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBM3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyIs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdBMb,
                       label: sat_sdyIs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBMb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udBMo_srtd" {
     udBMo_srtd:
         const SdyRV_srt+304;
         const 40;
         const 549755813889;
 },
 sat_sdyIt_entry() //  [R1]
         { info_tbl: [(cdBMe,
                       label: sat_sdyIt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBMe: // global
           _sdyIt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdBMf; else goto cdBMg;
       cdBMg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBMi; else goto cdBMh;
       cdBMi: // global
           HpAlloc = 32;
           goto cdBMf;
       cdBMf: // global
           R1 = _sdyIt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBMh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyIt::P64;
           _sdyIo::P64 = P64[_sdyIt::P64 + 16];
           I64[Hp - 24] = w1_sdyIp_info;
           P64[Hp - 16] = _sdyIo::P64;
           I64[Hp - 8] = sat_sdyIs_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udBMp_srtd" {
     udBMp_srtd:
         const SdyRV_srt+304;
         const 44;
         const 9345848836097;
 },
 Data.Functor.Classes.$w$cliftReadList1_entry() //  [R2]
         { info_tbl: [(cdBMj,
                       label: Data.Functor.Classes.$w$cliftReadList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBMj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBMn; else goto cdBMm;
       cdBMn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBMm: // global
           I64[Hp - 16] = sat_sdyIt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.396957681 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdBMu,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBMu: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.397905284 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_closure" {
     Data.Functor.Classes.$fRead1Maybe_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Maybe1_closure+4;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.401882473 UTC

[section ""data" . Data.Functor.Classes.readsBinaryWith_closure" {
     Data.Functor.Classes.readsBinaryWith_closure:
         const Data.Functor.Classes.readsBinaryWith_info;
 },
 go1_sdyIM_entry() //  [R1, R2]
         { info_tbl: [(cdBN9,
                       label: go1_sdyIM_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBN9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBNa; else goto cdBNb;
       cdBNa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBNb: // global
           I64[Sp - 40] = block_cdBN2_info;
           _sdyIM::P64 = R1;
           _sdyIz::P64 = P64[R1 + 7];
           _sdyIJ::P64 = P64[R1 + 15];
           _sdyIL::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdyIz::P64;
           P64[Sp - 24] = _sdyIJ::P64;
           P64[Sp - 16] = _sdyIL::P64;
           P64[Sp - 8] = _sdyIM::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udBNv; else goto cdBN3;
       udBNv: // global
           call _cdBN2(R1) args: 0, res: 0, upd: 0;
       cdBN3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBN2() //  [R1]
         { info_tbl: [(cdBN2,
                       label: block_cdBN2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBN2: // global
           if (R1 & 7 == 1) goto cdBN6; else goto cdBN7;
       cdBN6: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdBN7: // global
           I64[Sp] = block_cdBNh_info;
           _sdyIQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdyIQ::P64;
           if (R1 & 7 != 0) goto udBNu; else goto cdBNi;
       udBNu: // global
           call _cdBNh(R1) args: 0, res: 0, upd: 0;
       cdBNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBNh() //  [R1]
         { info_tbl: [(cdBNh,
                       label: block_cdBNh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBNh: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdBNt; else goto cdBNs;
       cdBNt: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBNs: // global
           _sdyIS::P64 = P64[R1 + 7];
           _sdyIT::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyIS::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdyIT::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyID_entry() //  [R1, R2]
         { info_tbl: [(cdBNA,
                       label: go_sdyID_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBNA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBNB; else goto cdBNC;
       cdBNB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBNC: // global
           I64[Sp - 32] = block_cdBML_info;
           _sdyID::P64 = R1;
           _sdyIx::P64 = P64[R1 + 7];
           _sdyIz::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdyIx::P64;
           P64[Sp - 16] = _sdyIz::P64;
           P64[Sp - 8] = _sdyID::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udBNP; else goto cdBMM;
       udBNP: // global
           call _cdBML(R1) args: 0, res: 0, upd: 0;
       cdBMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBML() //  [R1]
         { info_tbl: [(cdBML,
                       label: block_cdBML_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBML: // global
           if (R1 & 7 == 1) goto cdBNx; else goto cdBNy;
       cdBNx: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBNy: // global
           I64[Sp - 8] = block_cdBMR_info;
           _sdyIH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyIH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udBNO; else goto cdBMS;
       udBNO: // global
           call _cdBMR(R1) args: 0, res: 0, upd: 0;
       cdBMS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBMR() //  [R1]
         { info_tbl: [(cdBMR,
                       label: block_cdBMR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBMR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBNJ; else goto cdBNI;
       cdBNJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBNI: // global
           _sdyIJ::P64 = P64[R1 + 7];
           _sdyIK::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyIM_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdyIJ::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 24] = block_cdBNF_info;
           R3 = _sdyIK::P64;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = Hp - 23;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBNF() //  [R1]
         { info_tbl: [(cdBNF,
                       label: block_cdBNF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBNF: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyIM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdBNU,
                       label: Data.Functor.Classes.readsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBNU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBNV; else goto cdBNW;
       cdBNV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBNW: // global
           I64[Sp - 32] = block_cdBMB_info;
           _sdyIx::P64 = R3;
           R3 = R4;
           _sdyIw::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdyIw::P64;
           P64[Sp - 16] = _sdyIx::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBMB() //  [R1]
         { info_tbl: [(cdBMB,
                       label: block_cdBMB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBMB: // global
           if (R1 & 7 == 1) goto cdBNR; else goto cdBNS;
       cdBNR: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBNS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBO2; else goto cdBO1;
       cdBO2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBO1: // global
           I64[Hp - 16] = go_sdyID_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdBNZ_info;
           R3 = P64[Sp + 32];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBNZ() //  [R1]
         { info_tbl: [(cdBNZ,
                       label: block_cdBNZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBNZ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyID_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.406583811 UTC

[section ""data" . Data.Functor.Classes.$wreadBinaryWith_closure" {
     Data.Functor.Classes.$wreadBinaryWith_closure:
         const Data.Functor.Classes.$wreadBinaryWith_info;
         const 0;
 },
 lvl3_sdyJ7_entry() //  [R1]
         { info_tbl: [(cdBOn,
                       label: lvl3_sdyJ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBOn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBOu; else goto cdBOv;
       cdBOu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBOv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdBOk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBOz; else goto cdBOl;
       udBOz: // global
           call _cdBOk(R1) args: 0, res: 0, upd: 0;
       cdBOl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdBOk() //  [R1]
         { info_tbl: [(cdBOk,
                       label: block_cdBOk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBOk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBOy; else goto cdBOx;
       cdBOy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdBOx: // global
           _sdyJa::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdyJa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJe_entry() //  [R1, R2]
         { info_tbl: [(cdBOL,
                       label: sat_sdyJe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBOL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBOP; else goto cdBOO;
       cdBOP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBOO: // global
           _sdyJ2::P64 = P64[R1 + 7];
           _sdyJ4::P64 = P64[R1 + 15];
           _sdyJb::P64 = P64[R1 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJb::P64;
           P64[Hp] = R2;
           R2 = Hp - 32;
           R1 = _sdyJ4::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJf_entry() //  [R1, R2]
         { info_tbl: [(cdBOQ,
                       label: sat_sdyJf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBOQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBOU; else goto cdBOT;
       cdBOU: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBOT: // global
           _sdyJ0::P64 = P64[R1 + 7];
           _sdyJ2::P64 = P64[R1 + 15];
           _sdyJ4::P64 = P64[R1 + 23];
           _sdyJ7::P64 = P64[R1 + 31];
           I64[Hp - 24] = sat_sdyJe_info;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJ4::P64;
           P64[Hp] = R2;
           R3 = Hp - 23;
           R2 = _sdyJ7::P64;
           R1 = _sdyJ0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJg_entry() //  [R1, R2]
         { info_tbl: [(cdBOV,
                       label: sat_sdyJg_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBOV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBOZ; else goto cdBOY;
       cdBOZ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBOY: // global
           _sdyIZ::P64 = P64[R1 + 7];
           _sdyJ0::P64 = P64[R1 + 15];
           _sdyJ2::P64 = P64[R1 + 23];
           _sdyJ3::P64 = P64[R1 + 31];
           _sdyJ4::P64 = P64[R1 + 39];
           I64[Hp - 56] = lvl3_sdyJ7_info;
           P64[Hp - 40] = _sdyJ3::P64;
           I64[Hp - 32] = sat_sdyJf_info;
           P64[Hp - 24] = _sdyJ0::P64;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJ4::P64;
           _cdBOg::P64 = Hp - 56;
           P64[Hp] = _cdBOg::P64;
           R3 = Hp - 31;
           R2 = _cdBOg::P64;
           R1 = _sdyIZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadBinaryWith_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdBP1,
                       label: Data.Functor.Classes.$wreadBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBP1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBP5; else goto cdBP4;
       cdBP5: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBP4: // global
           I64[Hp - 56] = sat_sdyJg_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R4;
           R3 = Hp - 55;
           R2 = Hp - 4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.409438579 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith1_closure" {
     Data.Functor.Classes.readBinaryWith1_closure:
         const Data.Functor.Classes.readBinaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith1_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdBPd,
                       label: Data.Functor.Classes.readBinaryWith1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBPd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdBPe; else goto cdBPf;
       cdBPe: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readBinaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBPf: // global
           _sdyJm::P64 = P64[Sp];
           I64[Sp] = block_cdBPa_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _sdyJm::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadBinaryWith_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _cdBPa() //  [R1]
         { info_tbl: [(cdBPa,
                       label: block_cdBPa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBPa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBPi; else goto cdBPh;
       cdBPi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBPh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.410758306 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith_closure" {
     Data.Functor.Classes.readBinaryWith_closure:
         const Data.Functor.Classes.readBinaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdBPn,
                       label: Data.Functor.Classes.readBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBPn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readBinaryWith1_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.412727795 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnaryWith_closure" {
     Data.Functor.Classes.$wshowsUnaryWith_closure:
         const Data.Functor.Classes.$wshowsUnaryWith_info;
 },
 Data.Functor.Classes.$wshowsUnaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBPr: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdyJt_entry() //  [R1]
         { info_tbl: [(cdBPz,
                       label: g_sdyJt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBPz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBPA; else goto cdBPB;
       cdBPA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBPB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJy_entry() //  [R1, R2]
         { info_tbl: [(cdBPM,
                       label: sat_sdyJy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBPM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBPQ; else goto cdBPP;
       cdBPQ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBPP: // global
           _sdyJq::P64 = P64[R1 + 7];
           _sdyJt::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyJq::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJB_entry() //  [R1]
         { info_tbl: [(cdBQ6,
                       label: sat_sdyJB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQ6: // global
           _sdyJB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBQ7; else goto cdBQ8;
       cdBQ8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBQa; else goto cdBQ9;
       cdBQa: // global
           HpAlloc = 24;
           goto cdBQ7;
       cdBQ7: // global
           R1 = _sdyJB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBQ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyJB::P64;
           _sdyJt::P64 = P64[_sdyJB::P64 + 16];
           _sdyJz::P64 = P64[_sdyJB::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyJz::P64;
           R2 = Hp - 14;
           R1 = _sdyJt::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJD_entry() //  [R1]
         { info_tbl: [(cdBQc,
                       label: sat_sdyJD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQc: // global
           _sdyJD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBQd; else goto cdBQe;
       cdBQe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBQg; else goto cdBQf;
       cdBQg: // global
           HpAlloc = 56;
           goto cdBQd;
       cdBQd: // global
           R1 = _sdyJD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBQf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyJD::P64;
           _sdyJq::P64 = P64[_sdyJD::P64 + 16];
           _sdyJt::P64 = P64[_sdyJD::P64 + 24];
           _sdyJz::P64 = P64[_sdyJD::P64 + 32];
           I64[Hp - 48] = sat_sdyJB_info;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = _sdyJz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyJq::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJE_entry() //  [R1, R2]
         { info_tbl: [(cdBQi,
                       label: sat_sdyJE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQi: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBQm; else goto cdBQl;
       cdBQm: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBQl: // global
           _sdyJq::P64 = P64[R1 + 7];
           _sdyJt::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyJD_info;
           P64[Hp - 40] = _sdyJq::P64;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdBQq,
                       label: Data.Functor.Classes.$wshowsUnaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBQu; else goto cdBQt;
       cdBQu: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnaryWith_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdBQt: // global
           I64[Hp - 48] = g_sdyJt_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdBPv::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdBQo; else goto cdBQp;
       cdBQo: // global
           I64[Hp - 16] = sat_sdyJy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdBPv::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBQp: // global
           I64[Hp - 16] = sat_sdyJE_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdBPv::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.415977817 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith_closure" {
     Data.Functor.Classes.showsUnaryWith_closure:
         const Data.Functor.Classes.showsUnaryWith_info;
 },
 Data.Functor.Classes.showsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdBQC,
                       label: Data.Functor.Classes.showsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBQD; else goto cdBQE;
       cdBQD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnaryWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBQE: // global
           I64[Sp - 32] = block_cdBQz_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udBQI; else goto cdBQA;
       udBQI: // global
           call _cdBQz(R1) args: 0, res: 0, upd: 0;
       cdBQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBQz() //  [R1]
         { info_tbl: [(cdBQz,
                       label: block_cdBQz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQz: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.417362469 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdBQQ,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBQR; else goto cdBQS;
       cdBQR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBQS: // global
           I64[Sp - 16] = block_cdBQN_info;
           R1 = R6;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udBQW; else goto cdBQO;
       udBQW: // global
           call _cdBQN(R1) args: 0, res: 0, upd: 0;
       cdBQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBQN() //  [R1]
         { info_tbl: [(cdBQN,
                       label: block_cdBQN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBQN: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.41886718 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_info;
         const 0;
 },
 sat_sdyK0_entry() //  [R1, R2]
         { info_tbl: [(cdBR6,
                       label: sat_sdyK0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBR6: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowList2_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdBR9,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBR9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBRd; else goto cdBRc;
       cdBRd: // global
           HpAlloc = 16;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBRc: // global
           I64[Hp - 8] = sat_sdyK0_info;
           P64[Hp] = R2;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.419996229 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_closure" {
     Data.Functor.Classes.$fShow2Const_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.421062593 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info;
         const 0;
 },
 sat_sdyK8_entry() //  [R1]
         { info_tbl: [(cdBRr,
                       label: sat_sdyK8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBRr: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdBRu,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBRu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBRv; else goto cdBRw;
       cdBRv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBRw: // global
           I64[Sp - 24] = block_cdBRi_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R6;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBRA; else goto cdBRj;
       udBRA: // global
           call _cdBRi(R1) args: 0, res: 0, upd: 0;
       cdBRj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBRi() //  [R1]
         { info_tbl: [(cdBRi,
                       label: block_cdBRi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBRi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBRz; else goto cdBRy;
       cdBRz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBRy: // global
           _sdyK7::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sdyK8_info;
           P64[Hp] = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = _sdyK7::I64;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.422921877 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_info;
         const 0;
 },
 lvl3_sdyKe_entry() //  [R1]
         { info_tbl: [(cdBRJ,
                       label: lvl3_sdyKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBRJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBRK; else goto cdBRL;
       cdBRK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBRL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyKg_entry() //  [R1, R2]
         { info_tbl: [(cdBRR,
                       label: sat_sdyKg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBRR: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowList_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdBRU,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBRU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBRY; else goto cdBRX;
       cdBRY: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBRX: // global
           I64[Hp - 32] = lvl3_sdyKe_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyKg_info;
           P64[Hp] = Hp - 32;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.424708812 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_closure" {
     Data.Functor.Classes.$fShow1Const_closure:
         const Data.Functor.Classes.$fShow1Const_info;
         const 0;
 },
 sat_sdyKj_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdBS8,
                       label: sat_sdyKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBS8: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowList_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyKi_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdBSg,
                       label: sat_sdyKi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBSg: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_entry() //  [R2]
         { info_tbl: [(cdBSk,
                       label: Data.Functor.Classes.$fShow1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBSk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBSo; else goto cdBSn;
       cdBSo: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBSn: // global
           I64[Hp - 48] = sat_sdyKj_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyKi_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.426620524 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cdBSA,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBSA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBSB; else goto cdBSC;
       cdBSB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBSC: // global
           I64[Sp - 24] = block_cdBSt_info;
           R1 = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBSX; else goto cdBSu;
       udBSX: // global
           call _cdBSt(R1) args: 0, res: 0, upd: 0;
       cdBSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBSt() //  [R1]
         { info_tbl: [(cdBSt,
                       label: block_cdBSt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBSt: // global
           _sdyKo::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdBSx; else goto cdBSy;
       cdBSx: // global
           I64[Sp + 8] = block_cdBSF_info;
           _sdyKr::P64 = P64[R1 + 7];
           R1 = _sdyKo::P64;
           P64[Sp + 16] = _sdyKr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udBSV; else goto cdBSH;
       udBSV: // global
           call _cdBSF(R1) args: 0, res: 0, upd: 0;
       cdBSH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdBSy: // global
           I64[Sp] = block_cdBSO_info;
           _sdyKu::P64 = P64[R1 + 6];
           R1 = _sdyKo::P64;
           P64[Sp + 24] = _sdyKu::P64;
           if (R1 & 7 != 0) goto udBSW; else goto cdBSQ;
       udBSW: // global
           call _cdBSO(R1) args: 0, res: 0, upd: 0;
       cdBSQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBSF() //  [R1]
         { info_tbl: [(cdBSF,
                       label: block_cdBSF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBSF: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 _cdBSO() //  [R1]
         { info_tbl: [(cdBSO,
                       label: block_cdBSO_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBSO: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.428875474 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList4_closure" {
     Data.Functor.Classes.$w$cliftShowList4_closure:
         const Data.Functor.Classes.$w$cliftShowList4_info;
         const 0;
 },
 sat_sdyKF_entry() //  [R1, R2]
         { info_tbl: [(cdBTe,
                       label: sat_sdyKF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBTf; else goto cdBTg;
       cdBTf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBTg: // global
           I64[Sp - 24] = block_cdBT7_info;
           _sdyKx::P64 = P64[R1 + 7];
           _sdyKy::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyKx::P64;
           P64[Sp - 8] = _sdyKy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBTn; else goto cdBT8;
       udBTn: // global
           call _cdBT7(R1) args: 0, res: 0, upd: 0;
       cdBT8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBT7() //  [R1]
         { info_tbl: [(cdBT7,
                       label: block_cdBT7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBT7: // global
           if (R1 & 7 == 1) goto cdBTb; else goto cdBTc;
       cdBTb: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdBTc: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdBTo,
                       label: Data.Functor.Classes.$w$cliftShowList4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBTs; else goto cdBTr;
       cdBTs: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBTr: // global
           I64[Hp - 16] = sat_sdyKF_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyKz::P64 = R4;
           R4 = R5;
           R3 = _sdyKz::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.430606033 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowList2_entry() //  [R2,
                                                                 R4, R6]
         { info_tbl: [(cdBTx,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTx: // global
           R5 = P64[Sp];
           _sdyKI::P64 = R4;
           R4 = R6;
           R3 = _sdyKI::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList4_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.431445667 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_closure" {
     Data.Functor.Classes.$fShow2Either_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.432659854 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTB: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyKS_entry() //  [R1]
         { info_tbl: [(cdBTO,
                       label: sat_sdyKS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTO: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdBTV,
                       label: Data.Functor.Classes.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBTW; else goto cdBTX;
       cdBTW: // global
           R1 = Data.Functor.Classes.$w$cliftShowsPrec_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdBTX: // global
           I64[Sp - 32] = block_cdBTF_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udBU4; else goto cdBTG;
       udBU4: // global
           call _cdBTF(R1) args: 0, res: 0, upd: 0;
       cdBTG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBTF() //  [R1]
         { info_tbl: [(cdBTF,
                       label: block_cdBTF_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBTF: // global
           _sdyKO::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cdBTS; else goto cdBTT;
       cdBTS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBU0; else goto cdBTZ;
       cdBU0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBTZ: // global
           _sdyKR::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sdyKS_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdyKR::P64;
           R4 = _sdyKO::I64;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = Hp - 16;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdBTT: // global
           R5 = P64[R1 + 6];
           R4 = _sdyKO::I64;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.434670105 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdBUc,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBUc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBUd; else goto cdBUe;
       cdBUd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBUe: // global
           I64[Sp - 32] = block_cdBU9_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udBUi; else goto cdBUa;
       udBUi: // global
           call _cdBU9(R1) args: 0, res: 0, upd: 0;
       cdBUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBU9() //  [R1]
         { info_tbl: [(cdBU9,
                       label: block_cdBU9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBU9: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.436447178 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList1_closure" {
     Data.Functor.Classes.$w$cliftShowList1_closure:
         const Data.Functor.Classes.$w$cliftShowList1_info;
         const 0;
 },
 lvl3_sdyL5_entry() //  [R1]
         { info_tbl: [(cdBUr,
                       label: lvl3_sdyL5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBUr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBUs; else goto cdBUt;
       cdBUs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBUt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyLa_entry() //  [R1, R2]
         { info_tbl: [(cdBUG,
                       label: sat_sdyLa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBUG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBUH; else goto cdBUI;
       cdBUH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBUI: // global
           I64[Sp - 24] = block_cdBUz_info;
           _sdyL2::P64 = P64[R1 + 7];
           _sdyL5::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyL2::P64;
           P64[Sp - 8] = _sdyL5::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBUP; else goto cdBUA;
       udBUP: // global
           call _cdBUz(R1) args: 0, res: 0, upd: 0;
       cdBUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBUz() //  [R1]
         { info_tbl: [(cdBUz,
                       label: block_cdBUz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBUz: // global
           if (R1 & 7 == 1) goto cdBUD; else goto cdBUE;
       cdBUD: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdBUE: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdBUQ,
                       label: Data.Functor.Classes.$w$cliftShowList1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBUQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdBUU; else goto cdBUT;
       cdBUU: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBUT: // global
           I64[Hp - 40] = lvl3_sdyL5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyLa_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdyL3::P64 = R4;
           R4 = R5;
           R3 = _sdyL3::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.43863914 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowList_entry() //  [R2,
                                                                R3, R5, R6]
         { info_tbl: [(cdBUZ,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBUZ: // global
           _sdyLe::P64 = R5;
           R5 = R6;
           R4 = _sdyLe::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.439828427 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_closure" {
     Data.Functor.Classes.$fShow1Either_closure:
         const Data.Functor.Classes.$fShow1Either_info;
         const 0;
 },
 sat_sdyLm_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdBVb,
                       label: sat_sdyLm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVb: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyLh_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdBVj,
                       label: sat_sdyLh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVj: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Either_entry() //  [R2]
         { info_tbl: [(cdBVn,
                       label: Data.Functor.Classes.$fShow1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBVr; else goto cdBVq;
       cdBVr: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBVq: // global
           I64[Hp - 48] = sat_sdyLm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyLh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.441421656 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdBVz,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBVA; else goto cdBVB;
       cdBVA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBVB: // global
           I64[Sp - 24] = block_cdBVw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBVF; else goto cdBVx;
       udBVF: // global
           call _cdBVw(R1) args: 0, res: 0, upd: 0;
       cdBVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBVw() //  [R1]
         { info_tbl: [(cdBVw,
                       label: block_cdBVw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVw: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.44289689 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_info;
         const 0;
 },
 sat_sdyLy_entry() //  [R1, R2]
         { info_tbl: [(cdBVP,
                       label: sat_sdyLy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVP: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdBVS,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBVS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBVW; else goto cdBVV;
       cdBVW: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBVV: // global
           I64[Hp - 8] = sat_sdyLy_info;
           P64[Hp] = R2;
           _sdyLv::P64 = R4;
           R4 = R5;
           R3 = _sdyLv::P64;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.444026779 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_closure" {
     Data.Functor.Classes.$fShow1Identity_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.444797646 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe1_closure" {
     Data.Functor.Classes.$fShow1Maybe1_closure:
         const Data.Functor.Classes.$fShow1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe1_entry() //  [R2]
         { info_tbl: [(cdBW1,
                       label: Data.Functor.Classes.$fShow1Maybe1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBW1: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Maybe6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.446013056 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdBWf,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBWf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBWg; else goto cdBWh;
       cdBWg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBWh: // global
           I64[Sp - 24] = block_cdBW8_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBWv; else goto cdBW9;
       udBWv: // global
           call _cdBW8(R1) args: 0, res: 0, upd: 0;
       cdBW9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBW8() //  [R1]
         { info_tbl: [(cdBW8,
                       label: block_cdBW8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBW8: // global
           if (R1 & 7 == 1) goto cdBWc; else goto cdBWd;
       cdBWc: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBWd: // global
           I64[Sp] = block_cdBWn_info;
           _sdyLE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdyLE::P64;
           if (R1 & 7 != 0) goto udBWu; else goto cdBWp;
       udBWu: // global
           call _cdBWn(R1) args: 0, res: 0, upd: 0;
       cdBWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBWn() //  [R1]
         { info_tbl: [(cdBWn,
                       label: block_cdBWn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBWn: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.447938472 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList2_closure" {
     Data.Functor.Classes.$w$cliftShowList2_closure:
         const Data.Functor.Classes.$w$cliftShowList2_info;
         const 0;
 },
 sat_sdyLN_entry() //  [R1, R2]
         { info_tbl: [(cdBWM,
                       label: sat_sdyLN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBWM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBWN; else goto cdBWO;
       cdBWN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBWO: // global
           I64[Sp - 16] = block_cdBWF_info;
           _sdyLH::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdyLH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udBWV; else goto cdBWG;
       udBWV: // global
           call _cdBWF(R1) args: 0, res: 0, upd: 0;
       cdBWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBWF() //  [R1]
         { info_tbl: [(cdBWF,
                       label: block_cdBWF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBWF: // global
           if (R1 & 7 == 1) goto cdBWJ; else goto cdBWK;
       cdBWJ: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBWK: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBWW,
                       label: Data.Functor.Classes.$w$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBWW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBX0; else goto cdBWZ;
       cdBX0: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBWZ: // global
           I64[Hp - 8] = sat_sdyLN_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.449599191 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowList_entry() //  [R2,
                                                               R4, R5]
         { info_tbl: [(cdBX5,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBX5: // global
           _sdyLQ::P64 = R4;
           R4 = R5;
           R3 = _sdyLQ::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.452331609 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_closure" {
     Data.Functor.Classes.$fShow1Maybe_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.454639441 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinaryWith_closure" {
     Data.Functor.Classes.$wshowsBinaryWith_closure:
         const Data.Functor.Classes.$wshowsBinaryWith_info;
 },
 Data.Functor.Classes.$wshowsBinaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBX9: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 f_sdyLY_entry() //  [R1]
         { info_tbl: [(cdBXh,
                       label: f_sdyLY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBXi; else goto cdBXj;
       cdBXi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBXj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sdyLZ_entry() //  [R1]
         { info_tbl: [(cdBXo,
                       label: g_sdyLZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdBXp; else goto cdBXq;
       cdBXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyM4_entry() //  [R1]
         { info_tbl: [(cdBXF,
                       label: sat_sdyM4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBXF: // global
           _sdyM4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBXG; else goto cdBXH;
       cdBXH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBXJ; else goto cdBXI;
       cdBXJ: // global
           HpAlloc = 56;
           goto cdBXG;
       cdBXG: // global
           R1 = _sdyM4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBXI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyM4::P64;
           _sdyLY::P64 = P64[_sdyM4::P64 + 16];
           _sdyLZ::P64 = P64[_sdyM4::P64 + 24];
           _sdyM1::P64 = P64[_sdyM4::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM1::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyLY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyM6_entry() //  [R1, R2]
         { info_tbl: [(cdBXL,
                       label: sat_sdyM6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBXL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBXP; else goto cdBXO;
       cdBXP: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBXO: // global
           _sdyLU::P64 = P64[R1 + 7];
           _sdyLY::P64 = P64[R1 + 15];
           _sdyLZ::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdyM4_info;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyLU::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyM9_entry() //  [R1]
         { info_tbl: [(cdBY9,
                       label: sat_sdyM9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBY9: // global
           _sdyM9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBYa; else goto cdBYb;
       cdBYb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdBYd; else goto cdBYc;
       cdBYd: // global
           HpAlloc = 24;
           goto cdBYa;
       cdBYa: // global
           R1 = _sdyM9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBYc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyM9::P64;
           _sdyLZ::P64 = P64[_sdyM9::P64 + 16];
           _sdyM7::P64 = P64[_sdyM9::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyM7::P64;
           R2 = Hp - 14;
           R1 = _sdyLZ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMb_entry() //  [R1]
         { info_tbl: [(cdBYf,
                       label: sat_sdyMb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYf: // global
           _sdyMb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBYg; else goto cdBYh;
       cdBYh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdBYj; else goto cdBYi;
       cdBYj: // global
           HpAlloc = 56;
           goto cdBYg;
       cdBYg: // global
           R1 = _sdyMb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMb::P64;
           _sdyLY::P64 = P64[_sdyMb::P64 + 16];
           _sdyLZ::P64 = P64[_sdyMb::P64 + 24];
           _sdyM7::P64 = P64[_sdyMb::P64 + 32];
           I64[Hp - 48] = sat_sdyM9_info;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyLY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMd_entry() //  [R1]
         { info_tbl: [(cdBYl,
                       label: sat_sdyMd_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYl: // global
           _sdyMd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBYm; else goto cdBYn;
       cdBYn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdBYp; else goto cdBYo;
       cdBYp: // global
           HpAlloc = 64;
           goto cdBYm;
       cdBYm: // global
           R1 = _sdyMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdBYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMd::P64;
           _sdyLU::P64 = P64[_sdyMd::P64 + 16];
           _sdyLY::P64 = P64[_sdyMd::P64 + 24];
           _sdyLZ::P64 = P64[_sdyMd::P64 + 32];
           _sdyM7::P64 = P64[_sdyMd::P64 + 40];
           I64[Hp - 56] = sat_sdyMb_info;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyLU::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMe_entry() //  [R1, R2]
         { info_tbl: [(cdBYr,
                       label: sat_sdyMe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdBYv; else goto cdBYu;
       cdBYv: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBYu: // global
           _sdyLU::P64 = P64[R1 + 7];
           _sdyLY::P64 = P64[R1 + 15];
           _sdyLZ::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdyMd_info;
           P64[Hp - 48] = _sdyLU::P64;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdBYz,
                       label: Data.Functor.Classes.$wshowsBinaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdBYD; else goto cdBYC;
       cdBYD: // global
           HpAlloc = 96;
           R1 = Data.Functor.Classes.$wshowsBinaryWith_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cdBYC: // global
           I64[Hp - 88] = f_sdyLY_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R6;
           I64[Hp - 56] = g_sdyLZ_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = P64[Sp];
           _cdBXd::P64 = Hp - 88;
           _cdBXk::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdBYx; else goto cdBYy;
       cdBYx: // global
           I64[Hp - 24] = sat_sdyM6_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdBXd::P64;
           P64[Hp] = _cdBXk::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBYy: // global
           I64[Hp - 24] = sat_sdyMe_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdBXd::P64;
           P64[Hp] = _cdBXk::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.45896758 UTC

[section ""data" . Data.Functor.Classes.showsBinaryWith_closure" {
     Data.Functor.Classes.showsBinaryWith_closure:
         const Data.Functor.Classes.showsBinaryWith_info;
 },
 Data.Functor.Classes.showsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdBYL,
                       label: Data.Functor.Classes.showsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBYM; else goto cdBYN;
       cdBYM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdBYN: // global
           I64[Sp - 40] = block_cdBYI_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udBYR; else goto cdBYJ;
       udBYR: // global
           call _cdBYI(R1) args: 0, res: 0, upd: 0;
       cdBYJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBYI() //  [R1]
         { info_tbl: [(cdBYI,
                       label: block_cdBYI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYI: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.460983683 UTC

[section ""data" . Data.Functor.Classes.readsUnary_closure" {
     Data.Functor.Classes.readsUnary_closure:
         const Data.Functor.Classes.readsUnary_info;
 },
 go_sdyMt_entry() //  [R1, R2]
         { info_tbl: [(cdBZd,
                       label: go_sdyMt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBZd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdBZe; else goto cdBZf;
       cdBZe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBZf: // global
           I64[Sp - 24] = block_cdBZ6_info;
           _sdyMt::P64 = R1;
           _sdyMp::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyMp::P64;
           P64[Sp - 8] = _sdyMt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udBZz; else goto cdBZ7;
       udBZz: // global
           call _cdBZ6(R1) args: 0, res: 0, upd: 0;
       cdBZ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBZ6() //  [R1]
         { info_tbl: [(cdBZ6,
                       label: block_cdBZ6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBZ6: // global
           if (R1 & 7 == 1) goto cdBZa; else goto cdBZb;
       cdBZa: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBZb: // global
           I64[Sp - 8] = block_cdBZl_info;
           _sdyMx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyMx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udBZy; else goto cdBZm;
       udBZy: // global
           call _cdBZl(R1) args: 0, res: 0, upd: 0;
       cdBZm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBZl() //  [R1]
         { info_tbl: [(cdBZl,
                       label: block_cdBZl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBZl: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdBZx; else goto cdBZw;
       cdBZx: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBZw: // global
           _sdyMz::P64 = P64[R1 + 7];
           _sdyMA::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyMz::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyMA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnary_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdBZE,
                       label: Data.Functor.Classes.readsUnary_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBZE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdBZF; else goto cdBZG;
       cdBZF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBZG: // global
           I64[Sp - 32] = block_cdBYW_info;
           R3 = R3;
           _sdyMn::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdyMn::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdBYW() //  [R1]
         { info_tbl: [(cdBYW,
                       label: block_cdBYW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBYW: // global
           if (R1 & 7 == 1) goto cdBZB; else goto cdBZC;
       cdBZB: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdBZC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdBZM; else goto cdBZL;
       cdBZM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBZL: // global
           I64[Hp - 8] = go_sdyMt_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdBZJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdBZJ() //  [R1]
         { info_tbl: [(cdBZJ,
                       label: block_cdBZJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBZJ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyMt_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.464867533 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary_closure" {
     Data.Functor.Classes.$wshowsUnary_closure:
         const Data.Functor.Classes.$wshowsUnary_info;
 },
 Data.Functor.Classes.$wshowsUnary_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBZS: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdyMJ_entry() //  [R1]
         { info_tbl: [(cdC00,
                       label: g_sdyMJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC00: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdC01; else goto cdC02;
       cdC01: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdC02: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyMO_entry() //  [R1, R2]
         { info_tbl: [(cdC0d,
                       label: sat_sdyMO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC0d: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdC0h; else goto cdC0g;
       cdC0h: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC0g: // global
           _sdyMG::P64 = P64[R1 + 7];
           _sdyMJ::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyMG::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyMR_entry() //  [R1]
         { info_tbl: [(cdC0x,
                       label: sat_sdyMR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC0x: // global
           _sdyMR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdC0y; else goto cdC0z;
       cdC0z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdC0B; else goto cdC0A;
       cdC0B: // global
           HpAlloc = 24;
           goto cdC0y;
       cdC0y: // global
           R1 = _sdyMR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdC0A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMR::P64;
           _sdyMJ::P64 = P64[_sdyMR::P64 + 16];
           _sdyMP::P64 = P64[_sdyMR::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyMP::P64;
           R2 = Hp - 14;
           R1 = _sdyMJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMT_entry() //  [R1]
         { info_tbl: [(cdC0D,
                       label: sat_sdyMT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC0D: // global
           _sdyMT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdC0E; else goto cdC0F;
       cdC0F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdC0H; else goto cdC0G;
       cdC0H: // global
           HpAlloc = 56;
           goto cdC0E;
       cdC0E: // global
           R1 = _sdyMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdC0G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMT::P64;
           _sdyMG::P64 = P64[_sdyMT::P64 + 16];
           _sdyMJ::P64 = P64[_sdyMT::P64 + 24];
           _sdyMP::P64 = P64[_sdyMT::P64 + 32];
           I64[Hp - 48] = sat_sdyMR_info;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = _sdyMP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyMG::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMU_entry() //  [R1, R2]
         { info_tbl: [(cdC0J,
                       label: sat_sdyMU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC0J: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdC0N; else goto cdC0M;
       cdC0N: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC0M: // global
           _sdyMG::P64 = P64[R1 + 7];
           _sdyMJ::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyMT_info;
           P64[Hp - 40] = _sdyMG::P64;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdC0R,
                       label: Data.Functor.Classes.$wshowsUnary_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC0R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdC0V; else goto cdC0U;
       cdC0V: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnary_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdC0U: // global
           I64[Hp - 48] = g_sdyMJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdBZW::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdC0P; else goto cdC0Q;
       cdC0P: // global
           I64[Hp - 16] = sat_sdyMO_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdBZW::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdC0Q: // global
           I64[Hp - 16] = sat_sdyMU_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdBZW::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.468037973 UTC

[section ""data" . Data.Functor.Classes.showsUnary_closure" {
     Data.Functor.Classes.showsUnary_closure:
         const Data.Functor.Classes.showsUnary_info;
 },
 Data.Functor.Classes.showsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdC13,
                       label: Data.Functor.Classes.showsUnary_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC13: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdC14; else goto cdC15;
       cdC14: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC15: // global
           I64[Sp - 32] = block_cdC10_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udC19; else goto cdC11;
       udC19: // global
           call _cdC10(R1) args: 0, res: 0, upd: 0;
       cdC11: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC10() //  [R1]
         { info_tbl: [(cdC10,
                       label: block_cdC10_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC10: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.469144423 UTC

[section ""cstring" . Data.Functor.Classes.$trModule4_bytes" {
     Data.Functor.Classes.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.46977478 UTC

[section ""data" . Data.Functor.Classes.$trModule3_closure" {
     Data.Functor.Classes.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.470344117 UTC

[section ""cstring" . Data.Functor.Classes.$trModule2_bytes" {
     Data.Functor.Classes.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.470909126 UTC

[section ""data" . Data.Functor.Classes.$trModule1_closure" {
     Data.Functor.Classes.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.471485626 UTC

[section ""data" . Data.Functor.Classes.$trModule_closure" {
     Data.Functor.Classes.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Classes.$trModule3_closure+1;
         const Data.Functor.Classes.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.472119993 UTC

[section ""data" . $krep_rdymB_closure" {
     $krep_rdymB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.472726528 UTC

[section ""data" . Data.Functor.Classes.$tcEq4_closure" {
     Data.Functor.Classes.$tcEq4_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.473458043 UTC

[section ""data" . Data.Functor.Classes.$tcEq7_closure" {
     Data.Functor.Classes.$tcEq7_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.47405123 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq6_bytes" {
     Data.Functor.Classes.$tcEq6_bytes:
         I8[] [69,113,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.474640539 UTC

[section ""data" . Data.Functor.Classes.$tcEq5_closure" {
     Data.Functor.Classes.$tcEq5_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.475248286 UTC

[section ""data" . Data.Functor.Classes.$tcEq1_closure" {
     Data.Functor.Classes.$tcEq1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq5_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 71749974434880567;
         const 7233443027070644957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.475825141 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd5_bytes" {
     Data.Functor.Classes.$tcOrd5_bytes:
         I8[] [79,114,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.476417221 UTC

[section ""data" . Data.Functor.Classes.$tcOrd4_closure" {
     Data.Functor.Classes.$tcOrd4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.477010813 UTC

[section ""data" . Data.Functor.Classes.$tcOrd1_closure" {
     Data.Functor.Classes.$tcOrd1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 11825914698899667233;
         const 4554948325937498991;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.477675984 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead5_bytes" {
     Data.Functor.Classes.$tcRead5_bytes:
         I8[] [82,101,97,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.478214152 UTC

[section ""data" . Data.Functor.Classes.$tcRead4_closure" {
     Data.Functor.Classes.$tcRead4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.478795223 UTC

[section ""data" . Data.Functor.Classes.$tcRead1_closure" {
     Data.Functor.Classes.$tcRead1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 14547308444716217043;
         const 925634574698086715;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.479435936 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow5_bytes" {
     Data.Functor.Classes.$tcShow5_bytes:
         I8[] [83,104,111,119,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.479984294 UTC

[section ""data" . Data.Functor.Classes.$tcShow4_closure" {
     Data.Functor.Classes.$tcShow4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.480571093 UTC

[section ""data" . Data.Functor.Classes.$tcShow1_closure" {
     Data.Functor.Classes.$tcShow1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 4743290066722511112;
         const 6779909240154408836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.481218338 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq9_bytes" {
     Data.Functor.Classes.$tcEq9_bytes:
         I8[] [69,113,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.481780291 UTC

[section ""data" . Data.Functor.Classes.$tcEq8_closure" {
     Data.Functor.Classes.$tcEq8_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.48236897 UTC

[section ""data" . Data.Functor.Classes.$tcEq2_closure" {
     Data.Functor.Classes.$tcEq2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq8_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 16920549266159426738;
         const 13264288076834164909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.482994397 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd7_bytes" {
     Data.Functor.Classes.$tcOrd7_bytes:
         I8[] [79,114,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.483580747 UTC

[section ""data" . Data.Functor.Classes.$tcOrd6_closure" {
     Data.Functor.Classes.$tcOrd6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.484137724 UTC

[section ""data" . Data.Functor.Classes.$tcOrd2_closure" {
     Data.Functor.Classes.$tcOrd2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 4167316048525678806;
         const 17649124474771181823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.484745301 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead7_bytes" {
     Data.Functor.Classes.$tcRead7_bytes:
         I8[] [82,101,97,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.485550605 UTC

[section ""data" . Data.Functor.Classes.$tcRead6_closure" {
     Data.Functor.Classes.$tcRead6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.486118978 UTC

[section ""data" . Data.Functor.Classes.$tcRead2_closure" {
     Data.Functor.Classes.$tcRead2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 615267248700376470;
         const 8978126042197021701;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.48671597 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow7_bytes" {
     Data.Functor.Classes.$tcShow7_bytes:
         I8[] [83,104,111,119,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.487267683 UTC

[section ""data" . Data.Functor.Classes.$tcShow6_closure" {
     Data.Functor.Classes.$tcShow6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.487848413 UTC

[section ""data" . Data.Functor.Classes.$tcShow2_closure" {
     Data.Functor.Classes.$tcShow2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 11321900378419812635;
         const 1323607160578303441;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.488795786 UTC

[section ""data" . Data.Functor.Classes.C:Show2_closure" {
     Data.Functor.Classes.C:Show2_closure:
         const Data.Functor.Classes.C:Show2_info;
 },
 Data.Functor.Classes.C:Show2_entry() //  [R2, R3]
         { info_tbl: [(cdC1f,
                       label: Data.Functor.Classes.C:Show2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC1f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdC1j; else goto cdC1i;
       cdC1j: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC1i: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.490010872 UTC

[section ""data" . Data.Functor.Classes.C:Read2_closure" {
     Data.Functor.Classes.C:Read2_closure:
         const Data.Functor.Classes.C:Read2_info;
 },
 Data.Functor.Classes.C:Read2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdC1p,
                       label: Data.Functor.Classes.C:Read2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC1p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdC1t; else goto cdC1s;
       cdC1t: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC1s: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read2_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.491146193 UTC

[section ""data" . Data.Functor.Classes.C:Ord2_closure" {
     Data.Functor.Classes.C:Ord2_closure:
         const Data.Functor.Classes.C:Ord2_info;
 },
 Data.Functor.Classes.C:Ord2_entry() //  [R2, R3]
         { info_tbl: [(cdC1z,
                       label: Data.Functor.Classes.C:Ord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC1z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdC1D; else goto cdC1C;
       cdC1D: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC1C: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.492264287 UTC

[section ""data" . Data.Functor.Classes.C:Show1_closure" {
     Data.Functor.Classes.C:Show1_closure:
         const Data.Functor.Classes.C:Show1_info;
 },
 Data.Functor.Classes.C:Show1_entry() //  [R2, R3]
         { info_tbl: [(cdC1J,
                       label: Data.Functor.Classes.C:Show1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC1J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdC1N; else goto cdC1M;
       cdC1N: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC1M: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.495036949 UTC

[section ""data" . Data.Functor.Classes.C:Read1_closure" {
     Data.Functor.Classes.C:Read1_closure:
         const Data.Functor.Classes.C:Read1_info;
 },
 Data.Functor.Classes.C:Read1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdC1T,
                       label: Data.Functor.Classes.C:Read1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC1T: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdC1X; else goto cdC1W;
       cdC1X: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC1W: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.496137297 UTC

[section ""data" . Data.Functor.Classes.C:Ord1_closure" {
     Data.Functor.Classes.C:Ord1_closure:
         const Data.Functor.Classes.C:Ord1_info;
 },
 Data.Functor.Classes.C:Ord1_entry() //  [R2, R3]
         { info_tbl: [(cdC23,
                       label: Data.Functor.Classes.C:Ord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC23: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdC27; else goto cdC26;
       cdC27: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC26: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.497016112 UTC

[Data.Functor.Classes.C:Show2_con_entry() //  [R1]
         { info_tbl: [(cdC28,
                       label: Data.Functor.Classes.C:Show2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC28: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.498192436 UTC

[Data.Functor.Classes.C:Read2_con_entry() //  [R1]
         { info_tbl: [(cdC2a,
                       label: Data.Functor.Classes.C:Read2_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2a: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.498879843 UTC

[Data.Functor.Classes.C:Ord2_con_entry() //  [R1]
         { info_tbl: [(cdC2c,
                       label: Data.Functor.Classes.C:Ord2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2c: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.499616855 UTC

[Data.Functor.Classes.C:Show1_con_entry() //  [R1]
         { info_tbl: [(cdC2e,
                       label: Data.Functor.Classes.C:Show1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2e: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.500300422 UTC

[Data.Functor.Classes.C:Read1_con_entry() //  [R1]
         { info_tbl: [(cdC2g,
                       label: Data.Functor.Classes.C:Read1_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2g: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.501004572 UTC

[Data.Functor.Classes.C:Ord1_con_entry() //  [R1]
         { info_tbl: [(cdC2i,
                       label: Data.Functor.Classes.C:Ord1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2i: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.501705995 UTC

[section ""relreadonly" . SdyRV_srt" {
     SdyRV_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.$fRead1Const2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec7_closure;
         const Data.Functor.Classes.$fRead1Either1_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$fRead1Either4_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec8_closure;
         const Data.Functor.Classes.$fRead1NonEmpty3_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec5_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1Proxy2_closure;
         const Data.Functor.Classes.$fRead1Proxy_lexeme_closure;
         const Data.Functor.Classes.$fRead1Proxy1_closure;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const Data.Functor.Classes.$fShow1Proxy2_closure;
         const Data.Functor.Classes.$fRead1(,)3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec6_closure;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$dmliftReadList2_closure;
         const Data.Functor.Classes.$fShow1Proxy1_closure;
         const Data.Functor.Classes.$dmliftReadList_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec2_closure;
         const Data.Functor.Classes.liftReadListPrecDefault_closure;
         const lvl_rdymy_closure;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
         const lvl1_rdymz_closure;
         const lvl2_rdymA_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$w$cliftReadList2_closure;
         const Data.Functor.Classes.$fRead2Either_closure;
         const Data.Functor.Classes.$fRead2Const_closure;
         const Data.Functor.Classes.$fRead2(,)_closure;
         const Data.Functor.Classes.liftReadListPrec2Default_closure;
         const Data.Functor.Classes.$fRead1(,)1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1(,)_closure;
         const GHC.Read.lex1_closure;
         const Data.Functor.Classes.$wreadsData_closure;
         const Data.Functor.Classes.readsData_closure;
         const Data.Functor.Classes.readData1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$wreadUnaryWith_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.readUnaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const5_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Const_closure;
         const Data.Functor.Classes.$fRead1Either7_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec1_closure;
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Either_closure;
         const Data.Functor.Classes.$fRead1Identity2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec3_closure;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Maybe5_closure;
         const Data.Functor.Classes.$fRead1Maybe_lexeme_closure;
         const Data.Functor.Classes.$fRead1Maybe2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec4_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec4_closure;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList1_closure;
         const Data.Functor.Classes.$wreadBinaryWith_closure;
         const Data.Functor.Classes.readBinaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
         const Data.Functor.Classes.$fShow1Const_closure;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$w$cliftShowList4_closure;
         const Data.Functor.Classes.$w$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList1_closure;
         const Data.Functor.Classes.$fShow1Either_closure;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const Data.Functor.Classes.$fShow1Maybe1_closure;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.503149306 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:44.504557904 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec2_closure" {
     Data.Functor.Classes.liftShowsPrec2_closure:
         const Data.Functor.Classes.liftShowsPrec2_info;
 },
 Data.Functor.Classes.liftShowsPrec2_entry() //  [R2]
         { info_tbl: [(cdC2r,
                       label: Data.Functor.Classes.liftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC2s; else goto cdC2t;
       cdC2s: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC2t: // global
           I64[Sp - 8] = block_cdC2o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC2x; else goto cdC2p;
       udC2x: // global
           call _cdC2o(R1) args: 0, res: 0, upd: 0;
       cdC2p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC2o() //  [R1]
         { info_tbl: [(cdC2o,
                       label: block_cdC2o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2o: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.510179812 UTC

[section ""data" . Data.Functor.Classes.liftShowList2_closure" {
     Data.Functor.Classes.liftShowList2_closure:
         const Data.Functor.Classes.liftShowList2_info;
 },
 Data.Functor.Classes.liftShowList2_entry() //  [R2]
         { info_tbl: [(cdC2O,
                       label: Data.Functor.Classes.liftShowList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC2P; else goto cdC2Q;
       cdC2P: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC2Q: // global
           I64[Sp - 8] = block_cdC2L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC2U; else goto cdC2M;
       udC2U: // global
           call _cdC2L(R1) args: 0, res: 0, upd: 0;
       cdC2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC2L() //  [R1]
         { info_tbl: [(cdC2L,
                       label: block_cdC2L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC2L: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.515701802 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec2_closure" {
     Data.Functor.Classes.liftReadsPrec2_closure:
         const Data.Functor.Classes.liftReadsPrec2_info;
 },
 Data.Functor.Classes.liftReadsPrec2_entry() //  [R2]
         { info_tbl: [(cdC3b,
                       label: Data.Functor.Classes.liftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC3b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC3c; else goto cdC3d;
       cdC3c: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC3d: // global
           I64[Sp - 8] = block_cdC38_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC3h; else goto cdC39;
       udC3h: // global
           call _cdC38(R1) args: 0, res: 0, upd: 0;
       cdC39: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC38() //  [R1]
         { info_tbl: [(cdC38,
                       label: block_cdC38_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC38: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.521265489 UTC

[section ""data" . Data.Functor.Classes.liftReadList2_closure" {
     Data.Functor.Classes.liftReadList2_closure:
         const Data.Functor.Classes.liftReadList2_info;
 },
 Data.Functor.Classes.liftReadList2_entry() //  [R2]
         { info_tbl: [(cdC3y,
                       label: Data.Functor.Classes.liftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC3y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC3z; else goto cdC3A;
       cdC3z: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC3A: // global
           I64[Sp - 8] = block_cdC3v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC3E; else goto cdC3w;
       udC3E: // global
           call _cdC3v(R1) args: 0, res: 0, upd: 0;
       cdC3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC3v() //  [R1]
         { info_tbl: [(cdC3v,
                       label: block_cdC3v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC3v: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.526885161 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec2_closure" {
     Data.Functor.Classes.liftReadPrec2_closure:
         const Data.Functor.Classes.liftReadPrec2_info;
 },
 Data.Functor.Classes.liftReadPrec2_entry() //  [R2]
         { info_tbl: [(cdC3V,
                       label: Data.Functor.Classes.liftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC3V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC3W; else goto cdC3X;
       cdC3W: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC3X: // global
           I64[Sp - 8] = block_cdC3S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC41; else goto cdC3T;
       udC41: // global
           call _cdC3S(R1) args: 0, res: 0, upd: 0;
       cdC3T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC3S() //  [R1]
         { info_tbl: [(cdC3S,
                       label: block_cdC3S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC3S: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.534176605 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2_closure" {
     Data.Functor.Classes.liftReadListPrec2_closure:
         const Data.Functor.Classes.liftReadListPrec2_info;
 },
 Data.Functor.Classes.liftReadListPrec2_entry() //  [R2]
         { info_tbl: [(cdC4i,
                       label: Data.Functor.Classes.liftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC4i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC4j; else goto cdC4k;
       cdC4j: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC4k: // global
           I64[Sp - 8] = block_cdC4f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC4o; else goto cdC4g;
       udC4o: // global
           call _cdC4f(R1) args: 0, res: 0, upd: 0;
       cdC4g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC4f() //  [R1]
         { info_tbl: [(cdC4f,
                       label: block_cdC4f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC4f: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.540641345 UTC

[section ""data" . Data.Functor.Classes.$p1Ord2_closure" {
     Data.Functor.Classes.$p1Ord2_closure:
         const Data.Functor.Classes.$p1Ord2_info;
 },
 Data.Functor.Classes.$p1Ord2_entry() //  [R2]
         { info_tbl: [(cdC4F,
                       label: Data.Functor.Classes.$p1Ord2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC4F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC4G; else goto cdC4H;
       cdC4G: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC4H: // global
           I64[Sp - 8] = block_cdC4C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC4L; else goto cdC4D;
       udC4L: // global
           call _cdC4C(R1) args: 0, res: 0, upd: 0;
       cdC4D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC4C() //  [R1]
         { info_tbl: [(cdC4C,
                       label: block_cdC4C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC4C: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.546142521 UTC

[section ""data" . Data.Functor.Classes.liftCompare2_closure" {
     Data.Functor.Classes.liftCompare2_closure:
         const Data.Functor.Classes.liftCompare2_info;
 },
 Data.Functor.Classes.liftCompare2_entry() //  [R2]
         { info_tbl: [(cdC52,
                       label: Data.Functor.Classes.liftCompare2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC52: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC53; else goto cdC54;
       cdC53: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC54: // global
           I64[Sp - 8] = block_cdC4Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC58; else goto cdC50;
       udC58: // global
           call _cdC4Z(R1) args: 0, res: 0, upd: 0;
       cdC50: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC4Z() //  [R1]
         { info_tbl: [(cdC4Z,
                       label: block_cdC4Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC4Z: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.551563 UTC

[section ""data" . Data.Functor.Classes.liftEq2_closure" {
     Data.Functor.Classes.liftEq2_closure:
         const Data.Functor.Classes.liftEq2_info;
 },
 Data.Functor.Classes.liftEq2_entry() //  [R2]
         { info_tbl: [(cdC5m,
                       label: Data.Functor.Classes.liftEq2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC5m: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.555236533 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec_closure" {
     Data.Functor.Classes.liftShowsPrec_closure:
         const Data.Functor.Classes.liftShowsPrec_info;
 },
 Data.Functor.Classes.liftShowsPrec_entry() //  [R2]
         { info_tbl: [(cdC5A,
                       label: Data.Functor.Classes.liftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC5A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC5B; else goto cdC5C;
       cdC5B: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC5C: // global
           I64[Sp - 8] = block_cdC5x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC5G; else goto cdC5y;
       udC5G: // global
           call _cdC5x(R1) args: 0, res: 0, upd: 0;
       cdC5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC5x() //  [R1]
         { info_tbl: [(cdC5x,
                       label: block_cdC5x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC5x: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.560918994 UTC

[section ""data" . Data.Functor.Classes.liftShowList_closure" {
     Data.Functor.Classes.liftShowList_closure:
         const Data.Functor.Classes.liftShowList_info;
 },
 Data.Functor.Classes.liftShowList_entry() //  [R2]
         { info_tbl: [(cdC5X,
                       label: Data.Functor.Classes.liftShowList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC5X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC5Y; else goto cdC5Z;
       cdC5Y: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC5Z: // global
           I64[Sp - 8] = block_cdC5U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC63; else goto cdC5V;
       udC63: // global
           call _cdC5U(R1) args: 0, res: 0, upd: 0;
       cdC5V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC5U() //  [R1]
         { info_tbl: [(cdC5U,
                       label: block_cdC5U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC5U: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.567753436 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec_closure" {
     Data.Functor.Classes.liftReadsPrec_closure:
         const Data.Functor.Classes.liftReadsPrec_info;
 },
 Data.Functor.Classes.liftReadsPrec_entry() //  [R2]
         { info_tbl: [(cdC6k,
                       label: Data.Functor.Classes.liftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC6k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC6l; else goto cdC6m;
       cdC6l: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC6m: // global
           I64[Sp - 8] = block_cdC6h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC6q; else goto cdC6i;
       udC6q: // global
           call _cdC6h(R1) args: 0, res: 0, upd: 0;
       cdC6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC6h() //  [R1]
         { info_tbl: [(cdC6h,
                       label: block_cdC6h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC6h: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.573202892 UTC

[section ""data" . Data.Functor.Classes.liftReadList_closure" {
     Data.Functor.Classes.liftReadList_closure:
         const Data.Functor.Classes.liftReadList_info;
 },
 Data.Functor.Classes.liftReadList_entry() //  [R2]
         { info_tbl: [(cdC6H,
                       label: Data.Functor.Classes.liftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC6H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC6I; else goto cdC6J;
       cdC6I: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC6J: // global
           I64[Sp - 8] = block_cdC6E_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC6N; else goto cdC6F;
       udC6N: // global
           call _cdC6E(R1) args: 0, res: 0, upd: 0;
       cdC6F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC6E() //  [R1]
         { info_tbl: [(cdC6E,
                       label: block_cdC6E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC6E: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.579186125 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec_closure" {
     Data.Functor.Classes.liftReadPrec_closure:
         const Data.Functor.Classes.liftReadPrec_info;
 },
 Data.Functor.Classes.liftReadPrec_entry() //  [R2]
         { info_tbl: [(cdC74,
                       label: Data.Functor.Classes.liftReadPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC74: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC75; else goto cdC76;
       cdC75: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC76: // global
           I64[Sp - 8] = block_cdC71_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC7a; else goto cdC72;
       udC7a: // global
           call _cdC71(R1) args: 0, res: 0, upd: 0;
       cdC72: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC71() //  [R1]
         { info_tbl: [(cdC71,
                       label: block_cdC71_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC71: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.584865802 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec_closure" {
     Data.Functor.Classes.liftReadListPrec_closure:
         const Data.Functor.Classes.liftReadListPrec_info;
 },
 Data.Functor.Classes.liftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdC7r,
                       label: Data.Functor.Classes.liftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC7r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC7s; else goto cdC7t;
       cdC7s: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC7t: // global
           I64[Sp - 8] = block_cdC7o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC7x; else goto cdC7p;
       udC7x: // global
           call _cdC7o(R1) args: 0, res: 0, upd: 0;
       cdC7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC7o() //  [R1]
         { info_tbl: [(cdC7o,
                       label: block_cdC7o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC7o: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.590871268 UTC

[section ""data" . Data.Functor.Classes.$p1Ord1_closure" {
     Data.Functor.Classes.$p1Ord1_closure:
         const Data.Functor.Classes.$p1Ord1_info;
 },
 Data.Functor.Classes.$p1Ord1_entry() //  [R2]
         { info_tbl: [(cdC7O,
                       label: Data.Functor.Classes.$p1Ord1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC7O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC7P; else goto cdC7Q;
       cdC7P: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC7Q: // global
           I64[Sp - 8] = block_cdC7L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC7U; else goto cdC7M;
       udC7U: // global
           call _cdC7L(R1) args: 0, res: 0, upd: 0;
       cdC7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC7L() //  [R1]
         { info_tbl: [(cdC7L,
                       label: block_cdC7L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC7L: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.597815177 UTC

[section ""data" . Data.Functor.Classes.liftCompare_closure" {
     Data.Functor.Classes.liftCompare_closure:
         const Data.Functor.Classes.liftCompare_info;
 },
 Data.Functor.Classes.liftCompare_entry() //  [R2]
         { info_tbl: [(cdC8b,
                       label: Data.Functor.Classes.liftCompare_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC8b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdC8c; else goto cdC8d;
       cdC8c: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC8d: // global
           I64[Sp - 8] = block_cdC88_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udC8h; else goto cdC89;
       udC8h: // global
           call _cdC88(R1) args: 0, res: 0, upd: 0;
       cdC89: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC88() //  [R1]
         { info_tbl: [(cdC88,
                       label: block_cdC88_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC88: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.603874439 UTC

[section ""data" . Data.Functor.Classes.liftEq_closure" {
     Data.Functor.Classes.liftEq_closure:
         const Data.Functor.Classes.liftEq_info;
 },
 Data.Functor.Classes.liftEq_entry() //  [R2]
         { info_tbl: [(cdC8v,
                       label: Data.Functor.Classes.liftEq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC8v: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.607276618 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const1_closure" {
     Data.Functor.Classes.$fRead1Const1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.609064666 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Const4_bytes" {
     Data.Functor.Classes.$fRead1Const4_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.611078979 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const3_closure" {
     Data.Functor.Classes.$fRead1Const3_closure:
         const Data.Functor.Classes.$fRead1Const3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const3_entry() //  [R1]
         { info_tbl: [(cdC8K,
                       label: Data.Functor.Classes.$fRead1Const3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC8K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdC8L; else goto cdC8M;
       cdC8L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdC8M: // global
           (_cdC8H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdC8H::I64 == 0) goto cdC8J; else goto cdC8I;
       cdC8J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdC8I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdC8H::I64;
           R2 = Data.Functor.Classes.$fRead1Const4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.615548862 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const2_closure" {
     Data.Functor.Classes.$fRead1Const2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.618480562 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadPrec1_info;
         const 0;
 },
 sat_sdyo7_entry() //  [R1, R2]
         { info_tbl: [(cdC9n,
                       label: sat_sdyo7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC9n: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyo8_entry() //  [R1, R2]
         { info_tbl: [(cdC9q,
                       label: sat_sdyo8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC9q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdC9u; else goto cdC9t;
       cdC9u: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdC9t: // global
           _sdynX::P64 = P64[R1 + 7];
           _sdyo1::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyo7_info;
           P64[Hp] = _sdyo1::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdynX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyob_entry() //  [R1, R2, R3]
         { info_tbl: [(cdC9v,
                       label: sat_sdyob_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC9v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdC9w; else goto cdC9x;
       cdC9w: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC9x: // global
           I64[Sp - 24] = block_cdC94_info;
           _sdynX::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdynX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udC9K; else goto cdC95;
       udC9K: // global
           call _cdC94(R1) args: 0, res: 0, upd: 0;
       cdC95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdC94() //  [R1]
         { info_tbl: [(cdC94,
                       label: block_cdC94_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC94: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdC9A; else goto cdC9z;
       cdC9A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdC9z: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdC9C; else goto cdC9G;
       cdC9C: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdC9G: // global
           I64[Hp - 16] = sat_sdyo8_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdC9D_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdC9D() //  [R1]
         { info_tbl: [(cdC9D,
                       label: block_cdC9D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC9D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdC9J; else goto cdC9I;
       cdC9J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdC9I: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdC9L,
                       label: Data.Functor.Classes.$w$cliftReadPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdC9L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdC9P; else goto cdC9O;
       cdC9P: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdC9O: // global
           I64[Hp - 8] = sat_sdyob_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.633443966 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const6_closure" {
     Data.Functor.Classes.$fRead1Const6_closure:
         const Data.Functor.Classes.$fRead1Const6_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const6_entry() //  [R2, R6]
         { info_tbl: [(cdCaj,
                       label: Data.Functor.Classes.$fRead1Const6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCaj: // global
           R4 = P64[Sp];
           R3 = R6;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.638490142 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyoo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCaz,
                       label: sat_sdyoo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCaz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdCaC,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCaC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCaG; else goto cdCaF;
       cdCaG: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCaF: // global
           I64[Hp - 8] = sat_sdyoo_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.64657542 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec7_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec7_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec7_info;
         const 0;
 },
 lvl3_sdyor_entry() //  [R1]
         { info_tbl: [(cdCb0,
                       label: lvl3_sdyor_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCb0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCb1; else goto cdCb2;
       cdCb1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyoz_entry() //  [R1, R2]
         { info_tbl: [(cdCbr,
                       label: sat_sdyoz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCbr: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoC_entry() //  [R1, R2]
         { info_tbl: [(cdCbx,
                       label: sat_sdyoC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCbx: // global
           _sdyox::P64 = R2;
           _sdyoC::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdCby; else goto cdCbz;
       cdCbz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCbB; else goto cdCbA;
       cdCbB: // global
           HpAlloc = 16;
           goto cdCby;
       cdCby: // global
           R2 = _sdyox::P64;
           R1 = _sdyoC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCbA: // global
           _sdyor::P64 = P64[_sdyoC::P64 + 7];
           _sdyot::P64 = P64[_sdyoC::P64 + 15];
           I64[Hp - 8] = sat_sdyoz_info;
           P64[Hp] = _sdyot::P64;
           I64[Sp - 8] = block_cdCbu_info;
           R3 = Hp - 7;
           R2 = _sdyor::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCbu() //  [R1]
         { info_tbl: [(cdCbu,
                       label: block_cdCbu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCbu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCbE; else goto cdCbD;
       cdCbE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCbD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoF_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCbF,
                       label: sat_sdyoF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCbF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdCbG; else goto cdCbH;
       cdCbG: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCbH: // global
           I64[Sp - 24] = block_cdCb8_info;
           _sdyor::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyor::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCbU; else goto cdCb9;
       udCbU: // global
           call _cdCb8(R1) args: 0, res: 0, upd: 0;
       cdCb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCb8() //  [R1]
         { info_tbl: [(cdCb8,
                       label: block_cdCb8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCb8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCbK; else goto cdCbJ;
       cdCbK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCbJ: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdCbM; else goto cdCbQ;
       cdCbM: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCbQ: // global
           I64[Hp - 16] = sat_sdyoC_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdCbN_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCbN() //  [R1]
         { info_tbl: [(cdCbN,
                       label: block_cdCbN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCbN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCbT; else goto cdCbS;
       cdCbT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCbS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoG_entry() //  [R1]
         { info_tbl: [(cdCbV,
                       label: sat_sdyoG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCbV: // global
           _sdyoG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCbW; else goto cdCbX;
       cdCbX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdCbZ; else goto cdCbY;
       cdCbZ: // global
           HpAlloc = 40;
           goto cdCbW;
       cdCbW: // global
           R1 = _sdyoG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyoG::P64;
           _sdyop::P64 = P64[_sdyoG::P64 + 16];
           _sdyoq::P64 = P64[_sdyoG::P64 + 24];
           I64[Hp - 32] = lvl3_sdyor_info;
           P64[Hp - 16] = _sdyop::P64;
           I64[Hp - 8] = sat_sdyoF_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyoq::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec7_entry() //  [R2, R3]
         { info_tbl: [(cdCc0,
                       label: Data.Functor.Classes.$w$cliftReadsPrec7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCc0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCc4; else goto cdCc3;
       cdCc4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCc3: // global
           I64[Hp - 24] = sat_sdyoG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.669588505 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_entry() //  [R2,
                                                                 R6]
         { info_tbl: [(cdCcM,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCcM: // global
           R3 = R6;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec7_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.674876685 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either3_bytes" {
     Data.Functor.Classes.$fRead1Either3_bytes:
         I8[] [82,105,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.6779959 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either2_closure" {
     Data.Functor.Classes.$fRead1Either2_closure:
         const Data.Functor.Classes.$fRead1Either2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either2_entry() //  [R1]
         { info_tbl: [(cdCd0,
                       label: Data.Functor.Classes.$fRead1Either2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCd0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCd1; else goto cdCd2;
       cdCd1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCd2: // global
           (_cdCcX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdCcX::I64 == 0) goto cdCcZ; else goto cdCcY;
       cdCcZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdCcY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdCcX::I64;
           R2 = Data.Functor.Classes.$fRead1Either3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.684328036 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either1_closure" {
     Data.Functor.Classes.$fRead1Either1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.686549008 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either6_bytes" {
     Data.Functor.Classes.$fRead1Either6_bytes:
         I8[] [76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.689140655 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either5_closure" {
     Data.Functor.Classes.$fRead1Either5_closure:
         const Data.Functor.Classes.$fRead1Either5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either5_entry() //  [R1]
         { info_tbl: [(cdCdi,
                       label: Data.Functor.Classes.$fRead1Either5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCdi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCdj; else goto cdCdk;
       cdCdj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCdk: // global
           (_cdCdf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdCdf::I64 == 0) goto cdCdh; else goto cdCdg;
       cdCdh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdCdg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdCdf::I64;
           R2 = Data.Functor.Classes.$fRead1Either6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.693313489 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either4_closure" {
     Data.Functor.Classes.$fRead1Either4_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.696858146 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadPrec3_info;
         const 0;
 },
 sat_sdyoY_entry() //  [R1, R2]
         { info_tbl: [(cdCdW,
                       label: sat_sdyoY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCdW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCe0; else goto cdCdZ;
       cdCe0: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCdZ: // global
           _sdyoR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sdyoR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyoZ_entry() //  [R1, R2]
         { info_tbl: [(cdCe1,
                       label: sat_sdyoZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCe1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCe5; else goto cdCe4;
       cdCe5: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCe4: // global
           _sdyoM::P64 = P64[R1 + 7];
           _sdyoR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyoY_info;
           P64[Hp] = _sdyoR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyoM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyp6_entry() //  [R1, R2]
         { info_tbl: [(cdCen,
                       label: sat_sdyp6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCen: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCer; else goto cdCeq;
       cdCer: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCeq: // global
           _sdyoR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdyoR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyp7_entry() //  [R1, R2]
         { info_tbl: [(cdCes,
                       label: sat_sdyp7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCes: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCew; else goto cdCev;
       cdCew: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCev: // global
           _sdyoN::P64 = P64[R1 + 7];
           _sdyoR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyp6_info;
           P64[Hp] = _sdyoR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyoN::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdypa_entry() //  [R1]
         { info_tbl: [(cdCeA,
                       label: sat_sdypa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCeA: // global
           _sdypa::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdCeB; else goto cdCeC;
       cdCeC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCeE; else goto cdCeD;
       cdCeE: // global
           HpAlloc = 24;
           goto cdCeB;
       cdCeB: // global
           R1 = _sdypa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCeD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdypa::P64;
           _sdyoN::P64 = P64[_sdypa::P64 + 16];
           _sdyoR::P64 = P64[_sdypa::P64 + 24];
           I64[Hp - 16] = sat_sdyp7_info;
           P64[Hp - 8] = _sdyoN::P64;
           P64[Hp] = _sdyoR::P64;
           I64[Sp - 24] = block_cdCex_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either1_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdCex() //  [R1]
         { info_tbl: [(cdCex,
                       label: block_cdCex_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCex: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCeH; else goto cdCeG;
       cdCeH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdCeG: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdypb_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCeI,
                       label: sat_sdypb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCeI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCeJ; else goto cdCeK;
       cdCeJ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCeK: // global
           I64[Sp - 32] = block_cdCdC_info;
           _sdyoM::P64 = P64[R1 + 6];
           _sdyoN::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdyoM::P64;
           P64[Sp - 16] = _sdyoN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCeV; else goto cdCdD;
       udCeV: // global
           call _cdCdC(R1) args: 0, res: 0, upd: 0;
       cdCdD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCdC() //  [R1]
         { info_tbl: [(cdCdC,
                       label: block_cdCdC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCdC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCeN; else goto cdCeM;
       cdCeN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCeM: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdCeP; else goto cdCeR;
       cdCeP: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCeR: // global
           I64[Hp - 16] = sat_sdyoZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 8] = block_cdCe6_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either4_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCe6() //  [R1]
         { info_tbl: [(cdCe6,
                       label: block_cdCe6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCe6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdCeU; else goto cdCeT;
       cdCeU: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCeT: // global
           I64[Hp - 40] = sat_sdypa_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCeW,
                       label: Data.Functor.Classes.$w$cliftReadPrec3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCeW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCf0; else goto cdCeZ;
       cdCf0: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCeZ: // global
           I64[Hp - 16] = sat_sdypb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyoO::P64 = R4;
           R4 = R5;
           R3 = _sdyoO::P64;
           R2 = Hp - 14;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.719616214 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either8_closure" {
     Data.Functor.Classes.$fRead1Either8_closure:
         const Data.Functor.Classes.$fRead1Either8_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either8_entry() //  [R2, R4, R6]
         { info_tbl: [(cdCfJ,
                       label: Data.Functor.Classes.$fRead1Either8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCfJ: // global
           R5 = P64[Sp];
           _sdype::P64 = R4;
           R4 = R6;
           R3 = _sdype::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.723685949 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdypo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCfZ,
                       label: sat_sdypo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCfZ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdCg2,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCg2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCg6; else goto cdCg5;
       cdCg6: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCg5: // global
           I64[Hp - 16] = sat_sdypo_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.731313153 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec8_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec8_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec8_info;
         const 0;
 },
 sat_sdypt_entry() //  [R1, R2]
         { info_tbl: [(cdCgr,
                       label: sat_sdypt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCgr: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyps_entry() //  [R1, R2]
         { info_tbl: [(cdCgz,
                       label: sat_sdyps_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCgz: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdypu_entry() //  [R1]
         { info_tbl: [(cdCgC,
                       label: sat_sdypu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCgC: // global
           _sdypu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCgD; else goto cdCgE;
       cdCgE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCgG; else goto cdCgF;
       cdCgG: // global
           HpAlloc = 32;
           goto cdCgD;
       cdCgD: // global
           R1 = _sdypu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdypu::P64;
           _sdypp::P64 = P64[_sdypu::P64 + 16];
           _sdypq::P64 = P64[_sdypu::P64 + 24];
           _sdypr::P64 = P64[_sdypu::P64 + 32];
           I64[Hp - 24] = sat_sdypt_info;
           P64[Hp - 16] = _sdypq::P64;
           I64[Hp - 8] = sat_sdyps_info;
           P64[Hp] = _sdypp::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdypr::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec8_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCgH,
                       label: Data.Functor.Classes.$w$cliftReadsPrec8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCgH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdCgL; else goto cdCgK;
       cdCgL: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCgK: // global
           I64[Hp - 32] = sat_sdypu_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.741804251 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_entry() //  [R2,
                                                                  R4, R6]
         { info_tbl: [(cdCh4,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCh4: // global
           _sdypx::P64 = R4;
           R4 = R6;
           R3 = _sdypx::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec8_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.745934527 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry() //  [R2, R3, R4]
         { info_tbl: [(cdChm,
                       label: Data.Functor.Classes.$fEq1Maybe_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdChm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdChn; else goto cdCho;
       cdChn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCho: // global
           I64[Sp - 24] = block_cdChf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udChZ; else goto cdChg;
       udChZ: // global
           call _cdChf(R1) args: 0, res: 0, upd: 0;
       cdChg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdChf() //  [R1]
         { info_tbl: [(cdChf,
                       label: block_cdChf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdChf: // global
           _sdypC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdChj; else goto cdChk;
       cdChj: // global
           I64[Sp + 16] = block_cdChr_info;
           R1 = _sdypC::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udChX; else goto cdCht;
       udChX: // global
           call _cdChr(R1) args: 0, res: 0, upd: 0;
       cdCht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdChk: // global
           I64[Sp] = block_cdChG_info;
           _sdypG::P64 = P64[R1 + 6];
           R1 = _sdypC::P64;
           P64[Sp + 16] = _sdypG::P64;
           if (R1 & 7 != 0) goto udChY; else goto cdChI;
       udChY: // global
           call _cdChG(R1) args: 0, res: 0, upd: 0;
       cdChI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdChr() //  [R1]
         { info_tbl: [(cdChr,
                       label: block_cdChr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdChr: // global
           if (R1 & 7 == 1) goto cdChz; else goto udChW;
       cdChz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udChW: // global
           Sp = Sp + 8;
           call _cdChO() args: 0, res: 0, upd: 0;
     }
 },
 _cdChG() //  [R1]
         { info_tbl: [(cdChG,
                       label: block_cdChG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdChG: // global
           if (R1 & 7 == 1) goto udChV; else goto cdChS;
       udChV: // global
           Sp = Sp + 24;
           call _cdChO() args: 0, res: 0, upd: 0;
       cdChS: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdChO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdChO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.758212843 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_closure" {
     Data.Functor.Classes.$fEq1Maybe_closure:
         const Data.Functor.Classes.$fEq1Maybe_info;
 },
 Data.Functor.Classes.$fEq1Maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCix,
                       label: Data.Functor.Classes.$fEq1Maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCix: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.762626411 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdCiP,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCiP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCiQ; else goto udCjA;
       cdCiQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udCjA: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdCiF() args: 0, res: 0, upd: 0;
     }
 },
 _cdCiF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCiF: // global
           I64[Sp - 8] = block_cdCiI_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCjF; else goto cdCiJ;
       udCjF: // global
           call _cdCiI(R1) args: 0, res: 0, upd: 0;
       cdCiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCiI() //  [R1]
         { info_tbl: [(cdCiI,
                       label: block_cdCiI_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCiI: // global
           _sdypL::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCiM; else goto cdCiN;
       cdCiM: // global
           I64[Sp + 24] = block_cdCiU_info;
           R1 = _sdypL::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udCjG; else goto cdCiW;
       udCjG: // global
           call _cdCiU(R1) args: 0, res: 0, upd: 0;
       cdCiW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCiN: // global
           I64[Sp] = block_cdCj9_info;
           _sdypQ::P64 = P64[R1 + 6];
           _sdypR::P64 = P64[R1 + 14];
           R1 = _sdypL::P64;
           P64[Sp + 16] = _sdypR::P64;
           P64[Sp + 24] = _sdypQ::P64;
           if (R1 & 7 != 0) goto udCjH; else goto cdCjb;
       udCjH: // global
           call _cdCj9(R1) args: 0, res: 0, upd: 0;
       cdCjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCiU() //  [R1]
         { info_tbl: [(cdCiU,
                       label: block_cdCiU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCiU: // global
           if (R1 & 7 == 1) goto cdCj2; else goto udCjE;
       cdCj2: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udCjE: // global
           Sp = Sp + 8;
           call _cdCjs() args: 0, res: 0, upd: 0;
     }
 },
 _cdCj9() //  [R1]
         { info_tbl: [(cdCj9,
                       label: block_cdCj9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCj9: // global
           if (R1 & 7 == 1) goto udCjB; else goto cdCjm;
       udCjB: // global
           Sp = Sp + 32;
           call _cdCjs() args: 0, res: 0, upd: 0;
       cdCjm: // global
           I64[Sp] = block_cdCjk_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdypU::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdypU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCjk() //  [R1]
         { info_tbl: [(cdCjk,
                       label: block_cdCjk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCjk: // global
           if (R1 & 7 == 1) goto udCjC; else goto cdCjw;
       udCjC: // global
           Sp = Sp + 32;
           call _cdCjs() args: 0, res: 0, upd: 0;
       cdCjw: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdCiF() args: 0, res: 0, upd: 0;
     }
 },
 _cdCjs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCjs: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.777657805 UTC

[section ""data" . Data.Functor.Classes.$fEq1[]_closure" {
     Data.Functor.Classes.$fEq1[]_closure:
         const Data.Functor.Classes.$fEq1[]_info;
 },
 Data.Functor.Classes.$fEq1[]_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCks,
                       label: Data.Functor.Classes.$fEq1[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCks: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.781377189 UTC

[section ""data" . Data.Functor.Classes.$w$cliftEq_closure" {
     Data.Functor.Classes.$w$cliftEq_closure:
         const Data.Functor.Classes.$w$cliftEq_info;
 },
 Data.Functor.Classes.$w$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdCkJ,
                       label: Data.Functor.Classes.$w$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCkJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCkK; else goto cdCkL;
       cdCkK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCkL: // global
           I64[Sp - 32] = block_cdCkD_info;
           _sdypX::P64 = R3;
           R3 = R5;
           _sdypW::P64 = R2;
           R2 = _sdypX::P64;
           R1 = _sdypW::P64;
           P64[Sp - 24] = _sdypW::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCkD() //  [R1]
         { info_tbl: [(cdCkD,
                       label: block_cdCkD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCkD: // global
           if (R1 & 7 == 1) goto cdCkG; else goto cdCkH;
       cdCkG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCkH: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.787859705 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdCla,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCla: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCle; else goto cdClf;
       cdCle: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdClf: // global
           I64[Sp - 24] = block_cdCl7_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCln; else goto cdCl8;
       udCln: // global
           call _cdCl7(R1) args: 0, res: 0, upd: 0;
       cdCl8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCl7() //  [R1]
         { info_tbl: [(cdCl7,
                       label: block_cdCl7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCl7: // global
           I64[Sp - 8] = block_cdCld_info;
           _sdyq6::P64 = P64[R1 + 7];
           _sdyq7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdyq7::P64;
           P64[Sp + 16] = _sdyq6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udClm; else goto cdClh;
       udClm: // global
           call _cdCld(R1) args: 0, res: 0, upd: 0;
       cdClh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCld() //  [R1]
         { info_tbl: [(cdCld,
                       label: block_cdCld_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCld: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftEq_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.795624315 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_entry() //  [R2, R3, R4]
         { info_tbl: [(cdClF,
                       label: Data.Functor.Classes.$fEq1NonEmpty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdClF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.799173013 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Identity_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Identity_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdClQ,
                       label: Data.Functor.Classes.$fEq1Identity_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdClQ: // global
           _sdyqc::P64 = R3;
           R3 = R4;
           _sdyqb::P64 = R2;
           R2 = _sdyqc::P64;
           R1 = _sdyqb::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.802885934 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_closure" {
     Data.Functor.Classes.$fEq1Identity_closure:
         const Data.Functor.Classes.$fEq1Identity_info;
 },
 Data.Functor.Classes.$fEq1Identity_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCm1,
                       label: Data.Functor.Classes.$fEq1Identity_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCm1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Identity_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.806963759 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry() //  []
         { info_tbl: [(cdCmc,
                       label: Data.Functor.Classes.$fEq1Proxy_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCmc: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.810882155 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_closure" {
     Data.Functor.Classes.$fEq1Proxy_closure:
         const Data.Functor.Classes.$fEq1Proxy_info;
 },
 Data.Functor.Classes.$fEq1Proxy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCmo,
                       label: Data.Functor.Classes.$fEq1Proxy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCmo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.814785756 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdCmG,
                       label: Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCmG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdCmH; else goto cdCmI;
       cdCmH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCmI: // global
           I64[Sp - 24] = block_cdCmz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCnh; else goto cdCmA;
       udCnh: // global
           call _cdCmz(R1) args: 0, res: 0, upd: 0;
       cdCmA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCmz() //  [R1]
         { info_tbl: [(cdCmz,
                       label: block_cdCmz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCmz: // global
           _sdyqj::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdCmD; else goto cdCmE;
       cdCmD: // global
           I64[Sp + 16] = block_cdCmL_info;
           R1 = _sdyqj::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udCnf; else goto cdCmN;
       udCnf: // global
           call _cdCmL(R1) args: 0, res: 0, upd: 0;
       cdCmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCmE: // global
           I64[Sp] = block_cdCn0_info;
           _sdyqn::P64 = P64[R1 + 6];
           R1 = _sdyqj::P64;
           P64[Sp + 16] = _sdyqn::P64;
           if (R1 & 7 != 0) goto udCng; else goto cdCn2;
       udCng: // global
           call _cdCn0(R1) args: 0, res: 0, upd: 0;
       cdCn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCmL() //  [R1]
         { info_tbl: [(cdCmL,
                       label: block_cdCmL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCmL: // global
           if (R1 & 7 == 1) goto cdCmT; else goto cdCmX;
       cdCmT: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCmX: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCn0() //  [R1]
         { info_tbl: [(cdCn0,
                       label: block_cdCn0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCn0: // global
           if (R1 & 7 == 1) goto cdCn8; else goto cdCnc;
       cdCn8: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCnc: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.824518427 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_closure" {
     Data.Functor.Classes.$fOrd1Maybe_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.827750333 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdCnU,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCnU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCnV; else goto udCoK;
       cdCnV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udCoK: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdCnK() args: 0, res: 0, upd: 0;
     }
 },
 _cdCnK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCnK: // global
           I64[Sp - 8] = block_cdCnN_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCoQ; else goto cdCnO;
       udCoQ: // global
           call _cdCnN(R1) args: 0, res: 0, upd: 0;
       cdCnO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCnN() //  [R1]
         { info_tbl: [(cdCnN,
                       label: block_cdCnN_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCnN: // global
           _sdyqs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCnR; else goto cdCnS;
       cdCnR: // global
           I64[Sp + 24] = block_cdCnZ_info;
           R1 = _sdyqs::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udCoR; else goto cdCo1;
       udCoR: // global
           call _cdCnZ(R1) args: 0, res: 0, upd: 0;
       cdCo1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCnS: // global
           I64[Sp] = block_cdCoe_info;
           _sdyqx::P64 = P64[R1 + 6];
           _sdyqy::P64 = P64[R1 + 14];
           R1 = _sdyqs::P64;
           P64[Sp + 16] = _sdyqy::P64;
           P64[Sp + 24] = _sdyqx::P64;
           if (R1 & 7 != 0) goto udCoS; else goto cdCog;
       udCoS: // global
           call _cdCoe(R1) args: 0, res: 0, upd: 0;
       cdCog: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCnZ() //  [R1]
         { info_tbl: [(cdCnZ,
                       label: block_cdCnZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCnZ: // global
           if (R1 & 7 == 1) goto cdCo7; else goto udCoP;
       cdCo7: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udCoP: // global
           Sp = Sp + 8;
           call _cdCox() args: 0, res: 0, upd: 0;
     }
 },
 _cdCoe() //  [R1]
         { info_tbl: [(cdCoe,
                       label: block_cdCoe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCoe: // global
           if (R1 & 7 == 1) goto udCoL; else goto cdCor;
       udCoL: // global
           Sp = Sp + 32;
           call _cdCoF() args: 0, res: 0, upd: 0;
       cdCor: // global
           I64[Sp] = block_cdCop_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdyqB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdyqB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCop() //  [R1]
         { info_tbl: [(cdCop,
                       label: block_cdCop_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCop: // global
           _cdCoH::P64 = R1 & 7;
           if (_cdCoH::P64 < 3) goto udCoJ; else goto udCoM;
       udCoJ: // global
           if (_cdCoH::P64 < 2) goto udCoN; else goto cdCoB;
       udCoN: // global
           Sp = Sp + 32;
           call _cdCox() args: 0, res: 0, upd: 0;
       cdCoB: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdCnK() args: 0, res: 0, upd: 0;
       udCoM: // global
           Sp = Sp + 32;
           call _cdCoF() args: 0, res: 0, upd: 0;
     }
 },
 _cdCox() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCox: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCoF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCoF: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.842338089 UTC

[section ""data" . Data.Functor.Classes.$fOrd1[]_closure" {
     Data.Functor.Classes.$fOrd1[]_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.845354879 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare1_closure" {
     Data.Functor.Classes.$w$cliftCompare1_closure:
         const Data.Functor.Classes.$w$cliftCompare1_info;
 },
 Data.Functor.Classes.$w$cliftCompare1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdCpO,
                       label: Data.Functor.Classes.$w$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCpO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCpP; else goto cdCpQ;
       cdCpP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCpQ: // global
           I64[Sp - 32] = block_cdCpH_info;
           _sdyqE::P64 = R3;
           R3 = R5;
           _sdyqD::P64 = R2;
           R2 = _sdyqE::P64;
           R1 = _sdyqD::P64;
           P64[Sp - 24] = _sdyqD::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCpH() //  [R1]
         { info_tbl: [(cdCpH,
                       label: block_cdCpH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCpH: // global
           _cdCpN::P64 = R1 & 7;
           if (_cdCpN::P64 < 3) goto udCq0; else goto cdCpM;
       udCq0: // global
           if (_cdCpN::P64 < 2) goto cdCpK; else goto cdCpL;
       cdCpK: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCpL: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       cdCpM: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.851873225 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdCqj,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCqj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCqn; else goto cdCqo;
       cdCqn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCqo: // global
           I64[Sp - 24] = block_cdCqg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCqw; else goto cdCqh;
       udCqw: // global
           call _cdCqg(R1) args: 0, res: 0, upd: 0;
       cdCqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCqg() //  [R1]
         { info_tbl: [(cdCqg,
                       label: block_cdCqg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCqg: // global
           I64[Sp - 8] = block_cdCqm_info;
           _sdyqN::P64 = P64[R1 + 7];
           _sdyqO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdyqO::P64;
           P64[Sp + 16] = _sdyqN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCqv; else goto cdCqq;
       udCqv: // global
           call _cdCqm(R1) args: 0, res: 0, upd: 0;
       cdCqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCqm() //  [R1]
         { info_tbl: [(cdCqm,
                       label: block_cdCqm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCqm: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.859431174 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.861430054 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Identity_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdCqP,
                       label: Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCqP: // global
           _sdyqT::P64 = R3;
           R3 = R4;
           _sdyqS::P64 = R2;
           R2 = _sdyqT::P64;
           R1 = _sdyqS::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.864882736 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_closure" {
     Data.Functor.Classes.$fOrd1Identity_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.867163295 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_entry() //  []
         { info_tbl: [(cdCr1,
                       label: Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCr1: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.870556527 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_closure" {
     Data.Functor.Classes.$fOrd1Proxy_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.872566878 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadPrec_entry() //  [R3]
         { info_tbl: [(cdCre,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCre: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.875855784 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1NonEmpty4_bytes" {
     Data.Functor.Classes.$fRead1NonEmpty4_bytes:
         I8[] [58,124]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.878542723 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty3_closure" {
     Data.Functor.Classes.$fRead1NonEmpty3_closure:
         const Data.Functor.Classes.$fRead1NonEmpty3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty3_entry() //  [R1]
         { info_tbl: [(cdCrs,
                       label: Data.Functor.Classes.$fRead1NonEmpty3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCrs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCrt; else goto cdCru;
       cdCrt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCru: // global
           (_cdCrp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdCrp::I64 == 0) goto cdCrr; else goto cdCrq;
       cdCrr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdCrq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdCrp::I64;
           R2 = Data.Functor.Classes.$fRead1NonEmpty4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.882904503 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty2_closure" {
     Data.Functor.Classes.$fRead1NonEmpty2_closure:
         const GHC.Types.I#_con_info;
         const 6;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.887030529 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec5_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec5_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec5_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCrE: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sdyrn_entry() //  [R1, R2]
         { info_tbl: [(cdCsx,
                       label: go2_sdyrn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCsx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCsy; else goto cdCsz;
       cdCsy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCsz: // global
           I64[Sp - 32] = block_cdCsq_info;
           _sdyrn::P64 = R1;
           _sdyra::P64 = P64[R1 + 7];
           _sdyrm::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdyra::P64;
           P64[Sp - 16] = _sdyrm::P64;
           P64[Sp - 8] = _sdyrn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCsT; else goto cdCsr;
       udCsT: // global
           call _cdCsq(R1) args: 0, res: 0, upd: 0;
       cdCsr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCsq() //  [R1]
         { info_tbl: [(cdCsq,
                       label: block_cdCsq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCsq: // global
           if (R1 & 7 == 1) goto cdCsu; else goto cdCsv;
       cdCsu: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdCsv: // global
           I64[Sp] = block_cdCsF_info;
           _sdyrr::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdyrr::P64;
           if (R1 & 7 != 0) goto udCsS; else goto cdCsG;
       udCsS: // global
           call _cdCsF(R1) args: 0, res: 0, upd: 0;
       cdCsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCsF() //  [R1]
         { info_tbl: [(cdCsF,
                       label: block_cdCsF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCsF: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdCsR; else goto cdCsQ;
       cdCsR: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCsQ: // global
           _sdyrt::P64 = P64[R1 + 7];
           _sdyru::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_2_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = GHC.Base.:|_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sdyrt::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = _sdyru::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sdyrd_entry() //  [R1, R2]
         { info_tbl: [(cdCsY,
                       label: go1_sdyrd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCsY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdCsZ; else goto udCtj;
       cdCsZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udCtj: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdCs1() args: 0, res: 0, upd: 0;
     }
 },
 _cdCs1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCs1: // global
           I64[Sp - 24] = block_cdCs4_info;
           R1 = P64[Sp + 8];
           _sdyrd::P64 = P64[Sp];
           P64[Sp - 16] = P64[_sdyrd::P64 + 15];
           P64[Sp - 8] = P64[_sdyrd::P64 + 23];
           P64[Sp + 8] = P64[_sdyrd::P64 + 7];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCtl; else goto cdCs5;
       udCtl: // global
           call _cdCs4(R1) args: 0, res: 0, upd: 0;
       cdCs5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCs4() //  [R1]
         { info_tbl: [(cdCs4,
                       label: block_cdCs4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCs4: // global
           if (R1 & 7 == 1) goto cdCsV; else goto cdCsW;
       cdCsV: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdCsW: // global
           I64[Sp] = block_cdCsa_info;
           _sdyrh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdyrh::P64;
           if (R1 & 7 != 0) goto udCtm; else goto cdCsb;
       udCtm: // global
           call _cdCsa(R1) args: 0, res: 0, upd: 0;
       cdCsb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCsa() //  [R1]
         { info_tbl: [(cdCsa,
                       label: block_cdCsa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCsa: // global
           I64[Sp - 8] = block_cdCsf_info;
           R3 = Data.Functor.Classes.$fRead1NonEmpty3_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCsf() //  [R1]
         { info_tbl: [(cdCsf,
                       label: block_cdCsf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCsf: // global
           _sdyrh::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCt8; else goto cdCta;
       cdCt8: // global
           P64[Sp + 40] = _sdyrh::P64;
           Sp = Sp + 32;
           call _cdCs1() args: 0, res: 0, upd: 0;
       cdCta: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCtd; else goto cdCtc;
       cdCtd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCtc: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdyrh::P64;
           I64[Hp - 16] = go2_sdyrn_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           I64[Sp + 32] = block_cdCt9_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCt9() //  [R1]
         { info_tbl: [(cdCt9,
                       label: block_cdCt9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCt9: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_sdyrn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyr4_entry() //  [R1, R2]
         { info_tbl: [(cdCtt,
                       label: go_sdyr4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCtt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCtu; else goto cdCtv;
       cdCtu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCtv: // global
           I64[Sp - 24] = block_cdCrN_info;
           _sdyr4::P64 = R1;
           _sdyr1::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyr1::P64;
           P64[Sp - 8] = _sdyr4::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCtI; else goto cdCrO;
       udCtI: // global
           call _cdCrN(R1) args: 0, res: 0, upd: 0;
       cdCrO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCrN() //  [R1]
         { info_tbl: [(cdCrN,
                       label: block_cdCrN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCrN: // global
           if (R1 & 7 == 1) goto cdCtq; else goto cdCtr;
       cdCtq: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCtr: // global
           I64[Sp - 8] = block_cdCrT_info;
           _sdyr8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyr8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCtH; else goto cdCrU;
       udCtH: // global
           call _cdCrT(R1) args: 0, res: 0, upd: 0;
       cdCrU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCrT() //  [R1]
         { info_tbl: [(cdCrT,
                       label: block_cdCrT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCrT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdCtC; else goto cdCtB;
       cdCtC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCtB: // global
           _sdyra::P64 = P64[R1 + 7];
           _sdyrb::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyrd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _sdyra::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 16] = block_cdCty_info;
           R3 = _sdyrb::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCty() //  [R1]
         { info_tbl: [(cdCty,
                       label: block_cdCty_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCty: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyrd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyrE_entry() //  [R1, R2]
         { info_tbl: [(cdCtQ,
                       label: sat_sdyrE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCtQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCtR; else goto cdCtS;
       cdCtR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCtS: // global
           I64[Sp - 16] = block_cdCtO_info;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           _sdyr4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdyr4::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCtO() //  [R1]
         { info_tbl: [(cdCtO,
                       label: block_cdCtO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCtO: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyr4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdCtY,
                       label: Data.Functor.Classes.$w$cliftReadsPrec5_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCtY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdCu2; else goto cdCu1;
       cdCu2: // global
           HpAlloc = 40;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec5_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdCu1: // global
           I64[Hp - 32] = go_sdyr4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdyrE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 31;
           _sdyrB::P64 = I64[(%MO_S_Gt_W64(R4,
                                           5) << 3) + GHC.Types.Bool_closure_tbl];
           R4 = R5;
           R3 = Hp - 15;
           R2 = _sdyrB::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.922362578 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdCvI,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCvI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCvJ; else goto cdCvK;
       cdCvJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCvK: // global
           I64[Sp - 32] = block_cdCvF_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCvO; else goto cdCvG;
       udCvO: // global
           call _cdCvF(R1) args: 0, res: 0, upd: 0;
       cdCvG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCvF() //  [R1]
         { info_tbl: [(cdCvF,
                       label: block_cdCvF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCvF: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.928244865 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Proxy4_bytes" {
     Data.Functor.Classes.$fRead1Proxy4_bytes:
         I8[] [80,114,111,120,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.930182289 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy3_closure" {
     Data.Functor.Classes.$fRead1Proxy3_closure:
         const Data.Functor.Classes.$fRead1Proxy3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy3_entry() //  [R1]
         { info_tbl: [(cdCw5,
                       label: Data.Functor.Classes.$fRead1Proxy3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCw5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCw6; else goto cdCw7;
       cdCw6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCw7: // global
           (_cdCw2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdCw2::I64 == 0) goto cdCw4; else goto cdCw3;
       cdCw4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdCw3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdCw2::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.93417662 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_lexeme_closure" {
     Data.Functor.Classes.$fRead1Proxy_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.936399819 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy2_closure" {
     Data.Functor.Classes.$fRead1Proxy2_closure:
         const Data.Functor.Classes.$fRead1Proxy2_info;
         const 0;
 },
 sat_sdyrO_entry() //  [R1]
         { info_tbl: [(cdCwp,
                       label: sat_sdyrO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCwp: // global
           R2 = Data.Proxy.Proxy_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Proxy2_entry() //  [R2, R3]
         { info_tbl: [(cdCwv,
                       label: Data.Functor.Classes.$fRead1Proxy2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCwv: // global
           _sdyrM::P64 = R3;
           _sdyrL::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdCww; else goto cdCwx;
       cdCwx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCwz; else goto cdCwy;
       cdCwz: // global
           HpAlloc = 16;
           goto cdCww;
       cdCww: // global
           R3 = _sdyrM::P64;
           R2 = _sdyrL::P64;
           R1 = Data.Functor.Classes.$fRead1Proxy2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCwy: // global
           I64[Hp - 8] = sat_sdyrO_info;
           P64[Hp] = _sdyrM::P64;
           I64[Sp - 8] = block_cdCws_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Proxy_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCws() //  [R1]
         { info_tbl: [(cdCws,
                       label: block_cdCws_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCws: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCwC; else goto cdCwB;
       cdCwC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCwB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.944052957 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy1_closure" {
     Data.Functor.Classes.$fRead1Proxy1_closure:
         const Data.Functor.Classes.$fRead1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy1_entry() //  [R2, R3]
         { info_tbl: [(cdCwT,
                       label: Data.Functor.Classes.$fRead1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCwT: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.947576134 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy5_closure" {
     Data.Functor.Classes.$fRead1Proxy5_closure:
         const Data.Functor.Classes.$fRead1Proxy5_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy5_entry() //  [R4, R5]
         { info_tbl: [(cdCx4,
                       label: Data.Functor.Classes.$fRead1Proxy5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCx4: // global
           R3 = R5;
           R2 = R4;
           call Data.Functor.Classes.$fRead1Proxy1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.951818759 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_entry() //  [R3]
         { info_tbl: [(cdCxf,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCxf: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.955653324 UTC

[section ""cstring" . Data.Functor.Classes.$fShow1NonEmpty1_bytes" {
     Data.Functor.Classes.$fShow1NonEmpty1_bytes:
         I8[] [32,58,124,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.958982325 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec1_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec1_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec1_info;
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCxo: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 f_sdys1_entry() //  [R1]
         { info_tbl: [(cdCxw,
                       label: f_sdys1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCxw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCxx; else goto cdCxy;
       cdCxx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCxy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdys6_entry() //  [R1]
         { info_tbl: [(cdCxN,
                       label: sat_sdys6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCxN: // global
           _sdys6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCxO; else goto cdCxP;
       cdCxP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCxR; else goto cdCxQ;
       cdCxR: // global
           HpAlloc = 32;
           goto cdCxO;
       cdCxO: // global
           R1 = _sdys6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCxQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdys6::P64;
           _sdys2::P64 = P64[_sdys6::P64 + 16];
           _sdys4::P64 = P64[_sdys6::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys4::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdys7_entry() //  [R1, R2]
         { info_tbl: [(cdCxS,
                       label: sat_sdys7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCxS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCxW; else goto cdCxV;
       cdCxW: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCxV: // global
           _sdys1::P64 = P64[R1 + 7];
           _sdys2::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdys6_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdys1::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdysa_entry() //  [R1]
         { info_tbl: [(cdCyg,
                       label: sat_sdysa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCyg: // global
           _sdysa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCyh; else goto cdCyi;
       cdCyi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCyk; else goto cdCyj;
       cdCyk: // global
           HpAlloc = 24;
           goto cdCyh;
       cdCyh: // global
           R1 = _sdysa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCyj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysa::P64;
           _sdys2::P64 = P64[_sdysa::P64 + 16];
           _sdys8::P64 = P64[_sdysa::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdys8::P64;
           R2 = Hp - 14;
           R1 = _sdys2::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysb_entry() //  [R1]
         { info_tbl: [(cdCyl,
                       label: sat_sdysb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCyl: // global
           _sdysb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCym; else goto cdCyn;
       cdCyn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCyp; else goto cdCyo;
       cdCyp: // global
           HpAlloc = 32;
           goto cdCym;
       cdCym: // global
           R1 = _sdysb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCyo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysb::P64;
           _sdys2::P64 = P64[_sdysb::P64 + 16];
           _sdys8::P64 = P64[_sdysb::P64 + 24];
           I64[Hp - 24] = sat_sdysa_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys8::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysc_entry() //  [R1]
         { info_tbl: [(cdCyq,
                       label: sat_sdysc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCyq: // global
           _sdysc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCyr; else goto cdCys;
       cdCys: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCyu; else goto cdCyt;
       cdCyu: // global
           HpAlloc = 32;
           goto cdCyr;
       cdCyr: // global
           R1 = _sdysc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCyt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdysc::P64;
           _sdys1::P64 = P64[_sdysc::P64 + 16];
           _sdys2::P64 = P64[_sdysc::P64 + 24];
           _sdys8::P64 = P64[_sdysc::P64 + 32];
           I64[Hp - 24] = sat_sdysb_info;
           P64[Hp - 8] = _sdys2::P64;
           P64[Hp] = _sdys8::P64;
           R2 = Hp - 24;
           R1 = _sdys1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdysd_entry() //  [R1, R2]
         { info_tbl: [(cdCyw,
                       label: sat_sdysd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCyw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdCyA; else goto cdCyz;
       cdCyA: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCyz: // global
           _sdys1::P64 = P64[R1 + 7];
           _sdys2::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdysc_info;
           P64[Hp - 40] = _sdys1::P64;
           P64[Hp - 32] = _sdys2::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cdCyE,
                       label: Data.Functor.Classes.$w$cliftShowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCyE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdCyI; else goto cdCyH;
       cdCyI: // global
           HpAlloc = 88;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdCyH: // global
           I64[Hp - 80] = f_sdys1_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdCxs::P64 = Hp - 80;
           _cdCxz::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 5)) goto cdCyC; else goto cdCyD;
       cdCyC: // global
           I64[Hp - 16] = sat_sdys7_info;
           P64[Hp - 8] = _cdCxs::P64;
           P64[Hp] = _cdCxz::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCyD: // global
           I64[Hp - 16] = sat_sdysd_info;
           P64[Hp - 8] = _cdCxs::P64;
           P64[Hp] = _cdCxz::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.986010536 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdCzq,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCzq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCzu; else goto cdCzv;
       cdCzu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCzv: // global
           I64[Sp - 32] = block_cdCzn_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCzD; else goto cdCzo;
       udCzD: // global
           call _cdCzn(R1) args: 0, res: 0, upd: 0;
       cdCzo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCzn() //  [R1]
         { info_tbl: [(cdCzn,
                       label: block_cdCzn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCzn: // global
           I64[Sp] = block_cdCzt_info;
           _sdysj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sdysj::I64;
           if (R1 & 7 != 0) goto udCzC; else goto cdCzx;
       udCzC: // global
           call _cdCzt(R1) args: 0, res: 0, upd: 0;
       cdCzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCzt() //  [R1]
         { info_tbl: [(cdCzt,
                       label: block_cdCzt_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCzt: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:44.995384148 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy2_closure" {
     Data.Functor.Classes.$fShow1Proxy2_closure:
         const Data.Functor.Classes.$fShow1Proxy2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy2_entry() //  [R2]
         { info_tbl: [(cdCzV,
                       label: Data.Functor.Classes.$fShow1Proxy2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCzV: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.000240912 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_entry() //  [R6]
         { info_tbl: [(cdCA6,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCA6: // global
           R2 = R6;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.005424337 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdCAk,
                       label: Data.Functor.Classes.$fEq2(,)_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCAk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdCAo; else goto cdCAp;
       cdCAo: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCAp: // global
           I64[Sp - 32] = block_cdCAh_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCAJ; else goto cdCAi;
       udCAJ: // global
           call _cdCAh(R1) args: 0, res: 0, upd: 0;
       cdCAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCAh() //  [R1]
         { info_tbl: [(cdCAh,
                       label: block_cdCAh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCAh: // global
           I64[Sp - 8] = block_cdCAn_info;
           _sdysw::P64 = P64[R1 + 7];
           _sdysx::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdysx::P64;
           P64[Sp + 24] = _sdysw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCAI; else goto cdCAr;
       udCAI: // global
           call _cdCAn(R1) args: 0, res: 0, upd: 0;
       cdCAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCAn() //  [R1]
         { info_tbl: [(cdCAn,
                       label: block_cdCAn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCAn: // global
           I64[Sp] = block_cdCAv_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdysA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdysA::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCAv() //  [R1]
         { info_tbl: [(cdCAv,
                       label: block_cdCAv_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCAv: // global
           if (R1 & 7 == 1) goto cdCAC; else goto cdCAG;
       cdCAC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCAG: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.015941554 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_closure" {
     Data.Functor.Classes.$fEq2(,)_closure:
         const Data.Functor.Classes.$fEq2(,)_info;
 },
 Data.Functor.Classes.$fEq2(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCB7,
                       label: Data.Functor.Classes.$fEq2(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCB7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.019711481 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1(,)_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1(,)_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1(,)_$cliftEq_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCBl,
                       label: Data.Functor.Classes.$fEq1(,)_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCBl: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdCBp; else goto cdCBq;
       cdCBp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1(,)_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCBq: // global
           I64[Sp - 32] = block_cdCBi_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCBK; else goto cdCBj;
       udCBK: // global
           call _cdCBi(R1) args: 0, res: 0, upd: 0;
       cdCBj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCBi() //  [R1]
         { info_tbl: [(cdCBi,
                       label: block_cdCBi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCBi: // global
           I64[Sp - 8] = block_cdCBo_info;
           _sdysH::P64 = P64[R1 + 7];
           _sdysI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdysI::P64;
           P64[Sp + 24] = _sdysH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCBJ; else goto cdCBs;
       udCBJ: // global
           call _cdCBo(R1) args: 0, res: 0, upd: 0;
       cdCBs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCBo() //  [R1]
         { info_tbl: [(cdCBo,
                       label: block_cdCBo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCBo: // global
           I64[Sp] = block_cdCBw_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdCBw() //  [R1]
         { info_tbl: [(cdCBw,
                       label: block_cdCBw_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCBw: // global
           if (R1 & 7 == 1) goto cdCBD; else goto cdCBH;
       cdCBD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCBH: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.028866144 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_closure" {
     Data.Functor.Classes.$fEq1(,)_closure:
         const Data.Functor.Classes.$fEq1(,)_info;
 },
 Data.Functor.Classes.$fEq1(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCCb,
                       label: Data.Functor.Classes.$fEq1(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCCb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1(,)_$cliftEq_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.032810542 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Either_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Either_$cliftEq2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdCCt,
                       label: Data.Functor.Classes.$fEq2Either_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCCt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCCu; else goto cdCCv;
       cdCCu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2Either_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCCv: // global
           I64[Sp - 32] = block_cdCCm_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCD6; else goto cdCCn;
       udCD6: // global
           call _cdCCm(R1) args: 0, res: 0, upd: 0;
       cdCCn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCCm() //  [R1]
         { info_tbl: [(cdCCm,
                       label: block_cdCCm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCCm: // global
           _sdysQ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCCq; else goto cdCCr;
       cdCCq: // global
           I64[Sp] = block_cdCCy_info;
           _sdysS::P64 = P64[R1 + 7];
           R1 = _sdysQ::P64;
           P64[Sp + 24] = _sdysS::P64;
           if (R1 & 7 != 0) goto udCD4; else goto cdCCA;
       udCD4: // global
           call _cdCCy(R1) args: 0, res: 0, upd: 0;
       cdCCA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCCr: // global
           I64[Sp + 8] = block_cdCCN_info;
           _sdysW::P64 = P64[R1 + 6];
           R1 = _sdysQ::P64;
           P64[Sp + 24] = _sdysW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udCD5; else goto cdCCP;
       udCD5: // global
           call _cdCCN(R1) args: 0, res: 0, upd: 0;
       cdCCP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCCy() //  [R1]
         { info_tbl: [(cdCCy,
                       label: block_cdCCy_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCCy: // global
           if (R1 & 7 == 1) goto cdCCG; else goto udCD3;
       cdCCG: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       udCD3: // global
           Sp = Sp + 32;
           call _cdCCV() args: 0, res: 0, upd: 0;
     }
 },
 _cdCCN() //  [R1]
         { info_tbl: [(cdCCN,
                       label: block_cdCCN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCCN: // global
           if (R1 & 7 == 1) goto udCD2; else goto cdCCZ;
       udCD2: // global
           Sp = Sp + 24;
           call _cdCCV() args: 0, res: 0, upd: 0;
       cdCCZ: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCCV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCCV: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.043873481 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_closure" {
     Data.Functor.Classes.$fEq2Either_closure:
         const Data.Functor.Classes.$fEq2Either_info;
 },
 Data.Functor.Classes.$fEq2Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCDD,
                       label: Data.Functor.Classes.$fEq2Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCDD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Either_$cliftEq2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.048618232 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Either_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Either_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Either_$cliftEq_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdCDV,
                       label: Data.Functor.Classes.$fEq1Either_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCDV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCDW; else goto cdCDX;
       cdCDW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Either_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCDX: // global
           I64[Sp - 32] = block_cdCDO_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCEy; else goto cdCDP;
       udCEy: // global
           call _cdCDO(R1) args: 0, res: 0, upd: 0;
       cdCDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCDO() //  [R1]
         { info_tbl: [(cdCDO,
                       label: block_cdCDO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCDO: // global
           _sdyt3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCDS; else goto cdCDT;
       cdCDS: // global
           I64[Sp] = block_cdCE0_info;
           _sdyt5::P64 = P64[R1 + 7];
           R1 = _sdyt3::P64;
           P64[Sp + 24] = _sdyt5::P64;
           if (R1 & 7 != 0) goto udCEw; else goto cdCE2;
       udCEw: // global
           call _cdCE0(R1) args: 0, res: 0, upd: 0;
       cdCE2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCDT: // global
           I64[Sp + 8] = block_cdCEf_info;
           _sdyt9::P64 = P64[R1 + 6];
           R1 = _sdyt3::P64;
           P64[Sp + 24] = _sdyt9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udCEx; else goto cdCEh;
       udCEx: // global
           call _cdCEf(R1) args: 0, res: 0, upd: 0;
       cdCEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCE0() //  [R1]
         { info_tbl: [(cdCE0,
                       label: block_cdCE0_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCE0: // global
           if (R1 & 7 == 1) goto cdCE8; else goto udCEv;
       cdCE8: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
       udCEv: // global
           Sp = Sp + 32;
           call _cdCEn() args: 0, res: 0, upd: 0;
     }
 },
 _cdCEf() //  [R1]
         { info_tbl: [(cdCEf,
                       label: block_cdCEf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCEf: // global
           if (R1 & 7 == 1) goto udCEu; else goto cdCEr;
       udCEu: // global
           Sp = Sp + 24;
           call _cdCEn() args: 0, res: 0, upd: 0;
       cdCEr: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCEn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCEn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.059051191 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_closure" {
     Data.Functor.Classes.$fEq1Either_closure:
         const Data.Functor.Classes.$fEq1Either_info;
 },
 Data.Functor.Classes.$fEq1Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCF7,
                       label: Data.Functor.Classes.$fEq1Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCF7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Either_$cliftEq_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.062669873 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Const_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Const_$cliftEq2_entry() //  [R2, R4, R5]
         { info_tbl: [(cdCFi,
                       label: Data.Functor.Classes.$fEq2Const_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCFi: // global
           R3 = R5;
           _sdytd::P64 = R2;
           R2 = R4;
           R1 = _sdytd::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.066156857 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_closure" {
     Data.Functor.Classes.$fEq2Const_closure:
         const Data.Functor.Classes.$fEq2Const_info;
 },
 Data.Functor.Classes.$fEq2Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCFt,
                       label: Data.Functor.Classes.$fEq2Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCFt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Const_$cliftEq2_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.069588278 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Const_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Const_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Const_$cliftEq_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdCFE,
                       label: Data.Functor.Classes.$fEq1Const_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCFE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdCFF; else goto cdCFG;
       cdCFF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Const_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCFG: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.073448489 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_closure" {
     Data.Functor.Classes.$fEq1Const_closure:
         const Data.Functor.Classes.$fEq1Const_info;
 },
 Data.Functor.Classes.$fEq1Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCFQ,
                       label: Data.Functor.Classes.$fEq1Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCFQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Const_$cliftEq_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.077816725 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdCG4,
                       label: Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCG4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdCG8; else goto cdCG9;
       cdCG8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCG9: // global
           I64[Sp - 32] = block_cdCG1_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCGy; else goto cdCG2;
       udCGy: // global
           call _cdCG1(R1) args: 0, res: 0, upd: 0;
       cdCG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCG1() //  [R1]
         { info_tbl: [(cdCG1,
                       label: block_cdCG1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCG1: // global
           I64[Sp - 8] = block_cdCG7_info;
           _sdytq::P64 = P64[R1 + 7];
           _sdytr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdytr::P64;
           P64[Sp + 24] = _sdytq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCGx; else goto cdCGb;
       udCGx: // global
           call _cdCG7(R1) args: 0, res: 0, upd: 0;
       cdCGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCG7() //  [R1]
         { info_tbl: [(cdCG7,
                       label: block_cdCG7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCG7: // global
           I64[Sp] = block_cdCGf_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdytu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdytu::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCGf() //  [R1]
         { info_tbl: [(cdCGf,
                       label: block_cdCGf_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCGf: // global
           _cdCGv::P64 = R1 & 7;
           if (_cdCGv::P64 < 3) goto udCGw; else goto cdCGu;
       udCGw: // global
           if (_cdCGv::P64 < 2) goto cdCGm; else goto cdCGq;
       cdCGm: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCGq: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCGu: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.087510927 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_closure" {
     Data.Functor.Classes.$fOrd2(,)_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.090124162 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare_closure" {
     Data.Functor.Classes.$w$cliftCompare_closure:
         const Data.Functor.Classes.$w$cliftCompare_info;
 },
 Data.Functor.Classes.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdCH4,
                       label: Data.Functor.Classes.$w$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCH4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdCH5; else goto cdCH6;
       cdCH5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdCH6: // global
           I64[Sp - 24] = block_cdCGX_info;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = R4;
           P64[Sp - 32] = R6;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdCGX() //  [R1]
         { info_tbl: [(cdCGX,
                       label: block_cdCGX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCGX: // global
           _cdCH3::P64 = R1 & 7;
           if (_cdCH3::P64 < 3) goto udCHg; else goto cdCH2;
       udCHg: // global
           if (_cdCH3::P64 < 2) goto cdCH0; else goto cdCH1;
       cdCH0: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCH1: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCH2: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.096437052 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdCHz,
                       label: Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCHz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdCHD; else goto cdCHE;
       cdCHD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCHE: // global
           I64[Sp - 32] = block_cdCHw_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCHM; else goto cdCHx;
       udCHM: // global
           call _cdCHw(R1) args: 0, res: 0, upd: 0;
       cdCHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCHw() //  [R1]
         { info_tbl: [(cdCHw,
                       label: block_cdCHw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCHw: // global
           I64[Sp - 8] = block_cdCHC_info;
           _sdytI::P64 = P64[R1 + 7];
           _sdytJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdytJ::P64;
           P64[Sp + 24] = _sdytI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCHL; else goto cdCHG;
       udCHL: // global
           call _cdCHC(R1) args: 0, res: 0, upd: 0;
       cdCHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCHC() //  [R1]
         { info_tbl: [(cdCHC,
                       label: block_cdCHC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCHC: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.104769419 UTC

[section ""data" . Data.Functor.Classes.$w$cp1Ord1_closure" {
     Data.Functor.Classes.$w$cp1Ord1_closure:
         const Data.Functor.Classes.$w$cp1Ord1_info;
 },
 Data.Functor.Classes.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdCI7,
                       label: Data.Functor.Classes.$w$cp1Ord1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCI7: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdCI8; else goto cdCI9;
       cdCI8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cp1Ord1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdCI9: // global
           I64[Sp - 40] = block_cdCI5_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCI5() //  [R1]
         { info_tbl: [(cdCI5,
                       label: block_cdCI5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCI5: // global
           I64[Sp] = block_cdCIc_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdCIc() //  [R1]
         { info_tbl: [(cdCIc,
                       label: block_cdCIc_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCIc: // global
           if (R1 & 7 == 1) goto cdCIj; else goto cdCIn;
       cdCIj: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCIn: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.112584038 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)1_closure" {
     Data.Functor.Classes.$fOrd1(,)1_closure:
         const Data.Functor.Classes.$fOrd1(,)1_info;
 },
 Data.Functor.Classes.$fOrd1(,)1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCIM,
                       label: Data.Functor.Classes.$fOrd1(,)1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCIM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdCIQ; else goto cdCIR;
       cdCIQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCIR: // global
           I64[Sp - 32] = block_cdCIJ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCIZ; else goto cdCIK;
       udCIZ: // global
           call _cdCIJ(R1) args: 0, res: 0, upd: 0;
       cdCIK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCIJ() //  [R1]
         { info_tbl: [(cdCIJ,
                       label: block_cdCIJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCIJ: // global
           I64[Sp - 8] = block_cdCIP_info;
           _sdyu0::P64 = P64[R1 + 7];
           _sdyu1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdyu1::P64;
           P64[Sp + 24] = _sdyu0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udCIY; else goto cdCIT;
       udCIY: // global
           call _cdCIP(R1) args: 0, res: 0, upd: 0;
       cdCIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCIP() //  [R1]
         { info_tbl: [(cdCIP,
                       label: block_cdCIP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCIP: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.121623907 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_closure" {
     Data.Functor.Classes.$fOrd1(,)_closure:
         const Data.Functor.Classes.$fOrd1(,)_info;
 },
 sat_sdyu7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdCJn,
                       label: sat_sdyu7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCJn: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyu6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdCJv,
                       label: sat_sdyu6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCJv: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1(,)_entry() //  [R2]
         { info_tbl: [(cdCJz,
                       label: Data.Functor.Classes.$fOrd1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCJz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCJD; else goto cdCJC;
       cdCJD: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCJC: // global
           I64[Hp - 48] = sat_sdyu7_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyu6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.129679364 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Either_$cliftCompare2_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdCK2,
                       label: Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCK2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCK3; else goto cdCK4;
       cdCK3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCK4: // global
           I64[Sp - 32] = block_cdCJV_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCKD; else goto cdCJW;
       udCKD: // global
           call _cdCJV(R1) args: 0, res: 0, upd: 0;
       cdCJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCJV() //  [R1]
         { info_tbl: [(cdCJV,
                       label: block_cdCJV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCJV: // global
           _sdyub::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCJZ; else goto cdCK0;
       cdCJZ: // global
           I64[Sp] = block_cdCK7_info;
           _sdyud::P64 = P64[R1 + 7];
           R1 = _sdyub::P64;
           P64[Sp + 24] = _sdyud::P64;
           if (R1 & 7 != 0) goto udCKB; else goto cdCK9;
       udCKB: // global
           call _cdCK7(R1) args: 0, res: 0, upd: 0;
       cdCK9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCK0: // global
           I64[Sp + 8] = block_cdCKm_info;
           _sdyuh::P64 = P64[R1 + 6];
           R1 = _sdyub::P64;
           P64[Sp + 24] = _sdyuh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udCKC; else goto cdCKo;
       udCKC: // global
           call _cdCKm(R1) args: 0, res: 0, upd: 0;
       cdCKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCK7() //  [R1]
         { info_tbl: [(cdCK7,
                       label: block_cdCK7_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCK7: // global
           if (R1 & 7 == 1) goto cdCKf; else goto cdCKj;
       cdCKf: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCKj: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCKm() //  [R1]
         { info_tbl: [(cdCKm,
                       label: block_cdCKm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCKm: // global
           if (R1 & 7 == 1) goto cdCKu; else goto cdCKy;
       cdCKu: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCKy: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.139596953 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_closure" {
     Data.Functor.Classes.$fOrd2Either_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.142171213 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Either_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdCLf,
                       label: Data.Functor.Classes.$fOrd1Either_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCLf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCLg; else goto cdCLh;
       cdCLg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCLh: // global
           I64[Sp - 32] = block_cdCL8_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCLQ; else goto cdCL9;
       udCLQ: // global
           call _cdCL8(R1) args: 0, res: 0, upd: 0;
       cdCL9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCL8() //  [R1]
         { info_tbl: [(cdCL8,
                       label: block_cdCL8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCL8: // global
           _sdyuo::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCLc; else goto cdCLd;
       cdCLc: // global
           I64[Sp] = block_cdCLk_info;
           _sdyuq::P64 = P64[R1 + 7];
           R1 = _sdyuo::P64;
           P64[Sp + 24] = _sdyuq::P64;
           if (R1 & 7 != 0) goto udCLO; else goto cdCLm;
       udCLO: // global
           call _cdCLk(R1) args: 0, res: 0, upd: 0;
       cdCLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCLd: // global
           I64[Sp + 8] = block_cdCLz_info;
           _sdyuu::P64 = P64[R1 + 6];
           R1 = _sdyuo::P64;
           P64[Sp + 24] = _sdyuu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udCLP; else goto cdCLB;
       udCLP: // global
           call _cdCLz(R1) args: 0, res: 0, upd: 0;
       cdCLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCLk() //  [R1]
         { info_tbl: [(cdCLk,
                       label: block_cdCLk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCLk: // global
           if (R1 & 7 == 1) goto cdCLs; else goto cdCLw;
       cdCLs: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
       cdCLw: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCLz() //  [R1]
         { info_tbl: [(cdCLz,
                       label: block_cdCLz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCLz: // global
           if (R1 & 7 == 1) goto cdCLH; else goto cdCLL;
       cdCLH: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdCLL: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.15347859 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either1_closure" {
     Data.Functor.Classes.$fOrd1Either1_closure:
         const Data.Functor.Classes.$fOrd1Either1_info;
 },
 Data.Functor.Classes.$fOrd1Either1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCMt,
                       label: Data.Functor.Classes.$fOrd1Either1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCMt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCMu; else goto cdCMv;
       cdCMu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCMv: // global
           I64[Sp - 32] = block_cdCMm_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCNb; else goto cdCMn;
       udCNb: // global
           call _cdCMm(R1) args: 0, res: 0, upd: 0;
       cdCMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCMm() //  [R1]
         { info_tbl: [(cdCMm,
                       label: block_cdCMm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCMm: // global
           _sdyuB::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdCMq; else goto cdCMr;
       cdCMq: // global
           I64[Sp] = block_cdCMy_info;
           _sdyuD::P64 = P64[R1 + 7];
           R1 = _sdyuB::P64;
           P64[Sp + 24] = _sdyuD::P64;
           if (R1 & 7 != 0) goto udCN9; else goto cdCMA;
       udCN9: // global
           call _cdCMy(R1) args: 0, res: 0, upd: 0;
       cdCMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdCMr: // global
           I64[Sp + 8] = block_cdCMS_info;
           _sdyuI::P64 = P64[R1 + 6];
           R1 = _sdyuB::P64;
           P64[Sp + 24] = _sdyuI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udCNa; else goto cdCMU;
       udCNa: // global
           call _cdCMS(R1) args: 0, res: 0, upd: 0;
       cdCMU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCMy() //  [R1]
         { info_tbl: [(cdCMy,
                       label: block_cdCMy_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCMy: // global
           if (R1 & 7 == 1) goto cdCMH; else goto udCN8;
       cdCMH: // global
           _sdyuy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdCME_info;
           R2 = _sdyuy::P64;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       udCN8: // global
           Sp = Sp + 32;
           call _cdCN0() args: 0, res: 0, upd: 0;
     }
 },
 _cdCME() //  [R1]
         { info_tbl: [(cdCME,
                       label: block_cdCME_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCME: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sdyuF::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sdyuF::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdCMS() //  [R1]
         { info_tbl: [(cdCMS,
                       label: block_cdCMS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCMS: // global
           if (R1 & 7 == 1) goto udCN7; else goto cdCN4;
       udCN7: // global
           Sp = Sp + 24;
           call _cdCN0() args: 0, res: 0, upd: 0;
       cdCN4: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdCN0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCN0: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.16766767 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_closure" {
     Data.Functor.Classes.$fOrd1Either_closure:
         const Data.Functor.Classes.$fOrd1Either_info;
 },
 sat_sdyuO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdCNS,
                       label: sat_sdyuO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCNS: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyuN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdCO0,
                       label: sat_sdyuN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCO0: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Either_entry() //  [R2]
         { info_tbl: [(cdCO4,
                       label: Data.Functor.Classes.$fOrd1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCO4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCO8; else goto cdCO7;
       cdCO8: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCO7: // global
           I64[Hp - 48] = sat_sdyuO_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyuN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.177073447 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Const_$cliftCompare2_entry() //  [R2,
                                                              R4, R5]
         { info_tbl: [(cdCOq,
                       label: Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCOq: // global
           R3 = R5;
           _sdyuP::P64 = R2;
           R2 = R4;
           R1 = _sdyuP::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.181180734 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_closure" {
     Data.Functor.Classes.$fOrd2Const_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.183915166 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const1_closure" {
     Data.Functor.Classes.$fOrd1Const1_closure:
         const Data.Functor.Classes.$fOrd1Const1_info;
 },
 Data.Functor.Classes.$fOrd1Const1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCOE,
                       label: Data.Functor.Classes.$fOrd1Const1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCOE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdCOF; else goto cdCOG;
       cdCOF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCOG: // global
           I64[Sp - 24] = block_cdCOC_info;
           R2 = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCOC() //  [R1]
         { info_tbl: [(cdCOC,
                       label: block_cdCOC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCOC: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.190796031 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const_closure" {
     Data.Functor.Classes.$fOrd1Const_closure:
         const Data.Functor.Classes.$fOrd1Const_info;
 },
 sat_sdyv3_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdCP1,
                       label: sat_sdyv3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCP1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdCP2; else goto cdCP3;
       cdCP2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCP3: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdyuZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdCP9,
                       label: sat_sdyuZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCP9: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Const1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Const_entry() //  [R2]
         { info_tbl: [(cdCPd,
                       label: Data.Functor.Classes.$fOrd1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCPd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCPh; else goto cdCPg;
       cdCPh: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCPg: // global
           I64[Hp - 48] = sat_sdyv3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyuZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.2004456 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1(,)5_bytes" {
     Data.Functor.Classes.$fRead1(,)5_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.202797351 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)4_closure" {
     Data.Functor.Classes.$fRead1(,)4_closure:
         const Data.Functor.Classes.$fRead1(,)4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)4_entry() //  [R1]
         { info_tbl: [(cdCPD,
                       label: Data.Functor.Classes.$fRead1(,)4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCPD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCPE; else goto cdCPF;
       cdCPE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCPF: // global
           (_cdCPA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdCPA::I64 == 0) goto cdCPC; else goto cdCPB;
       cdCPC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdCPB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdCPA::I64;
           R2 = Data.Functor.Classes.$fRead1(,)5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.207360909 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)3_closure" {
     Data.Functor.Classes.$fRead1(,)3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Functor.Classes.$fRead1(,)4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.21111662 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadPrec2_info;
         const 0;
 },
 sat_sdyvf_entry() //  [R1, R2]
         { info_tbl: [(cdCQd,
                       label: sat_sdyvf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCQh; else goto cdCQg;
       cdCQh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCQg: // global
           _sdyva::P64 = P64[R1 + 7];
           _sdyvb::P64 = P64[R1 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sdyvb::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sdyva::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvg_entry() //  [R1, R2]
         { info_tbl: [(cdCQi,
                       label: sat_sdyvg_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCQm; else goto cdCQl;
       cdCQm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCQl: // global
           _sdyv5::P64 = P64[R1 + 7];
           _sdyv9::P64 = P64[R1 + 15];
           _sdyva::P64 = P64[R1 + 23];
           _sdyvb::P64 = P64[R1 + 31];
           I64[Hp - 16] = sat_sdyvf_info;
           P64[Hp - 8] = _sdyva::P64;
           P64[Hp] = _sdyvb::P64;
           R3 = Hp - 15;
           R2 = _sdyv9::P64;
           R1 = _sdyv5::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvj_entry() //  [R1, R2]
         { info_tbl: [(cdCQq,
                       label: sat_sdyvj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQq: // global
           _sdyvb::P64 = R2;
           _sdyvj::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdCQr; else goto cdCQs;
       cdCQs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdCQu; else goto cdCQt;
       cdCQu: // global
           HpAlloc = 40;
           goto cdCQr;
       cdCQr: // global
           R2 = _sdyvb::P64;
           R1 = _sdyvj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCQt: // global
           _sdyv5::P64 = P64[_sdyvj::P64 + 7];
           _sdyv9::P64 = P64[_sdyvj::P64 + 15];
           _sdyva::P64 = P64[_sdyvj::P64 + 23];
           I64[Hp - 32] = sat_sdyvg_info;
           P64[Hp - 24] = _sdyv5::P64;
           P64[Hp - 16] = _sdyv9::P64;
           P64[Hp - 8] = _sdyva::P64;
           P64[Hp] = _sdyvb::P64;
           I64[Sp - 8] = block_cdCQn_info;
           R3 = Hp - 31;
           R2 = Data.Functor.Classes.$fRead1(,)3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCQn() //  [R1]
         { info_tbl: [(cdCQn,
                       label: block_cdCQn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCQx; else goto cdCQw;
       cdCQx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCQw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 p_sdyv8_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCQy,
                       label: p_sdyv8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCQC; else goto cdCQB;
       cdCQC: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCQB: // global
           _sdyv4::P64 = P64[R1 + 6];
           _sdyv5::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sdyvj_info;
           P64[Hp - 16] = _sdyv5::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 23;
           R2 = R2;
           R1 = _sdyv4::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl3_sdyvk_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCQL,
                       label: lvl3_sdyvk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdCQM; else goto cdCQN;
       cdCQM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCQN: // global
           I64[Sp - 8] = block_cdCQI_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wparen'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCQI() //  [R1]
         { info_tbl: [(cdCQI,
                       label: block_cdCQI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCQQ; else goto cdCQP;
       cdCQQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCQP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvt_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCQZ,
                       label: sat_sdyvt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdCR0; else goto cdCR1;
       cdCR0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCR1: // global
           I64[Sp - 8] = block_cdCQW_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wskipSpacesThenP_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCQW() //  [R1]
         { info_tbl: [(cdCQW,
                       label: block_cdCQW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCQW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCR4; else goto cdCR3;
       cdCR4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCR3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCR5,
                       label: Data.Functor.Classes.$w$cliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCR5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCR9; else goto cdCR8;
       cdCR9: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCR8: // global
           I64[Hp - 48] = p_sdyv8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = lvl3_sdyvk_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sdyvt_info;
           P64[Hp] = Hp - 22;
           _sdyv6::P64 = R4;
           R4 = R5;
           R3 = _sdyv6::P64;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.233526205 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)2_closure" {
     Data.Functor.Classes.$fRead1(,)2_closure:
         const Data.Functor.Classes.$fRead1(,)2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)2_entry() //  [R2, R4, R6]
         { info_tbl: [(cdCRR,
                       label: Data.Functor.Classes.$fRead1(,)2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCRR: // global
           R5 = P64[Sp];
           _sdyvw::P64 = R4;
           R4 = R6;
           R3 = _sdyvw::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.238148533 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec6_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec6_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec6_info;
         const 0;
 },
 sat_sdyvE_entry() //  [R1, R2]
         { info_tbl: [(cdCSb,
                       label: sat_sdyvE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCSb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvD_entry() //  [R1, R2]
         { info_tbl: [(cdCSj,
                       label: sat_sdyvD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCSj: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyvF_entry() //  [R1]
         { info_tbl: [(cdCSm,
                       label: sat_sdyvF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCSm: // global
           _sdyvF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCSn; else goto cdCSo;
       cdCSo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdCSq; else goto cdCSp;
       cdCSq: // global
           HpAlloc = 32;
           goto cdCSn;
       cdCSn: // global
           R1 = _sdyvF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCSp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyvF::P64;
           _sdyvA::P64 = P64[_sdyvF::P64 + 16];
           _sdyvB::P64 = P64[_sdyvF::P64 + 24];
           _sdyvC::P64 = P64[_sdyvF::P64 + 32];
           I64[Hp - 24] = sat_sdyvE_info;
           P64[Hp - 16] = _sdyvB::P64;
           I64[Hp - 8] = sat_sdyvD_info;
           P64[Hp] = _sdyvA::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyvC::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec6_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCSr,
                       label: Data.Functor.Classes.$w$cliftReadsPrec6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCSr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdCSv; else goto cdCSu;
       cdCSv: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCSu: // global
           I64[Hp - 32] = sat_sdyvF_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.249042627 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_entry() //  [R2,
                                                               R4, R6]
         { info_tbl: [(cdCSO,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCSO: // global
           _sdyvI::P64 = R4;
           R4 = R6;
           R3 = _sdyvI::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec6_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.252781725 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyvR_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCT4,
                       label: sat_sdyvR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCT4: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdCT7,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCT7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCTb; else goto cdCTa;
       cdCTb: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCTa: // global
           I64[Hp - 16] = sat_sdyvR_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.25844609 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)3_closure" {
     Data.Functor.Classes.$fShow1(,)3_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.260224297 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity5_closure" {
     Data.Functor.Classes.$fRead1Identity5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.26193107 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)2_closure" {
     Data.Functor.Classes.$fShow1(,)2_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.263576372 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)1_closure" {
     Data.Functor.Classes.$fShow1(,)1_closure:
         const GHC.Types.C#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.266404125 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec2_info;
 },
 f_sdyvW_entry() //  [R1]
         { info_tbl: [(cdCTv,
                       label: f_sdyvW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCTv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCTw; else goto cdCTx;
       cdCTw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCTx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdyvX_entry() //  [R1]
         { info_tbl: [(cdCTC,
                       label: f1_sdyvX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCTC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCTD; else goto cdCTE;
       cdCTD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCTE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw0_entry() //  [R1]
         { info_tbl: [(cdCTT,
                       label: sat_sdyw0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCTT: // global
           _sdyw0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCTU; else goto cdCTV;
       cdCTV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCTX; else goto cdCTW;
       cdCTX: // global
           HpAlloc = 24;
           goto cdCTU;
       cdCTU: // global
           R1 = _sdyw0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCTW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyw0::P64;
           _sdyvX::P64 = P64[_sdyw0::P64 + 16];
           _sdyvY::P64 = P64[_sdyw0::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdyvY::P64;
           R2 = Hp - 14;
           R1 = _sdyvX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw2_entry() //  [R1]
         { info_tbl: [(cdCTZ,
                       label: sat_sdyw2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCTZ: // global
           _sdyw2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCU0; else goto cdCU1;
       cdCU1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCU3; else goto cdCU2;
       cdCU3: // global
           HpAlloc = 56;
           goto cdCU0;
       cdCU0: // global
           R1 = _sdyw2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCU2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyw2::P64;
           _sdyvW::P64 = P64[_sdyw2::P64 + 16];
           _sdyvX::P64 = P64[_sdyw2::P64 + 24];
           _sdyvY::P64 = P64[_sdyw2::P64 + 32];
           I64[Hp - 48] = sat_sdyw0_info;
           P64[Hp - 32] = _sdyvX::P64;
           P64[Hp - 24] = _sdyvY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyvW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyw3_entry() //  [R1, R2]
         { info_tbl: [(cdCU5,
                       label: sat_sdyw3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCU5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdCU9; else goto cdCU8;
       cdCU9: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCU8: // global
           _sdyvW::P64 = P64[R1 + 7];
           _sdyvX::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyw2_info;
           P64[Hp - 40] = _sdyvW::P64;
           P64[Hp - 32] = _sdyvX::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdCUa,
                       label: Data.Functor.Classes.$w$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCUa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdCUe; else goto cdCUd;
       cdCUe: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCUd: // global
           I64[Hp - 80] = f_sdyvW_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = f1_sdyvX_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdyw3_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.282639119 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdCUP,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCUP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCUQ; else goto cdCUR;
       cdCUQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdCUR: // global
           I64[Sp - 16] = block_cdCUM_info;
           R1 = P64[Sp];
           P64[Sp - 8] = R4;
           P64[Sp] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udCUV; else goto cdCUN;
       udCUV: // global
           call _cdCUM(R1) args: 0, res: 0, upd: 0;
       cdCUN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCUM() //  [R1]
         { info_tbl: [(cdCUM,
                       label: block_cdCUM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCUM: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.288628866 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList2_closure" {
     Data.Functor.Classes.$dmliftShowList2_closure:
         const Data.Functor.Classes.$dmliftShowList2_info;
 },
 sat_sdywi_entry() //  [R1]
         { info_tbl: [(cdCVd,
                       label: sat_sdywi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCVd: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdCVe; else goto cdCVf;
       cdCVe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCVf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 24];
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdCVg,
                       label: Data.Functor.Classes.$dmliftShowList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCVg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdCVk; else goto cdCVj;
       cdCVk: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCVj: // global
           I64[Hp - 48] = sat_sdywi_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.295813992 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList3_closure" {
     Data.Functor.Classes.$w$cliftShowList3_closure:
         const Data.Functor.Classes.$w$cliftShowList3_info;
 },
 sat_sdywt_entry() //  [R1]
         { info_tbl: [(cdCVU,
                       label: sat_sdywt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCVU: // global
           _sdywt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCVV; else goto cdCVW;
       cdCVW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCVY; else goto cdCVX;
       cdCVY: // global
           HpAlloc = 24;
           goto cdCVV;
       cdCVV: // global
           R1 = _sdywt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCVX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywt::P64;
           _sdywk::P64 = P64[_sdywt::P64 + 16];
           _sdywo::P64 = P64[_sdywt::P64 + 24];
           _sdywr::P64 = P64[_sdywt::P64 + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdywo::P64;
           R4 = Hp - 14;
           R3 = _sdywr::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdywk::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywv_entry() //  [R1]
         { info_tbl: [(cdCW0,
                       label: sat_sdywv_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCW0: // global
           _sdywv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdCW1; else goto cdCW2;
       cdCW2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdCW4; else goto cdCW3;
       cdCW4: // global
           HpAlloc = 64;
           goto cdCW1;
       cdCW1: // global
           R1 = _sdywv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCW3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywv::P64;
           _sdywj::P64 = P64[_sdywv::P64 + 16];
           _sdywk::P64 = P64[_sdywv::P64 + 24];
           _sdywo::P64 = P64[_sdywv::P64 + 32];
           _sdywq::P64 = P64[_sdywv::P64 + 40];
           _sdywr::P64 = P64[_sdywv::P64 + 48];
           I64[Hp - 56] = sat_sdywt_info;
           P64[Hp - 40] = _sdywk::P64;
           P64[Hp - 32] = _sdywo::P64;
           P64[Hp - 24] = _sdywr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 56;
           R4 = Hp - 14;
           R3 = _sdywq::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdywj::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyww_entry() //  [R1, R2, R3]
         { info_tbl: [(cdCW5,
                       label: sat_sdyww_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCW5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCW7; else goto cdCW8;
       cdCW7: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCW8: // global
           I64[Sp - 32] = block_cdCVG_info;
           _sdywj::P64 = P64[R1 + 6];
           _sdywk::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdywj::P64;
           P64[Sp - 16] = _sdywk::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udCWc; else goto cdCVH;
       udCWc: // global
           call _cdCVG(R1) args: 0, res: 0, upd: 0;
       cdCVH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCVG() //  [R1]
         { info_tbl: [(cdCVG,
                       label: block_cdCVG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCVG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdCWb; else goto cdCWa;
       cdCWb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCWa: // global
           _sdywq::P64 = P64[R1 + 7];
           _sdywr::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sdywv_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sdywq::P64;
           P64[Hp - 24] = _sdywr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCWd,
                       label: Data.Functor.Classes.$w$cliftShowList3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCWd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCWh; else goto cdCWg;
       cdCWh: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCWg: // global
           I64[Hp - 16] = sat_sdyww_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdywl::P64 = R4;
           R4 = R5;
           R3 = _sdywl::P64;
           R2 = Hp - 14;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.309124804 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info;
 },
 Data.Functor.Classes.$fShow2(,)_$cliftShowList2_entry() //  [R2,
                                                              R4, R6]
         { info_tbl: [(cdCWM,
                       label: Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCWM: // global
           R5 = P64[Sp];
           _sdywz::P64 = R4;
           R4 = R6;
           R3 = _sdywz::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.312693106 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_closure" {
     Data.Functor.Classes.$fShow2(,)_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.315061249 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info;
 },
 sat_sdywL_entry() //  [R1]
         { info_tbl: [(cdCX7,
                       label: sat_sdywL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCX7: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cdCXa,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCXa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdCXb; else goto cdCXc;
       cdCXb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCXc: // global
           I64[Sp - 24] = block_cdCWY_info;
           R1 = R6;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udCXg; else goto cdCWZ;
       udCXg: // global
           call _cdCWY(R1) args: 0, res: 0, upd: 0;
       cdCWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCWY() //  [R1]
         { info_tbl: [(cdCWY,
                       label: block_cdCWY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCWY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdCXf; else goto cdCXe;
       cdCXf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCXe: // global
           _sdywJ::P64 = P64[R1 + 7];
           _sdywK::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdywL_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdywK::P64;
           R4 = _sdywJ::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.325228886 UTC

[section ""data" . $w$dmliftReadListPrec2_rdymu_closure" {
     $w$dmliftReadListPrec2_rdymu_closure:
         const $w$dmliftReadListPrec2_rdymu_info;
 },
 sat_sdywW_entry() //  [R1]
         { info_tbl: [(cdCXG,
                       label: sat_sdywW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCXG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCXH; else goto cdCXI;
       cdCXH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCXI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywX_entry() //  [R1, R2]
         { info_tbl: [(cdCXO,
                       label: sat_sdywX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCXO: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywV_entry() //  [R1, R2]
         { info_tbl: [(cdCXW,
                       label: sat_sdywV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCXW: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywT_entry() //  [R1]
         { info_tbl: [(cdCY3,
                       label: sat_sdywT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCY3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdCY4; else goto cdCY5;
       cdCY4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCY5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdywU_entry() //  [R1, R2]
         { info_tbl: [(cdCYb,
                       label: sat_sdywU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCYb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdywS_entry() //  [R1, R2]
         { info_tbl: [(cdCYj,
                       label: sat_sdywS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCYj: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w5_sdywR_entry() //  [R1]
         { info_tbl: [(cdCYm,
                       label: w5_sdywR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCYm: // global
           _sdywR::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdCYn; else goto cdCYo;
       cdCYo: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdCYq; else goto cdCYp;
       cdCYq: // global
           HpAlloc = 112;
           goto cdCYn;
       cdCYn: // global
           R1 = _sdywR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdCYp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdywR::P64;
           _sdywM::P64 = P64[_sdywR::P64 + 16];
           _sdywN::P64 = P64[_sdywR::P64 + 24];
           _sdywO::P64 = P64[_sdywR::P64 + 32];
           _sdywP::P64 = P64[_sdywR::P64 + 40];
           _sdywQ::P64 = P64[_sdywR::P64 + 48];
           I64[Hp - 104] = sat_sdywW_info;
           P64[Hp - 88] = _sdywQ::P64;
           I64[Hp - 80] = sat_sdywX_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdywV_info;
           P64[Hp - 56] = _sdywP::P64;
           I64[Hp - 48] = sat_sdywT_info;
           P64[Hp - 32] = _sdywO::P64;
           I64[Hp - 24] = sat_sdywU_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdywS_info;
           P64[Hp] = _sdywN::P64;
           R2 = _sdywM::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadList2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyx1_entry() //  [R1, R2]
         { info_tbl: [(cdCYz,
                       label: sat_sdyx1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCYz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdCYA; else goto cdCYB;
       cdCYA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdCYB: // global
           I64[Sp - 8] = block_cdCYw_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdCYw() //  [R1]
         { info_tbl: [(cdCYw,
                       label: block_cdCYw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCYw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdCYE; else goto cdCYD;
       cdCYE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCYD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec2_rdymu_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdCYF,
                       label: $w$dmliftReadListPrec2_rdymu_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCYF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdCYJ; else goto cdCYI;
       cdCYJ: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec2_rdymu_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCYI: // global
           I64[Hp - 64] = w5_sdywR_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyx1_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.345779525 UTC

[section ""data" . $dmliftReadListPrec1_rdymv_closure" {
     $dmliftReadListPrec1_rdymv_closure:
         const $dmliftReadListPrec1_rdymv_info;
 },
 $dmliftReadListPrec1_rdymv_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdCZw,
                       label: $dmliftReadListPrec1_rdymv_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCZw: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call $w$dmliftReadListPrec2_rdymu_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.349676382 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec2_closure" {
     Data.Functor.Classes.$dmliftReadListPrec2_closure:
         const Data.Functor.Classes.$dmliftReadListPrec2_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec2_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdCZH,
                       label: Data.Functor.Classes.$dmliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCZH: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec1_rdymv_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.354685513 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec2_closure" {
     Data.Functor.Classes.$dmliftReadPrec2_closure:
         const Data.Functor.Classes.$dmliftReadPrec2_info;
 },
 sat_sdyxi_entry() //  [R1]
         { info_tbl: [(cdD00,
                       label: sat_sdyxi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD00: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdD01; else goto cdD02;
       cdD01: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD02: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyxj_entry() //  [R1, R2]
         { info_tbl: [(cdD08,
                       label: sat_sdyxj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD08: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxh_entry() //  [R1, R2]
         { info_tbl: [(cdD0g,
                       label: sat_sdyxh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0g: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxf_entry() //  [R1]
         { info_tbl: [(cdD0n,
                       label: sat_sdyxf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdD0o; else goto cdD0p;
       cdD0o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD0p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyxg_entry() //  [R1, R2]
         { info_tbl: [(cdD0v,
                       label: sat_sdyxg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0v: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxe_entry() //  [R1, R2]
         { info_tbl: [(cdD0D,
                       label: sat_sdyxe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0D: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyxd_entry() //  [R1]
         { info_tbl: [(cdD0G,
                       label: f1_sdyxd_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0G: // global
           _sdyxd::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdD0H; else goto cdD0I;
       cdD0I: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdD0K; else goto cdD0J;
       cdD0K: // global
           HpAlloc = 112;
           goto cdD0H;
       cdD0H: // global
           R1 = _sdyxd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD0J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxd::P64;
           _sdyx8::P64 = P64[_sdyxd::P64 + 16];
           _sdyx9::P64 = P64[_sdyxd::P64 + 24];
           _sdyxa::P64 = P64[_sdyxd::P64 + 32];
           _sdyxb::P64 = P64[_sdyxd::P64 + 40];
           _sdyxc::P64 = P64[_sdyxd::P64 + 48];
           I64[Hp - 104] = sat_sdyxi_info;
           P64[Hp - 88] = _sdyxc::P64;
           I64[Hp - 80] = sat_sdyxj_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdyxh_info;
           P64[Hp - 56] = _sdyxb::P64;
           I64[Hp - 48] = sat_sdyxf_info;
           P64[Hp - 32] = _sdyxa::P64;
           I64[Hp - 24] = sat_sdyxg_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyxe_info;
           P64[Hp] = _sdyx9::P64;
           R2 = _sdyx8::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyxp_entry() //  [R1, R2]
         { info_tbl: [(cdD0Z,
                       label: sat_sdyxp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdD10; else goto cdD11;
       cdD10: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD11: // global
           I64[Sp - 8] = block_cdD0W_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdD0W() //  [R1]
         { info_tbl: [(cdD0W,
                       label: block_cdD0W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD0W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdD14; else goto cdD13;
       cdD14: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdD13: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxq_entry() //  [R1, R2]
         { info_tbl: [(cdD15,
                       label: sat_sdyxq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD15: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdD19; else goto cdD18;
       cdD19: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD18: // global
           _sdyxd::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdyxd::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyxp_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdD1a,
                       label: Data.Functor.Classes.$dmliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD1a: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdD1e; else goto cdD1d;
       cdD1e: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD1d: // global
           I64[Hp - 64] = f1_sdyxd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyxq_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.382569956 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList2_closure" {
     Data.Functor.Classes.$dmliftReadList2_closure:
         const Data.Functor.Classes.$dmliftReadList2_info;
         const 0;
 },
 sat_sdyxH_entry() //  [R1, R2, R3]
         { info_tbl: [(cdD2m,
                       label: sat_sdyxH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdD2n; else goto cdD2o;
       cdD2n: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD2o: // global
           I64[Sp - 8] = block_cdD2j_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdD2j() //  [R1]
         { info_tbl: [(cdD2j,
                       label: block_cdD2j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdD2r; else goto cdD2q;
       cdD2r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdD2q: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxC_entry() //  [R1, R2]
         { info_tbl: [(cdD2x,
                       label: sat_sdyxC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2x: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdD2I,
                       label: sat_sdyxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdD2J; else goto cdD2K;
       cdD2J: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD2K: // global
           I64[Sp - 8] = block_cdD2F_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdD2F() //  [R1]
         { info_tbl: [(cdD2F,
                       label: block_cdD2F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdD2N; else goto cdD2M;
       cdD2N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdD2M: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxw_entry() //  [R1, R2]
         { info_tbl: [(cdD2T,
                       label: sat_sdyxw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2T: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxI_entry() //  [R1]
         { info_tbl: [(cdD2W,
                       label: sat_sdyxI_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD2W: // global
           _sdyxI::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdD2X; else goto cdD2Y;
       cdD2Y: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdD30; else goto cdD2Z;
       cdD30: // global
           HpAlloc = 64;
           goto cdD2X;
       cdD2X: // global
           R1 = _sdyxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD2Z: // global
           _sdyxr::P64 = P64[_sdyxI::P64 + 16];
           _sdyxs::P64 = P64[_sdyxI::P64 + 24];
           _sdyxt::P64 = P64[_sdyxI::P64 + 32];
           _sdyxu::P64 = P64[_sdyxI::P64 + 40];
           _sdyxv::P64 = P64[_sdyxI::P64 + 48];
           I64[Hp - 56] = sat_sdyxH_info;
           P64[Hp - 48] = _sdyxv::P64;
           I64[Hp - 40] = sat_sdyxC_info;
           P64[Hp - 32] = _sdyxu::P64;
           I64[Hp - 24] = sat_sdyxB_info;
           P64[Hp - 16] = _sdyxt::P64;
           I64[Hp - 8] = sat_sdyxw_info;
           P64[Hp] = _sdyxs::P64;
           R2 = _sdyxr::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 54;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sdyxJ_entry() //  [R1]
         { info_tbl: [(cdD31,
                       label: sat_sdyxJ_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD31: // global
           _sdyxJ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdD32; else goto cdD33;
       cdD33: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdD35; else goto cdD34;
       cdD35: // global
           HpAlloc = 56;
           goto cdD32;
       cdD32: // global
           R1 = _sdyxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD34: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxJ::P64;
           _sdyxr::P64 = P64[_sdyxJ::P64 + 16];
           _sdyxs::P64 = P64[_sdyxJ::P64 + 24];
           _sdyxt::P64 = P64[_sdyxJ::P64 + 32];
           _sdyxu::P64 = P64[_sdyxJ::P64 + 40];
           _sdyxv::P64 = P64[_sdyxJ::P64 + 48];
           I64[Hp - 48] = sat_sdyxI_info;
           P64[Hp - 32] = _sdyxr::P64;
           P64[Hp - 24] = _sdyxs::P64;
           P64[Hp - 16] = _sdyxt::P64;
           P64[Hp - 8] = _sdyxu::P64;
           P64[Hp] = _sdyxv::P64;
           R2 = Hp - 48;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdD36,
                       label: Data.Functor.Classes.$dmliftReadList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD36: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdD3a; else goto cdD39;
       cdD3a: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD39: // global
           I64[Hp - 48] = sat_sdyxJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.407663317 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec2_closure" {
     Data.Functor.Classes.$dmliftReadsPrec2_closure:
         const Data.Functor.Classes.$dmliftReadsPrec2_info;
 },
 sat_sdyy1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdD43,
                       label: sat_sdyy1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD43: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdD44; else goto cdD45;
       cdD44: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD45: // global
           I64[Sp - 8] = block_cdD40_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdD40() //  [R1]
         { info_tbl: [(cdD40,
                       label: block_cdD40_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD40: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdD48; else goto cdD47;
       cdD48: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdD47: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxW_entry() //  [R1, R2]
         { info_tbl: [(cdD4e,
                       label: sat_sdyxW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4e: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxV_entry() //  [R1, R2, R3]
         { info_tbl: [(cdD4p,
                       label: sat_sdyxV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdD4q; else goto cdD4r;
       cdD4q: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD4r: // global
           I64[Sp - 8] = block_cdD4m_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdD4m() //  [R1]
         { info_tbl: [(cdD4m,
                       label: block_cdD4m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdD4u; else goto cdD4t;
       cdD4u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdD4t: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyxQ_entry() //  [R1, R2]
         { info_tbl: [(cdD4A,
                       label: sat_sdyxQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4A: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdyxP_entry() //  [R1]
         { info_tbl: [(cdD4D,
                       label: ds_sdyxP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4D: // global
           _sdyxP::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdD4E; else goto cdD4F;
       cdD4F: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdD4H; else goto cdD4G;
       cdD4H: // global
           HpAlloc = 64;
           goto cdD4E;
       cdD4E: // global
           R1 = _sdyxP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD4G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyxP::P64;
           _sdyxK::P64 = P64[_sdyxP::P64 + 16];
           _sdyxL::P64 = P64[_sdyxP::P64 + 24];
           _sdyxM::P64 = P64[_sdyxP::P64 + 32];
           _sdyxN::P64 = P64[_sdyxP::P64 + 40];
           _sdyxO::P64 = P64[_sdyxP::P64 + 48];
           I64[Hp - 56] = sat_sdyy1_info;
           P64[Hp - 48] = _sdyxO::P64;
           I64[Hp - 40] = sat_sdyxW_info;
           P64[Hp - 32] = _sdyxN::P64;
           I64[Hp - 24] = sat_sdyxV_info;
           P64[Hp - 16] = _sdyxM::P64;
           I64[Hp - 8] = sat_sdyxQ_info;
           P64[Hp] = _sdyxL::P64;
           R2 = _sdyxK::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Hp - 39;
           P64[Sp - 24] = Hp - 54;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyy3_entry() //  [R1]
         { info_tbl: [(cdD4R,
                       label: sat_sdyy3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdD4S; else goto cdD4T;
       cdD4S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD4T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyy4_entry() //  [R1, R2]
         { info_tbl: [(cdD4U,
                       label: sat_sdyy4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4U: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdD4Y; else goto cdD4X;
       cdD4Y: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD4X: // global
           _sdyxP::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyy3_info;
           P64[Hp - 8] = _sdyxP::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdD4Z,
                       label: Data.Functor.Classes.$dmliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD4Z: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdD53; else goto cdD52;
       cdD53: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD52: // global
           I64[Hp - 64] = ds_sdyxP_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdyy4_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.430804899 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList_closure" {
     Data.Functor.Classes.$dmliftShowList_closure:
         const Data.Functor.Classes.$dmliftShowList_info;
 },
 sat_sdyy8_entry() //  [R1]
         { info_tbl: [(cdD5T,
                       label: sat_sdyy8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD5T: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdD5U; else goto cdD5V;
       cdD5U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD5V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 48;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdD5W,
                       label: Data.Functor.Classes.$dmliftShowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD5W: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdD60; else goto cdD5Z;
       cdD60: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD5Z: // global
           I64[Hp - 32] = sat_sdyy8_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.437524877 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList_closure" {
     Data.Functor.Classes.$w$cliftShowList_closure:
         const Data.Functor.Classes.$w$cliftShowList_info;
 },
 lvl3_sdyyd_entry() //  [R1]
         { info_tbl: [(cdD6j,
                       label: lvl3_sdyyd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD6j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdD6k; else goto cdD6l;
       cdD6k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD6l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyyi_entry() //  [R1, R2]
         { info_tbl: [(cdD6u,
                       label: sat_sdyyi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD6u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdD6v; else goto cdD6w;
       cdD6v: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD6w: // global
           I64[Sp - 24] = block_cdD6r_info;
           _sdyya::P64 = P64[R1 + 7];
           _sdyyd::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyya::P64;
           P64[Sp - 8] = _sdyyd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udD6A; else goto cdD6s;
       udD6A: // global
           call _cdD6r(R1) args: 0, res: 0, upd: 0;
       cdD6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdD6r() //  [R1]
         { info_tbl: [(cdD6r,
                       label: block_cdD6r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD6r: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdD6B,
                       label: Data.Functor.Classes.$w$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD6B: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdD6F; else goto cdD6E;
       cdD6F: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD6E: // global
           I64[Hp - 40] = lvl3_sdyyd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyyi_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdyyb::P64 = R4;
           R4 = R5;
           R3 = _sdyyb::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.447471692 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowList_entry() //  [R2, R3,
                                                             R5, R6]
         { info_tbl: [(cdD71,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD71: // global
           _sdyym::P64 = R5;
           R5 = R6;
           R4 = _sdyym::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.452232947 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_closure" {
     Data.Functor.Classes.$fShow1(,)_closure:
         const Data.Functor.Classes.$fShow1(,)_info;
 },
 sat_sdyyu_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdD7h,
                       label: sat_sdyyu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD7h: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyyp_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdD7p,
                       label: sat_sdyyp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD7p: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_entry() //  [R2]
         { info_tbl: [(cdD7t,
                       label: Data.Functor.Classes.$fShow1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD7t: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdD7x; else goto cdD7w;
       cdD7x: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD7w: // global
           I64[Hp - 48] = sat_sdyyu_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyyp_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.459869158 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy1_closure" {
     Data.Functor.Classes.$fShow1Proxy1_closure:
         const Data.Functor.Classes.$fShow1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy1_entry() //  [R3]
         { info_tbl: [(cdD7P,
                       label: Data.Functor.Classes.$fShow1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD7P: // global
           R2 = R3;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.463367495 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowList_entry() //  [R4,
                                                               R5]
         { info_tbl: [(cdD80,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD80: // global
           _sdyyy::P64 = R4;
           R4 = R5;
           R3 = _sdyyy::P64;
           R2 = Data.Functor.Classes.$fShow1Proxy1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.466826363 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_closure" {
     Data.Functor.Classes.$fShow1Proxy_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure+5;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.469165951 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info;
 },
 sat_sdyyI_entry() //  [R1, R2]
         { info_tbl: [(cdD8k,
                       label: sat_sdyyI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD8k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdD8l; else goto cdD8m;
       cdD8l: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD8m: // global
           I64[Sp - 24] = block_cdD8h_info;
           _sdyyA::P64 = P64[R1 + 7];
           _sdyyB::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyyA::P64;
           P64[Sp - 8] = _sdyyB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udD8q; else goto cdD8i;
       udD8q: // global
           call _cdD8h(R1) args: 0, res: 0, upd: 0;
       cdD8i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdD8h() //  [R1]
         { info_tbl: [(cdD8h,
                       label: block_cdD8h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD8h: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdD8r,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD8r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdD8v; else goto cdD8u;
       cdD8v: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD8u: // global
           I64[Hp - 16] = sat_sdyyI_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyyC::P64 = R4;
           R4 = R5;
           R3 = _sdyyC::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.477333148 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.479352183 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowList_entry() //  [R3, R4,
                                                            R5]
         { info_tbl: [(cdD8N,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD8N: // global
           _B2::P64 = R4;
           R4 = R5;
           _sdyyK::P64 = R3;
           R3 = _B2::P64;
           R2 = _sdyyK::P64;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.483845247 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_closure" {
     Data.Functor.Classes.$fShow1[]_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure+3;
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.48673266 UTC

[section ""data" . $w$dmliftReadListPrec_rdymw_closure" {
     $w$dmliftReadListPrec_rdymw_closure:
         const $w$dmliftReadListPrec_rdymw_info;
 },
 sat_sdyyQ_entry() //  [R1]
         { info_tbl: [(cdD97,
                       label: sat_sdyyQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD97: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdD98; else goto cdD99;
       cdD98: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD99: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyyR_entry() //  [R1, R2]
         { info_tbl: [(cdD9f,
                       label: sat_sdyyR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD9f: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyyP_entry() //  [R1, R2]
         { info_tbl: [(cdD9n,
                       label: sat_sdyyP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD9n: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w3_sdyyO_entry() //  [R1]
         { info_tbl: [(cdD9q,
                       label: w3_sdyyO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD9q: // global
           _sdyyO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdD9r; else goto cdD9s;
       cdD9s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdD9u; else goto cdD9t;
       cdD9u: // global
           HpAlloc = 56;
           goto cdD9r;
       cdD9r: // global
           R1 = _sdyyO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdD9t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyyO::P64;
           _sdyyL::P64 = P64[_sdyyO::P64 + 16];
           _sdyyM::P64 = P64[_sdyyO::P64 + 24];
           _sdyyN::P64 = P64[_sdyyO::P64 + 32];
           I64[Hp - 48] = sat_sdyyQ_info;
           P64[Hp - 32] = _sdyyN::P64;
           I64[Hp - 24] = sat_sdyyR_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyyP_info;
           P64[Hp] = _sdyyM::P64;
           R2 = _sdyyL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyyV_entry() //  [R1, R2]
         { info_tbl: [(cdD9D,
                       label: sat_sdyyV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD9D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdD9E; else goto cdD9F;
       cdD9E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdD9F: // global
           I64[Sp - 8] = block_cdD9A_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdD9A() //  [R1]
         { info_tbl: [(cdD9A,
                       label: block_cdD9A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD9A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdD9I; else goto cdD9H;
       cdD9I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdD9H: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec_rdymw_entry() //  [R2, R3, R4]
         { info_tbl: [(cdD9J,
                       label: $w$dmliftReadListPrec_rdymw_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdD9J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdD9N; else goto cdD9M;
       cdD9N: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec_rdymw_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdD9M: // global
           I64[Hp - 48] = w3_sdyyO_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyyV_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.50168575 UTC

[section ""data" . $dmliftReadListPrec3_rdymx_closure" {
     $dmliftReadListPrec3_rdymx_closure:
         const $dmliftReadListPrec3_rdymx_info;
 },
 $dmliftReadListPrec3_rdymx_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDan,
                       label: $dmliftReadListPrec3_rdymx_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDan: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $w$dmliftReadListPrec_rdymw_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.505017748 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec_closure" {
     Data.Functor.Classes.$dmliftReadListPrec_closure:
         const Data.Functor.Classes.$dmliftReadListPrec_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdDay,
                       label: Data.Functor.Classes.$dmliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDay: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec3_rdymx_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.509578468 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec_closure" {
     Data.Functor.Classes.$dmliftReadPrec_closure:
         const Data.Functor.Classes.$dmliftReadPrec_info;
 },
 sat_sdyz5_entry() //  [R1]
         { info_tbl: [(cdDaR,
                       label: sat_sdyz5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDaR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDaS; else goto cdDaT;
       cdDaS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDaT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyz6_entry() //  [R1, R2]
         { info_tbl: [(cdDaZ,
                       label: sat_sdyz6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDaZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyz4_entry() //  [R1, R2]
         { info_tbl: [(cdDb7,
                       label: sat_sdyz4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDb7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyz3_entry() //  [R1]
         { info_tbl: [(cdDba,
                       label: f1_sdyz3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDba: // global
           _sdyz3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDbb; else goto cdDbc;
       cdDbc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDbe; else goto cdDbd;
       cdDbe: // global
           HpAlloc = 56;
           goto cdDbb;
       cdDbb: // global
           R1 = _sdyz3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDbd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyz3::P64;
           _sdyz0::P64 = P64[_sdyz3::P64 + 16];
           _sdyz1::P64 = P64[_sdyz3::P64 + 24];
           _sdyz2::P64 = P64[_sdyz3::P64 + 32];
           I64[Hp - 48] = sat_sdyz5_info;
           P64[Hp - 32] = _sdyz2::P64;
           I64[Hp - 24] = sat_sdyz6_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyz4_info;
           P64[Hp] = _sdyz1::P64;
           R2 = _sdyz0::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyzc_entry() //  [R1, R2]
         { info_tbl: [(cdDbt,
                       label: sat_sdyzc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDbt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDbu; else goto cdDbv;
       cdDbu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDbv: // global
           I64[Sp - 8] = block_cdDbq_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDbq() //  [R1]
         { info_tbl: [(cdDbq,
                       label: block_cdDbq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDbq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDby; else goto cdDbx;
       cdDby: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDbx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzd_entry() //  [R1, R2]
         { info_tbl: [(cdDbz,
                       label: sat_sdyzd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDbz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDbD; else goto cdDbC;
       cdDbD: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDbC: // global
           _sdyz3::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdyz3::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyzc_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDbE,
                       label: Data.Functor.Classes.$dmliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDbE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDbI; else goto cdDbH;
       cdDbI: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDbH: // global
           I64[Hp - 48] = f1_sdyz3_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyzd_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.528615886 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList_closure" {
     Data.Functor.Classes.$dmliftReadList_closure:
         const Data.Functor.Classes.$dmliftReadList_info;
         const 0;
 },
 sat_sdyzm_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDcD,
                       label: sat_sdyzm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDcD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDcE; else goto cdDcF;
       cdDcE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDcF: // global
           I64[Sp - 8] = block_cdDcA_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDcA() //  [R1]
         { info_tbl: [(cdDcA,
                       label: block_cdDcA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDcA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDcI; else goto cdDcH;
       cdDcI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDcH: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzh_entry() //  [R1, R2]
         { info_tbl: [(cdDcO,
                       label: sat_sdyzh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDcO: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzn_entry() //  [R1]
         { info_tbl: [(cdDcR,
                       label: sat_sdyzn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDcR: // global
           _sdyzn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdDcS; else goto cdDcT;
       cdDcT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDcV; else goto cdDcU;
       cdDcV: // global
           HpAlloc = 32;
           goto cdDcS;
       cdDcS: // global
           R1 = _sdyzn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDcU: // global
           _sdyze::P64 = P64[_sdyzn::P64 + 16];
           _sdyzf::P64 = P64[_sdyzn::P64 + 24];
           _sdyzg::P64 = P64[_sdyzn::P64 + 32];
           I64[Hp - 24] = sat_sdyzm_info;
           P64[Hp - 16] = _sdyzg::P64;
           I64[Hp - 8] = sat_sdyzh_info;
           P64[Hp] = _sdyzf::P64;
           R2 = _sdyze::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdyzo_entry() //  [R1]
         { info_tbl: [(cdDcW,
                       label: sat_sdyzo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDcW: // global
           _sdyzo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDcX; else goto cdDcY;
       cdDcY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDd0; else goto cdDcZ;
       cdDd0: // global
           HpAlloc = 40;
           goto cdDcX;
       cdDcX: // global
           R1 = _sdyzo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDcZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzo::P64;
           _sdyze::P64 = P64[_sdyzo::P64 + 16];
           _sdyzf::P64 = P64[_sdyzo::P64 + 24];
           _sdyzg::P64 = P64[_sdyzo::P64 + 32];
           I64[Hp - 32] = sat_sdyzn_info;
           P64[Hp - 16] = _sdyze::P64;
           P64[Hp - 8] = _sdyzf::P64;
           P64[Hp] = _sdyzg::P64;
           R2 = Hp - 32;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDd1,
                       label: Data.Functor.Classes.$dmliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDd1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDd5; else goto cdDd4;
       cdDd5: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDd4: // global
           I64[Hp - 32] = sat_sdyzo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.544060009 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info;
         const 0;
 },
 f_sdyzr_entry() //  [R1, R2]
         { info_tbl: [(cdDdE,
                       label: f_sdyzr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDdE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyzs_entry() //  [R1]
         { info_tbl: [(cdDdL,
                       label: f1_sdyzs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDdL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDdM; else goto cdDdN;
       cdDdM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDdN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdyzt_entry() //  [R1, R2]
         { info_tbl: [(cdDdT,
                       label: f2_sdyzt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDdT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzz_entry() //  [R1, R2]
         { info_tbl: [(cdDe9,
                       label: sat_sdyzz_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDe9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdDea; else goto cdDeb;
       cdDea: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDeb: // global
           I64[Sp - 32] = block_cdDe6_info;
           _sdyzr::P64 = P64[R1 + 7];
           _sdyzt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdyzr::P64;
           P64[Sp - 16] = _sdyzt::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udDef; else goto cdDe7;
       udDef: // global
           call _cdDe6(R1) args: 0, res: 0, upd: 0;
       cdDe7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDe6() //  [R1]
         { info_tbl: [(cdDe6,
                       label: block_cdDe6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDe6: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDej,
                       label: sat_sdyzC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDej: // global
           _sdyzv::P64 = R3;
           _sdyzu::P64 = R2;
           _sdyzC::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdDek; else goto cdDel;
       cdDel: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDen; else goto cdDem;
       cdDen: // global
           HpAlloc = 32;
           goto cdDek;
       cdDek: // global
           R3 = _sdyzv::P64;
           R2 = _sdyzu::P64;
           R1 = _sdyzC::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDem: // global
           _sdyzr::P64 = P64[_sdyzC::P64 + 6];
           _sdyzt::P64 = P64[_sdyzC::P64 + 14];
           I64[Hp - 24] = sat_sdyzz_info;
           P64[Hp - 16] = _sdyzr::P64;
           P64[Hp - 8] = _sdyzt::P64;
           P64[Hp] = _sdyzu::P64;
           I64[Sp - 8] = block_cdDeg_info;
           R3 = _sdyzv::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDeg() //  [R1]
         { info_tbl: [(cdDeg,
                       label: block_cdDeg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDeg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDeq; else goto cdDep;
       cdDeq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDep: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdDer,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDer: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdDev; else goto cdDeu;
       cdDev: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDeu: // global
           I64[Hp - 72] = f_sdyzr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = f1_sdyzs_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = f2_sdyzt_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdyzC_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.563376056 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info;
         const 0;
 },
 sat_sdyzK_entry() //  [R1]
         { info_tbl: [(cdDfp,
                       label: sat_sdyzK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDfp: // global
           _sdyzK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdDfq; else goto cdDfr;
       cdDfr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDft; else goto cdDfs;
       cdDft: // global
           HpAlloc = 32;
           goto cdDfq;
       cdDfq: // global
           R1 = _sdyzK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzK::P64;
           _sdyzD::P64 = P64[_sdyzK::P64 + 16];
           _sdyzG::P64 = P64[_sdyzK::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdyzD::P64;
           P64[Hp] = _sdyzG::P64;
           I64[Sp - 24] = block_cdDfm_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdDfm() //  [R1]
         { info_tbl: [(cdDfm,
                       label: block_cdDfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDfm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDfw; else goto cdDfv;
       cdDfw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdDfv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f_sdyzF_entry() //  [R1, R2]
         { info_tbl: [(cdDfx,
                       label: f_sdyzF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDfx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDfB; else goto cdDfA;
       cdDfB: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDfA: // global
           _sdyzD::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyzK_info;
           P64[Hp - 8] = _sdyzD::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdyzL_entry() //  [R1]
         { info_tbl: [(cdDfJ,
                       label: f1_sdyzL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDfJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDfK; else goto cdDfL;
       cdDfK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDfL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdDfG_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdDfG() //  [R1]
         { info_tbl: [(cdDfG,
                       label: block_cdDfG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDfG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDfO; else goto cdDfN;
       cdDfO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdDfN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdyzO_entry() //  [R1, R2]
         { info_tbl: [(cdDfU,
                       label: f2_sdyzO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDfU: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzU_entry() //  [R1, R2]
         { info_tbl: [(cdDga,
                       label: sat_sdyzU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDga: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdDgb; else goto cdDgc;
       cdDgb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDgc: // global
           I64[Sp - 32] = block_cdDg7_info;
           _sdyzF::P64 = P64[R1 + 7];
           _sdyzO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdyzF::P64;
           P64[Sp - 16] = _sdyzO::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udDgg; else goto cdDg8;
       udDgg: // global
           call _cdDg7(R1) args: 0, res: 0, upd: 0;
       cdDg8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDg7() //  [R1]
         { info_tbl: [(cdDg7,
                       label: block_cdDg7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDg7: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDgk,
                       label: sat_sdyzX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDgk: // global
           _sdyzQ::P64 = R3;
           _sdyzP::P64 = R2;
           _sdyzX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdDgl; else goto cdDgm;
       cdDgm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDgo; else goto cdDgn;
       cdDgo: // global
           HpAlloc = 32;
           goto cdDgl;
       cdDgl: // global
           R3 = _sdyzQ::P64;
           R2 = _sdyzP::P64;
           R1 = _sdyzX::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDgn: // global
           _sdyzF::P64 = P64[_sdyzX::P64 + 6];
           _sdyzO::P64 = P64[_sdyzX::P64 + 14];
           I64[Hp - 24] = sat_sdyzU_info;
           P64[Hp - 16] = _sdyzF::P64;
           P64[Hp - 8] = _sdyzO::P64;
           P64[Hp] = _sdyzP::P64;
           I64[Sp - 8] = block_cdDgh_info;
           R3 = _sdyzQ::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDgh() //  [R1]
         { info_tbl: [(cdDgh,
                       label: block_cdDgh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDgh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDgr; else goto cdDgq;
       cdDgr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDgq: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyzY_entry() //  [R1]
         { info_tbl: [(cdDgs,
                       label: sat_sdyzY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDgs: // global
           _sdyzY::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDgt; else goto cdDgu;
       cdDgu: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdDgw; else goto cdDgv;
       cdDgw: // global
           HpAlloc = 80;
           goto cdDgt;
       cdDgt: // global
           R1 = _sdyzY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDgv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyzY::P64;
           _sdyzD::P64 = P64[_sdyzY::P64 + 16];
           _sdyzE::P64 = P64[_sdyzY::P64 + 24];
           I64[Hp - 72] = f_sdyzF_info;
           P64[Hp - 64] = _sdyzD::P64;
           I64[Hp - 56] = f1_sdyzL_info;
           P64[Hp - 40] = _sdyzE::P64;
           I64[Hp - 32] = f2_sdyzO_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdyzX_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R2 = Hp - 14;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdDgx,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDgx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDgB; else goto cdDgA;
       cdDgB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDgA: // global
           I64[Hp - 24] = sat_sdyzY_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.595211917 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdyA3_entry() //  [R1]
         { info_tbl: [(cdDhB,
                       label: sat_sdyA3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDhB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDhC; else goto cdDhD;
       cdDhC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDhD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyA4_entry() //  [R1, R2]
         { info_tbl: [(cdDhJ,
                       label: sat_sdyA4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDhJ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyA2_entry() //  [R1, R2]
         { info_tbl: [(cdDhR,
                       label: sat_sdyA2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDhR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w2_sdyA1_entry() //  [R1]
         { info_tbl: [(cdDhU,
                       label: w2_sdyA1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDhU: // global
           _sdyA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDhV; else goto cdDhW;
       cdDhW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDhY; else goto cdDhX;
       cdDhY: // global
           HpAlloc = 56;
           goto cdDhV;
       cdDhV: // global
           R1 = _sdyA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDhX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyA1::P64;
           _sdyzZ::P64 = P64[_sdyA1::P64 + 16];
           _sdyA0::P64 = P64[_sdyA1::P64 + 24];
           I64[Hp - 48] = sat_sdyA3_info;
           P64[Hp - 32] = _sdyA0::P64;
           I64[Hp - 24] = sat_sdyA4_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdyA2_info;
           P64[Hp] = _sdyzZ::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyA8_entry() //  [R1, R2]
         { info_tbl: [(cdDi7,
                       label: sat_sdyA8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDi7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDi8; else goto cdDi9;
       cdDi8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDi9: // global
           I64[Sp - 8] = block_cdDi4_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDi4() //  [R1]
         { info_tbl: [(cdDi4,
                       label: block_cdDi4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDi4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDic; else goto cdDib;
       cdDic: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDib: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec2_entry() //  [R2, R3]
         { info_tbl: [(cdDid,
                       label: Data.Functor.Classes.$w$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDid: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDih; else goto cdDig;
       cdDih: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDig: // global
           I64[Hp - 40] = w2_sdyA1_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdyA8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.611603785 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty1_closure" {
     Data.Functor.Classes.$fRead1NonEmpty1_closure:
         const Data.Functor.Classes.$fRead1NonEmpty1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(cdDiP,
                       label: Data.Functor.Classes.$fRead1NonEmpty1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDiP: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec2_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.615315741 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure+4;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.618359019 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec_closure" {
     Data.Functor.Classes.$dmliftReadsPrec_closure:
         const Data.Functor.Classes.$dmliftReadsPrec_info;
 },
 sat_sdyAl_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDjd,
                       label: sat_sdyAl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDjd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDje; else goto cdDjf;
       cdDje: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDjf: // global
           I64[Sp - 8] = block_cdDja_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDja() //  [R1]
         { info_tbl: [(cdDja,
                       label: block_cdDja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDja: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDji; else goto cdDjh;
       cdDji: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDjh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyAg_entry() //  [R1, R2]
         { info_tbl: [(cdDjo,
                       label: sat_sdyAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDjo: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdyAf_entry() //  [R1]
         { info_tbl: [(cdDjr,
                       label: ds_sdyAf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDjr: // global
           _sdyAf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDjs; else goto cdDjt;
       cdDjt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDjv; else goto cdDju;
       cdDjv: // global
           HpAlloc = 32;
           goto cdDjs;
       cdDjs: // global
           R1 = _sdyAf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDju: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyAf::P64;
           _sdyAc::P64 = P64[_sdyAf::P64 + 16];
           _sdyAd::P64 = P64[_sdyAf::P64 + 24];
           _sdyAe::P64 = P64[_sdyAf::P64 + 32];
           I64[Hp - 24] = sat_sdyAl_info;
           P64[Hp - 16] = _sdyAe::P64;
           I64[Hp - 8] = sat_sdyAg_info;
           P64[Hp] = _sdyAd::P64;
           R2 = _sdyAc::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyAn_entry() //  [R1]
         { info_tbl: [(cdDjF,
                       label: sat_sdyAn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDjG; else goto cdDjH;
       cdDjG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDjH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAo_entry() //  [R1, R2]
         { info_tbl: [(cdDjI,
                       label: sat_sdyAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDjI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDjM; else goto cdDjL;
       cdDjM: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDjL: // global
           _sdyAf::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdyAn_info;
           P64[Hp - 8] = _sdyAf::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDjN,
                       label: Data.Functor.Classes.$dmliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDjN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDjR; else goto cdDjQ;
       cdDjR: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDjQ: // global
           I64[Hp - 48] = ds_sdyAf_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdyAo_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.634327833 UTC

[section ""data" . Data.Functor.Classes.eq1_closure" {
     Data.Functor.Classes.eq1_closure:
         const Data.Functor.Classes.eq1_info;
 },
 sat_sdyAr_entry() //  [R1]
         { info_tbl: [(cdDku,
                       label: sat_sdyAr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDkv; else goto cdDkw;
       cdDkv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDkw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq1_entry() //  [R2, R3]
         { info_tbl: [(cdDkx,
                       label: Data.Functor.Classes.eq1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDkx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDkB; else goto cdDkA;
       cdDkB: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDkA: // global
           I64[Hp - 16] = sat_sdyAr_info;
           P64[Hp] = R3;
           _sdyAp::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdyAp::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.640419479 UTC

[section ""data" . Data.Functor.Classes.compare1_closure" {
     Data.Functor.Classes.compare1_closure:
         const Data.Functor.Classes.compare1_info;
 },
 sat_sdyAu_entry() //  [R1]
         { info_tbl: [(cdDkS,
                       label: sat_sdyAu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDkS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDkT; else goto cdDkU;
       cdDkT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDkU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare1_entry() //  [R2, R3]
         { info_tbl: [(cdDkV,
                       label: Data.Functor.Classes.compare1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDkV: // global
           _sdyAt::P64 = R3;
           _sdyAs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDkW; else goto cdDkX;
       cdDkX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDkZ; else goto cdDkY;
       cdDkZ: // global
           HpAlloc = 24;
           goto cdDkW;
       cdDkW: // global
           R3 = _sdyAt::P64;
           R2 = _sdyAs::P64;
           R1 = Data.Functor.Classes.compare1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDkY: // global
           I64[Hp - 16] = sat_sdyAu_info;
           P64[Hp] = _sdyAt::P64;
           R2 = _sdyAs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.647136899 UTC

[section ""data" . Data.Functor.Classes.readsPrec1_closure" {
     Data.Functor.Classes.readsPrec1_closure:
         const Data.Functor.Classes.readsPrec1_info;
 },
 sat_sdyAy_entry() //  [R1]
         { info_tbl: [(cdDli,
                       label: sat_sdyAy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDli: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDlj; else goto cdDlk;
       cdDlj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAx_entry() //  [R1]
         { info_tbl: [(cdDlp,
                       label: sat_sdyAx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDlp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDlq; else goto cdDlr;
       cdDlq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDlr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdDls,
                       label: Data.Functor.Classes.readsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDls: // global
           _sdyAw::P64 = R3;
           _sdyAv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdDlt; else goto cdDlu;
       cdDlu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDlw; else goto cdDlv;
       cdDlw: // global
           HpAlloc = 48;
           goto cdDlt;
       cdDlt: // global
           R3 = _sdyAw::P64;
           R2 = _sdyAv::P64;
           R1 = Data.Functor.Classes.readsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDlv: // global
           I64[Hp - 40] = sat_sdyAy_info;
           P64[Hp - 24] = _sdyAw::P64;
           I64[Hp - 16] = sat_sdyAx_info;
           P64[Hp] = _sdyAw::P64;
           R2 = _sdyAv::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.656900585 UTC

[section ""data" . Data.Functor.Classes.readsUnary1_closure" {
     Data.Functor.Classes.readsUnary1_closure:
         const Data.Functor.Classes.readsUnary1_info;
 },
 go_sdyAG_entry() //  [R1, R2]
         { info_tbl: [(cdDm7,
                       label: go_sdyAG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDm7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdDm8; else goto cdDm9;
       cdDm8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDm9: // global
           I64[Sp - 24] = block_cdDm0_info;
           _sdyAG::P64 = R1;
           _sdyAC::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyAC::P64;
           P64[Sp - 8] = _sdyAG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udDmt; else goto cdDm1;
       udDmt: // global
           call _cdDm0(R1) args: 0, res: 0, upd: 0;
       cdDm1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDm0() //  [R1]
         { info_tbl: [(cdDm0,
                       label: block_cdDm0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDm0: // global
           if (R1 & 7 == 1) goto cdDm4; else goto cdDm5;
       cdDm4: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDm5: // global
           I64[Sp - 8] = block_cdDmf_info;
           _sdyAK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyAK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udDms; else goto cdDmg;
       udDms: // global
           call _cdDmf(R1) args: 0, res: 0, upd: 0;
       cdDmg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDmf() //  [R1]
         { info_tbl: [(cdDmf,
                       label: block_cdDmf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDmf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdDmr; else goto cdDmq;
       cdDmr: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDmq: // global
           _sdyAM::P64 = P64[R1 + 7];
           _sdyAN::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyAM::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyAN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyAS_entry() //  [R1]
         { info_tbl: [(cdDmy,
                       label: sat_sdyAS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDmy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDmz; else goto cdDmA;
       cdDmz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDmA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyAR_entry() //  [R1]
         { info_tbl: [(cdDmF,
                       label: sat_sdyAR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDmF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDmG; else goto cdDmH;
       cdDmG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDmH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDmM,
                       label: Data.Functor.Classes.readsUnary1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDmM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdDmN; else goto cdDmO;
       cdDmN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdDmO: // global
           I64[Sp - 32] = block_cdDlQ_info;
           _sdyAA::P64 = R3;
           R3 = R4;
           _sdyAz::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdyAz::P64;
           P64[Sp - 16] = _sdyAA::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDlQ() //  [R1]
         { info_tbl: [(cdDlQ,
                       label: block_cdDlQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDlQ: // global
           if (R1 & 7 == 1) goto cdDmJ; else goto cdDmK;
       cdDmJ: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDmK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDmU; else goto cdDmT;
       cdDmU: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDmT: // global
           I64[Hp - 56] = go_sdyAG_info;
           P64[Hp - 48] = P64[Sp + 24];
           I64[Hp - 40] = sat_sdyAS_info;
           _sdyAA::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sdyAA::P64;
           I64[Hp - 16] = sat_sdyAR_info;
           P64[Hp] = _sdyAA::P64;
           I64[Sp + 24] = block_cdDmR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           P64[Sp + 8] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 55;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdDmR() //  [R1]
         { info_tbl: [(cdDmR,
                       label: block_cdDmR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDmR: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyAG_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.677223472 UTC

[section ""data" . Data.Functor.Classes.readsBinary1_closure" {
     Data.Functor.Classes.readsBinary1_closure:
         const Data.Functor.Classes.readsBinary1_info;
 },
 Data.Functor.Classes.readsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDnN: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.readsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 lvl3_sdyB2_entry() //  [R1]
         { info_tbl: [(cdDo0,
                       label: lvl3_sdyB2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDo0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDo1; else goto cdDo2;
       cdDo1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDo2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl4_sdyB3_entry() //  [R1]
         { info_tbl: [(cdDo7,
                       label: lvl4_sdyB3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDo7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDo8; else goto cdDo9;
       cdDo8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDo9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_sdyBd_entry() //  [R1, R2]
         { info_tbl: [(cdDoD,
                       label: go1_sdyBd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDoD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDoE; else goto cdDoF;
       cdDoE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDoF: // global
           I64[Sp - 40] = block_cdDow_info;
           _sdyBd::P64 = R1;
           _sdyAY::P64 = P64[R1 + 7];
           _sdyBa::P64 = P64[R1 + 15];
           _sdyBc::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdyAY::P64;
           P64[Sp - 24] = _sdyBa::P64;
           P64[Sp - 16] = _sdyBc::P64;
           P64[Sp - 8] = _sdyBd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udDoZ; else goto cdDox;
       udDoZ: // global
           call _cdDow(R1) args: 0, res: 0, upd: 0;
       cdDox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDow() //  [R1]
         { info_tbl: [(cdDow,
                       label: block_cdDow_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDow: // global
           if (R1 & 7 == 1) goto cdDoA; else goto cdDoB;
       cdDoA: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdDoB: // global
           I64[Sp] = block_cdDoL_info;
           _sdyBh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdyBh::P64;
           if (R1 & 7 != 0) goto udDoY; else goto cdDoM;
       udDoY: // global
           call _cdDoL(R1) args: 0, res: 0, upd: 0;
       cdDoM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDoL() //  [R1]
         { info_tbl: [(cdDoL,
                       label: block_cdDoL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDoL: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdDoX; else goto cdDoW;
       cdDoX: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDoW: // global
           _sdyBj::P64 = P64[R1 + 7];
           _sdyBk::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyBj::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdyBk::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyB4_entry() //  [R1, R2]
         { info_tbl: [(cdDp4,
                       label: go_sdyB4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDp4: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdDp5; else goto cdDp6;
       cdDp5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDp6: // global
           I64[Sp - 48] = block_cdDof_info;
           _sdyB4::P64 = R1;
           _sdyAV::P64 = P64[R1 + 7];
           _sdyAY::P64 = P64[R1 + 15];
           _sdyB2::P64 = P64[R1 + 23];
           _sdyB3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _sdyAV::P64;
           P64[Sp - 32] = _sdyAY::P64;
           P64[Sp - 24] = _sdyB2::P64;
           P64[Sp - 16] = _sdyB3::P64;
           P64[Sp - 8] = _sdyB4::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto udDpj; else goto cdDog;
       udDpj: // global
           call _cdDof(R1) args: 0, res: 0, upd: 0;
       cdDog: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDof() //  [R1]
         { info_tbl: [(cdDof,
                       label: block_cdDof_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDof: // global
           if (R1 & 7 == 1) goto cdDp1; else goto cdDp2;
       cdDp1: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDp2: // global
           I64[Sp - 8] = block_cdDol_info;
           _sdyB8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyB8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udDpi; else goto cdDom;
       udDpi: // global
           call _cdDol(R1) args: 0, res: 0, upd: 0;
       cdDom: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDol() //  [R1]
         { info_tbl: [(cdDol,
                       label: block_cdDol_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDol: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDpd; else goto cdDpc;
       cdDpd: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDpc: // global
           _sdyBa::P64 = P64[R1 + 7];
           _sdyBb::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyBd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdyBa::P64;
           P64[Hp] = Hp - 56;
           _sdyB3::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdDp9_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = P64[Sp + 32];
           P64[Sp + 16] = _sdyB3::P64;
           P64[Sp + 24] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 32] = _sdyBb::P64;
           P64[Sp + 48] = Hp - 23;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdDp9() //  [R1]
         { info_tbl: [(cdDp9,
                       label: block_cdDp9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDp9: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyBd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDpo,
                       label: Data.Functor.Classes.readsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDpo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDpp; else goto cdDpq;
       cdDpp: // global
           R1 = Data.Functor.Classes.readsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdDpq: // global
           I64[Sp - 32] = block_cdDnR_info;
           _sdyAV::P64 = R3;
           R3 = R5;
           _sdyAU::P64 = R2;
           R2 = P64[Sp];
           P64[Sp - 24] = _sdyAV::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = _sdyAU::P64;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDnR() //  [R1]
         { info_tbl: [(cdDnR,
                       label: block_cdDnR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDnR: // global
           if (R1 & 7 == 1) goto cdDpl; else goto cdDpm;
       cdDpl: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDpm: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdDpw; else goto cdDpv;
       cdDpw: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDpv: // global
           I64[Hp - 80] = lvl3_sdyB2_info;
           _sdyAW::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sdyAW::P64;
           I64[Hp - 56] = lvl4_sdyB3_info;
           P64[Hp - 40] = _sdyAW::P64;
           I64[Hp - 32] = go_sdyB4_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           _cdDnW::P64 = Hp - 80;
           P64[Hp - 8] = _cdDnW::P64;
           _cdDo3::P64 = Hp - 56;
           P64[Hp] = _cdDo3::P64;
           _sdyAU::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cdDpt_info;
           R2 = _sdyAU::P64;
           I64[Sp - 8] = stg_ap_pppp_info;
           P64[Sp] = _cdDnW::P64;
           P64[Sp + 8] = _cdDo3::P64;
           P64[Sp + 16] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 24] = P64[Sp + 40];
           P64[Sp + 40] = Hp - 31;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdDpt() //  [R1]
         { info_tbl: [(cdDpt,
                       label: block_cdDpt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDpt: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyB4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.707314216 UTC

[section ""data" . Data.Functor.Classes.readPrec1_closure" {
     Data.Functor.Classes.readPrec1_closure:
         const Data.Functor.Classes.readPrec1_info;
 },
 sat_sdyBt_entry() //  [R1]
         { info_tbl: [(cdDqX,
                       label: sat_sdyBt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDqX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDqY; else goto cdDqZ;
       cdDqY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDqZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyBs_entry() //  [R1]
         { info_tbl: [(cdDr4,
                       label: sat_sdyBs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDr4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDr5; else goto cdDr6;
       cdDr5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDr6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdDr7,
                       label: Data.Functor.Classes.readPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDr7: // global
           _sdyBr::P64 = R3;
           _sdyBq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdDr8; else goto cdDr9;
       cdDr9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDrb; else goto cdDra;
       cdDrb: // global
           HpAlloc = 48;
           goto cdDr8;
       cdDr8: // global
           R3 = _sdyBr::P64;
           R2 = _sdyBq::P64;
           R1 = Data.Functor.Classes.readPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDra: // global
           I64[Hp - 40] = sat_sdyBt_info;
           P64[Hp - 24] = _sdyBr::P64;
           I64[Hp - 16] = sat_sdyBs_info;
           P64[Hp] = _sdyBr::P64;
           R2 = _sdyBq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.715815484 UTC

[section ""data" . Data.Functor.Classes.liftReadListDefault_closure" {
     Data.Functor.Classes.liftReadListDefault_closure:
         const Data.Functor.Classes.liftReadListDefault_info;
 },
 sat_sdyBC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDrH,
                       label: sat_sdyBC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDrH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDrI; else goto cdDrJ;
       cdDrI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDrJ: // global
           I64[Sp - 8] = block_cdDrE_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDrE() //  [R1]
         { info_tbl: [(cdDrE,
                       label: block_cdDrE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDrE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDrM; else goto cdDrL;
       cdDrM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDrL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyBx_entry() //  [R1, R2]
         { info_tbl: [(cdDrS,
                       label: sat_sdyBx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDrS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyBD_entry() //  [R1]
         { info_tbl: [(cdDrV,
                       label: sat_sdyBD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDrV: // global
           _sdyBD::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdDrW; else goto cdDrX;
       cdDrX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDrZ; else goto cdDrY;
       cdDrZ: // global
           HpAlloc = 32;
           goto cdDrW;
       cdDrW: // global
           R1 = _sdyBD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDrY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyBD::P64;
           _sdyBu::P64 = P64[_sdyBD::P64 + 16];
           _sdyBv::P64 = P64[_sdyBD::P64 + 24];
           _sdyBw::P64 = P64[_sdyBD::P64 + 32];
           I64[Hp - 24] = sat_sdyBC_info;
           P64[Hp - 16] = _sdyBw::P64;
           I64[Hp - 8] = sat_sdyBx_info;
           P64[Hp] = _sdyBv::P64;
           R2 = _sdyBu::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadListDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDs0,
                       label: Data.Functor.Classes.liftReadListDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDs0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDs4; else goto cdDs3;
       cdDs4: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDs3: // global
           I64[Hp - 32] = sat_sdyBD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.728393392 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrecDefault_closure" {
     Data.Functor.Classes.liftReadListPrecDefault_closure:
         const Data.Functor.Classes.liftReadListPrecDefault_info;
         const 0;
 },
 sat_sdyBH_entry() //  [R1]
         { info_tbl: [(cdDsy,
                       label: sat_sdyBH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDsy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDsz; else goto cdDsA;
       cdDsz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDsA: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrecDefault_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdDsB,
                       label: Data.Functor.Classes.liftReadListPrecDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDsB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDsF; else goto cdDsE;
       cdDsF: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrecDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDsE: // global
           I64[Hp - 32] = sat_sdyBH_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.734663917 UTC

[section ""data" . lvl_rdymy_closure" {
     lvl_rdymy_closure:
         const lvl_rdymy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rdymy_entry() //  [R1]
         { info_tbl: [(cdDsW,
                       label: lvl_rdymy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDsW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDsX; else goto cdDsY;
       cdDsX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDsY: // global
           (_cdDsT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdDsT::I64 == 0) goto cdDsV; else goto cdDsU;
       cdDsV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdDsU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdDsT::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.739812966 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_entry() //  []
         { info_tbl: [(cdDta,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDta: // global
           R1 = lvl_rdymy_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.743577031 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info;
         const 0;
 },
 sat_sdyBN_entry() //  [R1]
         { info_tbl: [(cdDtp,
                       label: sat_sdyBN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDtp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDtq; else goto cdDtr;
       cdDtq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDtr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udDtx_srtd" {
     udDtx_srtd:
         const SdyRV_srt+16;
         const 34;
         const 8590000129;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdDts,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDts: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDtw; else goto cdDtv;
       cdDtw: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDtv: // global
           I64[Hp - 16] = sat_sdyBN_info;
           P64[Hp] = R4;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.750299629 UTC

[section ""data" . lvl1_rdymz_closure" {
     lvl1_rdymz_closure:
         const lvl1_rdymz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdymz_entry() //  [R1]
         { info_tbl: [(cdDtN,
                       label: lvl1_rdymz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDtN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDtO; else goto cdDtP;
       cdDtO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDtP: // global
           (_cdDtK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdDtK::I64 == 0) goto cdDtM; else goto cdDtL;
       cdDtM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdDtL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdDtK::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.75455793 UTC

[section ""data" . lvl2_rdymA_closure" {
     lvl2_rdymA_closure:
         const lvl2_rdymA_info;
         const 0;
 },
 lvl2_rdymA_entry() //  [R2]
         { info_tbl: [(cdDu1,
                       label: lvl2_rdymA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDu1: // global
           R3 = R2;
           R2 = lvl1_rdymz_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.758309607 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadList_entry() //  [R4]
         { info_tbl: [(cdDuc,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDuc: // global
           R2 = R4;
           call lvl2_rdymA_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.761696079 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_closure" {
     Data.Functor.Classes.$fRead1Proxy_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure+3;
         const Data.Functor.Classes.$fRead1Proxy5_closure+4;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.763743983 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_entry() //  [R3]
         { info_tbl: [(cdDuo,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDuo: // global
           R2 = R3;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.767855257 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info;
 },
 sat_sdyBX_entry() //  [R1]
         { info_tbl: [(cdDuG,
                       label: sat_sdyBX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDuG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDuH; else goto cdDuI;
       cdDuH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDuI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdDuD_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdDuD() //  [R1]
         { info_tbl: [(cdDuD,
                       label: block_cdDuD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDuD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDuL; else goto cdDuK;
       cdDuL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdDuK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdDuM,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDuM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDuQ; else goto cdDuP;
       cdDuQ: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDuP: // global
           I64[Hp - 16] = sat_sdyBX_info;
           P64[Hp] = R3;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.776940193 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList2_closure" {
     Data.Functor.Classes.$w$cliftReadList2_closure:
         const Data.Functor.Classes.$w$cliftReadList2_info;
         const 0;
 },
 sat_sdyC3_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDvj,
                       label: sat_sdyC3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDvj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDvk; else goto cdDvl;
       cdDvk: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDvl: // global
           I64[Sp - 8] = block_cdDvg_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDvg() //  [R1]
         { info_tbl: [(cdDvg,
                       label: block_cdDvg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDvg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDvo; else goto cdDvn;
       cdDvo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDvn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyC4_entry() //  [R1]
         { info_tbl: [(cdDvp,
                       label: sat_sdyC4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDvp: // global
           _sdyC4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDvq; else goto cdDvr;
       cdDvr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDvt; else goto cdDvs;
       cdDvt: // global
           HpAlloc = 16;
           goto cdDvq;
       cdDvq: // global
           R1 = _sdyC4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDvs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyC4::P64;
           _sdyBY::P64 = P64[_sdyC4::P64 + 16];
           I64[Hp - 8] = sat_sdyC3_info;
           P64[Hp] = _sdyBY::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadList2_entry() //  [R2]
         { info_tbl: [(cdDvu,
                       label: Data.Functor.Classes.$w$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDvu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDvy; else goto cdDvx;
       cdDvy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDvx: // global
           I64[Hp - 16] = sat_sdyC4_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.787419654 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadList_entry() //  [R3]
         { info_tbl: [(cdDvT,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDvT: // global
           R2 = R3;
           call Data.Functor.Classes.$w$cliftReadList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.791283646 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_closure" {
     Data.Functor.Classes.$fRead1[]_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.794743808 UTC

[section ""data" . Data.Functor.Classes.showsPrec1_closure" {
     Data.Functor.Classes.showsPrec1_closure:
         const Data.Functor.Classes.showsPrec1_info;
 },
 sat_sdyCa_entry() //  [R1]
         { info_tbl: [(cdDw9,
                       label: sat_sdyCa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDw9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDwa; else goto cdDwb;
       cdDwa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDwb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyC9_entry() //  [R1]
         { info_tbl: [(cdDwg,
                       label: sat_sdyC9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDwg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDwh; else goto cdDwi;
       cdDwh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDwi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdDwj,
                       label: Data.Functor.Classes.showsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDwj: // global
           _sdyC8::P64 = R3;
           _sdyC7::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdDwk; else goto cdDwl;
       cdDwl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDwn; else goto cdDwm;
       cdDwn: // global
           HpAlloc = 48;
           goto cdDwk;
       cdDwk: // global
           R3 = _sdyC8::P64;
           R2 = _sdyC7::P64;
           R1 = Data.Functor.Classes.showsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDwm: // global
           I64[Hp - 40] = sat_sdyCa_info;
           P64[Hp - 24] = _sdyC8::P64;
           I64[Hp - 16] = sat_sdyC9_info;
           P64[Hp] = _sdyC8::P64;
           R2 = _sdyC7::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.80268497 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith1_closure" {
     Data.Functor.Classes.showsUnaryWith1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.806451946 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary1_closure" {
     Data.Functor.Classes.$wshowsUnary1_closure:
         const Data.Functor.Classes.$wshowsUnary1_info;
 },
 Data.Functor.Classes.$wshowsUnary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDwF: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCi_entry() //  [R1]
         { info_tbl: [(cdDwR,
                       label: sat_sdyCi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDwR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDwS; else goto cdDwT;
       cdDwS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDwT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCh_entry() //  [R1]
         { info_tbl: [(cdDwY,
                       label: sat_sdyCh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDwY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDwZ; else goto cdDx0;
       cdDwZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDx0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdyCg_entry() //  [R1]
         { info_tbl: [(cdDx1,
                       label: g_sdyCg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDx1: // global
           _sdyCg::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdDx2; else goto cdDx3;
       cdDx3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDx5; else goto cdDx4;
       cdDx5: // global
           HpAlloc = 48;
           goto cdDx2;
       cdDx2: // global
           R1 = _sdyCg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDx4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCg::P64;
           _sdyCb::P64 = P64[_sdyCg::P64 + 16];
           _sdyCc::P64 = P64[_sdyCg::P64 + 24];
           _sdyCf::P64 = P64[_sdyCg::P64 + 32];
           I64[Hp - 40] = sat_sdyCi_info;
           P64[Hp - 24] = _sdyCc::P64;
           I64[Hp - 16] = sat_sdyCh_info;
           P64[Hp] = _sdyCc::P64;
           R2 = _sdyCb::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCf::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCn_entry() //  [R1, R2]
         { info_tbl: [(cdDxg,
                       label: sat_sdyCn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDxg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDxk; else goto cdDxj;
       cdDxk: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDxj: // global
           _sdyCd::P64 = P64[R1 + 7];
           _sdyCg::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyCd::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCq_entry() //  [R1]
         { info_tbl: [(cdDxA,
                       label: sat_sdyCq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDxA: // global
           _sdyCq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDxB; else goto cdDxC;
       cdDxC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDxE; else goto cdDxD;
       cdDxE: // global
           HpAlloc = 24;
           goto cdDxB;
       cdDxB: // global
           R1 = _sdyCq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDxD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCq::P64;
           _sdyCg::P64 = P64[_sdyCq::P64 + 16];
           _sdyCo::P64 = P64[_sdyCq::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyCo::P64;
           R2 = Hp - 14;
           R1 = _sdyCg::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCs_entry() //  [R1]
         { info_tbl: [(cdDxG,
                       label: sat_sdyCs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDxG: // global
           _sdyCs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDxH; else goto cdDxI;
       cdDxI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDxK; else goto cdDxJ;
       cdDxK: // global
           HpAlloc = 56;
           goto cdDxH;
       cdDxH: // global
           R1 = _sdyCs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDxJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCs::P64;
           _sdyCd::P64 = P64[_sdyCs::P64 + 16];
           _sdyCg::P64 = P64[_sdyCs::P64 + 24];
           _sdyCo::P64 = P64[_sdyCs::P64 + 32];
           I64[Hp - 48] = sat_sdyCq_info;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = _sdyCo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyCd::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCt_entry() //  [R1, R2]
         { info_tbl: [(cdDxM,
                       label: sat_sdyCt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDxM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDxQ; else goto cdDxP;
       cdDxQ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDxP: // global
           _sdyCd::P64 = P64[R1 + 7];
           _sdyCg::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyCs_info;
           P64[Hp - 40] = _sdyCd::P64;
           P64[Hp - 32] = _sdyCg::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDxU,
                       label: Data.Functor.Classes.$wshowsUnary1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDxU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDxY; else goto cdDxX;
       cdDxY: // global
           HpAlloc = 64;
           R1 = Data.Functor.Classes.$wshowsUnary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdDxX: // global
           I64[Hp - 56] = g_sdyCg_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdDwJ::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdDxS; else goto cdDxT;
       cdDxS: // global
           I64[Hp - 16] = sat_sdyCn_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdDwJ::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDxT: // global
           I64[Hp - 16] = sat_sdyCt_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdDwJ::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.82919294 UTC

[section ""data" . Data.Functor.Classes.showsUnary1_closure" {
     Data.Functor.Classes.showsUnary1_closure:
         const Data.Functor.Classes.showsUnary1_info;
 },
 Data.Functor.Classes.showsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDyK,
                       label: Data.Functor.Classes.showsUnary1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDyK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDyL; else goto cdDyM;
       cdDyL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDyM: // global
           I64[Sp - 40] = block_cdDyH_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udDyQ; else goto cdDyI;
       udDyQ: // global
           call _cdDyH(R1) args: 0, res: 0, upd: 0;
       cdDyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDyH() //  [R1]
         { info_tbl: [(cdDyH,
                       label: block_cdDyH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDyH: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.837681827 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinary1_closure" {
     Data.Functor.Classes.$wshowsBinary1_closure:
         const Data.Functor.Classes.$wshowsBinary1_info;
 },
 Data.Functor.Classes.$wshowsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDz1: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdyCK_entry() //  [R1]
         { info_tbl: [(cdDzd,
                       label: sat_sdyCK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDzd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDze; else goto cdDzf;
       cdDze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDzf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCJ_entry() //  [R1]
         { info_tbl: [(cdDzk,
                       label: sat_sdyCJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDzk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDzl; else goto cdDzm;
       cdDzl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDzm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdyCI_entry() //  [R1]
         { info_tbl: [(cdDzn,
                       label: f1_sdyCI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDzn: // global
           _sdyCI::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdDzo; else goto cdDzp;
       cdDzp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDzr; else goto cdDzq;
       cdDzr: // global
           HpAlloc = 48;
           goto cdDzo;
       cdDzo: // global
           R1 = _sdyCI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDzq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCI::P64;
           _sdyCB::P64 = P64[_sdyCI::P64 + 16];
           _sdyCD::P64 = P64[_sdyCI::P64 + 24];
           _sdyCG::P64 = P64[_sdyCI::P64 + 32];
           I64[Hp - 40] = sat_sdyCK_info;
           P64[Hp - 24] = _sdyCD::P64;
           I64[Hp - 16] = sat_sdyCJ_info;
           P64[Hp] = _sdyCD::P64;
           R2 = _sdyCB::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCG::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCN_entry() //  [R1]
         { info_tbl: [(cdDzA,
                       label: sat_sdyCN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDzA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDzB; else goto cdDzC;
       cdDzB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDzC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCM_entry() //  [R1]
         { info_tbl: [(cdDzH,
                       label: sat_sdyCM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDzH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDzI; else goto cdDzJ;
       cdDzI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDzJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g1_sdyCL_entry() //  [R1]
         { info_tbl: [(cdDzK,
                       label: g1_sdyCL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDzK: // global
           _sdyCL::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdDzL; else goto cdDzM;
       cdDzM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDzO; else goto cdDzN;
       cdDzO: // global
           HpAlloc = 48;
           goto cdDzL;
       cdDzL: // global
           R1 = _sdyCL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDzN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCL::P64;
           _sdyCC::P64 = P64[_sdyCL::P64 + 16];
           _sdyCD::P64 = P64[_sdyCL::P64 + 24];
           _sdyCH::P64 = P64[_sdyCL::P64 + 32];
           I64[Hp - 40] = sat_sdyCN_info;
           P64[Hp - 24] = _sdyCD::P64;
           I64[Hp - 16] = sat_sdyCM_info;
           P64[Hp] = _sdyCD::P64;
           R2 = _sdyCC::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdyCH::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdyCS_entry() //  [R1]
         { info_tbl: [(cdDA3,
                       label: sat_sdyCS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDA3: // global
           _sdyCS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDA4; else goto cdDA5;
       cdDA5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDA7; else goto cdDA6;
       cdDA7: // global
           HpAlloc = 56;
           goto cdDA4;
       cdDA4: // global
           R1 = _sdyCS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCS::P64;
           _sdyCI::P64 = P64[_sdyCS::P64 + 16];
           _sdyCL::P64 = P64[_sdyCS::P64 + 24];
           _sdyCP::P64 = P64[_sdyCS::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyCI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCU_entry() //  [R1, R2]
         { info_tbl: [(cdDA9,
                       label: sat_sdyCU_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDA9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDAd; else goto cdDAc;
       cdDAd: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDAc: // global
           _sdyCE::P64 = P64[R1 + 7];
           _sdyCI::P64 = P64[R1 + 15];
           _sdyCL::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdyCS_info;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyCE::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyCX_entry() //  [R1]
         { info_tbl: [(cdDAx,
                       label: sat_sdyCX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDAx: // global
           _sdyCX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDAy; else goto cdDAz;
       cdDAz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDAB; else goto cdDAA;
       cdDAB: // global
           HpAlloc = 24;
           goto cdDAy;
       cdDAy: // global
           R1 = _sdyCX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDAA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCX::P64;
           _sdyCL::P64 = P64[_sdyCX::P64 + 16];
           _sdyCV::P64 = P64[_sdyCX::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyCV::P64;
           R2 = Hp - 14;
           R1 = _sdyCL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyCZ_entry() //  [R1]
         { info_tbl: [(cdDAD,
                       label: sat_sdyCZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDAD: // global
           _sdyCZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDAE; else goto cdDAF;
       cdDAF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDAH; else goto cdDAG;
       cdDAH: // global
           HpAlloc = 56;
           goto cdDAE;
       cdDAE: // global
           R1 = _sdyCZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDAG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyCZ::P64;
           _sdyCI::P64 = P64[_sdyCZ::P64 + 16];
           _sdyCL::P64 = P64[_sdyCZ::P64 + 24];
           _sdyCV::P64 = P64[_sdyCZ::P64 + 32];
           I64[Hp - 48] = sat_sdyCX_info;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyCI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyD1_entry() //  [R1]
         { info_tbl: [(cdDAJ,
                       label: sat_sdyD1_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDAJ: // global
           _sdyD1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDAK; else goto cdDAL;
       cdDAL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDAN; else goto cdDAM;
       cdDAN: // global
           HpAlloc = 64;
           goto cdDAK;
       cdDAK: // global
           R1 = _sdyD1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDAM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyD1::P64;
           _sdyCE::P64 = P64[_sdyD1::P64 + 16];
           _sdyCI::P64 = P64[_sdyD1::P64 + 24];
           _sdyCL::P64 = P64[_sdyD1::P64 + 32];
           _sdyCV::P64 = P64[_sdyD1::P64 + 40];
           I64[Hp - 56] = sat_sdyCZ_info;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = _sdyCV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyCE::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyD2_entry() //  [R1, R2]
         { info_tbl: [(cdDAP,
                       label: sat_sdyD2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDAP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdDAT; else goto cdDAS;
       cdDAT: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDAS: // global
           _sdyCE::P64 = P64[R1 + 7];
           _sdyCI::P64 = P64[R1 + 15];
           _sdyCL::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdyD1_info;
           P64[Hp - 48] = _sdyCE::P64;
           P64[Hp - 40] = _sdyCI::P64;
           P64[Hp - 32] = _sdyCL::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinary1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdDAX,
                       label: Data.Functor.Classes.$wshowsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDAX: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdDB1; else goto cdDB0;
       cdDB1: // global
           HpAlloc = 112;
           R1 = Data.Functor.Classes.$wshowsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdDB0: // global
           I64[Hp - 104] = f1_sdyCI_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = P64[Sp];
           I64[Hp - 64] = g1_sdyCL_info;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = P64[Sp + 8];
           _cdDz5::P64 = Hp - 104;
           _cdDzs::P64 = Hp - 64;
           if (%MO_S_Le_W64(R6, 10)) goto cdDAV; else goto cdDAW;
       cdDAV: // global
           I64[Hp - 24] = sat_sdyCU_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdDz5::P64;
           P64[Hp] = _cdDzs::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDAW: // global
           I64[Hp - 24] = sat_sdyD2_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdDz5::P64;
           P64[Hp] = _cdDzs::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.870958796 UTC

[section ""data" . Data.Functor.Classes.showsBinary1_closure" {
     Data.Functor.Classes.showsBinary1_closure:
         const Data.Functor.Classes.showsBinary1_info;
 },
 Data.Functor.Classes.showsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDC7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.showsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.showsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDCe,
                       label: Data.Functor.Classes.showsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDCe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDCf; else goto cdDCg;
       cdDCf: // global
           R1 = Data.Functor.Classes.showsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdDCg: // global
           I64[Sp - 40] = block_cdDCb_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udDCk; else goto cdDCc;
       udDCk: // global
           call _cdDCb(R1) args: 0, res: 0, upd: 0;
       cdDCc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDCb() //  [R1]
         { info_tbl: [(cdDCb,
                       label: block_cdDCb_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDCb: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.878587336 UTC

[section ""data" . Data.Functor.Classes.eq2_closure" {
     Data.Functor.Classes.eq2_closure:
         const Data.Functor.Classes.eq2_info;
 },
 sat_sdyDg_entry() //  [R1]
         { info_tbl: [(cdDCE,
                       label: sat_sdyDg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDCE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDCF; else goto cdDCG;
       cdDCF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDCG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDf_entry() //  [R1]
         { info_tbl: [(cdDCL,
                       label: sat_sdyDf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDCL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDCM; else goto cdDCN;
       cdDCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDCN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDCO,
                       label: Data.Functor.Classes.eq2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDCO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDCS; else goto cdDCR;
       cdDCS: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDCR: // global
           I64[Hp - 40] = sat_sdyDg_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdyDf_info;
           P64[Hp] = R3;
           R3 = Hp - 40;
           _sdyDc::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdyDc::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.886283045 UTC

[section ""data" . Data.Functor.Classes.compare2_closure" {
     Data.Functor.Classes.compare2_closure:
         const Data.Functor.Classes.compare2_info;
 },
 sat_sdyDl_entry() //  [R1]
         { info_tbl: [(cdDDd,
                       label: sat_sdyDl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDDd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDDe; else goto cdDDf;
       cdDDe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDDf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDk_entry() //  [R1]
         { info_tbl: [(cdDDk,
                       label: sat_sdyDk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDDk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDDl; else goto cdDDm;
       cdDDl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDDm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDDn,
                       label: Data.Functor.Classes.compare2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDDn: // global
           _sdyDj::P64 = R4;
           _sdyDi::P64 = R3;
           _sdyDh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdDDo; else goto cdDDp;
       cdDDp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDDr; else goto cdDDq;
       cdDDr: // global
           HpAlloc = 48;
           goto cdDDo;
       cdDDo: // global
           R4 = _sdyDj::P64;
           R3 = _sdyDi::P64;
           R2 = _sdyDh::P64;
           R1 = Data.Functor.Classes.compare2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDDq: // global
           I64[Hp - 40] = sat_sdyDl_info;
           P64[Hp - 24] = _sdyDj::P64;
           I64[Hp - 16] = sat_sdyDk_info;
           P64[Hp] = _sdyDi::P64;
           R2 = _sdyDh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftCompare2_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.894905518 UTC

[section ""data" . Data.Functor.Classes.readsPrec2_closure" {
     Data.Functor.Classes.readsPrec2_closure:
         const Data.Functor.Classes.readsPrec2_info;
 },
 sat_sdyDs_entry() //  [R1]
         { info_tbl: [(cdDDP,
                       label: sat_sdyDs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDDP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDDQ; else goto cdDDR;
       cdDDQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDDR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDr_entry() //  [R1]
         { info_tbl: [(cdDDW,
                       label: sat_sdyDr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDDW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDDX; else goto cdDDY;
       cdDDX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDDY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDq_entry() //  [R1]
         { info_tbl: [(cdDE3,
                       label: sat_sdyDq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDE3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDE4; else goto cdDE5;
       cdDE4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDE5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDp_entry() //  [R1]
         { info_tbl: [(cdDEa,
                       label: sat_sdyDp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDEb; else goto cdDEc;
       cdDEb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDEc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDEd,
                       label: Data.Functor.Classes.readsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDEd: // global
           _sdyDo::P64 = R4;
           _sdyDn::P64 = R3;
           _sdyDm::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDEe; else goto cdDEf;
       cdDEf: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdDEh; else goto cdDEg;
       cdDEh: // global
           HpAlloc = 96;
           goto cdDEe;
       cdDEe: // global
           R4 = _sdyDo::P64;
           R3 = _sdyDn::P64;
           R2 = _sdyDm::P64;
           R1 = Data.Functor.Classes.readsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDEg: // global
           I64[Hp - 88] = sat_sdyDs_info;
           P64[Hp - 72] = _sdyDo::P64;
           I64[Hp - 64] = sat_sdyDr_info;
           P64[Hp - 48] = _sdyDo::P64;
           I64[Hp - 40] = sat_sdyDq_info;
           P64[Hp - 24] = _sdyDn::P64;
           I64[Hp - 16] = sat_sdyDp_info;
           P64[Hp] = _sdyDn::P64;
           R2 = _sdyDm::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.9079187 UTC

[section ""data" . Data.Functor.Classes.readPrec2_closure" {
     Data.Functor.Classes.readPrec2_closure:
         const Data.Functor.Classes.readPrec2_info;
 },
 sat_sdyDz_entry() //  [R1]
         { info_tbl: [(cdDEP,
                       label: sat_sdyDz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDEP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDEQ; else goto cdDER;
       cdDEQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDER: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDy_entry() //  [R1]
         { info_tbl: [(cdDEW,
                       label: sat_sdyDy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDEW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDEX; else goto cdDEY;
       cdDEX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDEY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDx_entry() //  [R1]
         { info_tbl: [(cdDF3,
                       label: sat_sdyDx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDF3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDF4; else goto cdDF5;
       cdDF4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDF5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyDw_entry() //  [R1]
         { info_tbl: [(cdDFa,
                       label: sat_sdyDw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDFa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDFb; else goto cdDFc;
       cdDFb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDFc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDFd,
                       label: Data.Functor.Classes.readPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDFd: // global
           _sdyDv::P64 = R4;
           _sdyDu::P64 = R3;
           _sdyDt::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDFe; else goto cdDFf;
       cdDFf: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdDFh; else goto cdDFg;
       cdDFh: // global
           HpAlloc = 96;
           goto cdDFe;
       cdDFe: // global
           R4 = _sdyDv::P64;
           R3 = _sdyDu::P64;
           R2 = _sdyDt::P64;
           R1 = Data.Functor.Classes.readPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDFg: // global
           I64[Hp - 88] = sat_sdyDz_info;
           P64[Hp - 72] = _sdyDv::P64;
           I64[Hp - 64] = sat_sdyDy_info;
           P64[Hp - 48] = _sdyDv::P64;
           I64[Hp - 40] = sat_sdyDx_info;
           P64[Hp - 24] = _sdyDu::P64;
           I64[Hp - 16] = sat_sdyDw_info;
           P64[Hp] = _sdyDu::P64;
           R2 = _sdyDt::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.921155508 UTC

[section ""data" . Data.Functor.Classes.liftReadList2Default_closure" {
     Data.Functor.Classes.liftReadList2Default_closure:
         const Data.Functor.Classes.liftReadList2Default_info;
 },
 sat_sdyDQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDFX,
                       label: sat_sdyDQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDFX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDFY; else goto cdDFZ;
       cdDFY: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDFZ: // global
           I64[Sp - 8] = block_cdDFU_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDFU() //  [R1]
         { info_tbl: [(cdDFU,
                       label: block_cdDFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDFU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDG2; else goto cdDG1;
       cdDG2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDG1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDL_entry() //  [R1, R2]
         { info_tbl: [(cdDG8,
                       label: sat_sdyDL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDG8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDK_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDGj,
                       label: sat_sdyDK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDGj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDGk; else goto cdDGl;
       cdDGk: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDGl: // global
           I64[Sp - 8] = block_cdDGg_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDGg() //  [R1]
         { info_tbl: [(cdDGg,
                       label: block_cdDGg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDGg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDGo; else goto cdDGn;
       cdDGo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDGn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDF_entry() //  [R1, R2]
         { info_tbl: [(cdDGu,
                       label: sat_sdyDF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDGu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyDR_entry() //  [R1]
         { info_tbl: [(cdDGx,
                       label: sat_sdyDR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDGx: // global
           _sdyDR::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto cdDGy; else goto cdDGz;
       cdDGz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdDGB; else goto cdDGA;
       cdDGB: // global
           HpAlloc = 64;
           goto cdDGy;
       cdDGy: // global
           R1 = _sdyDR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDGA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyDR::P64;
           _sdyDA::P64 = P64[_sdyDR::P64 + 16];
           _sdyDB::P64 = P64[_sdyDR::P64 + 24];
           _sdyDC::P64 = P64[_sdyDR::P64 + 32];
           _sdyDD::P64 = P64[_sdyDR::P64 + 40];
           _sdyDE::P64 = P64[_sdyDR::P64 + 48];
           I64[Hp - 56] = sat_sdyDQ_info;
           P64[Hp - 48] = _sdyDE::P64;
           I64[Hp - 40] = sat_sdyDL_info;
           P64[Hp - 32] = _sdyDD::P64;
           I64[Hp - 24] = sat_sdyDK_info;
           P64[Hp - 16] = _sdyDC::P64;
           I64[Hp - 8] = sat_sdyDF_info;
           P64[Hp] = _sdyDB::P64;
           R2 = _sdyDA::P64;
           I64[Sp - 72] = stg_ap_pppppp_info;
           P64[Sp - 64] = Hp - 7;
           P64[Sp - 56] = Hp - 22;
           P64[Sp - 48] = Hp - 39;
           P64[Sp - 40] = Hp - 54;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 72;
           call Data.Functor.Classes.liftReadListPrec2_entry(R2) args: 80, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadList2Default_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdDGC,
                       label: Data.Functor.Classes.liftReadList2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDGC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDGG; else goto cdDGF;
       cdDGG: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDGF: // global
           I64[Hp - 48] = sat_sdyDR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.939343266 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_closure" {
     Data.Functor.Classes.$fRead2Either_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Either8_closure+6;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadList2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdDHj,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDHj: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Either_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.944109524 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_closure" {
     Data.Functor.Classes.$fRead2Const_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Const6_closure+6;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadList2_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdDHv,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDHv: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Const_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.949658281 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_closure" {
     Data.Functor.Classes.$fRead2(,)_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1(,)2_closure+6;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadList2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdDHH,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDHH: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2(,)_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.954377293 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2Default_closure" {
     Data.Functor.Classes.liftReadListPrec2Default_closure:
         const Data.Functor.Classes.liftReadListPrec2Default_info;
         const 0;
 },
 sat_sdyDX_entry() //  [R1]
         { info_tbl: [(cdDHX,
                       label: sat_sdyDX_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDHX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDHY; else goto cdDHZ;
       cdDHY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDHZ: // global
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           P64[Sp - 16] = P64[R1 + 40];
           P64[Sp - 8] = P64[R1 + 48];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrec2Default_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cdDI0,
                       label: Data.Functor.Classes.liftReadListPrec2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDI0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDI4; else goto cdDI3;
       cdDI4: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDI3: // global
           I64[Hp - 48] = sat_sdyDX_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.960586847 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)1_closure" {
     Data.Functor.Classes.$fRead1(,)1_closure:
         const Data.Functor.Classes.$fRead1(,)1_info;
         const 0;
 },
 sat_sdyE3_entry() //  [R1]
         { info_tbl: [(cdDIp,
                       label: sat_sdyE3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDIp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDIq; else goto cdDIr;
       cdDIq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDIr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDIs,
                       label: Data.Functor.Classes.$fRead1(,)1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDIs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDIw; else goto cdDIv;
       cdDIw: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDIv: // global
           I64[Hp - 16] = sat_sdyE3_info;
           P64[Hp] = R2;
           _sdyE1::P64 = R5;
           R5 = R6;
           R4 = _sdyE1::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.967355616 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec_info;
         const 0;
 },
 sat_sdyE8_entry() //  [R1, R2]
         { info_tbl: [(cdDIS,
                       label: sat_sdyE8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDIS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyE7_entry() //  [R1]
         { info_tbl: [(cdDIZ,
                       label: sat_sdyE7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDIZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDJ0; else goto cdDJ1;
       cdDJ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDJ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyE9_entry() //  [R1]
         { info_tbl: [(cdDJ2,
                       label: sat_sdyE9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDJ2: // global
           _sdyE9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDJ3; else goto cdDJ4;
       cdDJ4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDJ6; else goto cdDJ5;
       cdDJ6: // global
           HpAlloc = 40;
           goto cdDJ3;
       cdDJ3: // global
           R1 = _sdyE9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDJ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyE9::P64;
           _sdyE4::P64 = P64[_sdyE9::P64 + 16];
           _sdyE5::P64 = P64[_sdyE9::P64 + 24];
           _sdyE6::P64 = P64[_sdyE9::P64 + 32];
           I64[Hp - 32] = sat_sdyE8_info;
           P64[Hp - 24] = _sdyE5::P64;
           I64[Hp - 16] = sat_sdyE7_info;
           P64[Hp] = _sdyE4::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyE6::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDJ7,
                       label: Data.Functor.Classes.$w$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDJ7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDJb; else goto cdDJa;
       cdDJb: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDJa: // global
           I64[Hp - 32] = sat_sdyE9_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.977227264 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_entry() //  [R2,
                                                              R3, R5]
         { info_tbl: [(cdDJv,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDJv: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.981432223 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyEh_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDJL,
                       label: sat_sdyEh_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDJL: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdDJO,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDJO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDJS; else goto cdDJR;
       cdDJS: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDJR: // global
           I64[Hp - 24] = sat_sdyEh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 22;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:45.988466721 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_closure" {
     Data.Functor.Classes.$fRead1(,)_closure:
         const Data.Functor.Classes.$fRead1(,)_info;
         const 0;
 },
 sat_sdyEp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDK9,
                       label: sat_sdyEp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDK9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEo_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdDKh,
                       label: sat_sdyEo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDKh: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEn_entry() //  [R1]
         { info_tbl: [(cdDKo,
                       label: sat_sdyEn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDKo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDKp; else goto cdDKq;
       cdDKp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDKq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEm_entry() //  [R1, R2, R4]
         { info_tbl: [(cdDKw,
                       label: sat_sdyEm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDKw: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_entry() //  [R2]
         { info_tbl: [(cdDKA,
                       label: Data.Functor.Classes.$fRead1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDKA: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdDKE; else goto cdDKD;
       cdDKE: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDKD: // global
           I64[Hp - 104] = sat_sdyEp_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdyEo_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyEn_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyEm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_info;
         const 0;
 },
 sat_sdyEr_entry() //  [R1]
         { info_tbl: [(cdDKN,
                       label: sat_sdyEr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDKN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDKO; else goto cdDKP;
       cdDKO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDKP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdDKQ,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDKQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDKU; else goto cdDKT;
       cdDKU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDKT: // global
           I64[Hp - 16] = sat_sdyEr_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.006262954 UTC

[section ""data" . Data.Functor.Classes.showsPrec2_closure" {
     Data.Functor.Classes.showsPrec2_closure:
         const Data.Functor.Classes.showsPrec2_info;
 },
 sat_sdyEy_entry() //  [R1]
         { info_tbl: [(cdDLx,
                       label: sat_sdyEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDLx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDLy; else goto cdDLz;
       cdDLy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDLz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEx_entry() //  [R1]
         { info_tbl: [(cdDLE,
                       label: sat_sdyEx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDLE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDLF; else goto cdDLG;
       cdDLF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDLG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEw_entry() //  [R1]
         { info_tbl: [(cdDLL,
                       label: sat_sdyEw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDLL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDLM; else goto cdDLN;
       cdDLM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDLN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyEv_entry() //  [R1]
         { info_tbl: [(cdDLS,
                       label: sat_sdyEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDLS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDLT; else goto cdDLU;
       cdDLT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDLU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDLV,
                       label: Data.Functor.Classes.showsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDLV: // global
           _sdyEu::P64 = R4;
           _sdyEt::P64 = R3;
           _sdyEs::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdDLW; else goto cdDLX;
       cdDLX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdDLZ; else goto cdDLY;
       cdDLZ: // global
           HpAlloc = 96;
           goto cdDLW;
       cdDLW: // global
           R4 = _sdyEu::P64;
           R3 = _sdyEt::P64;
           R2 = _sdyEs::P64;
           R1 = Data.Functor.Classes.showsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDLY: // global
           I64[Hp - 88] = sat_sdyEy_info;
           P64[Hp - 72] = _sdyEu::P64;
           I64[Hp - 64] = sat_sdyEx_info;
           P64[Hp - 48] = _sdyEu::P64;
           I64[Hp - 40] = sat_sdyEw_info;
           P64[Hp - 24] = _sdyEt::P64;
           I64[Hp - 16] = sat_sdyEv_info;
           P64[Hp] = _sdyEt::P64;
           R2 = _sdyEs::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.019603357 UTC

[section ""data" . Data.Functor.Classes.$wreadsData_closure" {
     Data.Functor.Classes.$wreadsData_closure:
         const Data.Functor.Classes.$wreadsData_info;
         const 0;
 },
 sat_sdyEL_entry() //  [R1]
         { info_tbl: [(cdDMN,
                       label: sat_sdyEL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDMN: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sdyEC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyEC_entry() //  [R1, R2]
         { info_tbl: [(cdDMU,
                       label: go_sdyEC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDMU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdDMV; else goto cdDMW;
       cdDMV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDMW: // global
           I64[Sp - 24] = block_cdDMy_info;
           _sdyEC::P64 = R1;
           _sdyEz::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyEz::P64;
           P64[Sp - 8] = _sdyEC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udDN9; else goto cdDMz;
       udDN9: // global
           call _cdDMy(R1) args: 0, res: 0, upd: 0;
       cdDMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDMy() //  [R1]
         { info_tbl: [(cdDMy,
                       label: block_cdDMy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDMy: // global
           if (R1 & 7 == 1) goto cdDMR; else goto cdDMS;
       cdDMR: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDMS: // global
           I64[Sp - 8] = block_cdDME_info;
           _sdyEG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyEG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udDN8; else goto cdDMF;
       udDN8: // global
           call _cdDME(R1) args: 0, res: 0, upd: 0;
       cdDMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDME() //  [R1]
         { info_tbl: [(cdDME,
                       label: block_cdDME_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDME: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDN3; else goto cdDN2;
       cdDN3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDN2: // global
           _sdyEI::P64 = P64[R1 + 7];
           _sdyEJ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdyEL_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _sdyEz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdDMZ_info;
           R3 = _sdyEJ::P64;
           R2 = _sdyEI::P64;
           R1 = _sdyEz::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDMZ() //  [R1]
         { info_tbl: [(cdDMZ,
                       label: block_cdDMZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDMZ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyEQ_entry() //  [R1, R2]
         { info_tbl: [(cdDNh,
                       label: sat_sdyEQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDNh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDNi; else goto cdDNj;
       cdDNi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDNj: // global
           I64[Sp - 16] = block_cdDNf_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDNf() //  [R1]
         { info_tbl: [(cdDNf,
                       label: block_cdDNf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDNf: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyEC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udDNu_srtd" {
     udDNu_srtd:
         const SdyRV_srt+120;
         const 36;
         const 51539607553;
 },
 Data.Functor.Classes.$wreadsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDNp,
                       label: Data.Functor.Classes.$wreadsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDNp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDNt; else goto cdDNs;
       cdDNt: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDNs: // global
           I64[Hp - 24] = go_sdyEC_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyEQ_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sdyEN::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sdyEN::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.039019798 UTC

[section ""data" . Data.Functor.Classes.readsData_closure" {
     Data.Functor.Classes.readsData_closure:
         const Data.Functor.Classes.readsData_info;
         const 0;
 },
 Data.Functor.Classes.readsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDOg,
                       label: Data.Functor.Classes.readsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDOg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDOh; else goto cdDOi;
       cdDOh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDOi: // global
           I64[Sp - 24] = block_cdDOd_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udDOm; else goto cdDOe;
       udDOm: // global
           call _cdDOd(R1) args: 0, res: 0, upd: 0;
       cdDOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDOd() //  [R1]
         { info_tbl: [(cdDOd,
                       label: block_cdDOd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDOd: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wreadsData_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.044797105 UTC

[section ""data" . Data.Functor.Classes.readData2_closure" {
     Data.Functor.Classes.readData2_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.047550355 UTC

[section ""data" . Data.Functor.Classes.readData1_closure" {
     Data.Functor.Classes.readData1_closure:
         const Data.Functor.Classes.readData1_info;
         const 0;
 },
 lvl3_sdyEZ_entry() //  [R1]
         { info_tbl: [(cdDOF,
                       label: lvl3_sdyEZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDOF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDOG; else goto cdDOH;
       cdDOG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDOH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.readData2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyF4_entry() //  [R1, R2]
         { info_tbl: [(cdDOQ,
                       label: sat_sdyF4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDOQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDOR; else goto cdDOS;
       cdDOR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDOS: // global
           I64[Sp - 16] = block_cdDON_info;
           _sdyEZ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdyEZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udDP1; else goto cdDOO;
       udDP1: // global
           call _cdDON(R1) args: 0, res: 0, upd: 0;
       cdDOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDON() //  [R1]
         { info_tbl: [(cdDON,
                       label: block_cdDON_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDON: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdDOZ; else goto cdDP0;
       cdDOZ: // global
           R1 = Text.ParserCombinators.ReadP.$fAlternativeReadP4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDP0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readData1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDP2,
                       label: Data.Functor.Classes.readData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDP2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDP6; else goto cdDP5;
       cdDP6: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readData1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDP5: // global
           I64[Hp - 32] = lvl3_sdyEZ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyF4_info;
           P64[Hp] = Hp - 32;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.05720601 UTC

[section ""data" . Data.Functor.Classes.readData_closure" {
     Data.Functor.Classes.readData_closure:
         const Data.Functor.Classes.readData_info;
         const 0;
 },
 Data.Functor.Classes.readData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDPt,
                       label: Data.Functor.Classes.readData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDPt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readData1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.062108826 UTC

[section ""data" . Data.Functor.Classes.readsUnaryWith_closure" {
     Data.Functor.Classes.readsUnaryWith_closure:
         const Data.Functor.Classes.readsUnaryWith_info;
 },
 go_sdyFb_entry() //  [R1, R2]
         { info_tbl: [(cdDPV,
                       label: go_sdyFb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDPV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdDPW; else goto cdDPX;
       cdDPW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDPX: // global
           I64[Sp - 24] = block_cdDPO_info;
           _sdyFb::P64 = R1;
           _sdyF7::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyF7::P64;
           P64[Sp - 8] = _sdyFb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udDQh; else goto cdDPP;
       udDQh: // global
           call _cdDPO(R1) args: 0, res: 0, upd: 0;
       cdDPP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDPO() //  [R1]
         { info_tbl: [(cdDPO,
                       label: block_cdDPO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDPO: // global
           if (R1 & 7 == 1) goto cdDPS; else goto cdDPT;
       cdDPS: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDPT: // global
           I64[Sp - 8] = block_cdDQ3_info;
           _sdyFf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyFf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udDQg; else goto cdDQ4;
       udDQg: // global
           call _cdDQ3(R1) args: 0, res: 0, upd: 0;
       cdDQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDQ3() //  [R1]
         { info_tbl: [(cdDQ3,
                       label: block_cdDQ3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDQ3: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdDQf; else goto cdDQe;
       cdDQf: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDQe: // global
           _sdyFh::P64 = P64[R1 + 7];
           _sdyFi::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyFh::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyFi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdDQm,
                       label: Data.Functor.Classes.readsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDQm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdDQn; else goto cdDQo;
       cdDQn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDQo: // global
           I64[Sp - 32] = block_cdDPE_info;
           R3 = R3;
           _sdyF5::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdyF5::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDPE() //  [R1]
         { info_tbl: [(cdDPE,
                       label: block_cdDPE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDPE: // global
           if (R1 & 7 == 1) goto cdDQj; else goto cdDQk;
       cdDQj: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdDQk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDQu; else goto cdDQt;
       cdDQu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDQt: // global
           I64[Hp - 8] = go_sdyFb_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdDQr_info;
           R3 = P64[Sp + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDQr() //  [R1]
         { info_tbl: [(cdDQr,
                       label: block_cdDQr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDQr: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyFb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.077977625 UTC

[section ""data" . Data.Functor.Classes.$wreadUnaryWith_closure" {
     Data.Functor.Classes.$wreadUnaryWith_closure:
         const Data.Functor.Classes.$wreadUnaryWith_info;
         const 0;
 },
 sat_sdyFA_entry() //  [R1, R2]
         { info_tbl: [(cdDRq,
                       label: sat_sdyFA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDRq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDRu; else goto cdDRt;
       cdDRu: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDRt: // global
           _sdyFp::P64 = P64[R1 + 7];
           _sdyFr::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdyFp::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdyFr::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyFx_entry() //  [R1]
         { info_tbl: [(cdDRC,
                       label: sat_sdyFx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDRC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDRJ; else goto cdDRK;
       cdDRJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDRK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdDRz_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udDRO; else goto cdDRA;
       udDRO: // global
           call _cdDRz(R1) args: 0, res: 0, upd: 0;
       cdDRA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdDRz() //  [R1]
         { info_tbl: [(cdDRz,
                       label: block_cdDRz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDRz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDRN; else goto cdDRM;
       cdDRN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdDRM: // global
           _sdyFw::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdyFw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyFB_entry() //  [R1, R2]
         { info_tbl: [(cdDRP,
                       label: sat_sdyFB_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDRP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDRT; else goto cdDRS;
       cdDRT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDRS: // global
           _sdyFn::P64 = P64[R1 + 7];
           _sdyFp::P64 = P64[R1 + 15];
           _sdyFq::P64 = P64[R1 + 23];
           _sdyFr::P64 = P64[R1 + 31];
           I64[Hp - 40] = sat_sdyFA_info;
           P64[Hp - 32] = _sdyFp::P64;
           P64[Hp - 24] = _sdyFr::P64;
           I64[Hp - 16] = sat_sdyFx_info;
           P64[Hp] = _sdyFq::P64;
           R3 = Hp - 39;
           R2 = Hp - 16;
           R1 = _sdyFn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadUnaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdDRV,
                       label: Data.Functor.Classes.$wreadUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDRV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdDRZ; else goto cdDRY;
       cdDRZ: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDRY: // global
           I64[Hp - 48] = sat_sdyFB_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R3;
           R3 = Hp - 47;
           R2 = Hp - 4;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.090166574 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith1_closure" {
     Data.Functor.Classes.readUnaryWith1_closure:
         const Data.Functor.Classes.readUnaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdDSr,
                       label: Data.Functor.Classes.readUnaryWith1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDSr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdDSs; else goto cdDSt;
       cdDSs: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readUnaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDSt: // global
           I64[Sp - 8] = block_cdDSo_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadUnaryWith_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdDSo() //  [R1]
         { info_tbl: [(cdDSo,
                       label: block_cdDSo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDSo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdDSw; else goto cdDSv;
       cdDSw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDSv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.096382402 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith_closure" {
     Data.Functor.Classes.readUnaryWith_closure:
         const Data.Functor.Classes.readUnaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDSK,
                       label: Data.Functor.Classes.readUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDSK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readUnaryWith1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.100192165 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const5_closure" {
     Data.Functor.Classes.$fRead1Const5_closure:
         const Data.Functor.Classes.$fRead1Const5_info;
         const 0;
 },
 sat_sdyFO_entry() //  [R1]
         { info_tbl: [(cdDSZ,
                       label: sat_sdyFO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDSZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDT0; else goto cdDT1;
       cdDT0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDT1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdDT2,
                       label: Data.Functor.Classes.$fRead1Const5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDT2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDT6; else goto cdDT5;
       cdDT6: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDT5: // global
           I64[Hp - 16] = sat_sdyFO_info;
           P64[Hp] = R2;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.107048826 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec1_info;
         const 0;
 },
 sat_sdyFR_entry() //  [R1]
         { info_tbl: [(cdDTr,
                       label: sat_sdyFR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDTr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDTs; else goto cdDTt;
       cdDTs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDTt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyFS_entry() //  [R1]
         { info_tbl: [(cdDTu,
                       label: sat_sdyFS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDTu: // global
           _sdyFS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDTv; else goto cdDTw;
       cdDTw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDTy; else goto cdDTx;
       cdDTy: // global
           HpAlloc = 24;
           goto cdDTv;
       cdDTv: // global
           R1 = _sdyFS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDTx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyFS::P64;
           _sdyFP::P64 = P64[_sdyFS::P64 + 16];
           _sdyFQ::P64 = P64[_sdyFS::P64 + 24];
           I64[Hp - 16] = sat_sdyFR_info;
           P64[Hp] = _sdyFP::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyFQ::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdDTz,
                       label: Data.Functor.Classes.$w$cliftReadsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDTz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdDTD; else goto cdDTC;
       cdDTD: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDTC: // global
           I64[Hp - 24] = sat_sdyFS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.115515295 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_entry() //  [R2,
                                                                R5]
         { info_tbl: [(cdDTU,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDTU: // global
           R3 = R5;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.119246329 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec_info;
         const 0;
 },
 w1_sdyFY_entry() //  [R1]
         { info_tbl: [(cdDU9,
                       label: w1_sdyFY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDU9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDUa; else goto cdDUb;
       cdDUa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDUb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyG1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDUh,
                       label: sat_sdyG1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDUh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdDUk,
                       label: Data.Functor.Classes.$w$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDUk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDUo; else goto cdDUn;
       cdDUo: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDUn: // global
           I64[Hp - 32] = w1_sdyFY_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyG1_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.12634403 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdDUF,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDUF: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.131074278 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_closure" {
     Data.Functor.Classes.$fRead1Const_closure:
         const Data.Functor.Classes.$fRead1Const_info;
         const 0;
 },
 lvl3_sdyG6_entry() //  [R1]
         { info_tbl: [(cdDUU,
                       label: lvl3_sdyG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDUU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDUV; else goto cdDUW;
       cdDUV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDUW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGf_entry() //  [R1]
         { info_tbl: [(cdDV2,
                       label: sat_sdyGf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDV2: // global
           R1 = P64[R1 + 6];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGc_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdDVa,
                       label: sat_sdyGc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDVa: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Const5_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGb_entry() //  [R1]
         { info_tbl: [(cdDVh,
                       label: sat_sdyGb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDVh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDVi; else goto cdDVj;
       cdDVi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDVj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGa_entry() //  [R1, R4]
         { info_tbl: [(cdDVp,
                       label: sat_sdyGa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDVp: // global
           R3 = R4;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Const_entry() //  [R2]
         { info_tbl: [(cdDVt,
                       label: Data.Functor.Classes.$fRead1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDVt: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdDVx; else goto cdDVw;
       cdDVx: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDVw: // global
           I64[Hp - 128] = lvl3_sdyG6_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sdyGf_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sdyGc_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyGb_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyGa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_info;
         const 0;
 },
 sat_sdyGh_entry() //  [R1]
         { info_tbl: [(cdDVG,
                       label: sat_sdyGh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDVG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDVH; else goto cdDVI;
       cdDVH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDVI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdDVJ,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDVJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDVN; else goto cdDVM;
       cdDVN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDVM: // global
           I64[Hp - 16] = sat_sdyGh_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.149193914 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either7_closure" {
     Data.Functor.Classes.$fRead1Either7_closure:
         const Data.Functor.Classes.$fRead1Either7_info;
         const 0;
 },
 sat_sdyGn_entry() //  [R1]
         { info_tbl: [(cdDWv,
                       label: sat_sdyGn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDWv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDWw; else goto cdDWx;
       cdDWw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDWx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either7_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdDWy,
                       label: Data.Functor.Classes.$fRead1Either7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDWy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDWC; else goto cdDWB;
       cdDWC: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either7_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDWB: // global
           I64[Hp - 16] = sat_sdyGn_info;
           P64[Hp] = R2;
           _sdyGl::P64 = R5;
           R5 = R6;
           R4 = _sdyGl::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.155442146 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec2_info;
         const 0;
 },
 sat_sdyGs_entry() //  [R1, R2]
         { info_tbl: [(cdDWY,
                       label: sat_sdyGs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDWY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGr_entry() //  [R1]
         { info_tbl: [(cdDX5,
                       label: sat_sdyGr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDX5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDX6; else goto cdDX7;
       cdDX6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDX7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGt_entry() //  [R1]
         { info_tbl: [(cdDX8,
                       label: sat_sdyGt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDX8: // global
           _sdyGt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdDX9; else goto cdDXa;
       cdDXa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDXc; else goto cdDXb;
       cdDXc: // global
           HpAlloc = 40;
           goto cdDX9;
       cdDX9: // global
           R1 = _sdyGt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDXb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyGt::P64;
           _sdyGo::P64 = P64[_sdyGt::P64 + 16];
           _sdyGp::P64 = P64[_sdyGt::P64 + 24];
           _sdyGq::P64 = P64[_sdyGt::P64 + 32];
           I64[Hp - 32] = sat_sdyGs_info;
           P64[Hp - 24] = _sdyGp::P64;
           I64[Hp - 16] = sat_sdyGr_info;
           P64[Hp] = _sdyGo::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdyGq::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDXd,
                       label: Data.Functor.Classes.$w$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDXd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDXh; else goto cdDXg;
       cdDXh: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDXg: // global
           I64[Hp - 32] = sat_sdyGt_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.165187763 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_entry() //  [R2,
                                                                 R3, R5]
         { info_tbl: [(cdDXB,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDXB: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.169038585 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec1_info;
         const 0;
 },
 w2_sdyGA_entry() //  [R1]
         { info_tbl: [(cdDXQ,
                       label: w2_sdyGA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDXQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDXR; else goto cdDXS;
       cdDXR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDXS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdDXY,
                       label: sat_sdyGD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDXY: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdDY1,
                       label: Data.Functor.Classes.$w$cliftReadListPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDY1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdDY5; else goto cdDY4;
       cdDY5: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDY4: // global
           I64[Hp - 40] = w2_sdyGA_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyGD_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.176698515 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cdDYm,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDYm: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.182105175 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_closure" {
     Data.Functor.Classes.$fRead1Either_closure:
         const Data.Functor.Classes.$fRead1Either_info;
         const 0;
 },
 sat_sdyGQ_entry() //  [R1, R2]
         { info_tbl: [(cdDYC,
                       label: sat_sdyGQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDYC: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGN_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdDYK,
                       label: sat_sdyGN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDYK: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Either7_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyGM_entry() //  [R1]
         { info_tbl: [(cdDYR,
                       label: sat_sdyGM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDYR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDYS; else goto cdDYT;
       cdDYS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDYT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyGL_entry() //  [R1, R2, R4]
         { info_tbl: [(cdDYZ,
                       label: sat_sdyGL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDYZ: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Either_entry() //  [R2]
         { info_tbl: [(cdDZ3,
                       label: Data.Functor.Classes.$fRead1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDZ3: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdDZ7; else goto cdDZ6;
       cdDZ7: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDZ6: // global
           I64[Hp - 104] = sat_sdyGQ_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdyGN_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdyGM_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdyGL_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_info;
         const 0;
 },
 sat_sdyGS_entry() //  [R1]
         { info_tbl: [(cdDZg,
                       label: sat_sdyGS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDZg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdDZh; else goto cdDZi;
       cdDZh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDZi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdDZj,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDZj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdDZn; else goto cdDZm;
       cdDZn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdDZm: // global
           I64[Hp - 16] = sat_sdyGS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.197536018 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Identity4_bytes" {
     Data.Functor.Classes.$fRead1Identity4_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.199514017 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity3_closure" {
     Data.Functor.Classes.$fRead1Identity3_closure:
         const Data.Functor.Classes.$fRead1Identity3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity3_entry() //  [R1]
         { info_tbl: [(cdDZZ,
                       label: Data.Functor.Classes.$fRead1Identity3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDZZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdE00; else goto cdE01;
       cdE00: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE01: // global
           (_cdDZW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdDZW::I64 == 0) goto cdDZY; else goto cdDZX;
       cdDZY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdDZX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdDZW::I64;
           R2 = Data.Functor.Classes.$fRead1Identity4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.203619955 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity2_closure" {
     Data.Functor.Classes.$fRead1Identity2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.206789353 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec_closure" {
     Data.Functor.Classes.$w$cliftReadPrec_closure:
         const Data.Functor.Classes.$w$cliftReadPrec_info;
         const 0;
 },
 sat_sdyH3_entry() //  [R1, R2]
         { info_tbl: [(cdE0C,
                       label: sat_sdyH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE0C: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyH4_entry() //  [R1, R2]
         { info_tbl: [(cdE0F,
                       label: sat_sdyH4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE0F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE0J; else goto cdE0I;
       cdE0J: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdE0I: // global
           _sdyGT::P64 = P64[R1 + 7];
           _sdyGX::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyH3_info;
           P64[Hp] = _sdyGX::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyGT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyH7_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE0K,
                       label: sat_sdyH7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE0K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdE0L; else goto cdE0M;
       cdE0L: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE0M: // global
           I64[Sp - 24] = block_cdE0j_info;
           _sdyGT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyGT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udE0Z; else goto cdE0k;
       udE0Z: // global
           call _cdE0j(R1) args: 0, res: 0, upd: 0;
       cdE0k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdE0j() //  [R1]
         { info_tbl: [(cdE0j,
                       label: block_cdE0j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE0j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdE0P; else goto cdE0O;
       cdE0P: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE0O: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdE0R; else goto cdE0V;
       cdE0R: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdE0V: // global
           I64[Hp - 16] = sat_sdyH4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdE0S_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdE0S() //  [R1]
         { info_tbl: [(cdE0S,
                       label: block_cdE0S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE0S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE0Y; else goto cdE0X;
       cdE0Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE0X: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdE10,
                       label: Data.Functor.Classes.$w$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE10: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE14; else goto cdE13;
       cdE14: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE13: // global
           I64[Hp - 8] = sat_sdyH7_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.221618186 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity1_closure" {
     Data.Functor.Classes.$fRead1Identity1_closure:
         const Data.Functor.Classes.$fRead1Identity1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdE1y,
                       label: Data.Functor.Classes.$fRead1Identity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE1y: // global
           _sdyHa::P64 = R4;
           R4 = R5;
           R3 = _sdyHa::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.226483836 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec3_info;
         const 0;
 },
 lvl3_sdyHe_entry() //  [R1]
         { info_tbl: [(cdE1R,
                       label: lvl3_sdyHe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE1R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdE1S; else goto cdE1T;
       cdE1S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE1T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyHm_entry() //  [R1, R2]
         { info_tbl: [(cdE2i,
                       label: sat_sdyHm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2i: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHp_entry() //  [R1, R2]
         { info_tbl: [(cdE2o,
                       label: sat_sdyHp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2o: // global
           _sdyHk::P64 = R2;
           _sdyHp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdE2p; else goto cdE2q;
       cdE2q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE2s; else goto cdE2r;
       cdE2s: // global
           HpAlloc = 16;
           goto cdE2p;
       cdE2p: // global
           R2 = _sdyHk::P64;
           R1 = _sdyHp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdE2r: // global
           _sdyHe::P64 = P64[_sdyHp::P64 + 7];
           _sdyHg::P64 = P64[_sdyHp::P64 + 15];
           I64[Hp - 8] = sat_sdyHm_info;
           P64[Hp] = _sdyHg::P64;
           I64[Sp - 8] = block_cdE2l_info;
           R3 = Hp - 7;
           R2 = _sdyHe::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdE2l() //  [R1]
         { info_tbl: [(cdE2l,
                       label: block_cdE2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE2v; else goto cdE2u;
       cdE2v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE2u: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE2w,
                       label: sat_sdyHs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdE2x; else goto cdE2y;
       cdE2x: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE2y: // global
           I64[Sp - 24] = block_cdE1Z_info;
           _sdyHe::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyHe::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udE2L; else goto cdE20;
       udE2L: // global
           call _cdE1Z(R1) args: 0, res: 0, upd: 0;
       cdE20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdE1Z() //  [R1]
         { info_tbl: [(cdE1Z,
                       label: block_cdE1Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE1Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdE2B; else goto cdE2A;
       cdE2B: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE2A: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdE2D; else goto cdE2H;
       cdE2D: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdE2H: // global
           I64[Hp - 16] = sat_sdyHp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdE2E_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdE2E() //  [R1]
         { info_tbl: [(cdE2E,
                       label: block_cdE2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE2K; else goto cdE2J;
       cdE2K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE2J: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHt_entry() //  [R1]
         { info_tbl: [(cdE2M,
                       label: sat_sdyHt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2M: // global
           _sdyHt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdE2N; else goto cdE2O;
       cdE2O: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdE2Q; else goto cdE2P;
       cdE2Q: // global
           HpAlloc = 40;
           goto cdE2N;
       cdE2N: // global
           R1 = _sdyHt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE2P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyHt::P64;
           _sdyHc::P64 = P64[_sdyHt::P64 + 16];
           _sdyHd::P64 = P64[_sdyHt::P64 + 24];
           I64[Hp - 32] = lvl3_sdyHe_info;
           P64[Hp - 16] = _sdyHc::P64;
           I64[Hp - 8] = sat_sdyHs_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyHd::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec3_entry() //  [R2, R3]
         { info_tbl: [(cdE2R,
                       label: Data.Functor.Classes.$w$cliftReadsPrec3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE2R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdE2V; else goto cdE2U;
       cdE2V: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE2U: // global
           I64[Hp - 24] = sat_sdyHt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.246684939 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_entry() //  [R2,
                                                                   R4]
         { info_tbl: [(cdE3D,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE3D: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec3_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.252527097 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyHB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE3T,
                       label: sat_sdyHB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE3T: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udE41_srtd" {
     udE41_srtd:
         const SdyRV_srt+304;
         const 35;
         const 21474836481;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_entry() //  [R2,
                                                                      R3]
         { info_tbl: [(cdE3W,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE3W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE40; else goto cdE3Z;
       cdE40: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE3Z: // global
           I64[Hp - 8] = sat_sdyHB_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.261627301 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList_closure" {
     Data.Functor.Classes.$w$cliftReadList_closure:
         const Data.Functor.Classes.$w$cliftReadList_info;
         const 0;
 },
 w1_sdyHD_entry() //  [R1, R2]
         { info_tbl: [(cdE4n,
                       label: w1_sdyHD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE4n: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyHG_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE4v,
                       label: sat_sdyHG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE4v: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udE4I_srtd" {
     udE4I_srtd:
         const SdyRV_srt+304;
         const 33;
         const 4294967297;
 },
 sat_sdyHH_entry() //  [R1]
         { info_tbl: [(cdE4y,
                       label: sat_sdyHH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE4y: // global
           _sdyHH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdE4z; else goto cdE4A;
       cdE4A: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdE4C; else goto cdE4B;
       cdE4C: // global
           HpAlloc = 32;
           goto cdE4z;
       cdE4z: // global
           R1 = _sdyHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE4B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyHH::P64;
           _sdyHC::P64 = P64[_sdyHH::P64 + 16];
           I64[Hp - 24] = w1_sdyHD_info;
           P64[Hp - 16] = _sdyHC::P64;
           I64[Hp - 8] = sat_sdyHG_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udE4J_srtd" {
     udE4J_srtd:
         const SdyRV_srt+304;
         const 36;
         const 38654705665;
 },
 Data.Functor.Classes.$w$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdE4D,
                       label: Data.Functor.Classes.$w$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE4D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdE4H; else goto cdE4G;
       cdE4H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdE4G: // global
           I64[Hp - 16] = sat_sdyHH_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.276184833 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdE55,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE55: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.280537506 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_closure" {
     Data.Functor.Classes.$fRead1Identity_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Identity1_closure+4;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.282831376 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe7_bytes" {
     Data.Functor.Classes.$fRead1Maybe7_bytes:
         I8[] [78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.285162604 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe6_closure" {
     Data.Functor.Classes.$fRead1Maybe6_closure:
         const Data.Functor.Classes.$fRead1Maybe6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe6_entry() //  [R1]
         { info_tbl: [(cdE5k,
                       label: Data.Functor.Classes.$fRead1Maybe6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE5k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdE5l; else goto cdE5m;
       cdE5l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE5m: // global
           (_cdE5h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdE5h::I64 == 0) goto cdE5j; else goto cdE5i;
       cdE5j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdE5i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdE5h::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.290135273 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_lexeme_closure" {
     Data.Functor.Classes.$fRead1Maybe_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.292831376 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe5_closure" {
     Data.Functor.Classes.$fRead1Maybe5_closure:
         const Data.Functor.Classes.$fRead1Maybe5_info;
         const 0;
 },
 sat_sdyHN_entry() //  [R1]
         { info_tbl: [(cdE5E,
                       label: sat_sdyHN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE5E: // global
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Maybe5_entry() //  [R2, R3]
         { info_tbl: [(cdE5K,
                       label: Data.Functor.Classes.$fRead1Maybe5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE5K: // global
           _sdyHL::P64 = R3;
           _sdyHK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdE5L; else goto cdE5M;
       cdE5M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE5O; else goto cdE5N;
       cdE5O: // global
           HpAlloc = 16;
           goto cdE5L;
       cdE5L: // global
           R3 = _sdyHL::P64;
           R2 = _sdyHK::P64;
           R1 = Data.Functor.Classes.$fRead1Maybe5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE5N: // global
           I64[Hp - 8] = sat_sdyHN_info;
           P64[Hp] = _sdyHL::P64;
           I64[Sp - 8] = block_cdE5H_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Maybe_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdE5H() //  [R1]
         { info_tbl: [(cdE5H,
                       label: block_cdE5H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE5H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE5R; else goto cdE5Q;
       cdE5R: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE5Q: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.302563172 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe4_bytes" {
     Data.Functor.Classes.$fRead1Maybe4_bytes:
         I8[] [74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.30467429 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe3_closure" {
     Data.Functor.Classes.$fRead1Maybe3_closure:
         const Data.Functor.Classes.$fRead1Maybe3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe3_entry() //  [R1]
         { info_tbl: [(cdE6b,
                       label: Data.Functor.Classes.$fRead1Maybe3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdE6c; else goto cdE6d;
       cdE6c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE6d: // global
           (_cdE68::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdE68::I64 == 0) goto cdE6a; else goto cdE69;
       cdE6a: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdE69: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdE68::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.30978656 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe2_closure" {
     Data.Functor.Classes.$fRead1Maybe2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.312955111 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadPrec4_info;
         const 0;
 },
 sat_sdyI2_entry() //  [R1, R2]
         { info_tbl: [(cdE6T,
                       label: sat_sdyI2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE6T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE6X; else goto cdE6W;
       cdE6X: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdE6W: // global
           _sdyHV::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdyHV::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI3_entry() //  [R1, R2]
         { info_tbl: [(cdE6Y,
                       label: sat_sdyI3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE6Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE72; else goto cdE71;
       cdE72: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdE71: // global
           _sdyHQ::P64 = P64[R1 + 7];
           _sdyHV::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdyI2_info;
           P64[Hp] = _sdyHV::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdyHQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI6_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE73,
                       label: sat_sdyI6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE73: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdE74; else goto cdE75;
       cdE74: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE75: // global
           I64[Sp - 24] = block_cdE6z_info;
           _sdyHQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdyHQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udE7i; else goto cdE6A;
       udE7i: // global
           call _cdE6z(R1) args: 0, res: 0, upd: 0;
       cdE6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdE6z() //  [R1]
         { info_tbl: [(cdE6z,
                       label: block_cdE6z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE6z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdE78; else goto cdE77;
       cdE78: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE77: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdE7a; else goto cdE7e;
       cdE7a: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdE7e: // global
           I64[Hp - 16] = sat_sdyI3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdE7b_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Maybe2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdE7b() //  [R1]
         { info_tbl: [(cdE7b,
                       label: block_cdE7b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE7b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE7h; else goto cdE7g;
       cdE7h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdE7g: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyI7_entry() //  [R1]
         { info_tbl: [(cdE7j,
                       label: sat_sdyI7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE7j: // global
           _sdyI7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdE7k; else goto cdE7l;
       cdE7l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE7n; else goto cdE7m;
       cdE7n: // global
           HpAlloc = 16;
           goto cdE7k;
       cdE7k: // global
           R1 = _sdyI7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyI7::P64;
           _sdyHQ::P64 = P64[_sdyI7::P64 + 16];
           _sdyHR::P64 = P64[_sdyI7::P64 + 24];
           _sdyHS::P64 = P64[_sdyI7::P64 + 32];
           I64[Hp - 8] = sat_sdyI6_info;
           P64[Hp] = _sdyHQ::P64;
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udE7y_srtd" {
     udE7y_srtd:
         const SdyRV_srt+64;
         const 70;
         const 175921860444161;
         const 52;
 },
 Data.Functor.Classes.$w$cliftReadPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(cdE7q,
                       label: Data.Functor.Classes.$w$cliftReadPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE7q: // global
           _sdyHS::P64 = R4;
           _sdyHR::P64 = R3;
           _sdyHQ::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdE7r; else goto cdE7s;
       cdE7s: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdE7u; else goto cdE7t;
       cdE7u: // global
           HpAlloc = 40;
           goto cdE7r;
       cdE7r: // global
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = _sdyHQ::P64;
           R1 = Data.Functor.Classes.$w$cliftReadPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE7t: // global
           I64[Hp - 32] = sat_sdyI7_info;
           P64[Hp - 16] = _sdyHQ::P64;
           P64[Hp - 8] = _sdyHR::P64;
           P64[Hp] = _sdyHS::P64;
           I64[Sp - 16] = block_cdE7o_info;
           R4 = _sdyHS::P64;
           R3 = _sdyHR::P64;
           R2 = Data.Functor.Classes.$fRead1Maybe5_closure+2;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdE7o() //  [R1]
         { info_tbl: [(cdE7o,
                       label: block_cdE7o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE7o: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.33246575 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe1_closure" {
     Data.Functor.Classes.$fRead1Maybe1_closure:
         const Data.Functor.Classes.$fRead1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdE8c,
                       label: Data.Functor.Classes.$fRead1Maybe1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE8c: // global
           _sdyIa::P64 = R4;
           R4 = R5;
           R3 = _sdyIa::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.336532757 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec4_info;
         const 0;
 },
 sat_sdyIe_entry() //  [R1, R2]
         { info_tbl: [(cdE8w,
                       label: sat_sdyIe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE8w: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyIf_entry() //  [R1]
         { info_tbl: [(cdE8z,
                       label: sat_sdyIf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE8z: // global
           _sdyIf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdE8A; else goto cdE8B;
       cdE8B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE8D; else goto cdE8C;
       cdE8D: // global
           HpAlloc = 16;
           goto cdE8A;
       cdE8A: // global
           R1 = _sdyIf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE8C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyIf::P64;
           _sdyIc::P64 = P64[_sdyIf::P64 + 16];
           _sdyId::P64 = P64[_sdyIf::P64 + 24];
           I64[Hp - 8] = sat_sdyIe_info;
           P64[Hp] = _sdyIc::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdyId::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec4_entry() //  [R2, R3]
         { info_tbl: [(cdE8E,
                       label: Data.Functor.Classes.$w$cliftReadsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE8E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdE8I; else goto cdE8H;
       cdE8I: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE8H: // global
           I64[Hp - 24] = sat_sdyIf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.344709639 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_entry() //  [R2,
                                                                R4]
         { info_tbl: [(cdE8Y,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE8Y: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec4_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.349336621 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdyIn_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE9e,
                       label: sat_sdyIn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9e: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udE9m_srtd" {
     udE9m_srtd:
         const SdyRV_srt+304;
         const 43;
         const 4947802324993;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cdE9h,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdE9l; else goto cdE9k;
       cdE9l: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdE9k: // global
           I64[Hp - 8] = sat_sdyIn_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.356031459 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList1_closure" {
     Data.Functor.Classes.$w$cliftReadList1_closure:
         const Data.Functor.Classes.$w$cliftReadList1_info;
         const 0;
 },
 w1_sdyIp_entry() //  [R1, R2]
         { info_tbl: [(cdE9I,
                       label: w1_sdyIp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9I: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyIs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdE9Q,
                       label: sat_sdyIs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9Q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udEa3_srtd" {
     udEa3_srtd:
         const SdyRV_srt+304;
         const 40;
         const 549755813889;
 },
 sat_sdyIt_entry() //  [R1]
         { info_tbl: [(cdE9T,
                       label: sat_sdyIt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9T: // global
           _sdyIt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdE9U; else goto cdE9V;
       cdE9V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdE9X; else goto cdE9W;
       cdE9X: // global
           HpAlloc = 32;
           goto cdE9U;
       cdE9U: // global
           R1 = _sdyIt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdE9W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyIt::P64;
           _sdyIo::P64 = P64[_sdyIt::P64 + 16];
           I64[Hp - 24] = w1_sdyIp_info;
           P64[Hp - 16] = _sdyIo::P64;
           I64[Hp - 8] = sat_sdyIs_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udEa4_srtd" {
     udEa4_srtd:
         const SdyRV_srt+304;
         const 44;
         const 9345848836097;
 },
 Data.Functor.Classes.$w$cliftReadList1_entry() //  [R2]
         { info_tbl: [(cdE9Y,
                       label: Data.Functor.Classes.$w$cliftReadList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEa2; else goto cdEa1;
       cdEa2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEa1: // global
           I64[Hp - 16] = sat_sdyIt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.367496984 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdEaq,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEaq: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.370963973 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_closure" {
     Data.Functor.Classes.$fRead1Maybe_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Maybe1_closure+4;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.374495372 UTC

[section ""data" . Data.Functor.Classes.readsBinaryWith_closure" {
     Data.Functor.Classes.readsBinaryWith_closure:
         const Data.Functor.Classes.readsBinaryWith_info;
 },
 go1_sdyIM_entry() //  [R1, R2]
         { info_tbl: [(cdEba,
                       label: go1_sdyIM_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEba: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEbb; else goto cdEbc;
       cdEbb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEbc: // global
           I64[Sp - 40] = block_cdEb3_info;
           _sdyIM::P64 = R1;
           _sdyIz::P64 = P64[R1 + 7];
           _sdyIJ::P64 = P64[R1 + 15];
           _sdyIL::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdyIz::P64;
           P64[Sp - 24] = _sdyIJ::P64;
           P64[Sp - 16] = _sdyIL::P64;
           P64[Sp - 8] = _sdyIM::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udEbw; else goto cdEb4;
       udEbw: // global
           call _cdEb3(R1) args: 0, res: 0, upd: 0;
       cdEb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEb3() //  [R1]
         { info_tbl: [(cdEb3,
                       label: block_cdEb3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEb3: // global
           if (R1 & 7 == 1) goto cdEb7; else goto cdEb8;
       cdEb7: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdEb8: // global
           I64[Sp] = block_cdEbi_info;
           _sdyIQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdyIQ::P64;
           if (R1 & 7 != 0) goto udEbv; else goto cdEbj;
       udEbv: // global
           call _cdEbi(R1) args: 0, res: 0, upd: 0;
       cdEbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEbi() //  [R1]
         { info_tbl: [(cdEbi,
                       label: block_cdEbi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEbi: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdEbu; else goto cdEbt;
       cdEbu: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEbt: // global
           _sdyIS::P64 = P64[R1 + 7];
           _sdyIT::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyIS::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdyIT::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdyID_entry() //  [R1, R2]
         { info_tbl: [(cdEbB,
                       label: go_sdyID_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEbB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEbC; else goto cdEbD;
       cdEbC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEbD: // global
           I64[Sp - 32] = block_cdEaM_info;
           _sdyID::P64 = R1;
           _sdyIx::P64 = P64[R1 + 7];
           _sdyIz::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdyIx::P64;
           P64[Sp - 16] = _sdyIz::P64;
           P64[Sp - 8] = _sdyID::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udEbQ; else goto cdEaN;
       udEbQ: // global
           call _cdEaM(R1) args: 0, res: 0, upd: 0;
       cdEaN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEaM() //  [R1]
         { info_tbl: [(cdEaM,
                       label: block_cdEaM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEaM: // global
           if (R1 & 7 == 1) goto cdEby; else goto cdEbz;
       cdEby: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEbz: // global
           I64[Sp - 8] = block_cdEaS_info;
           _sdyIH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyIH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udEbP; else goto cdEaT;
       udEbP: // global
           call _cdEaS(R1) args: 0, res: 0, upd: 0;
       cdEaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEaS() //  [R1]
         { info_tbl: [(cdEaS,
                       label: block_cdEaS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEaS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdEbK; else goto cdEbJ;
       cdEbK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEbJ: // global
           _sdyIJ::P64 = P64[R1 + 7];
           _sdyIK::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdyIM_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdyIJ::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 24] = block_cdEbG_info;
           R3 = _sdyIK::P64;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = Hp - 23;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEbG() //  [R1]
         { info_tbl: [(cdEbG,
                       label: block_cdEbG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEbG: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdyIM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdEbV,
                       label: Data.Functor.Classes.readsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEbV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdEbW; else goto cdEbX;
       cdEbW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEbX: // global
           I64[Sp - 32] = block_cdEaC_info;
           _sdyIx::P64 = R3;
           R3 = R4;
           _sdyIw::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdyIw::P64;
           P64[Sp - 16] = _sdyIx::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdEaC() //  [R1]
         { info_tbl: [(cdEaC,
                       label: block_cdEaC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEaC: // global
           if (R1 & 7 == 1) goto cdEbS; else goto cdEbT;
       cdEbS: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEbT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEc3; else goto cdEc2;
       cdEc3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEc2: // global
           I64[Hp - 16] = go_sdyID_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdEc0_info;
           R3 = P64[Sp + 32];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEc0() //  [R1]
         { info_tbl: [(cdEc0,
                       label: block_cdEc0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEc0: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyID_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.400118422 UTC

[section ""data" . Data.Functor.Classes.$wreadBinaryWith_closure" {
     Data.Functor.Classes.$wreadBinaryWith_closure:
         const Data.Functor.Classes.$wreadBinaryWith_info;
         const 0;
 },
 lvl3_sdyJ7_entry() //  [R1]
         { info_tbl: [(cdEdq,
                       label: lvl3_sdyJ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEdq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEdx; else goto cdEdy;
       cdEdx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEdy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdEdn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEdC; else goto cdEdo;
       udEdC: // global
           call _cdEdn(R1) args: 0, res: 0, upd: 0;
       cdEdo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdEdn() //  [R1]
         { info_tbl: [(cdEdn,
                       label: block_cdEdn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEdn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEdB; else goto cdEdA;
       cdEdB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdEdA: // global
           _sdyJa::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdyJa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJe_entry() //  [R1, R2]
         { info_tbl: [(cdEdO,
                       label: sat_sdyJe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEdO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdEdS; else goto cdEdR;
       cdEdS: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEdR: // global
           _sdyJ2::P64 = P64[R1 + 7];
           _sdyJ4::P64 = P64[R1 + 15];
           _sdyJb::P64 = P64[R1 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJb::P64;
           P64[Hp] = R2;
           R2 = Hp - 32;
           R1 = _sdyJ4::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJf_entry() //  [R1, R2]
         { info_tbl: [(cdEdT,
                       label: sat_sdyJf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEdT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdEdX; else goto cdEdW;
       cdEdX: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEdW: // global
           _sdyJ0::P64 = P64[R1 + 7];
           _sdyJ2::P64 = P64[R1 + 15];
           _sdyJ4::P64 = P64[R1 + 23];
           _sdyJ7::P64 = P64[R1 + 31];
           I64[Hp - 24] = sat_sdyJe_info;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJ4::P64;
           P64[Hp] = R2;
           R3 = Hp - 23;
           R2 = _sdyJ7::P64;
           R1 = _sdyJ0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJg_entry() //  [R1, R2]
         { info_tbl: [(cdEdY,
                       label: sat_sdyJg_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEdY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdEe2; else goto cdEe1;
       cdEe2: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEe1: // global
           _sdyIZ::P64 = P64[R1 + 7];
           _sdyJ0::P64 = P64[R1 + 15];
           _sdyJ2::P64 = P64[R1 + 23];
           _sdyJ3::P64 = P64[R1 + 31];
           _sdyJ4::P64 = P64[R1 + 39];
           I64[Hp - 56] = lvl3_sdyJ7_info;
           P64[Hp - 40] = _sdyJ3::P64;
           I64[Hp - 32] = sat_sdyJf_info;
           P64[Hp - 24] = _sdyJ0::P64;
           P64[Hp - 16] = _sdyJ2::P64;
           P64[Hp - 8] = _sdyJ4::P64;
           _cdEdj::P64 = Hp - 56;
           P64[Hp] = _cdEdj::P64;
           R3 = Hp - 31;
           R2 = _cdEdj::P64;
           R1 = _sdyIZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadBinaryWith_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdEe4,
                       label: Data.Functor.Classes.$wreadBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEe4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdEe8; else goto cdEe7;
       cdEe8: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEe7: // global
           I64[Hp - 56] = sat_sdyJg_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R4;
           R3 = Hp - 55;
           R2 = Hp - 4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.415415857 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith1_closure" {
     Data.Functor.Classes.readBinaryWith1_closure:
         const Data.Functor.Classes.readBinaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith1_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdEeE,
                       label: Data.Functor.Classes.readBinaryWith1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEeE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdEeF; else goto cdEeG;
       cdEeF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readBinaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEeG: // global
           _sdyJm::P64 = P64[Sp];
           I64[Sp] = block_cdEeB_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _sdyJm::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadBinaryWith_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _cdEeB() //  [R1]
         { info_tbl: [(cdEeB,
                       label: block_cdEeB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEeB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEeJ; else goto cdEeI;
       cdEeJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEeI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.421701992 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith_closure" {
     Data.Functor.Classes.readBinaryWith_closure:
         const Data.Functor.Classes.readBinaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdEeX,
                       label: Data.Functor.Classes.readBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEeX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readBinaryWith1_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.42655535 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnaryWith_closure" {
     Data.Functor.Classes.$wshowsUnaryWith_closure:
         const Data.Functor.Classes.$wshowsUnaryWith_info;
 },
 Data.Functor.Classes.$wshowsUnaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEf5: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdyJt_entry() //  [R1]
         { info_tbl: [(cdEfd,
                       label: g_sdyJt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEfd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEfe; else goto cdEff;
       cdEfe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEff: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJy_entry() //  [R1, R2]
         { info_tbl: [(cdEfq,
                       label: sat_sdyJy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEfq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEfu; else goto cdEft;
       cdEfu: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEft: // global
           _sdyJq::P64 = P64[R1 + 7];
           _sdyJt::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyJq::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyJB_entry() //  [R1]
         { info_tbl: [(cdEfK,
                       label: sat_sdyJB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEfK: // global
           _sdyJB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdEfL; else goto cdEfM;
       cdEfM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEfO; else goto cdEfN;
       cdEfO: // global
           HpAlloc = 24;
           goto cdEfL;
       cdEfL: // global
           R1 = _sdyJB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEfN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyJB::P64;
           _sdyJt::P64 = P64[_sdyJB::P64 + 16];
           _sdyJz::P64 = P64[_sdyJB::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyJz::P64;
           R2 = Hp - 14;
           R1 = _sdyJt::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJD_entry() //  [R1]
         { info_tbl: [(cdEfQ,
                       label: sat_sdyJD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEfQ: // global
           _sdyJD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdEfR; else goto cdEfS;
       cdEfS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEfU; else goto cdEfT;
       cdEfU: // global
           HpAlloc = 56;
           goto cdEfR;
       cdEfR: // global
           R1 = _sdyJD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEfT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyJD::P64;
           _sdyJq::P64 = P64[_sdyJD::P64 + 16];
           _sdyJt::P64 = P64[_sdyJD::P64 + 24];
           _sdyJz::P64 = P64[_sdyJD::P64 + 32];
           I64[Hp - 48] = sat_sdyJB_info;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = _sdyJz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyJq::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyJE_entry() //  [R1, R2]
         { info_tbl: [(cdEfW,
                       label: sat_sdyJE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEfW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdEg0; else goto cdEfZ;
       cdEg0: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEfZ: // global
           _sdyJq::P64 = P64[R1 + 7];
           _sdyJt::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyJD_info;
           P64[Hp - 40] = _sdyJq::P64;
           P64[Hp - 32] = _sdyJt::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEg4,
                       label: Data.Functor.Classes.$wshowsUnaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEg4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEg8; else goto cdEg7;
       cdEg8: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnaryWith_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdEg7: // global
           I64[Hp - 48] = g_sdyJt_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdEf9::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdEg2; else goto cdEg3;
       cdEg2: // global
           I64[Hp - 16] = sat_sdyJy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdEf9::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEg3: // global
           I64[Hp - 16] = sat_sdyJE_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdEf9::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.444773339 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith_closure" {
     Data.Functor.Classes.showsUnaryWith_closure:
         const Data.Functor.Classes.showsUnaryWith_info;
 },
 Data.Functor.Classes.showsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEgK,
                       label: Data.Functor.Classes.showsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEgK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdEgL; else goto cdEgM;
       cdEgL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnaryWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEgM: // global
           I64[Sp - 32] = block_cdEgH_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udEgQ; else goto cdEgI;
       udEgQ: // global
           call _cdEgH(R1) args: 0, res: 0, upd: 0;
       cdEgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEgH() //  [R1]
         { info_tbl: [(cdEgH,
                       label: block_cdEgH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEgH: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.45081079 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdEh7,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEh7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEh8; else goto cdEh9;
       cdEh8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEh9: // global
           I64[Sp - 16] = block_cdEh4_info;
           R1 = R6;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udEhd; else goto cdEh5;
       udEhd: // global
           call _cdEh4(R1) args: 0, res: 0, upd: 0;
       cdEh5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEh4() //  [R1]
         { info_tbl: [(cdEh4,
                       label: block_cdEh4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEh4: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.45672447 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_info;
         const 0;
 },
 sat_sdyK0_entry() //  [R1, R2]
         { info_tbl: [(cdEhw,
                       label: sat_sdyK0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEhw: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowList2_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdEhz,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEhz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEhD; else goto cdEhC;
       cdEhD: // global
           HpAlloc = 16;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEhC: // global
           I64[Hp - 8] = sat_sdyK0_info;
           P64[Hp] = R2;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.462910709 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_closure" {
     Data.Functor.Classes.$fShow2Const_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.46528908 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info;
         const 0;
 },
 sat_sdyK8_entry() //  [R1]
         { info_tbl: [(cdEhZ,
                       label: sat_sdyK8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEhZ: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdEi2,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEi2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEi3; else goto cdEi4;
       cdEi3: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEi4: // global
           I64[Sp - 24] = block_cdEhQ_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R6;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEi8; else goto cdEhR;
       udEi8: // global
           call _cdEhQ(R1) args: 0, res: 0, upd: 0;
       cdEhR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEhQ() //  [R1]
         { info_tbl: [(cdEhQ,
                       label: block_cdEhQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEhQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEi7; else goto cdEi6;
       cdEi7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEi6: // global
           _sdyK7::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sdyK8_info;
           P64[Hp] = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = _sdyK7::I64;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.474240205 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_info;
         const 0;
 },
 lvl3_sdyKe_entry() //  [R1]
         { info_tbl: [(cdEiu,
                       label: lvl3_sdyKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEiu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEiv; else goto cdEiw;
       cdEiv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEiw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyKg_entry() //  [R1, R2]
         { info_tbl: [(cdEiC,
                       label: sat_sdyKg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEiC: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowList_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdEiF,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEiF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdEiJ; else goto cdEiI;
       cdEiJ: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEiI: // global
           I64[Hp - 32] = lvl3_sdyKe_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdyKg_info;
           P64[Hp] = Hp - 32;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.482595233 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_closure" {
     Data.Functor.Classes.$fShow1Const_closure:
         const Data.Functor.Classes.$fShow1Const_info;
         const 0;
 },
 sat_sdyKj_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdEj5,
                       label: sat_sdyKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEj5: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowList_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyKi_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdEjd,
                       label: sat_sdyKi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEjd: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_entry() //  [R2]
         { info_tbl: [(cdEjh,
                       label: Data.Functor.Classes.$fShow1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEjh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEjl; else goto cdEjk;
       cdEjl: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEjk: // global
           I64[Hp - 48] = sat_sdyKj_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyKi_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.490945305 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cdEjK,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEjK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEjL; else goto cdEjM;
       cdEjL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEjM: // global
           I64[Sp - 24] = block_cdEjD_info;
           R1 = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEk7; else goto cdEjE;
       udEk7: // global
           call _cdEjD(R1) args: 0, res: 0, upd: 0;
       cdEjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEjD() //  [R1]
         { info_tbl: [(cdEjD,
                       label: block_cdEjD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEjD: // global
           _sdyKo::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdEjH; else goto cdEjI;
       cdEjH: // global
           I64[Sp + 8] = block_cdEjP_info;
           _sdyKr::P64 = P64[R1 + 7];
           R1 = _sdyKo::P64;
           P64[Sp + 16] = _sdyKr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udEk5; else goto cdEjR;
       udEk5: // global
           call _cdEjP(R1) args: 0, res: 0, upd: 0;
       cdEjR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdEjI: // global
           I64[Sp] = block_cdEjY_info;
           _sdyKu::P64 = P64[R1 + 6];
           R1 = _sdyKo::P64;
           P64[Sp + 24] = _sdyKu::P64;
           if (R1 & 7 != 0) goto udEk6; else goto cdEk0;
       udEk6: // global
           call _cdEjY(R1) args: 0, res: 0, upd: 0;
       cdEk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEjP() //  [R1]
         { info_tbl: [(cdEjP,
                       label: block_cdEjP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEjP: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 _cdEjY() //  [R1]
         { info_tbl: [(cdEjY,
                       label: block_cdEjY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEjY: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.502988011 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList4_closure" {
     Data.Functor.Classes.$w$cliftShowList4_closure:
         const Data.Functor.Classes.$w$cliftShowList4_info;
         const 0;
 },
 sat_sdyKF_entry() //  [R1, R2]
         { info_tbl: [(cdEkH,
                       label: sat_sdyKF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEkH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEkI; else goto cdEkJ;
       cdEkI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEkJ: // global
           I64[Sp - 24] = block_cdEkA_info;
           _sdyKx::P64 = P64[R1 + 7];
           _sdyKy::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyKx::P64;
           P64[Sp - 8] = _sdyKy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEkQ; else goto cdEkB;
       udEkQ: // global
           call _cdEkA(R1) args: 0, res: 0, upd: 0;
       cdEkB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEkA() //  [R1]
         { info_tbl: [(cdEkA,
                       label: block_cdEkA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEkA: // global
           if (R1 & 7 == 1) goto cdEkE; else goto cdEkF;
       cdEkE: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdEkF: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEkR,
                       label: Data.Functor.Classes.$w$cliftShowList4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEkR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEkV; else goto cdEkU;
       cdEkV: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEkU: // global
           I64[Hp - 16] = sat_sdyKF_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdyKz::P64 = R4;
           R4 = R5;
           R3 = _sdyKz::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.512780999 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowList2_entry() //  [R2,
                                                                 R4, R6]
         { info_tbl: [(cdEle,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEle: // global
           R5 = P64[Sp];
           _sdyKI::P64 = R4;
           R4 = R6;
           R3 = _sdyKI::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList4_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.517782026 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_closure" {
     Data.Functor.Classes.$fShow2Either_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.520584607 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEln: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyKS_entry() //  [R1]
         { info_tbl: [(cdElA,
                       label: sat_sdyKS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdElA: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdElH,
                       label: Data.Functor.Classes.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdElH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdElI; else goto cdElJ;
       cdElI: // global
           R1 = Data.Functor.Classes.$w$cliftShowsPrec_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdElJ: // global
           I64[Sp - 32] = block_cdElr_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udElQ; else goto cdEls;
       udElQ: // global
           call _cdElr(R1) args: 0, res: 0, upd: 0;
       cdEls: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdElr() //  [R1]
         { info_tbl: [(cdElr,
                       label: block_cdElr_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdElr: // global
           _sdyKO::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cdElE; else goto cdElF;
       cdElE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdElM; else goto cdElL;
       cdElM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdElL: // global
           _sdyKR::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sdyKS_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdyKR::P64;
           R4 = _sdyKO::I64;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = Hp - 16;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdElF: // global
           R5 = P64[R1 + 6];
           R4 = _sdyKO::I64;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.53214198 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdEmf,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEmf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdEmg; else goto cdEmh;
       cdEmg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEmh: // global
           I64[Sp - 32] = block_cdEmc_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udEml; else goto cdEmd;
       udEml: // global
           call _cdEmc(R1) args: 0, res: 0, upd: 0;
       cdEmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEmc() //  [R1]
         { info_tbl: [(cdEmc,
                       label: block_cdEmc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEmc: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.539960147 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList1_closure" {
     Data.Functor.Classes.$w$cliftShowList1_closure:
         const Data.Functor.Classes.$w$cliftShowList1_info;
         const 0;
 },
 lvl3_sdyL5_entry() //  [R1]
         { info_tbl: [(cdEmD,
                       label: lvl3_sdyL5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEmD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEmE; else goto cdEmF;
       cdEmE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEmF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyLa_entry() //  [R1, R2]
         { info_tbl: [(cdEmS,
                       label: sat_sdyLa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEmS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEmT; else goto cdEmU;
       cdEmT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEmU: // global
           I64[Sp - 24] = block_cdEmL_info;
           _sdyL2::P64 = P64[R1 + 7];
           _sdyL5::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdyL2::P64;
           P64[Sp - 8] = _sdyL5::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEn1; else goto cdEmM;
       udEn1: // global
           call _cdEmL(R1) args: 0, res: 0, upd: 0;
       cdEmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEmL() //  [R1]
         { info_tbl: [(cdEmL,
                       label: block_cdEmL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEmL: // global
           if (R1 & 7 == 1) goto cdEmP; else goto cdEmQ;
       cdEmP: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdEmQ: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEn2,
                       label: Data.Functor.Classes.$w$cliftShowList1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEn2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdEn6; else goto cdEn5;
       cdEn6: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEn5: // global
           I64[Hp - 40] = lvl3_sdyL5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdyLa_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdyL3::P64 = R4;
           R4 = R5;
           R3 = _sdyL3::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.55087445 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowList_entry() //  [R2,
                                                                R3, R5, R6]
         { info_tbl: [(cdEnu,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEnu: // global
           _sdyLe::P64 = R5;
           R5 = R6;
           R4 = _sdyLe::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.555100344 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_closure" {
     Data.Functor.Classes.$fShow1Either_closure:
         const Data.Functor.Classes.$fShow1Either_info;
         const 0;
 },
 sat_sdyLm_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdEnK,
                       label: sat_sdyLm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEnK: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyLh_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdEnS,
                       label: sat_sdyLh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEnS: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Either_entry() //  [R2]
         { info_tbl: [(cdEnW,
                       label: Data.Functor.Classes.$fShow1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEnW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEo0; else goto cdEnZ;
       cdEo0: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEnZ: // global
           I64[Hp - 48] = sat_sdyLm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdyLh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.563606917 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdEol,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEol: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEom; else goto cdEon;
       cdEom: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEon: // global
           I64[Sp - 24] = block_cdEoi_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEor; else goto cdEoj;
       udEor: // global
           call _cdEoi(R1) args: 0, res: 0, upd: 0;
       cdEoj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEoi() //  [R1]
         { info_tbl: [(cdEoi,
                       label: block_cdEoi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEoi: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.569556629 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_info;
         const 0;
 },
 sat_sdyLy_entry() //  [R1, R2]
         { info_tbl: [(cdEoK,
                       label: sat_sdyLy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEoK: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdEoN,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEoN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEoR; else goto cdEoQ;
       cdEoR: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEoQ: // global
           I64[Hp - 8] = sat_sdyLy_info;
           P64[Hp] = R2;
           _sdyLv::P64 = R4;
           R4 = R5;
           R3 = _sdyLv::P64;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.575404397 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_closure" {
     Data.Functor.Classes.$fShow1Identity_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.577436042 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe1_closure" {
     Data.Functor.Classes.$fShow1Maybe1_closure:
         const Data.Functor.Classes.$fShow1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe1_entry() //  [R2]
         { info_tbl: [(cdEp4,
                       label: Data.Functor.Classes.$fShow1Maybe1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEp4: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Maybe6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.581261627 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdEpm,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEpm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdEpn; else goto cdEpo;
       cdEpn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEpo: // global
           I64[Sp - 24] = block_cdEpf_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEpC; else goto cdEpg;
       udEpC: // global
           call _cdEpf(R1) args: 0, res: 0, upd: 0;
       cdEpg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEpf() //  [R1]
         { info_tbl: [(cdEpf,
                       label: block_cdEpf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEpf: // global
           if (R1 & 7 == 1) goto cdEpj; else goto cdEpk;
       cdEpj: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEpk: // global
           I64[Sp] = block_cdEpu_info;
           _sdyLE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdyLE::P64;
           if (R1 & 7 != 0) goto udEpB; else goto cdEpw;
       udEpB: // global
           call _cdEpu(R1) args: 0, res: 0, upd: 0;
       cdEpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEpu() //  [R1]
         { info_tbl: [(cdEpu,
                       label: block_cdEpu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEpu: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.590010884 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList2_closure" {
     Data.Functor.Classes.$w$cliftShowList2_closure:
         const Data.Functor.Classes.$w$cliftShowList2_info;
         const 0;
 },
 sat_sdyLN_entry() //  [R1, R2]
         { info_tbl: [(cdEq9,
                       label: sat_sdyLN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEq9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEqa; else goto cdEqb;
       cdEqa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEqb: // global
           I64[Sp - 16] = block_cdEq2_info;
           _sdyLH::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdyLH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udEqi; else goto cdEq3;
       udEqi: // global
           call _cdEq2(R1) args: 0, res: 0, upd: 0;
       cdEq3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEq2() //  [R1]
         { info_tbl: [(cdEq2,
                       label: block_cdEq2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEq2: // global
           if (R1 & 7 == 1) goto cdEq6; else goto cdEq7;
       cdEq6: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEq7: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdEqj,
                       label: Data.Functor.Classes.$w$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEqj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEqn; else goto cdEqm;
       cdEqn: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEqm: // global
           I64[Hp - 8] = sat_sdyLN_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.598655639 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowList_entry() //  [R2,
                                                               R4, R5]
         { info_tbl: [(cdEqH,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEqH: // global
           _sdyLQ::P64 = R4;
           R4 = R5;
           R3 = _sdyLQ::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.602386096 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_closure" {
     Data.Functor.Classes.$fShow1Maybe_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.605984408 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinaryWith_closure" {
     Data.Functor.Classes.$wshowsBinaryWith_closure:
         const Data.Functor.Classes.$wshowsBinaryWith_info;
 },
 Data.Functor.Classes.$wshowsBinaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEqQ: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 f_sdyLY_entry() //  [R1]
         { info_tbl: [(cdEqY,
                       label: f_sdyLY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEqY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEqZ; else goto cdEr0;
       cdEqZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEr0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sdyLZ_entry() //  [R1]
         { info_tbl: [(cdEr5,
                       label: g_sdyLZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEr5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdEr6; else goto cdEr7;
       cdEr6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEr7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyM4_entry() //  [R1]
         { info_tbl: [(cdErm,
                       label: sat_sdyM4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdErm: // global
           _sdyM4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdErn; else goto cdEro;
       cdEro: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdErq; else goto cdErp;
       cdErq: // global
           HpAlloc = 56;
           goto cdErn;
       cdErn: // global
           R1 = _sdyM4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdErp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyM4::P64;
           _sdyLY::P64 = P64[_sdyM4::P64 + 16];
           _sdyLZ::P64 = P64[_sdyM4::P64 + 24];
           _sdyM1::P64 = P64[_sdyM4::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM1::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyLY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyM6_entry() //  [R1, R2]
         { info_tbl: [(cdErs,
                       label: sat_sdyM6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdErs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdErw; else goto cdErv;
       cdErw: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdErv: // global
           _sdyLU::P64 = P64[R1 + 7];
           _sdyLY::P64 = P64[R1 + 15];
           _sdyLZ::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdyM4_info;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyLU::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyM9_entry() //  [R1]
         { info_tbl: [(cdErQ,
                       label: sat_sdyM9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdErQ: // global
           _sdyM9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdErR; else goto cdErS;
       cdErS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdErU; else goto cdErT;
       cdErU: // global
           HpAlloc = 24;
           goto cdErR;
       cdErR: // global
           R1 = _sdyM9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdErT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyM9::P64;
           _sdyLZ::P64 = P64[_sdyM9::P64 + 16];
           _sdyM7::P64 = P64[_sdyM9::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyM7::P64;
           R2 = Hp - 14;
           R1 = _sdyLZ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMb_entry() //  [R1]
         { info_tbl: [(cdErW,
                       label: sat_sdyMb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdErW: // global
           _sdyMb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdErX; else goto cdErY;
       cdErY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEs0; else goto cdErZ;
       cdEs0: // global
           HpAlloc = 56;
           goto cdErX;
       cdErX: // global
           R1 = _sdyMb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdErZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMb::P64;
           _sdyLY::P64 = P64[_sdyMb::P64 + 16];
           _sdyLZ::P64 = P64[_sdyMb::P64 + 24];
           _sdyM7::P64 = P64[_sdyMb::P64 + 32];
           I64[Hp - 48] = sat_sdyM9_info;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdyLY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMd_entry() //  [R1]
         { info_tbl: [(cdEs2,
                       label: sat_sdyMd_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEs2: // global
           _sdyMd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdEs3; else goto cdEs4;
       cdEs4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdEs6; else goto cdEs5;
       cdEs6: // global
           HpAlloc = 64;
           goto cdEs3;
       cdEs3: // global
           R1 = _sdyMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEs5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMd::P64;
           _sdyLU::P64 = P64[_sdyMd::P64 + 16];
           _sdyLY::P64 = P64[_sdyMd::P64 + 24];
           _sdyLZ::P64 = P64[_sdyMd::P64 + 32];
           _sdyM7::P64 = P64[_sdyMd::P64 + 40];
           I64[Hp - 56] = sat_sdyMb_info;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = _sdyM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdyLU::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMe_entry() //  [R1, R2]
         { info_tbl: [(cdEs8,
                       label: sat_sdyMe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEs8: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdEsc; else goto cdEsb;
       cdEsc: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEsb: // global
           _sdyLU::P64 = P64[R1 + 7];
           _sdyLY::P64 = P64[R1 + 15];
           _sdyLZ::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdyMd_info;
           P64[Hp - 48] = _sdyLU::P64;
           P64[Hp - 40] = _sdyLY::P64;
           P64[Hp - 32] = _sdyLZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdEsg,
                       label: Data.Functor.Classes.$wshowsBinaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEsg: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdEsk; else goto cdEsj;
       cdEsk: // global
           HpAlloc = 96;
           R1 = Data.Functor.Classes.$wshowsBinaryWith_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cdEsj: // global
           I64[Hp - 88] = f_sdyLY_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R6;
           I64[Hp - 56] = g_sdyLZ_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = P64[Sp];
           _cdEqU::P64 = Hp - 88;
           _cdEr1::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdEse; else goto cdEsf;
       cdEse: // global
           I64[Hp - 24] = sat_sdyM6_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdEqU::P64;
           P64[Hp] = _cdEr1::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEsf: // global
           I64[Hp - 24] = sat_sdyMe_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdEqU::P64;
           P64[Hp] = _cdEr1::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.63041353 UTC

[section ""data" . Data.Functor.Classes.showsBinaryWith_closure" {
     Data.Functor.Classes.showsBinaryWith_closure:
         const Data.Functor.Classes.showsBinaryWith_info;
 },
 Data.Functor.Classes.showsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdEtb,
                       label: Data.Functor.Classes.showsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEtb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEtc; else goto cdEtd;
       cdEtc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdEtd: // global
           I64[Sp - 40] = block_cdEt8_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udEth; else goto cdEt9;
       udEth: // global
           call _cdEt8(R1) args: 0, res: 0, upd: 0;
       cdEt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEt8() //  [R1]
         { info_tbl: [(cdEt8,
                       label: block_cdEt8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEt8: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.637784846 UTC

[section ""data" . Data.Functor.Classes.readsUnary_closure" {
     Data.Functor.Classes.readsUnary_closure:
         const Data.Functor.Classes.readsUnary_info;
 },
 go_sdyMt_entry() //  [R1, R2]
         { info_tbl: [(cdEtM,
                       label: go_sdyMt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEtM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdEtN; else goto cdEtO;
       cdEtN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEtO: // global
           I64[Sp - 24] = block_cdEtF_info;
           _sdyMt::P64 = R1;
           _sdyMp::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdyMp::P64;
           P64[Sp - 8] = _sdyMt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udEu8; else goto cdEtG;
       udEu8: // global
           call _cdEtF(R1) args: 0, res: 0, upd: 0;
       cdEtG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEtF() //  [R1]
         { info_tbl: [(cdEtF,
                       label: block_cdEtF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEtF: // global
           if (R1 & 7 == 1) goto cdEtJ; else goto cdEtK;
       cdEtJ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEtK: // global
           I64[Sp - 8] = block_cdEtU_info;
           _sdyMx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdyMx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udEu7; else goto cdEtV;
       udEu7: // global
           call _cdEtU(R1) args: 0, res: 0, upd: 0;
       cdEtV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEtU() //  [R1]
         { info_tbl: [(cdEtU,
                       label: block_cdEtU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEtU: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdEu6; else goto cdEu5;
       cdEu6: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEu5: // global
           _sdyMz::P64 = P64[R1 + 7];
           _sdyMA::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdyMz::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdyMA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnary_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdEud,
                       label: Data.Functor.Classes.readsUnary_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEud: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEue; else goto cdEuf;
       cdEue: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEuf: // global
           I64[Sp - 32] = block_cdEtv_info;
           R3 = R3;
           _sdyMn::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdyMn::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdEtv() //  [R1]
         { info_tbl: [(cdEtv,
                       label: block_cdEtv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEtv: // global
           if (R1 & 7 == 1) goto cdEua; else goto cdEub;
       cdEua: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEub: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEul; else goto cdEuk;
       cdEul: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEuk: // global
           I64[Hp - 8] = go_sdyMt_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdEui_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdEui() //  [R1]
         { info_tbl: [(cdEui,
                       label: block_cdEui_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEui: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdyMt_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.655462429 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary_closure" {
     Data.Functor.Classes.$wshowsUnary_closure:
         const Data.Functor.Classes.$wshowsUnary_info;
 },
 Data.Functor.Classes.$wshowsUnary_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEv4: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdyMJ_entry() //  [R1]
         { info_tbl: [(cdEvc,
                       label: g_sdyMJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEvc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEvd; else goto cdEve;
       cdEvd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEve: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdyMO_entry() //  [R1, R2]
         { info_tbl: [(cdEvp,
                       label: sat_sdyMO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEvp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEvt; else goto cdEvs;
       cdEvt: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEvs: // global
           _sdyMG::P64 = P64[R1 + 7];
           _sdyMJ::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyMG::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdyMR_entry() //  [R1]
         { info_tbl: [(cdEvJ,
                       label: sat_sdyMR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEvJ: // global
           _sdyMR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdEvK; else goto cdEvL;
       cdEvL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEvN; else goto cdEvM;
       cdEvN: // global
           HpAlloc = 24;
           goto cdEvK;
       cdEvK: // global
           R1 = _sdyMR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEvM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMR::P64;
           _sdyMJ::P64 = P64[_sdyMR::P64 + 16];
           _sdyMP::P64 = P64[_sdyMR::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdyMP::P64;
           R2 = Hp - 14;
           R1 = _sdyMJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMT_entry() //  [R1]
         { info_tbl: [(cdEvP,
                       label: sat_sdyMT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEvP: // global
           _sdyMT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdEvQ; else goto cdEvR;
       cdEvR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEvT; else goto cdEvS;
       cdEvT: // global
           HpAlloc = 56;
           goto cdEvQ;
       cdEvQ: // global
           R1 = _sdyMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEvS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdyMT::P64;
           _sdyMG::P64 = P64[_sdyMT::P64 + 16];
           _sdyMJ::P64 = P64[_sdyMT::P64 + 24];
           _sdyMP::P64 = P64[_sdyMT::P64 + 32];
           I64[Hp - 48] = sat_sdyMR_info;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = _sdyMP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdyMG::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdyMU_entry() //  [R1, R2]
         { info_tbl: [(cdEvV,
                       label: sat_sdyMU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEvV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdEvZ; else goto cdEvY;
       cdEvZ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdEvY: // global
           _sdyMG::P64 = P64[R1 + 7];
           _sdyMJ::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdyMT_info;
           P64[Hp - 40] = _sdyMG::P64;
           P64[Hp - 32] = _sdyMJ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEw3,
                       label: Data.Functor.Classes.$wshowsUnary_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEw3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdEw7; else goto cdEw6;
       cdEw7: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnary_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdEw6: // global
           I64[Hp - 48] = g_sdyMJ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdEv8::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdEw1; else goto cdEw2;
       cdEw1: // global
           I64[Hp - 16] = sat_sdyMO_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdEv8::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdEw2: // global
           I64[Hp - 16] = sat_sdyMU_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdEv8::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.671903949 UTC

[section ""data" . Data.Functor.Classes.showsUnary_closure" {
     Data.Functor.Classes.showsUnary_closure:
         const Data.Functor.Classes.showsUnary_info;
 },
 Data.Functor.Classes.showsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEwK,
                       label: Data.Functor.Classes.showsUnary_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEwK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdEwL; else goto cdEwM;
       cdEwL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEwM: // global
           I64[Sp - 32] = block_cdEwH_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udEwQ; else goto cdEwI;
       udEwQ: // global
           call _cdEwH(R1) args: 0, res: 0, upd: 0;
       cdEwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdEwH() //  [R1]
         { info_tbl: [(cdEwH,
                       label: block_cdEwH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEwH: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.677836924 UTC

[section ""cstring" . Data.Functor.Classes.$trModule4_bytes" {
     Data.Functor.Classes.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.679659272 UTC

[section ""data" . Data.Functor.Classes.$trModule3_closure" {
     Data.Functor.Classes.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.682023363 UTC

[section ""cstring" . Data.Functor.Classes.$trModule2_bytes" {
     Data.Functor.Classes.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.683810018 UTC

[section ""data" . Data.Functor.Classes.$trModule1_closure" {
     Data.Functor.Classes.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.685852376 UTC

[section ""data" . Data.Functor.Classes.$trModule_closure" {
     Data.Functor.Classes.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Classes.$trModule3_closure+1;
         const Data.Functor.Classes.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.687674397 UTC

[section ""data" . $krep_rdymB_closure" {
     $krep_rdymB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.689566685 UTC

[section ""data" . Data.Functor.Classes.$tcEq4_closure" {
     Data.Functor.Classes.$tcEq4_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.691361668 UTC

[section ""data" . Data.Functor.Classes.$tcEq7_closure" {
     Data.Functor.Classes.$tcEq7_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.693169683 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq6_bytes" {
     Data.Functor.Classes.$tcEq6_bytes:
         I8[] [69,113,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.69495519 UTC

[section ""data" . Data.Functor.Classes.$tcEq5_closure" {
     Data.Functor.Classes.$tcEq5_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.696724336 UTC

[section ""data" . Data.Functor.Classes.$tcEq1_closure" {
     Data.Functor.Classes.$tcEq1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq5_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 71749974434880567;
         const 7233443027070644957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.69863153 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd5_bytes" {
     Data.Functor.Classes.$tcOrd5_bytes:
         I8[] [79,114,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.700404495 UTC

[section ""data" . Data.Functor.Classes.$tcOrd4_closure" {
     Data.Functor.Classes.$tcOrd4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.702457928 UTC

[section ""data" . Data.Functor.Classes.$tcOrd1_closure" {
     Data.Functor.Classes.$tcOrd1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 11825914698899667233;
         const 4554948325937498991;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.704417923 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead5_bytes" {
     Data.Functor.Classes.$tcRead5_bytes:
         I8[] [82,101,97,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.706250271 UTC

[section ""data" . Data.Functor.Classes.$tcRead4_closure" {
     Data.Functor.Classes.$tcRead4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.708055522 UTC

[section ""data" . Data.Functor.Classes.$tcRead1_closure" {
     Data.Functor.Classes.$tcRead1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 14547308444716217043;
         const 925634574698086715;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.710719251 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow5_bytes" {
     Data.Functor.Classes.$tcShow5_bytes:
         I8[] [83,104,111,119,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.712456604 UTC

[section ""data" . Data.Functor.Classes.$tcShow4_closure" {
     Data.Functor.Classes.$tcShow4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.71427724 UTC

[section ""data" . Data.Functor.Classes.$tcShow1_closure" {
     Data.Functor.Classes.$tcShow1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 4743290066722511112;
         const 6779909240154408836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.716114582 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq9_bytes" {
     Data.Functor.Classes.$tcEq9_bytes:
         I8[] [69,113,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.718441395 UTC

[section ""data" . Data.Functor.Classes.$tcEq8_closure" {
     Data.Functor.Classes.$tcEq8_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.720229625 UTC

[section ""data" . Data.Functor.Classes.$tcEq2_closure" {
     Data.Functor.Classes.$tcEq2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq8_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 16920549266159426738;
         const 13264288076834164909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.722156176 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd7_bytes" {
     Data.Functor.Classes.$tcOrd7_bytes:
         I8[] [79,114,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.723835214 UTC

[section ""data" . Data.Functor.Classes.$tcOrd6_closure" {
     Data.Functor.Classes.$tcOrd6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.725656408 UTC

[section ""data" . Data.Functor.Classes.$tcOrd2_closure" {
     Data.Functor.Classes.$tcOrd2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 4167316048525678806;
         const 17649124474771181823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.727593065 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead7_bytes" {
     Data.Functor.Classes.$tcRead7_bytes:
         I8[] [82,101,97,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.72934596 UTC

[section ""data" . Data.Functor.Classes.$tcRead6_closure" {
     Data.Functor.Classes.$tcRead6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.731142584 UTC

[section ""data" . Data.Functor.Classes.$tcRead2_closure" {
     Data.Functor.Classes.$tcRead2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 615267248700376470;
         const 8978126042197021701;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.733085361 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow7_bytes" {
     Data.Functor.Classes.$tcShow7_bytes:
         I8[] [83,104,111,119,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.735343494 UTC

[section ""data" . Data.Functor.Classes.$tcShow6_closure" {
     Data.Functor.Classes.$tcShow6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.737798498 UTC

[section ""data" . Data.Functor.Classes.$tcShow2_closure" {
     Data.Functor.Classes.$tcShow2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 11321900378419812635;
         const 1323607160578303441;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.74001666 UTC

[section ""data" . Data.Functor.Classes.C:Show2_closure" {
     Data.Functor.Classes.C:Show2_closure:
         const Data.Functor.Classes.C:Show2_info;
 },
 Data.Functor.Classes.C:Show2_entry() //  [R2, R3]
         { info_tbl: [(cdExB,
                       label: Data.Functor.Classes.C:Show2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdExB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdExF; else goto cdExE;
       cdExF: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdExE: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.744242283 UTC

[section ""data" . Data.Functor.Classes.C:Read2_closure" {
     Data.Functor.Classes.C:Read2_closure:
         const Data.Functor.Classes.C:Read2_info;
 },
 Data.Functor.Classes.C:Read2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdExQ,
                       label: Data.Functor.Classes.C:Read2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdExQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdExU; else goto cdExT;
       cdExU: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdExT: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read2_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.750645192 UTC

[section ""data" . Data.Functor.Classes.C:Ord2_closure" {
     Data.Functor.Classes.C:Ord2_closure:
         const Data.Functor.Classes.C:Ord2_info;
 },
 Data.Functor.Classes.C:Ord2_entry() //  [R2, R3]
         { info_tbl: [(cdEy5,
                       label: Data.Functor.Classes.C:Ord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEy5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEy9; else goto cdEy8;
       cdEy9: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEy8: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.755599751 UTC

[section ""data" . Data.Functor.Classes.C:Show1_closure" {
     Data.Functor.Classes.C:Show1_closure:
         const Data.Functor.Classes.C:Show1_info;
 },
 Data.Functor.Classes.C:Show1_entry() //  [R2, R3]
         { info_tbl: [(cdEyk,
                       label: Data.Functor.Classes.C:Show1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEyk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEyo; else goto cdEyn;
       cdEyo: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEyn: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.760110834 UTC

[section ""data" . Data.Functor.Classes.C:Read1_closure" {
     Data.Functor.Classes.C:Read1_closure:
         const Data.Functor.Classes.C:Read1_info;
 },
 Data.Functor.Classes.C:Read1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdEyz,
                       label: Data.Functor.Classes.C:Read1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEyz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdEyD; else goto cdEyC;
       cdEyD: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEyC: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.764803328 UTC

[section ""data" . Data.Functor.Classes.C:Ord1_closure" {
     Data.Functor.Classes.C:Ord1_closure:
         const Data.Functor.Classes.C:Ord1_info;
 },
 Data.Functor.Classes.C:Ord1_entry() //  [R2, R3]
         { info_tbl: [(cdEyO,
                       label: Data.Functor.Classes.C:Ord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEyO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdEyS; else goto cdEyR;
       cdEyS: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEyR: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.769088064 UTC

[Data.Functor.Classes.C:Show2_con_entry() //  [R1]
         { info_tbl: [(cdEyY,
                       label: Data.Functor.Classes.C:Show2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEyY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.773307777 UTC

[Data.Functor.Classes.C:Read2_con_entry() //  [R1]
         { info_tbl: [(cdEz4,
                       label: Data.Functor.Classes.C:Read2_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEz4: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.777746042 UTC

[Data.Functor.Classes.C:Ord2_con_entry() //  [R1]
         { info_tbl: [(cdEza,
                       label: Data.Functor.Classes.C:Ord2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEza: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.781539718 UTC

[Data.Functor.Classes.C:Show1_con_entry() //  [R1]
         { info_tbl: [(cdEzg,
                       label: Data.Functor.Classes.C:Show1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEzg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.785404054 UTC

[Data.Functor.Classes.C:Read1_con_entry() //  [R1]
         { info_tbl: [(cdEzm,
                       label: Data.Functor.Classes.C:Read1_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEzm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.788718505 UTC

[Data.Functor.Classes.C:Ord1_con_entry() //  [R1]
         { info_tbl: [(cdEzs,
                       label: Data.Functor.Classes.C:Ord1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEzs: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:46.79228632 UTC

[section ""relreadonly" . SdyRV_srt" {
     SdyRV_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.$fRead1Const2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec7_closure;
         const Data.Functor.Classes.$fRead1Either1_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$fRead1Either4_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec8_closure;
         const Data.Functor.Classes.$fRead1NonEmpty3_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec5_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1Proxy2_closure;
         const Data.Functor.Classes.$fRead1Proxy_lexeme_closure;
         const Data.Functor.Classes.$fRead1Proxy1_closure;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const Data.Functor.Classes.$fShow1Proxy2_closure;
         const Data.Functor.Classes.$fRead1(,)3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec6_closure;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$dmliftReadList2_closure;
         const Data.Functor.Classes.$fShow1Proxy1_closure;
         const Data.Functor.Classes.$dmliftReadList_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec2_closure;
         const Data.Functor.Classes.liftReadListPrecDefault_closure;
         const lvl_rdymy_closure;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
         const lvl1_rdymz_closure;
         const lvl2_rdymA_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$w$cliftReadList2_closure;
         const Data.Functor.Classes.$fRead2Either_closure;
         const Data.Functor.Classes.$fRead2Const_closure;
         const Data.Functor.Classes.$fRead2(,)_closure;
         const Data.Functor.Classes.liftReadListPrec2Default_closure;
         const Data.Functor.Classes.$fRead1(,)1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1(,)_closure;
         const GHC.Read.lex1_closure;
         const Data.Functor.Classes.$wreadsData_closure;
         const Data.Functor.Classes.readsData_closure;
         const Data.Functor.Classes.readData1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$wreadUnaryWith_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.readUnaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const5_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Const_closure;
         const Data.Functor.Classes.$fRead1Either7_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec1_closure;
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Either_closure;
         const Data.Functor.Classes.$fRead1Identity2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec3_closure;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Maybe5_closure;
         const Data.Functor.Classes.$fRead1Maybe_lexeme_closure;
         const Data.Functor.Classes.$fRead1Maybe2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec4_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec4_closure;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList1_closure;
         const Data.Functor.Classes.$wreadBinaryWith_closure;
         const Data.Functor.Classes.readBinaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
         const Data.Functor.Classes.$fShow1Const_closure;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$w$cliftShowList4_closure;
         const Data.Functor.Classes.$w$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList1_closure;
         const Data.Functor.Classes.$fShow1Either_closure;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const Data.Functor.Classes.$fShow1Maybe1_closure;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.890239301 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:53.89169792 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec2_closure" {
     Data.Functor.Classes.liftShowsPrec2_closure:
         const Data.Functor.Classes.liftShowsPrec2_info;
 },
 Data.Functor.Classes.liftShowsPrec2_entry() //  [R2]
         { info_tbl: [(cdF04,
                       label: Data.Functor.Classes.liftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF04: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF05; else goto cdF06;
       cdF05: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF06: // global
           I64[Sp - 8] = block_cdF01_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF0a; else goto cdF02;
       udF0a: // global
           call _cdF01(R1) args: 0, res: 0, upd: 0;
       cdF02: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF01() //  [R1]
         { info_tbl: [(cdF01,
                       label: block_cdF01_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF01: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.897313507 UTC

[section ""data" . Data.Functor.Classes.liftShowList2_closure" {
     Data.Functor.Classes.liftShowList2_closure:
         const Data.Functor.Classes.liftShowList2_info;
 },
 Data.Functor.Classes.liftShowList2_entry() //  [R2]
         { info_tbl: [(cdF0s,
                       label: Data.Functor.Classes.liftShowList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF0s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF0t; else goto cdF0u;
       cdF0t: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF0u: // global
           I64[Sp - 8] = block_cdF0p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF0y; else goto cdF0q;
       udF0y: // global
           call _cdF0p(R1) args: 0, res: 0, upd: 0;
       cdF0q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF0p() //  [R1]
         { info_tbl: [(cdF0p,
                       label: block_cdF0p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF0p: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.902860191 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec2_closure" {
     Data.Functor.Classes.liftReadsPrec2_closure:
         const Data.Functor.Classes.liftReadsPrec2_info;
 },
 Data.Functor.Classes.liftReadsPrec2_entry() //  [R2]
         { info_tbl: [(cdF0Q,
                       label: Data.Functor.Classes.liftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF0Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF0R; else goto cdF0S;
       cdF0R: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF0S: // global
           I64[Sp - 8] = block_cdF0N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF0W; else goto cdF0O;
       udF0W: // global
           call _cdF0N(R1) args: 0, res: 0, upd: 0;
       cdF0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF0N() //  [R1]
         { info_tbl: [(cdF0N,
                       label: block_cdF0N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF0N: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.909512045 UTC

[section ""data" . Data.Functor.Classes.liftReadList2_closure" {
     Data.Functor.Classes.liftReadList2_closure:
         const Data.Functor.Classes.liftReadList2_info;
 },
 Data.Functor.Classes.liftReadList2_entry() //  [R2]
         { info_tbl: [(cdF1e,
                       label: Data.Functor.Classes.liftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF1e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF1f; else goto cdF1g;
       cdF1f: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF1g: // global
           I64[Sp - 8] = block_cdF1b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF1k; else goto cdF1c;
       udF1k: // global
           call _cdF1b(R1) args: 0, res: 0, upd: 0;
       cdF1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF1b() //  [R1]
         { info_tbl: [(cdF1b,
                       label: block_cdF1b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF1b: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.914739962 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec2_closure" {
     Data.Functor.Classes.liftReadPrec2_closure:
         const Data.Functor.Classes.liftReadPrec2_info;
 },
 Data.Functor.Classes.liftReadPrec2_entry() //  [R2]
         { info_tbl: [(cdF1C,
                       label: Data.Functor.Classes.liftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF1C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF1D; else goto cdF1E;
       cdF1D: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF1E: // global
           I64[Sp - 8] = block_cdF1z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF1I; else goto cdF1A;
       udF1I: // global
           call _cdF1z(R1) args: 0, res: 0, upd: 0;
       cdF1A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF1z() //  [R1]
         { info_tbl: [(cdF1z,
                       label: block_cdF1z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF1z: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.92008336 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2_closure" {
     Data.Functor.Classes.liftReadListPrec2_closure:
         const Data.Functor.Classes.liftReadListPrec2_info;
 },
 Data.Functor.Classes.liftReadListPrec2_entry() //  [R2]
         { info_tbl: [(cdF20,
                       label: Data.Functor.Classes.liftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF20: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF21; else goto cdF22;
       cdF21: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF22: // global
           I64[Sp - 8] = block_cdF1X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF26; else goto cdF1Y;
       udF26: // global
           call _cdF1X(R1) args: 0, res: 0, upd: 0;
       cdF1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF1X() //  [R1]
         { info_tbl: [(cdF1X,
                       label: block_cdF1X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF1X: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.925901676 UTC

[section ""data" . Data.Functor.Classes.$p1Ord2_closure" {
     Data.Functor.Classes.$p1Ord2_closure:
         const Data.Functor.Classes.$p1Ord2_info;
 },
 Data.Functor.Classes.$p1Ord2_entry() //  [R2]
         { info_tbl: [(cdF2o,
                       label: Data.Functor.Classes.$p1Ord2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF2o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF2p; else goto cdF2q;
       cdF2p: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF2q: // global
           I64[Sp - 8] = block_cdF2l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF2u; else goto cdF2m;
       udF2u: // global
           call _cdF2l(R1) args: 0, res: 0, upd: 0;
       cdF2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF2l() //  [R1]
         { info_tbl: [(cdF2l,
                       label: block_cdF2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF2l: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.93120799 UTC

[section ""data" . Data.Functor.Classes.liftCompare2_closure" {
     Data.Functor.Classes.liftCompare2_closure:
         const Data.Functor.Classes.liftCompare2_info;
 },
 Data.Functor.Classes.liftCompare2_entry() //  [R2]
         { info_tbl: [(cdF2M,
                       label: Data.Functor.Classes.liftCompare2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF2M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF2N; else goto cdF2O;
       cdF2N: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF2O: // global
           I64[Sp - 8] = block_cdF2J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF2S; else goto cdF2K;
       udF2S: // global
           call _cdF2J(R1) args: 0, res: 0, upd: 0;
       cdF2K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF2J() //  [R1]
         { info_tbl: [(cdF2J,
                       label: block_cdF2J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF2J: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.936459519 UTC

[section ""data" . Data.Functor.Classes.liftEq2_closure" {
     Data.Functor.Classes.liftEq2_closure:
         const Data.Functor.Classes.liftEq2_info;
 },
 Data.Functor.Classes.liftEq2_entry() //  [R2]
         { info_tbl: [(cdF37,
                       label: Data.Functor.Classes.liftEq2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF37: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.94310365 UTC

[section ""data" . Data.Functor.Classes.liftShowsPrec_closure" {
     Data.Functor.Classes.liftShowsPrec_closure:
         const Data.Functor.Classes.liftShowsPrec_info;
 },
 Data.Functor.Classes.liftShowsPrec_entry() //  [R2]
         { info_tbl: [(cdF3l,
                       label: Data.Functor.Classes.liftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF3l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF3m; else goto cdF3n;
       cdF3m: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF3n: // global
           I64[Sp - 8] = block_cdF3i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF3r; else goto cdF3j;
       udF3r: // global
           call _cdF3i(R1) args: 0, res: 0, upd: 0;
       cdF3j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF3i() //  [R1]
         { info_tbl: [(cdF3i,
                       label: block_cdF3i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF3i: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.948857126 UTC

[section ""data" . Data.Functor.Classes.liftShowList_closure" {
     Data.Functor.Classes.liftShowList_closure:
         const Data.Functor.Classes.liftShowList_info;
 },
 Data.Functor.Classes.liftShowList_entry() //  [R2]
         { info_tbl: [(cdF3J,
                       label: Data.Functor.Classes.liftShowList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF3J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF3K; else goto cdF3L;
       cdF3K: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftShowList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF3L: // global
           I64[Sp - 8] = block_cdF3G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF3P; else goto cdF3H;
       udF3P: // global
           call _cdF3G(R1) args: 0, res: 0, upd: 0;
       cdF3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF3G() //  [R1]
         { info_tbl: [(cdF3G,
                       label: block_cdF3G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF3G: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.954239914 UTC

[section ""data" . Data.Functor.Classes.liftReadsPrec_closure" {
     Data.Functor.Classes.liftReadsPrec_closure:
         const Data.Functor.Classes.liftReadsPrec_info;
 },
 Data.Functor.Classes.liftReadsPrec_entry() //  [R2]
         { info_tbl: [(cdF47,
                       label: Data.Functor.Classes.liftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF47: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF48; else goto cdF49;
       cdF48: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF49: // global
           I64[Sp - 8] = block_cdF44_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF4d; else goto cdF45;
       udF4d: // global
           call _cdF44(R1) args: 0, res: 0, upd: 0;
       cdF45: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF44() //  [R1]
         { info_tbl: [(cdF44,
                       label: block_cdF44_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF44: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.960099558 UTC

[section ""data" . Data.Functor.Classes.liftReadList_closure" {
     Data.Functor.Classes.liftReadList_closure:
         const Data.Functor.Classes.liftReadList_info;
 },
 Data.Functor.Classes.liftReadList_entry() //  [R2]
         { info_tbl: [(cdF4v,
                       label: Data.Functor.Classes.liftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF4v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF4w; else goto cdF4x;
       cdF4w: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF4x: // global
           I64[Sp - 8] = block_cdF4s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF4B; else goto cdF4t;
       udF4B: // global
           call _cdF4s(R1) args: 0, res: 0, upd: 0;
       cdF4t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF4s() //  [R1]
         { info_tbl: [(cdF4s,
                       label: block_cdF4s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF4s: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.965574117 UTC

[section ""data" . Data.Functor.Classes.liftReadPrec_closure" {
     Data.Functor.Classes.liftReadPrec_closure:
         const Data.Functor.Classes.liftReadPrec_info;
 },
 Data.Functor.Classes.liftReadPrec_entry() //  [R2]
         { info_tbl: [(cdF4T,
                       label: Data.Functor.Classes.liftReadPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF4U; else goto cdF4V;
       cdF4U: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF4V: // global
           I64[Sp - 8] = block_cdF4Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF4Z; else goto cdF4R;
       udF4Z: // global
           call _cdF4Q(R1) args: 0, res: 0, upd: 0;
       cdF4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF4Q() //  [R1]
         { info_tbl: [(cdF4Q,
                       label: block_cdF4Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF4Q: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.970944301 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec_closure" {
     Data.Functor.Classes.liftReadListPrec_closure:
         const Data.Functor.Classes.liftReadListPrec_info;
 },
 Data.Functor.Classes.liftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdF5h,
                       label: Data.Functor.Classes.liftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF5h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF5i; else goto cdF5j;
       cdF5i: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF5j: // global
           I64[Sp - 8] = block_cdF5e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF5n; else goto cdF5f;
       udF5n: // global
           call _cdF5e(R1) args: 0, res: 0, upd: 0;
       cdF5f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF5e() //  [R1]
         { info_tbl: [(cdF5e,
                       label: block_cdF5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF5e: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.976779989 UTC

[section ""data" . Data.Functor.Classes.$p1Ord1_closure" {
     Data.Functor.Classes.$p1Ord1_closure:
         const Data.Functor.Classes.$p1Ord1_info;
 },
 Data.Functor.Classes.$p1Ord1_entry() //  [R2]
         { info_tbl: [(cdF5F,
                       label: Data.Functor.Classes.$p1Ord1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF5F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF5G; else goto cdF5H;
       cdF5G: // global
           R2 = R2;
           R1 = Data.Functor.Classes.$p1Ord1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF5H: // global
           I64[Sp - 8] = block_cdF5C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF5L; else goto cdF5D;
       udF5L: // global
           call _cdF5C(R1) args: 0, res: 0, upd: 0;
       cdF5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF5C() //  [R1]
         { info_tbl: [(cdF5C,
                       label: block_cdF5C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF5C: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.982342631 UTC

[section ""data" . Data.Functor.Classes.liftCompare_closure" {
     Data.Functor.Classes.liftCompare_closure:
         const Data.Functor.Classes.liftCompare_info;
 },
 Data.Functor.Classes.liftCompare_entry() //  [R2]
         { info_tbl: [(cdF63,
                       label: Data.Functor.Classes.liftCompare_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF63: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdF64; else goto cdF65;
       cdF64: // global
           R2 = R2;
           R1 = Data.Functor.Classes.liftCompare_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF65: // global
           I64[Sp - 8] = block_cdF60_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udF69; else goto cdF61;
       udF69: // global
           call _cdF60(R1) args: 0, res: 0, upd: 0;
       cdF61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF60() //  [R1]
         { info_tbl: [(cdF60,
                       label: block_cdF60_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF60: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.987540253 UTC

[section ""data" . Data.Functor.Classes.liftEq_closure" {
     Data.Functor.Classes.liftEq_closure:
         const Data.Functor.Classes.liftEq_info;
 },
 Data.Functor.Classes.liftEq_entry() //  [R2]
         { info_tbl: [(cdF6o,
                       label: Data.Functor.Classes.liftEq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF6o: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.990657188 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const1_closure" {
     Data.Functor.Classes.$fRead1Const1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.992293223 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Const4_bytes" {
     Data.Functor.Classes.$fRead1Const4_bytes:
         I8[] [67,111,110,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.994208024 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const3_closure" {
     Data.Functor.Classes.$fRead1Const3_closure:
         const Data.Functor.Classes.$fRead1Const3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const3_entry() //  [R1]
         { info_tbl: [(cdF6D,
                       label: Data.Functor.Classes.$fRead1Const3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF6D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdF6E; else goto cdF6F;
       cdF6E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdF6F: // global
           (_cdF6A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdF6A::I64 == 0) goto cdF6C; else goto cdF6B;
       cdF6C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdF6B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdF6A::I64;
           R2 = Data.Functor.Classes.$fRead1Const4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:53.998608799 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const2_closure" {
     Data.Functor.Classes.$fRead1Const2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.001292594 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadPrec1_info;
         const 0;
 },
 sat_sdEB3_entry() //  [R1, R2]
         { info_tbl: [(cdF7h,
                       label: sat_sdEB3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF7h: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEB4_entry() //  [R1, R2]
         { info_tbl: [(cdF7k,
                       label: sat_sdEB4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF7k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF7o; else goto cdF7n;
       cdF7o: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF7n: // global
           _sdEAT::P64 = P64[R1 + 7];
           _sdEAX::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdEB3_info;
           P64[Hp] = _sdEAX::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdEAT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEB7_entry() //  [R1, R2, R3]
         { info_tbl: [(cdF7p,
                       label: sat_sdEB7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF7p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdF7q; else goto cdF7r;
       cdF7q: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdF7r: // global
           I64[Sp - 24] = block_cdF6Y_info;
           _sdEAT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdEAT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udF7E; else goto cdF6Z;
       udF7E: // global
           call _cdF6Y(R1) args: 0, res: 0, upd: 0;
       cdF6Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF6Y() //  [R1]
         { info_tbl: [(cdF6Y,
                       label: block_cdF6Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF6Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdF7u; else goto cdF7t;
       cdF7u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdF7t: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdF7w; else goto cdF7A;
       cdF7w: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdF7A: // global
           I64[Hp - 16] = sat_sdEB4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdF7x_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdF7x() //  [R1]
         { info_tbl: [(cdF7x,
                       label: block_cdF7x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF7x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF7D; else goto cdF7C;
       cdF7D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdF7C: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdF7F,
                       label: Data.Functor.Classes.$w$cliftReadPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF7F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF7J; else goto cdF7I;
       cdF7J: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdF7I: // global
           I64[Hp - 8] = sat_sdEB7_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.015417599 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const6_closure" {
     Data.Functor.Classes.$fRead1Const6_closure:
         const Data.Functor.Classes.$fRead1Const6_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const6_entry() //  [R2, R6]
         { info_tbl: [(cdF8l,
                       label: Data.Functor.Classes.$fRead1Const6_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF8l: // global
           R4 = P64[Sp];
           R3 = R6;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.019030999 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdEBk_entry() //  [R1, R2, R3]
         { info_tbl: [(cdF8B,
                       label: sat_sdEBk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF8B: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdF8E,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF8E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF8I; else goto cdF8H;
       cdF8I: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdF8H: // global
           I64[Hp - 8] = sat_sdEBk_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.025660781 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec7_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec7_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec7_info;
         const 0;
 },
 lvl3_sdEBn_entry() //  [R1]
         { info_tbl: [(cdF93,
                       label: lvl3_sdEBn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF93: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdF94; else goto cdF95;
       cdF94: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdF95: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEBv_entry() //  [R1, R2]
         { info_tbl: [(cdF9u,
                       label: sat_sdEBv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9u: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEBy_entry() //  [R1, R2]
         { info_tbl: [(cdF9A,
                       label: sat_sdEBy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9A: // global
           _sdEBt::P64 = R2;
           _sdEBy::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdF9B; else goto cdF9C;
       cdF9C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF9E; else goto cdF9D;
       cdF9E: // global
           HpAlloc = 16;
           goto cdF9B;
       cdF9B: // global
           R2 = _sdEBt::P64;
           R1 = _sdEBy::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdF9D: // global
           _sdEBn::P64 = P64[_sdEBy::P64 + 7];
           _sdEBp::P64 = P64[_sdEBy::P64 + 15];
           I64[Hp - 8] = sat_sdEBv_info;
           P64[Hp] = _sdEBp::P64;
           I64[Sp - 8] = block_cdF9x_info;
           R3 = Hp - 7;
           R2 = _sdEBn::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdF9x() //  [R1]
         { info_tbl: [(cdF9x,
                       label: block_cdF9x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF9H; else goto cdF9G;
       cdF9H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdF9G: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEBB_entry() //  [R1, R2, R3]
         { info_tbl: [(cdF9I,
                       label: sat_sdEBB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdF9J; else goto cdF9K;
       cdF9J: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdF9K: // global
           I64[Sp - 24] = block_cdF9b_info;
           _sdEBn::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdEBn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udF9X; else goto cdF9c;
       udF9X: // global
           call _cdF9b(R1) args: 0, res: 0, upd: 0;
       cdF9c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF9b() //  [R1]
         { info_tbl: [(cdF9b,
                       label: block_cdF9b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdF9N; else goto cdF9M;
       cdF9N: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdF9M: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdF9P; else goto cdF9T;
       cdF9P: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdF9T: // global
           I64[Hp - 16] = sat_sdEBy_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdF9Q_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Const2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdF9Q() //  [R1]
         { info_tbl: [(cdF9Q,
                       label: block_cdF9Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdF9W; else goto cdF9V;
       cdF9W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdF9V: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEBC_entry() //  [R1]
         { info_tbl: [(cdF9Y,
                       label: sat_sdEBC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF9Y: // global
           _sdEBC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdF9Z; else goto cdFa0;
       cdFa0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdFa2; else goto cdFa1;
       cdFa2: // global
           HpAlloc = 40;
           goto cdF9Z;
       cdF9Z: // global
           R1 = _sdEBC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFa1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEBC::P64;
           _sdEBl::P64 = P64[_sdEBC::P64 + 16];
           _sdEBm::P64 = P64[_sdEBC::P64 + 24];
           I64[Hp - 32] = lvl3_sdEBn_info;
           P64[Hp - 16] = _sdEBl::P64;
           I64[Hp - 8] = sat_sdEBB_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdEBm::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec7_entry() //  [R2, R3]
         { info_tbl: [(cdFa3,
                       label: Data.Functor.Classes.$w$cliftReadsPrec7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFa3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFa7; else goto cdFa6;
       cdFa7: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFa6: // global
           I64[Hp - 24] = sat_sdEBC_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.045150165 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_entry() //  [R2,
                                                                 R6]
         { info_tbl: [(cdFb4,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFb4: // global
           R3 = R6;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec7_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.049308528 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either3_bytes" {
     Data.Functor.Classes.$fRead1Either3_bytes:
         I8[] [82,105,103,104,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.051101207 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either2_closure" {
     Data.Functor.Classes.$fRead1Either2_closure:
         const Data.Functor.Classes.$fRead1Either2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either2_entry() //  [R1]
         { info_tbl: [(cdFbi,
                       label: Data.Functor.Classes.$fRead1Either2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFbi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFbj; else goto cdFbk;
       cdFbj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFbk: // global
           (_cdFbf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdFbf::I64 == 0) goto cdFbh; else goto cdFbg;
       cdFbh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdFbg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdFbf::I64;
           R2 = Data.Functor.Classes.$fRead1Either3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.05500933 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either1_closure" {
     Data.Functor.Classes.$fRead1Either1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.056673073 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Either6_bytes" {
     Data.Functor.Classes.$fRead1Either6_bytes:
         I8[] [76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.058551377 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either5_closure" {
     Data.Functor.Classes.$fRead1Either5_closure:
         const Data.Functor.Classes.$fRead1Either5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either5_entry() //  [R1]
         { info_tbl: [(cdFbB,
                       label: Data.Functor.Classes.$fRead1Either5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFbB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFbC; else goto cdFbD;
       cdFbC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFbD: // global
           (_cdFby::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdFby::I64 == 0) goto cdFbA; else goto cdFbz;
       cdFbA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdFbz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdFby::I64;
           R2 = Data.Functor.Classes.$fRead1Either6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.062745344 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either4_closure" {
     Data.Functor.Classes.$fRead1Either4_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.066146529 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadPrec3_info;
         const 0;
 },
 sat_sdEBU_entry() //  [R1, R2]
         { info_tbl: [(cdFcg,
                       label: sat_sdEBU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFck; else goto cdFcj;
       cdFck: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFcj: // global
           _sdEBN::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           R1 = _sdEBN::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEBV_entry() //  [R1, R2]
         { info_tbl: [(cdFcl,
                       label: sat_sdEBV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFcp; else goto cdFco;
       cdFcp: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFco: // global
           _sdEBI::P64 = P64[R1 + 7];
           _sdEBN::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdEBU_info;
           P64[Hp] = _sdEBN::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdEBI::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEC2_entry() //  [R1, R2]
         { info_tbl: [(cdFcH,
                       label: sat_sdEC2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFcL; else goto cdFcK;
       cdFcL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFcK: // global
           _sdEBN::P64 = P64[R1 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdEBN::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEC3_entry() //  [R1, R2]
         { info_tbl: [(cdFcM,
                       label: sat_sdEC3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFcQ; else goto cdFcP;
       cdFcQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFcP: // global
           _sdEBJ::P64 = P64[R1 + 7];
           _sdEBN::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdEC2_info;
           P64[Hp] = _sdEBN::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdEBJ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEC6_entry() //  [R1]
         { info_tbl: [(cdFcU,
                       label: sat_sdEC6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcU: // global
           _sdEC6::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdFcV; else goto cdFcW;
       cdFcW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFcY; else goto cdFcX;
       cdFcY: // global
           HpAlloc = 24;
           goto cdFcV;
       cdFcV: // global
           R1 = _sdEC6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFcX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEC6::P64;
           _sdEBJ::P64 = P64[_sdEC6::P64 + 16];
           _sdEBN::P64 = P64[_sdEC6::P64 + 24];
           I64[Hp - 16] = sat_sdEC3_info;
           P64[Hp - 8] = _sdEBJ::P64;
           P64[Hp] = _sdEBN::P64;
           I64[Sp - 24] = block_cdFcR_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either1_closure+4;
           Sp = Sp - 24;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdFcR() //  [R1]
         { info_tbl: [(cdFcR,
                       label: block_cdFcR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFd1; else goto cdFd0;
       cdFd1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdFd0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEC7_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFd2,
                       label: sat_sdEC7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFd2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFd3; else goto cdFd4;
       cdFd3: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFd4: // global
           I64[Sp - 32] = block_cdFbW_info;
           _sdEBI::P64 = P64[R1 + 6];
           _sdEBJ::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdEBI::P64;
           P64[Sp - 16] = _sdEBJ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFdf; else goto cdFbX;
       udFdf: // global
           call _cdFbW(R1) args: 0, res: 0, upd: 0;
       cdFbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFbW() //  [R1]
         { info_tbl: [(cdFbW,
                       label: block_cdFbW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFbW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFd7; else goto cdFd6;
       cdFd7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFd6: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdFd9; else goto cdFdb;
       cdFd9: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFdb: // global
           I64[Hp - 16] = sat_sdEBV_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 8] = block_cdFcq_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Either4_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFcq() //  [R1]
         { info_tbl: [(cdFcq,
                       label: block_cdFcq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFcq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdFde; else goto cdFdd;
       cdFde: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFdd: // global
           I64[Hp - 40] = sat_sdEC6_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R3 = Hp - 40;
           R2 = Hp - 6;
           Sp = Sp + 24;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFdg,
                       label: Data.Functor.Classes.$w$cliftReadPrec3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFdg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFdk; else goto cdFdj;
       cdFdk: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFdj: // global
           I64[Hp - 16] = sat_sdEC7_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdEBK::P64 = R4;
           R4 = R5;
           R3 = _sdEBK::P64;
           R2 = Hp - 14;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.088804713 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either8_closure" {
     Data.Functor.Classes.$fRead1Either8_closure:
         const Data.Functor.Classes.$fRead1Either8_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either8_entry() //  [R2, R4, R6]
         { info_tbl: [(cdFei,
                       label: Data.Functor.Classes.$fRead1Either8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFei: // global
           R5 = P64[Sp];
           _sdECa::P64 = R4;
           R4 = R6;
           R3 = _sdECa::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.092981489 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdECk_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFey,
                       label: sat_sdECk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFey: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdFeB,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFeB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFeF; else goto cdFeE;
       cdFeF: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFeE: // global
           I64[Hp - 16] = sat_sdECk_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.099022151 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec8_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec8_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec8_info;
         const 0;
 },
 sat_sdECp_entry() //  [R1, R2]
         { info_tbl: [(cdFf1,
                       label: sat_sdECp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFf1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdECo_entry() //  [R1, R2]
         { info_tbl: [(cdFf9,
                       label: sat_sdECo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFf9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdECq_entry() //  [R1]
         { info_tbl: [(cdFfc,
                       label: sat_sdECq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFfc: // global
           _sdECq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFfd; else goto cdFfe;
       cdFfe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFfg; else goto cdFff;
       cdFfg: // global
           HpAlloc = 32;
           goto cdFfd;
       cdFfd: // global
           R1 = _sdECq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFff: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdECq::P64;
           _sdECl::P64 = P64[_sdECq::P64 + 16];
           _sdECm::P64 = P64[_sdECq::P64 + 24];
           _sdECn::P64 = P64[_sdECq::P64 + 32];
           I64[Hp - 24] = sat_sdECp_info;
           P64[Hp - 16] = _sdECm::P64;
           I64[Hp - 8] = sat_sdECo_info;
           P64[Hp] = _sdECl::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdECn::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec8_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFfh,
                       label: Data.Functor.Classes.$w$cliftReadsPrec8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFfh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdFfl; else goto cdFfk;
       cdFfl: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec8_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFfk: // global
           I64[Hp - 32] = sat_sdECq_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.108880426 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_entry() //  [R2,
                                                                  R4, R6]
         { info_tbl: [(cdFfK,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFfK: // global
           _sdECt::P64 = R4;
           R4 = R6;
           R3 = _sdECt::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec8_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.113026676 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFg2,
                       label: Data.Functor.Classes.$fEq1Maybe_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFg2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdFg3; else goto cdFg4;
       cdFg3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFg4: // global
           I64[Sp - 24] = block_cdFfV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFgF; else goto cdFfW;
       udFgF: // global
           call _cdFfV(R1) args: 0, res: 0, upd: 0;
       cdFfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFfV() //  [R1]
         { info_tbl: [(cdFfV,
                       label: block_cdFfV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFfV: // global
           _sdECy::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdFfZ; else goto cdFg0;
       cdFfZ: // global
           I64[Sp + 16] = block_cdFg7_info;
           R1 = _sdECy::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udFgD; else goto cdFg9;
       udFgD: // global
           call _cdFg7(R1) args: 0, res: 0, upd: 0;
       cdFg9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFg0: // global
           I64[Sp] = block_cdFgm_info;
           _sdECC::P64 = P64[R1 + 6];
           R1 = _sdECy::P64;
           P64[Sp + 16] = _sdECC::P64;
           if (R1 & 7 != 0) goto udFgE; else goto cdFgo;
       udFgE: // global
           call _cdFgm(R1) args: 0, res: 0, upd: 0;
       cdFgo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFg7() //  [R1]
         { info_tbl: [(cdFg7,
                       label: block_cdFg7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFg7: // global
           if (R1 & 7 == 1) goto cdFgf; else goto udFgC;
       cdFgf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udFgC: // global
           Sp = Sp + 8;
           call _cdFgu() args: 0, res: 0, upd: 0;
     }
 },
 _cdFgm() //  [R1]
         { info_tbl: [(cdFgm,
                       label: block_cdFgm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFgm: // global
           if (R1 & 7 == 1) goto udFgB; else goto cdFgy;
       udFgB: // global
           Sp = Sp + 24;
           call _cdFgu() args: 0, res: 0, upd: 0;
       cdFgy: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFgu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFgu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.124355461 UTC

[section ""data" . Data.Functor.Classes.$fEq1Maybe_closure" {
     Data.Functor.Classes.$fEq1Maybe_closure:
         const Data.Functor.Classes.$fEq1Maybe_info;
 },
 Data.Functor.Classes.$fEq1Maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFhi,
                       label: Data.Functor.Classes.$fEq1Maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFhi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Maybe_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.128517698 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdFhA,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFhA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFhB; else goto udFil;
       cdFhB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udFil: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdFhq() args: 0, res: 0, upd: 0;
     }
 },
 _cdFhq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFhq: // global
           I64[Sp - 8] = block_cdFht_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFiq; else goto cdFhu;
       udFiq: // global
           call _cdFht(R1) args: 0, res: 0, upd: 0;
       cdFhu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFht() //  [R1]
         { info_tbl: [(cdFht,
                       label: block_cdFht_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFht: // global
           _sdECH::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFhx; else goto cdFhy;
       cdFhx: // global
           I64[Sp + 24] = block_cdFhF_info;
           R1 = _sdECH::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udFir; else goto cdFhH;
       udFir: // global
           call _cdFhF(R1) args: 0, res: 0, upd: 0;
       cdFhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFhy: // global
           I64[Sp] = block_cdFhU_info;
           _sdECM::P64 = P64[R1 + 6];
           _sdECN::P64 = P64[R1 + 14];
           R1 = _sdECH::P64;
           P64[Sp + 16] = _sdECN::P64;
           P64[Sp + 24] = _sdECM::P64;
           if (R1 & 7 != 0) goto udFis; else goto cdFhW;
       udFis: // global
           call _cdFhU(R1) args: 0, res: 0, upd: 0;
       cdFhW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFhF() //  [R1]
         { info_tbl: [(cdFhF,
                       label: block_cdFhF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFhF: // global
           if (R1 & 7 == 1) goto cdFhN; else goto udFip;
       cdFhN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udFip: // global
           Sp = Sp + 8;
           call _cdFid() args: 0, res: 0, upd: 0;
     }
 },
 _cdFhU() //  [R1]
         { info_tbl: [(cdFhU,
                       label: block_cdFhU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFhU: // global
           if (R1 & 7 == 1) goto udFim; else goto cdFi7;
       udFim: // global
           Sp = Sp + 32;
           call _cdFid() args: 0, res: 0, upd: 0;
       cdFi7: // global
           I64[Sp] = block_cdFi5_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdECQ::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdECQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFi5() //  [R1]
         { info_tbl: [(cdFi5,
                       label: block_cdFi5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFi5: // global
           if (R1 & 7 == 1) goto udFin; else goto cdFih;
       udFin: // global
           Sp = Sp + 32;
           call _cdFid() args: 0, res: 0, upd: 0;
       cdFih: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdFhq() args: 0, res: 0, upd: 0;
     }
 },
 _cdFid() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFid: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.142345879 UTC

[section ""data" . Data.Functor.Classes.$fEq1[]_closure" {
     Data.Functor.Classes.$fEq1[]_closure:
         const Data.Functor.Classes.$fEq1[]_info;
 },
 Data.Functor.Classes.$fEq1[]_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFjj,
                       label: Data.Functor.Classes.$fEq1[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFjj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.146022449 UTC

[section ""data" . Data.Functor.Classes.$w$cliftEq_closure" {
     Data.Functor.Classes.$w$cliftEq_closure:
         const Data.Functor.Classes.$w$cliftEq_info;
 },
 Data.Functor.Classes.$w$cliftEq_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdFjA,
                       label: Data.Functor.Classes.$w$cliftEq_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFjA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFjB; else goto cdFjC;
       cdFjB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftEq_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFjC: // global
           I64[Sp - 32] = block_cdFju_info;
           _sdECT::P64 = R3;
           R3 = R5;
           _sdECS::P64 = R2;
           R2 = _sdECT::P64;
           R1 = _sdECS::P64;
           P64[Sp - 24] = _sdECS::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFju() //  [R1]
         { info_tbl: [(cdFju,
                       label: block_cdFju_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFju: // global
           if (R1 & 7 == 1) goto cdFjx; else goto cdFjy;
       cdFjx: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFjy: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.152208149 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdFk3,
                       label: Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFk3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFk7; else goto cdFk8;
       cdFk7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFk8: // global
           I64[Sp - 24] = block_cdFk0_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFkg; else goto cdFk1;
       udFkg: // global
           call _cdFk0(R1) args: 0, res: 0, upd: 0;
       cdFk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFk0() //  [R1]
         { info_tbl: [(cdFk0,
                       label: block_cdFk0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFk0: // global
           I64[Sp - 8] = block_cdFk6_info;
           _sdED2::P64 = P64[R1 + 7];
           _sdED3::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdED3::P64;
           P64[Sp + 16] = _sdED2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFkf; else goto cdFka;
       udFkf: // global
           call _cdFk6(R1) args: 0, res: 0, upd: 0;
       cdFka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFk6() //  [R1]
         { info_tbl: [(cdFk6,
                       label: block_cdFk6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFk6: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftEq_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.159685463 UTC

[section ""data" . Data.Functor.Classes.$fEq1NonEmpty_closure" {
     Data.Functor.Classes.$fEq1NonEmpty_closure:
         const Data.Functor.Classes.$fEq1NonEmpty_info;
 },
 Data.Functor.Classes.$fEq1NonEmpty_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFkA,
                       label: Data.Functor.Classes.$fEq1NonEmpty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFkA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.163892629 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Identity_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Identity_$cliftEq_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cdFkL,
                       label: Data.Functor.Classes.$fEq1Identity_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFkL: // global
           _sdED8::P64 = R3;
           R3 = R4;
           _sdED7::P64 = R2;
           R2 = _sdED8::P64;
           R1 = _sdED7::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.167399352 UTC

[section ""data" . Data.Functor.Classes.$fEq1Identity_closure" {
     Data.Functor.Classes.$fEq1Identity_closure:
         const Data.Functor.Classes.$fEq1Identity_info;
 },
 Data.Functor.Classes.$fEq1Identity_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFkW,
                       label: Data.Functor.Classes.$fEq1Identity_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFkW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Identity_$cliftEq_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.17076934 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry() //  []
         { info_tbl: [(cdFl7,
                       label: Data.Functor.Classes.$fEq1Proxy_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFl7: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.174306163 UTC

[section ""data" . Data.Functor.Classes.$fEq1Proxy_closure" {
     Data.Functor.Classes.$fEq1Proxy_closure:
         const Data.Functor.Classes.$fEq1Proxy_info;
 },
 Data.Functor.Classes.$fEq1Proxy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFlk,
                       label: Data.Functor.Classes.$fEq1Proxy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFlk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Proxy_$cliftEq_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.178050531 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdFlC,
                       label: Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFlC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdFlD; else goto cdFlE;
       cdFlD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFlE: // global
           I64[Sp - 24] = block_cdFlv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFmd; else goto cdFlw;
       udFmd: // global
           call _cdFlv(R1) args: 0, res: 0, upd: 0;
       cdFlw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFlv() //  [R1]
         { info_tbl: [(cdFlv,
                       label: block_cdFlv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFlv: // global
           _sdEDf::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdFlz; else goto cdFlA;
       cdFlz: // global
           I64[Sp + 16] = block_cdFlH_info;
           R1 = _sdEDf::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto udFmb; else goto cdFlJ;
       udFmb: // global
           call _cdFlH(R1) args: 0, res: 0, upd: 0;
       cdFlJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFlA: // global
           I64[Sp] = block_cdFlW_info;
           _sdEDj::P64 = P64[R1 + 6];
           R1 = _sdEDf::P64;
           P64[Sp + 16] = _sdEDj::P64;
           if (R1 & 7 != 0) goto udFmc; else goto cdFlY;
       udFmc: // global
           call _cdFlW(R1) args: 0, res: 0, upd: 0;
       cdFlY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFlH() //  [R1]
         { info_tbl: [(cdFlH,
                       label: block_cdFlH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFlH: // global
           if (R1 & 7 == 1) goto cdFlP; else goto cdFlT;
       cdFlP: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFlT: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFlW() //  [R1]
         { info_tbl: [(cdFlW,
                       label: block_cdFlW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFlW: // global
           if (R1 & 7 == 1) goto cdFm4; else goto cdFm8;
       cdFm4: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFm8: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.187708023 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Maybe_closure" {
     Data.Functor.Classes.$fOrd1Maybe_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Maybe_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Maybe_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.191003575 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdFmW,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFmW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFmX; else goto udFnM;
       cdFmX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       udFnM: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdFmM() args: 0, res: 0, upd: 0;
     }
 },
 _cdFmM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFmM: // global
           I64[Sp - 8] = block_cdFmP_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFnS; else goto cdFmQ;
       udFnS: // global
           call _cdFmP(R1) args: 0, res: 0, upd: 0;
       cdFmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFmP() //  [R1]
         { info_tbl: [(cdFmP,
                       label: block_cdFmP_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFmP: // global
           _sdEDo::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFmT; else goto cdFmU;
       cdFmT: // global
           I64[Sp + 24] = block_cdFn1_info;
           R1 = _sdEDo::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto udFnT; else goto cdFn3;
       udFnT: // global
           call _cdFn1(R1) args: 0, res: 0, upd: 0;
       cdFn3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFmU: // global
           I64[Sp] = block_cdFng_info;
           _sdEDt::P64 = P64[R1 + 6];
           _sdEDu::P64 = P64[R1 + 14];
           R1 = _sdEDo::P64;
           P64[Sp + 16] = _sdEDu::P64;
           P64[Sp + 24] = _sdEDt::P64;
           if (R1 & 7 != 0) goto udFnU; else goto cdFni;
       udFnU: // global
           call _cdFng(R1) args: 0, res: 0, upd: 0;
       cdFni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFn1() //  [R1]
         { info_tbl: [(cdFn1,
                       label: block_cdFn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFn1: // global
           if (R1 & 7 == 1) goto cdFn9; else goto udFnR;
       cdFn9: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udFnR: // global
           Sp = Sp + 8;
           call _cdFnz() args: 0, res: 0, upd: 0;
     }
 },
 _cdFng() //  [R1]
         { info_tbl: [(cdFng,
                       label: block_cdFng_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFng: // global
           if (R1 & 7 == 1) goto udFnN; else goto cdFnt;
       udFnN: // global
           Sp = Sp + 32;
           call _cdFnH() args: 0, res: 0, upd: 0;
       cdFnt: // global
           I64[Sp] = block_cdFnr_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sdEDx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sdEDx::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFnr() //  [R1]
         { info_tbl: [(cdFnr,
                       label: block_cdFnr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFnr: // global
           _cdFnJ::P64 = R1 & 7;
           if (_cdFnJ::P64 < 3) goto udFnL; else goto udFnO;
       udFnL: // global
           if (_cdFnJ::P64 < 2) goto udFnP; else goto cdFnD;
       udFnP: // global
           Sp = Sp + 32;
           call _cdFnz() args: 0, res: 0, upd: 0;
       cdFnD: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cdFmM() args: 0, res: 0, upd: 0;
       udFnO: // global
           Sp = Sp + 32;
           call _cdFnH() args: 0, res: 0, upd: 0;
     }
 },
 _cdFnz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFnz: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFnH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFnH: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.205143518 UTC

[section ""data" . Data.Functor.Classes.$fOrd1[]_closure" {
     Data.Functor.Classes.$fOrd1[]_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.207816586 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare1_closure" {
     Data.Functor.Classes.$w$cliftCompare1_closure:
         const Data.Functor.Classes.$w$cliftCompare1_info;
 },
 Data.Functor.Classes.$w$cliftCompare1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdFoX,
                       label: Data.Functor.Classes.$w$cliftCompare1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFoX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFoY; else goto cdFoZ;
       cdFoY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFoZ: // global
           I64[Sp - 32] = block_cdFoQ_info;
           _sdEDA::P64 = R3;
           R3 = R5;
           _sdEDz::P64 = R2;
           R2 = _sdEDA::P64;
           R1 = _sdEDz::P64;
           P64[Sp - 24] = _sdEDz::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFoQ() //  [R1]
         { info_tbl: [(cdFoQ,
                       label: block_cdFoQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFoQ: // global
           _cdFoW::P64 = R1 & 7;
           if (_cdFoW::P64 < 3) goto udFp9; else goto cdFoV;
       udFp9: // global
           if (_cdFoW::P64 < 2) goto cdFoT; else goto cdFoU;
       cdFoT: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFoU: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
       cdFoV: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.214230862 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdFpv,
                       label: Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFpv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFpz; else goto cdFpA;
       cdFpz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFpA: // global
           I64[Sp - 24] = block_cdFps_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFpI; else goto cdFpt;
       udFpI: // global
           call _cdFps(R1) args: 0, res: 0, upd: 0;
       cdFpt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFps() //  [R1]
         { info_tbl: [(cdFps,
                       label: block_cdFps_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFps: // global
           I64[Sp - 8] = block_cdFpy_info;
           _sdEDJ::P64 = P64[R1 + 7];
           _sdEDK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdEDK::P64;
           P64[Sp + 16] = _sdEDJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFpH; else goto cdFpC;
       udFpH: // global
           call _cdFpy(R1) args: 0, res: 0, upd: 0;
       cdFpC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFpy() //  [R1]
         { info_tbl: [(cdFpy,
                       label: block_cdFpy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFpy: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.221778996 UTC

[section ""data" . Data.Functor.Classes.$fOrd1NonEmpty_closure" {
     Data.Functor.Classes.$fOrd1NonEmpty_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1NonEmpty_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.223668698 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Identity_$cliftCompare_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdFq3,
                       label: Data.Functor.Classes.$fOrd1Identity_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFq3: // global
           _sdEDP::P64 = R3;
           R3 = R4;
           _sdEDO::P64 = R2;
           R2 = _sdEDP::P64;
           R1 = _sdEDO::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.227085781 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Identity_closure" {
     Data.Functor.Classes.$fOrd1Identity_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Identity_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Identity_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.22896233 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_entry() //  []
         { info_tbl: [(cdFqf,
                       label: Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFqf: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.232672848 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Proxy_closure" {
     Data.Functor.Classes.$fOrd1Proxy_closure:
         const Data.Functor.Classes.C:Ord1_con_info;
         const Data.Functor.Classes.$fEq1Proxy_$cliftEq_closure+3;
         const Data.Functor.Classes.$fOrd1Proxy_$cliftCompare_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.234678887 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadPrec_entry() //  [R3]
         { info_tbl: [(cdFqt,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFqt: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.23778632 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1NonEmpty4_bytes" {
     Data.Functor.Classes.$fRead1NonEmpty4_bytes:
         I8[] [58,124]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.23967839 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty3_closure" {
     Data.Functor.Classes.$fRead1NonEmpty3_closure:
         const Data.Functor.Classes.$fRead1NonEmpty3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty3_entry() //  [R1]
         { info_tbl: [(cdFqH,
                       label: Data.Functor.Classes.$fRead1NonEmpty3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFqH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFqI; else goto cdFqJ;
       cdFqI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFqJ: // global
           (_cdFqE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdFqE::I64 == 0) goto cdFqG; else goto cdFqF;
       cdFqG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdFqF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdFqE::I64;
           R2 = Data.Functor.Classes.$fRead1NonEmpty4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.243674081 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty2_closure" {
     Data.Functor.Classes.$fRead1NonEmpty2_closure:
         const GHC.Types.I#_con_info;
         const 6;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.247743468 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec5_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec5_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec5_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFqU: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sdEEj_entry() //  [R1, R2]
         { info_tbl: [(cdFrN,
                       label: go2_sdEEj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFrO; else goto cdFrP;
       cdFrO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFrP: // global
           I64[Sp - 32] = block_cdFrG_info;
           _sdEEj::P64 = R1;
           _sdEE6::P64 = P64[R1 + 7];
           _sdEEi::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdEE6::P64;
           P64[Sp - 16] = _sdEEi::P64;
           P64[Sp - 8] = _sdEEj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFs9; else goto cdFrH;
       udFs9: // global
           call _cdFrG(R1) args: 0, res: 0, upd: 0;
       cdFrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFrG() //  [R1]
         { info_tbl: [(cdFrG,
                       label: block_cdFrG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrG: // global
           if (R1 & 7 == 1) goto cdFrK; else goto cdFrL;
       cdFrK: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdFrL: // global
           I64[Sp] = block_cdFrV_info;
           _sdEEn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdEEn::P64;
           if (R1 & 7 != 0) goto udFs8; else goto cdFrW;
       udFs8: // global
           call _cdFrV(R1) args: 0, res: 0, upd: 0;
       cdFrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFrV() //  [R1]
         { info_tbl: [(cdFrV,
                       label: block_cdFrV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrV: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdFs7; else goto cdFs6;
       cdFs7: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFs6: // global
           _sdEEp::P64 = P64[R1 + 7];
           _sdEEq::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_2_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = GHC.Base.:|_con_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sdEEp::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = _sdEEq::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sdEE9_entry() //  [R1, R2]
         { info_tbl: [(cdFse,
                       label: go1_sdEE9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFse: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdFsf; else goto udFsz;
       cdFsf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udFsz: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdFrh() args: 0, res: 0, upd: 0;
     }
 },
 _cdFrh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrh: // global
           I64[Sp - 24] = block_cdFrk_info;
           R1 = P64[Sp + 8];
           _sdEE9::P64 = P64[Sp];
           P64[Sp - 16] = P64[_sdEE9::P64 + 15];
           P64[Sp - 8] = P64[_sdEE9::P64 + 23];
           P64[Sp + 8] = P64[_sdEE9::P64 + 7];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFsB; else goto cdFrl;
       udFsB: // global
           call _cdFrk(R1) args: 0, res: 0, upd: 0;
       cdFrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFrk() //  [R1]
         { info_tbl: [(cdFrk,
                       label: block_cdFrk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrk: // global
           if (R1 & 7 == 1) goto cdFsb; else goto cdFsc;
       cdFsb: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdFsc: // global
           I64[Sp] = block_cdFrq_info;
           _sdEEd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdEEd::P64;
           if (R1 & 7 != 0) goto udFsC; else goto cdFrr;
       udFsC: // global
           call _cdFrq(R1) args: 0, res: 0, upd: 0;
       cdFrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFrq() //  [R1]
         { info_tbl: [(cdFrq,
                       label: block_cdFrq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrq: // global
           I64[Sp - 8] = block_cdFrv_info;
           R3 = Data.Functor.Classes.$fRead1NonEmpty3_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFrv() //  [R1]
         { info_tbl: [(cdFrv,
                       label: block_cdFrv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFrv: // global
           _sdEEd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFso; else goto cdFsq;
       cdFso: // global
           P64[Sp + 40] = _sdEEd::P64;
           Sp = Sp + 32;
           call _cdFrh() args: 0, res: 0, upd: 0;
       cdFsq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFst; else goto cdFss;
       cdFst: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFss: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdEEd::P64;
           I64[Hp - 16] = go2_sdEEj_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           I64[Sp + 32] = block_cdFsp_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFsp() //  [R1]
         { info_tbl: [(cdFsp,
                       label: block_cdFsp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFsp: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_sdEEj_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdEE0_entry() //  [R1, R2]
         { info_tbl: [(cdFsJ,
                       label: go_sdEE0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFsJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFsK; else goto cdFsL;
       cdFsK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFsL: // global
           I64[Sp - 24] = block_cdFr3_info;
           _sdEE0::P64 = R1;
           _sdEDX::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdEDX::P64;
           P64[Sp - 8] = _sdEE0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFsY; else goto cdFr4;
       udFsY: // global
           call _cdFr3(R1) args: 0, res: 0, upd: 0;
       cdFr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFr3() //  [R1]
         { info_tbl: [(cdFr3,
                       label: block_cdFr3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFr3: // global
           if (R1 & 7 == 1) goto cdFsG; else goto cdFsH;
       cdFsG: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFsH: // global
           I64[Sp - 8] = block_cdFr9_info;
           _sdEE4::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdEE4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFsX; else goto cdFra;
       udFsX: // global
           call _cdFr9(R1) args: 0, res: 0, upd: 0;
       cdFra: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFr9() //  [R1]
         { info_tbl: [(cdFr9,
                       label: block_cdFr9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFr9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdFsS; else goto cdFsR;
       cdFsS: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFsR: // global
           _sdEE6::P64 = P64[R1 + 7];
           _sdEE7::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdEE9_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _sdEE6::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 16] = block_cdFsO_info;
           R3 = _sdEE7::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFsO() //  [R1]
         { info_tbl: [(cdFsO,
                       label: block_cdFsO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFsO: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdEE9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEEA_entry() //  [R1, R2]
         { info_tbl: [(cdFt6,
                       label: sat_sdEEA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFt6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFt7; else goto cdFt8;
       cdFt7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFt8: // global
           I64[Sp - 16] = block_cdFt4_info;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           _sdEE0::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdEE0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFt4() //  [R1]
         { info_tbl: [(cdFt4,
                       label: block_cdFt4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFt4: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdEE0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec5_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdFte,
                       label: Data.Functor.Classes.$w$cliftReadsPrec5_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFte: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdFti; else goto cdFth;
       cdFti: // global
           HpAlloc = 40;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec5_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdFth: // global
           I64[Hp - 32] = go_sdEE0_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdEEA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 31;
           _sdEEx::P64 = I64[(%MO_S_Gt_W64(R4,
                                           5) << 3) + GHC.Types.Bool_closure_tbl];
           R4 = R5;
           R3 = Hp - 15;
           R2 = _sdEEx::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.283013281 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdFvk,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFvk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFvl; else goto cdFvm;
       cdFvl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFvm: // global
           I64[Sp - 32] = block_cdFvh_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFvq; else goto cdFvi;
       udFvq: // global
           call _cdFvh(R1) args: 0, res: 0, upd: 0;
       cdFvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFvh() //  [R1]
         { info_tbl: [(cdFvh,
                       label: block_cdFvh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFvh: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.28858627 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Proxy4_bytes" {
     Data.Functor.Classes.$fRead1Proxy4_bytes:
         I8[] [80,114,111,120,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.290577212 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy3_closure" {
     Data.Functor.Classes.$fRead1Proxy3_closure:
         const Data.Functor.Classes.$fRead1Proxy3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy3_entry() //  [R1]
         { info_tbl: [(cdFvI,
                       label: Data.Functor.Classes.$fRead1Proxy3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFvI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFvJ; else goto cdFvK;
       cdFvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFvK: // global
           (_cdFvF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdFvF::I64 == 0) goto cdFvH; else goto cdFvG;
       cdFvH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdFvG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdFvF::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.294890076 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_lexeme_closure" {
     Data.Functor.Classes.$fRead1Proxy_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.297048685 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy2_closure" {
     Data.Functor.Classes.$fRead1Proxy2_closure:
         const Data.Functor.Classes.$fRead1Proxy2_info;
         const 0;
 },
 sat_sdEEK_entry() //  [R1]
         { info_tbl: [(cdFw3,
                       label: sat_sdEEK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFw3: // global
           R2 = Data.Proxy.Proxy_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Proxy2_entry() //  [R2, R3]
         { info_tbl: [(cdFw9,
                       label: Data.Functor.Classes.$fRead1Proxy2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFw9: // global
           _sdEEI::P64 = R3;
           _sdEEH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdFwa; else goto cdFwb;
       cdFwb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFwd; else goto cdFwc;
       cdFwd: // global
           HpAlloc = 16;
           goto cdFwa;
       cdFwa: // global
           R3 = _sdEEI::P64;
           R2 = _sdEEH::P64;
           R1 = Data.Functor.Classes.$fRead1Proxy2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFwc: // global
           I64[Hp - 8] = sat_sdEEK_info;
           P64[Hp] = _sdEEI::P64;
           I64[Sp - 8] = block_cdFw6_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Proxy_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFw6() //  [R1]
         { info_tbl: [(cdFw6,
                       label: block_cdFw6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFw6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFwg; else goto cdFwf;
       cdFwg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFwf: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.304600251 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy1_closure" {
     Data.Functor.Classes.$fRead1Proxy1_closure:
         const Data.Functor.Classes.$fRead1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy1_entry() //  [R2, R3]
         { info_tbl: [(cdFwB,
                       label: Data.Functor.Classes.$fRead1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFwB: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.308674377 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy5_closure" {
     Data.Functor.Classes.$fRead1Proxy5_closure:
         const Data.Functor.Classes.$fRead1Proxy5_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy5_entry() //  [R4, R5]
         { info_tbl: [(cdFwM,
                       label: Data.Functor.Classes.$fRead1Proxy5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFwM: // global
           R3 = R5;
           R2 = R4;
           call Data.Functor.Classes.$fRead1Proxy1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.312290884 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_entry() //  [R3]
         { info_tbl: [(cdFwX,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFwX: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.315531333 UTC

[section ""cstring" . Data.Functor.Classes.$fShow1NonEmpty1_bytes" {
     Data.Functor.Classes.$fShow1NonEmpty1_bytes:
         I8[] [32,58,124,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.318805917 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec1_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec1_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec1_info;
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFx6: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 8, res: 0, upd: 8;
     }
 },
 f_sdEEX_entry() //  [R1]
         { info_tbl: [(cdFxe,
                       label: f_sdEEX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFxf; else goto cdFxg;
       cdFxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1NonEmpty2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEF2_entry() //  [R1]
         { info_tbl: [(cdFxv,
                       label: sat_sdEF2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFxv: // global
           _sdEF2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFxw; else goto cdFxx;
       cdFxx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFxz; else goto cdFxy;
       cdFxz: // global
           HpAlloc = 32;
           goto cdFxw;
       cdFxw: // global
           R1 = _sdEF2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFxy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEF2::P64;
           _sdEEY::P64 = P64[_sdEF2::P64 + 16];
           _sdEF0::P64 = P64[_sdEF2::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdEEY::P64;
           P64[Hp] = _sdEF0::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEF3_entry() //  [R1, R2]
         { info_tbl: [(cdFxA,
                       label: sat_sdEF3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFxA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFxE; else goto cdFxD;
       cdFxE: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFxD: // global
           _sdEEX::P64 = P64[R1 + 7];
           _sdEEY::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdEF2_info;
           P64[Hp - 8] = _sdEEY::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdEEX::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEF6_entry() //  [R1]
         { info_tbl: [(cdFxY,
                       label: sat_sdEF6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFxY: // global
           _sdEF6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFxZ; else goto cdFy0;
       cdFy0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFy2; else goto cdFy1;
       cdFy2: // global
           HpAlloc = 24;
           goto cdFxZ;
       cdFxZ: // global
           R1 = _sdEF6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFy1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEF6::P64;
           _sdEEY::P64 = P64[_sdEF6::P64 + 16];
           _sdEF4::P64 = P64[_sdEF6::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdEF4::P64;
           R2 = Hp - 14;
           R1 = _sdEEY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEF7_entry() //  [R1]
         { info_tbl: [(cdFy3,
                       label: sat_sdEF7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFy3: // global
           _sdEF7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFy4; else goto cdFy5;
       cdFy5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFy7; else goto cdFy6;
       cdFy7: // global
           HpAlloc = 32;
           goto cdFy4;
       cdFy4: // global
           R1 = _sdEF7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFy6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEF7::P64;
           _sdEEY::P64 = P64[_sdEF7::P64 + 16];
           _sdEF4::P64 = P64[_sdEF7::P64 + 24];
           I64[Hp - 24] = sat_sdEF6_info;
           P64[Hp - 8] = _sdEEY::P64;
           P64[Hp] = _sdEF4::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Classes.$fShow1NonEmpty1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEF8_entry() //  [R1]
         { info_tbl: [(cdFy8,
                       label: sat_sdEF8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFy8: // global
           _sdEF8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFy9; else goto cdFya;
       cdFya: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFyc; else goto cdFyb;
       cdFyc: // global
           HpAlloc = 32;
           goto cdFy9;
       cdFy9: // global
           R1 = _sdEF8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFyb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEF8::P64;
           _sdEEX::P64 = P64[_sdEF8::P64 + 16];
           _sdEEY::P64 = P64[_sdEF8::P64 + 24];
           _sdEF4::P64 = P64[_sdEF8::P64 + 32];
           I64[Hp - 24] = sat_sdEF7_info;
           P64[Hp - 8] = _sdEEY::P64;
           P64[Hp] = _sdEF4::P64;
           R2 = Hp - 24;
           R1 = _sdEEX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEF9_entry() //  [R1, R2]
         { info_tbl: [(cdFye,
                       label: sat_sdEF9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFye: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdFyi; else goto cdFyh;
       cdFyi: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFyh: // global
           _sdEEX::P64 = P64[R1 + 7];
           _sdEEY::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdEF8_info;
           P64[Hp - 40] = _sdEEX::P64;
           P64[Hp - 32] = _sdEEY::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cdFym,
                       label: Data.Functor.Classes.$w$cliftShowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFym: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdFyq; else goto cdFyp;
       cdFyq: // global
           HpAlloc = 88;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdFyp: // global
           I64[Hp - 80] = f_sdEEX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdFxa::P64 = Hp - 80;
           _cdFxh::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 5)) goto cdFyk; else goto cdFyl;
       cdFyk: // global
           I64[Hp - 16] = sat_sdEF3_info;
           P64[Hp - 8] = _cdFxa::P64;
           P64[Hp] = _cdFxh::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFyl: // global
           I64[Hp - 16] = sat_sdEF9_info;
           P64[Hp - 8] = _cdFxa::P64;
           P64[Hp] = _cdFxh::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.340407457 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info;
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdFzq,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFzq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFzu; else goto cdFzv;
       cdFzu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFzv: // global
           I64[Sp - 32] = block_cdFzn_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFzD; else goto cdFzo;
       udFzD: // global
           call _cdFzn(R1) args: 0, res: 0, upd: 0;
       cdFzo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFzn() //  [R1]
         { info_tbl: [(cdFzn,
                       label: block_cdFzn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFzn: // global
           I64[Sp] = block_cdFzt_info;
           _sdEFf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sdEFf::I64;
           if (R1 & 7 != 0) goto udFzC; else goto cdFzx;
       udFzC: // global
           call _cdFzt(R1) args: 0, res: 0, upd: 0;
       cdFzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFzt() //  [R1]
         { info_tbl: [(cdFzt,
                       label: block_cdFzt_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFzt: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.348847919 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy2_closure" {
     Data.Functor.Classes.$fShow1Proxy2_closure:
         const Data.Functor.Classes.$fShow1Proxy2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy2_entry() //  [R2]
         { info_tbl: [(cdFzX,
                       label: Data.Functor.Classes.$fShow1Proxy2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFzX: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Proxy3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.352415107 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_entry() //  [R6]
         { info_tbl: [(cdFA8,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFA8: // global
           R2 = R6;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.356644537 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdFAm,
                       label: Data.Functor.Classes.$fEq2(,)_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFAm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdFAq; else goto cdFAr;
       cdFAq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFAr: // global
           I64[Sp - 32] = block_cdFAj_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFAL; else goto cdFAk;
       udFAL: // global
           call _cdFAj(R1) args: 0, res: 0, upd: 0;
       cdFAk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFAj() //  [R1]
         { info_tbl: [(cdFAj,
                       label: block_cdFAj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFAj: // global
           I64[Sp - 8] = block_cdFAp_info;
           _sdEFs::P64 = P64[R1 + 7];
           _sdEFt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdEFt::P64;
           P64[Sp + 24] = _sdEFs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFAK; else goto cdFAt;
       udFAK: // global
           call _cdFAp(R1) args: 0, res: 0, upd: 0;
       cdFAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFAp() //  [R1]
         { info_tbl: [(cdFAp,
                       label: block_cdFAp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFAp: // global
           I64[Sp] = block_cdFAx_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdEFw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdEFw::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFAx() //  [R1]
         { info_tbl: [(cdFAx,
                       label: block_cdFAx_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFAx: // global
           if (R1 & 7 == 1) goto cdFAE; else goto cdFAI;
       cdFAE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFAI: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.366471878 UTC

[section ""data" . Data.Functor.Classes.$fEq2(,)_closure" {
     Data.Functor.Classes.$fEq2(,)_closure:
         const Data.Functor.Classes.$fEq2(,)_info;
 },
 Data.Functor.Classes.$fEq2(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFBd,
                       label: Data.Functor.Classes.$fEq2(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFBd: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2(,)_$cliftEq2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.370346176 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1(,)_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1(,)_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1(,)_$cliftEq_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFBr,
                       label: Data.Functor.Classes.$fEq1(,)_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFBr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdFBv; else goto cdFBw;
       cdFBv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1(,)_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFBw: // global
           I64[Sp - 32] = block_cdFBo_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFBQ; else goto cdFBp;
       udFBQ: // global
           call _cdFBo(R1) args: 0, res: 0, upd: 0;
       cdFBp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFBo() //  [R1]
         { info_tbl: [(cdFBo,
                       label: block_cdFBo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFBo: // global
           I64[Sp - 8] = block_cdFBu_info;
           _sdEFD::P64 = P64[R1 + 7];
           _sdEFE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdEFE::P64;
           P64[Sp + 24] = _sdEFD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFBP; else goto cdFBy;
       udFBP: // global
           call _cdFBu(R1) args: 0, res: 0, upd: 0;
       cdFBy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFBu() //  [R1]
         { info_tbl: [(cdFBu,
                       label: block_cdFBu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFBu: // global
           I64[Sp] = block_cdFBC_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdFBC() //  [R1]
         { info_tbl: [(cdFBC,
                       label: block_cdFBC_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFBC: // global
           if (R1 & 7 == 1) goto cdFBJ; else goto cdFBN;
       cdFBJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFBN: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.380364428 UTC

[section ""data" . Data.Functor.Classes.$fEq1(,)_closure" {
     Data.Functor.Classes.$fEq1(,)_closure:
         const Data.Functor.Classes.$fEq1(,)_info;
 },
 Data.Functor.Classes.$fEq1(,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFCm,
                       label: Data.Functor.Classes.$fEq1(,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFCm: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1(,)_$cliftEq_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.385005318 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Either_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Either_$cliftEq2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdFCE,
                       label: Data.Functor.Classes.$fEq2Either_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFCE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFCF; else goto cdFCG;
       cdFCF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq2Either_$cliftEq2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFCG: // global
           I64[Sp - 32] = block_cdFCx_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFDh; else goto cdFCy;
       udFDh: // global
           call _cdFCx(R1) args: 0, res: 0, upd: 0;
       cdFCy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFCx() //  [R1]
         { info_tbl: [(cdFCx,
                       label: block_cdFCx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFCx: // global
           _sdEFM::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFCB; else goto cdFCC;
       cdFCB: // global
           I64[Sp] = block_cdFCJ_info;
           _sdEFO::P64 = P64[R1 + 7];
           R1 = _sdEFM::P64;
           P64[Sp + 24] = _sdEFO::P64;
           if (R1 & 7 != 0) goto udFDf; else goto cdFCL;
       udFDf: // global
           call _cdFCJ(R1) args: 0, res: 0, upd: 0;
       cdFCL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFCC: // global
           I64[Sp + 8] = block_cdFCY_info;
           _sdEFS::P64 = P64[R1 + 6];
           R1 = _sdEFM::P64;
           P64[Sp + 24] = _sdEFS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udFDg; else goto cdFD0;
       udFDg: // global
           call _cdFCY(R1) args: 0, res: 0, upd: 0;
       cdFD0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFCJ() //  [R1]
         { info_tbl: [(cdFCJ,
                       label: block_cdFCJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFCJ: // global
           if (R1 & 7 == 1) goto cdFCR; else goto udFDe;
       cdFCR: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       udFDe: // global
           Sp = Sp + 32;
           call _cdFD6() args: 0, res: 0, upd: 0;
     }
 },
 _cdFCY() //  [R1]
         { info_tbl: [(cdFCY,
                       label: block_cdFCY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFCY: // global
           if (R1 & 7 == 1) goto udFDd; else goto cdFDa;
       udFDd: // global
           Sp = Sp + 24;
           call _cdFD6() args: 0, res: 0, upd: 0;
       cdFDa: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFD6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFD6: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.395940523 UTC

[section ""data" . Data.Functor.Classes.$fEq2Either_closure" {
     Data.Functor.Classes.$fEq2Either_closure:
         const Data.Functor.Classes.$fEq2Either_info;
 },
 Data.Functor.Classes.$fEq2Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFDS,
                       label: Data.Functor.Classes.$fEq2Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFDS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Either_$cliftEq2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.400354476 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Either_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Either_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Either_$cliftEq_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdFEa,
                       label: Data.Functor.Classes.$fEq1Either_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFEa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFEb; else goto cdFEc;
       cdFEb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Either_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFEc: // global
           I64[Sp - 32] = block_cdFE3_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFEN; else goto cdFE4;
       udFEN: // global
           call _cdFE3(R1) args: 0, res: 0, upd: 0;
       cdFE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFE3() //  [R1]
         { info_tbl: [(cdFE3,
                       label: block_cdFE3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFE3: // global
           _sdEFZ::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFE7; else goto cdFE8;
       cdFE7: // global
           I64[Sp] = block_cdFEf_info;
           _sdEG1::P64 = P64[R1 + 7];
           R1 = _sdEFZ::P64;
           P64[Sp + 24] = _sdEG1::P64;
           if (R1 & 7 != 0) goto udFEL; else goto cdFEh;
       udFEL: // global
           call _cdFEf(R1) args: 0, res: 0, upd: 0;
       cdFEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFE8: // global
           I64[Sp + 8] = block_cdFEu_info;
           _sdEG5::P64 = P64[R1 + 6];
           R1 = _sdEFZ::P64;
           P64[Sp + 24] = _sdEG5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udFEM; else goto cdFEw;
       udFEM: // global
           call _cdFEu(R1) args: 0, res: 0, upd: 0;
       cdFEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFEf() //  [R1]
         { info_tbl: [(cdFEf,
                       label: block_cdFEf_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFEf: // global
           if (R1 & 7 == 1) goto cdFEn; else goto udFEK;
       cdFEn: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
       udFEK: // global
           Sp = Sp + 32;
           call _cdFEC() args: 0, res: 0, upd: 0;
     }
 },
 _cdFEu() //  [R1]
         { info_tbl: [(cdFEu,
                       label: block_cdFEu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFEu: // global
           if (R1 & 7 == 1) goto udFEJ; else goto cdFEG;
       udFEJ: // global
           Sp = Sp + 24;
           call _cdFEC() args: 0, res: 0, upd: 0;
       cdFEG: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFEC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFEC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.410981815 UTC

[section ""data" . Data.Functor.Classes.$fEq1Either_closure" {
     Data.Functor.Classes.$fEq1Either_closure:
         const Data.Functor.Classes.$fEq1Either_info;
 },
 Data.Functor.Classes.$fEq1Either_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFFr,
                       label: Data.Functor.Classes.$fEq1Either_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFFr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Either_$cliftEq_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.41470361 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_$cliftEq2_closure" {
     Data.Functor.Classes.$fEq2Const_$cliftEq2_closure:
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_info;
 },
 Data.Functor.Classes.$fEq2Const_$cliftEq2_entry() //  [R2, R4, R5]
         { info_tbl: [(cdFFC,
                       label: Data.Functor.Classes.$fEq2Const_$cliftEq2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFFC: // global
           R3 = R5;
           _sdEG9::P64 = R2;
           R2 = R4;
           R1 = _sdEG9::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.418259021 UTC

[section ""data" . Data.Functor.Classes.$fEq2Const_closure" {
     Data.Functor.Classes.$fEq2Const_closure:
         const Data.Functor.Classes.$fEq2Const_info;
 },
 Data.Functor.Classes.$fEq2Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFFN,
                       label: Data.Functor.Classes.$fEq2Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFFN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq2Const_$cliftEq2_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.422264156 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_$cliftEq_closure" {
     Data.Functor.Classes.$fEq1Const_$cliftEq_closure:
         const Data.Functor.Classes.$fEq1Const_$cliftEq_info;
 },
 Data.Functor.Classes.$fEq1Const_$cliftEq_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdFFY,
                       label: Data.Functor.Classes.$fEq1Const_$cliftEq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFFY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdFFZ; else goto cdFG0;
       cdFFZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fEq1Const_$cliftEq_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFG0: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.42618077 UTC

[section ""data" . Data.Functor.Classes.$fEq1Const_closure" {
     Data.Functor.Classes.$fEq1Const_closure:
         const Data.Functor.Classes.$fEq1Const_info;
 },
 Data.Functor.Classes.$fEq1Const_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFGb,
                       label: Data.Functor.Classes.$fEq1Const_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFGb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$fEq1Const_$cliftEq_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.430077454 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdFGp,
                       label: Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFGp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdFGt; else goto cdFGu;
       cdFGt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFGu: // global
           I64[Sp - 32] = block_cdFGm_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFGT; else goto cdFGn;
       udFGT: // global
           call _cdFGm(R1) args: 0, res: 0, upd: 0;
       cdFGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFGm() //  [R1]
         { info_tbl: [(cdFGm,
                       label: block_cdFGm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFGm: // global
           I64[Sp - 8] = block_cdFGs_info;
           _sdEGm::P64 = P64[R1 + 7];
           _sdEGn::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdEGn::P64;
           P64[Sp + 24] = _sdEGm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFGS; else goto cdFGw;
       udFGS: // global
           call _cdFGs(R1) args: 0, res: 0, upd: 0;
       cdFGw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFGs() //  [R1]
         { info_tbl: [(cdFGs,
                       label: block_cdFGs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFGs: // global
           I64[Sp] = block_cdFGA_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 32];
           _sdEGq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp + 32] = _sdEGq::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFGA() //  [R1]
         { info_tbl: [(cdFGA,
                       label: block_cdFGA_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFGA: // global
           _cdFGQ::P64 = R1 & 7;
           if (_cdFGQ::P64 < 3) goto udFGR; else goto cdFGP;
       udFGR: // global
           if (_cdFGQ::P64 < 2) goto cdFGH; else goto cdFGL;
       cdFGH: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFGL: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFGP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.439825185 UTC

[section ""data" . Data.Functor.Classes.$fOrd2(,)_closure" {
     Data.Functor.Classes.$fOrd2(,)_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2(,)_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2(,)_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.442194808 UTC

[section ""data" . Data.Functor.Classes.$w$cliftCompare_closure" {
     Data.Functor.Classes.$w$cliftCompare_closure:
         const Data.Functor.Classes.$w$cliftCompare_info;
 },
 Data.Functor.Classes.$w$cliftCompare_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdFHu,
                       label: Data.Functor.Classes.$w$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFHu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdFHv; else goto cdFHw;
       cdFHv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdFHw: // global
           I64[Sp - 24] = block_cdFHn_info;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pp_info;
           P64[Sp - 40] = R4;
           P64[Sp - 32] = R6;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdFHn() //  [R1]
         { info_tbl: [(cdFHn,
                       label: block_cdFHn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFHn: // global
           _cdFHt::P64 = R1 & 7;
           if (_cdFHt::P64 < 3) goto udFHG; else goto cdFHs;
       udFHG: // global
           if (_cdFHt::P64 < 2) goto cdFHq; else goto cdFHr;
       cdFHq: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFHr: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFHs: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.448994954 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdFI3,
                       label: Data.Functor.Classes.$fOrd1(,)_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFI3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdFI7; else goto cdFI8;
       cdFI7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFI8: // global
           I64[Sp - 32] = block_cdFI0_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFIg; else goto cdFI1;
       udFIg: // global
           call _cdFI0(R1) args: 0, res: 0, upd: 0;
       cdFI1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFI0() //  [R1]
         { info_tbl: [(cdFI0,
                       label: block_cdFI0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFI0: // global
           I64[Sp - 8] = block_cdFI6_info;
           _sdEGE::P64 = P64[R1 + 7];
           _sdEGF::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdEGF::P64;
           P64[Sp + 24] = _sdEGE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFIf; else goto cdFIa;
       udFIf: // global
           call _cdFI6(R1) args: 0, res: 0, upd: 0;
       cdFIa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFI6() //  [R1]
         { info_tbl: [(cdFI6,
                       label: block_cdFI6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFI6: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftCompare_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.457570535 UTC

[section ""data" . Data.Functor.Classes.$w$cp1Ord1_closure" {
     Data.Functor.Classes.$w$cp1Ord1_closure:
         const Data.Functor.Classes.$w$cp1Ord1_info;
 },
 Data.Functor.Classes.$w$cp1Ord1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdFID,
                       label: Data.Functor.Classes.$w$cp1Ord1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFID: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdFIE; else goto cdFIF;
       cdFIE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cp1Ord1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdFIF: // global
           I64[Sp - 40] = block_cdFIB_info;
           R2 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFIB() //  [R1]
         { info_tbl: [(cdFIB,
                       label: block_cdFIB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFIB: // global
           I64[Sp] = block_cdFII_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdFII() //  [R1]
         { info_tbl: [(cdFII,
                       label: block_cdFII_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFII: // global
           if (R1 & 7 == 1) goto cdFIP; else goto cdFIT;
       cdFIP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFIT: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.465480894 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)1_closure" {
     Data.Functor.Classes.$fOrd1(,)1_closure:
         const Data.Functor.Classes.$fOrd1(,)1_info;
 },
 Data.Functor.Classes.$fOrd1(,)1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFJm,
                       label: Data.Functor.Classes.$fOrd1(,)1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFJm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdFJq; else goto cdFJr;
       cdFJq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFJr: // global
           I64[Sp - 32] = block_cdFJj_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFJz; else goto cdFJk;
       udFJz: // global
           call _cdFJj(R1) args: 0, res: 0, upd: 0;
       cdFJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFJj() //  [R1]
         { info_tbl: [(cdFJj,
                       label: block_cdFJj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFJj: // global
           I64[Sp - 8] = block_cdFJp_info;
           _sdEGW::P64 = P64[R1 + 7];
           _sdEGX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdEGX::P64;
           P64[Sp + 24] = _sdEGW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udFJy; else goto cdFJt;
       udFJy: // global
           call _cdFJp(R1) args: 0, res: 0, upd: 0;
       cdFJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFJp() //  [R1]
         { info_tbl: [(cdFJp,
                       label: block_cdFJp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFJp: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cp1Ord1_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.473414171 UTC

[section ""data" . Data.Functor.Classes.$fOrd1(,)_closure" {
     Data.Functor.Classes.$fOrd1(,)_closure:
         const Data.Functor.Classes.$fOrd1(,)_info;
 },
 sat_sdEH3_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdFJZ,
                       label: sat_sdEH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFJZ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)_$cliftCompare_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEH2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdFK7,
                       label: sat_sdEH2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFK7: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1(,)1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1(,)_entry() //  [R2]
         { info_tbl: [(cdFKb,
                       label: Data.Functor.Classes.$fOrd1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFKb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFKf; else goto cdFKe;
       cdFKf: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFKe: // global
           I64[Hp - 48] = sat_sdEH3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdEH2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.481072347 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Either_$cliftCompare2_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdFKH,
                       label: Data.Functor.Classes.$fOrd2Either_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFKH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFKI; else goto cdFKJ;
       cdFKI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFKJ: // global
           I64[Sp - 32] = block_cdFKA_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFLi; else goto cdFKB;
       udFLi: // global
           call _cdFKA(R1) args: 0, res: 0, upd: 0;
       cdFKB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFKA() //  [R1]
         { info_tbl: [(cdFKA,
                       label: block_cdFKA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFKA: // global
           _sdEH7::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFKE; else goto cdFKF;
       cdFKE: // global
           I64[Sp] = block_cdFKM_info;
           _sdEH9::P64 = P64[R1 + 7];
           R1 = _sdEH7::P64;
           P64[Sp + 24] = _sdEH9::P64;
           if (R1 & 7 != 0) goto udFLg; else goto cdFKO;
       udFLg: // global
           call _cdFKM(R1) args: 0, res: 0, upd: 0;
       cdFKO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFKF: // global
           I64[Sp + 8] = block_cdFL1_info;
           _sdEHd::P64 = P64[R1 + 6];
           R1 = _sdEH7::P64;
           P64[Sp + 24] = _sdEHd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udFLh; else goto cdFL3;
       udFLh: // global
           call _cdFL1(R1) args: 0, res: 0, upd: 0;
       cdFL3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFKM() //  [R1]
         { info_tbl: [(cdFKM,
                       label: block_cdFKM_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFKM: // global
           if (R1 & 7 == 1) goto cdFKU; else goto cdFKY;
       cdFKU: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFKY: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFL1() //  [R1]
         { info_tbl: [(cdFL1,
                       label: block_cdFL1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFL1: // global
           if (R1 & 7 == 1) goto cdFL9; else goto cdFLd;
       cdFL9: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFLd: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.491162388 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Either_closure" {
     Data.Functor.Classes.$fOrd2Either_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Either_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Either_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.494233751 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure" {
     Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure:
         const Data.Functor.Classes.$fOrd1Either_$cliftCompare_info;
 },
 Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdFLZ,
                       label: Data.Functor.Classes.$fOrd1Either_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFLZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFM0; else goto cdFM1;
       cdFM0: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_$cliftCompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFM1: // global
           I64[Sp - 32] = block_cdFLS_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFMA; else goto cdFLT;
       udFMA: // global
           call _cdFLS(R1) args: 0, res: 0, upd: 0;
       cdFLT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFLS() //  [R1]
         { info_tbl: [(cdFLS,
                       label: block_cdFLS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFLS: // global
           _sdEHk::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFLW; else goto cdFLX;
       cdFLW: // global
           I64[Sp] = block_cdFM4_info;
           _sdEHm::P64 = P64[R1 + 7];
           R1 = _sdEHk::P64;
           P64[Sp + 24] = _sdEHm::P64;
           if (R1 & 7 != 0) goto udFMy; else goto cdFM6;
       udFMy: // global
           call _cdFM4(R1) args: 0, res: 0, upd: 0;
       cdFM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFLX: // global
           I64[Sp + 8] = block_cdFMj_info;
           _sdEHq::P64 = P64[R1 + 6];
           R1 = _sdEHk::P64;
           P64[Sp + 24] = _sdEHq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udFMz; else goto cdFMl;
       udFMz: // global
           call _cdFMj(R1) args: 0, res: 0, upd: 0;
       cdFMl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFM4() //  [R1]
         { info_tbl: [(cdFM4,
                       label: block_cdFM4_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFM4: // global
           if (R1 & 7 == 1) goto cdFMc; else goto cdFMg;
       cdFMc: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
       cdFMg: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFMj() //  [R1]
         { info_tbl: [(cdFMj,
                       label: block_cdFMj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFMj: // global
           if (R1 & 7 == 1) goto cdFMr; else goto cdFMv;
       cdFMr: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdFMv: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.505204836 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either1_closure" {
     Data.Functor.Classes.$fOrd1Either1_closure:
         const Data.Functor.Classes.$fOrd1Either1_info;
 },
 Data.Functor.Classes.$fOrd1Either1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFNj,
                       label: Data.Functor.Classes.$fOrd1Either1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFNj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFNk; else goto cdFNl;
       cdFNk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFNl: // global
           I64[Sp - 32] = block_cdFNc_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFO1; else goto cdFNd;
       udFO1: // global
           call _cdFNc(R1) args: 0, res: 0, upd: 0;
       cdFNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFNc() //  [R1]
         { info_tbl: [(cdFNc,
                       label: block_cdFNc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFNc: // global
           _sdEHx::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdFNg; else goto cdFNh;
       cdFNg: // global
           I64[Sp] = block_cdFNo_info;
           _sdEHz::P64 = P64[R1 + 7];
           R1 = _sdEHx::P64;
           P64[Sp + 24] = _sdEHz::P64;
           if (R1 & 7 != 0) goto udFNZ; else goto cdFNq;
       udFNZ: // global
           call _cdFNo(R1) args: 0, res: 0, upd: 0;
       cdFNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdFNh: // global
           I64[Sp + 8] = block_cdFNI_info;
           _sdEHE::P64 = P64[R1 + 6];
           R1 = _sdEHx::P64;
           P64[Sp + 24] = _sdEHE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udFO0; else goto cdFNK;
       udFO0: // global
           call _cdFNI(R1) args: 0, res: 0, upd: 0;
       cdFNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFNo() //  [R1]
         { info_tbl: [(cdFNo,
                       label: block_cdFNo_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFNo: // global
           if (R1 & 7 == 1) goto cdFNx; else goto udFNY;
       cdFNx: // global
           _sdEHu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdFNu_info;
           R2 = _sdEHu::P64;
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       udFNY: // global
           Sp = Sp + 32;
           call _cdFNQ() args: 0, res: 0, upd: 0;
     }
 },
 _cdFNu() //  [R1]
         { info_tbl: [(cdFNu,
                       label: block_cdFNu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFNu: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sdEHB::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sdEHB::P64;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdFNI() //  [R1]
         { info_tbl: [(cdFNI,
                       label: block_cdFNI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFNI: // global
           if (R1 & 7 == 1) goto udFNX; else goto cdFNU;
       udFNX: // global
           Sp = Sp + 24;
           call _cdFNQ() args: 0, res: 0, upd: 0;
       cdFNU: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdFNQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFNQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.518271202 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Either_closure" {
     Data.Functor.Classes.$fOrd1Either_closure:
         const Data.Functor.Classes.$fOrd1Either_info;
 },
 sat_sdEHK_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdFOO,
                       label: sat_sdEHK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFOO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either_$cliftCompare_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEHJ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdFOW,
                       label: sat_sdEHJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFOW: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Either1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Either_entry() //  [R2]
         { info_tbl: [(cdFP0,
                       label: Data.Functor.Classes.$fOrd1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFP0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFP4; else goto cdFP3;
       cdFP4: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFP3: // global
           I64[Hp - 48] = sat_sdEHK_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdEHJ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.52572369 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure" {
     Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure:
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info;
 },
 Data.Functor.Classes.$fOrd2Const_$cliftCompare2_entry() //  [R2,
                                                              R4, R5]
         { info_tbl: [(cdFPp,
                       label: Data.Functor.Classes.$fOrd2Const_$cliftCompare2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFPp: // global
           R3 = R5;
           _sdEHL::P64 = R2;
           R2 = R4;
           R1 = _sdEHL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.529144603 UTC

[section ""data" . Data.Functor.Classes.$fOrd2Const_closure" {
     Data.Functor.Classes.$fOrd2Const_closure:
         const Data.Functor.Classes.C:Ord2_con_info;
         const Data.Functor.Classes.$fEq2Const_$cliftEq2_closure+4;
         const Data.Functor.Classes.$fOrd2Const_$cliftCompare2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.531258816 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const1_closure" {
     Data.Functor.Classes.$fOrd1Const1_closure:
         const Data.Functor.Classes.$fOrd1Const1_info;
 },
 Data.Functor.Classes.$fOrd1Const1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFPD,
                       label: Data.Functor.Classes.$fOrd1Const1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFPD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdFPE; else goto cdFPF;
       cdFPE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFPF: // global
           I64[Sp - 24] = block_cdFPB_info;
           R2 = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFPB() //  [R1]
         { info_tbl: [(cdFPB,
                       label: block_cdFPB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFPB: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.537713888 UTC

[section ""data" . Data.Functor.Classes.$fOrd1Const_closure" {
     Data.Functor.Classes.$fOrd1Const_closure:
         const Data.Functor.Classes.$fOrd1Const_info;
 },
 sat_sdEHZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdFQ2,
                       label: sat_sdEHZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFQ2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdFQ3; else goto cdFQ4;
       cdFQ3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFQ4: // global
           R2 = P64[R1 + 5];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdEHV_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdFQa,
                       label: sat_sdEHV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFQa: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$fOrd1Const1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fOrd1Const_entry() //  [R2]
         { info_tbl: [(cdFQe,
                       label: Data.Functor.Classes.$fOrd1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFQe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFQi; else goto cdFQh;
       cdFQi: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fOrd1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFQh: // global
           I64[Hp - 48] = sat_sdEHZ_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdEHV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 29;
           P64[Hp] = Hp - 45;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.545003715 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1(,)5_bytes" {
     Data.Functor.Classes.$fRead1(,)5_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.546891882 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)4_closure" {
     Data.Functor.Classes.$fRead1(,)4_closure:
         const Data.Functor.Classes.$fRead1(,)4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)4_entry() //  [R1]
         { info_tbl: [(cdFQI,
                       label: Data.Functor.Classes.$fRead1(,)4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFQI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFQJ; else goto cdFQK;
       cdFQJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFQK: // global
           (_cdFQF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdFQF::I64 == 0) goto cdFQH; else goto cdFQG;
       cdFQH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdFQG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdFQF::I64;
           R2 = Data.Functor.Classes.$fRead1(,)5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.55090869 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)3_closure" {
     Data.Functor.Classes.$fRead1(,)3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Functor.Classes.$fRead1(,)4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.55455542 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadPrec2_info;
         const 0;
 },
 sat_sdEIb_entry() //  [R1, R2]
         { info_tbl: [(cdFRj,
                       label: sat_sdEIb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFRn; else goto cdFRm;
       cdFRn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFRm: // global
           _sdEI6::P64 = P64[R1 + 7];
           _sdEI7::P64 = P64[R1 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sdEI7::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sdEI6::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEIc_entry() //  [R1, R2]
         { info_tbl: [(cdFRo,
                       label: sat_sdEIc_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFRs; else goto cdFRr;
       cdFRs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFRr: // global
           _sdEI1::P64 = P64[R1 + 7];
           _sdEI5::P64 = P64[R1 + 15];
           _sdEI6::P64 = P64[R1 + 23];
           _sdEI7::P64 = P64[R1 + 31];
           I64[Hp - 16] = sat_sdEIb_info;
           P64[Hp - 8] = _sdEI6::P64;
           P64[Hp] = _sdEI7::P64;
           R3 = Hp - 15;
           R2 = _sdEI5::P64;
           R1 = _sdEI1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEIf_entry() //  [R1, R2]
         { info_tbl: [(cdFRw,
                       label: sat_sdEIf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRw: // global
           _sdEI7::P64 = R2;
           _sdEIf::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdFRx; else goto cdFRy;
       cdFRy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdFRA; else goto cdFRz;
       cdFRA: // global
           HpAlloc = 40;
           goto cdFRx;
       cdFRx: // global
           R2 = _sdEI7::P64;
           R1 = _sdEIf::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFRz: // global
           _sdEI1::P64 = P64[_sdEIf::P64 + 7];
           _sdEI5::P64 = P64[_sdEIf::P64 + 15];
           _sdEI6::P64 = P64[_sdEIf::P64 + 23];
           I64[Hp - 32] = sat_sdEIc_info;
           P64[Hp - 24] = _sdEI1::P64;
           P64[Hp - 16] = _sdEI5::P64;
           P64[Hp - 8] = _sdEI6::P64;
           P64[Hp] = _sdEI7::P64;
           I64[Sp - 8] = block_cdFRt_info;
           R3 = Hp - 31;
           R2 = Data.Functor.Classes.$fRead1(,)3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFRt() //  [R1]
         { info_tbl: [(cdFRt,
                       label: block_cdFRt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFRD; else goto cdFRC;
       cdFRD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFRC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 p_sdEI4_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFRE,
                       label: p_sdEI4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFRI; else goto cdFRH;
       cdFRI: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFRH: // global
           _sdEI0::P64 = P64[R1 + 6];
           _sdEI1::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sdEIf_info;
           P64[Hp - 16] = _sdEI1::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 23;
           R2 = R2;
           R1 = _sdEI0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl3_sdEIg_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFRR,
                       label: lvl3_sdEIg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdFRS; else goto cdFRT;
       cdFRS: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFRT: // global
           I64[Sp - 8] = block_cdFRO_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wparen'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFRO() //  [R1]
         { info_tbl: [(cdFRO,
                       label: block_cdFRO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFRO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFRW; else goto cdFRV;
       cdFRW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFRV: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEIp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFS5,
                       label: sat_sdEIp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFS5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdFS6; else goto cdFS7;
       cdFS6: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFS7: // global
           I64[Sp - 8] = block_cdFS2_info;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Read.$wskipSpacesThenP_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdFS2() //  [R1]
         { info_tbl: [(cdFS2,
                       label: block_cdFS2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFS2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdFSa; else goto cdFS9;
       cdFSa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFS9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFSb,
                       label: Data.Functor.Classes.$w$cliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFSb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFSf; else goto cdFSe;
       cdFSf: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFSe: // global
           I64[Hp - 48] = p_sdEI4_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = lvl3_sdEIg_info;
           P64[Hp - 16] = Hp - 46;
           I64[Hp - 8] = sat_sdEIp_info;
           P64[Hp] = Hp - 22;
           _sdEI2::P64 = R4;
           R4 = R5;
           R3 = _sdEI2::P64;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.57764034 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)2_closure" {
     Data.Functor.Classes.$fRead1(,)2_closure:
         const Data.Functor.Classes.$fRead1(,)2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)2_entry() //  [R2, R4, R6]
         { info_tbl: [(cdFTa,
                       label: Data.Functor.Classes.$fRead1(,)2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFTa: // global
           R5 = P64[Sp];
           _sdEIs::P64 = R4;
           R4 = R6;
           R3 = _sdEIs::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.58183054 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec6_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec6_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec6_info;
         const 0;
 },
 sat_sdEIA_entry() //  [R1, R2]
         { info_tbl: [(cdFTu,
                       label: sat_sdEIA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFTu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEIz_entry() //  [R1, R2]
         { info_tbl: [(cdFTC,
                       label: sat_sdEIz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFTC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEIB_entry() //  [R1]
         { info_tbl: [(cdFTF,
                       label: sat_sdEIB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFTF: // global
           _sdEIB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFTG; else goto cdFTH;
       cdFTH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdFTJ; else goto cdFTI;
       cdFTJ: // global
           HpAlloc = 32;
           goto cdFTG;
       cdFTG: // global
           R1 = _sdEIB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFTI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEIB::P64;
           _sdEIw::P64 = P64[_sdEIB::P64 + 16];
           _sdEIx::P64 = P64[_sdEIB::P64 + 24];
           _sdEIy::P64 = P64[_sdEIB::P64 + 32];
           I64[Hp - 24] = sat_sdEIA_info;
           P64[Hp - 16] = _sdEIx::P64;
           I64[Hp - 8] = sat_sdEIz_info;
           P64[Hp] = _sdEIw::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdEIy::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec6_entry() //  [R2, R3, R4]
         { info_tbl: [(cdFTK,
                       label: Data.Functor.Classes.$w$cliftReadsPrec6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFTK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdFTO; else goto cdFTN;
       cdFTO: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFTN: // global
           I64[Hp - 32] = sat_sdEIB_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.591386935 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_entry() //  [R2,
                                                               R4, R6]
         { info_tbl: [(cdFUd,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFUd: // global
           _sdEIE::P64 = R4;
           R4 = R6;
           R3 = _sdEIE::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec6_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.595455827 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdEIN_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFUt,
                       label: sat_sdEIN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFUt: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdFUw,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFUw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFUA; else goto cdFUz;
       cdFUA: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFUz: // global
           I64[Hp - 16] = sat_sdEIN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.600900709 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)3_closure" {
     Data.Functor.Classes.$fShow1(,)3_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.602658017 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity5_closure" {
     Data.Functor.Classes.$fRead1Identity5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.604393715 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)2_closure" {
     Data.Functor.Classes.$fShow1(,)2_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.606685287 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)1_closure" {
     Data.Functor.Classes.$fShow1(,)1_closure:
         const GHC.Types.C#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.609879126 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec2_info;
 },
 f_sdEIS_entry() //  [R1]
         { info_tbl: [(cdFUV,
                       label: f_sdEIS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFUV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFUW; else goto cdFUX;
       cdFUW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFUX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdEIT_entry() //  [R1]
         { info_tbl: [(cdFV2,
                       label: f1_sdEIT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFV2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFV3; else goto cdFV4;
       cdFV3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFV4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEIW_entry() //  [R1]
         { info_tbl: [(cdFVj,
                       label: sat_sdEIW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFVj: // global
           _sdEIW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFVk; else goto cdFVl;
       cdFVl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFVn; else goto cdFVm;
       cdFVn: // global
           HpAlloc = 24;
           goto cdFVk;
       cdFVk: // global
           R1 = _sdEIW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEIW::P64;
           _sdEIT::P64 = P64[_sdEIW::P64 + 16];
           _sdEIU::P64 = P64[_sdEIW::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdEIU::P64;
           R2 = Hp - 14;
           R1 = _sdEIT::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEIY_entry() //  [R1]
         { info_tbl: [(cdFVp,
                       label: sat_sdEIY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFVp: // global
           _sdEIY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFVq; else goto cdFVr;
       cdFVr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFVt; else goto cdFVs;
       cdFVt: // global
           HpAlloc = 56;
           goto cdFVq;
       cdFVq: // global
           R1 = _sdEIY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFVs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEIY::P64;
           _sdEIS::P64 = P64[_sdEIY::P64 + 16];
           _sdEIT::P64 = P64[_sdEIY::P64 + 24];
           _sdEIU::P64 = P64[_sdEIY::P64 + 32];
           I64[Hp - 48] = sat_sdEIW_info;
           P64[Hp - 32] = _sdEIT::P64;
           P64[Hp - 24] = _sdEIU::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdEIS::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEIZ_entry() //  [R1, R2]
         { info_tbl: [(cdFVv,
                       label: sat_sdEIZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFVv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdFVz; else goto cdFVy;
       cdFVz: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFVy: // global
           _sdEIS::P64 = P64[R1 + 7];
           _sdEIT::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdEIY_info;
           P64[Hp - 40] = _sdEIS::P64;
           P64[Hp - 32] = _sdEIT::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec2_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cdFVA,
                       label: Data.Functor.Classes.$w$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFVA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdFVE; else goto cdFVD;
       cdFVE: // global
           HpAlloc = 88;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFVD: // global
           I64[Hp - 80] = f_sdEIS_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = f1_sdEIT_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdEIZ_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.624847104 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdFWu,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFWv; else goto cdFWw;
       cdFWv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdFWw: // global
           I64[Sp - 16] = block_cdFWr_info;
           R1 = P64[Sp];
           P64[Sp - 8] = R4;
           P64[Sp] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udFWA; else goto cdFWs;
       udFWA: // global
           call _cdFWr(R1) args: 0, res: 0, upd: 0;
       cdFWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFWr() //  [R1]
         { info_tbl: [(cdFWr,
                       label: block_cdFWr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFWr: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.631250502 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList2_closure" {
     Data.Functor.Classes.$dmliftShowList2_closure:
         const Data.Functor.Classes.$dmliftShowList2_info;
 },
 sat_sdEJe_entry() //  [R1]
         { info_tbl: [(cdFWT,
                       label: sat_sdEJe_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFWT: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdFWU; else goto cdFWV;
       cdFWU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFWV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = P64[R1 + 24];
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdFWW,
                       label: Data.Functor.Classes.$dmliftShowList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFWW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdFX0; else goto cdFWZ;
       cdFX0: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFWZ: // global
           I64[Hp - 48] = sat_sdEJe_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.638271679 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList3_closure" {
     Data.Functor.Classes.$w$cliftShowList3_closure:
         const Data.Functor.Classes.$w$cliftShowList3_info;
 },
 sat_sdEJp_entry() //  [R1]
         { info_tbl: [(cdFXF,
                       label: sat_sdEJp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFXF: // global
           _sdEJp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFXG; else goto cdFXH;
       cdFXH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFXJ; else goto cdFXI;
       cdFXJ: // global
           HpAlloc = 24;
           goto cdFXG;
       cdFXG: // global
           R1 = _sdEJp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFXI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEJp::P64;
           _sdEJg::P64 = P64[_sdEJp::P64 + 16];
           _sdEJk::P64 = P64[_sdEJp::P64 + 24];
           _sdEJn::P64 = P64[_sdEJp::P64 + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)1_closure+1;
           P64[Hp] = _sdEJk::P64;
           R4 = Hp - 14;
           R3 = _sdEJn::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdEJg::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEJr_entry() //  [R1]
         { info_tbl: [(cdFXL,
                       label: sat_sdEJr_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFXL: // global
           _sdEJr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdFXM; else goto cdFXN;
       cdFXN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdFXP; else goto cdFXO;
       cdFXP: // global
           HpAlloc = 64;
           goto cdFXM;
       cdFXM: // global
           R1 = _sdEJr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFXO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEJr::P64;
           _sdEJf::P64 = P64[_sdEJr::P64 + 16];
           _sdEJg::P64 = P64[_sdEJr::P64 + 24];
           _sdEJk::P64 = P64[_sdEJr::P64 + 32];
           _sdEJm::P64 = P64[_sdEJr::P64 + 40];
           _sdEJn::P64 = P64[_sdEJr::P64 + 48];
           I64[Hp - 56] = sat_sdEJp_info;
           P64[Hp - 40] = _sdEJg::P64;
           P64[Hp - 32] = _sdEJk::P64;
           P64[Hp - 24] = _sdEJn::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)2_closure+1;
           P64[Hp] = Hp - 56;
           R4 = Hp - 14;
           R3 = _sdEJm::P64;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = _sdEJf::P64;
           Sp = Sp - 16;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEJs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFXQ,
                       label: sat_sdEJs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFXQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdFXS; else goto cdFXT;
       cdFXS: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFXT: // global
           I64[Sp - 32] = block_cdFXr_info;
           _sdEJf::P64 = P64[R1 + 6];
           _sdEJg::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sdEJf::P64;
           P64[Sp - 16] = _sdEJg::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udFXX; else goto cdFXs;
       udFXX: // global
           call _cdFXr(R1) args: 0, res: 0, upd: 0;
       cdFXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFXr() //  [R1]
         { info_tbl: [(cdFXr,
                       label: block_cdFXr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFXr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdFXW; else goto cdFXV;
       cdFXW: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFXV: // global
           _sdEJm::P64 = P64[R1 + 7];
           _sdEJn::P64 = P64[R1 + 15];
           I64[Hp - 72] = sat_sdEJr_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sdEJm::P64;
           P64[Hp - 24] = _sdEJn::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.$fShow1(,)3_closure+1;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdFXY,
                       label: Data.Functor.Classes.$w$cliftShowList3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFXY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFY2; else goto cdFY1;
       cdFY2: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFY1: // global
           I64[Hp - 16] = sat_sdEJs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdEJh::P64 = R4;
           R4 = R5;
           R3 = _sdEJh::P64;
           R2 = Hp - 14;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.652685552 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info;
 },
 Data.Functor.Classes.$fShow2(,)_$cliftShowList2_entry() //  [R2,
                                                              R4, R6]
         { info_tbl: [(cdFYJ,
                       label: Data.Functor.Classes.$fShow2(,)_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFYJ: // global
           R5 = P64[Sp];
           _sdEJv::P64 = R4;
           R4 = R6;
           R3 = _sdEJv::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.656158996 UTC

[section ""data" . Data.Functor.Classes.$fShow2(,)_closure" {
     Data.Functor.Classes.$fShow2(,)_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2(,)_$cliftShowList2_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.658809565 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info;
 },
 sat_sdEJH_entry() //  [R1]
         { info_tbl: [(cdFZ4,
                       label: sat_sdEJH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFZ4: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cdFZ7,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFZ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdFZ8; else goto cdFZ9;
       cdFZ8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdFZ9: // global
           I64[Sp - 24] = block_cdFYV_info;
           R1 = R6;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udFZd; else goto cdFYW;
       udFZd: // global
           call _cdFYV(R1) args: 0, res: 0, upd: 0;
       cdFYW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdFYV() //  [R1]
         { info_tbl: [(cdFYV,
                       label: block_cdFYV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFYV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdFZc; else goto cdFZb;
       cdFZc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdFZb: // global
           _sdEJF::P64 = P64[R1 + 7];
           _sdEJG::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdEJH_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdEJG::P64;
           R4 = _sdEJF::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.667490832 UTC

[section ""data" . $w$dmliftReadListPrec2_rdymu_closure" {
     $w$dmliftReadListPrec2_rdymu_closure:
         const $w$dmliftReadListPrec2_rdymu_info;
 },
 sat_sdEJS_entry() //  [R1]
         { info_tbl: [(cdFZF,
                       label: sat_sdEJS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdFZG; else goto cdFZH;
       cdFZG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdFZH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEJT_entry() //  [R1, R2]
         { info_tbl: [(cdFZN,
                       label: sat_sdEJT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFZN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEJR_entry() //  [R1, R2]
         { info_tbl: [(cdFZV,
                       label: sat_sdEJR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFZV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEJP_entry() //  [R1]
         { info_tbl: [(cdG02,
                       label: sat_sdEJP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG02: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG03; else goto cdG04;
       cdG03: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG04: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEJQ_entry() //  [R1, R2]
         { info_tbl: [(cdG0a,
                       label: sat_sdEJQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG0a: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEJO_entry() //  [R1, R2]
         { info_tbl: [(cdG0i,
                       label: sat_sdEJO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG0i: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w5_sdEJN_entry() //  [R1]
         { info_tbl: [(cdG0l,
                       label: w5_sdEJN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG0l: // global
           _sdEJN::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdG0m; else goto cdG0n;
       cdG0n: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdG0p; else goto cdG0o;
       cdG0p: // global
           HpAlloc = 112;
           goto cdG0m;
       cdG0m: // global
           R1 = _sdEJN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG0o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEJN::P64;
           _sdEJI::P64 = P64[_sdEJN::P64 + 16];
           _sdEJJ::P64 = P64[_sdEJN::P64 + 24];
           _sdEJK::P64 = P64[_sdEJN::P64 + 32];
           _sdEJL::P64 = P64[_sdEJN::P64 + 40];
           _sdEJM::P64 = P64[_sdEJN::P64 + 48];
           I64[Hp - 104] = sat_sdEJS_info;
           P64[Hp - 88] = _sdEJM::P64;
           I64[Hp - 80] = sat_sdEJT_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdEJR_info;
           P64[Hp - 56] = _sdEJL::P64;
           I64[Hp - 48] = sat_sdEJP_info;
           P64[Hp - 32] = _sdEJK::P64;
           I64[Hp - 24] = sat_sdEJQ_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdEJO_info;
           P64[Hp] = _sdEJJ::P64;
           R2 = _sdEJI::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadList2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdEJX_entry() //  [R1, R2]
         { info_tbl: [(cdG0y,
                       label: sat_sdEJX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG0y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdG0z; else goto cdG0A;
       cdG0z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdG0A: // global
           I64[Sp - 8] = block_cdG0v_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdG0v() //  [R1]
         { info_tbl: [(cdG0v,
                       label: block_cdG0v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG0v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdG0D; else goto cdG0C;
       cdG0D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdG0C: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec2_rdymu_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdG0E,
                       label: $w$dmliftReadListPrec2_rdymu_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG0E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdG0I; else goto cdG0H;
       cdG0I: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec2_rdymu_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG0H: // global
           I64[Hp - 64] = w5_sdEJN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdEJX_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.688835904 UTC

[section ""data" . $dmliftReadListPrec1_rdymv_closure" {
     $dmliftReadListPrec1_rdymv_closure:
         const $dmliftReadListPrec1_rdymv_info;
 },
 $dmliftReadListPrec1_rdymv_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdG1L,
                       label: $dmliftReadListPrec1_rdymv_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG1L: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call $w$dmliftReadListPrec2_rdymu_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.692444299 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec2_closure" {
     Data.Functor.Classes.$dmliftReadListPrec2_closure:
         const Data.Functor.Classes.$dmliftReadListPrec2_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec2_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdG1W,
                       label: Data.Functor.Classes.$dmliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG1W: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec1_rdymv_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.697349742 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec2_closure" {
     Data.Functor.Classes.$dmliftReadPrec2_closure:
         const Data.Functor.Classes.$dmliftReadPrec2_info;
 },
 sat_sdEKe_entry() //  [R1]
         { info_tbl: [(cdG2f,
                       label: sat_sdEKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG2g; else goto cdG2h;
       cdG2g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG2h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEKf_entry() //  [R1, R2]
         { info_tbl: [(cdG2n,
                       label: sat_sdEKf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2n: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKd_entry() //  [R1, R2]
         { info_tbl: [(cdG2v,
                       label: sat_sdEKd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2v: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKb_entry() //  [R1]
         { info_tbl: [(cdG2C,
                       label: sat_sdEKb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG2D; else goto cdG2E;
       cdG2D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG2E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEKc_entry() //  [R1, R2]
         { info_tbl: [(cdG2K,
                       label: sat_sdEKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2K: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKa_entry() //  [R1, R2]
         { info_tbl: [(cdG2S,
                       label: sat_sdEKa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2S: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdEK9_entry() //  [R1]
         { info_tbl: [(cdG2V,
                       label: f1_sdEK9_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2V: // global
           _sdEK9::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdG2W; else goto cdG2X;
       cdG2X: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdG2Z; else goto cdG2Y;
       cdG2Z: // global
           HpAlloc = 112;
           goto cdG2W;
       cdG2W: // global
           R1 = _sdEK9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG2Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEK9::P64;
           _sdEK4::P64 = P64[_sdEK9::P64 + 16];
           _sdEK5::P64 = P64[_sdEK9::P64 + 24];
           _sdEK6::P64 = P64[_sdEK9::P64 + 32];
           _sdEK7::P64 = P64[_sdEK9::P64 + 40];
           _sdEK8::P64 = P64[_sdEK9::P64 + 48];
           I64[Hp - 104] = sat_sdEKe_info;
           P64[Hp - 88] = _sdEK8::P64;
           I64[Hp - 80] = sat_sdEKf_info;
           P64[Hp - 72] = Hp - 104;
           I64[Hp - 64] = sat_sdEKd_info;
           P64[Hp - 56] = _sdEK7::P64;
           I64[Hp - 48] = sat_sdEKb_info;
           P64[Hp - 32] = _sdEK6::P64;
           I64[Hp - 24] = sat_sdEKc_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdEKa_info;
           P64[Hp] = _sdEK5::P64;
           R2 = _sdEK4::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 23;
           P64[Sp - 32] = Hp - 63;
           P64[Sp - 24] = Hp - 79;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdEKl_entry() //  [R1, R2]
         { info_tbl: [(cdG3e,
                       label: sat_sdEKl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG3e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdG3f; else goto cdG3g;
       cdG3f: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdG3g: // global
           I64[Sp - 8] = block_cdG3b_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdG3b() //  [R1]
         { info_tbl: [(cdG3b,
                       label: block_cdG3b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG3b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdG3j; else goto cdG3i;
       cdG3j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdG3i: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKm_entry() //  [R1, R2]
         { info_tbl: [(cdG3k,
                       label: sat_sdEKm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG3k: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdG3o; else goto cdG3n;
       cdG3o: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdG3n: // global
           _sdEK9::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdEK9::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdEKl_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdG3p,
                       label: Data.Functor.Classes.$dmliftReadPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG3p: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdG3t; else goto cdG3s;
       cdG3t: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG3s: // global
           I64[Hp - 64] = f1_sdEK9_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdEKm_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.721471919 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList2_closure" {
     Data.Functor.Classes.$dmliftReadList2_closure:
         const Data.Functor.Classes.$dmliftReadList2_info;
         const 0;
 },
 sat_sdEKD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdG4T,
                       label: sat_sdEKD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdG4U; else goto cdG4V;
       cdG4U: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG4V: // global
           I64[Sp - 8] = block_cdG4Q_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdG4Q() //  [R1]
         { info_tbl: [(cdG4Q,
                       label: block_cdG4Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG4Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdG4Y; else goto cdG4X;
       cdG4Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdG4X: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKy_entry() //  [R1, R2]
         { info_tbl: [(cdG54,
                       label: sat_sdEKy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG54: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKx_entry() //  [R1, R2, R3]
         { info_tbl: [(cdG5f,
                       label: sat_sdEKx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdG5g; else goto cdG5h;
       cdG5g: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG5h: // global
           I64[Sp - 8] = block_cdG5c_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdG5c() //  [R1]
         { info_tbl: [(cdG5c,
                       label: block_cdG5c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdG5k; else goto cdG5j;
       cdG5k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdG5j: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKs_entry() //  [R1, R2]
         { info_tbl: [(cdG5q,
                       label: sat_sdEKs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5q: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKE_entry() //  [R1]
         { info_tbl: [(cdG5t,
                       label: sat_sdEKE_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5t: // global
           _sdEKE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdG5u; else goto cdG5v;
       cdG5v: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdG5x; else goto cdG5w;
       cdG5x: // global
           HpAlloc = 64;
           goto cdG5u;
       cdG5u: // global
           R1 = _sdEKE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG5w: // global
           _sdEKn::P64 = P64[_sdEKE::P64 + 16];
           _sdEKo::P64 = P64[_sdEKE::P64 + 24];
           _sdEKp::P64 = P64[_sdEKE::P64 + 32];
           _sdEKq::P64 = P64[_sdEKE::P64 + 40];
           _sdEKr::P64 = P64[_sdEKE::P64 + 48];
           I64[Hp - 56] = sat_sdEKD_info;
           P64[Hp - 48] = _sdEKr::P64;
           I64[Hp - 40] = sat_sdEKy_info;
           P64[Hp - 32] = _sdEKq::P64;
           I64[Hp - 24] = sat_sdEKx_info;
           P64[Hp - 16] = _sdEKp::P64;
           I64[Hp - 8] = sat_sdEKs_info;
           P64[Hp] = _sdEKo::P64;
           R2 = _sdEKn::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 54;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 sat_sdEKF_entry() //  [R1]
         { info_tbl: [(cdG5y,
                       label: sat_sdEKF_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5y: // global
           _sdEKF::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdG5z; else goto cdG5A;
       cdG5A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdG5C; else goto cdG5B;
       cdG5C: // global
           HpAlloc = 56;
           goto cdG5z;
       cdG5z: // global
           R1 = _sdEKF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEKF::P64;
           _sdEKn::P64 = P64[_sdEKF::P64 + 16];
           _sdEKo::P64 = P64[_sdEKF::P64 + 24];
           _sdEKp::P64 = P64[_sdEKF::P64 + 32];
           _sdEKq::P64 = P64[_sdEKF::P64 + 40];
           _sdEKr::P64 = P64[_sdEKF::P64 + 48];
           I64[Hp - 48] = sat_sdEKE_info;
           P64[Hp - 32] = _sdEKn::P64;
           P64[Hp - 24] = _sdEKo::P64;
           P64[Hp - 16] = _sdEKp::P64;
           P64[Hp - 8] = _sdEKq::P64;
           P64[Hp] = _sdEKr::P64;
           R2 = Hp - 48;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList2_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdG5D,
                       label: Data.Functor.Classes.$dmliftReadList2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5D: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdG5H; else goto cdG5G;
       cdG5H: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG5G: // global
           I64[Hp - 48] = sat_sdEKF_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.743957351 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec2_closure" {
     Data.Functor.Classes.$dmliftReadsPrec2_closure:
         const Data.Functor.Classes.$dmliftReadsPrec2_info;
 },
 sat_sdEKX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdG6R,
                       label: sat_sdEKX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG6R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdG6S; else goto cdG6T;
       cdG6S: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG6T: // global
           I64[Sp - 8] = block_cdG6O_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdG6O() //  [R1]
         { info_tbl: [(cdG6O,
                       label: block_cdG6O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG6O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdG6W; else goto cdG6V;
       cdG6W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdG6V: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKS_entry() //  [R1, R2]
         { info_tbl: [(cdG72,
                       label: sat_sdEKS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG72: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKR_entry() //  [R1, R2, R3]
         { info_tbl: [(cdG7d,
                       label: sat_sdEKR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdG7e; else goto cdG7f;
       cdG7e: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG7f: // global
           I64[Sp - 8] = block_cdG7a_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdG7a() //  [R1]
         { info_tbl: [(cdG7a,
                       label: block_cdG7a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdG7i; else goto cdG7h;
       cdG7i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdG7h: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEKM_entry() //  [R1, R2]
         { info_tbl: [(cdG7o,
                       label: sat_sdEKM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7o: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdEKL_entry() //  [R1]
         { info_tbl: [(cdG7r,
                       label: ds_sdEKL_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7r: // global
           _sdEKL::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdG7s; else goto cdG7t;
       cdG7t: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdG7v; else goto cdG7u;
       cdG7v: // global
           HpAlloc = 64;
           goto cdG7s;
       cdG7s: // global
           R1 = _sdEKL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG7u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEKL::P64;
           _sdEKG::P64 = P64[_sdEKL::P64 + 16];
           _sdEKH::P64 = P64[_sdEKL::P64 + 24];
           _sdEKI::P64 = P64[_sdEKL::P64 + 32];
           _sdEKJ::P64 = P64[_sdEKL::P64 + 40];
           _sdEKK::P64 = P64[_sdEKL::P64 + 48];
           I64[Hp - 56] = sat_sdEKX_info;
           P64[Hp - 48] = _sdEKK::P64;
           I64[Hp - 40] = sat_sdEKS_info;
           P64[Hp - 32] = _sdEKJ::P64;
           I64[Hp - 24] = sat_sdEKR_info;
           P64[Hp - 16] = _sdEKI::P64;
           I64[Hp - 8] = sat_sdEKM_info;
           P64[Hp] = _sdEKH::P64;
           R2 = _sdEKG::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Hp - 39;
           P64[Sp - 24] = Hp - 54;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdEKZ_entry() //  [R1]
         { info_tbl: [(cdG7F,
                       label: sat_sdEKZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG7G; else goto cdG7H;
       cdG7G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG7H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEL0_entry() //  [R1, R2]
         { info_tbl: [(cdG7I,
                       label: sat_sdEL0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdG7M; else goto cdG7L;
       cdG7M: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdG7L: // global
           _sdEKL::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdEKZ_info;
           P64[Hp - 8] = _sdEKL::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdG7N,
                       label: Data.Functor.Classes.$dmliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG7N: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdG7R; else goto cdG7Q;
       cdG7R: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG7Q: // global
           I64[Hp - 64] = ds_sdEKL_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = sat_sdEL0_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.765441831 UTC

[section ""data" . Data.Functor.Classes.$dmliftShowList_closure" {
     Data.Functor.Classes.$dmliftShowList_closure:
         const Data.Functor.Classes.$dmliftShowList_info;
 },
 sat_sdEL4_entry() //  [R1]
         { info_tbl: [(cdG8X,
                       label: sat_sdEL4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG8X: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdG8Y; else goto cdG8Z;
       cdG8Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG8Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           Sp = Sp - 48;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftShowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdG90,
                       label: Data.Functor.Classes.$dmliftShowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG90: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdG94; else goto cdG93;
       cdG94: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftShowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG93: // global
           I64[Hp - 32] = sat_sdEL4_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Show.showList___closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.772999424 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList_closure" {
     Data.Functor.Classes.$w$cliftShowList_closure:
         const Data.Functor.Classes.$w$cliftShowList_info;
 },
 lvl3_sdEL9_entry() //  [R1]
         { info_tbl: [(cdG9s,
                       label: lvl3_sdEL9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG9s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG9t; else goto cdG9u;
       cdG9t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG9u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdELe_entry() //  [R1, R2]
         { info_tbl: [(cdG9D,
                       label: sat_sdELe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG9D: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdG9E; else goto cdG9F;
       cdG9E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdG9F: // global
           I64[Sp - 24] = block_cdG9A_info;
           _sdEL6::P64 = P64[R1 + 7];
           _sdEL9::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdEL6::P64;
           P64[Sp - 8] = _sdEL9::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udG9J; else goto cdG9B;
       udG9J: // global
           call _cdG9A(R1) args: 0, res: 0, upd: 0;
       cdG9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdG9A() //  [R1]
         { info_tbl: [(cdG9A,
                       label: block_cdG9A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG9A: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec2_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdG9K,
                       label: Data.Functor.Classes.$w$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG9K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdG9O; else goto cdG9N;
       cdG9O: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG9N: // global
           I64[Hp - 40] = lvl3_sdEL9_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdELe_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdEL7::P64 = R4;
           R4 = R5;
           R3 = _sdEL7::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.782516485 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1(,)_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1(,)_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1(,)_$cliftShowList_entry() //  [R2, R3,
                                                             R5, R6]
         { info_tbl: [(cdGae,
                       label: Data.Functor.Classes.$fShow1(,)_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGae: // global
           _sdELi::P64 = R5;
           R5 = R6;
           R4 = _sdELi::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.786806564 UTC

[section ""data" . Data.Functor.Classes.$fShow1(,)_closure" {
     Data.Functor.Classes.$fShow1(,)_closure:
         const Data.Functor.Classes.$fShow1(,)_info;
 },
 sat_sdELq_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdGau,
                       label: sat_sdELq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGau: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdELl_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdGaC,
                       label: sat_sdELl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGaC: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1(,)_entry() //  [R2]
         { info_tbl: [(cdGaG,
                       label: Data.Functor.Classes.$fShow1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGaG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGaK; else goto cdGaJ;
       cdGaK: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGaJ: // global
           I64[Hp - 48] = sat_sdELq_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdELl_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.794181948 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy1_closure" {
     Data.Functor.Classes.$fShow1Proxy1_closure:
         const Data.Functor.Classes.$fShow1Proxy1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy1_entry() //  [R3]
         { info_tbl: [(cdGb5,
                       label: Data.Functor.Classes.$fShow1Proxy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGb5: // global
           R2 = R3;
           call Data.Functor.Classes.$fShow1Proxy2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.797627816 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Proxy_$cliftShowList_entry() //  [R4,
                                                               R5]
         { info_tbl: [(cdGbg,
                       label: Data.Functor.Classes.$fShow1Proxy_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGbg: // global
           _sdELu::P64 = R4;
           R4 = R5;
           R3 = _sdELu::P64;
           R2 = Data.Functor.Classes.$fShow1Proxy1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.80103045 UTC

[section ""data" . Data.Functor.Classes.$fShow1Proxy_closure" {
     Data.Functor.Classes.$fShow1Proxy_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec_closure+5;
         const Data.Functor.Classes.$fShow1Proxy_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.803746111 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info;
 },
 sat_sdELE_entry() //  [R1, R2]
         { info_tbl: [(cdGbA,
                       label: sat_sdELE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGbA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdGbB; else goto cdGbC;
       cdGbB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGbC: // global
           I64[Sp - 24] = block_cdGbx_info;
           _sdELw::P64 = P64[R1 + 7];
           _sdELx::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdELw::P64;
           P64[Sp - 8] = _sdELx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udGbG; else goto cdGby;
       udGbG: // global
           call _cdGbx(R1) args: 0, res: 0, upd: 0;
       cdGby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGbx() //  [R1]
         { info_tbl: [(cdGbx,
                       label: block_cdGbx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGbx: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$w$cliftShowsPrec1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdGbH,
                       label: Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGbH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGbL; else goto cdGbK;
       cdGbL: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGbK: // global
           I64[Hp - 16] = sat_sdELE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdELy::P64 = R4;
           R4 = R5;
           R3 = _sdELy::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.812083124 UTC

[section ""data" . Data.Functor.Classes.$fShow1NonEmpty_closure" {
     Data.Functor.Classes.$fShow1NonEmpty_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.814502624 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1[]_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_info;
 },
 Data.Functor.Classes.$fShow1[]_$cliftShowList_entry() //  [R3, R4,
                                                            R5]
         { info_tbl: [(cdGc5,
                       label: Data.Functor.Classes.$fShow1[]_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGc5: // global
           _B2::P64 = R4;
           R4 = R5;
           _sdELG::P64 = R3;
           R3 = _B2::P64;
           R2 = _sdELG::P64;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.818111951 UTC

[section ""data" . Data.Functor.Classes.$fShow1[]_closure" {
     Data.Functor.Classes.$fShow1[]_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1[]_$cliftShowsPrec_closure+3;
         const Data.Functor.Classes.$fShow1[]_$cliftShowList_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.820919302 UTC

[section ""data" . $w$dmliftReadListPrec_rdymw_closure" {
     $w$dmliftReadListPrec_rdymw_closure:
         const $w$dmliftReadListPrec_rdymw_info;
 },
 sat_sdELM_entry() //  [R1]
         { info_tbl: [(cdGcp,
                       label: sat_sdELM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGcq; else goto cdGcr;
       cdGcq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGcr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdELN_entry() //  [R1, R2]
         { info_tbl: [(cdGcx,
                       label: sat_sdELN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGcx: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdELL_entry() //  [R1, R2]
         { info_tbl: [(cdGcF,
                       label: sat_sdELL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGcF: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w3_sdELK_entry() //  [R1]
         { info_tbl: [(cdGcI,
                       label: w3_sdELK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGcI: // global
           _sdELK::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGcJ; else goto cdGcK;
       cdGcK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGcM; else goto cdGcL;
       cdGcM: // global
           HpAlloc = 56;
           goto cdGcJ;
       cdGcJ: // global
           R1 = _sdELK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGcL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdELK::P64;
           _sdELH::P64 = P64[_sdELK::P64 + 16];
           _sdELI::P64 = P64[_sdELK::P64 + 24];
           _sdELJ::P64 = P64[_sdELK::P64 + 32];
           I64[Hp - 48] = sat_sdELM_info;
           P64[Hp - 32] = _sdELJ::P64;
           I64[Hp - 24] = sat_sdELN_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdELL_info;
           P64[Hp] = _sdELI::P64;
           R2 = _sdELH::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdELR_entry() //  [R1, R2]
         { info_tbl: [(cdGcV,
                       label: sat_sdELR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGcV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGcW; else goto cdGcX;
       cdGcW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGcX: // global
           I64[Sp - 8] = block_cdGcS_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGcS() //  [R1]
         { info_tbl: [(cdGcS,
                       label: block_cdGcS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGcS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGd0; else goto cdGcZ;
       cdGd0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGcZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $w$dmliftReadListPrec_rdymw_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGd1,
                       label: $w$dmliftReadListPrec_rdymw_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGd1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGd5; else goto cdGd4;
       cdGd5: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $w$dmliftReadListPrec_rdymw_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGd4: // global
           I64[Hp - 48] = w3_sdELK_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdELR_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.836637228 UTC

[section ""data" . $dmliftReadListPrec3_rdymx_closure" {
     $dmliftReadListPrec3_rdymx_closure:
         const $dmliftReadListPrec3_rdymx_info;
 },
 $dmliftReadListPrec3_rdymx_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGdQ,
                       label: $dmliftReadListPrec3_rdymx_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGdQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $w$dmliftReadListPrec_rdymw_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.840370528 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadListPrec_closure" {
     Data.Functor.Classes.$dmliftReadListPrec_closure:
         const Data.Functor.Classes.$dmliftReadListPrec_info;
 },
 Data.Functor.Classes.$dmliftReadListPrec_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(cdGe1,
                       label: Data.Functor.Classes.$dmliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGe1: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $dmliftReadListPrec3_rdymx_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.845626376 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadPrec_closure" {
     Data.Functor.Classes.$dmliftReadPrec_closure:
         const Data.Functor.Classes.$dmliftReadPrec_info;
 },
 sat_sdEM1_entry() //  [R1]
         { info_tbl: [(cdGek,
                       label: sat_sdEM1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGel; else goto cdGem;
       cdGel: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGem: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEM2_entry() //  [R1, R2]
         { info_tbl: [(cdGes,
                       label: sat_sdEM2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGes: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEM0_entry() //  [R1, R2]
         { info_tbl: [(cdGeA,
                       label: sat_sdEM0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGeA: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdELZ_entry() //  [R1]
         { info_tbl: [(cdGeD,
                       label: f1_sdELZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGeD: // global
           _sdELZ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGeE; else goto cdGeF;
       cdGeF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGeH; else goto cdGeG;
       cdGeH: // global
           HpAlloc = 56;
           goto cdGeE;
       cdGeE: // global
           R1 = _sdELZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGeG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdELZ::P64;
           _sdELW::P64 = P64[_sdELZ::P64 + 16];
           _sdELX::P64 = P64[_sdELZ::P64 + 24];
           _sdELY::P64 = P64[_sdELZ::P64 + 32];
           I64[Hp - 48] = sat_sdEM1_info;
           P64[Hp - 32] = _sdELY::P64;
           I64[Hp - 24] = sat_sdEM2_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdEM0_info;
           P64[Hp] = _sdELX::P64;
           R2 = _sdELW::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 23;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdEM8_entry() //  [R1, R2]
         { info_tbl: [(cdGeW,
                       label: sat_sdEM8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGeW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGeX; else goto cdGeY;
       cdGeX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGeY: // global
           I64[Sp - 8] = block_cdGeT_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGeT() //  [R1]
         { info_tbl: [(cdGeT,
                       label: block_cdGeT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGeT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGf1; else goto cdGf0;
       cdGf1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGf0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEM9_entry() //  [R1, R2]
         { info_tbl: [(cdGf2,
                       label: sat_sdEM9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGf2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGf6; else goto cdGf5;
       cdGf6: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGf5: // global
           _sdELZ::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = _sdELZ::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdEM8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGf7,
                       label: Data.Functor.Classes.$dmliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGf7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGfb; else goto cdGfa;
       cdGfb: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGfa: // global
           I64[Hp - 48] = f1_sdELZ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdEM9_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.864062874 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadList_closure" {
     Data.Functor.Classes.$dmliftReadList_closure:
         const Data.Functor.Classes.$dmliftReadList_info;
         const 0;
 },
 sat_sdEMi_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGgj,
                       label: sat_sdEMi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGgj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGgk; else goto cdGgl;
       cdGgk: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGgl: // global
           I64[Sp - 8] = block_cdGgg_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGgg() //  [R1]
         { info_tbl: [(cdGgg,
                       label: block_cdGgg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGgg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGgo; else goto cdGgn;
       cdGgo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGgn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMd_entry() //  [R1, R2]
         { info_tbl: [(cdGgu,
                       label: sat_sdEMd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGgu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMj_entry() //  [R1]
         { info_tbl: [(cdGgx,
                       label: sat_sdEMj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGgx: // global
           _sdEMj::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdGgy; else goto cdGgz;
       cdGgz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGgB; else goto cdGgA;
       cdGgB: // global
           HpAlloc = 32;
           goto cdGgy;
       cdGgy: // global
           R1 = _sdEMj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGgA: // global
           _sdEMa::P64 = P64[_sdEMj::P64 + 16];
           _sdEMb::P64 = P64[_sdEMj::P64 + 24];
           _sdEMc::P64 = P64[_sdEMj::P64 + 32];
           I64[Hp - 24] = sat_sdEMi_info;
           P64[Hp - 16] = _sdEMc::P64;
           I64[Hp - 8] = sat_sdEMd_info;
           P64[Hp] = _sdEMb::P64;
           R2 = _sdEMa::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdEMk_entry() //  [R1]
         { info_tbl: [(cdGgC,
                       label: sat_sdEMk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGgC: // global
           _sdEMk::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGgD; else goto cdGgE;
       cdGgE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGgG; else goto cdGgF;
       cdGgG: // global
           HpAlloc = 40;
           goto cdGgD;
       cdGgD: // global
           R1 = _sdEMk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEMk::P64;
           _sdEMa::P64 = P64[_sdEMk::P64 + 16];
           _sdEMb::P64 = P64[_sdEMk::P64 + 24];
           _sdEMc::P64 = P64[_sdEMk::P64 + 32];
           I64[Hp - 32] = sat_sdEMj_info;
           P64[Hp - 16] = _sdEMa::P64;
           P64[Hp - 8] = _sdEMb::P64;
           P64[Hp] = _sdEMc::P64;
           R2 = Hp - 32;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$dmliftReadList_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGgH,
                       label: Data.Functor.Classes.$dmliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGgH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGgL; else goto cdGgK;
       cdGgL: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGgK: // global
           I64[Hp - 32] = sat_sdEMk_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.879417514 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info;
         const 0;
 },
 f_sdEMn_entry() //  [R1, R2]
         { info_tbl: [(cdGhx,
                       label: f_sdEMn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGhx: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdEMo_entry() //  [R1]
         { info_tbl: [(cdGhE,
                       label: f1_sdEMo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGhE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGhF; else goto cdGhG;
       cdGhF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGhG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdEMp_entry() //  [R1, R2]
         { info_tbl: [(cdGhM,
                       label: f2_sdEMp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGhM: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMv_entry() //  [R1, R2]
         { info_tbl: [(cdGi2,
                       label: sat_sdEMv_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGi2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdGi3; else goto cdGi4;
       cdGi3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGi4: // global
           I64[Sp - 32] = block_cdGhZ_info;
           _sdEMn::P64 = P64[R1 + 7];
           _sdEMp::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdEMn::P64;
           P64[Sp - 16] = _sdEMp::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udGi8; else goto cdGi0;
       udGi8: // global
           call _cdGhZ(R1) args: 0, res: 0, upd: 0;
       cdGi0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGhZ() //  [R1]
         { info_tbl: [(cdGhZ,
                       label: block_cdGhZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGhZ: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMy_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGic,
                       label: sat_sdEMy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGic: // global
           _sdEMr::P64 = R3;
           _sdEMq::P64 = R2;
           _sdEMy::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdGid; else goto cdGie;
       cdGie: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGig; else goto cdGif;
       cdGig: // global
           HpAlloc = 32;
           goto cdGid;
       cdGid: // global
           R3 = _sdEMr::P64;
           R2 = _sdEMq::P64;
           R1 = _sdEMy::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGif: // global
           _sdEMn::P64 = P64[_sdEMy::P64 + 6];
           _sdEMp::P64 = P64[_sdEMy::P64 + 14];
           I64[Hp - 24] = sat_sdEMv_info;
           P64[Hp - 16] = _sdEMn::P64;
           P64[Hp - 8] = _sdEMp::P64;
           P64[Hp] = _sdEMq::P64;
           I64[Sp - 8] = block_cdGi9_info;
           R3 = _sdEMr::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGi9() //  [R1]
         { info_tbl: [(cdGi9,
                       label: block_cdGi9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGi9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGij; else goto cdGii;
       cdGij: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGii: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdGik,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGik: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdGio; else goto cdGin;
       cdGio: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGin: // global
           I64[Hp - 72] = f_sdEMn_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = f1_sdEMo_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = f2_sdEMp_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdEMy_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.899357162 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info;
         const 0;
 },
 sat_sdEMG_entry() //  [R1]
         { info_tbl: [(cdGjs,
                       label: sat_sdEMG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGjs: // global
           _sdEMG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdGjt; else goto cdGju;
       cdGju: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGjw; else goto cdGjv;
       cdGjw: // global
           HpAlloc = 32;
           goto cdGjt;
       cdGjt: // global
           R1 = _sdEMG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGjv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEMG::P64;
           _sdEMz::P64 = P64[_sdEMG::P64 + 16];
           _sdEMC::P64 = P64[_sdEMG::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdEMz::P64;
           P64[Hp] = _sdEMC::P64;
           I64[Sp - 24] = block_cdGjp_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdGjp() //  [R1]
         { info_tbl: [(cdGjp,
                       label: block_cdGjp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGjp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGjz; else goto cdGjy;
       cdGjz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdGjy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f_sdEMB_entry() //  [R1, R2]
         { info_tbl: [(cdGjA,
                       label: f_sdEMB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGjA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGjE; else goto cdGjD;
       cdGjE: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGjD: // global
           _sdEMz::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdEMG_info;
           P64[Hp - 8] = _sdEMz::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 f1_sdEMH_entry() //  [R1]
         { info_tbl: [(cdGjM,
                       label: f1_sdEMH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGjM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdGjN; else goto cdGjO;
       cdGjN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGjO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdGjJ_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdGjJ() //  [R1]
         { info_tbl: [(cdGjJ,
                       label: block_cdGjJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGjJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGjR; else goto cdGjQ;
       cdGjR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdGjQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 f2_sdEMK_entry() //  [R1, R2]
         { info_tbl: [(cdGjX,
                       label: f2_sdEMK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGjX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMQ_entry() //  [R1, R2]
         { info_tbl: [(cdGkd,
                       label: sat_sdEMQ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGkd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdGke; else goto cdGkf;
       cdGke: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGkf: // global
           I64[Sp - 32] = block_cdGka_info;
           _sdEMB::P64 = P64[R1 + 7];
           _sdEMK::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 24] = _sdEMB::P64;
           P64[Sp - 16] = _sdEMK::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udGkj; else goto cdGkb;
       udGkj: // global
           call _cdGka(R1) args: 0, res: 0, upd: 0;
       cdGkb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGka() //  [R1]
         { info_tbl: [(cdGka,
                       label: block_cdGka_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGka: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftReadsPrec5_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMT_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGkn,
                       label: sat_sdEMT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGkn: // global
           _sdEMM::P64 = R3;
           _sdEML::P64 = R2;
           _sdEMT::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdGko; else goto cdGkp;
       cdGkp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGkr; else goto cdGkq;
       cdGkr: // global
           HpAlloc = 32;
           goto cdGko;
       cdGko: // global
           R3 = _sdEMM::P64;
           R2 = _sdEML::P64;
           R1 = _sdEMT::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGkq: // global
           _sdEMB::P64 = P64[_sdEMT::P64 + 6];
           _sdEMK::P64 = P64[_sdEMT::P64 + 14];
           I64[Hp - 24] = sat_sdEMQ_info;
           P64[Hp - 16] = _sdEMB::P64;
           P64[Hp - 8] = _sdEMK::P64;
           P64[Hp] = _sdEML::P64;
           I64[Sp - 8] = block_cdGkk_info;
           R3 = _sdEMM::P64;
           R2 = Hp - 23;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGkk() //  [R1]
         { info_tbl: [(cdGkk,
                       label: block_cdGkk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGkk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGku; else goto cdGkt;
       cdGku: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGkt: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMU_entry() //  [R1]
         { info_tbl: [(cdGkv,
                       label: sat_sdEMU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGkv: // global
           _sdEMU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGkw; else goto cdGkx;
       cdGkx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdGkz; else goto cdGky;
       cdGkz: // global
           HpAlloc = 80;
           goto cdGkw;
       cdGkw: // global
           R1 = _sdEMU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEMU::P64;
           _sdEMz::P64 = P64[_sdEMU::P64 + 16];
           _sdEMA::P64 = P64[_sdEMU::P64 + 24];
           I64[Hp - 72] = f_sdEMB_info;
           P64[Hp - 64] = _sdEMz::P64;
           I64[Hp - 56] = f1_sdEMH_info;
           P64[Hp - 40] = _sdEMA::P64;
           I64[Hp - 32] = f2_sdEMK_info;
           P64[Hp - 24] = Hp - 56;
           I64[Hp - 16] = sat_sdEMT_info;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 31;
           R2 = Hp - 14;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cdGkA,
                       label: Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGkA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGkE; else goto cdGkD;
       cdGkE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGkD: // global
           I64[Hp - 24] = sat_sdEMU_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.927017696 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec2_info;
         const 0;
 },
 sat_sdEMZ_entry() //  [R1]
         { info_tbl: [(cdGm4,
                       label: sat_sdEMZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGm4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGm5; else goto cdGm6;
       cdGm5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGm6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = Data.Functor.Classes.$fRead1Identity5_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEN0_entry() //  [R1, R2]
         { info_tbl: [(cdGmc,
                       label: sat_sdEN0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGmc: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEMY_entry() //  [R1, R2]
         { info_tbl: [(cdGmk,
                       label: sat_sdEMY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGmk: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readPrec_to_S_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 w2_sdEMX_entry() //  [R1]
         { info_tbl: [(cdGmn,
                       label: w2_sdEMX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGmn: // global
           _sdEMX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGmo; else goto cdGmp;
       cdGmp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGmr; else goto cdGmq;
       cdGmr: // global
           HpAlloc = 56;
           goto cdGmo;
       cdGmo: // global
           R1 = _sdEMX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGmq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEMX::P64;
           _sdEMV::P64 = P64[_sdEMX::P64 + 16];
           _sdEMW::P64 = P64[_sdEMX::P64 + 24];
           I64[Hp - 48] = sat_sdEMZ_info;
           P64[Hp - 32] = _sdEMW::P64;
           I64[Hp - 24] = sat_sdEN0_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sdEMY_info;
           P64[Hp] = _sdEMV::P64;
           R3 = Hp - 23;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_entry(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEN4_entry() //  [R1, R2]
         { info_tbl: [(cdGmA,
                       label: sat_sdEN4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGmA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGmB; else goto cdGmC;
       cdGmB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGmC: // global
           I64[Sp - 8] = block_cdGmx_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGmx() //  [R1]
         { info_tbl: [(cdGmx,
                       label: block_cdGmx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGmx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGmF; else goto cdGmE;
       cdGmF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGmE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec2_entry() //  [R2, R3]
         { info_tbl: [(cdGmG,
                       label: Data.Functor.Classes.$w$cliftReadListPrec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGmG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGmK; else goto cdGmJ;
       cdGmK: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGmJ: // global
           I64[Hp - 40] = w2_sdEMX_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdEN4_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.943240349 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty1_closure" {
     Data.Functor.Classes.$fRead1NonEmpty1_closure:
         const Data.Functor.Classes.$fRead1NonEmpty1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1NonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(cdGns,
                       label: Data.Functor.Classes.$fRead1NonEmpty1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGns: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec2_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.946599282 UTC

[section ""data" . Data.Functor.Classes.$fRead1NonEmpty_closure" {
     Data.Functor.Classes.$fRead1NonEmpty_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure+4;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1NonEmpty1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.949513384 UTC

[section ""data" . Data.Functor.Classes.$dmliftReadsPrec_closure" {
     Data.Functor.Classes.$dmliftReadsPrec_closure:
         const Data.Functor.Classes.$dmliftReadsPrec_info;
 },
 sat_sdENh_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGnQ,
                       label: sat_sdENh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGnQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGnR; else goto cdGnS;
       cdGnR: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGnS: // global
           I64[Sp - 8] = block_cdGnN_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGnN() //  [R1]
         { info_tbl: [(cdGnN,
                       label: block_cdGnN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGnN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGnV; else goto cdGnU;
       cdGnV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGnU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdENc_entry() //  [R1, R2]
         { info_tbl: [(cdGo1,
                       label: sat_sdENc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGo1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdENb_entry() //  [R1]
         { info_tbl: [(cdGo4,
                       label: ds_sdENb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGo4: // global
           _sdENb::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGo5; else goto cdGo6;
       cdGo6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGo8; else goto cdGo7;
       cdGo8: // global
           HpAlloc = 32;
           goto cdGo5;
       cdGo5: // global
           R1 = _sdENb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGo7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdENb::P64;
           _sdEN8::P64 = P64[_sdENb::P64 + 16];
           _sdEN9::P64 = P64[_sdENb::P64 + 24];
           _sdENa::P64 = P64[_sdENb::P64 + 32];
           I64[Hp - 24] = sat_sdENh_info;
           P64[Hp - 16] = _sdENa::P64;
           I64[Hp - 8] = sat_sdENc_info;
           P64[Hp] = _sdEN9::P64;
           R2 = _sdEN8::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 7;
           P64[Sp - 24] = Hp - 22;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdENj_entry() //  [R1]
         { info_tbl: [(cdGoi,
                       label: sat_sdENj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGoi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGoj; else goto cdGok;
       cdGoj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdENk_entry() //  [R1, R2]
         { info_tbl: [(cdGol,
                       label: sat_sdENk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGol: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGop; else goto cdGoo;
       cdGop: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGoo: // global
           _sdENb::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sdENj_info;
           P64[Hp - 8] = _sdENb::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$dmliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGoq,
                       label: Data.Functor.Classes.$dmliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGoq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGou; else goto cdGot;
       cdGou: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$dmliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGot: // global
           I64[Hp - 48] = ds_sdENb_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdENk_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.965709909 UTC

[section ""data" . Data.Functor.Classes.eq1_closure" {
     Data.Functor.Classes.eq1_closure:
         const Data.Functor.Classes.eq1_info;
 },
 sat_sdENn_entry() //  [R1]
         { info_tbl: [(cdGpj,
                       label: sat_sdENn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGpj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGpk; else goto cdGpl;
       cdGpk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGpl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq1_entry() //  [R2, R3]
         { info_tbl: [(cdGpm,
                       label: Data.Functor.Classes.eq1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGpm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGpq; else goto cdGpp;
       cdGpq: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGpp: // global
           I64[Hp - 16] = sat_sdENn_info;
           P64[Hp] = R3;
           _sdENl::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdENl::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.97301788 UTC

[section ""data" . Data.Functor.Classes.compare1_closure" {
     Data.Functor.Classes.compare1_closure:
         const Data.Functor.Classes.compare1_info;
 },
 sat_sdENq_entry() //  [R1]
         { info_tbl: [(cdGpJ,
                       label: sat_sdENq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGpK; else goto cdGpL;
       cdGpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGpL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare1_entry() //  [R2, R3]
         { info_tbl: [(cdGpM,
                       label: Data.Functor.Classes.compare1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGpM: // global
           _sdENp::P64 = R3;
           _sdENo::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGpN; else goto cdGpO;
       cdGpO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGpQ; else goto cdGpP;
       cdGpQ: // global
           HpAlloc = 24;
           goto cdGpN;
       cdGpN: // global
           R3 = _sdENp::P64;
           R2 = _sdENo::P64;
           R1 = Data.Functor.Classes.compare1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGpP: // global
           I64[Hp - 16] = sat_sdENq_info;
           P64[Hp] = _sdENp::P64;
           R2 = _sdENo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.979543572 UTC

[section ""data" . Data.Functor.Classes.readsPrec1_closure" {
     Data.Functor.Classes.readsPrec1_closure:
         const Data.Functor.Classes.readsPrec1_info;
 },
 sat_sdENu_entry() //  [R1]
         { info_tbl: [(cdGqc,
                       label: sat_sdENu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGqc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGqd; else goto cdGqe;
       cdGqd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGqe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdENt_entry() //  [R1]
         { info_tbl: [(cdGqj,
                       label: sat_sdENt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGqj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGqk; else goto cdGql;
       cdGqk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGql: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdGqm,
                       label: Data.Functor.Classes.readsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGqm: // global
           _sdENs::P64 = R3;
           _sdENr::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdGqn; else goto cdGqo;
       cdGqo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGqq; else goto cdGqp;
       cdGqq: // global
           HpAlloc = 48;
           goto cdGqn;
       cdGqn: // global
           R3 = _sdENs::P64;
           R2 = _sdENr::P64;
           R1 = Data.Functor.Classes.readsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGqp: // global
           I64[Hp - 40] = sat_sdENu_info;
           P64[Hp - 24] = _sdENs::P64;
           I64[Hp - 16] = sat_sdENt_info;
           P64[Hp] = _sdENs::P64;
           R2 = _sdENr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:54.988482544 UTC

[section ""data" . Data.Functor.Classes.readsUnary1_closure" {
     Data.Functor.Classes.readsUnary1_closure:
         const Data.Functor.Classes.readsUnary1_info;
 },
 go_sdENC_entry() //  [R1, R2]
         { info_tbl: [(cdGr6,
                       label: go_sdENC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGr6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdGr7; else goto cdGr8;
       cdGr7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGr8: // global
           I64[Sp - 24] = block_cdGqZ_info;
           _sdENC::P64 = R1;
           _sdENy::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdENy::P64;
           P64[Sp - 8] = _sdENC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udGrs; else goto cdGr0;
       udGrs: // global
           call _cdGqZ(R1) args: 0, res: 0, upd: 0;
       cdGr0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGqZ() //  [R1]
         { info_tbl: [(cdGqZ,
                       label: block_cdGqZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGqZ: // global
           if (R1 & 7 == 1) goto cdGr3; else goto cdGr4;
       cdGr3: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGr4: // global
           I64[Sp - 8] = block_cdGre_info;
           _sdENG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdENG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udGrr; else goto cdGrf;
       udGrr: // global
           call _cdGre(R1) args: 0, res: 0, upd: 0;
       cdGrf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGre() //  [R1]
         { info_tbl: [(cdGre,
                       label: block_cdGre_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGre: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdGrq; else goto cdGrp;
       cdGrq: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGrp: // global
           _sdENI::P64 = P64[R1 + 7];
           _sdENJ::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdENI::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdENJ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdENO_entry() //  [R1]
         { info_tbl: [(cdGrx,
                       label: sat_sdENO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGrx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGry; else goto cdGrz;
       cdGry: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGrz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdENN_entry() //  [R1]
         { info_tbl: [(cdGrE,
                       label: sat_sdENN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGrE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGrF; else goto cdGrG;
       cdGrF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGrG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdGrL,
                       label: Data.Functor.Classes.readsUnary1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGrL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdGrM; else goto cdGrN;
       cdGrM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdGrN: // global
           I64[Sp - 32] = block_cdGqP_info;
           _sdENw::P64 = R3;
           R3 = R4;
           _sdENv::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdENv::P64;
           P64[Sp - 16] = _sdENw::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGqP() //  [R1]
         { info_tbl: [(cdGqP,
                       label: block_cdGqP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGqP: // global
           if (R1 & 7 == 1) goto cdGrI; else goto cdGrJ;
       cdGrI: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGrJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGrT; else goto cdGrS;
       cdGrT: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGrS: // global
           I64[Hp - 56] = go_sdENC_info;
           P64[Hp - 48] = P64[Sp + 24];
           I64[Hp - 40] = sat_sdENO_info;
           _sdENw::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sdENw::P64;
           I64[Hp - 16] = sat_sdENN_info;
           P64[Hp] = _sdENw::P64;
           I64[Sp + 24] = block_cdGrQ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pppp_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp] = Hp - 40;
           P64[Sp + 8] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 55;
           Sp = Sp - 16;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdGrQ() //  [R1]
         { info_tbl: [(cdGrQ,
                       label: block_cdGrQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGrQ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdENC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.008430515 UTC

[section ""data" . Data.Functor.Classes.readsBinary1_closure" {
     Data.Functor.Classes.readsBinary1_closure:
         const Data.Functor.Classes.readsBinary1_info;
 },
 Data.Functor.Classes.readsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGt3: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.readsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 lvl3_sdENY_entry() //  [R1]
         { info_tbl: [(cdGtg,
                       label: lvl3_sdENY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGtg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGth; else goto cdGti;
       cdGth: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGti: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl4_sdENZ_entry() //  [R1]
         { info_tbl: [(cdGtn,
                       label: lvl4_sdENZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGtn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGto; else goto cdGtp;
       cdGto: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGtp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_sdEO9_entry() //  [R1, R2]
         { info_tbl: [(cdGtT,
                       label: go1_sdEO9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGtT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdGtU; else goto cdGtV;
       cdGtU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGtV: // global
           I64[Sp - 40] = block_cdGtM_info;
           _sdEO9::P64 = R1;
           _sdENU::P64 = P64[R1 + 7];
           _sdEO6::P64 = P64[R1 + 15];
           _sdEO8::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdENU::P64;
           P64[Sp - 24] = _sdEO6::P64;
           P64[Sp - 16] = _sdEO8::P64;
           P64[Sp - 8] = _sdEO9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udGuf; else goto cdGtN;
       udGuf: // global
           call _cdGtM(R1) args: 0, res: 0, upd: 0;
       cdGtN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGtM() //  [R1]
         { info_tbl: [(cdGtM,
                       label: block_cdGtM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGtM: // global
           if (R1 & 7 == 1) goto cdGtQ; else goto cdGtR;
       cdGtQ: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdGtR: // global
           I64[Sp] = block_cdGu1_info;
           _sdEOd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdEOd::P64;
           if (R1 & 7 != 0) goto udGue; else goto cdGu2;
       udGue: // global
           call _cdGu1(R1) args: 0, res: 0, upd: 0;
       cdGu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGu1() //  [R1]
         { info_tbl: [(cdGu1,
                       label: block_cdGu1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGu1: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdGud; else goto cdGuc;
       cdGud: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGuc: // global
           _sdEOf::P64 = P64[R1 + 7];
           _sdEOg::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdEOf::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdEOg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdEO0_entry() //  [R1, R2]
         { info_tbl: [(cdGuk,
                       label: go_sdEO0_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGuk: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdGul; else goto cdGum;
       cdGul: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGum: // global
           I64[Sp - 48] = block_cdGtv_info;
           _sdEO0::P64 = R1;
           _sdENR::P64 = P64[R1 + 7];
           _sdENU::P64 = P64[R1 + 15];
           _sdENY::P64 = P64[R1 + 23];
           _sdENZ::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _sdENR::P64;
           P64[Sp - 32] = _sdENU::P64;
           P64[Sp - 24] = _sdENY::P64;
           P64[Sp - 16] = _sdENZ::P64;
           P64[Sp - 8] = _sdEO0::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto udGuz; else goto cdGtw;
       udGuz: // global
           call _cdGtv(R1) args: 0, res: 0, upd: 0;
       cdGtw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGtv() //  [R1]
         { info_tbl: [(cdGtv,
                       label: block_cdGtv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGtv: // global
           if (R1 & 7 == 1) goto cdGuh; else goto cdGui;
       cdGuh: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGui: // global
           I64[Sp - 8] = block_cdGtB_info;
           _sdEO4::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdEO4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udGuy; else goto cdGtC;
       udGuy: // global
           call _cdGtB(R1) args: 0, res: 0, upd: 0;
       cdGtC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGtB() //  [R1]
         { info_tbl: [(cdGtB,
                       label: block_cdGtB_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGtB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGut; else goto cdGus;
       cdGut: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGus: // global
           _sdEO6::P64 = P64[R1 + 7];
           _sdEO7::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdEO9_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdEO6::P64;
           P64[Hp] = Hp - 56;
           _sdENZ::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdGup_info;
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppp_info;
           P64[Sp + 8] = P64[Sp + 32];
           P64[Sp + 16] = _sdENZ::P64;
           P64[Sp + 24] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 32] = _sdEO7::P64;
           P64[Sp + 48] = Hp - 23;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdGup() //  [R1]
         { info_tbl: [(cdGup,
                       label: block_cdGup_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGup: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdEO9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdGuE,
                       label: Data.Functor.Classes.readsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGuE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdGuF; else goto cdGuG;
       cdGuF: // global
           R1 = Data.Functor.Classes.readsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdGuG: // global
           I64[Sp - 32] = block_cdGt7_info;
           _sdENR::P64 = R3;
           R3 = R5;
           _sdENQ::P64 = R2;
           R2 = P64[Sp];
           P64[Sp - 24] = _sdENR::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = _sdENQ::P64;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGt7() //  [R1]
         { info_tbl: [(cdGt7,
                       label: block_cdGt7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGt7: // global
           if (R1 & 7 == 1) goto cdGuB; else goto cdGuC;
       cdGuB: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGuC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdGuM; else goto cdGuL;
       cdGuM: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGuL: // global
           I64[Hp - 80] = lvl3_sdENY_info;
           _sdENS::P64 = P64[Sp + 16];
           P64[Hp - 64] = _sdENS::P64;
           I64[Hp - 56] = lvl4_sdENZ_info;
           P64[Hp - 40] = _sdENS::P64;
           I64[Hp - 32] = go_sdEO0_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           _cdGtc::P64 = Hp - 80;
           P64[Hp - 8] = _cdGtc::P64;
           _cdGtj::P64 = Hp - 56;
           P64[Hp] = _cdGtj::P64;
           _sdENQ::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cdGuJ_info;
           R2 = _sdENQ::P64;
           I64[Sp - 8] = stg_ap_pppp_info;
           P64[Sp] = _cdGtc::P64;
           P64[Sp + 8] = _cdGtj::P64;
           P64[Sp + 16] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 24] = P64[Sp + 40];
           P64[Sp + 40] = Hp - 31;
           Sp = Sp - 8;
           call Data.Functor.Classes.liftReadsPrec_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdGuJ() //  [R1]
         { info_tbl: [(cdGuJ,
                       label: block_cdGuJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGuJ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdEO0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.040088068 UTC

[section ""data" . Data.Functor.Classes.readPrec1_closure" {
     Data.Functor.Classes.readPrec1_closure:
         const Data.Functor.Classes.readPrec1_info;
 },
 sat_sdEOp_entry() //  [R1]
         { info_tbl: [(cdGwB,
                       label: sat_sdEOp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGwB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGwC; else goto cdGwD;
       cdGwC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGwD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEOo_entry() //  [R1]
         { info_tbl: [(cdGwI,
                       label: sat_sdEOo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGwJ; else goto cdGwK;
       cdGwJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGwK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdGwL,
                       label: Data.Functor.Classes.readPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGwL: // global
           _sdEOn::P64 = R3;
           _sdEOm::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdGwM; else goto cdGwN;
       cdGwN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGwP; else goto cdGwO;
       cdGwP: // global
           HpAlloc = 48;
           goto cdGwM;
       cdGwM: // global
           R3 = _sdEOn::P64;
           R2 = _sdEOm::P64;
           R1 = Data.Functor.Classes.readPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGwO: // global
           I64[Hp - 40] = sat_sdEOp_info;
           P64[Hp - 24] = _sdEOn::P64;
           I64[Hp - 16] = sat_sdEOo_info;
           P64[Hp] = _sdEOn::P64;
           R2 = _sdEOm::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.048616076 UTC

[section ""data" . Data.Functor.Classes.liftReadListDefault_closure" {
     Data.Functor.Classes.liftReadListDefault_closure:
         const Data.Functor.Classes.liftReadListDefault_info;
 },
 sat_sdEOy_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGxq,
                       label: sat_sdEOy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGxq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGxr; else goto cdGxs;
       cdGxr: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGxs: // global
           I64[Sp - 8] = block_cdGxn_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGxn() //  [R1]
         { info_tbl: [(cdGxn,
                       label: block_cdGxn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGxn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGxv; else goto cdGxu;
       cdGxv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGxu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEOt_entry() //  [R1, R2]
         { info_tbl: [(cdGxB,
                       label: sat_sdEOt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGxB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEOz_entry() //  [R1]
         { info_tbl: [(cdGxE,
                       label: sat_sdEOz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGxE: // global
           _sdEOz::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdGxF; else goto cdGxG;
       cdGxG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGxI; else goto cdGxH;
       cdGxI: // global
           HpAlloc = 32;
           goto cdGxF;
       cdGxF: // global
           R1 = _sdEOz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGxH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEOz::P64;
           _sdEOq::P64 = P64[_sdEOz::P64 + 16];
           _sdEOr::P64 = P64[_sdEOz::P64 + 24];
           _sdEOs::P64 = P64[_sdEOz::P64 + 32];
           I64[Hp - 24] = sat_sdEOy_info;
           P64[Hp - 16] = _sdEOs::P64;
           I64[Hp - 8] = sat_sdEOt_info;
           P64[Hp] = _sdEOr::P64;
           R2 = _sdEOq::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 7;
           P64[Sp - 40] = Hp - 22;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadListDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGxJ,
                       label: Data.Functor.Classes.liftReadListDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGxJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGxN; else goto cdGxM;
       cdGxN: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGxM: // global
           I64[Hp - 32] = sat_sdEOz_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.061503128 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrecDefault_closure" {
     Data.Functor.Classes.liftReadListPrecDefault_closure:
         const Data.Functor.Classes.liftReadListPrecDefault_info;
         const 0;
 },
 sat_sdEOD_entry() //  [R1]
         { info_tbl: [(cdGys,
                       label: sat_sdEOD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGys: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdGyt; else goto cdGyu;
       cdGyt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGyu: // global
           R2 = P64[R1 + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 24;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrecDefault_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdGyv,
                       label: Data.Functor.Classes.liftReadListPrecDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGyv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGyz; else goto cdGyy;
       cdGyz: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrecDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGyy: // global
           I64[Hp - 32] = sat_sdEOD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.067359224 UTC

[section ""data" . lvl_rdymy_closure" {
     lvl_rdymy_closure:
         const lvl_rdymy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rdymy_entry() //  [R1]
         { info_tbl: [(cdGyS,
                       label: lvl_rdymy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGyS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGyT; else goto cdGyU;
       cdGyT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGyU: // global
           (_cdGyP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdGyP::I64 == 0) goto cdGyR; else goto cdGyQ;
       cdGyR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdGyQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdGyP::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.071242155 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_entry() //  []
         { info_tbl: [(cdGz7,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGz7: // global
           R1 = lvl_rdymy_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.074940341 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info;
         const 0;
 },
 sat_sdEOJ_entry() //  [R1]
         { info_tbl: [(cdGzm,
                       label: sat_sdEOJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGzm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGzn; else goto cdGzo;
       cdGzn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGzo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Functor.Classes.$fRead1Proxy2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udGzu_srtd" {
     udGzu_srtd:
         const SdF7K_srt+16;
         const 34;
         const 8590000129;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cdGzp,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGzp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGzt; else goto cdGzs;
       cdGzt: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGzs: // global
           I64[Hp - 16] = sat_sdEOJ_info;
           P64[Hp] = R4;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.081910083 UTC

[section ""data" . lvl1_rdymz_closure" {
     lvl1_rdymz_closure:
         const lvl1_rdymz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdymz_entry() //  [R1]
         { info_tbl: [(cdGzO,
                       label: lvl1_rdymz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGzO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdGzP; else goto cdGzQ;
       cdGzP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGzQ: // global
           (_cdGzL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdGzL::I64 == 0) goto cdGzN; else goto cdGzM;
       cdGzN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdGzM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdGzL::I64;
           R2 = Data.Functor.Classes.$fRead1Proxy1_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.086261258 UTC

[section ""data" . lvl2_rdymA_closure" {
     lvl2_rdymA_closure:
         const lvl2_rdymA_info;
         const 0;
 },
 lvl2_rdymA_entry() //  [R2]
         { info_tbl: [(cdGA7,
                       label: lvl2_rdymA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGA7: // global
           R3 = R2;
           R2 = lvl1_rdymz_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.089617992 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Proxy_$cliftReadList_entry() //  [R4]
         { info_tbl: [(cdGAi,
                       label: Data.Functor.Classes.$fRead1Proxy_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGAi: // global
           R2 = R4;
           call lvl2_rdymA_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.092792496 UTC

[section ""data" . Data.Functor.Classes.$fRead1Proxy_closure" {
     Data.Functor.Classes.$fRead1Proxy_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadList_closure+3;
         const Data.Functor.Classes.$fRead1Proxy5_closure+4;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.095441896 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_entry() //  [R3]
         { info_tbl: [(cdGAu,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGAu: // global
           R2 = R3;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.099568842 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info;
 },
 sat_sdEOT_entry() //  [R1]
         { info_tbl: [(cdGAM,
                       label: sat_sdEOT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGAM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdGAN; else goto cdGAO;
       cdGAN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGAO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdGAJ_info;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdGAJ() //  [R1]
         { info_tbl: [(cdGAJ,
                       label: block_cdGAJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGAJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGAR; else goto cdGAQ;
       cdGAR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdGAQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cdGAS,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGAS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGAW; else goto cdGAV;
       cdGAW: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGAV: // global
           I64[Hp - 16] = sat_sdEOT_info;
           P64[Hp] = R3;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.11104255 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList2_closure" {
     Data.Functor.Classes.$w$cliftReadList2_closure:
         const Data.Functor.Classes.$w$cliftReadList2_info;
         const 0;
 },
 sat_sdEOZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGBv,
                       label: sat_sdEOZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGBv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGBw; else goto cdGBx;
       cdGBw: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGBx: // global
           I64[Sp - 8] = block_cdGBs_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGBs() //  [R1]
         { info_tbl: [(cdGBs,
                       label: block_cdGBs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGBs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGBA; else goto cdGBz;
       cdGBA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGBz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEP0_entry() //  [R1]
         { info_tbl: [(cdGBB,
                       label: sat_sdEP0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGBB: // global
           _sdEP0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGBC; else goto cdGBD;
       cdGBD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGBF; else goto cdGBE;
       cdGBF: // global
           HpAlloc = 16;
           goto cdGBC;
       cdGBC: // global
           R1 = _sdEP0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGBE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEP0::P64;
           _sdEOU::P64 = P64[_sdEP0::P64 + 16];
           I64[Hp - 8] = sat_sdEOZ_info;
           P64[Hp] = _sdEOU::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadList2_entry() //  [R2]
         { info_tbl: [(cdGBG,
                       label: Data.Functor.Classes.$w$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGBG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGBK; else goto cdGBJ;
       cdGBK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGBJ: // global
           I64[Hp - 16] = sat_sdEP0_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.123609849 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1[]_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1[]_$cliftReadList_entry() //  [R3]
         { info_tbl: [(cdGCf,
                       label: Data.Functor.Classes.$fRead1[]_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGCf: // global
           R2 = R3;
           call Data.Functor.Classes.$w$cliftReadList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.127565948 UTC

[section ""data" . Data.Functor.Classes.$fRead1[]_closure" {
     Data.Functor.Classes.$fRead1[]_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1[]_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1[]_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadPrec_closure+2;
         const Data.Functor.Classes.$fRead1[]_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.130615245 UTC

[section ""data" . Data.Functor.Classes.showsPrec1_closure" {
     Data.Functor.Classes.showsPrec1_closure:
         const Data.Functor.Classes.showsPrec1_info;
 },
 sat_sdEP6_entry() //  [R1]
         { info_tbl: [(cdGCv,
                       label: sat_sdEP6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGCv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGCw; else goto cdGCx;
       cdGCw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGCx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEP5_entry() //  [R1]
         { info_tbl: [(cdGCC,
                       label: sat_sdEP5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGCC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGCD; else goto cdGCE;
       cdGCD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGCE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdGCF,
                       label: Data.Functor.Classes.showsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGCF: // global
           _sdEP4::P64 = R3;
           _sdEP3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdGCG; else goto cdGCH;
       cdGCH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGCJ; else goto cdGCI;
       cdGCJ: // global
           HpAlloc = 48;
           goto cdGCG;
       cdGCG: // global
           R3 = _sdEP4::P64;
           R2 = _sdEP3::P64;
           R1 = Data.Functor.Classes.showsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGCI: // global
           I64[Hp - 40] = sat_sdEP6_info;
           P64[Hp - 24] = _sdEP4::P64;
           I64[Hp - 16] = sat_sdEP5_info;
           P64[Hp] = _sdEP4::P64;
           R2 = _sdEP3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.140785852 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith1_closure" {
     Data.Functor.Classes.showsUnaryWith1_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.144573922 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary1_closure" {
     Data.Functor.Classes.$wshowsUnary1_closure:
         const Data.Functor.Classes.$wshowsUnary1_info;
 },
 Data.Functor.Classes.$wshowsUnary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGD6: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEPe_entry() //  [R1]
         { info_tbl: [(cdGDi,
                       label: sat_sdEPe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGDi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGDj; else goto cdGDk;
       cdGDj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPd_entry() //  [R1]
         { info_tbl: [(cdGDp,
                       label: sat_sdEPd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGDp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGDq; else goto cdGDr;
       cdGDq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGDr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdEPc_entry() //  [R1]
         { info_tbl: [(cdGDs,
                       label: g_sdEPc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGDs: // global
           _sdEPc::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdGDt; else goto cdGDu;
       cdGDu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGDw; else goto cdGDv;
       cdGDw: // global
           HpAlloc = 48;
           goto cdGDt;
       cdGDt: // global
           R1 = _sdEPc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGDv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPc::P64;
           _sdEP7::P64 = P64[_sdEPc::P64 + 16];
           _sdEP8::P64 = P64[_sdEPc::P64 + 24];
           _sdEPb::P64 = P64[_sdEPc::P64 + 32];
           I64[Hp - 40] = sat_sdEPe_info;
           P64[Hp - 24] = _sdEP8::P64;
           I64[Hp - 16] = sat_sdEPd_info;
           P64[Hp] = _sdEP8::P64;
           R2 = _sdEP7::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdEPb::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdEPj_entry() //  [R1, R2]
         { info_tbl: [(cdGDH,
                       label: sat_sdEPj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGDH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGDL; else goto cdGDK;
       cdGDL: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGDK: // global
           _sdEP9::P64 = P64[R1 + 7];
           _sdEPc::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdEPc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdEP9::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEPm_entry() //  [R1]
         { info_tbl: [(cdGE1,
                       label: sat_sdEPm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGE1: // global
           _sdEPm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGE2; else goto cdGE3;
       cdGE3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGE5; else goto cdGE4;
       cdGE5: // global
           HpAlloc = 24;
           goto cdGE2;
       cdGE2: // global
           R1 = _sdEPm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGE4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPm::P64;
           _sdEPc::P64 = P64[_sdEPm::P64 + 16];
           _sdEPk::P64 = P64[_sdEPm::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdEPk::P64;
           R2 = Hp - 14;
           R1 = _sdEPc::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPo_entry() //  [R1]
         { info_tbl: [(cdGE7,
                       label: sat_sdEPo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGE7: // global
           _sdEPo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGE8; else goto cdGE9;
       cdGE9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGEb; else goto cdGEa;
       cdGEb: // global
           HpAlloc = 56;
           goto cdGE8;
       cdGE8: // global
           R1 = _sdEPo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGEa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPo::P64;
           _sdEP9::P64 = P64[_sdEPo::P64 + 16];
           _sdEPc::P64 = P64[_sdEPo::P64 + 24];
           _sdEPk::P64 = P64[_sdEPo::P64 + 32];
           I64[Hp - 48] = sat_sdEPm_info;
           P64[Hp - 32] = _sdEPc::P64;
           P64[Hp - 24] = _sdEPk::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdEP9::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPp_entry() //  [R1, R2]
         { info_tbl: [(cdGEd,
                       label: sat_sdEPp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGEd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGEh; else goto cdGEg;
       cdGEh: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGEg: // global
           _sdEP9::P64 = P64[R1 + 7];
           _sdEPc::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdEPo_info;
           P64[Hp - 40] = _sdEP9::P64;
           P64[Hp - 32] = _sdEPc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdGEl,
                       label: Data.Functor.Classes.$wshowsUnary1_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGEl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGEp; else goto cdGEo;
       cdGEp: // global
           HpAlloc = 64;
           R1 = Data.Functor.Classes.$wshowsUnary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdGEo: // global
           I64[Hp - 56] = g_sdEPc_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R6;
           _cdGDa::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdGEj; else goto cdGEk;
       cdGEj: // global
           I64[Hp - 16] = sat_sdEPj_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdGDa::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGEk: // global
           I64[Hp - 16] = sat_sdEPp_info;
           P64[Hp - 8] = R4;
           P64[Hp] = _cdGDa::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.166657453 UTC

[section ""data" . Data.Functor.Classes.showsUnary1_closure" {
     Data.Functor.Classes.showsUnary1_closure:
         const Data.Functor.Classes.showsUnary1_info;
 },
 Data.Functor.Classes.showsUnary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdGFy,
                       label: Data.Functor.Classes.showsUnary1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGFy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdGFz; else goto cdGFA;
       cdGFz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGFA: // global
           I64[Sp - 40] = block_cdGFv_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udGFE; else goto cdGFw;
       udGFE: // global
           call _cdGFv(R1) args: 0, res: 0, upd: 0;
       cdGFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGFv() //  [R1]
         { info_tbl: [(cdGFv,
                       label: block_cdGFv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGFv: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsUnary1_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.174922978 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinary1_closure" {
     Data.Functor.Classes.$wshowsBinary1_closure:
         const Data.Functor.Classes.$wshowsBinary1_info;
 },
 Data.Functor.Classes.$wshowsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGFQ: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdEPG_entry() //  [R1]
         { info_tbl: [(cdGG2,
                       label: sat_sdEPG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGG3; else goto cdGG4;
       cdGG3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGG4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPF_entry() //  [R1]
         { info_tbl: [(cdGG9,
                       label: sat_sdEPF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGGa; else goto cdGGb;
       cdGGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGGb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f1_sdEPE_entry() //  [R1]
         { info_tbl: [(cdGGc,
                       label: f1_sdEPE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGGc: // global
           _sdEPE::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdGGd; else goto cdGGe;
       cdGGe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGGg; else goto cdGGf;
       cdGGg: // global
           HpAlloc = 48;
           goto cdGGd;
       cdGGd: // global
           R1 = _sdEPE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGGf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPE::P64;
           _sdEPx::P64 = P64[_sdEPE::P64 + 16];
           _sdEPz::P64 = P64[_sdEPE::P64 + 24];
           _sdEPC::P64 = P64[_sdEPE::P64 + 32];
           I64[Hp - 40] = sat_sdEPG_info;
           P64[Hp - 24] = _sdEPz::P64;
           I64[Hp - 16] = sat_sdEPF_info;
           P64[Hp] = _sdEPz::P64;
           R2 = _sdEPx::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdEPC::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdEPJ_entry() //  [R1]
         { info_tbl: [(cdGGp,
                       label: sat_sdEPJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGGp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGGq; else goto cdGGr;
       cdGGq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGGr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPI_entry() //  [R1]
         { info_tbl: [(cdGGw,
                       label: sat_sdEPI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGGw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGGx; else goto cdGGy;
       cdGGx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g1_sdEPH_entry() //  [R1]
         { info_tbl: [(cdGGz,
                       label: g1_sdEPH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGGz: // global
           _sdEPH::P64 = R1;
           if ((Sp + -56) < SpLim) (likely: False) goto cdGGA; else goto cdGGB;
       cdGGB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGGD; else goto cdGGC;
       cdGGD: // global
           HpAlloc = 48;
           goto cdGGA;
       cdGGA: // global
           R1 = _sdEPH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGGC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPH::P64;
           _sdEPy::P64 = P64[_sdEPH::P64 + 16];
           _sdEPz::P64 = P64[_sdEPH::P64 + 24];
           _sdEPD::P64 = P64[_sdEPH::P64 + 32];
           I64[Hp - 40] = sat_sdEPJ_info;
           P64[Hp - 24] = _sdEPz::P64;
           I64[Hp - 16] = sat_sdEPI_info;
           P64[Hp] = _sdEPz::P64;
           R2 = _sdEPy::P64;
           I64[Sp - 56] = stg_ap_pppp_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = _sdEPD::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 64, res: 0, upd: 24;
     }
 },
 sat_sdEPO_entry() //  [R1]
         { info_tbl: [(cdGGS,
                       label: sat_sdEPO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGGS: // global
           _sdEPO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGGT; else goto cdGGU;
       cdGGU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGGW; else goto cdGGV;
       cdGGW: // global
           HpAlloc = 56;
           goto cdGGT;
       cdGGT: // global
           R1 = _sdEPO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGGV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPO::P64;
           _sdEPE::P64 = P64[_sdEPO::P64 + 16];
           _sdEPH::P64 = P64[_sdEPO::P64 + 24];
           _sdEPL::P64 = P64[_sdEPO::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdEPH::P64;
           P64[Hp - 24] = _sdEPL::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdEPE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPQ_entry() //  [R1, R2]
         { info_tbl: [(cdGGY,
                       label: sat_sdEPQ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGGY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGH2; else goto cdGH1;
       cdGH2: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGH1: // global
           _sdEPA::P64 = P64[R1 + 7];
           _sdEPE::P64 = P64[R1 + 15];
           _sdEPH::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdEPO_info;
           P64[Hp - 40] = _sdEPE::P64;
           P64[Hp - 32] = _sdEPH::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdEPA::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEPT_entry() //  [R1]
         { info_tbl: [(cdGHm,
                       label: sat_sdEPT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGHm: // global
           _sdEPT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGHn; else goto cdGHo;
       cdGHo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGHq; else goto cdGHp;
       cdGHq: // global
           HpAlloc = 24;
           goto cdGHn;
       cdGHn: // global
           R1 = _sdEPT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGHp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPT::P64;
           _sdEPH::P64 = P64[_sdEPT::P64 + 16];
           _sdEPR::P64 = P64[_sdEPT::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdEPR::P64;
           R2 = Hp - 14;
           R1 = _sdEPH::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPV_entry() //  [R1]
         { info_tbl: [(cdGHs,
                       label: sat_sdEPV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGHs: // global
           _sdEPV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGHt; else goto cdGHu;
       cdGHu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGHw; else goto cdGHv;
       cdGHw: // global
           HpAlloc = 56;
           goto cdGHt;
       cdGHt: // global
           R1 = _sdEPV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGHv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPV::P64;
           _sdEPE::P64 = P64[_sdEPV::P64 + 16];
           _sdEPH::P64 = P64[_sdEPV::P64 + 24];
           _sdEPR::P64 = P64[_sdEPV::P64 + 32];
           I64[Hp - 48] = sat_sdEPT_info;
           P64[Hp - 32] = _sdEPH::P64;
           P64[Hp - 24] = _sdEPR::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdEPE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPX_entry() //  [R1]
         { info_tbl: [(cdGHy,
                       label: sat_sdEPX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGHy: // global
           _sdEPX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGHz; else goto cdGHA;
       cdGHA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGHC; else goto cdGHB;
       cdGHC: // global
           HpAlloc = 64;
           goto cdGHz;
       cdGHz: // global
           R1 = _sdEPX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGHB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEPX::P64;
           _sdEPA::P64 = P64[_sdEPX::P64 + 16];
           _sdEPE::P64 = P64[_sdEPX::P64 + 24];
           _sdEPH::P64 = P64[_sdEPX::P64 + 32];
           _sdEPR::P64 = P64[_sdEPX::P64 + 40];
           I64[Hp - 56] = sat_sdEPV_info;
           P64[Hp - 40] = _sdEPE::P64;
           P64[Hp - 32] = _sdEPH::P64;
           P64[Hp - 24] = _sdEPR::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdEPA::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEPY_entry() //  [R1, R2]
         { info_tbl: [(cdGHE,
                       label: sat_sdEPY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGHE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdGHI; else goto cdGHH;
       cdGHI: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGHH: // global
           _sdEPA::P64 = P64[R1 + 7];
           _sdEPE::P64 = P64[R1 + 15];
           _sdEPH::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdEPX_info;
           P64[Hp - 48] = _sdEPA::P64;
           P64[Hp - 40] = _sdEPE::P64;
           P64[Hp - 32] = _sdEPH::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinary1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdGHM,
                       label: Data.Functor.Classes.$wshowsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGHM: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdGHQ; else goto cdGHP;
       cdGHQ: // global
           HpAlloc = 112;
           R1 = Data.Functor.Classes.$wshowsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdGHP: // global
           I64[Hp - 104] = f1_sdEPE_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = P64[Sp];
           I64[Hp - 64] = g1_sdEPH_info;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = P64[Sp + 8];
           _cdGFU::P64 = Hp - 104;
           _cdGGh::P64 = Hp - 64;
           if (%MO_S_Le_W64(R6, 10)) goto cdGHK; else goto cdGHL;
       cdGHK: // global
           I64[Hp - 24] = sat_sdEPQ_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdGFU::P64;
           P64[Hp] = _cdGGh::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGHL: // global
           I64[Hp - 24] = sat_sdEPY_info;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = _cdGFU::P64;
           P64[Hp] = _cdGGh::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.212630771 UTC

[section ""data" . Data.Functor.Classes.showsBinary1_closure" {
     Data.Functor.Classes.showsBinary1_closure:
         const Data.Functor.Classes.showsBinary1_info;
 },
 Data.Functor.Classes.showsBinary1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGJz: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.showsBinary1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.showsBinary1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdGJG,
                       label: Data.Functor.Classes.showsBinary1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGJG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdGJH; else goto cdGJI;
       cdGJH: // global
           R1 = Data.Functor.Classes.showsBinary1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdGJI: // global
           I64[Sp - 40] = block_cdGJD_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udGJM; else goto cdGJE;
       udGJM: // global
           call _cdGJD(R1) args: 0, res: 0, upd: 0;
       cdGJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGJD() //  [R1]
         { info_tbl: [(cdGJD,
                       label: block_cdGJD_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGJD: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinary1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.22048203 UTC

[section ""data" . Data.Functor.Classes.eq2_closure" {
     Data.Functor.Classes.eq2_closure:
         const Data.Functor.Classes.eq2_info;
 },
 sat_sdEQc_entry() //  [R1]
         { info_tbl: [(cdGK7,
                       label: sat_sdEQc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGK7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGK8; else goto cdGK9;
       cdGK8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGK9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQb_entry() //  [R1]
         { info_tbl: [(cdGKe,
                       label: sat_sdEQb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGKe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGKf; else goto cdGKg;
       cdGKf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGKg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.eq2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGKh,
                       label: Data.Functor.Classes.eq2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGKh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGKl; else goto cdGKk;
       cdGKl: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.eq2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGKk: // global
           I64[Hp - 40] = sat_sdEQc_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdEQb_info;
           P64[Hp] = R3;
           R3 = Hp - 40;
           _sdEQ8::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdEQ8::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.228744442 UTC

[section ""data" . Data.Functor.Classes.compare2_closure" {
     Data.Functor.Classes.compare2_closure:
         const Data.Functor.Classes.compare2_info;
 },
 sat_sdEQh_entry() //  [R1]
         { info_tbl: [(cdGKK,
                       label: sat_sdEQh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGKK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGKL; else goto cdGKM;
       cdGKL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGKM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQg_entry() //  [R1]
         { info_tbl: [(cdGKR,
                       label: sat_sdEQg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGKR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGKS; else goto cdGKT;
       cdGKS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGKT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.compare2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGKU,
                       label: Data.Functor.Classes.compare2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGKU: // global
           _sdEQf::P64 = R4;
           _sdEQe::P64 = R3;
           _sdEQd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdGKV; else goto cdGKW;
       cdGKW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdGKY; else goto cdGKX;
       cdGKY: // global
           HpAlloc = 48;
           goto cdGKV;
       cdGKV: // global
           R4 = _sdEQf::P64;
           R3 = _sdEQe::P64;
           R2 = _sdEQd::P64;
           R1 = Data.Functor.Classes.compare2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGKX: // global
           I64[Hp - 40] = sat_sdEQh_info;
           P64[Hp - 24] = _sdEQf::P64;
           I64[Hp - 16] = sat_sdEQg_info;
           P64[Hp] = _sdEQe::P64;
           R2 = _sdEQd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftCompare2_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.238068684 UTC

[section ""data" . Data.Functor.Classes.readsPrec2_closure" {
     Data.Functor.Classes.readsPrec2_closure:
         const Data.Functor.Classes.readsPrec2_info;
 },
 sat_sdEQo_entry() //  [R1]
         { info_tbl: [(cdGLr,
                       label: sat_sdEQo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGLr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGLs; else goto cdGLt;
       cdGLs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGLt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQn_entry() //  [R1]
         { info_tbl: [(cdGLy,
                       label: sat_sdEQn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGLy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGLz; else goto cdGLA;
       cdGLz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGLA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQm_entry() //  [R1]
         { info_tbl: [(cdGLF,
                       label: sat_sdEQm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGLF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGLG; else goto cdGLH;
       cdGLG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGLH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQl_entry() //  [R1]
         { info_tbl: [(cdGLM,
                       label: sat_sdEQl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGLM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGLN; else goto cdGLO;
       cdGLN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGLO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGLP,
                       label: Data.Functor.Classes.readsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGLP: // global
           _sdEQk::P64 = R4;
           _sdEQj::P64 = R3;
           _sdEQi::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGLQ; else goto cdGLR;
       cdGLR: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdGLT; else goto cdGLS;
       cdGLT: // global
           HpAlloc = 96;
           goto cdGLQ;
       cdGLQ: // global
           R4 = _sdEQk::P64;
           R3 = _sdEQj::P64;
           R2 = _sdEQi::P64;
           R1 = Data.Functor.Classes.readsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGLS: // global
           I64[Hp - 88] = sat_sdEQo_info;
           P64[Hp - 72] = _sdEQk::P64;
           I64[Hp - 64] = sat_sdEQn_info;
           P64[Hp - 48] = _sdEQk::P64;
           I64[Hp - 40] = sat_sdEQm_info;
           P64[Hp - 24] = _sdEQj::P64;
           I64[Hp - 16] = sat_sdEQl_info;
           P64[Hp] = _sdEQj::P64;
           R2 = _sdEQi::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.250592749 UTC

[section ""data" . Data.Functor.Classes.readPrec2_closure" {
     Data.Functor.Classes.readPrec2_closure:
         const Data.Functor.Classes.readPrec2_info;
 },
 sat_sdEQv_entry() //  [R1]
         { info_tbl: [(cdGMA,
                       label: sat_sdEQv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGMA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGMB; else goto cdGMC;
       cdGMB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQu_entry() //  [R1]
         { info_tbl: [(cdGMH,
                       label: sat_sdEQu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGMH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGMI; else goto cdGMJ;
       cdGMI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGMJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQt_entry() //  [R1]
         { info_tbl: [(cdGMO,
                       label: sat_sdEQt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGMO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGMP; else goto cdGMQ;
       cdGMP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGMQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEQs_entry() //  [R1]
         { info_tbl: [(cdGMV,
                       label: sat_sdEQs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGMV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGMW; else goto cdGMX;
       cdGMW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGMX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.readPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGMY,
                       label: Data.Functor.Classes.readPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGMY: // global
           _sdEQr::P64 = R4;
           _sdEQq::P64 = R3;
           _sdEQp::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGMZ; else goto cdGN0;
       cdGN0: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdGN2; else goto cdGN1;
       cdGN2: // global
           HpAlloc = 96;
           goto cdGMZ;
       cdGMZ: // global
           R4 = _sdEQr::P64;
           R3 = _sdEQq::P64;
           R2 = _sdEQp::P64;
           R1 = Data.Functor.Classes.readPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGN1: // global
           I64[Hp - 88] = sat_sdEQv_info;
           P64[Hp - 72] = _sdEQr::P64;
           I64[Hp - 64] = sat_sdEQu_info;
           P64[Hp - 48] = _sdEQr::P64;
           I64[Hp - 40] = sat_sdEQt_info;
           P64[Hp - 24] = _sdEQq::P64;
           I64[Hp - 16] = sat_sdEQs_info;
           P64[Hp] = _sdEQq::P64;
           R2 = _sdEQp::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.263860599 UTC

[section ""data" . Data.Functor.Classes.liftReadList2Default_closure" {
     Data.Functor.Classes.liftReadList2Default_closure:
         const Data.Functor.Classes.liftReadList2Default_info;
 },
 sat_sdEQM_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGNR,
                       label: sat_sdEQM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGNR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGNS; else goto cdGNT;
       cdGNS: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGNT: // global
           I64[Sp - 8] = block_cdGNO_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGNO() //  [R1]
         { info_tbl: [(cdGNO,
                       label: block_cdGNO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGNO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGNW; else goto cdGNV;
       cdGNW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGNV: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEQH_entry() //  [R1, R2]
         { info_tbl: [(cdGO2,
                       label: sat_sdEQH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGO2: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEQG_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGOd,
                       label: sat_sdEQG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGOd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdGOe; else goto cdGOf;
       cdGOe: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGOf: // global
           I64[Sp - 8] = block_cdGOa_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGOa() //  [R1]
         { info_tbl: [(cdGOa,
                       label: block_cdGOa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGOa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGOi; else goto cdGOh;
       cdGOi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGOh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEQB_entry() //  [R1, R2]
         { info_tbl: [(cdGOo,
                       label: sat_sdEQB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGOo: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEQN_entry() //  [R1]
         { info_tbl: [(cdGOr,
                       label: sat_sdEQN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGOr: // global
           _sdEQN::P64 = R1;
           if ((Sp + -72) < SpLim) (likely: False) goto cdGOs; else goto cdGOt;
       cdGOt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdGOv; else goto cdGOu;
       cdGOv: // global
           HpAlloc = 64;
           goto cdGOs;
       cdGOs: // global
           R1 = _sdEQN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGOu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEQN::P64;
           _sdEQw::P64 = P64[_sdEQN::P64 + 16];
           _sdEQx::P64 = P64[_sdEQN::P64 + 24];
           _sdEQy::P64 = P64[_sdEQN::P64 + 32];
           _sdEQz::P64 = P64[_sdEQN::P64 + 40];
           _sdEQA::P64 = P64[_sdEQN::P64 + 48];
           I64[Hp - 56] = sat_sdEQM_info;
           P64[Hp - 48] = _sdEQA::P64;
           I64[Hp - 40] = sat_sdEQH_info;
           P64[Hp - 32] = _sdEQz::P64;
           I64[Hp - 24] = sat_sdEQG_info;
           P64[Hp - 16] = _sdEQy::P64;
           I64[Hp - 8] = sat_sdEQB_info;
           P64[Hp] = _sdEQx::P64;
           R2 = _sdEQw::P64;
           I64[Sp - 72] = stg_ap_pppppp_info;
           P64[Sp - 64] = Hp - 7;
           P64[Sp - 56] = Hp - 22;
           P64[Sp - 48] = Hp - 39;
           P64[Sp - 40] = Hp - 54;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 72;
           call Data.Functor.Classes.liftReadListPrec2_entry(R2) args: 80, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.liftReadList2Default_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cdGOw,
                       label: Data.Functor.Classes.liftReadList2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGOw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGOA; else goto cdGOz;
       cdGOA: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadList2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGOz: // global
           I64[Hp - 48] = sat_sdEQN_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.282626139 UTC

[section ""data" . Data.Functor.Classes.$fRead2Either_closure" {
     Data.Functor.Classes.$fRead2Either_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Either8_closure+6;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Either_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Either_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Either_$cliftReadList2_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdGPs,
                       label: Data.Functor.Classes.$fRead2Either_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGPs: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Either_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.287168689 UTC

[section ""data" . Data.Functor.Classes.$fRead2Const_closure" {
     Data.Functor.Classes.$fRead2Const_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1Const6_closure+6;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2Const_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2Const_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2Const_$cliftReadList2_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdGPE,
                       label: Data.Functor.Classes.$fRead2Const_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGPE: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2Const_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.291629504 UTC

[section ""data" . Data.Functor.Classes.$fRead2(,)_closure" {
     Data.Functor.Classes.$fRead2(,)_closure:
         const Data.Functor.Classes.C:Read2_con_info;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2_closure+5;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure+4;
         const Data.Functor.Classes.$fRead1(,)2_closure+6;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure+4;
         const 0;
 },
 section ""data" . Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure" {
     Data.Functor.Classes.$fRead2(,)_$cliftReadList2_closure:
         const Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info;
         const 0;
 },
 Data.Functor.Classes.$fRead2(,)_$cliftReadList2_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdGPQ,
                       label: Data.Functor.Classes.$fRead2(,)_$cliftReadList2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGPQ: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead2(,)_closure+1;
           call Data.Functor.Classes.liftReadList2Default_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.29628113 UTC

[section ""data" . Data.Functor.Classes.liftReadListPrec2Default_closure" {
     Data.Functor.Classes.liftReadListPrec2Default_closure:
         const Data.Functor.Classes.liftReadListPrec2Default_info;
         const 0;
 },
 sat_sdEQT_entry() //  [R1]
         { info_tbl: [(cdGQ6,
                       label: sat_sdEQT_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGQ6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdGQ7; else goto cdGQ8;
       cdGQ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGQ8: // global
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           P64[Sp - 16] = P64[R1 + 40];
           P64[Sp - 8] = P64[R1 + 48];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.liftReadListPrec2Default_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cdGQ9,
                       label: Data.Functor.Classes.liftReadListPrec2Default_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGQ9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdGQd; else goto cdGQc;
       cdGQd: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.liftReadListPrec2Default_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGQc: // global
           I64[Hp - 48] = sat_sdEQT_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R2 = Hp - 48;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.303053653 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)1_closure" {
     Data.Functor.Classes.$fRead1(,)1_closure:
         const Data.Functor.Classes.$fRead1(,)1_info;
         const 0;
 },
 sat_sdEQZ_entry() //  [R1]
         { info_tbl: [(cdGQA,
                       label: sat_sdEQZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGQA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGQB; else goto cdGQC;
       cdGQB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGQC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdGQD,
                       label: Data.Functor.Classes.$fRead1(,)1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGQD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGQH; else goto cdGQG;
       cdGQH: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGQG: // global
           I64[Hp - 16] = sat_sdEQZ_info;
           P64[Hp] = R2;
           _sdEQX::P64 = R5;
           R5 = R6;
           R4 = _sdEQX::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.309452772 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec_info;
         const 0;
 },
 sat_sdER4_entry() //  [R1, R2]
         { info_tbl: [(cdGR5,
                       label: sat_sdER4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGR5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdER3_entry() //  [R1]
         { info_tbl: [(cdGRc,
                       label: sat_sdER3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGRc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGRd; else goto cdGRe;
       cdGRd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGRe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdER5_entry() //  [R1]
         { info_tbl: [(cdGRf,
                       label: sat_sdER5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGRf: // global
           _sdER5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdGRg; else goto cdGRh;
       cdGRh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGRj; else goto cdGRi;
       cdGRj: // global
           HpAlloc = 40;
           goto cdGRg;
       cdGRg: // global
           R1 = _sdER5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGRi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdER5::P64;
           _sdER0::P64 = P64[_sdER5::P64 + 16];
           _sdER1::P64 = P64[_sdER5::P64 + 24];
           _sdER2::P64 = P64[_sdER5::P64 + 32];
           I64[Hp - 32] = sat_sdER4_info;
           P64[Hp - 24] = _sdER1::P64;
           I64[Hp - 16] = sat_sdER3_info;
           P64[Hp] = _sdER0::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdER2::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGRk,
                       label: Data.Functor.Classes.$w$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGRk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGRo; else goto cdGRn;
       cdGRo: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGRn: // global
           I64[Hp - 32] = sat_sdER5_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.320383819 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_entry() //  [R2,
                                                              R3, R5]
         { info_tbl: [(cdGRP,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGRP: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.3241862 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdERd_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGS5,
                       label: sat_sdERd_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGS5: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(cdGS8,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGS8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGSc; else goto cdGSb;
       cdGSc: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGSb: // global
           I64[Hp - 24] = sat_sdERd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 22;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.33084846 UTC

[section ""data" . Data.Functor.Classes.$fRead1(,)_closure" {
     Data.Functor.Classes.$fRead1(,)_closure:
         const Data.Functor.Classes.$fRead1(,)_info;
         const 0;
 },
 sat_sdERl_entry() //  [R1, R2, R3]
         { info_tbl: [(cdGSu,
                       label: sat_sdERl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGSu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_entry(R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdERk_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdGSC,
                       label: sat_sdERk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGSC: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1(,)1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdERj_entry() //  [R1]
         { info_tbl: [(cdGSJ,
                       label: sat_sdERj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGSK; else goto cdGSL;
       cdGSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdERi_entry() //  [R1, R2, R4]
         { info_tbl: [(cdGSR,
                       label: sat_sdERi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGSR: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1(,)_entry() //  [R2]
         { info_tbl: [(cdGSV,
                       label: Data.Functor.Classes.$fRead1(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGSV: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdGSZ; else goto cdGSY;
       cdGSZ: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGSY: // global
           I64[Hp - 104] = sat_sdERl_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdERk_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdERj_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdERi_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_info;
         const 0;
 },
 sat_sdERn_entry() //  [R1]
         { info_tbl: [(cdGT8,
                       label: sat_sdERn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGT8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGT9; else goto cdGTa;
       cdGT9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGTa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1(,)_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdGTb,
                       label: Data.Functor.Classes.$fRead1(,)_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGTb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGTf; else goto cdGTe;
       cdGTf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGTe: // global
           I64[Hp - 16] = sat_sdERn_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.34716646 UTC

[section ""data" . Data.Functor.Classes.showsPrec2_closure" {
     Data.Functor.Classes.showsPrec2_closure:
         const Data.Functor.Classes.showsPrec2_info;
 },
 sat_sdERu_entry() //  [R1]
         { info_tbl: [(cdGU0,
                       label: sat_sdERu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGU0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGU1; else goto cdGU2;
       cdGU1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGU2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdERt_entry() //  [R1]
         { info_tbl: [(cdGU7,
                       label: sat_sdERt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGU7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGU8; else goto cdGU9;
       cdGU8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGU9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdERs_entry() //  [R1]
         { info_tbl: [(cdGUe,
                       label: sat_sdERs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGUe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGUf; else goto cdGUg;
       cdGUf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGUg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdERr_entry() //  [R1]
         { info_tbl: [(cdGUl,
                       label: sat_sdERr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGUl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGUm; else goto cdGUn;
       cdGUm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGUn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.showsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGUo,
                       label: Data.Functor.Classes.showsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGUo: // global
           _sdERq::P64 = R4;
           _sdERp::P64 = R3;
           _sdERo::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdGUp; else goto cdGUq;
       cdGUq: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdGUs; else goto cdGUr;
       cdGUs: // global
           HpAlloc = 96;
           goto cdGUp;
       cdGUp: // global
           R4 = _sdERq::P64;
           R3 = _sdERp::P64;
           R2 = _sdERo::P64;
           R1 = Data.Functor.Classes.showsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGUr: // global
           I64[Hp - 88] = sat_sdERu_info;
           P64[Hp - 72] = _sdERq::P64;
           I64[Hp - 64] = sat_sdERt_info;
           P64[Hp - 48] = _sdERq::P64;
           I64[Hp - 40] = sat_sdERs_info;
           P64[Hp - 24] = _sdERp::P64;
           I64[Hp - 16] = sat_sdERr_info;
           P64[Hp] = _sdERp::P64;
           R2 = _sdERo::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 40;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 88;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec2_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.360962564 UTC

[section ""data" . Data.Functor.Classes.$wreadsData_closure" {
     Data.Functor.Classes.$wreadsData_closure:
         const Data.Functor.Classes.$wreadsData_info;
         const 0;
 },
 sat_sdERH_entry() //  [R1]
         { info_tbl: [(cdGVp,
                       label: sat_sdERH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVp: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sdERy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdERy_entry() //  [R1, R2]
         { info_tbl: [(cdGVw,
                       label: go_sdERy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdGVx; else goto cdGVy;
       cdGVx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGVy: // global
           I64[Sp - 24] = block_cdGVa_info;
           _sdERy::P64 = R1;
           _sdERv::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdERv::P64;
           P64[Sp - 8] = _sdERy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udGVL; else goto cdGVb;
       udGVL: // global
           call _cdGVa(R1) args: 0, res: 0, upd: 0;
       cdGVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGVa() //  [R1]
         { info_tbl: [(cdGVa,
                       label: block_cdGVa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVa: // global
           if (R1 & 7 == 1) goto cdGVt; else goto cdGVu;
       cdGVt: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGVu: // global
           I64[Sp - 8] = block_cdGVg_info;
           _sdERC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdERC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udGVK; else goto cdGVh;
       udGVK: // global
           call _cdGVg(R1) args: 0, res: 0, upd: 0;
       cdGVh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGVg() //  [R1]
         { info_tbl: [(cdGVg,
                       label: block_cdGVg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGVF; else goto cdGVE;
       cdGVF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGVE: // global
           _sdERE::P64 = P64[R1 + 7];
           _sdERF::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdERH_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           _sdERv::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdGVB_info;
           R3 = _sdERF::P64;
           R2 = _sdERE::P64;
           R1 = _sdERv::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGVB() //  [R1]
         { info_tbl: [(cdGVB,
                       label: block_cdGVB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVB: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdERM_entry() //  [R1, R2]
         { info_tbl: [(cdGVT,
                       label: sat_sdERM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGVU; else goto cdGVV;
       cdGVU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGVV: // global
           I64[Sp - 16] = block_cdGVR_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGVR() //  [R1]
         { info_tbl: [(cdGVR,
                       label: block_cdGVR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGVR: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdERy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udGW6_srtd" {
     udGW6_srtd:
         const SdF7K_srt+120;
         const 36;
         const 51539607553;
 },
 Data.Functor.Classes.$wreadsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGW1,
                       label: Data.Functor.Classes.$wreadsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGW1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdGW5; else goto cdGW4;
       cdGW5: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGW4: // global
           I64[Hp - 24] = go_sdERy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdERM_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sdERJ::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sdERJ::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.379174784 UTC

[section ""data" . Data.Functor.Classes.readsData_closure" {
     Data.Functor.Classes.readsData_closure:
         const Data.Functor.Classes.readsData_info;
         const 0;
 },
 Data.Functor.Classes.readsData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGX1,
                       label: Data.Functor.Classes.readsData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGX1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdGX2; else goto cdGX3;
       cdGX2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsData_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGX3: // global
           I64[Sp - 24] = block_cdGWY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udGX7; else goto cdGWZ;
       udGX7: // global
           call _cdGWY(R1) args: 0, res: 0, upd: 0;
       cdGWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGWY() //  [R1]
         { info_tbl: [(cdGWY,
                       label: block_cdGWY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGWY: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wreadsData_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.384753346 UTC

[section ""data" . Data.Functor.Classes.readData2_closure" {
     Data.Functor.Classes.readData2_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.387546174 UTC

[section ""data" . Data.Functor.Classes.readData1_closure" {
     Data.Functor.Classes.readData1_closure:
         const Data.Functor.Classes.readData1_info;
         const 0;
 },
 lvl3_sdERV_entry() //  [R1]
         { info_tbl: [(cdGXr,
                       label: lvl3_sdERV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGXr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGXs; else goto cdGXt;
       cdGXs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGXt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.readData2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdES0_entry() //  [R1, R2]
         { info_tbl: [(cdGXC,
                       label: sat_sdES0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGXC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGXD; else goto cdGXE;
       cdGXD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGXE: // global
           I64[Sp - 16] = block_cdGXz_info;
           _sdERV::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdERV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udGXN; else goto cdGXA;
       udGXN: // global
           call _cdGXz(R1) args: 0, res: 0, upd: 0;
       cdGXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGXz() //  [R1]
         { info_tbl: [(cdGXz,
                       label: block_cdGXz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGXz: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdGXL; else goto cdGXM;
       cdGXL: // global
           R1 = Text.ParserCombinators.ReadP.$fAlternativeReadP4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGXM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readData1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGXO,
                       label: Data.Functor.Classes.readData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGXO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdGXS; else goto cdGXR;
       cdGXS: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readData1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGXR: // global
           I64[Hp - 32] = lvl3_sdERV_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdES0_info;
           P64[Hp] = Hp - 32;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.398114012 UTC

[section ""data" . Data.Functor.Classes.readData_closure" {
     Data.Functor.Classes.readData_closure:
         const Data.Functor.Classes.readData_info;
         const 0;
 },
 Data.Functor.Classes.readData_entry() //  [R2, R3, R4]
         { info_tbl: [(cdGYk,
                       label: Data.Functor.Classes.readData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGYk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readData1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.402676966 UTC

[section ""data" . Data.Functor.Classes.readsUnaryWith_closure" {
     Data.Functor.Classes.readsUnaryWith_closure:
         const Data.Functor.Classes.readsUnaryWith_info;
 },
 go_sdES7_entry() //  [R1, R2]
         { info_tbl: [(cdGYM,
                       label: go_sdES7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGYM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdGYN; else goto cdGYO;
       cdGYN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGYO: // global
           I64[Sp - 24] = block_cdGYF_info;
           _sdES7::P64 = R1;
           _sdES3::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdES3::P64;
           P64[Sp - 8] = _sdES7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udGZ8; else goto cdGYG;
       udGZ8: // global
           call _cdGYF(R1) args: 0, res: 0, upd: 0;
       cdGYG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGYF() //  [R1]
         { info_tbl: [(cdGYF,
                       label: block_cdGYF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGYF: // global
           if (R1 & 7 == 1) goto cdGYJ; else goto cdGYK;
       cdGYJ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGYK: // global
           I64[Sp - 8] = block_cdGYU_info;
           _sdESb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdESb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udGZ7; else goto cdGYV;
       udGZ7: // global
           call _cdGYU(R1) args: 0, res: 0, upd: 0;
       cdGYV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGYU() //  [R1]
         { info_tbl: [(cdGYU,
                       label: block_cdGYU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGYU: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdGZ6; else goto cdGZ5;
       cdGZ6: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGZ5: // global
           _sdESd::P64 = P64[R1 + 7];
           _sdESe::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdESd::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdESe::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdGZd,
                       label: Data.Functor.Classes.readsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGZd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdGZe; else goto cdGZf;
       cdGZe: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdGZf: // global
           I64[Sp - 32] = block_cdGYv_info;
           R3 = R3;
           _sdES1::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdES1::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdGYv() //  [R1]
         { info_tbl: [(cdGYv,
                       label: block_cdGYv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGYv: // global
           if (R1 & 7 == 1) goto cdGZa; else goto cdGZb;
       cdGZa: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdGZb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdGZl; else goto cdGZk;
       cdGZl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdGZk: // global
           I64[Hp - 8] = go_sdES7_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdGZi_info;
           R3 = P64[Sp + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdGZi() //  [R1]
         { info_tbl: [(cdGZi,
                       label: block_cdGZi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGZi: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdES7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.417973965 UTC

[section ""data" . Data.Functor.Classes.$wreadUnaryWith_closure" {
     Data.Functor.Classes.$wreadUnaryWith_closure:
         const Data.Functor.Classes.$wreadUnaryWith_info;
         const 0;
 },
 sat_sdESw_entry() //  [R1, R2]
         { info_tbl: [(cdH0s,
                       label: sat_sdESw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH0s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdH0w; else goto cdH0v;
       cdH0w: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH0v: // global
           _sdESl::P64 = P64[R1 + 7];
           _sdESn::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdESl::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdESn::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdESt_entry() //  [R1]
         { info_tbl: [(cdH0E,
                       label: sat_sdESt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH0E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdH0L; else goto cdH0M;
       cdH0L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH0M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdH0B_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udH0Q; else goto cdH0C;
       udH0Q: // global
           call _cdH0B(R1) args: 0, res: 0, upd: 0;
       cdH0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdH0B() //  [R1]
         { info_tbl: [(cdH0B,
                       label: block_cdH0B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH0B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdH0P; else goto cdH0O;
       cdH0P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdH0O: // global
           _sdESs::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdESs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdESx_entry() //  [R1, R2]
         { info_tbl: [(cdH0R,
                       label: sat_sdESx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH0R: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdH0V; else goto cdH0U;
       cdH0V: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH0U: // global
           _sdESj::P64 = P64[R1 + 7];
           _sdESl::P64 = P64[R1 + 15];
           _sdESm::P64 = P64[R1 + 23];
           _sdESn::P64 = P64[R1 + 31];
           I64[Hp - 40] = sat_sdESw_info;
           P64[Hp - 32] = _sdESl::P64;
           P64[Hp - 24] = _sdESn::P64;
           I64[Hp - 16] = sat_sdESt_info;
           P64[Hp] = _sdESm::P64;
           R3 = Hp - 39;
           R2 = Hp - 16;
           R1 = _sdESj::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadUnaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdH0X,
                       label: Data.Functor.Classes.$wreadUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH0X: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdH11; else goto cdH10;
       cdH11: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadUnaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH10: // global
           I64[Hp - 48] = sat_sdESx_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R3;
           R3 = Hp - 47;
           R2 = Hp - 4;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.430792384 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith1_closure" {
     Data.Functor.Classes.readUnaryWith1_closure:
         const Data.Functor.Classes.readUnaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdH1B,
                       label: Data.Functor.Classes.readUnaryWith1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH1B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdH1C; else goto cdH1D;
       cdH1C: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readUnaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH1D: // global
           I64[Sp - 8] = block_cdH1y_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadUnaryWith_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdH1y() //  [R1]
         { info_tbl: [(cdH1y,
                       label: block_cdH1y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH1y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdH1G; else goto cdH1F;
       cdH1G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdH1F: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.43748759 UTC

[section ""data" . Data.Functor.Classes.readUnaryWith_closure" {
     Data.Functor.Classes.readUnaryWith_closure:
         const Data.Functor.Classes.readUnaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readUnaryWith_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdH1W,
                       label: Data.Functor.Classes.readUnaryWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH1W: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readUnaryWith1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.441445183 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const5_closure" {
     Data.Functor.Classes.$fRead1Const5_closure:
         const Data.Functor.Classes.$fRead1Const5_info;
         const 0;
 },
 sat_sdESK_entry() //  [R1]
         { info_tbl: [(cdH2b,
                       label: sat_sdESK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH2b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH2c; else goto cdH2d;
       cdH2c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH2d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdH2e,
                       label: Data.Functor.Classes.$fRead1Const5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH2e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdH2i; else goto cdH2h;
       cdH2i: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH2h: // global
           I64[Hp - 16] = sat_sdESK_info;
           P64[Hp] = R2;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.44804241 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec1_info;
         const 0;
 },
 sat_sdESN_entry() //  [R1]
         { info_tbl: [(cdH2F,
                       label: sat_sdESN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH2F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH2G; else goto cdH2H;
       cdH2G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH2H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdESO_entry() //  [R1]
         { info_tbl: [(cdH2I,
                       label: sat_sdESO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH2I: // global
           _sdESO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdH2J; else goto cdH2K;
       cdH2K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdH2M; else goto cdH2L;
       cdH2M: // global
           HpAlloc = 24;
           goto cdH2J;
       cdH2J: // global
           R1 = _sdESO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH2L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdESO::P64;
           _sdESL::P64 = P64[_sdESO::P64 + 16];
           _sdESM::P64 = P64[_sdESO::P64 + 24];
           I64[Hp - 16] = sat_sdESN_info;
           P64[Hp] = _sdESL::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdESM::P64;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdH2N,
                       label: Data.Functor.Classes.$w$cliftReadsPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH2N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdH2R; else goto cdH2Q;
       cdH2R: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH2Q: // global
           I64[Hp - 24] = sat_sdESO_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.456229017 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_entry() //  [R2,
                                                                R5]
         { info_tbl: [(cdH3e,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH3e: // global
           R3 = R5;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.460086087 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec_info;
         const 0;
 },
 w1_sdESU_entry() //  [R1]
         { info_tbl: [(cdH3t,
                       label: w1_sdESU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH3u; else goto cdH3v;
       cdH3u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH3v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdESX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdH3B,
                       label: sat_sdESX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH3B: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdH3E,
                       label: Data.Functor.Classes.$w$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH3E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdH3I; else goto cdH3H;
       cdH3I: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH3H: // global
           I64[Hp - 32] = w1_sdESU_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdESX_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.467804394 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_entry() //  [R2]
         { info_tbl: [(cdH42,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH42: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.472199764 UTC

[section ""data" . Data.Functor.Classes.$fRead1Const_closure" {
     Data.Functor.Classes.$fRead1Const_closure:
         const Data.Functor.Classes.$fRead1Const_info;
         const 0;
 },
 lvl3_sdET2_entry() //  [R1]
         { info_tbl: [(cdH4h,
                       label: lvl3_sdET2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH4h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH4i; else goto cdH4j;
       cdH4i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH4j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdETb_entry() //  [R1]
         { info_tbl: [(cdH4p,
                       label: sat_sdETb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH4p: // global
           R1 = P64[R1 + 6];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdET8_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdH4x,
                       label: sat_sdET8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH4x: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Const5_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdET7_entry() //  [R1]
         { info_tbl: [(cdH4E,
                       label: sat_sdET7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH4E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH4F; else goto cdH4G;
       cdH4F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH4G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdET6_entry() //  [R1, R4]
         { info_tbl: [(cdH4M,
                       label: sat_sdET6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH4M: // global
           R3 = R4;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Const_entry() //  [R2]
         { info_tbl: [(cdH4Q,
                       label: Data.Functor.Classes.$fRead1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH4Q: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdH4U; else goto cdH4T;
       cdH4U: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH4T: // global
           I64[Hp - 128] = lvl3_sdET2_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sdETb_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sdET8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdET7_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdET6_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Const_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Const_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_info;
         const 0;
 },
 sat_sdETd_entry() //  [R1]
         { info_tbl: [(cdH53,
                       label: sat_sdETd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH53: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH54; else goto cdH55;
       cdH54: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH55: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Const_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Const_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdH56,
                       label: Data.Functor.Classes.$fRead1Const_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH56: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdH5a; else goto cdH59;
       cdH5a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH59: // global
           I64[Hp - 16] = sat_sdETd_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.490833605 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either7_closure" {
     Data.Functor.Classes.$fRead1Either7_closure:
         const Data.Functor.Classes.$fRead1Either7_info;
         const 0;
 },
 sat_sdETj_entry() //  [R1]
         { info_tbl: [(cdH62,
                       label: sat_sdETj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH62: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH63; else goto cdH64;
       cdH63: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH64: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either7_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdH65,
                       label: Data.Functor.Classes.$fRead1Either7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH65: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdH69; else goto cdH68;
       cdH69: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either7_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH68: // global
           I64[Hp - 16] = sat_sdETj_info;
           P64[Hp] = R2;
           _sdETh::P64 = R5;
           R5 = R6;
           R4 = _sdETh::P64;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.497581104 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec2_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec2_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec2_info;
         const 0;
 },
 sat_sdETo_entry() //  [R1, R2]
         { info_tbl: [(cdH6x,
                       label: sat_sdETo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH6x: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdETn_entry() //  [R1]
         { info_tbl: [(cdH6E,
                       label: sat_sdETn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH6E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH6F; else goto cdH6G;
       cdH6F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH6G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdETp_entry() //  [R1]
         { info_tbl: [(cdH6H,
                       label: sat_sdETp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH6H: // global
           _sdETp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdH6I; else goto cdH6J;
       cdH6J: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdH6L; else goto cdH6K;
       cdH6L: // global
           HpAlloc = 40;
           goto cdH6I;
       cdH6I: // global
           R1 = _sdETp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdETp::P64;
           _sdETk::P64 = P64[_sdETp::P64 + 16];
           _sdETl::P64 = P64[_sdETp::P64 + 24];
           _sdETm::P64 = P64[_sdETp::P64 + 32];
           I64[Hp - 32] = sat_sdETo_info;
           P64[Hp - 24] = _sdETl::P64;
           I64[Hp - 16] = sat_sdETn_info;
           P64[Hp] = _sdETk::P64;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = _sdETm::P64;
           R3 = Hp - 31;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdH6M,
                       label: Data.Functor.Classes.$w$cliftReadsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH6M: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdH6Q; else goto cdH6P;
       cdH6Q: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH6P: // global
           I64[Hp - 32] = sat_sdETp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.507696071 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_entry() //  [R2,
                                                                 R3, R5]
         { info_tbl: [(cdH7h,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH7h: // global
           R4 = R5;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.511682325 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadListPrec1_closure" {
     Data.Functor.Classes.$w$cliftReadListPrec1_closure:
         const Data.Functor.Classes.$w$cliftReadListPrec1_info;
         const 0;
 },
 w2_sdETw_entry() //  [R1]
         { info_tbl: [(cdH7w,
                       label: w2_sdETw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH7w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH7x; else goto cdH7y;
       cdH7x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH7y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdETz_entry() //  [R1, R2, R3]
         { info_tbl: [(cdH7E,
                       label: sat_sdETz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH7E: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Data.Functor.Classes.$w$cliftReadPrec3_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadListPrec1_entry() //  [R2, R3]
         { info_tbl: [(cdH7H,
                       label: Data.Functor.Classes.$w$cliftReadListPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH7H: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdH7L; else goto cdH7K;
       cdH7L: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadListPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdH7K: // global
           I64[Hp - 40] = w2_sdETw_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdETz_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.520779683 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(cdH85,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH85: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.525426164 UTC

[section ""data" . Data.Functor.Classes.$fRead1Either_closure" {
     Data.Functor.Classes.$fRead1Either_closure:
         const Data.Functor.Classes.$fRead1Either_info;
         const 0;
 },
 sat_sdETM_entry() //  [R1, R2]
         { info_tbl: [(cdH8l,
                       label: sat_sdETM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH8l: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadListPrec1_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdETJ_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdH8t,
                       label: sat_sdETJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH8t: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fRead1Either7_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdETI_entry() //  [R1]
         { info_tbl: [(cdH8A,
                       label: sat_sdETI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH8A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH8B; else goto cdH8C;
       cdH8B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH8C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_$cliftReadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdETH_entry() //  [R1, R2, R4]
         { info_tbl: [(cdH8I,
                       label: sat_sdETH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH8I: // global
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Classes.$w$cliftReadsPrec2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Either_entry() //  [R2]
         { info_tbl: [(cdH8M,
                       label: Data.Functor.Classes.$fRead1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH8M: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdH8Q; else goto cdH8P;
       cdH8Q: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH8P: // global
           I64[Hp - 104] = sat_sdETM_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdETJ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdETI_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sdETH_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 45;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 84;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Classes.$fRead1Either_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Either_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_info;
         const 0;
 },
 sat_sdETO_entry() //  [R1]
         { info_tbl: [(cdH8Z,
                       label: sat_sdETO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH8Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH90; else goto cdH91;
       cdH90: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH91: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$fRead1Either_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$fRead1Either_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdH92,
                       label: Data.Functor.Classes.$fRead1Either_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH92: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdH96; else goto cdH95;
       cdH96: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdH95: // global
           I64[Hp - 16] = sat_sdETO_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.541827774 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Identity4_bytes" {
     Data.Functor.Classes.$fRead1Identity4_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.543951425 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity3_closure" {
     Data.Functor.Classes.$fRead1Identity3_closure:
         const Data.Functor.Classes.$fRead1Identity3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity3_entry() //  [R1]
         { info_tbl: [(cdH9Q,
                       label: Data.Functor.Classes.$fRead1Identity3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH9Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdH9R; else goto cdH9S;
       cdH9R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdH9S: // global
           (_cdH9N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdH9N::I64 == 0) goto cdH9P; else goto cdH9O;
       cdH9P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdH9O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdH9N::I64;
           R2 = Data.Functor.Classes.$fRead1Identity4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.548070133 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity2_closure" {
     Data.Functor.Classes.$fRead1Identity2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.551092276 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec_closure" {
     Data.Functor.Classes.$w$cliftReadPrec_closure:
         const Data.Functor.Classes.$w$cliftReadPrec_info;
         const 0;
 },
 sat_sdETZ_entry() //  [R1, R2]
         { info_tbl: [(cdHau,
                       label: sat_sdETZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHau: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEU0_entry() //  [R1, R2]
         { info_tbl: [(cdHax,
                       label: sat_sdEU0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHax: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHaB; else goto cdHaA;
       cdHaB: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHaA: // global
           _sdETP::P64 = P64[R1 + 7];
           _sdETT::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdETZ_info;
           P64[Hp] = _sdETT::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdETP::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEU3_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHaC,
                       label: sat_sdEU3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHaC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHaD; else goto cdHaE;
       cdHaD: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHaE: // global
           I64[Sp - 24] = block_cdHab_info;
           _sdETP::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdETP::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHaR; else goto cdHac;
       udHaR: // global
           call _cdHab(R1) args: 0, res: 0, upd: 0;
       cdHac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHab() //  [R1]
         { info_tbl: [(cdHab,
                       label: block_cdHab_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHab: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHaH; else goto cdHaG;
       cdHaH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHaG: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdHaJ; else goto cdHaN;
       cdHaJ: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHaN: // global
           I64[Hp - 16] = sat_sdEU0_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdHaK_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHaK() //  [R1]
         { info_tbl: [(cdHaK,
                       label: block_cdHaK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHaK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHaQ; else goto cdHaP;
       cdHaQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHaP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftReadPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cdHaS,
                       label: Data.Functor.Classes.$w$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHaS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHaW; else goto cdHaV;
       cdHaW: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHaV: // global
           I64[Hp - 8] = sat_sdEU3_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.566239458 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity1_closure" {
     Data.Functor.Classes.$fRead1Identity1_closure:
         const Data.Functor.Classes.$fRead1Identity1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdHbx,
                       label: Data.Functor.Classes.$fRead1Identity1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHbx: // global
           _sdEU6::P64 = R4;
           R4 = R5;
           R3 = _sdEU6::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.571351273 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec3_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec3_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec3_info;
         const 0;
 },
 lvl3_sdEUa_entry() //  [R1]
         { info_tbl: [(cdHbQ,
                       label: lvl3_sdEUa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHbR; else goto cdHbS;
       cdHbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHbS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEUi_entry() //  [R1, R2]
         { info_tbl: [(cdHch,
                       label: sat_sdEUi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHch: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEUl_entry() //  [R1, R2]
         { info_tbl: [(cdHcn,
                       label: sat_sdEUl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHcn: // global
           _sdEUg::P64 = R2;
           _sdEUl::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdHco; else goto cdHcp;
       cdHcp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHcr; else goto cdHcq;
       cdHcr: // global
           HpAlloc = 16;
           goto cdHco;
       cdHco: // global
           R2 = _sdEUg::P64;
           R1 = _sdEUl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHcq: // global
           _sdEUa::P64 = P64[_sdEUl::P64 + 7];
           _sdEUc::P64 = P64[_sdEUl::P64 + 15];
           I64[Hp - 8] = sat_sdEUi_info;
           P64[Hp] = _sdEUc::P64;
           I64[Sp - 8] = block_cdHck_info;
           R3 = Hp - 7;
           R2 = _sdEUa::P64;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHck() //  [R1]
         { info_tbl: [(cdHck,
                       label: block_cdHck_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHck: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHcu; else goto cdHct;
       cdHcu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHct: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEUo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHcv,
                       label: sat_sdEUo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHcv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHcw; else goto cdHcx;
       cdHcw: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHcx: // global
           I64[Sp - 24] = block_cdHbY_info;
           _sdEUa::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdEUa::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHcK; else goto cdHbZ;
       udHcK: // global
           call _cdHbY(R1) args: 0, res: 0, upd: 0;
       cdHbZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHbY() //  [R1]
         { info_tbl: [(cdHbY,
                       label: block_cdHbY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHbY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHcA; else goto cdHcz;
       cdHcA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHcz: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdHcC; else goto cdHcG;
       cdHcC: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHcG: // global
           I64[Hp - 16] = sat_sdEUl_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdHcD_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Identity2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHcD() //  [R1]
         { info_tbl: [(cdHcD,
                       label: block_cdHcD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHcD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHcJ; else goto cdHcI;
       cdHcJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHcI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEUp_entry() //  [R1]
         { info_tbl: [(cdHcL,
                       label: sat_sdEUp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHcL: // global
           _sdEUp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHcM; else goto cdHcN;
       cdHcN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHcP; else goto cdHcO;
       cdHcP: // global
           HpAlloc = 40;
           goto cdHcM;
       cdHcM: // global
           R1 = _sdEUp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHcO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEUp::P64;
           _sdEU8::P64 = P64[_sdEUp::P64 + 16];
           _sdEU9::P64 = P64[_sdEUp::P64 + 24];
           I64[Hp - 32] = lvl3_sdEUa_info;
           P64[Hp - 16] = _sdEU8::P64;
           I64[Hp - 8] = sat_sdEUo_info;
           P64[Hp] = Hp - 32;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdEU9::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec3_entry() //  [R2, R3]
         { info_tbl: [(cdHcQ,
                       label: Data.Functor.Classes.$w$cliftReadsPrec3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHcQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdHcU; else goto cdHcT;
       cdHcU: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHcT: // global
           I64[Hp - 24] = sat_sdEUp_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.592746273 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_entry() //  [R2,
                                                                   R4]
         { info_tbl: [(cdHdR,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHdR: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec3_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.597829364 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdEUx_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHe7,
                       label: sat_sdEUx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHe7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udHef_srtd" {
     udHef_srtd:
         const SdF7K_srt+304;
         const 35;
         const 21474836481;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_entry() //  [R2,
                                                                      R3]
         { info_tbl: [(cdHea,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHea: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHee; else goto cdHed;
       cdHee: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHed: // global
           I64[Hp - 8] = sat_sdEUx_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.60470795 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList_closure" {
     Data.Functor.Classes.$w$cliftReadList_closure:
         const Data.Functor.Classes.$w$cliftReadList_info;
         const 0;
 },
 w1_sdEUz_entry() //  [R1, R2]
         { info_tbl: [(cdHeC,
                       label: w1_sdEUz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHeC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEUC_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHeK,
                       label: sat_sdEUC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHeK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udHeX_srtd" {
     udHeX_srtd:
         const SdF7K_srt+304;
         const 33;
         const 4294967297;
 },
 sat_sdEUD_entry() //  [R1]
         { info_tbl: [(cdHeN,
                       label: sat_sdEUD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHeN: // global
           _sdEUD::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdHeO; else goto cdHeP;
       cdHeP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdHeR; else goto cdHeQ;
       cdHeR: // global
           HpAlloc = 32;
           goto cdHeO;
       cdHeO: // global
           R1 = _sdEUD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHeQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEUD::P64;
           _sdEUy::P64 = P64[_sdEUD::P64 + 16];
           I64[Hp - 24] = w1_sdEUz_info;
           P64[Hp - 16] = _sdEUy::P64;
           I64[Hp - 8] = sat_sdEUC_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udHeY_srtd" {
     udHeY_srtd:
         const SdF7K_srt+304;
         const 36;
         const 38654705665;
 },
 Data.Functor.Classes.$w$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdHeS,
                       label: Data.Functor.Classes.$w$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHeS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHeW; else goto cdHeV;
       cdHeW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHeV: // global
           I64[Hp - 16] = sat_sdEUD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.616317657 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Identity_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdHft,
                       label: Data.Functor.Classes.$fRead1Identity_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHft: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.619854296 UTC

[section ""data" . Data.Functor.Classes.$fRead1Identity_closure" {
     Data.Functor.Classes.$fRead1Identity_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Identity1_closure+4;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.621699947 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe7_bytes" {
     Data.Functor.Classes.$fRead1Maybe7_bytes:
         I8[] [78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.623772048 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe6_closure" {
     Data.Functor.Classes.$fRead1Maybe6_closure:
         const Data.Functor.Classes.$fRead1Maybe6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe6_entry() //  [R1]
         { info_tbl: [(cdHfI,
                       label: Data.Functor.Classes.$fRead1Maybe6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHfI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHfJ; else goto cdHfK;
       cdHfJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHfK: // global
           (_cdHfF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdHfF::I64 == 0) goto cdHfH; else goto cdHfG;
       cdHfH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdHfG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdHfF::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.628399507 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_lexeme_closure" {
     Data.Functor.Classes.$fRead1Maybe_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.630907404 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe5_closure" {
     Data.Functor.Classes.$fRead1Maybe5_closure:
         const Data.Functor.Classes.$fRead1Maybe5_info;
         const 0;
 },
 sat_sdEUJ_entry() //  [R1]
         { info_tbl: [(cdHg3,
                       label: sat_sdEUJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHg3: // global
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fRead1Maybe5_entry() //  [R2, R3]
         { info_tbl: [(cdHg9,
                       label: Data.Functor.Classes.$fRead1Maybe5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHg9: // global
           _sdEUH::P64 = R3;
           _sdEUG::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdHga; else goto cdHgb;
       cdHgb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHgd; else goto cdHgc;
       cdHgd: // global
           HpAlloc = 16;
           goto cdHga;
       cdHga: // global
           R3 = _sdEUH::P64;
           R2 = _sdEUG::P64;
           R1 = Data.Functor.Classes.$fRead1Maybe5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHgc: // global
           I64[Hp - 8] = sat_sdEUJ_info;
           P64[Hp] = _sdEUH::P64;
           I64[Sp - 8] = block_cdHg6_info;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Maybe_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHg6() //  [R1]
         { info_tbl: [(cdHg6,
                       label: block_cdHg6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHg6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHgg; else goto cdHgf;
       cdHgg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHgf: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.639287165 UTC

[section ""cstring" . Data.Functor.Classes.$fRead1Maybe4_bytes" {
     Data.Functor.Classes.$fRead1Maybe4_bytes:
         I8[] [74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.641421747 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe3_closure" {
     Data.Functor.Classes.$fRead1Maybe3_closure:
         const Data.Functor.Classes.$fRead1Maybe3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe3_entry() //  [R1]
         { info_tbl: [(cdHgE,
                       label: Data.Functor.Classes.$fRead1Maybe3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHgE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHgF; else goto cdHgG;
       cdHgF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHgG: // global
           (_cdHgB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdHgB::I64 == 0) goto cdHgD; else goto cdHgC;
       cdHgD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdHgC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdHgB::I64;
           R2 = Data.Functor.Classes.$fRead1Maybe4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.646098756 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe2_closure" {
     Data.Functor.Classes.$fRead1Maybe2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.649432988 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadPrec4_info;
         const 0;
 },
 sat_sdEUY_entry() //  [R1, R2]
         { info_tbl: [(cdHhn,
                       label: sat_sdEUY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHhr; else goto cdHhq;
       cdHhr: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHhq: // global
           _sdEUR::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           R1 = _sdEUR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEUZ_entry() //  [R1, R2]
         { info_tbl: [(cdHhs,
                       label: sat_sdEUZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHhw; else goto cdHhv;
       cdHhw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHhv: // global
           _sdEUM::P64 = P64[R1 + 7];
           _sdEUR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sdEUY_info;
           P64[Hp] = _sdEUR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = _sdEUM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEV2_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHhx,
                       label: sat_sdEV2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHhy; else goto cdHhz;
       cdHhy: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHhz: // global
           I64[Sp - 24] = block_cdHh3_info;
           _sdEUM::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sdEUM::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHhM; else goto cdHh4;
       udHhM: // global
           call _cdHh3(R1) args: 0, res: 0, upd: 0;
       cdHh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHh3() //  [R1]
         { info_tbl: [(cdHh3,
                       label: block_cdHh3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHh3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHhC; else goto cdHhB;
       cdHhC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHhB: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto cdHhE; else goto cdHhI;
       cdHhE: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHhI: // global
           I64[Hp - 16] = sat_sdEUZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdHhF_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Classes.$fRead1Maybe2_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHhF() //  [R1]
         { info_tbl: [(cdHhF,
                       label: block_cdHhF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHhL; else goto cdHhK;
       cdHhL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHhK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEV3_entry() //  [R1]
         { info_tbl: [(cdHhN,
                       label: sat_sdEV3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhN: // global
           _sdEV3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHhO; else goto cdHhP;
       cdHhP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHhR; else goto cdHhQ;
       cdHhR: // global
           HpAlloc = 16;
           goto cdHhO;
       cdHhO: // global
           R1 = _sdEV3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHhQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEV3::P64;
           _sdEUM::P64 = P64[_sdEV3::P64 + 16];
           _sdEUN::P64 = P64[_sdEV3::P64 + 24];
           _sdEUO::P64 = P64[_sdEV3::P64 + 32];
           I64[Hp - 8] = sat_sdEV2_info;
           P64[Hp] = _sdEUM::P64;
           R4 = _sdEUO::P64;
           R3 = _sdEUN::P64;
           R2 = Hp - 6;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udHi2_srtd" {
     udHi2_srtd:
         const SdF7K_srt+64;
         const 70;
         const 175921860444161;
         const 52;
 },
 Data.Functor.Classes.$w$cliftReadPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(cdHhU,
                       label: Data.Functor.Classes.$w$cliftReadPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhU: // global
           _sdEUO::P64 = R4;
           _sdEUN::P64 = R3;
           _sdEUM::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHhV; else goto cdHhW;
       cdHhW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHhY; else goto cdHhX;
       cdHhY: // global
           HpAlloc = 40;
           goto cdHhV;
       cdHhV: // global
           R4 = _sdEUO::P64;
           R3 = _sdEUN::P64;
           R2 = _sdEUM::P64;
           R1 = Data.Functor.Classes.$w$cliftReadPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHhX: // global
           I64[Hp - 32] = sat_sdEV3_info;
           P64[Hp - 16] = _sdEUM::P64;
           P64[Hp - 8] = _sdEUN::P64;
           P64[Hp] = _sdEUO::P64;
           I64[Sp - 16] = block_cdHhS_info;
           R4 = _sdEUO::P64;
           R3 = _sdEUN::P64;
           R2 = Data.Functor.Classes.$fRead1Maybe5_closure+2;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHhS() //  [R1]
         { info_tbl: [(cdHhS,
                       label: block_cdHhS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHhS: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.66985882 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe1_closure" {
     Data.Functor.Classes.$fRead1Maybe1_closure:
         const Data.Functor.Classes.$fRead1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe1_entry() //  [R2, R4, R5]
         { info_tbl: [(cdHiR,
                       label: Data.Functor.Classes.$fRead1Maybe1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHiR: // global
           _sdEV6::P64 = R4;
           R4 = R5;
           R3 = _sdEV6::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.674740703 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadsPrec4_closure" {
     Data.Functor.Classes.$w$cliftReadsPrec4_closure:
         const Data.Functor.Classes.$w$cliftReadsPrec4_info;
         const 0;
 },
 sat_sdEVa_entry() //  [R1, R2]
         { info_tbl: [(cdHjb,
                       label: sat_sdEVa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHjb: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEVb_entry() //  [R1]
         { info_tbl: [(cdHje,
                       label: sat_sdEVb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHje: // global
           _sdEVb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHjf; else goto cdHjg;
       cdHjg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHji; else goto cdHjh;
       cdHji: // global
           HpAlloc = 16;
           goto cdHjf;
       cdHjf: // global
           R1 = _sdEVb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHjh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEVb::P64;
           _sdEV8::P64 = P64[_sdEVb::P64 + 16];
           _sdEV9::P64 = P64[_sdEVb::P64 + 24];
           I64[Hp - 8] = sat_sdEVa_info;
           P64[Hp] = _sdEV8::P64;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = _sdEV9::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Classes.$w$cliftReadsPrec4_entry() //  [R2, R3]
         { info_tbl: [(cdHjj,
                       label: Data.Functor.Classes.$w$cliftReadsPrec4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHjj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdHjn; else goto cdHjm;
       cdHjn: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadsPrec4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHjm: // global
           I64[Hp - 24] = sat_sdEVb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.683215537 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_entry() //  [R2,
                                                                R4]
         { info_tbl: [(cdHjI,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHjI: // global
           R3 = R4;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadsPrec4_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.687202671 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info;
         const 0;
 },
 sat_sdEVj_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHjY,
                       label: sat_sdEVj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHjY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udHk6_srtd" {
     udHk6_srtd:
         const SdF7K_srt+304;
         const 43;
         const 4947802324993;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cdHk1,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHk1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHk5; else goto cdHk4;
       cdHk5: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHk4: // global
           I64[Hp - 8] = sat_sdEVj_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.694600224 UTC

[section ""data" . Data.Functor.Classes.$w$cliftReadList1_closure" {
     Data.Functor.Classes.$w$cliftReadList1_closure:
         const Data.Functor.Classes.$w$cliftReadList1_info;
         const 0;
 },
 w1_sdEVl_entry() //  [R1, R2]
         { info_tbl: [(cdHkt,
                       label: w1_sdEVl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHkt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEVo_entry() //  [R1, R2, R3]
         { info_tbl: [(cdHkB,
                       label: sat_sdEVo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHkB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Classes.$w$cliftReadPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . udHkO_srtd" {
     udHkO_srtd:
         const SdF7K_srt+304;
         const 40;
         const 549755813889;
 },
 sat_sdEVp_entry() //  [R1]
         { info_tbl: [(cdHkE,
                       label: sat_sdEVp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHkE: // global
           _sdEVp::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdHkF; else goto cdHkG;
       cdHkG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdHkI; else goto cdHkH;
       cdHkI: // global
           HpAlloc = 32;
           goto cdHkF;
       cdHkF: // global
           R1 = _sdEVp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHkH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEVp::P64;
           _sdEVk::P64 = P64[_sdEVp::P64 + 16];
           I64[Hp - 24] = w1_sdEVl_info;
           P64[Hp - 16] = _sdEVk::P64;
           I64[Hp - 8] = sat_sdEVo_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Identity5_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . udHkP_srtd" {
     udHkP_srtd:
         const SdF7K_srt+304;
         const 44;
         const 9345848836097;
 },
 Data.Functor.Classes.$w$cliftReadList1_entry() //  [R2]
         { info_tbl: [(cdHkJ,
                       label: Data.Functor.Classes.$w$cliftReadList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHkJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHkN; else goto cdHkM;
       cdHkN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftReadList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHkM: // global
           I64[Hp - 16] = sat_sdEVp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.705957242 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure" {
     Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure:
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info;
         const 0;
 },
 Data.Functor.Classes.$fRead1Maybe_$cliftReadList_entry() //  [R2]
         { info_tbl: [(cdHlk,
                       label: Data.Functor.Classes.$fRead1Maybe_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHlk: // global
           R2 = R2;
           call Data.Functor.Classes.$w$cliftReadList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.709300282 UTC

[section ""data" . Data.Functor.Classes.$fRead1Maybe_closure" {
     Data.Functor.Classes.$fRead1Maybe_closure:
         const Data.Functor.Classes.C:Read1_con_info;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec_closure+3;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadList_closure+2;
         const Data.Functor.Classes.$fRead1Maybe1_closure+4;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.713362453 UTC

[section ""data" . Data.Functor.Classes.readsBinaryWith_closure" {
     Data.Functor.Classes.readsBinaryWith_closure:
         const Data.Functor.Classes.readsBinaryWith_info;
 },
 go1_sdEVI_entry() //  [R1, R2]
         { info_tbl: [(cdHm4,
                       label: go1_sdEVI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHm4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHm5; else goto cdHm6;
       cdHm5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHm6: // global
           I64[Sp - 40] = block_cdHlX_info;
           _sdEVI::P64 = R1;
           _sdEVv::P64 = P64[R1 + 7];
           _sdEVF::P64 = P64[R1 + 15];
           _sdEVH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sdEVv::P64;
           P64[Sp - 24] = _sdEVF::P64;
           P64[Sp - 16] = _sdEVH::P64;
           P64[Sp - 8] = _sdEVI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udHmq; else goto cdHlY;
       udHmq: // global
           call _cdHlX(R1) args: 0, res: 0, upd: 0;
       cdHlY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHlX() //  [R1]
         { info_tbl: [(cdHlX,
                       label: block_cdHlX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHlX: // global
           if (R1 & 7 == 1) goto cdHm1; else goto cdHm2;
       cdHm1: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdHm2: // global
           I64[Sp] = block_cdHmc_info;
           _sdEVM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sdEVM::P64;
           if (R1 & 7 != 0) goto udHmp; else goto cdHmd;
       udHmp: // global
           call _cdHmc(R1) args: 0, res: 0, upd: 0;
       cdHmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHmc() //  [R1]
         { info_tbl: [(cdHmc,
                       label: block_cdHmc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHmc: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdHmo; else goto cdHmn;
       cdHmo: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHmn: // global
           _sdEVO::P64 = P64[R1 + 7];
           _sdEVP::P64 = P64[R1 + 15];
           I64[Hp - 112] = stg_ap_2_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 24];
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdEVO::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = _sdEVP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sdEVz_entry() //  [R1, R2]
         { info_tbl: [(cdHmv,
                       label: go_sdEVz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHmv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHmw; else goto cdHmx;
       cdHmw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHmx: // global
           I64[Sp - 32] = block_cdHlG_info;
           _sdEVz::P64 = R1;
           _sdEVt::P64 = P64[R1 + 7];
           _sdEVv::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sdEVt::P64;
           P64[Sp - 16] = _sdEVv::P64;
           P64[Sp - 8] = _sdEVz::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udHmK; else goto cdHlH;
       udHmK: // global
           call _cdHlG(R1) args: 0, res: 0, upd: 0;
       cdHlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHlG() //  [R1]
         { info_tbl: [(cdHlG,
                       label: block_cdHlG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHlG: // global
           if (R1 & 7 == 1) goto cdHms; else goto cdHmt;
       cdHms: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHmt: // global
           I64[Sp - 8] = block_cdHlM_info;
           _sdEVD::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdEVD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udHmJ; else goto cdHlN;
       udHmJ: // global
           call _cdHlM(R1) args: 0, res: 0, upd: 0;
       cdHlN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHlM() //  [R1]
         { info_tbl: [(cdHlM,
                       label: block_cdHlM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHlM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHmE; else goto cdHmD;
       cdHmE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHmD: // global
           _sdEVF::P64 = P64[R1 + 7];
           _sdEVG::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = go1_sdEVI_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sdEVF::P64;
           P64[Hp] = Hp - 56;
           I64[Sp + 24] = block_cdHmA_info;
           R3 = _sdEVG::P64;
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 16];
           P64[Sp + 32] = Hp - 23;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHmA() //  [R1]
         { info_tbl: [(cdHmA,
                       label: block_cdHmA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHmA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sdEVI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdHmP,
                       label: Data.Functor.Classes.readsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHmP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdHmQ; else goto cdHmR;
       cdHmQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHmR: // global
           I64[Sp - 32] = block_cdHlw_info;
           _sdEVt::P64 = R3;
           R3 = R4;
           _sdEVs::P64 = R2;
           R2 = R6;
           P64[Sp - 24] = _sdEVs::P64;
           P64[Sp - 16] = _sdEVt::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHlw() //  [R1]
         { info_tbl: [(cdHlw,
                       label: block_cdHlw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHlw: // global
           if (R1 & 7 == 1) goto cdHmM; else goto cdHmN;
       cdHmM: // global
           R1 = []_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHmN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHmX; else goto cdHmW;
       cdHmX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHmW: // global
           I64[Hp - 16] = go_sdEVz_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdHmU_info;
           R3 = P64[Sp + 32];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[Sp + 8];
           P64[Sp + 32] = Hp - 15;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHmU() //  [R1]
         { info_tbl: [(cdHmU,
                       label: block_cdHmU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHmU: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdEVz_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.73809338 UTC

[section ""data" . Data.Functor.Classes.$wreadBinaryWith_closure" {
     Data.Functor.Classes.$wreadBinaryWith_closure:
         const Data.Functor.Classes.$wreadBinaryWith_info;
         const 0;
 },
 lvl3_sdEW3_entry() //  [R1]
         { info_tbl: [(cdHoA,
                       label: lvl3_sdEW3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHoA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHoH; else goto cdHoI;
       cdHoH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHoI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdHox_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHoM; else goto cdHoy;
       udHoM: // global
           call _cdHox(R1) args: 0, res: 0, upd: 0;
       cdHoy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdHox() //  [R1]
         { info_tbl: [(cdHox,
                       label: block_cdHox_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHox: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHoL; else goto cdHoK;
       cdHoL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdHoK: // global
           _sdEW6::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdEW6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEWa_entry() //  [R1, R2]
         { info_tbl: [(cdHoY,
                       label: sat_sdEWa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHoY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHp2; else goto cdHp1;
       cdHp2: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHp1: // global
           _sdEVY::P64 = P64[R1 + 7];
           _sdEW0::P64 = P64[R1 + 15];
           _sdEW7::P64 = P64[R1 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdEVY::P64;
           P64[Hp - 8] = _sdEW7::P64;
           P64[Hp] = R2;
           R2 = Hp - 32;
           R1 = _sdEW0::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEWb_entry() //  [R1, R2]
         { info_tbl: [(cdHp3,
                       label: sat_sdEWb_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHp3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdHp7; else goto cdHp6;
       cdHp7: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHp6: // global
           _sdEVW::P64 = P64[R1 + 7];
           _sdEVY::P64 = P64[R1 + 15];
           _sdEW0::P64 = P64[R1 + 23];
           _sdEW3::P64 = P64[R1 + 31];
           I64[Hp - 24] = sat_sdEWa_info;
           P64[Hp - 16] = _sdEVY::P64;
           P64[Hp - 8] = _sdEW0::P64;
           P64[Hp] = R2;
           R3 = Hp - 23;
           R2 = _sdEW3::P64;
           R1 = _sdEVW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEWc_entry() //  [R1, R2]
         { info_tbl: [(cdHp8,
                       label: sat_sdEWc_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHp8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHpc; else goto cdHpb;
       cdHpc: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHpb: // global
           _sdEVV::P64 = P64[R1 + 7];
           _sdEVW::P64 = P64[R1 + 15];
           _sdEVY::P64 = P64[R1 + 23];
           _sdEVZ::P64 = P64[R1 + 31];
           _sdEW0::P64 = P64[R1 + 39];
           I64[Hp - 56] = lvl3_sdEW3_info;
           P64[Hp - 40] = _sdEVZ::P64;
           I64[Hp - 32] = sat_sdEWb_info;
           P64[Hp - 24] = _sdEVW::P64;
           P64[Hp - 16] = _sdEVY::P64;
           P64[Hp - 8] = _sdEW0::P64;
           _cdHot::P64 = Hp - 56;
           P64[Hp] = _cdHot::P64;
           R3 = Hp - 31;
           R2 = _cdHot::P64;
           R1 = _sdEVV::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wreadBinaryWith_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cdHpe,
                       label: Data.Functor.Classes.$wreadBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHpe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHpi; else goto cdHph;
       cdHpi: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$wreadBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHph: // global
           I64[Hp - 56] = sat_sdEWc_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           I64[Hp - 8] = Text.Read.Lex.Ident_con_info;
           P64[Hp] = R4;
           R3 = Hp - 55;
           R2 = Hp - 4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.753171172 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith1_closure" {
     Data.Functor.Classes.readBinaryWith1_closure:
         const Data.Functor.Classes.readBinaryWith1_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith1_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdHpX,
                       label: Data.Functor.Classes.readBinaryWith1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHpX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdHpY; else goto cdHpZ;
       cdHpY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readBinaryWith1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHpZ: // global
           _sdEWi::P64 = P64[Sp];
           I64[Sp] = block_cdHpU_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           P64[Sp - 8] = _sdEWi::P64;
           Sp = Sp - 8;
           call Data.Functor.Classes.$wreadBinaryWith_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _cdHpU() //  [R1]
         { info_tbl: [(cdHpU,
                       label: block_cdHpU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHq2; else goto cdHq1;
       cdHq2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHq1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.760428346 UTC

[section ""data" . Data.Functor.Classes.readBinaryWith_closure" {
     Data.Functor.Classes.readBinaryWith_closure:
         const Data.Functor.Classes.readBinaryWith_info;
         const 0;
 },
 Data.Functor.Classes.readBinaryWith_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cdHqi,
                       label: Data.Functor.Classes.readBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHqi: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.readBinaryWith1_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.765121564 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnaryWith_closure" {
     Data.Functor.Classes.$wshowsUnaryWith_closure:
         const Data.Functor.Classes.$wshowsUnaryWith_info;
 },
 Data.Functor.Classes.$wshowsUnaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHqq: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdEWp_entry() //  [R1]
         { info_tbl: [(cdHqy,
                       label: g_sdEWp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHqy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHqz; else goto cdHqA;
       cdHqz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHqA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEWu_entry() //  [R1, R2]
         { info_tbl: [(cdHqL,
                       label: sat_sdEWu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHqL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHqP; else goto cdHqO;
       cdHqP: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHqO: // global
           _sdEWm::P64 = P64[R1 + 7];
           _sdEWp::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdEWp::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdEWm::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEWx_entry() //  [R1]
         { info_tbl: [(cdHr5,
                       label: sat_sdEWx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHr5: // global
           _sdEWx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHr6; else goto cdHr7;
       cdHr7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHr9; else goto cdHr8;
       cdHr9: // global
           HpAlloc = 24;
           goto cdHr6;
       cdHr6: // global
           R1 = _sdEWx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHr8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEWx::P64;
           _sdEWp::P64 = P64[_sdEWx::P64 + 16];
           _sdEWv::P64 = P64[_sdEWx::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdEWv::P64;
           R2 = Hp - 14;
           R1 = _sdEWp::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEWz_entry() //  [R1]
         { info_tbl: [(cdHrb,
                       label: sat_sdEWz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHrb: // global
           _sdEWz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHrc; else goto cdHrd;
       cdHrd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHrf; else goto cdHre;
       cdHrf: // global
           HpAlloc = 56;
           goto cdHrc;
       cdHrc: // global
           R1 = _sdEWz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHre: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEWz::P64;
           _sdEWm::P64 = P64[_sdEWz::P64 + 16];
           _sdEWp::P64 = P64[_sdEWz::P64 + 24];
           _sdEWv::P64 = P64[_sdEWz::P64 + 32];
           I64[Hp - 48] = sat_sdEWx_info;
           P64[Hp - 32] = _sdEWp::P64;
           P64[Hp - 24] = _sdEWv::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdEWm::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEWA_entry() //  [R1, R2]
         { info_tbl: [(cdHrh,
                       label: sat_sdEWA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHrh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHrl; else goto cdHrk;
       cdHrl: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHrk: // global
           _sdEWm::P64 = P64[R1 + 7];
           _sdEWp::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdEWz_info;
           P64[Hp - 40] = _sdEWm::P64;
           P64[Hp - 32] = _sdEWp::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHrp,
                       label: Data.Functor.Classes.$wshowsUnaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHrp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHrt; else goto cdHrs;
       cdHrt: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnaryWith_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdHrs: // global
           I64[Hp - 48] = g_sdEWp_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdHqu::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdHrn; else goto cdHro;
       cdHrn: // global
           I64[Hp - 16] = sat_sdEWu_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdHqu::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHro: // global
           I64[Hp - 16] = sat_sdEWA_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdHqu::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.782243614 UTC

[section ""data" . Data.Functor.Classes.showsUnaryWith_closure" {
     Data.Functor.Classes.showsUnaryWith_closure:
         const Data.Functor.Classes.showsUnaryWith_info;
 },
 Data.Functor.Classes.showsUnaryWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHsm,
                       label: Data.Functor.Classes.showsUnaryWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHsm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdHsn; else goto cdHso;
       cdHsn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnaryWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHso: // global
           I64[Sp - 32] = block_cdHsj_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udHss; else goto cdHsk;
       udHss: // global
           call _cdHsj(R1) args: 0, res: 0, upd: 0;
       cdHsk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHsj() //  [R1]
         { info_tbl: [(cdHsj,
                       label: block_cdHsj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHsj: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.78849284 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdHsK,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHsK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHsL; else goto cdHsM;
       cdHsL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHsM: // global
           I64[Sp - 16] = block_cdHsH_info;
           R1 = R6;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udHsQ; else goto cdHsI;
       udHsQ: // global
           call _cdHsH(R1) args: 0, res: 0, upd: 0;
       cdHsI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHsH() //  [R1]
         { info_tbl: [(cdHsH,
                       label: block_cdHsH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHsH: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.79465565 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_info;
         const 0;
 },
 sat_sdEWW_entry() //  [R1, R2]
         { info_tbl: [(cdHta,
                       label: sat_sdEWW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHta: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow2Const_$cliftShowList2_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdHtd,
                       label: Data.Functor.Classes.$fShow2Const_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHtd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHth; else goto cdHtg;
       cdHth: // global
           HpAlloc = 16;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHtg: // global
           I64[Hp - 8] = sat_sdEWW_info;
           P64[Hp] = R2;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.801159003 UTC

[section ""data" . Data.Functor.Classes.$fShow2Const_closure" {
     Data.Functor.Classes.$fShow2Const_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.80349412 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info;
         const 0;
 },
 sat_sdEX4_entry() //  [R1]
         { info_tbl: [(cdHtE,
                       label: sat_sdEX4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHtE: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5, R6]
         { info_tbl: [(cdHtH,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHtH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHtI; else goto cdHtJ;
       cdHtI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHtJ: // global
           I64[Sp - 24] = block_cdHtv_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R6;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHtN; else goto cdHtw;
       udHtN: // global
           call _cdHtv(R1) args: 0, res: 0, upd: 0;
       cdHtw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHtv() //  [R1]
         { info_tbl: [(cdHtv,
                       label: block_cdHtv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHtv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHtM; else goto cdHtL;
       cdHtM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHtL: // global
           _sdEX3::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sdEX4_info;
           P64[Hp] = P64[Sp + 8];
           R5 = P64[Sp + 16];
           R4 = _sdEX3::I64;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.811674566 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Const_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_info;
         const 0;
 },
 lvl3_sdEXa_entry() //  [R1]
         { info_tbl: [(cdHub,
                       label: lvl3_sdEXa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHub: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHuc; else goto cdHud;
       cdHuc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHud: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEXc_entry() //  [R1, R2]
         { info_tbl: [(cdHuj,
                       label: sat_sdEXc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHuj: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Const3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_$cliftShowList_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cdHum,
                       label: Data.Functor.Classes.$fShow1Const_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHum: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHuq; else goto cdHup;
       cdHuq: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHup: // global
           I64[Hp - 32] = lvl3_sdEXa_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sdEXc_info;
           P64[Hp] = Hp - 32;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.819983767 UTC

[section ""data" . Data.Functor.Classes.$fShow1Const_closure" {
     Data.Functor.Classes.$fShow1Const_closure:
         const Data.Functor.Classes.$fShow1Const_info;
         const 0;
 },
 sat_sdEXf_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdHuP,
                       label: sat_sdEXf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHuP: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowList_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEXe_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdHuX,
                       label: sat_sdEXe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHuX: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_entry(R6,
                                                                        R5,
                                                                        R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Const_entry() //  [R2]
         { info_tbl: [(cdHv1,
                       label: Data.Functor.Classes.$fShow1Const_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHv1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHv5; else goto cdHv4;
       cdHv5: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Const_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHv4: // global
           I64[Hp - 48] = sat_sdEXf_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdEXe_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.828211969 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cdHvx,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHvx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHvy; else goto cdHvz;
       cdHvy: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHvz: // global
           I64[Sp - 24] = block_cdHvq_info;
           R1 = P64[Sp];
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHvU; else goto cdHvr;
       udHvU: // global
           call _cdHvq(R1) args: 0, res: 0, upd: 0;
       cdHvr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHvq() //  [R1]
         { info_tbl: [(cdHvq,
                       label: block_cdHvq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHvq: // global
           _sdEXk::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdHvu; else goto cdHvv;
       cdHvu: // global
           I64[Sp + 8] = block_cdHvC_info;
           _sdEXn::P64 = P64[R1 + 7];
           R1 = _sdEXk::P64;
           P64[Sp + 16] = _sdEXn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udHvS; else goto cdHvE;
       udHvS: // global
           call _cdHvC(R1) args: 0, res: 0, upd: 0;
       cdHvE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdHvv: // global
           I64[Sp] = block_cdHvL_info;
           _sdEXq::P64 = P64[R1 + 6];
           R1 = _sdEXk::P64;
           P64[Sp + 24] = _sdEXq::P64;
           if (R1 & 7 != 0) goto udHvT; else goto cdHvN;
       udHvT: // global
           call _cdHvL(R1) args: 0, res: 0, upd: 0;
       cdHvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHvC() //  [R1]
         { info_tbl: [(cdHvC,
                       label: block_cdHvC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHvC: // global
           R5 = P64[Sp + 8];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 _cdHvL() //  [R1]
         { info_tbl: [(cdHvL,
                       label: block_cdHvL_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHvL: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.840119405 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList4_closure" {
     Data.Functor.Classes.$w$cliftShowList4_closure:
         const Data.Functor.Classes.$w$cliftShowList4_info;
         const 0;
 },
 sat_sdEXB_entry() //  [R1, R2]
         { info_tbl: [(cdHwx,
                       label: sat_sdEXB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHwx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHwy; else goto cdHwz;
       cdHwy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHwz: // global
           I64[Sp - 24] = block_cdHwq_info;
           _sdEXt::P64 = P64[R1 + 7];
           _sdEXu::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdEXt::P64;
           P64[Sp - 8] = _sdEXu::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHwG; else goto cdHwr;
       udHwG: // global
           call _cdHwq(R1) args: 0, res: 0, upd: 0;
       cdHwr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHwq() //  [R1]
         { info_tbl: [(cdHwq,
                       label: block_cdHwq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHwq: // global
           if (R1 & 7 == 1) goto cdHwu; else goto cdHwv;
       cdHwu: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdHwv: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHwH,
                       label: Data.Functor.Classes.$w$cliftShowList4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHwH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHwL; else goto cdHwK;
       cdHwL: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHwK: // global
           I64[Hp - 16] = sat_sdEXB_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sdEXv::P64 = R4;
           R4 = R5;
           R3 = _sdEXv::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.84834226 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure" {
     Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure:
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_info;
         const 0;
 },
 Data.Functor.Classes.$fShow2Either_$cliftShowList2_entry() //  [R2,
                                                                 R4, R6]
         { info_tbl: [(cdHx6,
                       label: Data.Functor.Classes.$fShow2Either_$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHx6: // global
           R5 = P64[Sp];
           _sdEXE::P64 = R4;
           R4 = R6;
           R3 = _sdEXE::P64;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Classes.$w$cliftShowList4_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.851901855 UTC

[section ""data" . Data.Functor.Classes.$fShow2Either_closure" {
     Data.Functor.Classes.$fShow2Either_closure:
         const Data.Functor.Classes.C:Show2_con_info;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure+6;
         const Data.Functor.Classes.$fShow2Either_$cliftShowList2_closure+6;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.854429024 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowsPrec_closure" {
     Data.Functor.Classes.$w$cliftShowsPrec_closure:
         const Data.Functor.Classes.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHxf: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEXO_entry() //  [R1]
         { info_tbl: [(cdHxs,
                       label: sat_sdEXO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHxs: // global
           R2 = P64[R1 + 16];
           call GHC.Show.showsPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHxz,
                       label: Data.Functor.Classes.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHxz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdHxA; else goto cdHxB;
       cdHxA: // global
           R1 = Data.Functor.Classes.$w$cliftShowsPrec_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdHxB: // global
           I64[Sp - 32] = block_cdHxj_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udHxI; else goto cdHxk;
       udHxI: // global
           call _cdHxj(R1) args: 0, res: 0, upd: 0;
       cdHxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHxj() //  [R1]
         { info_tbl: [(cdHxj,
                       label: block_cdHxj_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHxj: // global
           _sdEXK::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cdHxw; else goto cdHxx;
       cdHxw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHxE; else goto cdHxD;
       cdHxE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHxD: // global
           _sdEXN::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sdEXO_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdEXN::P64;
           R4 = _sdEXK::I64;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = Hp - 16;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdHxx: // global
           R5 = P64[R1 + 6];
           R4 = _sdEXK::I64;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.864186169 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cdHy9,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHy9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdHya; else goto cdHyb;
       cdHya: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHyb: // global
           I64[Sp - 32] = block_cdHy6_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udHyf; else goto cdHy7;
       udHyf: // global
           call _cdHy6(R1) args: 0, res: 0, upd: 0;
       cdHy7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHy6() //  [R1]
         { info_tbl: [(cdHy6,
                       label: block_cdHy6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHy6: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$w$cliftShowsPrec_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.870855607 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList1_closure" {
     Data.Functor.Classes.$w$cliftShowList1_closure:
         const Data.Functor.Classes.$w$cliftShowList1_info;
         const 0;
 },
 lvl3_sdEY1_entry() //  [R1]
         { info_tbl: [(cdHyy,
                       label: lvl3_sdEY1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHyy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHyz; else goto cdHyA;
       cdHyz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHyA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEY6_entry() //  [R1, R2]
         { info_tbl: [(cdHyN,
                       label: sat_sdEY6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHyN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHyO; else goto cdHyP;
       cdHyO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHyP: // global
           I64[Sp - 24] = block_cdHyG_info;
           _sdEXY::P64 = P64[R1 + 7];
           _sdEY1::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sdEXY::P64;
           P64[Sp - 8] = _sdEY1::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHyW; else goto cdHyH;
       udHyW: // global
           call _cdHyG(R1) args: 0, res: 0, upd: 0;
       cdHyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHyG() //  [R1]
         { info_tbl: [(cdHyG,
                       label: block_cdHyG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHyG: // global
           if (R1 & 7 == 1) goto cdHyK; else goto cdHyL;
       cdHyK: // global
           R5 = P64[R1 + 7];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either5_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cdHyL: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Either2_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHyX,
                       label: Data.Functor.Classes.$w$cliftShowList1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHyX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdHz1; else goto cdHz0;
       cdHz1: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHz0: // global
           I64[Hp - 40] = lvl3_sdEY1_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sdEY6_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           _sdEXZ::P64 = R4;
           R4 = R5;
           R3 = _sdEXZ::P64;
           R2 = Hp - 15;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.881721039 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Either_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Either_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Either_$cliftShowList_entry() //  [R2,
                                                                R3, R5, R6]
         { info_tbl: [(cdHzt,
                       label: Data.Functor.Classes.$fShow1Either_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHzt: // global
           _sdEYa::P64 = R5;
           R5 = R6;
           R4 = _sdEYa::P64;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.88563662 UTC

[section ""data" . Data.Functor.Classes.$fShow1Either_closure" {
     Data.Functor.Classes.$fShow1Either_closure:
         const Data.Functor.Classes.$fShow1Either_info;
         const 0;
 },
 sat_sdEYi_entry() //  [R1, R2, R4, R5]
         { info_tbl: [(cdHzJ,
                       label: sat_sdEYi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHzJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$w$cliftShowList1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEYd_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdHzR,
                       label: sat_sdEYd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHzR: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Either_entry() //  [R2]
         { info_tbl: [(cdHzV,
                       label: Data.Functor.Classes.$fShow1Either_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHzV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHzZ; else goto cdHzY;
       cdHzZ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Either_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHzY: // global
           I64[Hp - 48] = sat_sdEYi_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sdEYd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 28;
           P64[Hp] = Hp - 44;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.893561997 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdHAn,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHAn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHAo; else goto cdHAp;
       cdHAo: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHAp: // global
           I64[Sp - 24] = block_cdHAk_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHAt; else goto cdHAl;
       udHAt: // global
           call _cdHAk(R1) args: 0, res: 0, upd: 0;
       cdHAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHAk() //  [R1]
         { info_tbl: [(cdHAk,
                       label: block_cdHAk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHAk: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.8994998 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_info;
         const 0;
 },
 sat_sdEYu_entry() //  [R1, R2]
         { info_tbl: [(cdHAN,
                       label: sat_sdEYu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHAN: // global
           R5 = R2;
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Identity3_closure;
           R2 = P64[R1 + 7];
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$fShow1Identity_$cliftShowList_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdHAQ,
                       label: Data.Functor.Classes.$fShow1Identity_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHAQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHAU; else goto cdHAT;
       cdHAU: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHAT: // global
           I64[Hp - 8] = sat_sdEYu_info;
           P64[Hp] = R2;
           _sdEYr::P64 = R4;
           R4 = R5;
           R3 = _sdEYr::P64;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.904897813 UTC

[section ""data" . Data.Functor.Classes.$fShow1Identity_closure" {
     Data.Functor.Classes.$fShow1Identity_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.906914707 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe1_closure" {
     Data.Functor.Classes.$fShow1Maybe1_closure:
         const Data.Functor.Classes.$fShow1Maybe1_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe1_entry() //  [R2]
         { info_tbl: [(cdHB8,
                       label: Data.Functor.Classes.$fShow1Maybe1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHB8: // global
           R3 = R2;
           R2 = Data.Functor.Classes.$fRead1Maybe6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.91113797 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdHBq,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHBq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHBr; else goto cdHBs;
       cdHBr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHBs: // global
           I64[Sp - 24] = block_cdHBj_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHBG; else goto cdHBk;
       udHBG: // global
           call _cdHBj(R1) args: 0, res: 0, upd: 0;
       cdHBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHBj() //  [R1]
         { info_tbl: [(cdHBj,
                       label: block_cdHBj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHBj: // global
           if (R1 & 7 == 1) goto cdHBn; else goto cdHBo;
       cdHBn: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHBo: // global
           I64[Sp] = block_cdHBy_info;
           _sdEYA::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdEYA::P64;
           if (R1 & 7 != 0) goto udHBF; else goto cdHBA;
       udHBF: // global
           call _cdHBy(R1) args: 0, res: 0, upd: 0;
       cdHBA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHBy() //  [R1]
         { info_tbl: [(cdHBy,
                       label: block_cdHBy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHBy: // global
           R5 = P64[Sp + 16];
           R4 = I64[R1 + 7];
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.920383174 UTC

[section ""data" . Data.Functor.Classes.$w$cliftShowList2_closure" {
     Data.Functor.Classes.$w$cliftShowList2_closure:
         const Data.Functor.Classes.$w$cliftShowList2_info;
         const 0;
 },
 sat_sdEYJ_entry() //  [R1, R2]
         { info_tbl: [(cdHCf,
                       label: sat_sdEYJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHCg; else goto cdHCh;
       cdHCg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHCh: // global
           I64[Sp - 16] = block_cdHC8_info;
           _sdEYD::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sdEYD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udHCo; else goto cdHC9;
       udHCo: // global
           call _cdHC8(R1) args: 0, res: 0, upd: 0;
       cdHC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHC8() //  [R1]
         { info_tbl: [(cdHC8,
                       label: block_cdHC8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHC8: // global
           if (R1 & 7 == 1) goto cdHCc; else goto cdHCd;
       cdHCc: // global
           R1 = Data.Functor.Classes.$fShow1Maybe1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHCd: // global
           R5 = P64[R1 + 6];
           R4 = 0;
           R3 = Data.Functor.Classes.$fRead1Maybe3_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$w$cliftShowList2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdHCp,
                       label: Data.Functor.Classes.$w$cliftShowList2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHCp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHCt; else goto cdHCs;
       cdHCt: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.$w$cliftShowList2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHCs: // global
           I64[Hp - 8] = sat_sdEYJ_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.928423347 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure" {
     Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure:
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info;
         const 0;
 },
 Data.Functor.Classes.$fShow1Maybe_$cliftShowList_entry() //  [R2,
                                                               R4, R5]
         { info_tbl: [(cdHCP,
                       label: Data.Functor.Classes.$fShow1Maybe_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHCP: // global
           _sdEYM::P64 = R4;
           R4 = R5;
           R3 = _sdEYM::P64;
           R2 = R2;
           call Data.Functor.Classes.$w$cliftShowList2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.932275073 UTC

[section ""data" . Data.Functor.Classes.$fShow1Maybe_closure" {
     Data.Functor.Classes.$fShow1Maybe_closure:
         const Data.Functor.Classes.C:Show1_con_info;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure+4;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowList_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.935951813 UTC

[section ""data" . Data.Functor.Classes.$wshowsBinaryWith_closure" {
     Data.Functor.Classes.$wshowsBinaryWith_closure:
         const Data.Functor.Classes.$wshowsBinaryWith_info;
 },
 Data.Functor.Classes.$wshowsBinaryWith_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHCY: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 f_sdEYU_entry() //  [R1]
         { info_tbl: [(cdHD6,
                       label: f_sdEYU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHD6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHD7; else goto cdHD8;
       cdHD7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHD8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sdEYV_entry() //  [R1]
         { info_tbl: [(cdHDd,
                       label: g_sdEYV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHDd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdHDe; else goto cdHDf;
       cdHDe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHDf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Functor.Classes.$fRead1Const1_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZ0_entry() //  [R1]
         { info_tbl: [(cdHDu,
                       label: sat_sdEZ0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHDu: // global
           _sdEZ0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHDv; else goto cdHDw;
       cdHDw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHDy; else goto cdHDx;
       cdHDy: // global
           HpAlloc = 56;
           goto cdHDv;
       cdHDv: // global
           R1 = _sdEZ0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHDx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEZ0::P64;
           _sdEYU::P64 = P64[_sdEZ0::P64 + 16];
           _sdEYV::P64 = P64[_sdEZ0::P64 + 24];
           _sdEYX::P64 = P64[_sdEZ0::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdEYV::P64;
           P64[Hp - 24] = _sdEYX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdEYU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZ2_entry() //  [R1, R2]
         { info_tbl: [(cdHDA,
                       label: sat_sdEZ2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHDA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHDE; else goto cdHDD;
       cdHDE: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHDD: // global
           _sdEYQ::P64 = P64[R1 + 7];
           _sdEYU::P64 = P64[R1 + 15];
           _sdEYV::P64 = P64[R1 + 23];
           I64[Hp - 56] = sat_sdEZ0_info;
           P64[Hp - 40] = _sdEYU::P64;
           P64[Hp - 32] = _sdEYV::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdEYQ::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEZ5_entry() //  [R1]
         { info_tbl: [(cdHDY,
                       label: sat_sdEZ5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHDY: // global
           _sdEZ5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHDZ; else goto cdHE0;
       cdHE0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHE2; else goto cdHE1;
       cdHE2: // global
           HpAlloc = 24;
           goto cdHDZ;
       cdHDZ: // global
           R1 = _sdEZ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHE1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEZ5::P64;
           _sdEYV::P64 = P64[_sdEZ5::P64 + 16];
           _sdEZ3::P64 = P64[_sdEZ5::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdEZ3::P64;
           R2 = Hp - 14;
           R1 = _sdEYV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZ7_entry() //  [R1]
         { info_tbl: [(cdHE4,
                       label: sat_sdEZ7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHE4: // global
           _sdEZ7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHE5; else goto cdHE6;
       cdHE6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHE8; else goto cdHE7;
       cdHE8: // global
           HpAlloc = 56;
           goto cdHE5;
       cdHE5: // global
           R1 = _sdEZ7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHE7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEZ7::P64;
           _sdEYU::P64 = P64[_sdEZ7::P64 + 16];
           _sdEYV::P64 = P64[_sdEZ7::P64 + 24];
           _sdEZ3::P64 = P64[_sdEZ7::P64 + 32];
           I64[Hp - 48] = sat_sdEZ5_info;
           P64[Hp - 32] = _sdEYV::P64;
           P64[Hp - 24] = _sdEZ3::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = _sdEYU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZ9_entry() //  [R1]
         { info_tbl: [(cdHEa,
                       label: sat_sdEZ9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHEa: // global
           _sdEZ9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHEb; else goto cdHEc;
       cdHEc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHEe; else goto cdHEd;
       cdHEe: // global
           HpAlloc = 64;
           goto cdHEb;
       cdHEb: // global
           R1 = _sdEZ9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHEd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEZ9::P64;
           _sdEYQ::P64 = P64[_sdEZ9::P64 + 16];
           _sdEYU::P64 = P64[_sdEZ9::P64 + 24];
           _sdEYV::P64 = P64[_sdEZ9::P64 + 32];
           _sdEZ3::P64 = P64[_sdEZ9::P64 + 40];
           I64[Hp - 56] = sat_sdEZ7_info;
           P64[Hp - 40] = _sdEYU::P64;
           P64[Hp - 32] = _sdEYV::P64;
           P64[Hp - 24] = _sdEZ3::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = _sdEYQ::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZa_entry() //  [R1, R2]
         { info_tbl: [(cdHEg,
                       label: sat_sdEZa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHEg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdHEk; else goto cdHEj;
       cdHEk: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHEj: // global
           _sdEYQ::P64 = P64[R1 + 7];
           _sdEYU::P64 = P64[R1 + 15];
           _sdEYV::P64 = P64[R1 + 23];
           I64[Hp - 64] = sat_sdEZ9_info;
           P64[Hp - 48] = _sdEYQ::P64;
           P64[Hp - 40] = _sdEYU::P64;
           P64[Hp - 32] = _sdEYV::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cdHEo,
                       label: Data.Functor.Classes.$wshowsBinaryWith_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, True, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHEo: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdHEs; else goto cdHEr;
       cdHEs: // global
           HpAlloc = 96;
           R1 = Data.Functor.Classes.$wshowsBinaryWith_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cdHEr: // global
           I64[Hp - 88] = f_sdEYU_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R6;
           I64[Hp - 56] = g_sdEYV_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = P64[Sp];
           _cdHD2::P64 = Hp - 88;
           _cdHD9::P64 = Hp - 56;
           if (%MO_S_Le_W64(R5, 10)) goto cdHEm; else goto cdHEn;
       cdHEm: // global
           I64[Hp - 24] = sat_sdEZ2_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdHD2::P64;
           P64[Hp] = _cdHD9::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHEn: // global
           I64[Hp - 24] = sat_sdEZa_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _cdHD2::P64;
           P64[Hp] = _cdHD9::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.961147125 UTC

[section ""data" . Data.Functor.Classes.showsBinaryWith_closure" {
     Data.Functor.Classes.showsBinaryWith_closure:
         const Data.Functor.Classes.showsBinaryWith_info;
 },
 Data.Functor.Classes.showsBinaryWith_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cdHFK,
                       label: Data.Functor.Classes.showsBinaryWith_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHFK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHFL; else goto cdHFM;
       cdHFL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsBinaryWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdHFM: // global
           I64[Sp - 40] = block_cdHFH_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udHFQ; else goto cdHFI;
       udHFQ: // global
           call _cdHFH(R1) args: 0, res: 0, upd: 0;
       cdHFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHFH() //  [R1]
         { info_tbl: [(cdHFH,
                       label: block_cdHFH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHFH: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Classes.$wshowsBinaryWith_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.967754904 UTC

[section ""data" . Data.Functor.Classes.readsUnary_closure" {
     Data.Functor.Classes.readsUnary_closure:
         const Data.Functor.Classes.readsUnary_info;
 },
 go_sdEZp_entry() //  [R1, R2]
         { info_tbl: [(cdHGm,
                       label: go_sdEZp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHGm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdHGn; else goto cdHGo;
       cdHGn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHGo: // global
           I64[Sp - 24] = block_cdHGf_info;
           _sdEZp::P64 = R1;
           _sdEZl::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdEZl::P64;
           P64[Sp - 8] = _sdEZp::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udHGI; else goto cdHGg;
       udHGI: // global
           call _cdHGf(R1) args: 0, res: 0, upd: 0;
       cdHGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHGf() //  [R1]
         { info_tbl: [(cdHGf,
                       label: block_cdHGf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHGf: // global
           if (R1 & 7 == 1) goto cdHGj; else goto cdHGk;
       cdHGj: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHGk: // global
           I64[Sp - 8] = block_cdHGu_info;
           _sdEZt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdEZt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udHGH; else goto cdHGv;
       udHGH: // global
           call _cdHGu(R1) args: 0, res: 0, upd: 0;
       cdHGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHGu() //  [R1]
         { info_tbl: [(cdHGu,
                       label: block_cdHGu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHGu: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdHGG; else goto cdHGF;
       cdHGG: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHGF: // global
           _sdEZv::P64 = P64[R1 + 7];
           _sdEZw::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = _sdEZv::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _sdEZw::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.readsUnary_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdHGN,
                       label: Data.Functor.Classes.readsUnary_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHGN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHGO; else goto cdHGP;
       cdHGO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.readsUnary_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHGP: // global
           I64[Sp - 32] = block_cdHG5_info;
           R3 = R3;
           _sdEZj::P64 = R2;
           R2 = R5;
           P64[Sp - 24] = _sdEZj::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 32;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdHG5() //  [R1]
         { info_tbl: [(cdHG5,
                       label: block_cdHG5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHG5: // global
           if (R1 & 7 == 1) goto cdHGK; else goto cdHGL;
       cdHGK: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHGL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdHGV; else goto cdHGU;
       cdHGV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHGU: // global
           I64[Hp - 8] = go_sdEZp_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cdHGS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdHGS() //  [R1]
         { info_tbl: [(cdHGS,
                       label: block_cdHGS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHGS: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdEZp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.982994865 UTC

[section ""data" . Data.Functor.Classes.$wshowsUnary_closure" {
     Data.Functor.Classes.$wshowsUnary_closure:
         const Data.Functor.Classes.$wshowsUnary_info;
 },
 Data.Functor.Classes.$wshowsUnary_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHHR: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2,
                                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdEZF_entry() //  [R1]
         { info_tbl: [(cdHHZ,
                       label: g_sdEZF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHHZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHI0; else goto cdHI1;
       cdHI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHI1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Classes.$fRead1Const1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdEZK_entry() //  [R1, R2]
         { info_tbl: [(cdHIc,
                       label: sat_sdEZK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHIc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHIg; else goto cdHIf;
       cdHIg: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHIf: // global
           _sdEZC::P64 = P64[R1 + 7];
           _sdEZF::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sdEZF::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdEZC::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdEZN_entry() //  [R1]
         { info_tbl: [(cdHIw,
                       label: sat_sdEZN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHIw: // global
           _sdEZN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHIx; else goto cdHIy;
       cdHIy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHIA; else goto cdHIz;
       cdHIA: // global
           HpAlloc = 24;
           goto cdHIx;
       cdHIx: // global
           R1 = _sdEZN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHIz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEZN::P64;
           _sdEZF::P64 = P64[_sdEZN::P64 + 16];
           _sdEZL::P64 = P64[_sdEZN::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sdEZL::P64;
           R2 = Hp - 14;
           R1 = _sdEZF::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZP_entry() //  [R1]
         { info_tbl: [(cdHIC,
                       label: sat_sdEZP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHIC: // global
           _sdEZP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdHID; else goto cdHIE;
       cdHIE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHIG; else goto cdHIF;
       cdHIG: // global
           HpAlloc = 56;
           goto cdHID;
       cdHID: // global
           R1 = _sdEZP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHIF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdEZP::P64;
           _sdEZC::P64 = P64[_sdEZP::P64 + 16];
           _sdEZF::P64 = P64[_sdEZP::P64 + 24];
           _sdEZL::P64 = P64[_sdEZP::P64 + 32];
           I64[Hp - 48] = sat_sdEZN_info;
           P64[Hp - 32] = _sdEZF::P64;
           P64[Hp - 24] = _sdEZL::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sdEZC::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdEZQ_entry() //  [R1, R2]
         { info_tbl: [(cdHII,
                       label: sat_sdEZQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHII: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdHIM; else goto cdHIL;
       cdHIM: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdHIL: // global
           _sdEZC::P64 = P64[R1 + 7];
           _sdEZF::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdEZP_info;
           P64[Hp - 40] = _sdEZC::P64;
           P64[Hp - 32] = _sdEZF::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Classes.$wshowsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHIQ,
                       label: Data.Functor.Classes.$wshowsUnary_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHIQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdHIU; else goto cdHIT;
       cdHIU: // global
           HpAlloc = 56;
           R1 = Data.Functor.Classes.$wshowsUnary_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cdHIT: // global
           I64[Hp - 48] = g_sdEZF_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R5;
           _cdHHV::P64 = Hp - 48;
           if (%MO_S_Le_W64(R4, 10)) goto cdHIO; else goto cdHIP;
       cdHIO: // global
           I64[Hp - 16] = sat_sdEZK_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdHHV::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdHIP: // global
           I64[Hp - 16] = sat_sdEZQ_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdHHV::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:55.999584364 UTC

[section ""data" . Data.Functor.Classes.showsUnary_closure" {
     Data.Functor.Classes.showsUnary_closure:
         const Data.Functor.Classes.showsUnary_info;
 },
 Data.Functor.Classes.showsUnary_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHJQ,
                       label: Data.Functor.Classes.showsUnary_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHJQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdHJR; else goto cdHJS;
       cdHJR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.showsUnary_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHJS: // global
           I64[Sp - 32] = block_cdHJN_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udHJW; else goto cdHJO;
       udHJW: // global
           call _cdHJN(R1) args: 0, res: 0, upd: 0;
       cdHJO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdHJN() //  [R1]
         { info_tbl: [(cdHJN,
                       label: block_cdHJN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHJN: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Classes.$wshowsUnary_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.005851914 UTC

[section ""cstring" . Data.Functor.Classes.$trModule4_bytes" {
     Data.Functor.Classes.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.00746563 UTC

[section ""data" . Data.Functor.Classes.$trModule3_closure" {
     Data.Functor.Classes.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.009064438 UTC

[section ""cstring" . Data.Functor.Classes.$trModule2_bytes" {
     Data.Functor.Classes.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.010710295 UTC

[section ""data" . Data.Functor.Classes.$trModule1_closure" {
     Data.Functor.Classes.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.012352048 UTC

[section ""data" . Data.Functor.Classes.$trModule_closure" {
     Data.Functor.Classes.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Classes.$trModule3_closure+1;
         const Data.Functor.Classes.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.014124256 UTC

[section ""data" . $krep_rdymB_closure" {
     $krep_rdymB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.015867055 UTC

[section ""data" . Data.Functor.Classes.$tcEq4_closure" {
     Data.Functor.Classes.$tcEq4_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.017606463 UTC

[section ""data" . Data.Functor.Classes.$tcEq7_closure" {
     Data.Functor.Classes.$tcEq7_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdymB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.019337993 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq6_bytes" {
     Data.Functor.Classes.$tcEq6_bytes:
         I8[] [69,113,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.020967316 UTC

[section ""data" . Data.Functor.Classes.$tcEq5_closure" {
     Data.Functor.Classes.$tcEq5_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.023871363 UTC

[section ""data" . Data.Functor.Classes.$tcEq1_closure" {
     Data.Functor.Classes.$tcEq1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq5_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 71749974434880567;
         const 7233443027070644957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.025755434 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd5_bytes" {
     Data.Functor.Classes.$tcOrd5_bytes:
         I8[] [79,114,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.027397208 UTC

[section ""data" . Data.Functor.Classes.$tcOrd4_closure" {
     Data.Functor.Classes.$tcOrd4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.030031283 UTC

[section ""data" . Data.Functor.Classes.$tcOrd1_closure" {
     Data.Functor.Classes.$tcOrd1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 11825914698899667233;
         const 4554948325937498991;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.031895473 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead5_bytes" {
     Data.Functor.Classes.$tcRead5_bytes:
         I8[] [82,101,97,100,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.033536307 UTC

[section ""data" . Data.Functor.Classes.$tcRead4_closure" {
     Data.Functor.Classes.$tcRead4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.035193776 UTC

[section ""data" . Data.Functor.Classes.$tcRead1_closure" {
     Data.Functor.Classes.$tcRead1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 14547308444716217043;
         const 925634574698086715;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.03699028 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow5_bytes" {
     Data.Functor.Classes.$tcShow5_bytes:
         I8[] [83,104,111,119,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.038656354 UTC

[section ""data" . Data.Functor.Classes.$tcShow4_closure" {
     Data.Functor.Classes.$tcShow4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.040382524 UTC

[section ""data" . Data.Functor.Classes.$tcShow1_closure" {
     Data.Functor.Classes.$tcShow1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow4_closure+1;
         const Data.Functor.Classes.$tcEq4_closure+4;
         const 4743290066722511112;
         const 6779909240154408836;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.042225028 UTC

[section ""cstring" . Data.Functor.Classes.$tcEq9_bytes" {
     Data.Functor.Classes.$tcEq9_bytes:
         I8[] [69,113,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.043904062 UTC

[section ""data" . Data.Functor.Classes.$tcEq8_closure" {
     Data.Functor.Classes.$tcEq8_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcEq9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.045626605 UTC

[section ""data" . Data.Functor.Classes.$tcEq2_closure" {
     Data.Functor.Classes.$tcEq2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcEq8_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 16920549266159426738;
         const 13264288076834164909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.047494874 UTC

[section ""cstring" . Data.Functor.Classes.$tcOrd7_bytes" {
     Data.Functor.Classes.$tcOrd7_bytes:
         I8[] [79,114,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.049157085 UTC

[section ""data" . Data.Functor.Classes.$tcOrd6_closure" {
     Data.Functor.Classes.$tcOrd6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcOrd7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.051210391 UTC

[section ""data" . Data.Functor.Classes.$tcOrd2_closure" {
     Data.Functor.Classes.$tcOrd2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcOrd6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 4167316048525678806;
         const 17649124474771181823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.052993383 UTC

[section ""cstring" . Data.Functor.Classes.$tcRead7_bytes" {
     Data.Functor.Classes.$tcRead7_bytes:
         I8[] [82,101,97,100,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.055352254 UTC

[section ""data" . Data.Functor.Classes.$tcRead6_closure" {
     Data.Functor.Classes.$tcRead6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcRead7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.057088226 UTC

[section ""data" . Data.Functor.Classes.$tcRead2_closure" {
     Data.Functor.Classes.$tcRead2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcRead6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 615267248700376470;
         const 8978126042197021701;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.058924315 UTC

[section ""cstring" . Data.Functor.Classes.$tcShow7_bytes" {
     Data.Functor.Classes.$tcShow7_bytes:
         I8[] [83,104,111,119,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.060612789 UTC

[section ""data" . Data.Functor.Classes.$tcShow6_closure" {
     Data.Functor.Classes.$tcShow6_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Classes.$tcShow7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.062310492 UTC

[section ""data" . Data.Functor.Classes.$tcShow2_closure" {
     Data.Functor.Classes.$tcShow2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Classes.$trModule_closure+1;
         const Data.Functor.Classes.$tcShow6_closure+1;
         const Data.Functor.Classes.$tcEq7_closure+4;
         const 11321900378419812635;
         const 1323607160578303441;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.064471037 UTC

[section ""data" . Data.Functor.Classes.C:Show2_closure" {
     Data.Functor.Classes.C:Show2_closure:
         const Data.Functor.Classes.C:Show2_info;
 },
 Data.Functor.Classes.C:Show2_entry() //  [R2, R3]
         { info_tbl: [(cdHKI,
                       label: Data.Functor.Classes.C:Show2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHKI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHKM; else goto cdHKL;
       cdHKM: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHKL: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.069327632 UTC

[section ""data" . Data.Functor.Classes.C:Read2_closure" {
     Data.Functor.Classes.C:Read2_closure:
         const Data.Functor.Classes.C:Read2_info;
 },
 Data.Functor.Classes.C:Read2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHKY,
                       label: Data.Functor.Classes.C:Read2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHKY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHL2; else goto cdHL1;
       cdHL2: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHL1: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read2_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.073390691 UTC

[section ""data" . Data.Functor.Classes.C:Ord2_closure" {
     Data.Functor.Classes.C:Ord2_closure:
         const Data.Functor.Classes.C:Ord2_info;
 },
 Data.Functor.Classes.C:Ord2_entry() //  [R2, R3]
         { info_tbl: [(cdHLe,
                       label: Data.Functor.Classes.C:Ord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHLe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHLi; else goto cdHLh;
       cdHLi: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHLh: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord2_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.077137891 UTC

[section ""data" . Data.Functor.Classes.C:Show1_closure" {
     Data.Functor.Classes.C:Show1_closure:
         const Data.Functor.Classes.C:Show1_info;
 },
 Data.Functor.Classes.C:Show1_entry() //  [R2, R3]
         { info_tbl: [(cdHLu,
                       label: Data.Functor.Classes.C:Show1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHLu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHLy; else goto cdHLx;
       cdHLy: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Show1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHLx: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.0811164 UTC

[section ""data" . Data.Functor.Classes.C:Read1_closure" {
     Data.Functor.Classes.C:Read1_closure:
         const Data.Functor.Classes.C:Read1_info;
 },
 Data.Functor.Classes.C:Read1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdHLK,
                       label: Data.Functor.Classes.C:Read1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHLK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHLO; else goto cdHLN;
       cdHLO: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Read1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHLN: // global
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.085554286 UTC

[section ""data" . Data.Functor.Classes.C:Ord1_closure" {
     Data.Functor.Classes.C:Ord1_closure:
         const Data.Functor.Classes.C:Ord1_info;
 },
 Data.Functor.Classes.C:Ord1_entry() //  [R2, R3]
         { info_tbl: [(cdHM0,
                       label: Data.Functor.Classes.C:Ord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHM0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdHM4; else goto cdHM3;
       cdHM4: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Classes.C:Ord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHM3: // global
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.090023358 UTC

[Data.Functor.Classes.C:Show2_con_entry() //  [R1]
         { info_tbl: [(cdHMb,
                       label: Data.Functor.Classes.C:Show2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHMb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.093567088 UTC

[Data.Functor.Classes.C:Read2_con_entry() //  [R1]
         { info_tbl: [(cdHMi,
                       label: Data.Functor.Classes.C:Read2_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHMi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.09673934 UTC

[Data.Functor.Classes.C:Ord2_con_entry() //  [R1]
         { info_tbl: [(cdHMp,
                       label: Data.Functor.Classes.C:Ord2_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,50]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHMp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.100009478 UTC

[Data.Functor.Classes.C:Show1_con_entry() //  [R1]
         { info_tbl: [(cdHMw,
                       label: Data.Functor.Classes.C:Show1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,83,104,111,119,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHMw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.103347409 UTC

[Data.Functor.Classes.C:Read1_con_entry() //  [R1]
         { info_tbl: [(cdHMD,
                       label: Data.Functor.Classes.C:Read1_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,82,101,97,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHMD: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.106686178 UTC

[Data.Functor.Classes.C:Ord1_con_entry() //  [R1]
         { info_tbl: [(cdHMK,
                       label: Data.Functor.Classes.C:Ord1_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,70,117,110,99,116,111,114,46,67,108,97,115,115,101,115,46,67,58,79,114,100,49]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHMK: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:56.110278101 UTC

[section ""relreadonly" . SdF7K_srt" {
     SdF7K_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.$fRead1Const2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec7_closure;
         const Data.Functor.Classes.$fRead1Either1_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$fRead1Either4_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec8_closure;
         const Data.Functor.Classes.$fRead1NonEmpty3_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec5_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1Proxy2_closure;
         const Data.Functor.Classes.$fRead1Proxy_lexeme_closure;
         const Data.Functor.Classes.$fRead1Proxy1_closure;
         const Data.Functor.Classes.$fRead1Proxy3_closure;
         const Data.Functor.Classes.$fShow1Proxy2_closure;
         const Data.Functor.Classes.$fRead1(,)3_closure;
         const Data.Functor.Classes.$w$cliftReadPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec6_closure;
         const Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2_closure;
         const Data.Functor.Classes.$dmliftReadList2_closure;
         const Data.Functor.Classes.$fShow1Proxy1_closure;
         const Data.Functor.Classes.$dmliftReadList_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec_closure;
         const Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec2_closure;
         const Data.Functor.Classes.liftReadListPrecDefault_closure;
         const lvl_rdymy_closure;
         const Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec_closure;
         const lvl1_rdymz_closure;
         const lvl2_rdymA_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Classes.$w$cliftReadList2_closure;
         const Data.Functor.Classes.$fRead2Either_closure;
         const Data.Functor.Classes.$fRead2Const_closure;
         const Data.Functor.Classes.$fRead2(,)_closure;
         const Data.Functor.Classes.liftReadListPrec2Default_closure;
         const Data.Functor.Classes.$fRead1(,)1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1(,)_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1(,)_closure;
         const GHC.Read.lex1_closure;
         const Data.Functor.Classes.$wreadsData_closure;
         const Data.Functor.Classes.readsData_closure;
         const Data.Functor.Classes.readData1_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Classes.$wreadUnaryWith_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Classes.readUnaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const5_closure;
         const Data.Functor.Classes.$w$cliftReadPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec1_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec_closure;
         const Data.Functor.Classes.$fRead1Const_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Const_closure;
         const Data.Functor.Classes.$fRead1Either7_closure;
         const Data.Functor.Classes.$w$cliftReadPrec3_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec2_closure;
         const Data.Functor.Classes.$w$cliftReadListPrec1_closure;
         const Data.Functor.Classes.$fRead1Either_$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Either_closure;
         const Data.Functor.Classes.$fRead1Identity2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec3_closure;
         const Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList_closure;
         const Data.Functor.Classes.$fRead1Maybe5_closure;
         const Data.Functor.Classes.$fRead1Maybe_lexeme_closure;
         const Data.Functor.Classes.$fRead1Maybe2_closure;
         const Data.Functor.Classes.$w$cliftReadPrec4_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Data.Functor.Classes.$w$cliftReadsPrec4_closure;
         const Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec_closure;
         const Data.Functor.Classes.$w$cliftReadList1_closure;
         const Data.Functor.Classes.$wreadBinaryWith_closure;
         const Data.Functor.Classes.readBinaryWith1_closure;
         const Data.Functor.Classes.$fRead1Const3_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$fShow2Const_$cliftShowList2_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Const_$cliftShowList_closure;
         const Data.Functor.Classes.$fShow1Const_closure;
         const Data.Functor.Classes.$fRead1Either2_closure;
         const Data.Functor.Classes.$fRead1Either5_closure;
         const Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2_closure;
         const Data.Functor.Classes.$w$cliftShowList4_closure;
         const Data.Functor.Classes.$w$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Either_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList1_closure;
         const Data.Functor.Classes.$fShow1Either_closure;
         const Data.Functor.Classes.$fRead1Identity3_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$fShow1Identity_$cliftShowList_closure;
         const Data.Functor.Classes.$fRead1Maybe6_closure;
         const Data.Functor.Classes.$fRead1Maybe3_closure;
         const Data.Functor.Classes.$fShow1Maybe1_closure;
         const Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec_closure;
         const Data.Functor.Classes.$w$cliftShowList2_closure;
 }]

