
==================== Tidy Core ====================
2018-03-16 16:08:42.922990032 UTC

Result size of Tidy Core
  = {terms: 4,077, types: 9,539, coercions: 1,442, joins: 0/57}

-- RHS size: {terms: 6, types: 52, coercions: 0, joins: 0/0}
liftShowsPrec2
  :: forall (f :: * -> * -> *).
     Show2 f =>
     forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> Int
     -> f a b
     -> ShowS
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for liftShowsPrec2: "Class op liftShowsPrec2"]
liftShowsPrec2
  = \ (@ (f_adw99 :: * -> * -> *)) (v_B1 :: Show2 f_adw99) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Show2 v_B2 v_B3 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 52, coercions: 0, joins: 0/0}
liftShowList2
  :: forall (f :: * -> * -> *).
     Show2 f =>
     forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> [f a b]
     -> ShowS
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for liftShowList2: "Class op liftShowList2"]
liftShowList2
  = \ (@ (f_adw99 :: * -> * -> *)) (v_B1 :: Show2 f_adw99) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Show2 v_B2 v_B3 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 89, coercions: 0, joins: 0/0}
liftReadsPrec2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     (Int -> ReadS a)
     -> ReadS [a]
     -> (Int -> ReadS b)
     -> ReadS [b]
     -> Int
     -> ReadS (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>,
 RULES: Built in rule for liftReadsPrec2: "Class op liftReadsPrec2"]
liftReadsPrec2
  = \ (@ (f_adw9i :: * -> * -> *)) (v_B1 :: Read2 f_adw9i) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read2 v_B2 v_B3 v_B4 v_B5 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 89, coercions: 0, joins: 0/0}
liftReadList2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     (Int -> ReadS a)
     -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>,
 RULES: Built in rule for liftReadList2: "Class op liftReadList2"]
liftReadList2
  = \ (@ (f_adw9i :: * -> * -> *)) (v_B1 :: Read2 f_adw9i) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read2 v_B2 v_B3 v_B4 v_B5 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 89, coercions: 0, joins: 0/0}
liftReadPrec2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     ReadPrec a
     -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>,
 RULES: Built in rule for liftReadPrec2: "Class op liftReadPrec2"]
liftReadPrec2
  = \ (@ (f_adw9i :: * -> * -> *)) (v_B1 :: Read2 f_adw9i) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read2 v_B2 v_B3 v_B4 v_B5 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 89, coercions: 0, joins: 0/0}
liftReadListPrec2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     ReadPrec a
     -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>,
 RULES: Built in rule for liftReadListPrec2: "Class op liftReadListPrec2"]
liftReadListPrec2
  = \ (@ (f_adw9i :: * -> * -> *)) (v_B1 :: Read2 f_adw9i) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read2 v_B2 v_B3 v_B4 v_B5 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 33, coercions: 0, joins: 0/0}
Data.Functor.Classes.$p1Ord2
  :: forall (f :: * -> * -> *). Ord2 f => Eq2 f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for Data.Functor.Classes.$p1Ord2: "Class op $p1Ord2"]
Data.Functor.Classes.$p1Ord2
  = \ (@ (f_adw9H :: * -> * -> *)) (v_B1 :: Ord2 f_adw9H) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Ord2 v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 33, coercions: 0, joins: 0/0}
liftCompare2
  :: forall (f :: * -> * -> *).
     Ord2 f =>
     forall a b c d.
     (a -> b -> Ordering)
     -> (c -> d -> Ordering) -> f a c -> f b d -> Ordering
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for liftCompare2: "Class op liftCompare2"]
liftCompare2
  = \ (@ (f_adw9H :: * -> * -> *)) (v_B1 :: Ord2 f_adw9H) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Ord2 v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 3, types: 8, coercions: 2, joins: 0/0}
liftEq2 [InlPrag=INLINE]
  :: forall (f :: * -> * -> *).
     Eq2 f =>
     forall a b c d.
     (a -> b -> Bool) -> (c -> d -> Bool) -> f a c -> f b d -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (f_adw9M :: * -> * -> *))
                 (v_B1 [Occ=Once] :: Eq2 f_adw9M) ->
                 v_B1
                 `cast` (Data.Functor.Classes.N:Eq2[0] <f_adw9M>_N
                         :: (Eq2 f_adw9M :: Constraint)
                            ~R# (forall a b c d.
                                 (a -> b -> Bool)
                                 -> (c -> d -> Bool) -> f_adw9M a c -> f_adw9M b d -> Bool :: *))}]
liftEq2
  = \ (@ (f_adw9M :: * -> * -> *)) (v_B1 :: Eq2 f_adw9M) ->
      v_B1
      `cast` (Data.Functor.Classes.N:Eq2[0] <f_adw9M>_N
              :: (Eq2 f_adw9M :: Constraint)
                 ~R# (forall a b c d.
                      (a -> b -> Bool)
                      -> (c -> d -> Bool) -> f_adw9M a c -> f_adw9M b d -> Bool :: *))

-- RHS size: {terms: 6, types: 32, coercions: 0, joins: 0/0}
liftShowsPrec
  :: forall (f :: * -> *).
     Show1 f =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for liftShowsPrec: "Class op liftShowsPrec"]
liftShowsPrec
  = \ (@ (f_adw9R :: * -> *)) (v_B1 :: Show1 f_adw9R) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Show1 v_B2 v_B3 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 32, coercions: 0, joins: 0/0}
liftShowList
  :: forall (f :: * -> *).
     Show1 f =>
     forall a. (Int -> a -> ShowS) -> ([a] -> ShowS) -> [f a] -> ShowS
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for liftShowList: "Class op liftShowList"]
liftShowList
  = \ (@ (f_adw9R :: * -> *)) (v_B1 :: Show1 f_adw9R) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Show1 v_B2 v_B3 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
liftReadsPrec
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>,
 RULES: Built in rule for liftReadsPrec: "Class op liftReadsPrec"]
liftReadsPrec
  = \ (@ (f_adw9W :: * -> *)) (v_B1 :: Read1 f_adw9W) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read1 v_B2 v_B3 v_B4 v_B5 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
liftReadList
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>,
 RULES: Built in rule for liftReadList: "Class op liftReadList"]
liftReadList
  = \ (@ (f_adw9W :: * -> *)) (v_B1 :: Read1 f_adw9W) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read1 v_B2 v_B3 v_B4 v_B5 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
liftReadPrec
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>,
 RULES: Built in rule for liftReadPrec: "Class op liftReadPrec"]
liftReadPrec
  = \ (@ (f_adw9W :: * -> *)) (v_B1 :: Read1 f_adw9W) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read1 v_B2 v_B3 v_B4 v_B5 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 53, coercions: 0, joins: 0/0}
liftReadListPrec
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>,
 RULES: Built in rule for liftReadListPrec: "Class op liftReadListPrec"]
liftReadListPrec
  = \ (@ (f_adw9W :: * -> *)) (v_B1 :: Read1 f_adw9W) ->
      case v_B1 of v_B1
      { Data.Functor.Classes.C:Read1 v_B2 v_B3 v_B4 v_B5 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 22, coercions: 0, joins: 0/0}
Data.Functor.Classes.$p1Ord1
  :: forall (f :: * -> *). Ord1 f => Eq1 f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for Data.Functor.Classes.$p1Ord1: "Class op $p1Ord1"]
Data.Functor.Classes.$p1Ord1
  = \ (@ (f_adwa9 :: * -> *)) (v_B1 :: Ord1 f_adwa9) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Ord1 v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 22, coercions: 0, joins: 0/0}
liftCompare
  :: forall (f :: * -> *).
     Ord1 f =>
     forall a b. (a -> b -> Ordering) -> f a -> f b -> Ordering
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for liftCompare: "Class op liftCompare"]
liftCompare
  = \ (@ (f_adwa9 :: * -> *)) (v_B1 :: Ord1 f_adwa9) ->
      case v_B1 of v_B1 { Data.Functor.Classes.C:Ord1 v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 3, types: 6, coercions: 2, joins: 0/0}
liftEq [InlPrag=INLINE]
  :: forall (f :: * -> *).
     Eq1 f =>
     forall a b. (a -> b -> Bool) -> f a -> f b -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (f_adwac :: * -> *)) (v_B1 [Occ=Once] :: Eq1 f_adwac) ->
                 v_B1
                 `cast` (Data.Functor.Classes.N:Eq1[0] <f_adwac>_N
                         :: (Eq1 f_adwac :: Constraint)
                            ~R# (forall a b.
                                 (a -> b -> Bool) -> f_adwac a -> f_adwac b -> Bool :: *))}]
liftEq
  = \ (@ (f_adwac :: * -> *)) (v_B1 :: Eq1 f_adwac) ->
      v_B1
      `cast` (Data.Functor.Classes.N:Eq1[0] <f_adwac>_N
              :: (Eq1 f_adwac :: Constraint)
                 ~R# (forall a b.
                      (a -> b -> Bool) -> f_adwac a -> f_adwac b -> Bool :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Const1 = GHC.Types.I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$fRead1Const4 = "Const"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Const3
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Const4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const2 :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Const2
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Const3

-- RHS size: {terms: 34, types: 49, coercions: 27, joins: 0/0}
Data.Functor.Classes.$w$cliftReadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 211 0}]
Data.Functor.Classes.$w$cliftReadPrec1
  = \ (@ a_sdxVk)
      (@ b_sdxVl)
      (w_sdxVm :: ReadPrec a_sdxVk)
      (w1_sdxVq :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdxVr)
      (w2_sdxVs
         :: Const a_sdxVk b_sdxVl
            -> Text.ParserCombinators.ReadP.P b1_sdxVr) ->
      GHC.Read.list3
        @ (Const a_sdxVk b_sdxVl)
        ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b2_X81aZ)
            (eta_X63
               :: Const a_sdxVk b_sdxVl
                  -> Text.ParserCombinators.ReadP.P b2_X81aZ) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 10# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b2_X81aZ;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Functor.Classes.$fRead1Const2
                       @ b2_X81aZ
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          (((w_sdxVm
                             `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdxVk>_R
                                     :: (ReadPrec a_sdxVk :: *)
                                        ~R# (Text.ParserCombinators.ReadPrec.Prec
                                             -> Text.ParserCombinators.ReadP.ReadP a_sdxVk :: *)))
                              Data.Functor.Classes.$fRead1Const1)
                           `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdxVk>_R
                                   :: (Text.ParserCombinators.ReadP.ReadP a_sdxVk :: *)
                                      ~R# (forall b.
                                           (a_sdxVk -> Text.ParserCombinators.ReadP.P b)
                                           -> Text.ParserCombinators.ReadP.P b :: *)))
                            @ b2_X81aZ
                            (\ (a2_i88WJ :: a_sdxVk) ->
                               eta_X63
                                 (a2_i88WJ
                                  `cast` (Sym (Data.Functor.Const.N:Const[0]
                                                   <*>_N <a_sdxVk>_R <b_sdxVl>_P)
                                          :: (a_sdxVk :: *) ~R# (Const a_sdxVk b_sdxVl :: *)))))
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b2_X81aZ ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Const
                                   a_sdxVk
                                   b_sdxVl>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Const a_sdxVk b_sdxVl>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Const a_sdxVk b_sdxVl -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Const a_sdxVk b_sdxVl) :: *)))
        w1_sdxVq
        @ b1_sdxVr
        w2_sdxVs

-- RHS size: {terms: 13, types: 27, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,A><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxVk)
                 (@ b_sdxVl)
                 (w_sdxVm [Occ=Once] :: ReadPrec a_sdxVk)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_sdxVq [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b1_sdxVr)
                 (w5_sdxVs [Occ=Once]
                    :: Const a_sdxVk b_sdxVl
                       -> Text.ParserCombinators.ReadP.P b1_sdxVr) ->
                 Data.Functor.Classes.$w$cliftReadPrec1
                   @ a_sdxVk @ b_sdxVl w_sdxVm w4_sdxVq @ b1_sdxVr w5_sdxVs}]
Data.Functor.Classes.$fRead1Const6
  = \ (@ a_sdxVk)
      (@ b_sdxVl)
      (w_sdxVm :: ReadPrec a_sdxVk)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_sdxVq :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdxVr)
      (w5_sdxVs
         :: Const a_sdxVk b_sdxVl
            -> Text.ParserCombinators.ReadP.P b1_sdxVr) ->
      Data.Functor.Classes.$w$cliftReadPrec1
        @ a_sdxVk @ b_sdxVl w_sdxVm w4_sdxVq @ b1_sdxVr w5_sdxVs

-- RHS size: {terms: 14, types: 32, coercions: 17, joins: 0/0}
Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2
  :: forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> ReadPrec [Const a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwSL)
                 (@ b_adwSM)
                 (rp1_adwdl [Occ=Once] :: ReadPrec a_adwSL)
                 (rl1_adwdm [Occ=Once] :: ReadPrec [a_adwSL])
                 (rp2_adwdn [Occ=Once] :: ReadPrec b_adwSM)
                 (rl2_adwdo [Occ=Once] :: ReadPrec [b_adwSM]) ->
                 list
                   @ (Const a_adwSL b_adwSM)
                   ((Data.Functor.Classes.$fRead1Const6
                       @ a_adwSL @ b_adwSM rp1_adwdl rl1_adwdm rp2_adwdn rl2_adwdo)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Const
                                              a_adwSL
                                              b_adwSM>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Const a_adwSL b_adwSM>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Const a_adwSL b_adwSM -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (Const a_adwSL b_adwSM) :: *)))}]
Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2
  = \ (@ a_adwSL)
      (@ b_adwSM)
      (rp1_adwdl :: ReadPrec a_adwSL)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      list
        @ (Const a_adwSL b_adwSM)
        ((\ (w_sdxVq [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_sdxVr)
            (w1_sdxVs
               :: Const a_adwSL b_adwSM
                  -> Text.ParserCombinators.ReadP.P b1_sdxVr) ->
            Data.Functor.Classes.$w$cliftReadPrec1
              @ a_adwSL @ b_adwSM rp1_adwdl w_sdxVq @ b1_sdxVr w1_sdxVs)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Const
                                   a_adwSL
                                   b_adwSM>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Const a_adwSL b_adwSM>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Const a_adwSL b_adwSM -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Const a_adwSL b_adwSM) :: *)))

-- RHS size: {terms: 40, types: 67, coercions: 23, joins: 0/1}
Data.Functor.Classes.$w$cliftReadsPrec7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Int -> ReadS a) -> Int -> ReadS (Const a b)
[GblId,
 Arity=2,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 281 60}]
Data.Functor.Classes.$w$cliftReadsPrec7
  = \ (@ a_sdxVu)
      (@ b_sdxVv)
      (w_sdxVw :: Int -> ReadS a_sdxVu)
      (w1_sdxVA :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Const a_sdxVu b_sdxVv)
        (let {
           lvl3_sdybr [Dmd=<L,C(U)>] :: ReadS a_sdxVu
           [LclId]
           lvl3_sdybr = w_sdxVw Data.Functor.Classes.$fRead1Const1 } in
         GHC.Read.list3
           @ (Const a_sdxVu b_sdxVv)
           ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
               (@ b1_i815E)
               (eta_X63
                  :: Const a_sdxVu b_sdxVv
                     -> Text.ParserCombinators.ReadP.P b1_i815E) ->
               case c_i88VW of { GHC.Types.I# x_i88VZ ->
               case GHC.Prim.<=# x_i88VZ 10# of {
                 __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_i815E;
                 1# ->
                   case Text.Read.Lex.$wexpect
                          Data.Functor.Classes.$fRead1Const2
                          @ b1_i815E
                          (\ _ [Occ=Dead, OS=OneShot] ->
                             case Text.ParserCombinators.ReadP.$wreadS_to_P
                                    @ a_sdxVu
                                    lvl3_sdybr
                                    @ b1_i815E
                                    (\ (a2_i88WJ :: a_sdxVu) ->
                                       eta_X63
                                         (a2_i88WJ
                                          `cast` (Sym (Data.Functor.Const.N:Const[0]
                                                           <*>_N <a_sdxVu>_R <b_sdxVv>_P)
                                                  :: (a_sdxVu :: *)
                                                     ~R# (Const a_sdxVu b_sdxVv :: *))))
                             of
                             { (# ww1_idxi6 #) ->
                             Text.ParserCombinators.ReadP.Look @ b1_i815E ww1_idxi6
                             })
                   of
                   { (# ww1_i88Ww #) ->
                   Text.ParserCombinators.ReadP.Look @ b1_i815E ww1_i88Ww
                   }
               }
               })
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Const
                                      a_sdxVu
                                      b_sdxVv>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Const a_sdxVu b_sdxVv>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Const a_sdxVu b_sdxVv -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec (Const a_sdxVu b_sdxVv) :: *)))
           w1_sdxVA
           @ (Const a_sdxVu b_sdxVv)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Const a_sdxVu b_sdxVv)))

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> ReadS a)
     -> ReadS [a]
     -> (Int -> ReadS b)
     -> ReadS [b]
     -> Int
     -> ReadS (Const a b)
[GblId,
 Arity=5,
 Str=<L,1*C1(C(U))><L,A><L,A><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxVu)
                 (@ b_sdxVv)
                 (w_sdxVw [Occ=Once] :: Int -> ReadS a_sdxVu)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_sdxVA [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec7
                   @ a_sdxVu @ b_sdxVv w_sdxVw w4_sdxVA}]
Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
  = \ (@ a_sdxVu)
      (@ b_sdxVv)
      (w_sdxVw :: Int -> ReadS a_sdxVu)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_sdxVA :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec7
        @ a_sdxVu @ b_sdxVv w_sdxVw w4_sdxVA

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$fRead1Either3 = "Right"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Either2
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either1 :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Either1
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Either2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Either6 = "Left"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Either5
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either6

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either4 :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Either4
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Either5

-- RHS size: {terms: 50, types: 63, coercions: 21, joins: 0/0}
Data.Functor.Classes.$w$cliftReadPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ReadPrec a
     -> ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0] 381 0}]
Data.Functor.Classes.$w$cliftReadPrec3
  = \ (@ a_sdxVC)
      (@ b_sdxVD)
      (w_sdxVE :: ReadPrec a_sdxVC)
      (w1_sdxVG :: ReadPrec b_sdxVD)
      (w2_sdxVI :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdxVJ)
      (w3_sdxVK
         :: Either a_sdxVC b_sdxVD
            -> Text.ParserCombinators.ReadP.P b1_sdxVJ) ->
      GHC.Read.list3
        @ (Either a_sdxVC b_sdxVD)
        ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b2_i815E)
            (eta_X5M
               :: Either a_sdxVC b_sdxVD
                  -> Text.ParserCombinators.ReadP.P b2_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 10# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b2_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Functor.Classes.$fRead1Either4
                       @ b2_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          (((w_sdxVE
                             `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdxVC>_R
                                     :: (ReadPrec a_sdxVC :: *)
                                        ~R# (Text.ParserCombinators.ReadPrec.Prec
                                             -> Text.ParserCombinators.ReadP.ReadP a_sdxVC :: *)))
                              Data.Functor.Classes.$fRead1Const1)
                           `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdxVC>_R
                                   :: (Text.ParserCombinators.ReadP.ReadP a_sdxVC :: *)
                                      ~R# (forall b.
                                           (a_sdxVC -> Text.ParserCombinators.ReadP.P b)
                                           -> Text.ParserCombinators.ReadP.P b :: *)))
                            @ b2_i815E
                            (\ (a2_i88WJ :: a_sdxVC) ->
                               eta_X5M (Data.Either.Left @ a_sdxVC @ b_sdxVD a2_i88WJ)))
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                  @ b2_i815E
                  (Text.ParserCombinators.ReadP.Look @ b2_i815E ww1_i88Ww)
                  (case Text.Read.Lex.$wexpect
                          Data.Functor.Classes.$fRead1Either1
                          @ b2_i815E
                          (\ _ [Occ=Dead, OS=OneShot] ->
                             (((w1_sdxVG
                                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <b_sdxVD>_R
                                        :: (ReadPrec b_sdxVD :: *)
                                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                -> Text.ParserCombinators.ReadP.ReadP
                                                     b_sdxVD :: *)))
                                 Data.Functor.Classes.$fRead1Const1)
                              `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_sdxVD>_R
                                      :: (Text.ParserCombinators.ReadP.ReadP b_sdxVD :: *)
                                         ~R# (forall b.
                                              (b_sdxVD -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b :: *)))
                               @ b2_i815E
                               (\ (a2_i88WJ :: b_sdxVD) ->
                                  eta_X5M (Data.Either.Right @ a_sdxVC @ b_sdxVD a2_i88WJ)))
                   of
                   { (# ww3_X892r #) ->
                   Text.ParserCombinators.ReadP.Look @ b2_i815E ww3_X892r
                   })
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Either
                                   a_sdxVC
                                   b_sdxVD>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Either a_sdxVC b_sdxVD>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_sdxVC b_sdxVD -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Either a_sdxVC b_sdxVD) :: *)))
        w2_sdxVI
        @ b1_sdxVJ
        w3_sdxVK

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxVC)
                 (@ b_sdxVD)
                 (w_sdxVE [Occ=Once] :: ReadPrec a_sdxVC)
                 _ [Occ=Dead]
                 (w2_sdxVG [Occ=Once] :: ReadPrec b_sdxVD)
                 _ [Occ=Dead]
                 (w4_sdxVI [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b1_sdxVJ)
                 (w5_sdxVK [Occ=Once]
                    :: Either a_sdxVC b_sdxVD
                       -> Text.ParserCombinators.ReadP.P b1_sdxVJ) ->
                 Data.Functor.Classes.$w$cliftReadPrec3
                   @ a_sdxVC @ b_sdxVD w_sdxVE w2_sdxVG w4_sdxVI @ b1_sdxVJ w5_sdxVK}]
Data.Functor.Classes.$fRead1Either8
  = \ (@ a_sdxVC)
      (@ b_sdxVD)
      (w_sdxVE :: ReadPrec a_sdxVC)
      _ [Occ=Dead]
      (w2_sdxVG :: ReadPrec b_sdxVD)
      _ [Occ=Dead]
      (w4_sdxVI :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdxVJ)
      (w5_sdxVK
         :: Either a_sdxVC b_sdxVD
            -> Text.ParserCombinators.ReadP.P b1_sdxVJ) ->
      Data.Functor.Classes.$w$cliftReadPrec3
        @ a_sdxVC @ b_sdxVD w_sdxVE w2_sdxVG w4_sdxVI @ b1_sdxVJ w5_sdxVK

-- RHS size: {terms: 15, types: 28, coercions: 13, joins: 0/0}
Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2
  :: forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> ReadPrec [Either a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwUm)
                 (@ b_adwUn)
                 (rp1_adwdl [Occ=Once] :: ReadPrec a_adwUm)
                 (rl1_adwdm [Occ=Once] :: ReadPrec [a_adwUm])
                 (rp2_adwdn [Occ=Once] :: ReadPrec b_adwUn)
                 (rl2_adwdo [Occ=Once] :: ReadPrec [b_adwUn]) ->
                 list
                   @ (Either a_adwUm b_adwUn)
                   ((Data.Functor.Classes.$fRead1Either8
                       @ a_adwUm @ b_adwUn rp1_adwdl rl1_adwdm rp2_adwdn rl2_adwdo)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Either
                                              a_adwUm
                                              b_adwUn>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Either a_adwUm b_adwUn>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Either a_adwUm b_adwUn -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (Either a_adwUm b_adwUn) :: *)))}]
Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2
  = \ (@ a_adwUm)
      (@ b_adwUn)
      (rp1_adwdl :: ReadPrec a_adwUm)
      _ [Occ=Dead]
      (rp2_adwdn :: ReadPrec b_adwUn)
      _ [Occ=Dead] ->
      list
        @ (Either a_adwUm b_adwUn)
        ((\ (w_sdxVI [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_sdxVJ)
            (w1_sdxVK
               :: Either a_adwUm b_adwUn
                  -> Text.ParserCombinators.ReadP.P b1_sdxVJ) ->
            Data.Functor.Classes.$w$cliftReadPrec3
              @ a_adwUm
              @ b_adwUn
              rp1_adwdl
              rp2_adwdn
              w_sdxVI
              @ b1_sdxVJ
              w1_sdxVK)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Either
                                   a_adwUm
                                   b_adwUn>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Either a_adwUm b_adwUn>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_adwUm b_adwUn -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Either a_adwUm b_adwUn) :: *)))

-- RHS size: {terms: 13, types: 24, coercions: 18, joins: 0/0}
Data.Functor.Classes.$w$cliftReadsPrec8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> ReadS a) -> (Int -> ReadS b) -> Int -> ReadS (Either a b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 110 60}]
Data.Functor.Classes.$w$cliftReadsPrec8
  = \ (@ a_sdxVM)
      (@ b_sdxVN)
      (w_sdxVO :: Int -> ReadS a_sdxVM)
      (w1_sdxVQ :: Int -> ReadS b_sdxVN)
      (w2_sdxVS :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Either a_sdxVM b_sdxVN)
        (Data.Functor.Classes.$w$cliftReadPrec3
           @ a_sdxVM
           @ b_sdxVN
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1 @ a_sdxVM w_sdxVO)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <a_sdxVM>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_sdxVM>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (a_sdxVM -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec a_sdxVM :: *)))
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
               @ b_sdxVN w1_sdxVQ)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <b_sdxVN>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <b_sdxVN>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (b_sdxVN -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec b_sdxVN :: *)))
           w2_sdxVS
           @ (Either a_sdxVM b_sdxVN)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Either a_sdxVM b_sdxVN)))

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> ReadS a)
     -> ReadS [a]
     -> (Int -> ReadS b)
     -> ReadS [b]
     -> Int
     -> ReadS (Either a b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxVM)
                 (@ b_sdxVN)
                 (w_sdxVO [Occ=Once] :: Int -> ReadS a_sdxVM)
                 _ [Occ=Dead]
                 (w2_sdxVQ [Occ=Once] :: Int -> ReadS b_sdxVN)
                 _ [Occ=Dead]
                 (w4_sdxVS [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec8
                   @ a_sdxVM @ b_sdxVN w_sdxVO w2_sdxVQ w4_sdxVS}]
Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
  = \ (@ a_sdxVM)
      (@ b_sdxVN)
      (w_sdxVO :: Int -> ReadS a_sdxVM)
      _ [Occ=Dead]
      (w2_sdxVQ :: Int -> ReadS b_sdxVN)
      _ [Occ=Dead]
      (w4_sdxVS :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec8
        @ a_sdxVM @ b_sdxVN w_sdxVO w2_sdxVQ w4_sdxVS

-- RHS size: {terms: 23, types: 20, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq1Maybe_$cliftEq
  :: forall a b. (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx6w)
                 (@ b_adx6x)
                 (ds_ddxfo [Occ=Once!] :: a_adx6w -> b_adx6x -> Bool)
                 (ds1_ddxfp [Occ=Once!] :: Maybe a_adx6w)
                 (ds2_ddxfq [Occ=Once*!] :: Maybe b_adx6x) ->
                 case ds1_ddxfp of {
                   Nothing ->
                     case ds2_ddxfq of {
                       Nothing -> GHC.Types.True;
                       Just _ [Occ=Dead] -> GHC.Types.False
                     };
                   Just ds3_ddxfH [Occ=Once] ->
                     case ds2_ddxfq of {
                       Nothing -> GHC.Types.False;
                       Just y_adwc9 [Occ=Once] -> ds_ddxfo ds3_ddxfH y_adwc9
                     }
                 }}]
Data.Functor.Classes.$fEq1Maybe_$cliftEq
  = \ (@ a_adx6w)
      (@ b_adx6x)
      (ds_ddxfo :: a_adx6w -> b_adx6x -> Bool)
      (ds1_ddxfp :: Maybe a_adx6w)
      (ds2_ddxfq :: Maybe b_adx6x) ->
      case ds1_ddxfp of {
        Nothing ->
          case ds2_ddxfq of {
            Nothing -> GHC.Types.True;
            Just ds3_ddxfG -> GHC.Types.False
          };
        Just ds3_ddxfH ->
          case ds2_ddxfq of {
            Nothing -> GHC.Types.False;
            Just y_adwc9 -> ds_ddxfo ds3_ddxfH y_adwc9
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fEq1Maybe [InlPrag=INLINE (sat-args=0)]
  :: Eq1 Maybe
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1Maybe_$cliftEq
               `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Maybe>_N)
                       :: (forall a b.
                           (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool :: *)
                          ~R# (Eq1 Maybe :: Constraint))}]
Data.Functor.Classes.$fEq1Maybe
  = Data.Functor.Classes.$fEq1Maybe_$cliftEq
    `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Maybe>_N)
            :: (forall a b.
                (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool :: *)
               ~R# (Eq1 Maybe :: Constraint))

Rec {
-- RHS size: {terms: 31, types: 29, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 [Occ=LoopBreaker]
  :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []]
Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
  = \ (@ a_adx6j)
      (@ b_adx6k)
      (ds_ddxeX :: a_adx6j -> b_adx6k -> Bool)
      (ds1_ddxeY :: [a_adx6j])
      (ds2_ddxeZ :: [b_adx6k]) ->
      case ds1_ddxeY of {
        [] ->
          case ds2_ddxeZ of {
            [] -> GHC.Types.True;
            : ds3_ddxfk ds4_ddxfl -> GHC.Types.False
          };
        : ds3_ddxfm ds4_ddxfn ->
          case ds2_ddxeZ of {
            [] -> GHC.Types.False;
            : y_adwbY ys_adwbZ ->
              case ds_ddxeX ds3_ddxfm y_adwbY of {
                False -> GHC.Types.False;
                True ->
                  Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                    @ a_adx6j @ b_adx6k ds_ddxeX ds4_ddxfn ys_adwbZ
              }
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fEq1[] [InlPrag=INLINE (sat-args=0)]
  :: Eq1 []
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
               `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <[]>_N)
                       :: (forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool :: *)
                          ~R# (Eq1 [] :: Constraint))}]
Data.Functor.Classes.$fEq1[]
  = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
    `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <[]>_N)
            :: (forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool :: *)
               ~R# (Eq1 [] :: Constraint))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> Bool) -> a -> [a] -> b -> [b] -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0 0] 90 10}]
Data.Functor.Classes.$w$cliftEq
  = \ (@ a_sdxVZ)
      (@ b_sdxW0)
      (w_sdxW1 :: a_sdxVZ -> b_sdxW0 -> Bool)
      (ww_sdxW6 :: a_sdxVZ)
      (ww1_sdxW7 :: [a_sdxVZ])
      (ww2_sdxWb :: b_sdxW0)
      (ww3_sdxWc :: [b_sdxW0]) ->
      case w_sdxW1 ww_sdxW6 ww2_sdxWb of {
        False -> GHC.Types.False;
        True ->
          Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
            @ a_sdxVZ @ b_sdxW0 w_sdxW1 ww1_sdxW7 ww3_sdxWc
      }

-- RHS size: {terms: 17, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq1NonEmpty_$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> Bool) -> NonEmpty a -> NonEmpty b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxVZ)
                 (@ b_sdxW0)
                 (w_sdxW1 [Occ=Once] :: a_sdxVZ -> b_sdxW0 -> Bool)
                 (w1_sdxW2 [Occ=Once!] :: NonEmpty a_sdxVZ)
                 (w2_sdxW3 [Occ=Once!] :: NonEmpty b_sdxW0) ->
                 case w1_sdxW2 of { :| ww1_sdxW6 [Occ=Once] ww2_sdxW7 [Occ=Once] ->
                 case w2_sdxW3 of { :| ww4_sdxWb [Occ=Once] ww5_sdxWc [Occ=Once] ->
                 Data.Functor.Classes.$w$cliftEq
                   @ a_sdxVZ @ b_sdxW0 w_sdxW1 ww1_sdxW6 ww2_sdxW7 ww4_sdxWb ww5_sdxWc
                 }
                 }}]
Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
  = \ (@ a_sdxVZ)
      (@ b_sdxW0)
      (w_sdxW1 :: a_sdxVZ -> b_sdxW0 -> Bool)
      (w1_sdxW2 :: NonEmpty a_sdxVZ)
      (w2_sdxW3 :: NonEmpty b_sdxW0) ->
      case w1_sdxW2 of { :| ww1_sdxW6 ww2_sdxW7 ->
      case w2_sdxW3 of { :| ww4_sdxWb ww5_sdxWc ->
      Data.Functor.Classes.$w$cliftEq
        @ a_sdxVZ @ b_sdxW0 w_sdxW1 ww1_sdxW6 ww2_sdxW7 ww4_sdxWb ww5_sdxWc
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fEq1NonEmpty [InlPrag=INLINE (sat-args=0)]
  :: Eq1 NonEmpty
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
               `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <NonEmpty>_N)
                       :: (forall a b.
                           (a -> b -> Bool) -> NonEmpty a -> NonEmpty b -> Bool :: *)
                          ~R# (Eq1 NonEmpty :: Constraint))}]
Data.Functor.Classes.$fEq1NonEmpty
  = Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
    `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <NonEmpty>_N)
            :: (forall a b.
                (a -> b -> Bool) -> NonEmpty a -> NonEmpty b -> Bool :: *)
               ~R# (Eq1 NonEmpty :: Constraint))

-- RHS size: {terms: 8, types: 11, coercions: 4, joins: 0/0}
Data.Functor.Classes.$fEq1Identity_$cliftEq
  :: forall a b. (a -> b -> Bool) -> Identity a -> Identity b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx5Y)
                 (@ b_adx5Z)
                 (eq_adwaA [Occ=Once!] :: a_adx5Y -> b_adx5Z -> Bool)
                 (ds_ddxeH [Occ=Once] :: Identity a_adx5Y)
                 (ds1_ddxeI [Occ=Once] :: Identity b_adx5Z) ->
                 eq_adwaA
                   (ds_ddxeH
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_adx5Y>_R
                            :: (Identity a_adx5Y :: *) ~R# (a_adx5Y :: *)))
                   (ds1_ddxeI
                    `cast` (Data.Functor.Identity.N:Identity[0] <b_adx5Z>_R
                            :: (Identity b_adx5Z :: *) ~R# (b_adx5Z :: *)))}]
Data.Functor.Classes.$fEq1Identity_$cliftEq
  = \ (@ a_adx5Y)
      (@ b_adx5Z)
      (eq_adwaA :: a_adx5Y -> b_adx5Z -> Bool)
      (ds_ddxeH :: Identity a_adx5Y)
      (ds1_ddxeI :: Identity b_adx5Z) ->
      eq_adwaA
        (ds_ddxeH
         `cast` (Data.Functor.Identity.N:Identity[0] <a_adx5Y>_R
                 :: (Identity a_adx5Y :: *) ~R# (a_adx5Y :: *)))
        (ds1_ddxeI
         `cast` (Data.Functor.Identity.N:Identity[0] <b_adx5Z>_R
                 :: (Identity b_adx5Z :: *) ~R# (b_adx5Z :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fEq1Identity [InlPrag=INLINE (sat-args=0)]
  :: Eq1 Identity
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1Identity_$cliftEq
               `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Identity>_N)
                       :: (forall a b.
                           (a -> b -> Bool) -> Identity a -> Identity b -> Bool :: *)
                          ~R# (Eq1 Identity :: Constraint))}]
Data.Functor.Classes.$fEq1Identity
  = Data.Functor.Classes.$fEq1Identity_$cliftEq
    `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Identity>_N)
            :: (forall a b.
                (a -> b -> Bool) -> Identity a -> Identity b -> Bool :: *)
               ~R# (Eq1 Identity :: Constraint))

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq1Proxy_$cliftEq
  :: forall a b. (a -> b -> Bool) -> Proxy a -> Proxy b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx5Q)
                 (@ b_adx5R)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Types.True}]
Data.Functor.Classes.$fEq1Proxy_$cliftEq
  = \ (@ a_adx5Q)
      (@ b_adx5R)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Types.True

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fEq1Proxy [InlPrag=INLINE (sat-args=0)]
  :: Eq1 Proxy
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1Proxy_$cliftEq
               `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Proxy>_N)
                       :: (forall a b.
                           (a -> b -> Bool) -> Proxy a -> Proxy b -> Bool :: *)
                          ~R# (Eq1 Proxy :: Constraint))}]
Data.Functor.Classes.$fEq1Proxy
  = Data.Functor.Classes.$fEq1Proxy_$cliftEq
    `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Proxy>_N)
            :: (forall a b.
                (a -> b -> Bool) -> Proxy a -> Proxy b -> Bool :: *)
               ~R# (Eq1 Proxy :: Constraint))

-- RHS size: {terms: 23, types: 20, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1Maybe_$cliftCompare
  :: forall a b.
     (a -> b -> Ordering) -> Maybe a -> Maybe b -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx5I)
                 (@ b_adx5J)
                 (ds_ddxeg [Occ=Once!] :: a_adx5I -> b_adx5J -> Ordering)
                 (ds1_ddxeh [Occ=Once!] :: Maybe a_adx5I)
                 (ds2_ddxei [Occ=Once*!] :: Maybe b_adx5J) ->
                 case ds1_ddxeh of {
                   Nothing ->
                     case ds2_ddxei of {
                       Nothing -> GHC.Types.EQ;
                       Just _ [Occ=Dead] -> GHC.Types.LT
                     };
                   Just ds3_ddxez [Occ=Once] ->
                     case ds2_ddxei of {
                       Nothing -> GHC.Types.GT;
                       Just y_adwc6 [Occ=Once] -> ds_ddxeg ds3_ddxez y_adwc6
                     }
                 }}]
Data.Functor.Classes.$fOrd1Maybe_$cliftCompare
  = \ (@ a_adx5I)
      (@ b_adx5J)
      (ds_ddxeg :: a_adx5I -> b_adx5J -> Ordering)
      (ds1_ddxeh :: Maybe a_adx5I)
      (ds2_ddxei :: Maybe b_adx5J) ->
      case ds1_ddxeh of {
        Nothing ->
          case ds2_ddxei of {
            Nothing -> GHC.Types.EQ;
            Just ds3_ddxey -> GHC.Types.LT
          };
        Just ds3_ddxez ->
          case ds2_ddxei of {
            Nothing -> GHC.Types.GT;
            Just y_adwc6 -> ds_ddxeg ds3_ddxez y_adwc6
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fOrd1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord1 Maybe
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord1 TYPE: Maybe
                                   Data.Functor.Classes.$fEq1Maybe_$cliftEq
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Maybe>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool :: *)
                                              ~R# (Eq1 Maybe :: Constraint))
                                   Data.Functor.Classes.$fOrd1Maybe_$cliftCompare]
Data.Functor.Classes.$fOrd1Maybe
  = Data.Functor.Classes.C:Ord1
      @ Maybe
      (Data.Functor.Classes.$fEq1Maybe_$cliftEq
       `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Maybe>_N)
               :: (forall a b.
                   (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool :: *)
                  ~R# (Eq1 Maybe :: Constraint)))
      Data.Functor.Classes.$fOrd1Maybe_$cliftCompare

Rec {
-- RHS size: {terms: 33, types: 29, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1 [Occ=LoopBreaker]
  :: forall a b. (a -> b -> Ordering) -> [a] -> [b] -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []]
Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
  = \ (@ a_adx5p)
      (@ b_adx5q)
      (ds_ddxdP :: a_adx5p -> b_adx5q -> Ordering)
      (ds1_ddxdQ :: [a_adx5p])
      (ds2_ddxdR :: [b_adx5q]) ->
      case ds1_ddxdQ of {
        [] ->
          case ds2_ddxdR of {
            [] -> GHC.Types.EQ;
            : ds3_ddxec ds4_ddxed -> GHC.Types.LT
          };
        : ds3_ddxee ds4_ddxef ->
          case ds2_ddxdR of {
            [] -> GHC.Types.GT;
            : y_adwbT ys_adwbU ->
              case ds_ddxdP ds3_ddxee y_adwbT of {
                LT -> GHC.Types.LT;
                EQ ->
                  Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                    @ a_adx5p @ b_adx5q ds_ddxdP ds4_ddxef ys_adwbU;
                GT -> GHC.Types.GT
              }
          }
      }
end Rec }

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fOrd1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord1 []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord1 TYPE: []
                                   Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <[]>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool) -> [a] -> [b] -> Bool :: *)
                                              ~R# (Eq1 [] :: Constraint))
                                   Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1]
Data.Functor.Classes.$fOrd1[]
  = Data.Functor.Classes.C:Ord1
      @ []
      (Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
       `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <[]>_N)
               :: (forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool :: *)
                  ~R# (Eq1 [] :: Constraint)))
      Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1

-- RHS size: {terms: 20, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftCompare1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> Ordering) -> a -> [a] -> b -> [b] -> Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0 0] 100 20}]
Data.Functor.Classes.$w$cliftCompare1
  = \ (@ a_sdxWk)
      (@ b_sdxWl)
      (w_sdxWm :: a_sdxWk -> b_sdxWl -> Ordering)
      (ww_sdxWr :: a_sdxWk)
      (ww1_sdxWs :: [a_sdxWk])
      (ww2_sdxWw :: b_sdxWl)
      (ww3_sdxWx :: [b_sdxWl]) ->
      case w_sdxWm ww_sdxWr ww2_sdxWw of {
        LT -> GHC.Types.LT;
        EQ ->
          Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
            @ a_sdxWk @ b_sdxWl w_sdxWm ww1_sdxWs ww3_sdxWx;
        GT -> GHC.Types.GT
      }

-- RHS size: {terms: 17, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> Ordering) -> NonEmpty a -> NonEmpty b -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxWk)
                 (@ b_sdxWl)
                 (w_sdxWm [Occ=Once] :: a_sdxWk -> b_sdxWl -> Ordering)
                 (w1_sdxWn [Occ=Once!] :: NonEmpty a_sdxWk)
                 (w2_sdxWo [Occ=Once!] :: NonEmpty b_sdxWl) ->
                 case w1_sdxWn of { :| ww1_sdxWr [Occ=Once] ww2_sdxWs [Occ=Once] ->
                 case w2_sdxWo of { :| ww4_sdxWw [Occ=Once] ww5_sdxWx [Occ=Once] ->
                 Data.Functor.Classes.$w$cliftCompare1
                   @ a_sdxWk @ b_sdxWl w_sdxWm ww1_sdxWr ww2_sdxWs ww4_sdxWw ww5_sdxWx
                 }
                 }}]
Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare
  = \ (@ a_sdxWk)
      (@ b_sdxWl)
      (w_sdxWm :: a_sdxWk -> b_sdxWl -> Ordering)
      (w1_sdxWn :: NonEmpty a_sdxWk)
      (w2_sdxWo :: NonEmpty b_sdxWl) ->
      case w1_sdxWn of { :| ww1_sdxWr ww2_sdxWs ->
      case w2_sdxWo of { :| ww4_sdxWw ww5_sdxWx ->
      Data.Functor.Classes.$w$cliftCompare1
        @ a_sdxWk @ b_sdxWl w_sdxWm ww1_sdxWr ww2_sdxWs ww4_sdxWw ww5_sdxWx
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fOrd1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord1 NonEmpty
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord1 TYPE: NonEmpty
                                   Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <NonEmpty>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool)
                                               -> NonEmpty a -> NonEmpty b -> Bool :: *)
                                              ~R# (Eq1 NonEmpty :: Constraint))
                                   Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare]
Data.Functor.Classes.$fOrd1NonEmpty
  = Data.Functor.Classes.C:Ord1
      @ NonEmpty
      (Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
       `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <NonEmpty>_N)
               :: (forall a b.
                   (a -> b -> Bool) -> NonEmpty a -> NonEmpty b -> Bool :: *)
                  ~R# (Eq1 NonEmpty :: Constraint)))
      Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare

-- RHS size: {terms: 8, types: 11, coercions: 4, joins: 0/0}
Data.Functor.Classes.$fOrd1Identity_$cliftCompare
  :: forall a b.
     (a -> b -> Ordering) -> Identity a -> Identity b -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx4U)
                 (@ b_adx4V)
                 (comp_adwax [Occ=Once!] :: a_adx4U -> b_adx4V -> Ordering)
                 (ds_ddxdz [Occ=Once] :: Identity a_adx4U)
                 (ds1_ddxdA [Occ=Once] :: Identity b_adx4V) ->
                 comp_adwax
                   (ds_ddxdz
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_adx4U>_R
                            :: (Identity a_adx4U :: *) ~R# (a_adx4U :: *)))
                   (ds1_ddxdA
                    `cast` (Data.Functor.Identity.N:Identity[0] <b_adx4V>_R
                            :: (Identity b_adx4V :: *) ~R# (b_adx4V :: *)))}]
Data.Functor.Classes.$fOrd1Identity_$cliftCompare
  = \ (@ a_adx4U)
      (@ b_adx4V)
      (comp_adwax :: a_adx4U -> b_adx4V -> Ordering)
      (ds_ddxdz :: Identity a_adx4U)
      (ds1_ddxdA :: Identity b_adx4V) ->
      comp_adwax
        (ds_ddxdz
         `cast` (Data.Functor.Identity.N:Identity[0] <a_adx4U>_R
                 :: (Identity a_adx4U :: *) ~R# (a_adx4U :: *)))
        (ds1_ddxdA
         `cast` (Data.Functor.Identity.N:Identity[0] <b_adx4V>_R
                 :: (Identity b_adx4V :: *) ~R# (b_adx4V :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fOrd1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord1 Identity
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord1 TYPE: Identity
                                   Data.Functor.Classes.$fEq1Identity_$cliftEq
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Identity>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool)
                                               -> Identity a -> Identity b -> Bool :: *)
                                              ~R# (Eq1 Identity :: Constraint))
                                   Data.Functor.Classes.$fOrd1Identity_$cliftCompare]
Data.Functor.Classes.$fOrd1Identity
  = Data.Functor.Classes.C:Ord1
      @ Identity
      (Data.Functor.Classes.$fEq1Identity_$cliftEq
       `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Identity>_N)
               :: (forall a b.
                   (a -> b -> Bool) -> Identity a -> Identity b -> Bool :: *)
                  ~R# (Eq1 Identity :: Constraint)))
      Data.Functor.Classes.$fOrd1Identity_$cliftCompare

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1Proxy_$cliftCompare
  :: forall a b.
     (a -> b -> Ordering) -> Proxy a -> Proxy b -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx4I)
                 (@ b_adx4J)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Types.EQ}]
Data.Functor.Classes.$fOrd1Proxy_$cliftCompare
  = \ (@ a_adx4I)
      (@ b_adx4J)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Types.EQ

-- RHS size: {terms: 3, types: 3, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fOrd1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord1 Proxy
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord1 TYPE: Proxy
                                   Data.Functor.Classes.$fEq1Proxy_$cliftEq
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Proxy>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool) -> Proxy a -> Proxy b -> Bool :: *)
                                              ~R# (Eq1 Proxy :: Constraint))
                                   Data.Functor.Classes.$fOrd1Proxy_$cliftCompare]
Data.Functor.Classes.$fOrd1Proxy
  = Data.Functor.Classes.C:Ord1
      @ Proxy
      (Data.Functor.Classes.$fEq1Proxy_$cliftEq
       `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Proxy>_N)
               :: (forall a b.
                   (a -> b -> Bool) -> Proxy a -> Proxy b -> Bool :: *)
                  ~R# (Eq1 Proxy :: Constraint)))
      Data.Functor.Classes.$fOrd1Proxy_$cliftCompare

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1[]_$cliftReadPrec
  :: forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx3A)
                 _ [Occ=Dead]
                 (rl_adwbP [Occ=Once] :: ReadPrec [a_adx3A]) ->
                 rl_adwbP}]
Data.Functor.Classes.$fRead1[]_$cliftReadPrec
  = \ (@ a_adx3A) _ [Occ=Dead] (rl_adwbP :: ReadPrec [a_adx3A]) ->
      rl_adwbP

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1NonEmpty4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1NonEmpty4 = ":|"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1NonEmpty3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1NonEmpty3
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1NonEmpty4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1NonEmpty2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1NonEmpty2 = GHC.Types.I# 6#

-- RHS size: {terms: 75, types: 133, coercions: 0, joins: 0/5}
Data.Functor.Classes.$w$cliftReadsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> ReadS a)
     -> ReadS [a] -> GHC.Prim.Int# -> String -> [(NonEmpty a, String)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0] 522 0}]
Data.Functor.Classes.$w$cliftReadsPrec5
  = \ (@ a_sdxWD)
      (w_sdxWE :: Int -> ReadS a_sdxWD)
      (w1_sdxWF :: ReadS [a_sdxWD])
      (ww_sdxWK :: GHC.Prim.Int#)
      (w2_sdxWH :: String) ->
      letrec {
        go_sdybt [Occ=LoopBreaker]
          :: [(a_sdxWD, String)] -> [(NonEmpty a_sdxWD, String)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_sdybt
          = \ (ds_i7Jck :: [(a_sdxWD, String)]) ->
              case ds_i7Jck of {
                [] -> GHC.Types.[] @ (NonEmpty a_sdxWD, String);
                : y_i7Jcp ys_i7Jcq ->
                  case y_i7Jcp of { (a1_adwbz, s''_adwbA) ->
                  let {
                    z_X7JiE :: [(NonEmpty a_sdxWD, String)]
                    [LclId]
                    z_X7JiE = go_sdybt ys_i7Jcq } in
                  letrec {
                    go1_X7JiH [Occ=LoopBreaker]
                      :: [(String, String)] -> [(NonEmpty a_sdxWD, String)]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go1_X7JiH
                      = \ (ds1_X7JiJ :: [(String, String)]) ->
                          case ds1_X7JiJ of {
                            [] -> z_X7JiE;
                            : y1_X7JiR ys1_X7JiT ->
                              case y1_X7JiR of { (ds2_ddxd8, s'''_adwbB) ->
                              case GHC.Base.eqString
                                     ds2_ddxd8 Data.Functor.Classes.$fRead1NonEmpty3
                              of {
                                False -> go1_X7JiH ys1_X7JiT;
                                True ->
                                  let {
                                    z1_X7JiY :: [(NonEmpty a_sdxWD, String)]
                                    [LclId]
                                    z1_X7JiY = go1_X7JiH ys1_X7JiT } in
                                  letrec {
                                    go2_X7Jj1 [Occ=LoopBreaker]
                                      :: [([a_sdxWD], String)] -> [(NonEmpty a_sdxWD, String)]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                    go2_X7Jj1
                                      = \ (ds3_X7Jj3 :: [([a_sdxWD], String)]) ->
                                          case ds3_X7Jj3 of {
                                            [] -> z1_X7JiY;
                                            : y2_X7Jjb ys2_X7Jjd ->
                                              case y2_X7Jjb of { (as_adwbC, s''''_adwbD) ->
                                              GHC.Types.:
                                                @ (NonEmpty a_sdxWD, String)
                                                (GHC.Base.:| @ a_sdxWD a1_adwbz as_adwbC,
                                                 s''''_adwbD)
                                                (go2_X7Jj1 ys2_X7Jjd)
                                              }
                                          }; } in
                                  go2_X7Jj1 (w1_sdxWF s'''_adwbB)
                              }
                              }
                          }; } in
                  go1_X7JiH
                    (Text.ParserCombinators.ReadP.run @ String GHC.Read.lex1 s''_adwbA)
                  }
              }; } in
      readParen
        @ (NonEmpty a_sdxWD)
        (GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># ww_sdxWK 5#))
        (\ (s'_adwby :: String) ->
           go_sdybt (w_sdxWE Data.Functor.Classes.$fRead1NonEmpty2 s'_adwby))
        w2_sdxWH

-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxWD)
                 (w_sdxWE [Occ=Once] :: Int -> ReadS a_sdxWD)
                 (w1_sdxWF [Occ=Once] :: ReadS [a_sdxWD])
                 (w2_sdxWG [Occ=Once!] :: Int)
                 (w3_sdxWH [Occ=Once] :: String) ->
                 case w2_sdxWG of { GHC.Types.I# ww1_sdxWK [Occ=Once] ->
                 Data.Functor.Classes.$w$cliftReadsPrec5
                   @ a_sdxWD w_sdxWE w1_sdxWF ww1_sdxWK w3_sdxWH
                 }}]
Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
  = \ (@ a_sdxWD)
      (w_sdxWE :: Int -> ReadS a_sdxWD)
      (w1_sdxWF :: ReadS [a_sdxWD])
      (w2_sdxWG :: Int)
      (w3_sdxWH :: String) ->
      case w2_sdxWG of { GHC.Types.I# ww1_sdxWK ->
      Data.Functor.Classes.$w$cliftReadsPrec5
        @ a_sdxWD w_sdxWE w1_sdxWF ww1_sdxWK w3_sdxWH
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$fRead1Proxy4 = "Proxy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Proxy3
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Proxy4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy_lexeme :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Proxy_lexeme
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Proxy3

-- RHS size: {terms: 13, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy2
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,1*C1(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx1j)
                 _ [Occ=Dead]
                 (@ b_X81cg)
                 (eta1_X6E [Occ=Once!]
                    :: Proxy a_adx1j -> Text.ParserCombinators.ReadP.P b_X81cg) ->
                 case Text.Read.Lex.$wexpect
                        Data.Functor.Classes.$fRead1Proxy_lexeme
                        @ b_X81cg
                        (\ _ [Occ=Dead, OS=OneShot] ->
                           eta1_X6E (Data.Proxy.Proxy @ * @ a_adx1j))
                 of
                 { (# ww1_i88Ww [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_X81cg ww1_i88Ww
                 }}]
Data.Functor.Classes.$fRead1Proxy2
  = \ (@ a_adx1j)
      _ [Occ=Dead]
      (@ b_X81cg)
      (eta1_X6E
         :: Proxy a_adx1j -> Text.ParserCombinators.ReadP.P b_X81cg) ->
      case Text.Read.Lex.$wexpect
             Data.Functor.Classes.$fRead1Proxy_lexeme
             @ b_X81cg
             (\ _ [Occ=Dead, OS=OneShot] ->
                eta1_X6E (Data.Proxy.Proxy @ * @ a_adx1j))
      of
      { (# ww1_i88Ww #) ->
      Text.ParserCombinators.ReadP.Look @ b_X81cg ww1_i88Ww
      }

-- RHS size: {terms: 3, types: 7, coercions: 15, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Functor.Classes.$fRead1Proxy1
  = \ (@ a_adx1j) ->
      GHC.Read.list3
        @ (Proxy a_adx1j)
        ((Data.Functor.Classes.$fRead1Proxy2 @ a_adx1j)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Proxy
                                   a_adx1j>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Proxy a_adx1j>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Proxy a_adx1j -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Proxy a_adx1j) :: *)))

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy5
  :: forall a.
     ReadPrec a
     -> ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx1j) _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Functor.Classes.$fRead1Proxy1 @ a_adx1j}]
Data.Functor.Classes.$fRead1Proxy5
  = \ (@ a_adx1j) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Functor.Classes.$fRead1Proxy1 @ a_adx1j

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> [a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx0x)
                 _ [Occ=Dead]
                 (sl_adwbO [Occ=Once] :: [a_adx0x] -> ShowS)
                 _ [Occ=Dead] ->
                 sl_adwbO}]
Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
  = \ (@ a_adx0x)
      _ [Occ=Dead]
      (sl_adwbO :: [a_adx0x] -> ShowS)
      _ [Occ=Dead] ->
      sl_adwbO

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1NonEmpty1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fShow1NonEmpty1 = " :| "#

-- RHS size: {terms: 35, types: 21, coercions: 0, joins: 0/2}
Data.Functor.Classes.$w$cliftShowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS) -> GHC.Prim.Int# -> a -> [a] -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0 0] 271 120}]
Data.Functor.Classes.$w$cliftShowsPrec1
  = \ (@ a_sdxWN)
      (w_sdxWO :: Int -> a_sdxWN -> ShowS)
      (w1_sdxWP :: [a_sdxWN] -> ShowS)
      (ww_sdxWU :: GHC.Prim.Int#)
      (ww1_sdxWY :: a_sdxWN)
      (ww2_sdxWZ :: [a_sdxWN]) ->
      let {
        f_sdxtw [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sdxtw
          = w_sdxWO Data.Functor.Classes.$fRead1NonEmpty2 ww1_sdxWY } in
      let {
        g_sdxtu [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sdxtu = w1_sdxWP ww2_sdxWZ } in
      case GHC.Prim.># ww_sdxWU 5# of {
        __DEFAULT ->
          \ (x_X7RB5 :: String) ->
            f_sdxtw
              (GHC.CString.unpackAppendCString#
                 Data.Functor.Classes.$fShow1NonEmpty1 (g_sdxtu x_X7RB5));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (f_sdxtw
                 (GHC.CString.unpackAppendCString#
                    Data.Functor.Classes.$fShow1NonEmpty1
                    (g_sdxtu (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))
      }

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> NonEmpty a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxWN)
                 (w_sdxWO [Occ=Once] :: Int -> a_sdxWN -> ShowS)
                 (w1_sdxWP [Occ=Once] :: [a_sdxWN] -> ShowS)
                 (w2_sdxWQ [Occ=Once!] :: Int)
                 (w3_sdxWR [Occ=Once!] :: NonEmpty a_sdxWN) ->
                 case w2_sdxWQ of { GHC.Types.I# ww1_sdxWU [Occ=Once] ->
                 case w3_sdxWR of { :| ww3_sdxWY [Occ=Once] ww4_sdxWZ [Occ=Once] ->
                 Data.Functor.Classes.$w$cliftShowsPrec1
                   @ a_sdxWN w_sdxWO w1_sdxWP ww1_sdxWU ww3_sdxWY ww4_sdxWZ
                 }
                 }}]
Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
  = \ (@ a_sdxWN)
      (w_sdxWO :: Int -> a_sdxWN -> ShowS)
      (w1_sdxWP :: [a_sdxWN] -> ShowS)
      (w2_sdxWQ :: Int)
      (w3_sdxWR :: NonEmpty a_sdxWN) ->
      case w2_sdxWQ of { GHC.Types.I# ww1_sdxWU ->
      case w3_sdxWR of { :| ww3_sdxWY ww4_sdxWZ ->
      Data.Functor.Classes.$w$cliftShowsPrec1
        @ a_sdxWN w_sdxWO w1_sdxWP ww1_sdxWU ww3_sdxWY ww4_sdxWZ
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Proxy2 :: [Char] -> [Char]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Functor.Classes.$fShow1Proxy2
  = ++ @ Char Data.Functor.Classes.$fRead1Proxy3

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> Proxy a -> ShowS
[GblId,
 Arity=5,
 Str=<L,A><L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwZA)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 Data.Functor.Classes.$fShow1Proxy2}]
Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
  = \ (@ a_adwZA)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Functor.Classes.$fShow1Proxy2

-- RHS size: {terms: 24, types: 31, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq2(,)_$cliftEq2
  :: forall a b c d.
     (a -> b -> Bool) -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwZq)
                 (@ b_adwZr)
                 (@ c_adwZs)
                 (@ d_adwZt)
                 (e1_adwbj [Occ=Once!] :: a_adwZq -> b_adwZr -> Bool)
                 (e2_adwbk [Occ=Once!] :: c_adwZs -> d_adwZt -> Bool)
                 (ds_ddxbQ [Occ=Once!] :: (a_adwZq, c_adwZs))
                 (ds1_ddxbR [Occ=Once!] :: (b_adwZr, d_adwZt)) ->
                 case ds_ddxbQ of { (x1_adwbl [Occ=Once], y1_adwbm [Occ=Once]) ->
                 case ds1_ddxbR of { (x2_adwbn [Occ=Once], y2_adwbo [Occ=Once]) ->
                 case e1_adwbj x1_adwbl x2_adwbn of {
                   False -> GHC.Types.False;
                   True -> e2_adwbk y1_adwbm y2_adwbo
                 }
                 }
                 }}]
Data.Functor.Classes.$fEq2(,)_$cliftEq2
  = \ (@ a_adwZq)
      (@ b_adwZr)
      (@ c_adwZs)
      (@ d_adwZt)
      (e1_adwbj :: a_adwZq -> b_adwZr -> Bool)
      (e2_adwbk :: c_adwZs -> d_adwZt -> Bool)
      (ds_ddxbQ :: (a_adwZq, c_adwZs))
      (ds1_ddxbR :: (b_adwZr, d_adwZt)) ->
      case ds_ddxbQ of { (x1_adwbl, y1_adwbm) ->
      case ds1_ddxbR of { (x2_adwbn, y2_adwbo) ->
      case e1_adwbj x1_adwbl x2_adwbn of {
        False -> GHC.Types.False;
        True -> e2_adwbk y1_adwbm y2_adwbo
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fEq2(,) [InlPrag=INLINE (sat-args=0)]
  :: Eq2 (,)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq2(,)_$cliftEq2
               `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <(,)>_N)
                       :: (forall a b c d.
                           (a -> b -> Bool)
                           -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool :: *)
                          ~R# (Eq2 (,) :: Constraint))}]
Data.Functor.Classes.$fEq2(,)
  = Data.Functor.Classes.$fEq2(,)_$cliftEq2
    `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <(,)>_N)
            :: (forall a b c d.
                (a -> b -> Bool)
                -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool :: *)
               ~R# (Eq2 (,) :: Constraint))

-- RHS size: {terms: 24, types: 29, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq1(,)_$cliftEq
  :: forall a.
     Eq a =>
     forall a1 b. (a1 -> b -> Bool) -> (a, a1) -> (a, b) -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwZ4)
                 ($dEq_adwZ5 [Occ=Once] :: Eq a_adwZ4)
                 (@ a1_adwZ9)
                 (@ b_adwZa)
                 (eta_B3 [Occ=Once!] :: a1_adwZ9 -> b_adwZa -> Bool)
                 (eta1_B2 [Occ=Once!] :: (a_adwZ4, a1_adwZ9))
                 (eta2_B1 [Occ=Once!] :: (a_adwZ4, b_adwZa)) ->
                 case eta1_B2 of { (x1_adwbl [Occ=Once], y1_adwbm [Occ=Once]) ->
                 case eta2_B1 of { (x2_adwbn [Occ=Once], y2_adwbo [Occ=Once]) ->
                 case == @ a_adwZ4 $dEq_adwZ5 x1_adwbl x2_adwbn of {
                   False -> GHC.Types.False;
                   True -> eta_B3 y1_adwbm y2_adwbo
                 }
                 }
                 }}]
Data.Functor.Classes.$fEq1(,)_$cliftEq
  = \ (@ a_adwZ4)
      ($dEq_adwZ5 :: Eq a_adwZ4)
      (@ a1_adwZ9)
      (@ b_adwZa)
      (eta_B3 :: a1_adwZ9 -> b_adwZa -> Bool)
      (eta1_B2 :: (a_adwZ4, a1_adwZ9))
      (eta2_B1 :: (a_adwZ4, b_adwZa)) ->
      case eta1_B2 of { (x1_adwbl, y1_adwbm) ->
      case eta2_B1 of { (x2_adwbn, y2_adwbo) ->
      case == @ a_adwZ4 $dEq_adwZ5 x1_adwbl x2_adwbn of {
        False -> GHC.Types.False;
        True -> eta_B3 y1_adwbm y2_adwbo
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
Data.Functor.Classes.$fEq1(,) [InlPrag=INLINE (sat-args=0)]
  :: forall a. Eq a => Eq1 ((,) a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1(,)_$cliftEq
               `cast` (forall (a :: <*>_N).
                       <Eq a>_R ->_R Sym (Data.Functor.Classes.N:Eq1[0] <(,) a>_N)
                       :: (forall a.
                           Eq a =>
                           forall a b. (a -> b -> Bool) -> (a, a) -> (a, b) -> Bool :: *)
                          ~R# (forall a. Eq a => Eq1 ((,) a) :: *))}]
Data.Functor.Classes.$fEq1(,)
  = Data.Functor.Classes.$fEq1(,)_$cliftEq
    `cast` (forall (a :: <*>_N).
            <Eq a>_R ->_R Sym (Data.Functor.Classes.N:Eq1[0] <(,) a>_N)
            :: (forall a.
                Eq a =>
                forall a b. (a -> b -> Bool) -> (a, a) -> (a, b) -> Bool :: *)
               ~R# (forall a. Eq a => Eq1 ((,) a) :: *))

-- RHS size: {terms: 28, types: 35, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq2Either_$cliftEq2
  :: forall a b c d.
     (a -> b -> Bool)
     -> (c -> d -> Bool) -> Either a c -> Either b d -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 80 60] 120 20}]
Data.Functor.Classes.$fEq2Either_$cliftEq2
  = \ (@ a_adwYX)
      (@ b_adwYY)
      (@ c_adwYZ)
      (@ d_adwZ0)
      (e1_adwaV :: a_adwYX -> b_adwYY -> Bool)
      (ds_ddxbm :: c_adwYZ -> d_adwZ0 -> Bool)
      (ds1_ddxbn :: Either a_adwYX c_adwYZ)
      (ds2_ddxbo :: Either b_adwYY d_adwZ0) ->
      case ds1_ddxbn of {
        Left x_adwaW ->
          case ds2_ddxbo of {
            Left y_adwaX -> e1_adwaV x_adwaW y_adwaX;
            Right ds3_ddxbM -> GHC.Types.False
          };
        Right ds3_ddxbN ->
          case ds2_ddxbo of {
            Left ds4_ddxbO -> GHC.Types.False;
            Right y_adwb0 -> ds_ddxbm ds3_ddxbN y_adwb0
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fEq2Either [InlPrag=INLINE (sat-args=0)]
  :: Eq2 Either
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq2Either_$cliftEq2
               `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Either>_N)
                       :: (forall a b c d.
                           (a -> b -> Bool)
                           -> (c -> d -> Bool) -> Either a c -> Either b d -> Bool :: *)
                          ~R# (Eq2 Either :: Constraint))}]
Data.Functor.Classes.$fEq2Either
  = Data.Functor.Classes.$fEq2Either_$cliftEq2
    `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Either>_N)
            :: (forall a b c d.
                (a -> b -> Bool)
                -> (c -> d -> Bool) -> Either a c -> Either b d -> Bool :: *)
               ~R# (Eq2 Either :: Constraint))

-- RHS size: {terms: 28, types: 33, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fEq1Either_$cliftEq
  :: forall a.
     Eq a =>
     forall a1 b. (a1 -> b -> Bool) -> Either a a1 -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 80 60] 130 20}]
Data.Functor.Classes.$fEq1Either_$cliftEq
  = \ (@ a_adwYB)
      ($dEq_adwYC :: Eq a_adwYB)
      (@ a1_adwYG)
      (@ b_adwYH)
      (eta_B3 :: a1_adwYG -> b_adwYH -> Bool)
      (eta1_B2 :: Either a_adwYB a1_adwYG)
      (eta2_B1 :: Either a_adwYB b_adwYH) ->
      case eta1_B2 of {
        Left x_adwaW ->
          case eta2_B1 of {
            Left y_adwaX -> == @ a_adwYB $dEq_adwYC x_adwaW y_adwaX;
            Right ds_ddxbM -> GHC.Types.False
          };
        Right ds_ddxbN ->
          case eta2_B1 of {
            Left ds1_ddxbO -> GHC.Types.False;
            Right y_adwb0 -> eta_B3 ds_ddxbN y_adwb0
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
Data.Functor.Classes.$fEq1Either [InlPrag=INLINE (sat-args=0)]
  :: forall a. Eq a => Eq1 (Either a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1Either_$cliftEq
               `cast` (forall (a :: <*>_N).
                       <Eq a>_R ->_R Sym (Data.Functor.Classes.N:Eq1[0] <Either a>_N)
                       :: (forall a.
                           Eq a =>
                           forall a b.
                           (a -> b -> Bool) -> Either a a -> Either a b -> Bool :: *)
                          ~R# (forall a. Eq a => Eq1 (Either a) :: *))}]
Data.Functor.Classes.$fEq1Either
  = Data.Functor.Classes.$fEq1Either_$cliftEq
    `cast` (forall (a :: <*>_N).
            <Eq a>_R ->_R Sym (Data.Functor.Classes.N:Eq1[0] <Either a>_N)
            :: (forall a.
                Eq a =>
                forall a b.
                (a -> b -> Bool) -> Either a a -> Either a b -> Bool :: *)
               ~R# (forall a. Eq a => Eq1 (Either a) :: *))

-- RHS size: {terms: 11, types: 24, coercions: 10, joins: 0/0}
Data.Functor.Classes.$fEq2Const_$cliftEq2
  :: forall a b c d.
     (a -> b -> Bool)
     -> (c -> d -> Bool) -> Const a c -> Const b d -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwYu)
                 (@ b_adwYv)
                 (@ c_adwYw)
                 (@ d_adwYx)
                 (eq_adwaq [Occ=Once!] :: a_adwYu -> b_adwYv -> Bool)
                 _ [Occ=Dead]
                 (ds1_ddxbd [Occ=Once] :: Const a_adwYu c_adwYw)
                 (ds2_ddxbe [Occ=Once] :: Const b_adwYv d_adwYx) ->
                 eq_adwaq
                   (ds1_ddxbd
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwYu>_R <c_adwYw>_P
                            :: (Const a_adwYu c_adwYw :: *) ~R# (a_adwYu :: *)))
                   (ds2_ddxbe
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <b_adwYv>_R <d_adwYx>_P
                            :: (Const b_adwYv d_adwYx :: *) ~R# (b_adwYv :: *)))}]
Data.Functor.Classes.$fEq2Const_$cliftEq2
  = \ (@ a_adwYu)
      (@ b_adwYv)
      (@ c_adwYw)
      (@ d_adwYx)
      (eq_adwaq :: a_adwYu -> b_adwYv -> Bool)
      _ [Occ=Dead]
      (ds1_ddxbd :: Const a_adwYu c_adwYw)
      (ds2_ddxbe :: Const b_adwYv d_adwYx) ->
      eq_adwaq
        (ds1_ddxbd
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwYu>_R <c_adwYw>_P
                 :: (Const a_adwYu c_adwYw :: *) ~R# (a_adwYu :: *)))
        (ds2_ddxbe
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <b_adwYv>_R <d_adwYx>_P
                 :: (Const b_adwYv d_adwYx :: *) ~R# (b_adwYv :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fEq2Const [InlPrag=INLINE (sat-args=0)]
  :: Eq2 Const
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq2Const_$cliftEq2
               `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Const>_N)
                       :: (forall a b c d.
                           (a -> b -> Bool)
                           -> (c -> d -> Bool) -> Const a c -> Const b d -> Bool :: *)
                          ~R# (Eq2 Const :: Constraint))}]
Data.Functor.Classes.$fEq2Const
  = Data.Functor.Classes.$fEq2Const_$cliftEq2
    `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Const>_N)
            :: (forall a b c d.
                (a -> b -> Bool)
                -> (c -> d -> Bool) -> Const a c -> Const b d -> Bool :: *)
               ~R# (Eq2 Const :: Constraint))

-- RHS size: {terms: 11, types: 22, coercions: 10, joins: 0/0}
Data.Functor.Classes.$fEq1Const_$cliftEq
  :: forall a.
     Eq a =>
     forall a1 b. (a1 -> b -> Bool) -> Const a a1 -> Const a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwY8)
                 ($dEq_adwY9 [Occ=Once] :: Eq a_adwY8)
                 (@ a1_adwYd)
                 (@ b_adwYe)
                 _ [Occ=Dead]
                 (eta1_B2 [Occ=Once] :: Const a_adwY8 a1_adwYd)
                 (eta2_B1 [Occ=Once] :: Const a_adwY8 b_adwYe) ->
                 ==
                   @ a_adwY8
                   $dEq_adwY9
                   (eta1_B2
                    `cast` (Data.Functor.Const.N:Const[0]
                                <*>_N <a_adwY8>_R <a1_adwYd>_P
                            :: (Const a_adwY8 a1_adwYd :: *) ~R# (a_adwY8 :: *)))
                   (eta2_B1
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwY8>_R <b_adwYe>_P
                            :: (Const a_adwY8 b_adwYe :: *) ~R# (a_adwY8 :: *)))}]
Data.Functor.Classes.$fEq1Const_$cliftEq
  = \ (@ a_adwY8)
      ($dEq_adwY9 :: Eq a_adwY8)
      (@ a1_adwYd)
      (@ b_adwYe)
      _ [Occ=Dead]
      (eta1_B2 :: Const a_adwY8 a1_adwYd)
      (eta2_B1 :: Const a_adwY8 b_adwYe) ->
      ==
        @ a_adwY8
        $dEq_adwY9
        (eta1_B2
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N <a_adwY8>_R <a1_adwYd>_P
                 :: (Const a_adwY8 a1_adwYd :: *) ~R# (a_adwY8 :: *)))
        (eta2_B1
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwY8>_R <b_adwYe>_P
                 :: (Const a_adwY8 b_adwYe :: *) ~R# (a_adwY8 :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
Data.Functor.Classes.$fEq1Const [InlPrag=INLINE (sat-args=0)]
  :: forall a. Eq a => Eq1 (Const a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Classes.$fEq1Const_$cliftEq
               `cast` (forall (a :: <*>_N).
                       <Eq a>_R ->_R Sym (Data.Functor.Classes.N:Eq1[0] <Const a>_N)
                       :: (forall a.
                           Eq a =>
                           forall a b.
                           (a -> b -> Bool) -> Const a a -> Const a b -> Bool :: *)
                          ~R# (forall a. Eq a => Eq1 (Const a) :: *))}]
Data.Functor.Classes.$fEq1Const
  = Data.Functor.Classes.$fEq1Const_$cliftEq
    `cast` (forall (a :: <*>_N).
            <Eq a>_R ->_R Sym (Data.Functor.Classes.N:Eq1[0] <Const a>_N)
            :: (forall a.
                Eq a =>
                forall a b.
                (a -> b -> Bool) -> Const a a -> Const a b -> Bool :: *)
               ~R# (forall a. Eq a => Eq1 (Const a) :: *))

-- RHS size: {terms: 26, types: 31, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd2(,)_$cliftCompare2
  :: forall a b c d.
     (a -> b -> Ordering)
     -> (c -> d -> Ordering) -> (a, c) -> (b, d) -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwXY)
                 (@ b_adwXZ)
                 (@ c_adwY0)
                 (@ d_adwY1)
                 (comp1_adwbd [Occ=Once!] :: a_adwXY -> b_adwXZ -> Ordering)
                 (comp2_adwbe [Occ=Once!] :: c_adwY0 -> d_adwY1 -> Ordering)
                 (ds_ddxb2 [Occ=Once!] :: (a_adwXY, c_adwY0))
                 (ds1_ddxb3 [Occ=Once!] :: (b_adwXZ, d_adwY1)) ->
                 case ds_ddxb2 of { (x1_adwbf [Occ=Once], y1_adwbg [Occ=Once]) ->
                 case ds1_ddxb3 of { (x2_adwbh [Occ=Once], y2_adwbi [Occ=Once]) ->
                 case comp1_adwbd x1_adwbf x2_adwbh of {
                   LT -> GHC.Types.LT;
                   EQ -> comp2_adwbe y1_adwbg y2_adwbi;
                   GT -> GHC.Types.GT
                 }
                 }
                 }}]
Data.Functor.Classes.$fOrd2(,)_$cliftCompare2
  = \ (@ a_adwXY)
      (@ b_adwXZ)
      (@ c_adwY0)
      (@ d_adwY1)
      (comp1_adwbd :: a_adwXY -> b_adwXZ -> Ordering)
      (comp2_adwbe :: c_adwY0 -> d_adwY1 -> Ordering)
      (ds_ddxb2 :: (a_adwXY, c_adwY0))
      (ds1_ddxb3 :: (b_adwXZ, d_adwY1)) ->
      case ds_ddxb2 of { (x1_adwbf, y1_adwbg) ->
      case ds1_ddxb3 of { (x2_adwbh, y2_adwbi) ->
      case comp1_adwbd x1_adwbf x2_adwbh of {
        LT -> GHC.Types.LT;
        EQ -> comp2_adwbe y1_adwbg y2_adwbi;
        GT -> GHC.Types.GT
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fOrd2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord2 (,)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord2 TYPE: (,)
                                   Data.Functor.Classes.$fEq2(,)_$cliftEq2
                                   `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <(,)>_N)
                                           :: (forall a b c d.
                                               (a -> b -> Bool)
                                               -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool :: *)
                                              ~R# (Eq2 (,) :: Constraint))
                                   Data.Functor.Classes.$fOrd2(,)_$cliftCompare2]
Data.Functor.Classes.$fOrd2(,)
  = Data.Functor.Classes.C:Ord2
      @ (,)
      (Data.Functor.Classes.$fEq2(,)_$cliftEq2
       `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <(,)>_N)
               :: (forall a b c d.
                   (a -> b -> Bool)
                   -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool :: *)
                  ~R# (Eq2 (,) :: Constraint)))
      Data.Functor.Classes.$fOrd2(,)_$cliftCompare2

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Ord a =>
     forall a1 b. (a1 -> b -> Ordering) -> a -> a1 -> a -> b -> Ordering
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0 0 0] 100 20}]
Data.Functor.Classes.$w$cliftCompare
  = \ (@ a_sdxXh)
      (w_sdxXi :: Ord a_sdxXh)
      (@ a1_sdxXj)
      (@ b_sdxXk)
      (w1_sdxXl :: a1_sdxXj -> b_sdxXk -> Ordering)
      (ww_sdxXq :: a_sdxXh)
      (ww1_sdxXr :: a1_sdxXj)
      (ww2_sdxXv :: a_sdxXh)
      (ww3_sdxXw :: b_sdxXk) ->
      case compare @ a_sdxXh w_sdxXi ww_sdxXq ww2_sdxXv of {
        LT -> GHC.Types.LT;
        EQ -> w1_sdxXl ww1_sdxXr ww3_sdxXw;
        GT -> GHC.Types.GT
      }

-- RHS size: {terms: 20, types: 30, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1(,)_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Ord a =>
     forall a1 b. (a1 -> b -> Ordering) -> (a, a1) -> (a, b) -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxXh)
                 (w_sdxXi [Occ=Once] :: Ord a_sdxXh)
                 (@ a1_sdxXj)
                 (@ b_sdxXk)
                 (w1_sdxXl [Occ=Once] :: a1_sdxXj -> b_sdxXk -> Ordering)
                 (w2_sdxXm [Occ=Once!] :: (a_sdxXh, a1_sdxXj))
                 (w3_sdxXn [Occ=Once!] :: (a_sdxXh, b_sdxXk)) ->
                 case w2_sdxXm of { (ww1_sdxXq [Occ=Once], ww2_sdxXr [Occ=Once]) ->
                 case w3_sdxXn of { (ww4_sdxXv [Occ=Once], ww5_sdxXw [Occ=Once]) ->
                 Data.Functor.Classes.$w$cliftCompare
                   @ a_sdxXh
                   w_sdxXi
                   @ a1_sdxXj
                   @ b_sdxXk
                   w1_sdxXl
                   ww1_sdxXq
                   ww2_sdxXr
                   ww4_sdxXv
                   ww5_sdxXw
                 }
                 }}]
Data.Functor.Classes.$fOrd1(,)_$cliftCompare
  = \ (@ a_sdxXh)
      (w_sdxXi :: Ord a_sdxXh)
      (@ a1_sdxXj)
      (@ b_sdxXk)
      (w1_sdxXl :: a1_sdxXj -> b_sdxXk -> Ordering)
      (w2_sdxXm :: (a_sdxXh, a1_sdxXj))
      (w3_sdxXn :: (a_sdxXh, b_sdxXk)) ->
      case w2_sdxXm of { (ww1_sdxXq, ww2_sdxXr) ->
      case w3_sdxXn of { (ww4_sdxXv, ww5_sdxXw) ->
      Data.Functor.Classes.$w$cliftCompare
        @ a_sdxXh
        w_sdxXi
        @ a1_sdxXj
        @ b_sdxXk
        w1_sdxXl
        ww1_sdxXq
        ww2_sdxXr
        ww4_sdxXv
        ww5_sdxXw
      }
      }

-- RHS size: {terms: 21, types: 18, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Ord a =>
     forall a1 b. (a1 -> b -> Bool) -> a -> a1 -> a -> b -> Bool
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0 0 0] 110 10}]
Data.Functor.Classes.$w$cp1Ord1
  = \ (@ a_sdxXz)
      (w_sdxXA :: Ord a_sdxXz)
      (@ a1_sdxXB)
      (@ b_sdxXC)
      (w1_sdxXD :: a1_sdxXB -> b_sdxXC -> Bool)
      (ww_sdxXI :: a_sdxXz)
      (ww1_sdxXJ :: a1_sdxXB)
      (ww2_sdxXN :: a_sdxXz)
      (ww3_sdxXO :: b_sdxXC) ->
      case ==
             @ a_sdxXz (GHC.Classes.$p1Ord @ a_sdxXz w_sdxXA) ww_sdxXI ww2_sdxXN
      of {
        False -> GHC.Types.False;
        True -> w1_sdxXD ww1_sdxXJ ww3_sdxXO
      }

-- RHS size: {terms: 20, types: 30, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1(,)1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Ord a =>
     forall a1 b. (a1 -> b -> Bool) -> (a, a1) -> (a, b) -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxXz)
                 (w_sdxXA [Occ=Once] :: Ord a_sdxXz)
                 (@ a1_sdxXB)
                 (@ b_sdxXC)
                 (w1_sdxXD [Occ=Once] :: a1_sdxXB -> b_sdxXC -> Bool)
                 (w2_sdxXE [Occ=Once!] :: (a_sdxXz, a1_sdxXB))
                 (w3_sdxXF [Occ=Once!] :: (a_sdxXz, b_sdxXC)) ->
                 case w2_sdxXE of { (ww1_sdxXI [Occ=Once], ww2_sdxXJ [Occ=Once]) ->
                 case w3_sdxXF of { (ww4_sdxXN [Occ=Once], ww5_sdxXO [Occ=Once]) ->
                 Data.Functor.Classes.$w$cp1Ord1
                   @ a_sdxXz
                   w_sdxXA
                   @ a1_sdxXB
                   @ b_sdxXC
                   w1_sdxXD
                   ww1_sdxXI
                   ww2_sdxXJ
                   ww4_sdxXN
                   ww5_sdxXO
                 }
                 }}]
Data.Functor.Classes.$fOrd1(,)1
  = \ (@ a_sdxXz)
      (w_sdxXA :: Ord a_sdxXz)
      (@ a1_sdxXB)
      (@ b_sdxXC)
      (w1_sdxXD :: a1_sdxXB -> b_sdxXC -> Bool)
      (w2_sdxXE :: (a_sdxXz, a1_sdxXB))
      (w3_sdxXF :: (a_sdxXz, b_sdxXC)) ->
      case w2_sdxXE of { (ww1_sdxXI, ww2_sdxXJ) ->
      case w3_sdxXF of { (ww4_sdxXN, ww5_sdxXO) ->
      Data.Functor.Classes.$w$cp1Ord1
        @ a_sdxXz
        w_sdxXA
        @ a1_sdxXB
        @ b_sdxXC
        w1_sdxXD
        ww1_sdxXI
        ww2_sdxXJ
        ww4_sdxXN
        ww5_sdxXO
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 4, joins: 0/0}
Data.Functor.Classes.$fOrd1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_adwb3) (v_B1 :: Ord a_adwb3) ->
       Data.Functor.Classes.C:Ord1 TYPE: (,) a_adwb3
                                   (Data.Functor.Classes.$fOrd1(,)1 @ a_adwb3 v_B1)
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <(,) a_adwb3>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool)
                                               -> (a_adwb3, a) -> (a_adwb3, b) -> Bool :: *)
                                              ~R# (Eq1 ((,) a_adwb3) :: Constraint))
                                   Data.Functor.Classes.$fOrd1(,)_$cliftCompare @ a_adwb3 v_B1]
Data.Functor.Classes.$fOrd1(,)
  = \ (@ a_Xdx1z) ($dOrd_Xdx1B :: Ord a_Xdx1z) ->
      Data.Functor.Classes.C:Ord1
        @ ((,) a_Xdx1z)
        ((Data.Functor.Classes.$fOrd1(,)1 @ a_Xdx1z $dOrd_Xdx1B)
         `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <(,) a_Xdx1z>_N)
                 :: (forall a b.
                     (a -> b -> Bool) -> (a_Xdx1z, a) -> (a_Xdx1z, b) -> Bool :: *)
                    ~R# (Eq1 ((,) a_Xdx1z) :: Constraint)))
        (Data.Functor.Classes.$fOrd1(,)_$cliftCompare
           @ a_Xdx1z $dOrd_Xdx1B)

-- RHS size: {terms: 28, types: 35, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd2Either_$cliftCompare2
  :: forall a b c d.
     (a -> b -> Ordering)
     -> (c -> d -> Ordering) -> Either a c -> Either b d -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 80 60] 120 20}]
Data.Functor.Classes.$fOrd2Either_$cliftCompare2
  = \ (@ a_adwXn)
      (@ b_adwXo)
      (@ c_adwXp)
      (@ d_adwXq)
      (comp1_adwaP :: a_adwXn -> b_adwXo -> Ordering)
      (ds_ddxax :: c_adwXp -> d_adwXq -> Ordering)
      (ds1_ddxay :: Either a_adwXn c_adwXp)
      (ds2_ddxaz :: Either b_adwXo d_adwXq) ->
      case ds1_ddxay of {
        Left x_adwaQ ->
          case ds2_ddxaz of {
            Left y_adwaR -> comp1_adwaP x_adwaQ y_adwaR;
            Right ds3_ddxaX -> GHC.Types.LT
          };
        Right ds3_ddxaY ->
          case ds2_ddxaz of {
            Left ds4_ddxaZ -> GHC.Types.GT;
            Right y_adwaU -> ds_ddxax ds3_ddxaY y_adwaU
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Functor.Classes.$fOrd2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord2 Either
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord2 TYPE: Either
                                   Data.Functor.Classes.$fEq2Either_$cliftEq2
                                   `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Either>_N)
                                           :: (forall a b c d.
                                               (a -> b -> Bool)
                                               -> (c -> d -> Bool)
                                               -> Either a c
                                               -> Either b d
                                               -> Bool :: *)
                                              ~R# (Eq2 Either :: Constraint))
                                   Data.Functor.Classes.$fOrd2Either_$cliftCompare2]
Data.Functor.Classes.$fOrd2Either
  = Data.Functor.Classes.C:Ord2
      @ Either
      (Data.Functor.Classes.$fEq2Either_$cliftEq2
       `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Either>_N)
               :: (forall a b c d.
                   (a -> b -> Bool)
                   -> (c -> d -> Bool) -> Either a c -> Either b d -> Bool :: *)
                  ~R# (Eq2 Either :: Constraint)))
      Data.Functor.Classes.$fOrd2Either_$cliftCompare2

-- RHS size: {terms: 28, types: 33, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1Either_$cliftCompare
  :: forall a.
     Ord a =>
     forall a1 b.
     (a1 -> b -> Ordering) -> Either a a1 -> Either a b -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 80 60] 130 20}]
Data.Functor.Classes.$fOrd1Either_$cliftCompare
  = \ (@ a_adwWT)
      ($dOrd_adwWU :: Ord a_adwWT)
      (@ a1_adwX2)
      (@ b_adwX3)
      (eta_B3 :: a1_adwX2 -> b_adwX3 -> Ordering)
      (eta1_B2 :: Either a_adwWT a1_adwX2)
      (eta2_B1 :: Either a_adwWT b_adwX3) ->
      case eta1_B2 of {
        Left x_adwaQ ->
          case eta2_B1 of {
            Left y_adwaR -> compare @ a_adwWT $dOrd_adwWU x_adwaQ y_adwaR;
            Right ds_ddxaX -> GHC.Types.LT
          };
        Right ds_ddxaY ->
          case eta2_B1 of {
            Left ds1_ddxaZ -> GHC.Types.GT;
            Right y_adwaU -> eta_B3 ds_ddxaY y_adwaU
          }
      }

-- RHS size: {terms: 29, types: 34, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fOrd1Either1
  :: forall a.
     Ord a =>
     forall a1 b. (a1 -> b -> Bool) -> Either a a1 -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 80 60] 150 20}]
Data.Functor.Classes.$fOrd1Either1
  = \ (@ a_adwWT)
      ($dOrd_adwWU :: Ord a_adwWT)
      (@ a1_adwad)
      (@ b_adwae)
      (eta_B3 :: a1_adwad -> b_adwae -> Bool)
      (eta1_B2 :: Either a_adwWT a1_adwad)
      (eta2_B1 :: Either a_adwWT b_adwae) ->
      case eta1_B2 of {
        Left x_adwaW ->
          case eta2_B1 of {
            Left y_adwaX ->
              ==
                @ a_adwWT
                (GHC.Classes.$p1Ord @ a_adwWT $dOrd_adwWU)
                x_adwaW
                y_adwaX;
            Right ds_ddxbM -> GHC.Types.False
          };
        Right ds_ddxbN ->
          case eta2_B1 of {
            Left ds1_ddxbO -> GHC.Types.False;
            Right y_adwb0 -> eta_B3 ds_ddxbN y_adwb0
          }
      }

-- RHS size: {terms: 7, types: 8, coercions: 4, joins: 0/0}
Data.Functor.Classes.$fOrd1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord1 (Either a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_adwaF) (v_B1 :: Ord a_adwaF) ->
       Data.Functor.Classes.C:Ord1 TYPE: Either a_adwaF
                                   (Data.Functor.Classes.$fOrd1Either1 @ a_adwaF v_B1)
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Either a_adwaF>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool)
                                               -> Either a_adwaF a -> Either a_adwaF b -> Bool :: *)
                                              ~R# (Eq1 (Either a_adwaF) :: Constraint))
                                   Data.Functor.Classes.$fOrd1Either_$cliftCompare @ a_adwaF v_B1]
Data.Functor.Classes.$fOrd1Either
  = \ (@ a_Xdx16) ($dOrd_Xdx18 :: Ord a_Xdx16) ->
      Data.Functor.Classes.C:Ord1
        @ (Either a_Xdx16)
        ((Data.Functor.Classes.$fOrd1Either1 @ a_Xdx16 $dOrd_Xdx18)
         `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Either a_Xdx16>_N)
                 :: (forall a b.
                     (a -> b -> Bool)
                     -> Either a_Xdx16 a -> Either a_Xdx16 b -> Bool :: *)
                    ~R# (Eq1 (Either a_Xdx16) :: Constraint)))
        (Data.Functor.Classes.$fOrd1Either_$cliftCompare
           @ a_Xdx16 $dOrd_Xdx18)

-- RHS size: {terms: 11, types: 24, coercions: 10, joins: 0/0}
Data.Functor.Classes.$fOrd2Const_$cliftCompare2
  :: forall a b c d.
     (a -> b -> Ordering)
     -> (c -> d -> Ordering) -> Const a c -> Const b d -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwWM)
                 (@ b_adwWN)
                 (@ c_adwWO)
                 (@ d_adwWP)
                 (comp_adwan [Occ=Once!] :: a_adwWM -> b_adwWN -> Ordering)
                 _ [Occ=Dead]
                 (ds1_ddxan [Occ=Once] :: Const a_adwWM c_adwWO)
                 (ds2_ddxao [Occ=Once] :: Const b_adwWN d_adwWP) ->
                 comp_adwan
                   (ds1_ddxan
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwWM>_R <c_adwWO>_P
                            :: (Const a_adwWM c_adwWO :: *) ~R# (a_adwWM :: *)))
                   (ds2_ddxao
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <b_adwWN>_R <d_adwWP>_P
                            :: (Const b_adwWN d_adwWP :: *) ~R# (b_adwWN :: *)))}]
Data.Functor.Classes.$fOrd2Const_$cliftCompare2
  = \ (@ a_adwWM)
      (@ b_adwWN)
      (@ c_adwWO)
      (@ d_adwWP)
      (comp_adwan :: a_adwWM -> b_adwWN -> Ordering)
      _ [Occ=Dead]
      (ds1_ddxan :: Const a_adwWM c_adwWO)
      (ds2_ddxao :: Const b_adwWN d_adwWP) ->
      comp_adwan
        (ds1_ddxan
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwWM>_R <c_adwWO>_P
                 :: (Const a_adwWM c_adwWO :: *) ~R# (a_adwWM :: *)))
        (ds2_ddxao
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <b_adwWN>_R <d_adwWP>_P
                 :: (Const b_adwWN d_adwWP :: *) ~R# (b_adwWN :: *)))

-- RHS size: {terms: 3, types: 3, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fOrd2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord2 Const
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Ord2 TYPE: Const
                                   Data.Functor.Classes.$fEq2Const_$cliftEq2
                                   `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Const>_N)
                                           :: (forall a b c d.
                                               (a -> b -> Bool)
                                               -> (c -> d -> Bool)
                                               -> Const a c
                                               -> Const b d
                                               -> Bool :: *)
                                              ~R# (Eq2 Const :: Constraint))
                                   Data.Functor.Classes.$fOrd2Const_$cliftCompare2]
Data.Functor.Classes.$fOrd2Const
  = Data.Functor.Classes.C:Ord2
      @ Const
      (Data.Functor.Classes.$fEq2Const_$cliftEq2
       `cast` (Sym (Data.Functor.Classes.N:Eq2[0] <Const>_N)
               :: (forall a b c d.
                   (a -> b -> Bool)
                   -> (c -> d -> Bool) -> Const a c -> Const b d -> Bool :: *)
                  ~R# (Eq2 Const :: Constraint)))
      Data.Functor.Classes.$fOrd2Const_$cliftCompare2

-- RHS size: {terms: 12, types: 23, coercions: 10, joins: 0/0}
Data.Functor.Classes.$fOrd1Const1
  :: forall a.
     Ord a =>
     forall a1 b. (a1 -> b -> Bool) -> Const a a1 -> Const a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwWi)
                 ($dOrd_adwWj [Occ=Once] :: Ord a_adwWi)
                 (@ a1_adwad)
                 (@ b_adwae)
                 _ [Occ=Dead]
                 (eta1_B2 [Occ=Once] :: Const a_adwWi a1_adwad)
                 (eta2_B1 [Occ=Once] :: Const a_adwWi b_adwae) ->
                 ==
                   @ a_adwWi
                   (GHC.Classes.$p1Ord @ a_adwWi $dOrd_adwWj)
                   (eta1_B2
                    `cast` (Data.Functor.Const.N:Const[0]
                                <*>_N <a_adwWi>_R <a1_adwad>_P
                            :: (Const a_adwWi a1_adwad :: *) ~R# (a_adwWi :: *)))
                   (eta2_B1
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwWi>_R <b_adwae>_P
                            :: (Const a_adwWi b_adwae :: *) ~R# (a_adwWi :: *)))}]
Data.Functor.Classes.$fOrd1Const1
  = \ (@ a_adwWi)
      ($dOrd_adwWj :: Ord a_adwWi)
      (@ a1_adwad)
      (@ b_adwae)
      _ [Occ=Dead]
      (eta1_B2 :: Const a_adwWi a1_adwad)
      (eta2_B1 :: Const a_adwWi b_adwae) ->
      ==
        @ a_adwWi
        (GHC.Classes.$p1Ord @ a_adwWi $dOrd_adwWj)
        (eta1_B2
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N <a_adwWi>_R <a1_adwad>_P
                 :: (Const a_adwWi a1_adwad :: *) ~R# (a_adwWi :: *)))
        (eta2_B1
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwWi>_R <b_adwae>_P
                 :: (Const a_adwWi b_adwae :: *) ~R# (a_adwWi :: *)))

-- RHS size: {terms: 14, types: 27, coercions: 16, joins: 0/0}
Data.Functor.Classes.$fOrd1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord1 (Const a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_adwah) (v_B1 :: Ord a_adwah) ->
       Data.Functor.Classes.C:Ord1 TYPE: Const a_adwah
                                   (Data.Functor.Classes.$fOrd1Const1 @ a_adwah v_B1)
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Const a_adwah>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool)
                                               -> Const a_adwah a -> Const a_adwah b -> Bool :: *)
                                              ~R# (Eq1 (Const a_adwah) :: Constraint))
                                   \ (@ a1_adwWr)
                                     (@ b_adwWs)
                                     _ [Occ=Dead]
                                     (eta1_B2 [Occ=Once] :: Const a_adwah a1_adwWr)
                                     (eta2_X4t [Occ=Once] :: Const a_adwah b_adwWs) ->
                                     compare
                                       @ a_adwah
                                       v_B1
                                       (eta1_B2
                                        `cast` (Data.Functor.Const.N:Const[0]
                                                    <*>_N <a_adwah>_R <a1_adwWr>_P
                                                :: (Const a_adwah a1_adwWr :: *)
                                                   ~R# (a_adwah :: *)))
                                       (eta2_X4t
                                        `cast` (Data.Functor.Const.N:Const[0]
                                                    <*>_N <a_adwah>_R <b_adwWs>_P
                                                :: (Const a_adwah b_adwWs :: *)
                                                   ~R# (a_adwah :: *)))]
Data.Functor.Classes.$fOrd1Const
  = \ (@ a_Xdx0D) ($dOrd_Xdx0F :: Ord a_Xdx0D) ->
      Data.Functor.Classes.C:Ord1
        @ (Const a_Xdx0D)
        ((Data.Functor.Classes.$fOrd1Const1 @ a_Xdx0D $dOrd_Xdx0F)
         `cast` (Sym (Data.Functor.Classes.N:Eq1[0] <Const a_Xdx0D>_N)
                 :: (forall a b.
                     (a -> b -> Bool)
                     -> Const a_Xdx0D a -> Const a_Xdx0D b -> Bool :: *)
                    ~R# (Eq1 (Const a_Xdx0D) :: Constraint)))
        (\ (@ a1_adwWr)
           (@ b_adwWs)
           _ [Occ=Dead]
           (eta1_B2 :: Const a_Xdx0D a1_adwWr)
           (eta2_B1 :: Const a_Xdx0D b_adwWs) ->
           compare
             @ a_Xdx0D
             $dOrd_Xdx0F
             (eta1_B2
              `cast` (Data.Functor.Const.N:Const[0]
                          <*>_N <a_Xdx0D>_R <a1_adwWr>_P
                      :: (Const a_Xdx0D a1_adwWr :: *) ~R# (a_Xdx0D :: *)))
             (eta2_B1
              `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_Xdx0D>_R <b_adwWs>_P
                      :: (Const a_Xdx0D b_adwWs :: *) ~R# (a_Xdx0D :: *))))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1(,)5 = ","#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1(,)4
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1(,)5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)3 :: Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1(,)3
  = Text.Read.Lex.Punc Data.Functor.Classes.$fRead1(,)4

-- RHS size: {terms: 54, types: 107, coercions: 47, joins: 0/2}
Data.Functor.Classes.$w$cliftReadPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ReadPrec a
     -> ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0] 410 0}]
Data.Functor.Classes.$w$cliftReadPrec2
  = \ (@ a_sdxYe)
      (@ b_sdxYf)
      (w_sdxYg :: ReadPrec a_sdxYe)
      (w1_sdxYi :: ReadPrec b_sdxYf)
      (w2_sdxYk :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdxYl)
      (w3_sdxYm
         :: (a_sdxYe, b_sdxYf)
            -> Text.ParserCombinators.ReadP.P b1_sdxYl) ->
      GHC.Read.list3
        @ (a_sdxYe, b_sdxYf)
        (let {
           p_sdy5V [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> forall b2.
                   ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                   -> Text.ParserCombinators.ReadP.P b2
           [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []]
           p_sdy5V
             = \ (n_i88WF :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b2_i88WH)
                 (k1_i88WI [OS=OneShot]
                    :: (a_sdxYe, b_sdxYf)
                       -> Text.ParserCombinators.ReadP.P b2_i88WH) ->
                 (((w_sdxYg
                    `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdxYe>_R
                            :: (ReadPrec a_sdxYe :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.Prec
                                    -> Text.ParserCombinators.ReadP.ReadP a_sdxYe :: *)))
                     n_i88WF)
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdxYe>_R
                          :: (Text.ParserCombinators.ReadP.ReadP a_sdxYe :: *)
                             ~R# (forall b.
                                  (a_sdxYe -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)))
                   @ b2_i88WH
                   (\ (a1_i88WJ :: a_sdxYe) ->
                      case Text.Read.Lex.$wexpect
                             Data.Functor.Classes.$fRead1(,)3
                             @ b2_i88WH
                             (\ _ [Occ=Dead, OS=OneShot] ->
                                (((w1_sdxYi
                                   `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <b_sdxYf>_R
                                           :: (ReadPrec b_sdxYf :: *)
                                              ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                   -> Text.ParserCombinators.ReadP.ReadP
                                                        b_sdxYf :: *)))
                                    n_i88WF)
                                 `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_sdxYf>_R
                                         :: (Text.ParserCombinators.ReadP.ReadP b_sdxYf :: *)
                                            ~R# (forall b.
                                                 (b_sdxYf -> Text.ParserCombinators.ReadP.P b)
                                                 -> Text.ParserCombinators.ReadP.P b :: *)))
                                  @ b2_i88WH
                                  (\ (a3_X8918 :: b_sdxYf) -> k1_i88WI (a1_i88WJ, a3_X8918)))
                      of
                      { (# ww1_i88Ww #) ->
                      Text.ParserCombinators.ReadP.Look @ b2_i88WH ww1_i88Ww
                      }) } in
         let {
           lvl3_sdxur [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> forall b2.
                   ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                   -> Text.ParserCombinators.ReadP.P b2
           [LclId,
            Arity=2,
            Str=<L,U><L,U>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                    Tmpl= \ (w4_idxhM [Occ=Once]
                               :: Text.ParserCombinators.ReadPrec.Prec)
                            (@ b2_idxhN)
                            (w5_idxhO [Occ=Once]
                               :: (a_sdxYe, b_sdxYf)
                                  -> Text.ParserCombinators.ReadP.P b2_idxhN) ->
                            case GHC.Read.$wparen'
                                   @ (a_sdxYe, b_sdxYf)
                                   (p_sdy5V
                                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                           <(a_sdxYe,
                                                             b_sdxYf)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                      <(a_sdxYe,
                                                                                        b_sdxYf)>_R)
                                            :: (Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   ((a_sdxYe, b_sdxYf)
                                                    -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (ReadPrec (a_sdxYe, b_sdxYf) :: *)))
                                   w4_idxhM
                                   @ b2_idxhN
                                   w5_idxhO
                            of
                            { (# ww1_idxhR [Occ=Once] #) ->
                            Text.ParserCombinators.ReadP.Get @ b2_idxhN ww1_idxhR
                            }}]
           lvl3_sdxur
             = \ (w4_idxhM :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b2_idxhN)
                 (w5_idxhO [OS=OneShot]
                    :: (a_sdxYe, b_sdxYf)
                       -> Text.ParserCombinators.ReadP.P b2_idxhN) ->
                 case GHC.Read.$wparen'
                        @ (a_sdxYe, b_sdxYf)
                        (p_sdy5V
                         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                <(a_sdxYe,
                                                  b_sdxYf)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                           <(a_sdxYe, b_sdxYf)>_R)
                                 :: (Text.ParserCombinators.ReadPrec.Prec
                                     -> forall b.
                                        ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b)
                                        -> Text.ParserCombinators.ReadP.P b :: *)
                                    ~R# (ReadPrec (a_sdxYe, b_sdxYf) :: *)))
                        w4_idxhM
                        @ b2_idxhN
                        w5_idxhO
                 of
                 { (# ww1_idxhR #) ->
                 Text.ParserCombinators.ReadP.Get @ b2_idxhN ww1_idxhR
                 } } in
         (\ (eta_idxhn :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b2_idxho)
            (eta1_idxhp
               :: (a_sdxYe, b_sdxYf)
                  -> Text.ParserCombinators.ReadP.P b2_idxho) ->
            case GHC.Read.$wskipSpacesThenP
                   @ (a_sdxYe, b_sdxYf)
                   (lvl3_sdxur
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <(a_sdxYe,
                                             b_sdxYf)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <(a_sdxYe, b_sdxYf)>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (a_sdxYe, b_sdxYf) :: *)))
                   eta_idxhn
                   @ b2_idxho
                   eta1_idxhp
            of
            { (# ww1_idxhI #) ->
            Text.ParserCombinators.ReadP.Look @ b2_idxho ww1_idxhI
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <(a_sdxYe,
                                  b_sdxYf)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <(a_sdxYe, b_sdxYf)>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (a_sdxYe, b_sdxYf) :: *)))
        w2_sdxYk
        @ b1_sdxYl
        w3_sdxYm

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxYe)
                 (@ b_sdxYf)
                 (w_sdxYg [Occ=Once] :: ReadPrec a_sdxYe)
                 _ [Occ=Dead]
                 (w2_sdxYi [Occ=Once] :: ReadPrec b_sdxYf)
                 _ [Occ=Dead]
                 (w4_sdxYk [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b1_sdxYl)
                 (w5_sdxYm [Occ=Once]
                    :: (a_sdxYe, b_sdxYf)
                       -> Text.ParserCombinators.ReadP.P b1_sdxYl) ->
                 Data.Functor.Classes.$w$cliftReadPrec2
                   @ a_sdxYe @ b_sdxYf w_sdxYg w2_sdxYi w4_sdxYk @ b1_sdxYl w5_sdxYm}]
Data.Functor.Classes.$fRead1(,)2
  = \ (@ a_sdxYe)
      (@ b_sdxYf)
      (w_sdxYg :: ReadPrec a_sdxYe)
      _ [Occ=Dead]
      (w2_sdxYi :: ReadPrec b_sdxYf)
      _ [Occ=Dead]
      (w4_sdxYk :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdxYl)
      (w5_sdxYm
         :: (a_sdxYe, b_sdxYf)
            -> Text.ParserCombinators.ReadP.P b1_sdxYl) ->
      Data.Functor.Classes.$w$cliftReadPrec2
        @ a_sdxYe @ b_sdxYf w_sdxYg w2_sdxYi w4_sdxYk @ b1_sdxYl w5_sdxYm

-- RHS size: {terms: 13, types: 24, coercions: 18, joins: 0/0}
Data.Functor.Classes.$w$cliftReadsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> ReadS a) -> (Int -> ReadS b) -> Int -> ReadS (a, b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 110 60}]
Data.Functor.Classes.$w$cliftReadsPrec6
  = \ (@ a_sdxYo)
      (@ b_sdxYp)
      (w_sdxYq :: Int -> ReadS a_sdxYo)
      (w1_sdxYs :: Int -> ReadS b_sdxYp)
      (w2_sdxYu :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (a_sdxYo, b_sdxYp)
        (Data.Functor.Classes.$w$cliftReadPrec2
           @ a_sdxYo
           @ b_sdxYp
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1 @ a_sdxYo w_sdxYq)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <a_sdxYo>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_sdxYo>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (a_sdxYo -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec a_sdxYo :: *)))
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
               @ b_sdxYp w1_sdxYs)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <b_sdxYp>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <b_sdxYp>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (b_sdxYp -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec b_sdxYp :: *)))
           w2_sdxYu
           @ (a_sdxYo, b_sdxYp)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (a_sdxYo, b_sdxYp)))

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> ReadS a)
     -> ReadS [a]
     -> (Int -> ReadS b)
     -> ReadS [b]
     -> Int
     -> ReadS (a, b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxYo)
                 (@ b_sdxYp)
                 (w_sdxYq [Occ=Once] :: Int -> ReadS a_sdxYo)
                 _ [Occ=Dead]
                 (w2_sdxYs [Occ=Once] :: Int -> ReadS b_sdxYp)
                 _ [Occ=Dead]
                 (w4_sdxYu [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec6
                   @ a_sdxYo @ b_sdxYp w_sdxYq w2_sdxYs w4_sdxYu}]
Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
  = \ (@ a_sdxYo)
      (@ b_sdxYp)
      (w_sdxYq :: Int -> ReadS a_sdxYo)
      _ [Occ=Dead]
      (w2_sdxYs :: Int -> ReadS b_sdxYp)
      _ [Occ=Dead]
      (w4_sdxYu :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec6
        @ a_sdxYo @ b_sdxYp w_sdxYq w2_sdxYs w4_sdxYu

-- RHS size: {terms: 15, types: 28, coercions: 13, joins: 0/0}
Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2
  :: forall a b.
     ReadPrec a
     -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [(a, b)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwW8)
                 (@ b_adwW9)
                 (rp1_adwdl [Occ=Once] :: ReadPrec a_adwW8)
                 (rl1_adwdm [Occ=Once] :: ReadPrec [a_adwW8])
                 (rp2_adwdn [Occ=Once] :: ReadPrec b_adwW9)
                 (rl2_adwdo [Occ=Once] :: ReadPrec [b_adwW9]) ->
                 list
                   @ (a_adwW8, b_adwW9)
                   ((Data.Functor.Classes.$fRead1(,)2
                       @ a_adwW8 @ b_adwW9 rp1_adwdl rl1_adwdm rp2_adwdn rl2_adwdo)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <(a_adwW8,
                                             b_adwW9)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <(a_adwW8, b_adwW9)>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   ((a_adwW8, b_adwW9) -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (a_adwW8, b_adwW9) :: *)))}]
Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2
  = \ (@ a_adwW8)
      (@ b_adwW9)
      (rp1_adwdl :: ReadPrec a_adwW8)
      _ [Occ=Dead]
      (rp2_adwdn :: ReadPrec b_adwW9)
      _ [Occ=Dead] ->
      list
        @ (a_adwW8, b_adwW9)
        ((\ (w_sdxYk [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_sdxYl)
            (w1_sdxYm
               :: (a_adwW8, b_adwW9)
                  -> Text.ParserCombinators.ReadP.P b1_sdxYl) ->
            Data.Functor.Classes.$w$cliftReadPrec2
              @ a_adwW8
              @ b_adwW9
              rp1_adwdl
              rp2_adwdn
              w_sdxYk
              @ b1_sdxYl
              w1_sdxYm)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <(a_adwW8,
                                  b_adwW9)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <(a_adwW8, b_adwW9)>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        ((a_adwW8, b_adwW9) -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (a_adwW8, b_adwW9) :: *)))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,)3 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fShow1(,)3 = GHC.Types.C# '('#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity5 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Identity5 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,)2 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fShow1(,)2 = GHC.Types.C# ','#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,)1 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fShow1(,)1 = GHC.Types.C# ')'#

-- RHS size: {terms: 24, types: 20, coercions: 0, joins: 0/2}
Data.Functor.Classes.$w$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> a -> b -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0] 160 60}]
Data.Functor.Classes.$w$cliftShowsPrec2
  = \ (@ a_sdxYw)
      (@ b_sdxYx)
      (w_sdxYy :: Int -> a_sdxYw -> ShowS)
      (w1_sdxYA :: Int -> b_sdxYx -> ShowS)
      (ww_sdxYG :: a_sdxYw)
      (ww1_sdxYH :: b_sdxYx) ->
      let {
        f_sdxtj [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sdxtj
          = w_sdxYy Data.Functor.Classes.$fRead1Identity5 ww_sdxYG } in
      let {
        f1_sdxth [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f1_sdxth
          = w1_sdxYA Data.Functor.Classes.$fRead1Identity5 ww1_sdxYH } in
      \ (x_X7RBP :: String) ->
        GHC.Types.:
          @ Char
          Data.Functor.Classes.$fShow1(,)3
          (f_sdxtj
             (GHC.Types.:
                @ Char
                Data.Functor.Classes.$fShow1(,)2
                (f1_sdxth
                   (GHC.Types.: @ Char Data.Functor.Classes.$fShow1(,)1 x_X7RBP))))

-- RHS size: {terms: 16, types: 27, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> Int
     -> (a, b)
     -> ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdxYw)
                 (@ b_sdxYx)
                 (w_sdxYy [Occ=Once] :: Int -> a_sdxYw -> ShowS)
                 _ [Occ=Dead]
                 (w2_sdxYA [Occ=Once] :: Int -> b_sdxYx -> ShowS)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w5_sdxYD [Occ=Once!] :: (a_sdxYw, b_sdxYx)) ->
                 case w5_sdxYD of { (ww1_sdxYG [Occ=Once], ww2_sdxYH [Occ=Once]) ->
                 Data.Functor.Classes.$w$cliftShowsPrec2
                   @ a_sdxYw @ b_sdxYx w_sdxYy w2_sdxYA ww1_sdxYG ww2_sdxYH
                 }}]
Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
  = \ (@ a_sdxYw)
      (@ b_sdxYx)
      (w_sdxYy :: Int -> a_sdxYw -> ShowS)
      _ [Occ=Dead]
      (w2_sdxYA :: Int -> b_sdxYx -> ShowS)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w5_sdxYD :: (a_sdxYw, b_sdxYx)) ->
      case w5_sdxYD of { (ww1_sdxYG, ww2_sdxYH) ->
      Data.Functor.Classes.$w$cliftShowsPrec2
        @ a_sdxYw @ b_sdxYx w_sdxYy w2_sdxYA ww1_sdxYG ww2_sdxYH
      }

-- RHS size: {terms: 16, types: 30, coercions: 0, joins: 0/0}
Data.Functor.Classes.$dmliftShowList2
  :: forall (f :: * -> * -> *).
     Show2 f =>
     forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> [f a b]
     -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(C(C1(U))))))),A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adw99 :: * -> * -> *))
                 ($dShow2_adwOS [Occ=Once] :: Show2 f_adw99)
                 (@ a_adwOU)
                 (@ b_adwOV)
                 (sp1_adw9e [Occ=Once] :: Int -> a_adwOU -> ShowS)
                 (sl1_adw9f [Occ=Once] :: [a_adwOU] -> ShowS)
                 (sp2_adw9g [Occ=Once] :: Int -> b_adwOV -> ShowS)
                 (sl2_adw9h [Occ=Once] :: [b_adwOV] -> ShowS) ->
                 GHC.Show.showList__
                   @ (f_adw99 a_adwOU b_adwOV)
                   (liftShowsPrec2
                      @ f_adw99
                      $dShow2_adwOS
                      @ a_adwOU
                      @ b_adwOV
                      sp1_adw9e
                      sl1_adw9f
                      sp2_adw9g
                      sl2_adw9h
                      (GHC.Types.I# 0#))}]
Data.Functor.Classes.$dmliftShowList2
  = \ (@ (f_adw99 :: * -> * -> *))
      ($dShow2_adwOS :: Show2 f_adw99)
      (@ a_adwOU)
      (@ b_adwOV)
      (sp1_adw9e :: Int -> a_adwOU -> ShowS)
      (sl1_adw9f :: [a_adwOU] -> ShowS)
      (sp2_adw9g :: Int -> b_adwOV -> ShowS)
      (sl2_adw9h :: [b_adwOV] -> ShowS) ->
      GHC.Show.showList__
        @ (f_adw99 a_adwOU b_adwOV)
        (liftShowsPrec2
           @ f_adw99
           $dShow2_adwOS
           @ a_adwOU
           @ b_adwOV
           sp1_adw9e
           sl1_adw9f
           sp2_adw9g
           sl2_adw9h
           Data.Functor.Classes.$fRead1Identity5)

-- RHS size: {terms: 27, types: 30, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftShowList3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> (Int -> b -> ShowS) -> [(a, b)] -> String -> String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0] 180 0}]
Data.Functor.Classes.$w$cliftShowList3
  = \ (@ a_sdxYK)
      (@ b_sdxYL)
      (w_sdxYM :: Int -> a_sdxYK -> ShowS)
      (w1_sdxYO :: Int -> b_sdxYL -> ShowS)
      (w2_sdxYQ :: [(a_sdxYK, b_sdxYL)])
      (w3_sdxYR :: String) ->
      GHC.Show.showList__
        @ (a_sdxYK, b_sdxYL)
        (\ (ds_ddx9A :: (a_sdxYK, b_sdxYL))
           (eta_X6J [OS=OneShot] :: String) ->
           case ds_ddx9A of { (x_adwb7, y_adwb8) ->
           GHC.Types.:
             @ Char
             Data.Functor.Classes.$fShow1(,)3
             (w_sdxYM
                Data.Functor.Classes.$fRead1Identity5
                x_adwb7
                (GHC.Types.:
                   @ Char
                   Data.Functor.Classes.$fShow1(,)2
                   (w1_sdxYO
                      Data.Functor.Classes.$fRead1Identity5
                      y_adwb8
                      (GHC.Types.: @ Char Data.Functor.Classes.$fShow1(,)1 eta_X6J))))
           })
        w2_sdxYQ
        w3_sdxYR

-- RHS size: {terms: 13, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow2(,)_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> [(a, b)]
     -> ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxYK)
                 (@ b_sdxYL)
                 (w_sdxYM [Occ=Once] :: Int -> a_sdxYK -> ShowS)
                 _ [Occ=Dead]
                 (w2_sdxYO [Occ=Once] :: Int -> b_sdxYL -> ShowS)
                 _ [Occ=Dead]
                 (w4_sdxYQ [Occ=Once] :: [(a_sdxYK, b_sdxYL)])
                 (w5_sdxYR [Occ=Once] :: String) ->
                 Data.Functor.Classes.$w$cliftShowList3
                   @ a_sdxYK @ b_sdxYL w_sdxYM w2_sdxYO w4_sdxYQ w5_sdxYR}]
Data.Functor.Classes.$fShow2(,)_$cliftShowList2
  = \ (@ a_sdxYK)
      (@ b_sdxYL)
      (w_sdxYM :: Int -> a_sdxYK -> ShowS)
      _ [Occ=Dead]
      (w2_sdxYO :: Int -> b_sdxYL -> ShowS)
      _ [Occ=Dead]
      (w4_sdxYQ :: [(a_sdxYK, b_sdxYL)])
      (w5_sdxYR :: String) ->
      Data.Functor.Classes.$w$cliftShowList3
        @ a_sdxYK @ b_sdxYL w_sdxYM w2_sdxYO w4_sdxYQ w5_sdxYR

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Show2 (,)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show2 TYPE: (,)
                                    Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
                                    Data.Functor.Classes.$fShow2(,)_$cliftShowList2]
Data.Functor.Classes.$fShow2(,)
  = Data.Functor.Classes.C:Show2
      @ (,)
      Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
      Data.Functor.Classes.$fShow2(,)_$cliftShowList2

-- RHS size: {terms: 16, types: 24, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS) -> ([a1] -> ShowS) -> Int -> (a, a1) -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwQx)
                 ($dShow_adwQy :: Show a_adwQx)
                 (@ a1_adwQC)
                 (eta_B4 [Occ=Once] :: Int -> a1_adwQC -> ShowS)
                 (eta1_B3 [Occ=Once] :: [a1_adwQC] -> ShowS)
                 (eta2_B2 [Occ=Once] :: Int)
                 (eta3_B1 [Occ=Once] :: (a_adwQx, a1_adwQC)) ->
                 Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
                   @ a_adwQx
                   @ a1_adwQC
                   (showsPrec @ a_adwQx $dShow_adwQy)
                   (showList @ a_adwQx $dShow_adwQy)
                   eta_B4
                   eta1_B3
                   eta2_B2
                   eta3_B1}]
Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
  = \ (@ a_adwQx)
      ($dShow_adwQy :: Show a_adwQx)
      (@ a1_adwQC)
      (eta_B4 :: Int -> a1_adwQC -> ShowS)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta3_B1 :: (a_adwQx, a1_adwQC)) ->
      case eta3_B1 of { (ww1_sdxYG, ww2_sdxYH) ->
      Data.Functor.Classes.$w$cliftShowsPrec2
        @ a_adwQx
        @ a1_adwQC
        (showsPrec @ a_adwQx $dShow_adwQy)
        eta_B4
        ww1_sdxYG
        ww2_sdxYH
      }

-- RHS size: {terms: 32, types: 66, coercions: 18, joins: 0/1}
$w$dmliftReadListPrec2_rdymu
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []]
$w$dmliftReadListPrec2_rdymu
  = \ (@ (f_sdxYT :: * -> * -> *))
      (w_sdxYU :: Read2 f_sdxYT)
      (@ a_sdxYV)
      (@ b_sdxYW)
      (w1_sdxYX :: ReadPrec a_sdxYV)
      (w2_sdxYY :: ReadPrec [a_sdxYV])
      (w3_sdxYZ :: ReadPrec b_sdxYW)
      (w4_sdxZ0 :: ReadPrec [b_sdxYW]) ->
      let {
        w5_sdxta [Dmd=<L,C(U)>] :: ReadS [f_sdxYT a_sdxYV b_sdxYW]
        [LclId]
        w5_sdxta
          = liftReadList2
              @ f_sdxYT
              w_sdxYU
              @ a_sdxYV
              @ b_sdxYW
              (readPrec_to_S @ a_sdxYV w1_sdxYX)
              (Text.ParserCombinators.ReadP.run
                 @ [a_sdxYV]
                 ((((w2_sdxYY
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_sdxYV]>_R
                             :: (ReadPrec [a_sdxYV] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [a_sdxYV] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_sdxYV]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [a_sdxYV] :: *)
                              ~R# (forall b.
                                   ([a_sdxYV] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [a_sdxYV]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_sdxYV])))
              (readPrec_to_S @ b_sdxYW w3_sdxYZ)
              (Text.ParserCombinators.ReadP.run
                 @ [b_sdxYW]
                 ((((w4_sdxZ0
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[b_sdxYW]>_R
                             :: (ReadPrec [b_sdxYW] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [b_sdxYW] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[b_sdxYW]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [b_sdxYW] :: *)
                              ~R# (forall b.
                                   ([b_sdxYW] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [b_sdxYW]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                       @ [b_sdxYW]))) } in
      (\ (@ b1_idxi2)
         (w6_idxi3
            :: [f_sdxYT a_sdxYV b_sdxYW]
               -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
         case Text.ParserCombinators.ReadP.$wreadS_to_P
                @ [f_sdxYT a_sdxYV b_sdxYW] w5_sdxta @ b1_idxi2 w6_idxi3
         of
         { (# ww1_idxi6 #) ->
         Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
         })
      `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                       <[f_sdxYT a_sdxYV b_sdxYW]>_R)
              :: (forall b.
                  ([f_sdxYT a_sdxYV b_sdxYW] -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b :: *)
                 ~R# (Text.ParserCombinators.ReadP.ReadP
                        [f_sdxYT a_sdxYV b_sdxYW] :: *))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
$dmliftReadListPrec1_rdymv
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     ReadPrec a
     -> ReadPrec [a]
     -> ReadPrec b
     -> ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []]
$dmliftReadListPrec1_rdymv
  = \ (@ (f_sdxYT :: * -> * -> *))
      (w_sdxYU :: Read2 f_sdxYT)
      (@ a_sdxYV)
      (@ b_sdxYW)
      (w1_sdxYX :: ReadPrec a_sdxYV)
      (w2_sdxYY :: ReadPrec [a_sdxYV])
      (w3_sdxYZ :: ReadPrec b_sdxYW)
      (w4_sdxZ0 :: ReadPrec [b_sdxYW])
      _ [Occ=Dead] ->
      $w$dmliftReadListPrec2_rdymu
        @ f_sdxYT
        w_sdxYU
        @ a_sdxYV
        @ b_sdxYW
        w1_sdxYX
        w2_sdxYY
        w3_sdxYZ
        w4_sdxZ0

-- RHS size: {terms: 1, types: 0, coercions: 36, joins: 0/0}
Data.Functor.Classes.$dmliftReadListPrec2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     ReadPrec a
     -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= (\ (@ (f_XdwdT :: * -> * -> *))
                  ($dRead2_XdwSe [Occ=Once] :: Read2 f_XdwdT)
                  (@ a_XdwTf)
                  (@ b_XdwTh)
                  (rp1_Xdwei [Occ=Once] :: ReadPrec a_XdwTf)
                  (rl1_Xdwek [Occ=Once] :: ReadPrec [a_XdwTf])
                  (rp2_Xdwem [Occ=Once] :: ReadPrec b_XdwTh)
                  (rl2_Xdweo [Occ=Once] :: ReadPrec [b_XdwTh])
                  _ [Occ=Dead] ->
                  let {
                    w_idxi1 [Occ=OnceL] :: ReadS [f_XdwdT a_XdwTf b_XdwTh]
                    [LclId]
                    w_idxi1
                      = liftReadList2
                          @ f_XdwdT
                          $dRead2_XdwSe
                          @ a_XdwTf
                          @ b_XdwTh
                          (readPrec_to_S @ a_XdwTf rp1_Xdwei)
                          (Text.ParserCombinators.ReadP.run
                             @ [a_XdwTf]
                             ((((rl1_Xdwek
                                 `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_XdwTf]>_R
                                         :: (ReadPrec [a_XdwTf] :: *)
                                            ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                 -> Text.ParserCombinators.ReadP.ReadP
                                                      [a_XdwTf] :: *)))
                                  (GHC.Types.I# 0#))
                               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_XdwTf]>_R
                                       :: (Text.ParserCombinators.ReadP.ReadP [a_XdwTf] :: *)
                                          ~R# (forall b.
                                               ([a_XdwTf] -> Text.ParserCombinators.ReadP.P b)
                                               -> Text.ParserCombinators.ReadP.P b :: *)))
                                @ [a_XdwTf]
                                (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_XdwTf])))
                          (readPrec_to_S @ b_XdwTh rp2_Xdwem)
                          (Text.ParserCombinators.ReadP.run
                             @ [b_XdwTh]
                             ((((rl2_Xdweo
                                 `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[b_XdwTh]>_R
                                         :: (ReadPrec [b_XdwTh] :: *)
                                            ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                 -> Text.ParserCombinators.ReadP.ReadP
                                                      [b_XdwTh] :: *)))
                                  (GHC.Types.I# 0#))
                               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[b_XdwTh]>_R
                                       :: (Text.ParserCombinators.ReadP.ReadP [b_XdwTh] :: *)
                                          ~R# (forall b.
                                               ([b_XdwTh] -> Text.ParserCombinators.ReadP.P b)
                                               -> Text.ParserCombinators.ReadP.P b :: *)))
                                @ [b_XdwTh]
                                (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                   @ [b_XdwTh]))) } in
                  \ (@ b1_idxi2)
                    (w1_idxi3 [Occ=Once]
                       :: [f_XdwdT a_XdwTf b_XdwTh]
                          -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                    case Text.ParserCombinators.ReadP.$wreadS_to_P
                           @ [f_XdwdT a_XdwTf b_XdwTh] w_idxi1 @ b1_idxi2 w1_idxi3
                    of
                    { (# ww1_idxi6 [Occ=Once] #) ->
                    Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                    })
               `cast` (forall (f :: <* -> * -> *>_N).
                       <Read2 f>_R
                       ->_R forall (a :: <*>_N) (b :: <*>_N).
                            <ReadPrec a>_R
                            ->_R <ReadPrec [a]>_R
                            ->_R <ReadPrec b>_R
                            ->_R <ReadPrec [b]>_R
                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                <[f a b]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <[f a b]>_R)
                       :: (forall (f :: * -> * -> *).
                           Read2 f =>
                           forall a b.
                           ReadPrec a
                           -> ReadPrec [a]
                           -> ReadPrec b
                           -> ReadPrec [b]
                           -> Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              ([f a b] -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (forall (f :: * -> * -> *).
                               Read2 f =>
                               forall a b.
                               ReadPrec a
                               -> ReadPrec [a]
                               -> ReadPrec b
                               -> ReadPrec [b]
                               -> ReadPrec [f a b] :: *))}]
Data.Functor.Classes.$dmliftReadListPrec2
  = $dmliftReadListPrec1_rdymv
    `cast` (forall (f :: <* -> * -> *>_N).
            <Read2 f>_R
            ->_R forall (a :: <*>_N) (b :: <*>_N).
                 <ReadPrec a>_R
                 ->_R <ReadPrec [a]>_R
                 ->_R <ReadPrec b>_R
                 ->_R <ReadPrec [b]>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[f a b]>_R)
            :: (forall (f :: * -> * -> *).
                Read2 f =>
                forall a b.
                ReadPrec a
                -> ReadPrec [a]
                -> ReadPrec b
                -> ReadPrec [b]
                -> Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP [f a b] :: *)
               ~R# (forall (f :: * -> * -> *).
                    Read2 f =>
                    forall a b.
                    ReadPrec a
                    -> ReadPrec [a]
                    -> ReadPrec b
                    -> ReadPrec [b]
                    -> ReadPrec [f a b] :: *))

-- RHS size: {terms: 36, types: 69, coercions: 25, joins: 0/2}
Data.Functor.Classes.$dmliftReadPrec2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     ReadPrec a
     -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(C(U)))))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XdwdU :: * -> * -> *))
                 ($dRead2_XdwSf [Occ=Once] :: Read2 f_XdwdU)
                 (@ a_adwOl)
                 (@ b_adwOm)
                 (rp1_adw9z [Occ=Once] :: ReadPrec a_adwOl)
                 (rl1_adw9A [Occ=Once] :: ReadPrec [a_adwOl])
                 (rp2_adw9B [Occ=Once] :: ReadPrec b_adwOm)
                 (rl2_adw9C [Occ=Once] :: ReadPrec [b_adwOm]) ->
                 let {
                   f1_idxhZ [Occ=OnceL!] :: Int -> ReadS (f_XdwdU a_adwOl b_adwOm)
                   [LclId]
                   f1_idxhZ
                     = liftReadsPrec2
                         @ f_XdwdU
                         $dRead2_XdwSf
                         @ a_adwOl
                         @ b_adwOm
                         (readPrec_to_S @ a_adwOl rp1_adw9z)
                         (Text.ParserCombinators.ReadP.run
                            @ [a_adwOl]
                            ((((rl1_adw9A
                                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_adwOl]>_R
                                        :: (ReadPrec [a_adwOl] :: *)
                                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                -> Text.ParserCombinators.ReadP.ReadP
                                                     [a_adwOl] :: *)))
                                 (GHC.Types.I# 0#))
                              `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_adwOl]>_R
                                      :: (Text.ParserCombinators.ReadP.ReadP [a_adwOl] :: *)
                                         ~R# (forall b.
                                              ([a_adwOl] -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b :: *)))
                               @ [a_adwOl]
                               (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_adwOl])))
                         (readPrec_to_S @ b_adwOm rp2_adw9B)
                         (Text.ParserCombinators.ReadP.run
                            @ [b_adwOm]
                            ((((rl2_adw9C
                                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[b_adwOm]>_R
                                        :: (ReadPrec [b_adwOm] :: *)
                                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                -> Text.ParserCombinators.ReadP.ReadP
                                                     [b_adwOm] :: *)))
                                 (GHC.Types.I# 0#))
                              `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[b_adwOm]>_R
                                      :: (Text.ParserCombinators.ReadP.ReadP [b_adwOm] :: *)
                                         ~R# (forall b.
                                              ([b_adwOm] -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b :: *)))
                               @ [b_adwOm]
                               (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                  @ [b_adwOm]))) } in
                 (\ (n_idxi0 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec) ->
                    let {
                      w_idxi1 [Occ=OnceL] :: ReadS (f_XdwdU a_adwOl b_adwOm)
                      [LclId]
                      w_idxi1 = f1_idxhZ n_idxi0 } in
                    \ (@ b1_idxi2)
                      (w1_idxi3 [Occ=Once]
                         :: f_XdwdU a_adwOl b_adwOm
                            -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                      case Text.ParserCombinators.ReadP.$wreadS_to_P
                             @ (f_XdwdU a_adwOl b_adwOm) w_idxi1 @ b1_idxi2 w1_idxi3
                      of
                      { (# ww1_idxi6 [Occ=Once] #) ->
                      Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                      })
                 `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <f_XdwdU a_adwOl b_adwOm>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                 <f_XdwdU a_adwOl b_adwOm>_R)
                         :: (Text.ParserCombinators.ReadPrec.Prec
                             -> forall b.
                                (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b)
                                -> Text.ParserCombinators.ReadP.P b :: *)
                            ~R# (ReadPrec (f_XdwdU a_adwOl b_adwOm) :: *))}]
Data.Functor.Classes.$dmliftReadPrec2
  = \ (@ (f_XdwdU :: * -> * -> *))
      ($dRead2_XdwSf :: Read2 f_XdwdU)
      (@ a_adwOl)
      (@ b_adwOm)
      (rp1_adw9z :: ReadPrec a_adwOl)
      (rl1_adw9A :: ReadPrec [a_adwOl])
      (rp2_adw9B :: ReadPrec b_adwOm)
      (rl2_adw9C :: ReadPrec [b_adwOm]) ->
      let {
        f1_sdxt6 [Dmd=<L,C(C(U))>]
          :: Int -> ReadS (f_XdwdU a_adwOl b_adwOm)
        [LclId]
        f1_sdxt6
          = liftReadsPrec2
              @ f_XdwdU
              $dRead2_XdwSf
              @ a_adwOl
              @ b_adwOm
              (readPrec_to_S @ a_adwOl rp1_adw9z)
              (Text.ParserCombinators.ReadP.run
                 @ [a_adwOl]
                 ((((rl1_adw9A
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_adwOl]>_R
                             :: (ReadPrec [a_adwOl] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [a_adwOl] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_adwOl]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [a_adwOl] :: *)
                              ~R# (forall b.
                                   ([a_adwOl] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [a_adwOl]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_adwOl])))
              (readPrec_to_S @ b_adwOm rp2_adw9B)
              (Text.ParserCombinators.ReadP.run
                 @ [b_adwOm]
                 ((((rl2_adw9C
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[b_adwOm]>_R
                             :: (ReadPrec [b_adwOm] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [b_adwOm] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[b_adwOm]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [b_adwOm] :: *)
                              ~R# (forall b.
                                   ([b_adwOm] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [b_adwOm]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                       @ [b_adwOm]))) } in
      (\ (n_idxi0 :: Text.ParserCombinators.ReadPrec.Prec) ->
         let {
           w_sdxt8 [Dmd=<L,C(U)>] :: ReadS (f_XdwdU a_adwOl b_adwOm)
           [LclId]
           w_sdxt8 = f1_sdxt6 n_idxi0 } in
         \ (@ b1_idxi2)
           (w1_idxi3
              :: f_XdwdU a_adwOl b_adwOm
                 -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
           case Text.ParserCombinators.ReadP.$wreadS_to_P
                  @ (f_XdwdU a_adwOl b_adwOm) w_sdxt8 @ b1_idxi2 w1_idxi3
           of
           { (# ww1_idxi6 #) ->
           Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
           })
      `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                             <f_XdwdU a_adwOl b_adwOm>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <f_XdwdU a_adwOl b_adwOm>_R)
              :: (Text.ParserCombinators.ReadPrec.Prec
                  -> forall b.
                     (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)
                 ~R# (ReadPrec (f_XdwdU a_adwOl b_adwOm) :: *))

-- RHS size: {terms: 38, types: 82, coercions: 50, joins: 0/0}
Data.Functor.Classes.$dmliftReadList2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     (Int -> ReadS a)
     -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XdwdV :: * -> * -> *))
                 ($dRead2_XdwSg [Occ=Once] :: Read2 f_XdwdV)
                 (@ a_adwNZ)
                 (@ b_adwO0)
                 (rp1_adw9v [Occ=Once] :: Int -> ReadS a_adwNZ)
                 (rl1_adw9w [Occ=OnceL] :: ReadS [a_adwNZ])
                 (rp2_adw9x [Occ=Once] :: Int -> ReadS b_adwO0)
                 (rl2_adw9y [Occ=OnceL] :: ReadS [b_adwO0]) ->
                 Text.ParserCombinators.ReadP.run
                   @ [f_XdwdV a_adwNZ b_adwO0]
                   (((((list
                          @ (f_XdwdV a_adwNZ b_adwO0)
                          (liftReadPrec2
                             @ f_XdwdV
                             $dRead2_XdwSg
                             @ a_adwNZ
                             @ b_adwO0
                             ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                 @ a_adwNZ rp1_adw9v)
                              `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                     <a_adwNZ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                              <a_adwNZ>_R)
                                      :: (Text.ParserCombinators.ReadPrec.Prec
                                          -> forall b.
                                             (a_adwNZ -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                         ~R# (ReadPrec a_adwNZ :: *)))
                             ((\ _ [Occ=Dead]
                                 (@ b1_idxi2)
                                 (w1_idxi3 [Occ=Once]
                                    :: [a_adwNZ] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                                        @ [a_adwNZ] rl1_adw9w @ b1_idxi2 w1_idxi3
                                 of
                                 { (# ww1_idxi6 [Occ=Once] #) ->
                                 Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                                 })
                              `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                     <[a_adwNZ]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                <[a_adwNZ]>_R)
                                      :: (Text.ParserCombinators.ReadPrec.Prec
                                          -> forall b.
                                             ([a_adwNZ] -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                         ~R# (ReadPrec [a_adwNZ] :: *)))
                             ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                 @ b_adwO0 rp2_adw9x)
                              `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                     <b_adwO0>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                              <b_adwO0>_R)
                                      :: (Text.ParserCombinators.ReadPrec.Prec
                                          -> forall b.
                                             (b_adwO0 -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                         ~R# (ReadPrec b_adwO0 :: *)))
                             ((\ _ [Occ=Dead]
                                 (@ b1_idxi2)
                                 (w1_idxi3 [Occ=Once]
                                    :: [b_adwO0] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                                        @ [b_adwO0] rl2_adw9y @ b1_idxi2 w1_idxi3
                                 of
                                 { (# ww1_idxi6 [Occ=Once] #) ->
                                 Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                                 })
                              `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                     <[b_adwO0]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                <[b_adwO0]>_R)
                                      :: (Text.ParserCombinators.ReadPrec.Prec
                                          -> forall b.
                                             ([b_adwO0] -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                         ~R# (ReadPrec [b_adwO0] :: *)))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[f_XdwdV a_adwNZ b_adwO0]>_R
                               :: (ReadPrec [f_XdwdV a_adwNZ b_adwO0] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [f_XdwdV a_adwNZ b_adwO0] :: *)))
                        (GHC.Types.I# 0#))
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[f_XdwdV a_adwNZ b_adwO0]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP
                                   [f_XdwdV a_adwNZ b_adwO0] :: *)
                                ~R# (forall b.
                                     ([f_XdwdV a_adwNZ b_adwO0] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [f_XdwdV a_adwNZ b_adwO0]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [f_XdwdV a_adwNZ b_adwO0]))}]
Data.Functor.Classes.$dmliftReadList2
  = \ (@ (f_XdwdV :: * -> * -> *))
      ($dRead2_XdwSg :: Read2 f_XdwdV)
      (@ a_adwNZ)
      (@ b_adwO0)
      (rp1_adw9v :: Int -> ReadS a_adwNZ)
      (rl1_adw9w :: ReadS [a_adwNZ])
      (rp2_adw9x :: Int -> ReadS b_adwO0)
      (rl2_adw9y :: ReadS [b_adwO0]) ->
      Text.ParserCombinators.ReadP.run
        @ [f_XdwdV a_adwNZ b_adwO0]
        (((((list
               @ (f_XdwdV a_adwNZ b_adwO0)
               (liftReadPrec2
                  @ f_XdwdV
                  $dRead2_XdwSg
                  @ a_adwNZ
                  @ b_adwO0
                  ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                      @ a_adwNZ rp1_adw9v)
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <a_adwNZ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   <a_adwNZ>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  (a_adwNZ -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec a_adwNZ :: *)))
                  ((\ _ [Occ=Dead]
                      (@ b1_idxi2)
                      (w1_idxi3
                         :: [a_adwNZ] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                      case Text.ParserCombinators.ReadP.$wreadS_to_P
                             @ [a_adwNZ] rl1_adw9w @ b1_idxi2 w1_idxi3
                      of
                      { (# ww1_idxi6 #) ->
                      Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                      })
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <[a_adwNZ]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <[a_adwNZ]>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  ([a_adwNZ] -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec [a_adwNZ] :: *)))
                  ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                      @ b_adwO0 rp2_adw9x)
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <b_adwO0>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   <b_adwO0>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  (b_adwO0 -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec b_adwO0 :: *)))
                  ((\ _ [Occ=Dead]
                      (@ b1_idxi2)
                      (w1_idxi3
                         :: [b_adwO0] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                      case Text.ParserCombinators.ReadP.$wreadS_to_P
                             @ [b_adwO0] rl2_adw9y @ b1_idxi2 w1_idxi3
                      of
                      { (# ww1_idxi6 #) ->
                      Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                      })
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <[b_adwO0]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <[b_adwO0]>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  ([b_adwO0] -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec [b_adwO0] :: *)))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[f_XdwdV a_adwNZ b_adwO0]>_R
                    :: (ReadPrec [f_XdwdV a_adwNZ b_adwO0] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP
                                 [f_XdwdV a_adwNZ b_adwO0] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[f_XdwdV a_adwNZ b_adwO0]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP
                        [f_XdwdV a_adwNZ b_adwO0] :: *)
                     ~R# (forall b.
                          ([f_XdwdV a_adwNZ b_adwO0] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [f_XdwdV a_adwNZ b_adwO0]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [f_XdwdV a_adwNZ b_adwO0]))

-- RHS size: {terms: 40, types: 81, coercions: 48, joins: 0/1}
Data.Functor.Classes.$dmliftReadsPrec2
  :: forall (f :: * -> * -> *).
     Read2 f =>
     forall a b.
     (Int -> ReadS a)
     -> ReadS [a]
     -> (Int -> ReadS b)
     -> ReadS [b]
     -> Int
     -> ReadS (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C(C1(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XdwdW :: * -> * -> *))
                 ($dRead2_XdwSh [Occ=Once] :: Read2 f_XdwdW)
                 (@ a_adwNE)
                 (@ b_adwNF)
                 (rp1_adw9r [Occ=Once] :: Int -> ReadS a_adwNE)
                 (rl1_adw9s [Occ=OnceL] :: ReadS [a_adwNE])
                 (rp2_adw9t [Occ=Once] :: Int -> ReadS b_adwNF)
                 (rl2_adw9u [Occ=OnceL] :: ReadS [b_adwNF]) ->
                 let {
                   ds_idx7Y [Occ=OnceL] :: ReadPrec (f_XdwdW a_adwNE b_adwNF)
                   [LclId]
                   ds_idx7Y
                     = liftReadPrec2
                         @ f_XdwdW
                         $dRead2_XdwSh
                         @ a_adwNE
                         @ b_adwNF
                         ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                             @ a_adwNE rp1_adw9r)
                          `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                   ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <a_adwNE>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                          <a_adwNE>_R)
                                  :: (Text.ParserCombinators.ReadPrec.Prec
                                      -> forall b.
                                         (a_adwNE -> Text.ParserCombinators.ReadP.P b)
                                         -> Text.ParserCombinators.ReadP.P b :: *)
                                     ~R# (ReadPrec a_adwNE :: *)))
                         ((\ _ [Occ=Dead]
                             (@ b1_idxi2)
                             (w1_idxi3 [Occ=Once]
                                :: [a_adwNE] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                             case Text.ParserCombinators.ReadP.$wreadS_to_P
                                    @ [a_adwNE] rl1_adw9s @ b1_idxi2 w1_idxi3
                             of
                             { (# ww1_idxi6 [Occ=Once] #) ->
                             Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                             })
                          `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                   ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <[a_adwNE]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                            <[a_adwNE]>_R)
                                  :: (Text.ParserCombinators.ReadPrec.Prec
                                      -> forall b.
                                         ([a_adwNE] -> Text.ParserCombinators.ReadP.P b)
                                         -> Text.ParserCombinators.ReadP.P b :: *)
                                     ~R# (ReadPrec [a_adwNE] :: *)))
                         ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                             @ b_adwNF rp2_adw9t)
                          `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                   ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <b_adwNF>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                          <b_adwNF>_R)
                                  :: (Text.ParserCombinators.ReadPrec.Prec
                                      -> forall b.
                                         (b_adwNF -> Text.ParserCombinators.ReadP.P b)
                                         -> Text.ParserCombinators.ReadP.P b :: *)
                                     ~R# (ReadPrec b_adwNF :: *)))
                         ((\ _ [Occ=Dead]
                             (@ b1_idxi2)
                             (w1_idxi3 [Occ=Once]
                                :: [b_adwNF] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                             case Text.ParserCombinators.ReadP.$wreadS_to_P
                                    @ [b_adwNF] rl2_adw9u @ b1_idxi2 w1_idxi3
                             of
                             { (# ww1_idxi6 [Occ=Once] #) ->
                             Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                             })
                          `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                   ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <[b_adwNF]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                            <[b_adwNF]>_R)
                                  :: (Text.ParserCombinators.ReadPrec.Prec
                                      -> forall b.
                                         ([b_adwNF] -> Text.ParserCombinators.ReadP.P b)
                                         -> Text.ParserCombinators.ReadP.P b :: *)
                                     ~R# (ReadPrec [b_adwNF] :: *))) } in
                 \ (n_idx7Z [Occ=Once] :: Int) ->
                   Text.ParserCombinators.ReadP.run
                     @ (f_XdwdW a_adwNE b_adwNF)
                     ((((ds_idx7Y
                         `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                     <f_XdwdW a_adwNE b_adwNF>_R
                                 :: (ReadPrec (f_XdwdW a_adwNE b_adwNF) :: *)
                                    ~R# (Text.ParserCombinators.ReadPrec.Prec
                                         -> Text.ParserCombinators.ReadP.ReadP
                                              (f_XdwdW a_adwNE b_adwNF) :: *)))
                          n_idx7Z)
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <f_XdwdW a_adwNE b_adwNF>_R
                               :: (Text.ParserCombinators.ReadP.ReadP
                                     (f_XdwdW a_adwNE b_adwNF) :: *)
                                  ~R# (forall b.
                                       (f_XdwdW a_adwNE b_adwNF -> Text.ParserCombinators.ReadP.P b)
                                       -> Text.ParserCombinators.ReadP.P b :: *)))
                        @ (f_XdwdW a_adwNE b_adwNF)
                        (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                           @ (f_XdwdW a_adwNE b_adwNF)))}]
Data.Functor.Classes.$dmliftReadsPrec2
  = \ (@ (f_XdwdW :: * -> * -> *))
      ($dRead2_XdwSh :: Read2 f_XdwdW)
      (@ a_adwNE)
      (@ b_adwNF)
      (rp1_adw9r :: Int -> ReadS a_adwNE)
      (rl1_adw9s :: ReadS [a_adwNE])
      (rp2_adw9t :: Int -> ReadS b_adwNF)
      (rl2_adw9u :: ReadS [b_adwNF]) ->
      let {
        ds_sdxt4 [Dmd=<L,C(C1(U))>] :: ReadPrec (f_XdwdW a_adwNE b_adwNF)
        [LclId]
        ds_sdxt4
          = liftReadPrec2
              @ f_XdwdW
              $dRead2_XdwSh
              @ a_adwNE
              @ b_adwNF
              ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                  @ a_adwNE rp1_adw9r)
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <a_adwNE>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <a_adwNE>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (a_adwNE -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec a_adwNE :: *)))
              ((\ _ [Occ=Dead]
                  (@ b1_idxi2)
                  (w1_idxi3
                     :: [a_adwNE] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                  case Text.ParserCombinators.ReadP.$wreadS_to_P
                         @ [a_adwNE] rl1_adw9s @ b1_idxi2 w1_idxi3
                  of
                  { (# ww1_idxi6 #) ->
                  Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                  })
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <[a_adwNE]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <[a_adwNE]>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              ([a_adwNE] -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec [a_adwNE] :: *)))
              ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                  @ b_adwNF rp2_adw9t)
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <b_adwNF>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <b_adwNF>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (b_adwNF -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec b_adwNF :: *)))
              ((\ _ [Occ=Dead]
                  (@ b1_idxi2)
                  (w1_idxi3
                     :: [b_adwNF] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                  case Text.ParserCombinators.ReadP.$wreadS_to_P
                         @ [b_adwNF] rl2_adw9u @ b1_idxi2 w1_idxi3
                  of
                  { (# ww1_idxi6 #) ->
                  Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                  })
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <[b_adwNF]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <[b_adwNF]>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              ([b_adwNF] -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec [b_adwNF] :: *))) } in
      \ (n_idx7Z :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (f_XdwdW a_adwNE b_adwNF)
          ((((ds_sdxt4
              `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <f_XdwdW a_adwNE b_adwNF>_R
                      :: (ReadPrec (f_XdwdW a_adwNE b_adwNF) :: *)
                         ~R# (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP
                                   (f_XdwdW a_adwNE b_adwNF) :: *)))
               n_idx7Z)
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                        <f_XdwdW a_adwNE b_adwNF>_R
                    :: (Text.ParserCombinators.ReadP.ReadP
                          (f_XdwdW a_adwNE b_adwNF) :: *)
                       ~R# (forall b.
                            (f_XdwdW a_adwNE b_adwNF -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)))
             @ (f_XdwdW a_adwNE b_adwNF)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (f_XdwdW a_adwNE b_adwNF)))

-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
Data.Functor.Classes.$dmliftShowList
  :: forall (f :: * -> *).
     Show1 f =>
     forall a. (Int -> a -> ShowS) -> ([a] -> ShowS) -> [f a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C(C1(U))))),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adw9R :: * -> *))
                 ($dShow1_adwNo [Occ=Once] :: Show1 f_adw9R)
                 (@ a_adwNq)
                 (sp_adw9U [Occ=Once] :: Int -> a_adwNq -> ShowS)
                 (sl_adw9V [Occ=Once] :: [a_adwNq] -> ShowS) ->
                 GHC.Show.showList__
                   @ (f_adw9R a_adwNq)
                   (liftShowsPrec
                      @ f_adw9R
                      $dShow1_adwNo
                      @ a_adwNq
                      sp_adw9U
                      sl_adw9V
                      (GHC.Types.I# 0#))}]
Data.Functor.Classes.$dmliftShowList
  = \ (@ (f_adw9R :: * -> *))
      ($dShow1_adwNo :: Show1 f_adw9R)
      (@ a_adwNq)
      (sp_adw9U :: Int -> a_adwNq -> ShowS)
      (sl_adw9V :: [a_adwNq] -> ShowS) ->
      GHC.Show.showList__
        @ (f_adw9R a_adwNq)
        (liftShowsPrec
           @ f_adw9R
           $dShow1_adwNo
           @ a_adwNq
           sp_adw9U
           sl_adw9V
           Data.Functor.Classes.$fRead1Identity5)

-- RHS size: {terms: 21, types: 31, coercions: 0, joins: 0/1}
Data.Functor.Classes.$w$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     forall a1. (Int -> a1 -> ShowS) -> [(a, a1)] -> String -> String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0 0] 140 0}]
Data.Functor.Classes.$w$cliftShowList
  = \ (@ a_sdxZ3)
      (w_sdxZ4 :: Show a_sdxZ3)
      (@ a1_sdxZ5)
      (w1_sdxZ6 :: Int -> a1_sdxZ5 -> ShowS)
      (w2_sdxZ8 :: [(a_sdxZ3, a1_sdxZ5)])
      (w3_sdxZ9 :: String) ->
      let {
        lvl3_sdxuK [Dmd=<L,C(C1(C(U)))>] :: Int -> a_sdxZ3 -> ShowS
        [LclId]
        lvl3_sdxuK = showsPrec @ a_sdxZ3 w_sdxZ4 } in
      GHC.Show.showList__
        @ (a_sdxZ3, a1_sdxZ5)
        (\ (eta_X9 :: (a_sdxZ3, a1_sdxZ5)) ->
           case eta_X9 of { (ww1_sdxYG, ww2_sdxYH) ->
           Data.Functor.Classes.$w$cliftShowsPrec2
             @ a_sdxZ3 @ a1_sdxZ5 lvl3_sdxuK w1_sdxZ6 ww1_sdxYG ww2_sdxYH
           })
        w2_sdxZ8
        w3_sdxZ9

-- RHS size: {terms: 12, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,)_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS) -> ([a1] -> ShowS) -> [(a, a1)] -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxZ3)
                 (w_sdxZ4 [Occ=Once] :: Show a_sdxZ3)
                 (@ a1_sdxZ5)
                 (w1_sdxZ6 [Occ=Once] :: Int -> a1_sdxZ5 -> ShowS)
                 _ [Occ=Dead]
                 (w3_sdxZ8 [Occ=Once] :: [(a_sdxZ3, a1_sdxZ5)])
                 (w4_sdxZ9 [Occ=Once] :: String) ->
                 Data.Functor.Classes.$w$cliftShowList
                   @ a_sdxZ3 w_sdxZ4 @ a1_sdxZ5 w1_sdxZ6 w3_sdxZ8 w4_sdxZ9}]
Data.Functor.Classes.$fShow1(,)_$cliftShowList
  = \ (@ a_sdxZ3)
      (w_sdxZ4 :: Show a_sdxZ3)
      (@ a1_sdxZ5)
      (w1_sdxZ6 :: Int -> a1_sdxZ5 -> ShowS)
      _ [Occ=Dead]
      (w3_sdxZ8 :: [(a_sdxZ3, a1_sdxZ5)])
      (w4_sdxZ9 :: String) ->
      Data.Functor.Classes.$w$cliftShowList
        @ a_sdxZ3 w_sdxZ4 @ a1_sdxZ5 w1_sdxZ6 w3_sdxZ8 w4_sdxZ9

-- RHS size: {terms: 15, types: 22, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_adwb1) (v_B1 :: Show a_adwb1) ->
       Data.Functor.Classes.C:Show1 TYPE: (,) a_adwb1
                                    Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec @ a_adwb1 v_B1
                                    Data.Functor.Classes.$fShow1(,)_$cliftShowList @ a_adwb1 v_B1]
Data.Functor.Classes.$fShow1(,)
  = \ (@ a_adwQx) ($dShow_adwQy :: Show a_adwQx) ->
      Data.Functor.Classes.C:Show1
        @ ((,) a_adwQx)
        (Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
           @ a_adwQx $dShow_adwQy)
        (\ (@ a1_sdxZ5)
           (w_sdxZ6 :: Int -> a1_sdxZ5 -> ShowS)
           _ [Occ=Dead]
           (w2_sdxZ8 :: [(a_adwQx, a1_sdxZ5)])
           (w3_sdxZ9 :: String) ->
           Data.Functor.Classes.$w$cliftShowList
             @ a_adwQx $dShow_adwQy @ a1_sdxZ5 w_sdxZ6 w2_sdxZ8 w3_sdxZ9)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Proxy1
  :: forall a. Proxy a -> [Char] -> [Char]
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwZF) _ [Occ=Dead] ->
                 Data.Functor.Classes.$fShow1Proxy2}]
Data.Functor.Classes.$fShow1Proxy1
  = \ (@ a_adwZF) _ [Occ=Dead] -> Data.Functor.Classes.$fShow1Proxy2

-- RHS size: {terms: 9, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Proxy_$cliftShowList
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Proxy a] -> ShowS
[GblId,
 Arity=4,
 Str=<L,A><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwZF)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta_B2 [Occ=Once] :: [Proxy a_adwZF])
                 (eta1_B1 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Proxy a_adwZF)
                   (Data.Functor.Classes.$fShow1Proxy1 @ a_adwZF)
                   eta_B2
                   eta1_B1}]
Data.Functor.Classes.$fShow1Proxy_$cliftShowList
  = \ (@ a_adwZF)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta_B2 :: [Proxy a_adwZF])
      (eta1_B1 :: String) ->
      GHC.Show.showList__
        @ (Proxy a_adwZF)
        (Data.Functor.Classes.$fShow1Proxy1 @ a_adwZF)
        eta_B2
        eta1_B1

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Show1 Proxy
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show1 TYPE: Proxy
                                    Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
                                    Data.Functor.Classes.$fShow1Proxy_$cliftShowList]
Data.Functor.Classes.$fShow1Proxy
  = Data.Functor.Classes.C:Show1
      @ Proxy
      Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
      Data.Functor.Classes.$fShow1Proxy_$cliftShowList

-- RHS size: {terms: 18, types: 22, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [NonEmpty a] -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C(U)))><L,C(C(U))><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx0n)
                 (sp_adw9U [Occ=Once] :: Int -> a_adx0n -> ShowS)
                 (sl_adw9V [Occ=Once] :: [a_adx0n] -> ShowS)
                 (eta_B2 [Occ=Once] :: [NonEmpty a_adx0n])
                 (eta1_B1 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (NonEmpty a_adx0n)
                   (Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
                      @ a_adx0n sp_adw9U sl_adw9V Data.Functor.Classes.$fRead1Identity5)
                   eta_B2
                   eta1_B1}]
Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList
  = \ (@ a_adx0n)
      (sp_adw9U :: Int -> a_adx0n -> ShowS)
      (sl_adw9V :: [a_adx0n] -> ShowS)
      (eta_B2 :: [NonEmpty a_adx0n])
      (eta1_B1 :: String) ->
      GHC.Show.showList__
        @ (NonEmpty a_adx0n)
        (\ (w_sdxWR :: NonEmpty a_adx0n) ->
           case w_sdxWR of { :| ww1_sdxWY ww2_sdxWZ ->
           Data.Functor.Classes.$w$cliftShowsPrec1
             @ a_adx0n sp_adw9U sl_adw9V 0# ww1_sdxWY ww2_sdxWZ
           })
        eta_B2
        eta1_B1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Show1 NonEmpty
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show1 TYPE: NonEmpty
                                    Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
                                    Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList]
Data.Functor.Classes.$fShow1NonEmpty
  = Data.Functor.Classes.C:Show1
      @ NonEmpty
      Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
      Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1[]_$cliftShowList
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [[a]] -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx0C)
                 _ [Occ=Dead]
                 (sl_adw9V [Occ=Once] :: [a_adx0C] -> ShowS) ->
                 GHC.Show.showList__ @ [a_adx0C] sl_adw9V}]
Data.Functor.Classes.$fShow1[]_$cliftShowList
  = \ (@ a_adx0C) _ [Occ=Dead] (sl_adw9V :: [a_adx0C] -> ShowS) ->
      GHC.Show.showList__ @ [a_adx0C] sl_adw9V

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Show1 []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show1 TYPE: []
                                    Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
                                    Data.Functor.Classes.$fShow1[]_$cliftShowList]
Data.Functor.Classes.$fShow1[]
  = Data.Functor.Classes.C:Show1
      @ []
      Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
      Data.Functor.Classes.$fShow1[]_$cliftShowList

-- RHS size: {terms: 23, types: 46, coercions: 11, joins: 0/1}
$w$dmliftReadListPrec_rdymw
  :: forall (f :: * -> *).
     Read1 f =>
     forall a.
     ReadPrec a
     -> ReadPrec [a] -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []]
$w$dmliftReadListPrec_rdymw
  = \ (@ (f_sdxZb :: * -> *))
      (w_sdxZc :: Read1 f_sdxZb)
      (@ a_sdxZd)
      (w1_sdxZe :: ReadPrec a_sdxZd)
      (w2_sdxZf :: ReadPrec [a_sdxZd]) ->
      let {
        w3_sdxt0 [Dmd=<L,C(U)>] :: ReadS [f_sdxZb a_sdxZd]
        [LclId]
        w3_sdxt0
          = liftReadList
              @ f_sdxZb
              w_sdxZc
              @ a_sdxZd
              (readPrec_to_S @ a_sdxZd w1_sdxZe)
              (Text.ParserCombinators.ReadP.run
                 @ [a_sdxZd]
                 ((((w2_sdxZf
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_sdxZd]>_R
                             :: (ReadPrec [a_sdxZd] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [a_sdxZd] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_sdxZd]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [a_sdxZd] :: *)
                              ~R# (forall b.
                                   ([a_sdxZd] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [a_sdxZd]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                       @ [a_sdxZd]))) } in
      (\ (@ b_idxi2)
         (w4_idxi3
            :: [f_sdxZb a_sdxZd] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
         case Text.ParserCombinators.ReadP.$wreadS_to_P
                @ [f_sdxZb a_sdxZd] w3_sdxt0 @ b_idxi2 w4_idxi3
         of
         { (# ww1_idxi6 #) ->
         Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
         })
      `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                       <[f_sdxZb a_sdxZd]>_R)
              :: (forall b.
                  ([f_sdxZb a_sdxZd] -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b :: *)
                 ~R# (Text.ParserCombinators.ReadP.ReadP [f_sdxZb a_sdxZd] :: *))

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
$dmliftReadListPrec3_rdymx
  :: forall (f :: * -> *).
     Read1 f =>
     forall a.
     ReadPrec a
     -> ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []]
$dmliftReadListPrec3_rdymx
  = \ (@ (f_sdxZb :: * -> *))
      (w_sdxZc :: Read1 f_sdxZb)
      (@ a_sdxZd)
      (w1_sdxZe :: ReadPrec a_sdxZd)
      (w2_sdxZf :: ReadPrec [a_sdxZd])
      _ [Occ=Dead] ->
      $w$dmliftReadListPrec_rdymw
        @ f_sdxZb w_sdxZc @ a_sdxZd w1_sdxZe w2_sdxZf

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
Data.Functor.Classes.$dmliftReadListPrec
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= (\ (@ (f_XdweQ :: * -> *))
                  ($dRead1_XdwRn [Occ=Once] :: Read1 f_XdweQ)
                  (@ a_XdwS8)
                  (rp_Xdwf4 [Occ=Once] :: ReadPrec a_XdwS8)
                  (rl_Xdwf6 [Occ=Once] :: ReadPrec [a_XdwS8])
                  _ [Occ=Dead] ->
                  let {
                    w_idxi1 [Occ=OnceL] :: ReadS [f_XdweQ a_XdwS8]
                    [LclId]
                    w_idxi1
                      = liftReadList
                          @ f_XdweQ
                          $dRead1_XdwRn
                          @ a_XdwS8
                          (readPrec_to_S @ a_XdwS8 rp_Xdwf4)
                          (Text.ParserCombinators.ReadP.run
                             @ [a_XdwS8]
                             ((((rl_Xdwf6
                                 `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_XdwS8]>_R
                                         :: (ReadPrec [a_XdwS8] :: *)
                                            ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                 -> Text.ParserCombinators.ReadP.ReadP
                                                      [a_XdwS8] :: *)))
                                  (GHC.Types.I# 0#))
                               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_XdwS8]>_R
                                       :: (Text.ParserCombinators.ReadP.ReadP [a_XdwS8] :: *)
                                          ~R# (forall b.
                                               ([a_XdwS8] -> Text.ParserCombinators.ReadP.P b)
                                               -> Text.ParserCombinators.ReadP.P b :: *)))
                                @ [a_XdwS8]
                                (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                   @ [a_XdwS8]))) } in
                  \ (@ b_idxi2)
                    (w1_idxi3 [Occ=Once]
                       :: [f_XdweQ a_XdwS8] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                    case Text.ParserCombinators.ReadP.$wreadS_to_P
                           @ [f_XdweQ a_XdwS8] w_idxi1 @ b_idxi2 w1_idxi3
                    of
                    { (# ww1_idxi6 [Occ=Once] #) ->
                    Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                    })
               `cast` (forall (f :: <* -> *>_N).
                       <Read1 f>_R
                       ->_R forall (a :: <*>_N).
                            <ReadPrec a>_R
                            ->_R <ReadPrec [a]>_R
                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                <[f a]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <[f a]>_R)
                       :: (forall (f :: * -> *).
                           Read1 f =>
                           forall a.
                           ReadPrec a
                           -> ReadPrec [a]
                           -> Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              ([f a] -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (forall (f :: * -> *).
                               Read1 f =>
                               forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [f a] :: *))}]
Data.Functor.Classes.$dmliftReadListPrec
  = $dmliftReadListPrec3_rdymx
    `cast` (forall (f :: <* -> *>_N).
            <Read1 f>_R
            ->_R forall (a :: <*>_N).
                 <ReadPrec a>_R
                 ->_R <ReadPrec [a]>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[f a]>_R)
            :: (forall (f :: * -> *).
                Read1 f =>
                forall a.
                ReadPrec a
                -> ReadPrec [a]
                -> Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP [f a] :: *)
               ~R# (forall (f :: * -> *).
                    Read1 f =>
                    forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [f a] :: *))

-- RHS size: {terms: 27, types: 48, coercions: 17, joins: 0/2}
Data.Functor.Classes.$dmliftReadPrec
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(C(U)))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XdweR :: * -> *))
                 ($dRead1_XdwRo [Occ=Once] :: Read1 f_XdweR)
                 (@ a_adwMZ)
                 (rp_adwa5 [Occ=Once] :: ReadPrec a_adwMZ)
                 (rl_adwa6 [Occ=Once] :: ReadPrec [a_adwMZ]) ->
                 let {
                   f1_idxhZ [Occ=OnceL!] :: Int -> ReadS (f_XdweR a_adwMZ)
                   [LclId]
                   f1_idxhZ
                     = liftReadsPrec
                         @ f_XdweR
                         $dRead1_XdwRo
                         @ a_adwMZ
                         (readPrec_to_S @ a_adwMZ rp_adwa5)
                         (Text.ParserCombinators.ReadP.run
                            @ [a_adwMZ]
                            ((((rl_adwa6
                                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_adwMZ]>_R
                                        :: (ReadPrec [a_adwMZ] :: *)
                                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                -> Text.ParserCombinators.ReadP.ReadP
                                                     [a_adwMZ] :: *)))
                                 (GHC.Types.I# 0#))
                              `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_adwMZ]>_R
                                      :: (Text.ParserCombinators.ReadP.ReadP [a_adwMZ] :: *)
                                         ~R# (forall b.
                                              ([a_adwMZ] -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b :: *)))
                               @ [a_adwMZ]
                               (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                  @ [a_adwMZ]))) } in
                 (\ (n_idxi0 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec) ->
                    let {
                      w_idxi1 [Occ=OnceL] :: ReadS (f_XdweR a_adwMZ)
                      [LclId]
                      w_idxi1 = f1_idxhZ n_idxi0 } in
                    \ (@ b_idxi2)
                      (w1_idxi3 [Occ=Once]
                         :: f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                      case Text.ParserCombinators.ReadP.$wreadS_to_P
                             @ (f_XdweR a_adwMZ) w_idxi1 @ b_idxi2 w1_idxi3
                      of
                      { (# ww1_idxi6 [Occ=Once] #) ->
                      Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                      })
                 `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <f_XdweR a_adwMZ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <f_XdweR a_adwMZ>_R)
                         :: (Text.ParserCombinators.ReadPrec.Prec
                             -> forall b.
                                (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                                -> Text.ParserCombinators.ReadP.P b :: *)
                            ~R# (ReadPrec (f_XdweR a_adwMZ) :: *))}]
Data.Functor.Classes.$dmliftReadPrec
  = \ (@ (f_XdweR :: * -> *))
      ($dRead1_XdwRo :: Read1 f_XdweR)
      (@ a_adwMZ)
      (rp_adwa5 :: ReadPrec a_adwMZ)
      (rl_adwa6 :: ReadPrec [a_adwMZ]) ->
      let {
        f1_sdxsW [Dmd=<L,C(C(U))>] :: Int -> ReadS (f_XdweR a_adwMZ)
        [LclId]
        f1_sdxsW
          = liftReadsPrec
              @ f_XdweR
              $dRead1_XdwRo
              @ a_adwMZ
              (readPrec_to_S @ a_adwMZ rp_adwa5)
              (Text.ParserCombinators.ReadP.run
                 @ [a_adwMZ]
                 ((((rl_adwa6
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_adwMZ]>_R
                             :: (ReadPrec [a_adwMZ] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [a_adwMZ] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_adwMZ]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [a_adwMZ] :: *)
                              ~R# (forall b.
                                   ([a_adwMZ] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [a_adwMZ]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                       @ [a_adwMZ]))) } in
      (\ (n_idxi0 :: Text.ParserCombinators.ReadPrec.Prec) ->
         let {
           w_sdxsY [Dmd=<L,C(U)>] :: ReadS (f_XdweR a_adwMZ)
           [LclId]
           w_sdxsY = f1_sdxsW n_idxi0 } in
         \ (@ b_idxi2)
           (w1_idxi3
              :: f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b_idxi2) ->
           case Text.ParserCombinators.ReadP.$wreadS_to_P
                  @ (f_XdweR a_adwMZ) w_sdxsY @ b_idxi2 w1_idxi3
           of
           { (# ww1_idxi6 #) ->
           Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
           })
      `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                             <f_XdweR a_adwMZ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <f_XdweR a_adwMZ>_R)
              :: (Text.ParserCombinators.ReadPrec.Prec
                  -> forall b.
                     (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)
                 ~R# (ReadPrec (f_XdweR a_adwMZ) :: *))

-- RHS size: {terms: 23, types: 47, coercions: 28, joins: 0/0}
Data.Functor.Classes.$dmliftReadList
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XdweS :: * -> *))
                 ($dRead1_XdwRp [Occ=Once] :: Read1 f_XdweS)
                 (@ a_adwMJ)
                 (rp_adwa3 [Occ=Once] :: Int -> ReadS a_adwMJ)
                 (rl_adwa4 [Occ=OnceL] :: ReadS [a_adwMJ]) ->
                 Text.ParserCombinators.ReadP.run
                   @ [f_XdweS a_adwMJ]
                   (((((list
                          @ (f_XdweS a_adwMJ)
                          (liftReadPrec
                             @ f_XdweS
                             $dRead1_XdwRp
                             @ a_adwMJ
                             ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                 @ a_adwMJ rp_adwa3)
                              `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                     <a_adwMJ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                              <a_adwMJ>_R)
                                      :: (Text.ParserCombinators.ReadPrec.Prec
                                          -> forall b.
                                             (a_adwMJ -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                         ~R# (ReadPrec a_adwMJ :: *)))
                             ((\ _ [Occ=Dead]
                                 (@ b_idxi2)
                                 (w1_idxi3 [Occ=Once]
                                    :: [a_adwMJ] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                                        @ [a_adwMJ] rl_adwa4 @ b_idxi2 w1_idxi3
                                 of
                                 { (# ww1_idxi6 [Occ=Once] #) ->
                                 Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                                 })
                              `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                     <[a_adwMJ]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                <[a_adwMJ]>_R)
                                      :: (Text.ParserCombinators.ReadPrec.Prec
                                          -> forall b.
                                             ([a_adwMJ] -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                         ~R# (ReadPrec [a_adwMJ] :: *)))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[f_XdweS a_adwMJ]>_R
                               :: (ReadPrec [f_XdweS a_adwMJ] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [f_XdweS a_adwMJ] :: *)))
                        (GHC.Types.I# 0#))
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[f_XdweS a_adwMJ]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [f_XdweS a_adwMJ] :: *)
                                ~R# (forall b.
                                     ([f_XdweS a_adwMJ] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [f_XdweS a_adwMJ]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [f_XdweS a_adwMJ]))}]
Data.Functor.Classes.$dmliftReadList
  = \ (@ (f_XdweS :: * -> *))
      ($dRead1_XdwRp :: Read1 f_XdweS)
      (@ a_adwMJ)
      (rp_adwa3 :: Int -> ReadS a_adwMJ)
      (rl_adwa4 :: ReadS [a_adwMJ]) ->
      Text.ParserCombinators.ReadP.run
        @ [f_XdweS a_adwMJ]
        (((((list
               @ (f_XdweS a_adwMJ)
               (liftReadPrec
                  @ f_XdweS
                  $dRead1_XdwRp
                  @ a_adwMJ
                  ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                      @ a_adwMJ rp_adwa3)
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <a_adwMJ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   <a_adwMJ>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  (a_adwMJ -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec a_adwMJ :: *)))
                  ((\ _ [Occ=Dead]
                      (@ b_idxi2)
                      (w1_idxi3
                         :: [a_adwMJ] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                      case Text.ParserCombinators.ReadP.$wreadS_to_P
                             @ [a_adwMJ] rl_adwa4 @ b_idxi2 w1_idxi3
                      of
                      { (# ww1_idxi6 #) ->
                      Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                      })
                   `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <[a_adwMJ]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <[a_adwMJ]>_R)
                           :: (Text.ParserCombinators.ReadPrec.Prec
                               -> forall b.
                                  ([a_adwMJ] -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec [a_adwMJ] :: *)))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[f_XdweS a_adwMJ]>_R
                    :: (ReadPrec [f_XdweS a_adwMJ] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [f_XdweS a_adwMJ] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[f_XdweS a_adwMJ]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [f_XdweS a_adwMJ] :: *)
                     ~R# (forall b.
                          ([f_XdweS a_adwMJ] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [f_XdweS a_adwMJ]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [f_XdweS a_adwMJ]))

-- RHS size: {terms: 31, types: 46, coercions: 17, joins: 0/3}
Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
  :: forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec (NonEmpty a)
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60] 240 60}]
Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
  = \ (@ a_adx31)
      (rp_adwa5 :: ReadPrec a_adx31)
      (rl_adwa6 :: ReadPrec [a_adx31]) ->
      let {
        f_sdxsU [Dmd=<L,C(C1(U))>] :: Int -> ReadS a_adx31
        [LclId, Arity=1, Unf=OtherCon []]
        f_sdxsU = readPrec_to_S @ a_adx31 rp_adwa5 } in
      let {
        f1_sdxsT :: Text.ParserCombinators.ReadP.P [a_adx31]
        [LclId]
        f1_sdxsT
          = (((rl_adwa6
               `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_adx31]>_R
                       :: (ReadPrec [a_adx31] :: *)
                          ~R# (Text.ParserCombinators.ReadPrec.Prec
                               -> Text.ParserCombinators.ReadP.ReadP [a_adx31] :: *)))
                Data.Functor.Classes.$fRead1Identity5)
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_adx31]>_R
                     :: (Text.ParserCombinators.ReadP.ReadP [a_adx31] :: *)
                        ~R# (forall b.
                             ([a_adx31] -> Text.ParserCombinators.ReadP.P b)
                             -> Text.ParserCombinators.ReadP.P b :: *)))
              @ [a_adx31]
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                 @ [a_adx31]) } in
      let {
        f2_sdxsS [Dmd=<L,C(U)>] :: ReadS [a_adx31]
        [LclId, Arity=1, Unf=OtherCon []]
        f2_sdxsS
          = Text.ParserCombinators.ReadP.run @ [a_adx31] f1_sdxsT } in
      (\ (n_idxi0 :: Text.ParserCombinators.ReadPrec.Prec)
         (@ b_idxi2)
         (eta_B1
            :: NonEmpty a_adx31 -> Text.ParserCombinators.ReadP.P b_idxi2) ->
         case Text.ParserCombinators.ReadP.$wreadS_to_P
                @ (NonEmpty a_adx31)
                (\ (w_sdxWH :: String) ->
                   case n_idxi0 of { GHC.Types.I# ww1_sdxWK ->
                   Data.Functor.Classes.$w$cliftReadsPrec5
                     @ a_adx31 f_sdxsU f2_sdxsS ww1_sdxWK w_sdxWH
                   })
                @ b_idxi2
                eta_B1
         of
         { (# ww1_idxi6 #) ->
         Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
         })
      `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                             <NonEmpty
                                a_adx31>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <NonEmpty a_adx31>_R)
              :: (Text.ParserCombinators.ReadPrec.Prec
                  -> forall b.
                     (NonEmpty a_adx31 -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)
                 ~R# (ReadPrec (NonEmpty a_adx31) :: *))

-- RHS size: {terms: 47, types: 85, coercions: 19, joins: 0/3}
Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
  :: forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [NonEmpty a]
[GblId,
 Arity=2,
 Str=<L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 400 60}]
Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
  = \ (@ a_adx2T)
      (rp_adwa3 :: Int -> ReadS a_adx2T)
      (rl_adwa4 :: ReadS [a_adx2T]) ->
      Text.ParserCombinators.ReadP.run
        @ [NonEmpty a_adx2T]
        (((((list
               @ (NonEmpty a_adx2T)
               (let {
                  f_sdxsO [Dmd=<L,C(C1(U))>] :: Int -> ReadS a_adx2T
                  [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                  f_sdxsO
                    = \ (n_idx7Z :: Int) ->
                        Text.ParserCombinators.ReadP.run
                          @ a_adx2T
                          (case Text.ParserCombinators.ReadP.$wreadS_to_P
                                  @ a_adx2T
                                  (rp_adwa3 n_idx7Z)
                                  @ a_adx2T
                                  (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ a_adx2T)
                           of
                           { (# ww1_idxi6 #) ->
                           Text.ParserCombinators.ReadP.Look @ a_adx2T ww1_idxi6
                           }) } in
                let {
                  f1_sdxsN :: Text.ParserCombinators.ReadP.P [a_adx2T]
                  [LclId]
                  f1_sdxsN
                    = case Text.ParserCombinators.ReadP.$wreadS_to_P
                             @ [a_adx2T]
                             rl_adwa4
                             @ [a_adx2T]
                             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_adx2T])
                      of
                      { (# ww1_idxi6 #) ->
                      Text.ParserCombinators.ReadP.Look @ [a_adx2T] ww1_idxi6
                      } } in
                let {
                  f2_sdxsM [Dmd=<L,C(U)>] :: ReadS [a_adx2T]
                  [LclId, Arity=1, Unf=OtherCon []]
                  f2_sdxsM
                    = Text.ParserCombinators.ReadP.run @ [a_adx2T] f1_sdxsN } in
                (\ (n_Xdxne [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
                   (@ b_Xdxnh)
                   (eta_B1
                      :: NonEmpty a_adx2T -> Text.ParserCombinators.ReadP.P b_Xdxnh) ->
                   case Text.ParserCombinators.ReadP.$wreadS_to_P
                          @ (NonEmpty a_adx2T)
                          (\ (w_sdxWH :: String) ->
                             case n_Xdxne of { GHC.Types.I# ww1_sdxWK ->
                             Data.Functor.Classes.$w$cliftReadsPrec5
                               @ a_adx2T f_sdxsO f2_sdxsM ww1_sdxWK w_sdxWH
                             })
                          @ b_Xdxnh
                          eta_B1
                   of
                   { (# ww1_idxi6 #) ->
                   Text.ParserCombinators.ReadP.Look @ b_Xdxnh ww1_idxi6
                   })
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <NonEmpty
                                          a_adx2T>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <NonEmpty a_adx2T>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (NonEmpty a_adx2T -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec (NonEmpty a_adx2T) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[NonEmpty a_adx2T]>_R
                    :: (ReadPrec [NonEmpty a_adx2T] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [NonEmpty a_adx2T] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[NonEmpty a_adx2T]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [NonEmpty a_adx2T] :: *)
                     ~R# (forall b.
                          ([NonEmpty a_adx2T] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [NonEmpty a_adx2T]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [NonEmpty a_adx2T]))

-- RHS size: {terms: 20, types: 39, coercions: 6, joins: 0/1}
Data.Functor.Classes.$w$cliftReadListPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadPrec a
     -> ReadPrec [a]
     -> forall b.
        ([NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60] 170 60}]
Data.Functor.Classes.$w$cliftReadListPrec2
  = \ (@ a_sdxZp)
      (w_sdxZq :: ReadPrec a_sdxZp)
      (w1_sdxZr :: ReadPrec [a_sdxZp]) ->
      let {
        w2_sdxsI [Dmd=<L,C(U)>] :: ReadS [NonEmpty a_sdxZp]
        [LclId]
        w2_sdxsI
          = Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
              @ a_sdxZp
              (readPrec_to_S @ a_sdxZp w_sdxZq)
              (Text.ParserCombinators.ReadP.run
                 @ [a_sdxZp]
                 ((((w1_sdxZr
                     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_sdxZp]>_R
                             :: (ReadPrec [a_sdxZp] :: *)
                                ~R# (Text.ParserCombinators.ReadPrec.Prec
                                     -> Text.ParserCombinators.ReadP.ReadP [a_sdxZp] :: *)))
                      Data.Functor.Classes.$fRead1Identity5)
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_sdxZp]>_R
                           :: (Text.ParserCombinators.ReadP.ReadP [a_sdxZp] :: *)
                              ~R# (forall b.
                                   ([a_sdxZp] -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)))
                    @ [a_sdxZp]
                    (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                       @ [a_sdxZp]))) } in
      \ (@ b_idxi2)
        (w3_idxi3
           :: [NonEmpty a_sdxZp] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
        case Text.ParserCombinators.ReadP.$wreadS_to_P
               @ [NonEmpty a_sdxZp] w2_sdxsI @ b_idxi2 w3_idxi3
        of
        { (# ww1_idxi6 #) ->
        Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
        }

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1NonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadPrec a
     -> ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxZp)
                 (w_sdxZq [Occ=Once] :: ReadPrec a_sdxZp)
                 (w1_sdxZr [Occ=Once] :: ReadPrec [a_sdxZp])
                 _ [Occ=Dead] ->
                 Data.Functor.Classes.$w$cliftReadListPrec2
                   @ a_sdxZp w_sdxZq w1_sdxZr}]
Data.Functor.Classes.$fRead1NonEmpty1
  = \ (@ a_sdxZp)
      (w_sdxZq :: ReadPrec a_sdxZp)
      (w1_sdxZr :: ReadPrec [a_sdxZp])
      _ [Occ=Dead] ->
      Data.Functor.Classes.$w$cliftReadListPrec2
        @ a_sdxZp w_sdxZq w1_sdxZr

-- RHS size: {terms: 5, types: 1, coercions: 23, joins: 0/0}
Data.Functor.Classes.$fRead1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Read1 NonEmpty
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read1 TYPE: NonEmpty
                                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
                                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
                                    Data.Functor.Classes.$fRead1NonEmpty1
                                    `cast` (forall (a :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <[NonEmpty
                                                                    a]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                       <[NonEmpty
                                                                                           a]>_R)
                                            :: (forall a.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   ([NonEmpty a]
                                                    -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a.
                                                    ReadPrec a
                                                    -> ReadPrec [a] -> ReadPrec [NonEmpty a] :: *))]
Data.Functor.Classes.$fRead1NonEmpty
  = Data.Functor.Classes.C:Read1
      @ NonEmpty
      Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
      Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
      Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
      (Data.Functor.Classes.$fRead1NonEmpty1
       `cast` (forall (a :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <[NonEmpty
                                       a]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                          <[NonEmpty a]>_R)
               :: (forall a.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a.
                       ReadPrec a -> ReadPrec [a] -> ReadPrec [NonEmpty a] :: *)))

-- RHS size: {terms: 25, types: 46, coercions: 26, joins: 0/1}
Data.Functor.Classes.$dmliftReadsPrec
  :: forall (f :: * -> *).
     Read1 f =>
     forall a. (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_XdweY :: * -> *))
                 ($dRead1_XdwRv [Occ=Once] :: Read1 f_XdweY)
                 (@ a_adwMu)
                 (rp_adwa1 [Occ=Once] :: Int -> ReadS a_adwMu)
                 (rl_adwa2 [Occ=OnceL] :: ReadS [a_adwMu]) ->
                 let {
                   ds_idx7Y [Occ=OnceL] :: ReadPrec (f_XdweY a_adwMu)
                   [LclId]
                   ds_idx7Y
                     = liftReadPrec
                         @ f_XdweY
                         $dRead1_XdwRv
                         @ a_adwMu
                         ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                             @ a_adwMu rp_adwa1)
                          `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                   ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <a_adwMu>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                          <a_adwMu>_R)
                                  :: (Text.ParserCombinators.ReadPrec.Prec
                                      -> forall b.
                                         (a_adwMu -> Text.ParserCombinators.ReadP.P b)
                                         -> Text.ParserCombinators.ReadP.P b :: *)
                                     ~R# (ReadPrec a_adwMu :: *)))
                         ((\ _ [Occ=Dead]
                             (@ b_idxi2)
                             (w1_idxi3 [Occ=Once]
                                :: [a_adwMu] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                             case Text.ParserCombinators.ReadP.$wreadS_to_P
                                    @ [a_adwMu] rl_adwa2 @ b_idxi2 w1_idxi3
                             of
                             { (# ww1_idxi6 [Occ=Once] #) ->
                             Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                             })
                          `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                   ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <[a_adwMu]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                            <[a_adwMu]>_R)
                                  :: (Text.ParserCombinators.ReadPrec.Prec
                                      -> forall b.
                                         ([a_adwMu] -> Text.ParserCombinators.ReadP.P b)
                                         -> Text.ParserCombinators.ReadP.P b :: *)
                                     ~R# (ReadPrec [a_adwMu] :: *))) } in
                 \ (n_idx7Z [Occ=Once] :: Int) ->
                   Text.ParserCombinators.ReadP.run
                     @ (f_XdweY a_adwMu)
                     ((((ds_idx7Y
                         `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                     <f_XdweY a_adwMu>_R
                                 :: (ReadPrec (f_XdweY a_adwMu) :: *)
                                    ~R# (Text.ParserCombinators.ReadPrec.Prec
                                         -> Text.ParserCombinators.ReadP.ReadP
                                              (f_XdweY a_adwMu) :: *)))
                          n_idx7Z)
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <f_XdweY a_adwMu>_R
                               :: (Text.ParserCombinators.ReadP.ReadP (f_XdweY a_adwMu) :: *)
                                  ~R# (forall b.
                                       (f_XdweY a_adwMu -> Text.ParserCombinators.ReadP.P b)
                                       -> Text.ParserCombinators.ReadP.P b :: *)))
                        @ (f_XdweY a_adwMu)
                        (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                           @ (f_XdweY a_adwMu)))}]
Data.Functor.Classes.$dmliftReadsPrec
  = \ (@ (f_XdweY :: * -> *))
      ($dRead1_XdwRv :: Read1 f_XdweY)
      (@ a_adwMu)
      (rp_adwa1 :: Int -> ReadS a_adwMu)
      (rl_adwa2 :: ReadS [a_adwMu]) ->
      let {
        ds_sdxsG [Dmd=<L,C(C1(U))>] :: ReadPrec (f_XdweY a_adwMu)
        [LclId]
        ds_sdxsG
          = liftReadPrec
              @ f_XdweY
              $dRead1_XdwRv
              @ a_adwMu
              ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                  @ a_adwMu rp_adwa1)
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <a_adwMu>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <a_adwMu>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (a_adwMu -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec a_adwMu :: *)))
              ((\ _ [Occ=Dead]
                  (@ b_idxi2)
                  (w1_idxi3
                     :: [a_adwMu] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                  case Text.ParserCombinators.ReadP.$wreadS_to_P
                         @ [a_adwMu] rl_adwa2 @ b_idxi2 w1_idxi3
                  of
                  { (# ww1_idxi6 #) ->
                  Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                  })
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <[a_adwMu]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <[a_adwMu]>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              ([a_adwMu] -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec [a_adwMu] :: *))) } in
      \ (n_idx7Z :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (f_XdweY a_adwMu)
          ((((ds_sdxsG
              `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <f_XdweY a_adwMu>_R
                      :: (ReadPrec (f_XdweY a_adwMu) :: *)
                         ~R# (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP (f_XdweY a_adwMu) :: *)))
               n_idx7Z)
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <f_XdweY a_adwMu>_R
                    :: (Text.ParserCombinators.ReadP.ReadP (f_XdweY a_adwMu) :: *)
                       ~R# (forall b.
                            (f_XdweY a_adwMu -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)))
             @ (f_XdweY a_adwMu)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (f_XdweY a_adwMu)))

-- RHS size: {terms: 7, types: 13, coercions: 2, joins: 0/0}
eq1 :: forall (f :: * -> *) a. (Eq1 f, Eq a) => f a -> f a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwMe :: * -> *))
                 (@ a_adwMf)
                 ($dEq1_adwMh [Occ=Once] :: Eq1 f_adwMe)
                 ($dEq_adwMi [Occ=Once] :: Eq a_adwMf) ->
                 ($dEq1_adwMh
                  `cast` (Data.Functor.Classes.N:Eq1[0] <f_adwMe>_N
                          :: (Eq1 f_adwMe :: Constraint)
                             ~R# (forall a b.
                                  (a -> b -> Bool) -> f_adwMe a -> f_adwMe b -> Bool :: *)))
                   @ a_adwMf @ a_adwMf (== @ a_adwMf $dEq_adwMi)}]
eq1
  = \ (@ (f_adwMe :: * -> *))
      (@ a_adwMf)
      ($dEq1_adwMh :: Eq1 f_adwMe)
      ($dEq_adwMi :: Eq a_adwMf) ->
      ($dEq1_adwMh
       `cast` (Data.Functor.Classes.N:Eq1[0] <f_adwMe>_N
               :: (Eq1 f_adwMe :: Constraint)
                  ~R# (forall a b.
                       (a -> b -> Bool) -> f_adwMe a -> f_adwMe b -> Bool :: *)))
        @ a_adwMf @ a_adwMf (== @ a_adwMf $dEq_adwMi)

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
compare1
  :: forall (f :: * -> *) a.
     (Ord1 f, Ord a) =>
     f a -> f a -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)),1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwM2 :: * -> *))
                 (@ a_adwM3)
                 ($dOrd1_adwM5 [Occ=Once] :: Ord1 f_adwM2)
                 ($dOrd_adwM6 [Occ=Once] :: Ord a_adwM3) ->
                 liftCompare
                   @ f_adwM2
                   $dOrd1_adwM5
                   @ a_adwM3
                   @ a_adwM3
                   (compare @ a_adwM3 $dOrd_adwM6)}]
compare1
  = \ (@ (f_adwM2 :: * -> *))
      (@ a_adwM3)
      ($dOrd1_adwM5 :: Ord1 f_adwM2)
      ($dOrd_adwM6 :: Ord a_adwM3) ->
      liftCompare
        @ f_adwM2
        $dOrd1_adwM5
        @ a_adwM3
        @ a_adwM3
        (compare @ a_adwM3 $dOrd_adwM6)

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
readsPrec1
  :: forall (f :: * -> *) a. (Read1 f, Read a) => Int -> ReadS (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLL),1*U(1*C1(C1(U)),A,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwLg :: * -> *))
                 (@ a_adwLh)
                 ($dRead1_adwLj [Occ=Once] :: Read1 f_adwLg)
                 ($dRead_adwLk :: Read a_adwLh) ->
                 liftReadsPrec
                   @ f_adwLg
                   $dRead1_adwLj
                   @ a_adwLh
                   (readsPrec @ a_adwLh $dRead_adwLk)
                   (readList @ a_adwLh $dRead_adwLk)}]
readsPrec1
  = \ (@ (f_adwLg :: * -> *))
      (@ a_adwLh)
      ($dRead1_adwLj :: Read1 f_adwLg)
      ($dRead_adwLk :: Read a_adwLh) ->
      liftReadsPrec
        @ f_adwLg
        $dRead1_adwLj
        @ a_adwLh
        (readsPrec @ a_adwLh $dRead_adwLk)
        (readList @ a_adwLh $dRead_adwLk)

-- RHS size: {terms: 42, types: 69, coercions: 0, joins: 0/1}
readsUnary1
  :: forall (f :: * -> *) a t.
     (Read1 f, Read a) =>
     String -> (f a -> t) -> String -> ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 60 0 0] 280 10}]
readsUnary1
  = \ (@ (f_adwLt :: * -> *))
      (@ a_adwLu)
      (@ t_adwLv)
      ($dRead1_adwLx :: Read1 f_adwLt)
      ($dRead_adwLy :: Read a_adwLu)
      (name_adwed :: String)
      (cons_adwee :: f_adwLt a_adwLu -> t_adwLv)
      (kw_adwef :: String)
      (s_adweg :: String) ->
      case GHC.Base.eqString kw_adwef name_adwed of {
        False -> GHC.Types.[] @ (t_adwLv, String);
        True ->
          letrec {
            go_i7Jcj [Occ=LoopBreaker]
              :: [(f_adwLt a_adwLu, String)] -> [(t_adwLv, String)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i7Jcj
              = \ (ds_i7Jck :: [(f_adwLt a_adwLu, String)]) ->
                  case ds_i7Jck of {
                    [] -> GHC.Types.[] @ (t_adwLv, String);
                    : y_i7Jcp ys_i7Jcq ->
                      case y_i7Jcp of { (x_adweh, t1_adwei) ->
                      GHC.Types.:
                        @ (t_adwLv, String)
                        (cons_adwee x_adweh, t1_adwei)
                        (go_i7Jcj ys_i7Jcq)
                      }
                  }; } in
          go_i7Jcj
            (liftReadsPrec
               @ f_adwLt
               $dRead1_adwLx
               @ a_adwLu
               (readsPrec @ a_adwLu $dRead_adwLy)
               (readList @ a_adwLu $dRead_adwLy)
               Data.Functor.Classes.$fRead1Const1
               s_adweg)
      }

-- RHS size: {terms: 69, types: 124, coercions: 0, joins: 0/5}
readsBinary1
  :: forall (f :: * -> *) (g :: * -> *) a t.
     (Read1 f, Read1 g, Read a) =>
     String -> (f a -> g a -> t) -> String -> ReadS t
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(C(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 60 0 0] 470 10}]
readsBinary1
  = \ (@ (f_adwLH :: * -> *))
      (@ (g_adwLI :: * -> *))
      (@ a_adwLJ)
      (@ t_adwLK)
      ($dRead1_adwLM :: Read1 f_adwLH)
      ($dRead2_adwLN :: Read1 g_adwLI)
      ($dRead_adwLO :: Read a_adwLJ)
      (name_adwej :: String)
      (cons_adwek :: f_adwLH a_adwLJ -> g_adwLI a_adwLJ -> t_adwLK)
      (kw_adwel :: String)
      (s_adwem :: String) ->
      case GHC.Base.eqString kw_adwel name_adwej of {
        False -> GHC.Types.[] @ (t_adwLK, String);
        True ->
          let {
            lvl3_sdxuZ :: Int -> ReadS a_adwLJ
            [LclId]
            lvl3_sdxuZ = readsPrec @ a_adwLJ $dRead_adwLO } in
          let {
            lvl4_sdxv0 :: ReadS [a_adwLJ]
            [LclId]
            lvl4_sdxv0 = readList @ a_adwLJ $dRead_adwLO } in
          letrec {
            go_i7Jcj [Occ=LoopBreaker]
              :: [(f_adwLH a_adwLJ, String)] -> [(t_adwLK, String)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i7Jcj
              = \ (ds_i7Jck :: [(f_adwLH a_adwLJ, String)]) ->
                  case ds_i7Jck of {
                    [] -> GHC.Types.[] @ (t_adwLK, String);
                    : y_i7Jcp ys_i7Jcq ->
                      case y_i7Jcp of { (x_adwen, t1_adweo) ->
                      let {
                        z_X7Jks :: [(t_adwLK, String)]
                        [LclId]
                        z_X7Jks = go_i7Jcj ys_i7Jcq } in
                      letrec {
                        go1_X7Jkv [Occ=LoopBreaker]
                          :: [(g_adwLI a_adwLJ, String)] -> [(t_adwLK, String)]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go1_X7Jkv
                          = \ (ds1_X7Jkx :: [(g_adwLI a_adwLJ, String)]) ->
                              case ds1_X7Jkx of {
                                [] -> z_X7Jks;
                                : y1_X7JkF ys1_X7JkH ->
                                  case y1_X7JkF of { (y2_adwep, u_adweq) ->
                                  GHC.Types.:
                                    @ (t_adwLK, String)
                                    (cons_adwek x_adwen y2_adwep, u_adweq)
                                    (go1_X7Jkv ys1_X7JkH)
                                  }
                              }; } in
                      go1_X7Jkv
                        (liftReadsPrec
                           @ g_adwLI
                           $dRead2_adwLN
                           @ a_adwLJ
                           lvl3_sdxuZ
                           lvl4_sdxv0
                           Data.Functor.Classes.$fRead1Const1
                           t1_adweo)
                      }
                  }; } in
          go_i7Jcj
            (liftReadsPrec
               @ f_adwLH
               $dRead1_adwLM
               @ a_adwLJ
               lvl3_sdxuZ
               lvl4_sdxv0
               Data.Functor.Classes.$fRead1Const1
               s_adwem)
      }

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
readPrec1
  :: forall (f :: * -> *) a. (Read1 f, Read a) => ReadPrec (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwL3 :: * -> *))
                 (@ a_adwL4)
                 ($dRead1_adwL6 [Occ=Once] :: Read1 f_adwL3)
                 ($dRead_adwL7 :: Read a_adwL4) ->
                 liftReadPrec
                   @ f_adwL3
                   $dRead1_adwL6
                   @ a_adwL4
                   (readPrec @ a_adwL4 $dRead_adwL7)
                   (readListPrec @ a_adwL4 $dRead_adwL7)}]
readPrec1
  = \ (@ (f_adwL3 :: * -> *))
      (@ a_adwL4)
      ($dRead1_adwL6 :: Read1 f_adwL3)
      ($dRead_adwL7 :: Read a_adwL4) ->
      liftReadPrec
        @ f_adwL3
        $dRead1_adwL6
        @ a_adwL4
        (readPrec @ a_adwL4 $dRead_adwL7)
        (readListPrec @ a_adwL4 $dRead_adwL7)

-- RHS size: {terms: 22, types: 45, coercions: 28, joins: 0/0}
liftReadListDefault
  :: forall (f :: * -> *) a.
     Read1 f =>
     (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 170 60}]
liftReadListDefault
  = \ (@ (f_adwKQ :: * -> *))
      (@ a_adwKR)
      ($dRead1_adwKT :: Read1 f_adwKQ)
      (rp_adwdd :: Int -> ReadS a_adwKR)
      (rl_adwde :: ReadS [a_adwKR]) ->
      Text.ParserCombinators.ReadP.run
        @ [f_adwKQ a_adwKR]
        (((((liftReadListPrec
               @ f_adwKQ
               $dRead1_adwKT
               @ a_adwKR
               ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                   @ a_adwKR rp_adwdd)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <a_adwKR>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                <a_adwKR>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (a_adwKR -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec a_adwKR :: *)))
               ((\ _ [Occ=Dead]
                   (@ b_idxi2)
                   (w1_idxi3
                      :: [a_adwKR] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                   case Text.ParserCombinators.ReadP.$wreadS_to_P
                          @ [a_adwKR] rl_adwde @ b_idxi2 w1_idxi3
                   of
                   { (# ww1_idxi6 #) ->
                   Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                   })
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <[a_adwKR]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <[a_adwKR]>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               ([a_adwKR] -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec [a_adwKR] :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[f_adwKQ a_adwKR]>_R
                    :: (ReadPrec [f_adwKQ a_adwKR] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [f_adwKQ a_adwKR] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[f_adwKQ a_adwKR]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [f_adwKQ a_adwKR] :: *)
                     ~R# (forall b.
                          ([f_adwKQ a_adwKR] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [f_adwKQ a_adwKR]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [f_adwKQ a_adwKR]))

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
liftReadListPrecDefault
  :: forall (f :: * -> *) a.
     Read1 f =>
     ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwKH :: * -> *))
                 (@ a_adwKI)
                 ($dRead1_adwKK [Occ=Once] :: Read1 f_adwKH)
                 (rp_adwdf [Occ=Once] :: ReadPrec a_adwKI)
                 (rl_adwdg [Occ=Once] :: ReadPrec [a_adwKI]) ->
                 list
                   @ (f_adwKH a_adwKI)
                   (liftReadPrec
                      @ f_adwKH $dRead1_adwKK @ a_adwKI rp_adwdf rl_adwdg)}]
liftReadListPrecDefault
  = \ (@ (f_adwKH :: * -> *))
      (@ a_adwKI)
      ($dRead1_adwKK :: Read1 f_adwKH)
      (rp_adwdf :: ReadPrec a_adwKI)
      (rl_adwdg :: ReadPrec [a_adwKI]) ->
      list
        @ (f_adwKH a_adwKI)
        (liftReadPrec @ f_adwKH $dRead1_adwKK @ a_adwKI rp_adwdf rl_adwdg)

-- RHS size: {terms: 3, types: 7, coercions: 15, joins: 0/0}
lvl_rdymy :: forall a. ReadPrec [Proxy a]
[GblId]
lvl_rdymy
  = \ (@ a_adx1z) ->
      list
        @ (Proxy a_adx1z)
        ((Data.Functor.Classes.$fRead1Proxy1 @ a_adx1z)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Proxy
                                   a_adx1z>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Proxy a_adx1z>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Proxy a_adx1z -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Proxy a_adx1z) :: *)))

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec
  :: forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [Proxy a]
[GblId,
 Arity=2,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx1z) _ [Occ=Dead] _ [Occ=Dead] ->
                 list
                   @ (Proxy a_adx1z)
                   ((Data.Functor.Classes.$fRead1Proxy1 @ a_adx1z)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Proxy
                                              a_adx1z>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Proxy a_adx1z>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Proxy a_adx1z -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (Proxy a_adx1z) :: *)))}]
Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec
  = \ (@ a_adx1z) _ [Occ=Dead] _ [Occ=Dead] -> lvl_rdymy @ a_adx1z

-- RHS size: {terms: 9, types: 26, coercions: 15, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
  :: forall a.
     (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (Proxy a)
[GblId,
 Arity=3,
 Str=<L,A><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx12)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (n_idx7Z [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Proxy a_adx12)
                   (GHC.Read.list3
                      @ (Proxy a_adx12)
                      ((Data.Functor.Classes.$fRead1Proxy2 @ a_adx12)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Proxy
                                                 a_adx12>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Proxy a_adx12>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Proxy a_adx12 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (ReadPrec (Proxy a_adx12) :: *)))
                      n_idx7Z
                      @ (Proxy a_adx12)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Proxy a_adx12)))}]
Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
  = \ (@ a_adx12) _ [Occ=Dead] _ [Occ=Dead] (n_idx7Z :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Proxy a_adx12)
        (GHC.Read.list3
           @ (Proxy a_adx12)
           ((Data.Functor.Classes.$fRead1Proxy2 @ a_adx12)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Proxy
                                      a_adx12>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Proxy a_adx12>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Proxy a_adx12 -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec (Proxy a_adx12) :: *)))
           n_idx7Z
           @ (Proxy a_adx12)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Proxy a_adx12)))

-- RHS size: {terms: 5, types: 17, coercions: 27, joins: 0/0}
lvl1_rdymz :: forall a. Text.ParserCombinators.ReadP.P [Proxy a]
[GblId]
lvl1_rdymz
  = \ (@ a_adx1a) ->
      ((((list
            @ (Proxy a_adx1a)
            ((Data.Functor.Classes.$fRead1Proxy1 @ a_adx1a)
             `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <Proxy
                                       a_adx1a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <Proxy a_adx1a>_R)
                     :: (Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (Proxy a_adx1a -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)
                        ~R# (ReadPrec (Proxy a_adx1a) :: *))))
         `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                     <[Proxy a_adx1a]>_R
                 :: (ReadPrec [Proxy a_adx1a] :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.Prec
                         -> Text.ParserCombinators.ReadP.ReadP [Proxy a_adx1a] :: *)))
          Data.Functor.Classes.$fRead1Identity5)
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Proxy a_adx1a]>_R
               :: (Text.ParserCombinators.ReadP.ReadP [Proxy a_adx1a] :: *)
                  ~R# (forall b.
                       ([Proxy a_adx1a] -> Text.ParserCombinators.ReadP.P b)
                       -> Text.ParserCombinators.ReadP.P b :: *)))
        @ [Proxy a_adx1a]
        (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
           @ [Proxy a_adx1a])

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
lvl2_rdymA :: forall a. ReadS [Proxy a]
[GblId, Arity=1, Unf=OtherCon []]
lvl2_rdymA
  = \ (@ a_adx1a) ->
      Text.ParserCombinators.ReadP.run
        @ [Proxy a_adx1a] (lvl1_rdymz @ a_adx1a)

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy_$cliftReadList
  :: forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [Proxy a]
[GblId,
 Arity=3,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx1a) _ [Occ=Dead] _ [Occ=Dead] ->
                 Text.ParserCombinators.ReadP.run
                   @ [Proxy a_adx1a]
                   (((((list
                          @ (Proxy a_adx1a)
                          ((Data.Functor.Classes.$fRead1Proxy1 @ a_adx1a)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Proxy
                                                     a_adx1a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Proxy a_adx1a>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Proxy a_adx1a -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (ReadPrec (Proxy a_adx1a) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Proxy a_adx1a]>_R
                               :: (ReadPrec [Proxy a_adx1a] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [Proxy a_adx1a] :: *)))
                        Data.Functor.Classes.$fRead1Identity5)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Proxy a_adx1a]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Proxy a_adx1a] :: *)
                                ~R# (forall b.
                                     ([Proxy a_adx1a] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Proxy a_adx1a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Proxy a_adx1a]))}]
Data.Functor.Classes.$fRead1Proxy_$cliftReadList
  = \ (@ a_adx1a) _ [Occ=Dead] _ [Occ=Dead] -> lvl2_rdymA @ a_adx1a

-- RHS size: {terms: 5, types: 3, coercions: 25, joins: 0/0}
Data.Functor.Classes.$fRead1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Read1 Proxy
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read1 TYPE: Proxy
                                    Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
                                    Data.Functor.Classes.$fRead1Proxy_$cliftReadList
                                    Data.Functor.Classes.$fRead1Proxy5
                                    `cast` (forall (a :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Proxy
                                                                   a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                     <Proxy a>_R)
                                            :: (forall a.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Proxy a -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a.
                                                    ReadPrec a
                                                    -> ReadPrec [a] -> ReadPrec (Proxy a) :: *))
                                    Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec]
Data.Functor.Classes.$fRead1Proxy
  = Data.Functor.Classes.C:Read1
      @ Proxy
      Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
      Data.Functor.Classes.$fRead1Proxy_$cliftReadList
      (Data.Functor.Classes.$fRead1Proxy5
       `cast` (forall (a :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Proxy
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Proxy a>_R)
               :: (forall a.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Proxy a -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a.
                       ReadPrec a -> ReadPrec [a] -> ReadPrec (Proxy a) :: *)))
      Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1[]_$cliftReadListPrec
  :: forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [[a]]
[GblId,
 Arity=2,
 Str=<L,A><L,1*C1(C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adx3F)
                 _ [Occ=Dead]
                 (rl_adwdg [Occ=Once] :: ReadPrec [a_adx3F]) ->
                 list @ [a_adx3F] rl_adwdg}]
Data.Functor.Classes.$fRead1[]_$cliftReadListPrec
  = \ (@ a_adx3F) _ [Occ=Dead] (rl_adwdg :: ReadPrec [a_adx3F]) ->
      list @ [a_adx3F] rl_adwdg

-- RHS size: {terms: 12, types: 29, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
  :: forall a. (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,C(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx3j)
                 _ [Occ=Dead]
                 (rl_adwa2 [Occ=Once] :: ReadS [a_adx3j])
                 _ [Occ=Dead] ->
                 Text.ParserCombinators.ReadP.run
                   @ [a_adx3j]
                   (case Text.ParserCombinators.ReadP.$wreadS_to_P
                           @ [a_adx3j]
                           rl_adwa2
                           @ [a_adx3j]
                           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_adx3j])
                    of
                    { (# ww1_idxi6 [Occ=Once] #) ->
                    Text.ParserCombinators.ReadP.Look @ [a_adx3j] ww1_idxi6
                    })}]
Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
  = \ (@ a_adx3j)
      _ [Occ=Dead]
      (rl_adwa2 :: ReadS [a_adx3j])
      _ [Occ=Dead] ->
      Text.ParserCombinators.ReadP.run
        @ [a_adx3j]
        (case Text.ParserCombinators.ReadP.$wreadS_to_P
                @ [a_adx3j]
                rl_adwa2
                @ [a_adx3j]
                (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [a_adx3j])
         of
         { (# ww1_idxi6 #) ->
         Text.ParserCombinators.ReadP.Look @ [a_adx3j] ww1_idxi6
         })

-- RHS size: {terms: 16, types: 35, coercions: 19, joins: 0/0}
Data.Functor.Classes.$w$cliftReadList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. ReadS [a] -> ReadS [[a]]
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 130 60}]
Data.Functor.Classes.$w$cliftReadList2
  = \ (@ a_sdxZW) (w_sdxZY :: ReadS [a_sdxZW]) ->
      Text.ParserCombinators.ReadP.run
        @ [[a_sdxZW]]
        (((((list
               @ [a_sdxZW]
               ((\ _ [Occ=Dead, OS=OneShot]
                   (@ b_idxi2)
                   (w1_idxi3
                      :: [a_sdxZW] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                   case Text.ParserCombinators.ReadP.$wreadS_to_P
                          @ [a_sdxZW] w_sdxZY @ b_idxi2 w1_idxi3
                   of
                   { (# ww1_idxi6 #) ->
                   Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                   })
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <[a_sdxZW]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <[a_sdxZW]>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               ([a_sdxZW] -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec [a_sdxZW] :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[[a_sdxZW]]>_R
                    :: (ReadPrec [[a_sdxZW]] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [[a_sdxZW]] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[[a_sdxZW]]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [[a_sdxZW]] :: *)
                     ~R# (forall b.
                          ([[a_sdxZW]] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [[a_sdxZW]]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [[a_sdxZW]]))

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1[]_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [[a]]
[GblId,
 Arity=2,
 Str=<L,A><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdxZW)
                 _ [Occ=Dead]
                 (w1_sdxZY [Occ=Once] :: ReadS [a_sdxZW]) ->
                 Data.Functor.Classes.$w$cliftReadList2 @ a_sdxZW w1_sdxZY}]
Data.Functor.Classes.$fRead1[]_$cliftReadList
  = \ (@ a_sdxZW) _ [Occ=Dead] (w1_sdxZY :: ReadS [a_sdxZW]) ->
      Data.Functor.Classes.$w$cliftReadList2 @ a_sdxZW w1_sdxZY

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Read1 []
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read1 TYPE: []
                                    Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
                                    Data.Functor.Classes.$fRead1[]_$cliftReadList
                                    Data.Functor.Classes.$fRead1[]_$cliftReadPrec
                                    Data.Functor.Classes.$fRead1[]_$cliftReadListPrec]
Data.Functor.Classes.$fRead1[]
  = Data.Functor.Classes.C:Read1
      @ []
      Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
      Data.Functor.Classes.$fRead1[]_$cliftReadList
      Data.Functor.Classes.$fRead1[]_$cliftReadPrec
      Data.Functor.Classes.$fRead1[]_$cliftReadListPrec

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
showsPrec1
  :: forall (f :: * -> *) a. (Show1 f, Show a) => Int -> f a -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U(1*U,A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwJA :: * -> *))
                 (@ a_adwJB)
                 ($dShow1_adwJD [Occ=Once] :: Show1 f_adwJA)
                 ($dShow_adwJE :: Show a_adwJB) ->
                 liftShowsPrec
                   @ f_adwJA
                   $dShow1_adwJD
                   @ a_adwJB
                   (showsPrec @ a_adwJB $dShow_adwJE)
                   (showList @ a_adwJB $dShow_adwJE)}]
showsPrec1
  = \ (@ (f_adwJA :: * -> *))
      (@ a_adwJB)
      ($dShow1_adwJD :: Show1 f_adwJA)
      ($dShow_adwJE :: Show a_adwJB) ->
      liftShowsPrec
        @ f_adwJA
        $dShow1_adwJD
        @ a_adwJB
        (showsPrec @ a_adwJB $dShow_adwJE)
        (showList @ a_adwJB $dShow_adwJE)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.showsUnaryWith1 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.showsUnaryWith1 = GHC.Types.C# ' '#

-- RHS size: {terms: 40, types: 29, coercions: 0, joins: 0/1}
Data.Functor.Classes.$wshowsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Show1 f, Show a) =>
     String -> GHC.Prim.Int# -> f a -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><L,U><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0 0] 291 120}]
Data.Functor.Classes.$wshowsUnary1
  = \ (@ (f_sdy00 :: * -> *))
      (@ a_sdy01)
      (w_sdy02 :: Show1 f_sdy00)
      (w1_sdy03 :: Show a_sdy01)
      (w2_sdy04 :: String)
      (ww_sdy09 :: GHC.Prim.Int#)
      (w3_sdy06 :: f_sdy00 a_sdy01) ->
      let {
        g_sdxsB [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sdxsB
          = liftShowsPrec
              @ f_sdy00
              w_sdy02
              @ a_sdy01
              (showsPrec @ a_sdy01 w1_sdy03)
              (showList @ a_sdy01 w1_sdy03)
              Data.Functor.Classes.$fRead1Const1
              w3_sdy06 } in
      case GHC.Prim.># ww_sdy09 10# of {
        __DEFAULT ->
          \ (x_X7RCi :: String) ->
            ++
              @ Char
              w2_sdy04
              (GHC.Types.:
                 @ Char Data.Functor.Classes.showsUnaryWith1 (g_sdxsB x_X7RCi));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (++
                 @ Char
                 w2_sdy04
                 (GHC.Types.:
                    @ Char
                    Data.Functor.Classes.showsUnaryWith1
                    (g_sdxsB (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))
      }

-- RHS size: {terms: 16, types: 18, coercions: 0, joins: 0/0}
showsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Show1 f, Show a) =>
     String -> Int -> f a -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sdy00 :: * -> *))
                 (@ a_sdy01)
                 (w_sdy02 [Occ=Once] :: Show1 f_sdy00)
                 (w1_sdy03 [Occ=Once] :: Show a_sdy01)
                 (w2_sdy04 [Occ=Once] :: String)
                 (w3_sdy05 [Occ=Once!] :: Int)
                 (w4_sdy06 [Occ=Once] :: f_sdy00 a_sdy01) ->
                 case w3_sdy05 of { GHC.Types.I# ww1_sdy09 [Occ=Once] ->
                 Data.Functor.Classes.$wshowsUnary1
                   @ f_sdy00 @ a_sdy01 w_sdy02 w1_sdy03 w2_sdy04 ww1_sdy09 w4_sdy06
                 }}]
showsUnary1
  = \ (@ (f_sdy00 :: * -> *))
      (@ a_sdy01)
      (w_sdy02 :: Show1 f_sdy00)
      (w1_sdy03 :: Show a_sdy01)
      (w2_sdy04 :: String)
      (w3_sdy05 :: Int)
      (w4_sdy06 :: f_sdy00 a_sdy01) ->
      case w3_sdy05 of { GHC.Types.I# ww1_sdy09 ->
      Data.Functor.Classes.$wshowsUnary1
        @ f_sdy00 @ a_sdy01 w_sdy02 w1_sdy03 w2_sdy04 ww1_sdy09 w4_sdy06
      }

-- RHS size: {terms: 58, types: 45, coercions: 0, joins: 0/2}
Data.Functor.Classes.$wshowsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     String -> GHC.Prim.Int# -> f a -> g a -> ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 120 0 0 0 0] 461 120}]
Data.Functor.Classes.$wshowsBinary1
  = \ (@ (f_sdy0c :: * -> *))
      (@ (g_sdy0d :: * -> *))
      (@ a_sdy0e)
      (w_sdy0f :: Show1 f_sdy0c)
      (w1_sdy0g :: Show1 g_sdy0d)
      (w2_sdy0h :: Show a_sdy0e)
      (w3_sdy0i :: String)
      (ww_sdy0o :: GHC.Prim.Int#)
      (w4_sdy0k :: f_sdy0c a_sdy0e)
      (w5_sdy0l :: g_sdy0d a_sdy0e) ->
      let {
        f1_sdxsv [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f1_sdxsv
          = liftShowsPrec
              @ f_sdy0c
              w_sdy0f
              @ a_sdy0e
              (showsPrec @ a_sdy0e w2_sdy0h)
              (showList @ a_sdy0e w2_sdy0h)
              Data.Functor.Classes.$fRead1Const1
              w4_sdy0k } in
      let {
        g1_sdxst [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g1_sdxst
          = liftShowsPrec
              @ g_sdy0d
              w1_sdy0g
              @ a_sdy0e
              (showsPrec @ a_sdy0e w2_sdy0h)
              (showList @ a_sdy0e w2_sdy0h)
              Data.Functor.Classes.$fRead1Const1
              w5_sdy0l } in
      case GHC.Prim.># ww_sdy0o 10# of {
        __DEFAULT ->
          \ (x_X7RCu :: String) ->
            ++
              @ Char
              w3_sdy0i
              (GHC.Types.:
                 @ Char
                 Data.Functor.Classes.showsUnaryWith1
                 (f1_sdxsv
                    (GHC.Types.:
                       @ Char Data.Functor.Classes.showsUnaryWith1 (g1_sdxst x_X7RCu))));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (++
                 @ Char
                 w3_sdy0i
                 (GHC.Types.:
                    @ Char
                    Data.Functor.Classes.showsUnaryWith1
                    (f1_sdxsv
                       (GHC.Types.:
                          @ Char
                          Data.Functor.Classes.showsUnaryWith1
                          (g1_sdxst (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))))
      }

-- RHS size: {terms: 21, types: 27, coercions: 0, joins: 0/0}
showsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     String -> Int -> f a -> g a -> ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sdy0c :: * -> *))
                 (@ (g_sdy0d :: * -> *))
                 (@ a_sdy0e)
                 (w_sdy0f [Occ=Once] :: Show1 f_sdy0c)
                 (w1_sdy0g [Occ=Once] :: Show1 g_sdy0d)
                 (w2_sdy0h [Occ=Once] :: Show a_sdy0e)
                 (w3_sdy0i [Occ=Once] :: String)
                 (w4_sdy0j [Occ=Once!] :: Int)
                 (w5_sdy0k [Occ=Once] :: f_sdy0c a_sdy0e)
                 (w6_sdy0l [Occ=Once] :: g_sdy0d a_sdy0e) ->
                 case w4_sdy0j of { GHC.Types.I# ww1_sdy0o [Occ=Once] ->
                 Data.Functor.Classes.$wshowsBinary1
                   @ f_sdy0c
                   @ g_sdy0d
                   @ a_sdy0e
                   w_sdy0f
                   w1_sdy0g
                   w2_sdy0h
                   w3_sdy0i
                   ww1_sdy0o
                   w5_sdy0k
                   w6_sdy0l
                 }}]
showsBinary1
  = \ (@ (f_sdy0c :: * -> *))
      (@ (g_sdy0d :: * -> *))
      (@ a_sdy0e)
      (w_sdy0f :: Show1 f_sdy0c)
      (w1_sdy0g :: Show1 g_sdy0d)
      (w2_sdy0h :: Show a_sdy0e)
      (w3_sdy0i :: String)
      (w4_sdy0j :: Int)
      (w5_sdy0k :: f_sdy0c a_sdy0e)
      (w6_sdy0l :: g_sdy0d a_sdy0e) ->
      case w4_sdy0j of { GHC.Types.I# ww1_sdy0o ->
      Data.Functor.Classes.$wshowsBinary1
        @ f_sdy0c
        @ g_sdy0d
        @ a_sdy0e
        w_sdy0f
        w1_sdy0g
        w2_sdy0h
        w3_sdy0i
        ww1_sdy0o
        w5_sdy0k
        w6_sdy0l
      }

-- RHS size: {terms: 11, types: 22, coercions: 2, joins: 0/0}
eq2
  :: forall (f :: * -> * -> *) a b.
     (Eq2 f, Eq a, Eq b) =>
     f a b -> f a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwJi :: * -> * -> *))
                 (@ a_adwJj)
                 (@ b_adwJk)
                 ($dEq2_adwJm [Occ=Once] :: Eq2 f_adwJi)
                 ($dEq_adwJn [Occ=Once] :: Eq a_adwJj)
                 ($dEq1_adwJo [Occ=Once] :: Eq b_adwJk) ->
                 ($dEq2_adwJm
                  `cast` (Data.Functor.Classes.N:Eq2[0] <f_adwJi>_N
                          :: (Eq2 f_adwJi :: Constraint)
                             ~R# (forall a b c d.
                                  (a -> b -> Bool)
                                  -> (c -> d -> Bool) -> f_adwJi a c -> f_adwJi b d -> Bool :: *)))
                   @ a_adwJj
                   @ a_adwJj
                   @ b_adwJk
                   @ b_adwJk
                   (== @ a_adwJj $dEq_adwJn)
                   (== @ b_adwJk $dEq1_adwJo)}]
eq2
  = \ (@ (f_adwJi :: * -> * -> *))
      (@ a_adwJj)
      (@ b_adwJk)
      ($dEq2_adwJm :: Eq2 f_adwJi)
      ($dEq_adwJn :: Eq a_adwJj)
      ($dEq1_adwJo :: Eq b_adwJk) ->
      ($dEq2_adwJm
       `cast` (Data.Functor.Classes.N:Eq2[0] <f_adwJi>_N
               :: (Eq2 f_adwJi :: Constraint)
                  ~R# (forall a b c d.
                       (a -> b -> Bool)
                       -> (c -> d -> Bool) -> f_adwJi a c -> f_adwJi b d -> Bool :: *)))
        @ a_adwJj
        @ a_adwJj
        @ b_adwJk
        @ b_adwJk
        (== @ a_adwJj $dEq_adwJn)
        (== @ b_adwJk $dEq1_adwJo)

-- RHS size: {terms: 12, types: 23, coercions: 0, joins: 0/0}
compare2
  :: forall (f :: * -> * -> *) a b.
     (Ord2 f, Ord a, Ord b) =>
     f a b -> f a b -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,1*U(A,1*U,A,A,A,A,A,A)><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwJ0 :: * -> * -> *))
                 (@ a_adwJ1)
                 (@ b_adwJ2)
                 ($dOrd2_adwJ4 [Occ=Once] :: Ord2 f_adwJ0)
                 ($dOrd_adwJ5 [Occ=Once] :: Ord a_adwJ1)
                 ($dOrd1_adwJ6 [Occ=Once] :: Ord b_adwJ2) ->
                 liftCompare2
                   @ f_adwJ0
                   $dOrd2_adwJ4
                   @ a_adwJ1
                   @ a_adwJ1
                   @ b_adwJ2
                   @ b_adwJ2
                   (compare @ a_adwJ1 $dOrd_adwJ5)
                   (compare @ b_adwJ2 $dOrd1_adwJ6)}]
compare2
  = \ (@ (f_adwJ0 :: * -> * -> *))
      (@ a_adwJ1)
      (@ b_adwJ2)
      ($dOrd2_adwJ4 :: Ord2 f_adwJ0)
      ($dOrd_adwJ5 :: Ord a_adwJ1)
      ($dOrd1_adwJ6 :: Ord b_adwJ2) ->
      liftCompare2
        @ f_adwJ0
        $dOrd2_adwJ4
        @ a_adwJ1
        @ a_adwJ1
        @ b_adwJ2
        @ b_adwJ2
        (compare @ a_adwJ1 $dOrd_adwJ5)
        (compare @ b_adwJ2 $dOrd1_adwJ6)

-- RHS size: {terms: 16, types: 23, coercions: 0, joins: 0/0}
readsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Read2 f, Read a, Read b) =>
     Int -> ReadS (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))LLL),1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 60] 140 0}]
readsPrec2
  = \ (@ (f_adwIG :: * -> * -> *))
      (@ a_adwIH)
      (@ b_adwII)
      ($dRead2_adwIK :: Read2 f_adwIG)
      ($dRead_adwIL :: Read a_adwIH)
      ($dRead1_adwIM :: Read b_adwII) ->
      liftReadsPrec2
        @ f_adwIG
        $dRead2_adwIK
        @ a_adwIH
        @ b_adwII
        (readsPrec @ a_adwIH $dRead_adwIL)
        (readList @ a_adwIH $dRead_adwIL)
        (readsPrec @ b_adwII $dRead1_adwIM)
        (readList @ b_adwII $dRead1_adwIM)

-- RHS size: {terms: 16, types: 23, coercions: 0, joins: 0/0}
readPrec2
  :: forall (f :: * -> * -> *) a b.
     (Read2 f, Read a, Read b) =>
     ReadPrec (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,A,1*U,1*U)><L,U(A,A,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 60] 140 0}]
readPrec2
  = \ (@ (f_adwIm :: * -> * -> *))
      (@ a_adwIn)
      (@ b_adwIo)
      ($dRead2_adwIq :: Read2 f_adwIm)
      ($dRead_adwIr :: Read a_adwIn)
      ($dRead1_adwIs :: Read b_adwIo) ->
      liftReadPrec2
        @ f_adwIm
        $dRead2_adwIq
        @ a_adwIn
        @ b_adwIo
        (readPrec @ a_adwIn $dRead_adwIr)
        (readListPrec @ a_adwIn $dRead_adwIr)
        (readPrec @ b_adwIo $dRead1_adwIs)
        (readListPrec @ b_adwIo $dRead1_adwIs)

-- RHS size: {terms: 37, types: 79, coercions: 50, joins: 0/0}
liftReadList2Default
  :: forall (f :: * -> * -> *) a b.
     Read2 f =>
     (Int -> ReadS a)
     -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(C1(C1(U)))))))><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 280 60}]
liftReadList2Default
  = \ (@ (f_adwHZ :: * -> * -> *))
      (@ a_adwI0)
      (@ b_adwI1)
      ($dRead2_adwI3 :: Read2 f_adwHZ)
      (rp1_adwdh :: Int -> ReadS a_adwI0)
      (rl1_adwdi :: ReadS [a_adwI0])
      (rp2_adwdj :: Int -> ReadS b_adwI1)
      (rl2_adwdk :: ReadS [b_adwI1]) ->
      Text.ParserCombinators.ReadP.run
        @ [f_adwHZ a_adwI0 b_adwI1]
        (((((liftReadListPrec2
               @ f_adwHZ
               $dRead2_adwI3
               @ a_adwI0
               @ b_adwI1
               ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                   @ a_adwI0 rp1_adwdh)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <a_adwI0>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                <a_adwI0>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (a_adwI0 -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec a_adwI0 :: *)))
               ((\ _ [Occ=Dead]
                   (@ b1_idxi2)
                   (w1_idxi3
                      :: [a_adwI0] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                   case Text.ParserCombinators.ReadP.$wreadS_to_P
                          @ [a_adwI0] rl1_adwdi @ b1_idxi2 w1_idxi3
                   of
                   { (# ww1_idxi6 #) ->
                   Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                   })
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <[a_adwI0]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <[a_adwI0]>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               ([a_adwI0] -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec [a_adwI0] :: *)))
               ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                   @ b_adwI1 rp2_adwdj)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <b_adwI1>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                <b_adwI1>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (b_adwI1 -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec b_adwI1 :: *)))
               ((\ _ [Occ=Dead]
                   (@ b1_idxi2)
                   (w1_idxi3
                      :: [b_adwI1] -> Text.ParserCombinators.ReadP.P b1_idxi2) ->
                   case Text.ParserCombinators.ReadP.$wreadS_to_P
                          @ [b_adwI1] rl2_adwdk @ b1_idxi2 w1_idxi3
                   of
                   { (# ww1_idxi6 #) ->
                   Text.ParserCombinators.ReadP.Look @ b1_idxi2 ww1_idxi6
                   })
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <[b_adwI1]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <[b_adwI1]>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               ([b_adwI1] -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec [b_adwI1] :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[f_adwHZ a_adwI0 b_adwI1]>_R
                    :: (ReadPrec [f_adwHZ a_adwI0 b_adwI1] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP
                                 [f_adwHZ a_adwI0 b_adwI1] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[f_adwHZ a_adwI0 b_adwI1]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP
                        [f_adwHZ a_adwI0 b_adwI1] :: *)
                     ~R# (forall b.
                          ([f_adwHZ a_adwI0 b_adwI1] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [f_adwHZ a_adwI0 b_adwI1]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [f_adwHZ a_adwI0 b_adwI1]))

Rec {
-- RHS size: {terms: 5, types: 1, coercions: 33, joins: 0/0}
Data.Functor.Classes.$fRead2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Read2 Either
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read2 TYPE: Either
                                    Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
                                    Data.Functor.Classes.$fRead2Either_$cliftReadList2
                                    Data.Functor.Classes.$fRead1Either8
                                    `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R <ReadPrec b>_R
                                            ->_R <ReadPrec [b]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Either
                                                                   a
                                                                   b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                     <Either a b>_R)
                                            :: (forall a b.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> ReadPrec b
                                                -> ReadPrec [b]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Either a b -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a b.
                                                    ReadPrec a
                                                    -> ReadPrec [a]
                                                    -> ReadPrec b
                                                    -> ReadPrec [b]
                                                    -> ReadPrec (Either a b) :: *))
                                    Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2]
Data.Functor.Classes.$fRead2Either
  = Data.Functor.Classes.C:Read2
      @ Either
      Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
      Data.Functor.Classes.$fRead2Either_$cliftReadList2
      (Data.Functor.Classes.$fRead1Either8
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R <ReadPrec b>_R
               ->_R <ReadPrec [b]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Either
                                      a b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                          <Either a b>_R)
               :: (forall a b.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> ReadPrec b
                   -> ReadPrec [b]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Either a b -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a b.
                       ReadPrec a
                       -> ReadPrec [a]
                       -> ReadPrec b
                       -> ReadPrec [b]
                       -> ReadPrec (Either a b) :: *)))
      Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead2Either_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (Int -> ReadS a)
     -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [Either a b]
[GblId, Arity=4, Unf=OtherCon []]
Data.Functor.Classes.$fRead2Either_$cliftReadList2
  = \ (@ a_adwTQ) (@ b_adwTR) ->
      liftReadList2Default
        @ Either @ a_adwTQ @ b_adwTR Data.Functor.Classes.$fRead2Either
end Rec }

Rec {
-- RHS size: {terms: 5, types: 3, coercions: 37, joins: 0/0}
Data.Functor.Classes.$fRead2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Read2 Const
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read2 TYPE: Const
                                    Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
                                    Data.Functor.Classes.$fRead2Const_$cliftReadList2
                                    Data.Functor.Classes.$fRead1Const6
                                    `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R <ReadPrec b>_R
                                            ->_R <ReadPrec [b]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Const
                                                                   a
                                                                   b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                     <Const a b>_R)
                                            :: (forall a b.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> ReadPrec b
                                                -> ReadPrec [b]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Const a b -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a b.
                                                    ReadPrec a
                                                    -> ReadPrec [a]
                                                    -> ReadPrec b
                                                    -> ReadPrec [b]
                                                    -> ReadPrec (Const a b) :: *))
                                    Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2]
Data.Functor.Classes.$fRead2Const
  = Data.Functor.Classes.C:Read2
      @ Const
      Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
      Data.Functor.Classes.$fRead2Const_$cliftReadList2
      (Data.Functor.Classes.$fRead1Const6
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R <ReadPrec b>_R
               ->_R <ReadPrec [b]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Const
                                      a b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                          <Const a b>_R)
               :: (forall a b.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> ReadPrec b
                   -> ReadPrec [b]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Const a b -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a b.
                       ReadPrec a
                       -> ReadPrec [a]
                       -> ReadPrec b
                       -> ReadPrec [b]
                       -> ReadPrec (Const a b) :: *)))
      Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead2Const_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (Int -> ReadS a)
     -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [Const a b]
[GblId, Arity=4, Unf=OtherCon []]
Data.Functor.Classes.$fRead2Const_$cliftReadList2
  = \ (@ a_adwSm) (@ b_adwSn) ->
      liftReadList2Default
        @ Const @ a_adwSm @ b_adwSn Data.Functor.Classes.$fRead2Const
end Rec }

Rec {
-- RHS size: {terms: 5, types: 1, coercions: 33, joins: 0/0}
Data.Functor.Classes.$fRead2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Read2 (,)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read2 TYPE: (,)
                                    Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
                                    Data.Functor.Classes.$fRead2(,)_$cliftReadList2
                                    Data.Functor.Classes.$fRead1(,)2
                                    `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R <ReadPrec b>_R
                                            ->_R <ReadPrec [b]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <(a,
                                                                  b)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                     <(a, b)>_R)
                                            :: (forall a b.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> ReadPrec b
                                                -> ReadPrec [b]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   ((a, b) -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a b.
                                                    ReadPrec a
                                                    -> ReadPrec [a]
                                                    -> ReadPrec b
                                                    -> ReadPrec [b]
                                                    -> ReadPrec (a, b) :: *))
                                    Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2]
Data.Functor.Classes.$fRead2(,)
  = Data.Functor.Classes.C:Read2
      @ (,)
      Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
      Data.Functor.Classes.$fRead2(,)_$cliftReadList2
      (Data.Functor.Classes.$fRead1(,)2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R <ReadPrec b>_R
               ->_R <ReadPrec [b]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <(a, b)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <(a, b)>_R)
               :: (forall a b.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> ReadPrec b
                   -> ReadPrec [b]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ((a, b) -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a b.
                       ReadPrec a
                       -> ReadPrec [a]
                       -> ReadPrec b
                       -> ReadPrec [b]
                       -> ReadPrec (a, b) :: *)))
      Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead2(,)_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (Int -> ReadS a)
     -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [(a, b)]
[GblId, Arity=4, Unf=OtherCon []]
Data.Functor.Classes.$fRead2(,)_$cliftReadList2
  = \ (@ a_adwVr) (@ b_adwVs) ->
      liftReadList2Default
        @ (,) @ a_adwVr @ b_adwVs Data.Functor.Classes.$fRead2(,)
end Rec }

-- RHS size: {terms: 15, types: 28, coercions: 0, joins: 0/0}
liftReadListPrec2Default
  :: forall (f :: * -> * -> *) a b.
     Read2 f =>
     ReadPrec a
     -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adwHO :: * -> * -> *))
                 (@ a_adwHP)
                 (@ b_adwHQ)
                 ($dRead2_adwHS [Occ=Once] :: Read2 f_adwHO)
                 (rp1_adwdl [Occ=Once] :: ReadPrec a_adwHP)
                 (rl1_adwdm [Occ=Once] :: ReadPrec [a_adwHP])
                 (rp2_adwdn [Occ=Once] :: ReadPrec b_adwHQ)
                 (rl2_adwdo [Occ=Once] :: ReadPrec [b_adwHQ]) ->
                 list
                   @ (f_adwHO a_adwHP b_adwHQ)
                   (liftReadPrec2
                      @ f_adwHO
                      $dRead2_adwHS
                      @ a_adwHP
                      @ b_adwHQ
                      rp1_adwdl
                      rl1_adwdm
                      rp2_adwdn
                      rl2_adwdo)}]
liftReadListPrec2Default
  = \ (@ (f_adwHO :: * -> * -> *))
      (@ a_adwHP)
      (@ b_adwHQ)
      ($dRead2_adwHS :: Read2 f_adwHO)
      (rp1_adwdl :: ReadPrec a_adwHP)
      (rl1_adwdm :: ReadPrec [a_adwHP])
      (rp2_adwdn :: ReadPrec b_adwHQ)
      (rl2_adwdo :: ReadPrec [b_adwHQ]) ->
      list
        @ (f_adwHO a_adwHP b_adwHQ)
        (liftReadPrec2
           @ f_adwHO
           $dRead2_adwHS
           @ a_adwHP
           @ b_adwHQ
           rp1_adwdl
           rl1_adwdm
           rp2_adwdn
           rl2_adwdo)

-- RHS size: {terms: 14, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)1
  :: forall a.
     Read a =>
     forall a1.
     ReadPrec a1
     -> ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a, a1) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwUw)
                 ($dRead_adwUx :: Read a_adwUw)
                 (@ a1_adwUS)
                 (eta_B4 [Occ=Once] :: ReadPrec a1_adwUS)
                 (eta1_B3 [Occ=Once] :: ReadPrec [a1_adwUS])
                 (eta2_B2 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_i815e)
                 (eta3_B1 [Occ=Once]
                    :: (a_adwUw, a1_adwUS)
                       -> Text.ParserCombinators.ReadP.P b_i815e) ->
                 Data.Functor.Classes.$fRead1(,)2
                   @ a_adwUw
                   @ a1_adwUS
                   (readPrec @ a_adwUw $dRead_adwUx)
                   (readListPrec @ a_adwUw $dRead_adwUx)
                   eta_B4
                   eta1_B3
                   eta2_B2
                   @ b_i815e
                   eta3_B1}]
Data.Functor.Classes.$fRead1(,)1
  = \ (@ a_adwUw)
      ($dRead_adwUx :: Read a_adwUw)
      (@ a1_adwUS)
      (eta_B4 :: ReadPrec a1_adwUS)
      _ [Occ=Dead]
      (eta2_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815e)
      (eta3_B1
         :: (a_adwUw, a1_adwUS)
            -> Text.ParserCombinators.ReadP.P b_i815e) ->
      Data.Functor.Classes.$w$cliftReadPrec2
        @ a_adwUw
        @ a1_adwUS
        (readPrec @ a_adwUw $dRead_adwUx)
        eta_B4
        eta2_B2
        @ b_i815e
        eta3_B1

-- RHS size: {terms: 13, types: 23, coercions: 9, joins: 0/0}
Data.Functor.Classes.$w$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1. (Int -> ReadS a1) -> Int -> ReadS (a, a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 110 60}]
Data.Functor.Classes.$w$cliftReadsPrec
  = \ (@ a_sdy0L)
      (w_sdy0M :: Read a_sdy0L)
      (@ a1_sdy0N)
      (w1_sdy0O :: Int -> ReadS a1_sdy0N)
      (w2_sdy0Q :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (a_sdy0L, a1_sdy0N)
        (Data.Functor.Classes.$w$cliftReadPrec2
           @ a_sdy0L
           @ a1_sdy0N
           (readPrec @ a_sdy0L w_sdy0M)
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
               @ a1_sdy0N w1_sdy0O)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <a1_sdy0N>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <a1_sdy0N>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (a1_sdy0N -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec a1_sdy0N :: *)))
           w2_sdy0Q
           @ (a_sdy0L, a1_sdy0N)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (a_sdy0L, a1_sdy0N)))

-- RHS size: {terms: 10, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1. (Int -> ReadS a1) -> ReadS [a1] -> Int -> ReadS (a, a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy0L)
                 (w_sdy0M [Occ=Once] :: Read a_sdy0L)
                 (@ a1_sdy0N)
                 (w1_sdy0O [Occ=Once] :: Int -> ReadS a1_sdy0N)
                 _ [Occ=Dead]
                 (w3_sdy0Q [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec
                   @ a_sdy0L w_sdy0M @ a1_sdy0N w1_sdy0O w3_sdy0Q}]
Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec
  = \ (@ a_sdy0L)
      (w_sdy0M :: Read a_sdy0L)
      (@ a1_sdy0N)
      (w1_sdy0O :: Int -> ReadS a1_sdy0N)
      _ [Occ=Dead]
      (w3_sdy0Q :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec
        @ a_sdy0L w_sdy0M @ a1_sdy0N w1_sdy0O w3_sdy0Q

-- RHS size: {terms: 10, types: 16, coercions: 13, joins: 0/0}
Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
  :: forall a.
     Read a =>
     forall a1. ReadPrec a1 -> ReadPrec [a1] -> ReadPrec [(a, a1)]
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XdwZz)
                 ($dRead_XdwZB [Occ=Once] :: Read a_XdwZz)
                 (@ a1_adwV6)
                 (rp_adwdf [Occ=Once] :: ReadPrec a1_adwV6)
                 (rl_adwdg [Occ=Once] :: ReadPrec [a1_adwV6]) ->
                 list
                   @ (a_XdwZz, a1_adwV6)
                   ((Data.Functor.Classes.$fRead1(,)1
                       @ a_XdwZz $dRead_XdwZB @ a1_adwV6 rp_adwdf rl_adwdg)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <(a_XdwZz,
                                             a1_adwV6)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <(a_XdwZz, a1_adwV6)>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   ((a_XdwZz, a1_adwV6) -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (a_XdwZz, a1_adwV6) :: *)))}]
Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
  = \ (@ a_XdwZz)
      ($dRead_XdwZB :: Read a_XdwZz)
      (@ a1_adwV6)
      (rp_adwdf :: ReadPrec a1_adwV6)
      (rl_adwdg :: ReadPrec [a1_adwV6]) ->
      list
        @ (a_XdwZz, a1_adwV6)
        ((Data.Functor.Classes.$fRead1(,)1
            @ a_XdwZz $dRead_XdwZB @ a1_adwV6 rp_adwdf rl_adwdg)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <(a_XdwZz,
                                  a1_adwV6)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <(a_XdwZz, a1_adwV6)>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        ((a_XdwZz, a1_adwV6) -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (a_XdwZz, a1_adwV6) :: *)))

Rec {
-- RHS size: {terms: 17, types: 20, coercions: 23, joins: 0/0}
Data.Functor.Classes.$fRead1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_adwb2) (v_B1 :: Read a_adwb2) ->
       Data.Functor.Classes.C:Read1 TYPE: (,) a_adwb2
                                    Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec @ a_adwb2 v_B1
                                    Data.Functor.Classes.$fRead1(,)_$cliftReadList @ a_adwb2 v_B1
                                    (Data.Functor.Classes.$fRead1(,)1 @ a_adwb2 v_B1)
                                    `cast` (forall (a1 :: <*>_N).
                                            <ReadPrec a1>_R
                                            ->_R <ReadPrec [a1]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <(a_adwb2,
                                                                  a1)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                      <(a_adwb2,
                                                                                        a1)>_R)
                                            :: (forall a1.
                                                ReadPrec a1
                                                -> ReadPrec [a1]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   ((a_adwb2, a1)
                                                    -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a1.
                                                    ReadPrec a1
                                                    -> ReadPrec [a1]
                                                    -> ReadPrec (a_adwb2, a1) :: *))
                                    Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
                                      @ a_adwb2 v_B1]
Data.Functor.Classes.$fRead1(,)
  = \ (@ a_XdwZy) ($dRead_XdwZA :: Read a_XdwZy) ->
      Data.Functor.Classes.C:Read1
        @ ((,) a_XdwZy)
        (\ (@ a1_sdy0N)
           (w_sdy0O :: Int -> ReadS a1_sdy0N)
           _ [Occ=Dead]
           (w2_sdy0Q :: Int) ->
           Data.Functor.Classes.$w$cliftReadsPrec
             @ a_XdwZy $dRead_XdwZA @ a1_sdy0N w_sdy0O w2_sdy0Q)
        (Data.Functor.Classes.$fRead1(,)_$cliftReadList
           @ a_XdwZy $dRead_XdwZA)
        ((Data.Functor.Classes.$fRead1(,)1 @ a_XdwZy $dRead_XdwZA)
         `cast` (forall (a1 :: <*>_N).
                 <ReadPrec a1>_R
                 ->_R <ReadPrec [a1]>_R
                 ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                     <(a_XdwZy,
                                       a1)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <(a_XdwZy, a1)>_R)
                 :: (forall a1.
                     ReadPrec a1
                     -> ReadPrec [a1]
                     -> Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        ((a_XdwZy, a1) -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (forall a1.
                         ReadPrec a1 -> ReadPrec [a1] -> ReadPrec (a_XdwZy, a1) :: *)))
        (Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
           @ a_XdwZy $dRead_XdwZA)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1(,)_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     Read a =>
     forall a1. (Int -> ReadS a1) -> ReadS [a1] -> ReadS [(a, a1)]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []]
Data.Functor.Classes.$fRead1(,)_$cliftReadList
  = \ (@ a_XdwZA) ($dRead_XdwZC :: Read a_XdwZA) (@ a1_adwUJ) ->
      liftReadListDefault
        @ ((,) a_XdwZA)
        @ a1_adwUJ
        (Data.Functor.Classes.$fRead1(,) @ a_XdwZA $dRead_XdwZC)
end Rec }

-- RHS size: {terms: 16, types: 23, coercions: 0, joins: 0/0}
showsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Show2 f, Show a, Show b) =>
     Int -> f a b -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))L),1*U(1*C1(C1(C1(C1(U)))),A)><L,U(1*U,A,1*U)><L,U(1*U,A,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 60] 140 0}]
showsPrec2
  = \ (@ (f_adwHu :: * -> * -> *))
      (@ a_adwHv)
      (@ b_adwHw)
      ($dShow2_adwHy :: Show2 f_adwHu)
      ($dShow_adwHz :: Show a_adwHv)
      ($dShow1_adwHA :: Show b_adwHw) ->
      liftShowsPrec2
        @ f_adwHu
        $dShow2_adwHy
        @ a_adwHv
        @ b_adwHw
        (showsPrec @ a_adwHv $dShow_adwHz)
        (showList @ a_adwHv $dShow_adwHz)
        (showsPrec @ b_adwHw $dShow1_adwHA)
        (showList @ b_adwHw $dShow1_adwHA)

-- RHS size: {terms: 31, types: 45, coercions: 0, joins: 0/1}
Data.Functor.Classes.$wreadsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (String -> ReadS a) -> GHC.Prim.Int# -> String -> [(a, String)]
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 232 0}]
Data.Functor.Classes.$wreadsData
  = \ (@ a_sdy11)
      (w_sdy12 :: String -> ReadS a_sdy11)
      (ww_sdy17 :: GHC.Prim.Int#)
      (w1_sdy14 :: String) ->
      letrec {
        go_sdybA [Occ=LoopBreaker]
          :: [(String, String)] -> [(a_sdy11, String)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_sdybA
          = \ (ds_i7Jck :: [(String, String)]) ->
              case ds_i7Jck of {
                [] -> GHC.Types.[] @ (a_sdy11, String);
                : y_i7Jcp ys_i7Jcq ->
                  case y_i7Jcp of { (kw_adwds, s_adwdt) ->
                  ++
                    @ (a_sdy11, String) (w_sdy12 kw_adwds s_adwdt) (go_sdybA ys_i7Jcq)
                  }
              }; } in
      readParen
        @ a_sdy11
        (GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># ww_sdy17 10#))
        (\ (r_adwdr :: String) ->
           go_sdybA
             (Text.ParserCombinators.ReadP.run @ String GHC.Read.lex1 r_adwdr))
        w1_sdy14

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
readsData [InlPrag=NOUSERINLINE[0]]
  :: forall a. (String -> ReadS a) -> Int -> ReadS a
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy11)
                 (w_sdy12 [Occ=Once] :: String -> ReadS a_sdy11)
                 (w1_sdy13 [Occ=Once!] :: Int)
                 (w2_sdy14 [Occ=Once] :: String) ->
                 case w1_sdy13 of { GHC.Types.I# ww1_sdy17 [Occ=Once] ->
                 Data.Functor.Classes.$wreadsData
                   @ a_sdy11 w_sdy12 ww1_sdy17 w2_sdy14
                 }}]
readsData
  = \ (@ a_sdy11)
      (w_sdy12 :: String -> ReadS a_sdy11)
      (w1_sdy13 :: Int)
      (w2_sdy14 :: String) ->
      case w1_sdy13 of { GHC.Types.I# ww1_sdy17 ->
      Data.Functor.Classes.$wreadsData
        @ a_sdy11 w_sdy12 ww1_sdy17 w2_sdy14
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.readData2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.readData2 = GHC.Types.I# 10#

-- RHS size: {terms: 23, types: 19, coercions: 8, joins: 0/1}
Data.Functor.Classes.readData1
  :: forall a.
     ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 111 0}]
Data.Functor.Classes.readData1
  = \ (@ a_adwHc)
      (reader_adwdv :: ReadPrec a_adwHc)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815e)
      (eta1_B1 :: a_adwHc -> Text.ParserCombinators.ReadP.P b_i815e) ->
      let {
        lvl3_sdxvn [Dmd=<L,C(U)>]
          :: Text.ParserCombinators.ReadP.ReadP a_adwHc
        [LclId]
        lvl3_sdxvn
          = (reader_adwdv
             `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_adwHc>_R
                     :: (ReadPrec a_adwHc :: *)
                        ~R# (Text.ParserCombinators.ReadPrec.Prec
                             -> Text.ParserCombinators.ReadP.ReadP a_adwHc :: *)))
              Data.Functor.Classes.readData2 } in
      GHC.Read.list3
        @ a_adwHc
        ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 10# of {
              __DEFAULT ->
                (Text.ParserCombinators.ReadP.$fAlternativeReadP4 @ a_adwHc)
                `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a_adwHc>_R)
                        :: (forall b.
                            (a_adwHc -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadP.ReadP a_adwHc :: *));
              1# -> lvl3_sdxvn
            }
            })
         `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <a_adwHc>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> Text.ParserCombinators.ReadP.ReadP a_adwHc :: *)
                    ~R# (ReadPrec a_adwHc :: *)))
        eta_B2
        @ b_i815e
        eta1_B1

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
readData :: forall a. ReadPrec a -> ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Classes.readData1
               `cast` (forall (a :: <*>_N).
                       <ReadPrec a>_R
                       ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <a>_R)
                       :: (forall a.
                           ReadPrec a
                           -> Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (a -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (forall a. ReadPrec a -> ReadPrec a :: *))}]
readData
  = Data.Functor.Classes.readData1
    `cast` (forall (a :: <*>_N).
            <ReadPrec a>_R
            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a>_R)
            :: (forall a.
                ReadPrec a
                -> Text.ParserCombinators.ReadPrec.Prec
                -> forall b.
                   (a -> Text.ParserCombinators.ReadP.P b)
                   -> Text.ParserCombinators.ReadP.P b :: *)
               ~R# (forall a. ReadPrec a -> ReadPrec a :: *))

-- RHS size: {terms: 35, types: 52, coercions: 0, joins: 0/1}
readsUnaryWith
  :: forall a t.
     (Int -> ReadS a) -> String -> (a -> t) -> String -> ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 60 0 0] 210 10}]
readsUnaryWith
  = \ (@ a_adwH5)
      (@ t_adwH6)
      (rp_adwdw :: Int -> ReadS a_adwH5)
      (name_adwdx :: String)
      (cons_adwdy :: a_adwH5 -> t_adwH6)
      (kw_adwdz :: String)
      (s_adwdA :: String) ->
      case GHC.Base.eqString kw_adwdz name_adwdx of {
        False -> GHC.Types.[] @ (t_adwH6, String);
        True ->
          letrec {
            go_i7Jcj [Occ=LoopBreaker]
              :: [(a_adwH5, String)] -> [(t_adwH6, String)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i7Jcj
              = \ (ds_i7Jck :: [(a_adwH5, String)]) ->
                  case ds_i7Jck of {
                    [] -> GHC.Types.[] @ (t_adwH6, String);
                    : y_i7Jcp ys_i7Jcq ->
                      case y_i7Jcp of { (x_adwdB, t1_adwdC) ->
                      GHC.Types.:
                        @ (t_adwH6, String)
                        (cons_adwdy x_adwdB, t1_adwdC)
                        (go_i7Jcj ys_i7Jcq)
                      }
                  }; } in
          go_i7Jcj (rp_adwdw Data.Functor.Classes.$fRead1Const1 s_adwdA)
      }

-- RHS size: {terms: 24, types: 21, coercions: 4, joins: 0/0}
Data.Functor.Classes.$wreadUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     ReadPrec a
     -> String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> (# String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 60 20 60] 151 0}]
Data.Functor.Classes.$wreadUnaryWith
  = \ (@ a_sdy1n)
      (@ t_sdy1o)
      (w_sdy1p :: ReadPrec a_sdy1n)
      (w1_sdy1q :: String)
      (w2_sdy1r :: a_sdy1n -> t_sdy1o)
      (w3_sdy1s :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sdy1t)
      (w4_sdy1u :: t_sdy1o -> Text.ParserCombinators.ReadP.P b_sdy1t) ->
      Text.Read.Lex.$wexpect
        (Text.Read.Lex.Ident w1_sdy1q)
        @ b_sdy1t
        (\ _ [Occ=Dead, OS=OneShot] ->
           (((w_sdy1p
              `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdy1n>_R
                      :: (ReadPrec a_sdy1n :: *)
                         ~R# (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP a_sdy1n :: *)))
               (case w3_sdy1s of { GHC.Types.I# x_i88Yu ->
                GHC.Types.I# (GHC.Prim.+# x_i88Yu 1#)
                }))
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdy1n>_R
                    :: (Text.ParserCombinators.ReadP.ReadP a_sdy1n :: *)
                       ~R# (forall b.
                            (a_sdy1n -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)))
             @ b_sdy1t
             (\ (a2_i88WJ :: a_sdy1n) -> w4_sdy1u (w2_sdy1r a2_i88WJ)))

-- RHS size: {terms: 18, types: 27, coercions: 0, joins: 0/0}
Data.Functor.Classes.readUnaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     ReadPrec a
     -> String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy1n)
                 (@ t_sdy1o)
                 (w_sdy1p [Occ=Once] :: ReadPrec a_sdy1n)
                 (w1_sdy1q [Occ=Once] :: String)
                 (w2_sdy1r [Occ=Once] :: a_sdy1n -> t_sdy1o)
                 (w3_sdy1s [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_sdy1t)
                 (w4_sdy1u [Occ=Once]
                    :: t_sdy1o -> Text.ParserCombinators.ReadP.P b_sdy1t) ->
                 case Data.Functor.Classes.$wreadUnaryWith
                        @ a_sdy1n
                        @ t_sdy1o
                        w_sdy1p
                        w1_sdy1q
                        w2_sdy1r
                        w3_sdy1s
                        @ b_sdy1t
                        w4_sdy1u
                 of
                 { (# ww1_sdy4c [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_sdy1t ww1_sdy4c
                 }}]
Data.Functor.Classes.readUnaryWith1
  = \ (@ a_sdy1n)
      (@ t_sdy1o)
      (w_sdy1p :: ReadPrec a_sdy1n)
      (w1_sdy1q :: String)
      (w2_sdy1r :: a_sdy1n -> t_sdy1o)
      (w3_sdy1s :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sdy1t)
      (w4_sdy1u :: t_sdy1o -> Text.ParserCombinators.ReadP.P b_sdy1t) ->
      case Data.Functor.Classes.$wreadUnaryWith
             @ a_sdy1n
             @ t_sdy1o
             w_sdy1p
             w1_sdy1q
             w2_sdy1r
             w3_sdy1s
             @ b_sdy1t
             w4_sdy1u
      of
      { (# ww1_sdy4c #) ->
      Text.ParserCombinators.ReadP.Look @ b_sdy1t ww1_sdy4c
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
readUnaryWith
  :: forall a t. ReadPrec a -> String -> (a -> t) -> ReadPrec t
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Classes.readUnaryWith1
               `cast` (forall (a :: <*>_N) (t :: <*>_N).
                       <ReadPrec a>_R
                       ->_R <String>_R
                       ->_R <a -> t>_R
                       ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <t>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <t>_R)
                       :: (forall a t.
                           ReadPrec a
                           -> String
                           -> (a -> t)
                           -> Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (t -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (forall a t.
                               ReadPrec a -> String -> (a -> t) -> ReadPrec t :: *))}]
readUnaryWith
  = Data.Functor.Classes.readUnaryWith1
    `cast` (forall (a :: <*>_N) (t :: <*>_N).
            <ReadPrec a>_R
            ->_R <String>_R
            ->_R <a -> t>_R
            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <t>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <t>_R)
            :: (forall a t.
                ReadPrec a
                -> String
                -> (a -> t)
                -> Text.ParserCombinators.ReadPrec.Prec
                -> forall b.
                   (t -> Text.ParserCombinators.ReadP.P b)
                   -> Text.ParserCombinators.ReadP.P b :: *)
               ~R# (forall a t.
                    ReadPrec a -> String -> (a -> t) -> ReadPrec t :: *))

-- RHS size: {terms: 13, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const5
  :: forall a.
     Read a =>
     forall a1.
     ReadPrec a1
     -> ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Const a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwRr)
                 ($dRead_adwRs :: Read a_adwRr)
                 (@ a1_adwRN)
                 (eta_B2 [Occ=Once] :: ReadPrec a1_adwRN)
                 (eta1_B1 [Occ=Once] :: ReadPrec [a1_adwRN])
                 (eta2_X3 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_i815E)
                 (eta3_X4 [Occ=Once]
                    :: Const a_adwRr a1_adwRN
                       -> Text.ParserCombinators.ReadP.P b_i815E) ->
                 Data.Functor.Classes.$fRead1Const6
                   @ a_adwRr
                   @ a1_adwRN
                   (readPrec @ a_adwRr $dRead_adwRs)
                   (readListPrec @ a_adwRr $dRead_adwRs)
                   eta_B2
                   eta1_B1
                   eta2_X3
                   @ b_i815E
                   eta3_X4}]
Data.Functor.Classes.$fRead1Const5
  = \ (@ a_adwRr)
      ($dRead_adwRs :: Read a_adwRr)
      (@ a1_adwRN)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta2_X3 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815E)
      (eta3_X4
         :: Const a_adwRr a1_adwRN
            -> Text.ParserCombinators.ReadP.P b_i815E) ->
      Data.Functor.Classes.$w$cliftReadPrec1
        @ a_adwRr
        @ a1_adwRN
        (readPrec @ a_adwRr $dRead_adwRs)
        eta2_X3
        @ b_i815E
        eta3_X4

-- RHS size: {terms: 10, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftReadsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Read a => forall a1. Int -> ReadS (Const a a1)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 80 60}]
Data.Functor.Classes.$w$cliftReadsPrec1
  = \ (@ a_sdy1z)
      (w_sdy1A :: Read a_sdy1z)
      (@ a1_sdy1B)
      (w1_sdy1E :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Const a_sdy1z a1_sdy1B)
        (Data.Functor.Classes.$w$cliftReadPrec1
           @ a_sdy1z
           @ a1_sdy1B
           (readPrec @ a_sdy1z w_sdy1A)
           w1_sdy1E
           @ (Const a_sdy1z a1_sdy1B)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Const a_sdy1z a1_sdy1B)))

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1.
     (Int -> ReadS a1) -> ReadS [a1] -> Int -> ReadS (Const a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy1z)
                 (w_sdy1A [Occ=Once] :: Read a_sdy1z)
                 (@ a1_sdy1B)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_sdy1E [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec1
                   @ a_sdy1z w_sdy1A @ a1_sdy1B w3_sdy1E}]
Data.Functor.Classes.$fRead1Const_$cliftReadsPrec
  = \ (@ a_sdy1z)
      (w_sdy1A :: Read a_sdy1z)
      (@ a1_sdy1B)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_sdy1E :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec1
        @ a_sdy1z w_sdy1A @ a1_sdy1B w3_sdy1E

-- RHS size: {terms: 14, types: 27, coercions: 17, joins: 0/1}
Data.Functor.Classes.$w$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Read a => forall a1. ReadPrec [Const a a1]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C(C1(U)),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 110 0}]
Data.Functor.Classes.$w$cliftReadListPrec
  = \ (@ a_sdy1G) (w_sdy1H :: Read a_sdy1G) (@ a1_sdy1I) ->
      list
        @ (Const a_sdy1G a1_sdy1I)
        (let {
           w1_sdxVm [Dmd=<L,C(C1(U))>] :: ReadPrec a_sdy1G
           [LclId]
           w1_sdxVm = readPrec @ a_sdy1G w_sdy1H } in
         (\ (w2_sdxVq [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_sdxVr)
            (w3_sdxVs
               :: Const a_sdy1G a1_sdy1I
                  -> Text.ParserCombinators.ReadP.P b_sdxVr) ->
            Data.Functor.Classes.$w$cliftReadPrec1
              @ a_sdy1G @ a1_sdy1I w1_sdxVm w2_sdxVq @ b_sdxVr w3_sdxVs)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Const
                                   a_sdy1G
                                   a1_sdy1I>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <Const a_sdy1G a1_sdy1I>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Const a_sdy1G a1_sdy1I -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Const a_sdy1G a1_sdy1I) :: *)))

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1. ReadPrec a1 -> ReadPrec [a1] -> ReadPrec [Const a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy1G)
                 (w_sdy1H [Occ=Once] :: Read a_sdy1G)
                 (@ a1_sdy1I)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 Data.Functor.Classes.$w$cliftReadListPrec
                   @ a_sdy1G w_sdy1H @ a1_sdy1I}]
Data.Functor.Classes.$fRead1Const_$cliftReadListPrec
  = \ (@ a_sdy1G)
      (w_sdy1H :: Read a_sdy1G)
      (@ a1_sdy1I)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Functor.Classes.$w$cliftReadListPrec
        @ a_sdy1G w_sdy1H @ a1_sdy1I

Rec {
-- RHS size: {terms: 22, types: 42, coercions: 27, joins: 0/1}
Data.Functor.Classes.$fRead1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read1 (Const a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_adwag) (v_X8A :: Read a_adwag) ->
       Data.Functor.Classes.C:Read1 TYPE: Const a_adwag
                                    Data.Functor.Classes.$fRead1Const_$cliftReadsPrec
                                      @ a_adwag v_X8A
                                    Data.Functor.Classes.$fRead1Const_$cliftReadList @ a_adwag v_X8A
                                    (Data.Functor.Classes.$fRead1Const5 @ a_adwag v_X8A)
                                    `cast` (forall (a1 :: <*>_N).
                                            <ReadPrec a1>_R
                                            ->_R <ReadPrec [a1]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Const
                                                                   a_adwag
                                                                   a1>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                      <Const
                                                                                         a_adwag
                                                                                         a1>_R)
                                            :: (forall a1.
                                                ReadPrec a1
                                                -> ReadPrec [a1]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Const a_adwag a1
                                                    -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a1.
                                                    ReadPrec a1
                                                    -> ReadPrec [a1]
                                                    -> ReadPrec (Const a_adwag a1) :: *))
                                    Data.Functor.Classes.$fRead1Const_$cliftReadListPrec
                                      @ a_adwag v_X8A]
Data.Functor.Classes.$fRead1Const
  = \ (@ a_XdwZZ) ($dRead_Xdx01 :: Read a_XdwZZ) ->
      let {
        lvl3_sdybB :: forall a1. ReadPrec [Const a_XdwZZ a1]
        [LclId]
        lvl3_sdybB
          = \ (@ a1_sdy1I) ->
              Data.Functor.Classes.$w$cliftReadListPrec
                @ a_XdwZZ $dRead_Xdx01 @ a1_sdy1I } in
      Data.Functor.Classes.C:Read1
        @ (Const a_XdwZZ)
        (\ (@ a1_sdy1B) _ [Occ=Dead] _ [Occ=Dead] (w2_sdy1E :: Int) ->
           Data.Functor.Classes.$w$cliftReadsPrec1
             @ a_XdwZZ $dRead_Xdx01 @ a1_sdy1B w2_sdy1E)
        (Data.Functor.Classes.$fRead1Const_$cliftReadList
           @ a_XdwZZ $dRead_Xdx01)
        ((Data.Functor.Classes.$fRead1Const5 @ a_XdwZZ $dRead_Xdx01)
         `cast` (forall (a1 :: <*>_N).
                 <ReadPrec a1>_R
                 ->_R <ReadPrec [a1]>_R
                 ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                     <Const
                                        a_XdwZZ
                                        a1>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Const a_XdwZZ a1>_R)
                 :: (forall a1.
                     ReadPrec a1
                     -> ReadPrec [a1]
                     -> Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Const a_XdwZZ a1 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (forall a1.
                         ReadPrec a1 -> ReadPrec [a1] -> ReadPrec (Const a_XdwZZ a1) :: *)))
        (\ (@ a1_sdy1I) _ [Occ=Dead] _ [Occ=Dead] -> lvl3_sdybB @ a1_sdy1I)

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Const_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     Read a =>
     forall a1. (Int -> ReadS a1) -> ReadS [a1] -> ReadS [Const a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []]
Data.Functor.Classes.$fRead1Const_$cliftReadList
  = \ (@ a_Xdx00) ($dRead_Xdx02 :: Read a_Xdx00) (@ a1_adwRE) ->
      liftReadListDefault
        @ (Const a_Xdx00)
        @ a1_adwRE
        (Data.Functor.Classes.$fRead1Const @ a_Xdx00 $dRead_Xdx02)
end Rec }

-- RHS size: {terms: 14, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either7
  :: forall a.
     Read a =>
     forall a1.
     ReadPrec a1
     -> ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Either a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwSV)
                 ($dRead_adwSW :: Read a_adwSV)
                 (@ a1_adwTh)
                 (eta_X8F [Occ=Once] :: ReadPrec a1_adwTh)
                 (eta1_Xhj [Occ=Once] :: ReadPrec [a1_adwTh])
                 (eta2_X3 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_i815e)
                 (eta3_X4 [Occ=Once]
                    :: Either a_adwSV a1_adwTh
                       -> Text.ParserCombinators.ReadP.P b_i815e) ->
                 Data.Functor.Classes.$fRead1Either8
                   @ a_adwSV
                   @ a1_adwTh
                   (readPrec @ a_adwSV $dRead_adwSW)
                   (readListPrec @ a_adwSV $dRead_adwSW)
                   eta_X8F
                   eta1_Xhj
                   eta2_X3
                   @ b_i815e
                   eta3_X4}]
Data.Functor.Classes.$fRead1Either7
  = \ (@ a_adwSV)
      ($dRead_adwSW :: Read a_adwSV)
      (@ a1_adwTh)
      (eta_X8F :: ReadPrec a1_adwTh)
      _ [Occ=Dead]
      (eta2_X3 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815e)
      (eta3_X4
         :: Either a_adwSV a1_adwTh
            -> Text.ParserCombinators.ReadP.P b_i815e) ->
      Data.Functor.Classes.$w$cliftReadPrec3
        @ a_adwSV
        @ a1_adwTh
        (readPrec @ a_adwSV $dRead_adwSW)
        eta_X8F
        eta2_X3
        @ b_i815e
        eta3_X4

-- RHS size: {terms: 13, types: 23, coercions: 9, joins: 0/0}
Data.Functor.Classes.$w$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1. (Int -> ReadS a1) -> Int -> ReadS (Either a a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 110 60}]
Data.Functor.Classes.$w$cliftReadsPrec2
  = \ (@ a_sdy1O)
      (w_sdy1P :: Read a_sdy1O)
      (@ a1_sdy1Q)
      (w1_sdy1R :: Int -> ReadS a1_sdy1Q)
      (w2_sdy1T :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Either a_sdy1O a1_sdy1Q)
        (Data.Functor.Classes.$w$cliftReadPrec3
           @ a_sdy1O
           @ a1_sdy1Q
           (readPrec @ a_sdy1O w_sdy1P)
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
               @ a1_sdy1Q w1_sdy1R)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <a1_sdy1Q>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <a1_sdy1Q>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (a1_sdy1Q -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec a1_sdy1Q :: *)))
           w2_sdy1T
           @ (Either a_sdy1O a1_sdy1Q)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Either a_sdy1O a1_sdy1Q)))

-- RHS size: {terms: 10, types: 15, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1.
     (Int -> ReadS a1) -> ReadS [a1] -> Int -> ReadS (Either a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy1O)
                 (w_sdy1P [Occ=Once] :: Read a_sdy1O)
                 (@ a1_sdy1Q)
                 (w1_sdy1R [Occ=Once] :: Int -> ReadS a1_sdy1Q)
                 _ [Occ=Dead]
                 (w3_sdy1T [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec2
                   @ a_sdy1O w_sdy1P @ a1_sdy1Q w1_sdy1R w3_sdy1T}]
Data.Functor.Classes.$fRead1Either_$cliftReadsPrec
  = \ (@ a_sdy1O)
      (w_sdy1P :: Read a_sdy1O)
      (@ a1_sdy1Q)
      (w1_sdy1R :: Int -> ReadS a1_sdy1Q)
      _ [Occ=Dead]
      (w3_sdy1T :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec2
        @ a_sdy1O w_sdy1P @ a1_sdy1Q w1_sdy1R w3_sdy1T

-- RHS size: {terms: 16, types: 25, coercions: 13, joins: 0/1}
Data.Functor.Classes.$w$cliftReadListPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1. ReadPrec a1 -> ReadPrec [Either a a1]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 120 0}]
Data.Functor.Classes.$w$cliftReadListPrec1
  = \ (@ a_sdy1V)
      (w_sdy1W :: Read a_sdy1V)
      (@ a1_sdy1X)
      (w1_sdy1Y :: ReadPrec a1_sdy1X) ->
      list
        @ (Either a_sdy1V a1_sdy1X)
        (let {
           w2_sdxVE [Dmd=<L,C(C1(U))>] :: ReadPrec a_sdy1V
           [LclId]
           w2_sdxVE = readPrec @ a_sdy1V w_sdy1W } in
         (\ (w3_sdxVI [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_sdxVJ)
            (w4_sdxVK
               :: Either a_sdy1V a1_sdy1X
                  -> Text.ParserCombinators.ReadP.P b_sdxVJ) ->
            Data.Functor.Classes.$w$cliftReadPrec3
              @ a_sdy1V @ a1_sdy1X w2_sdxVE w1_sdy1Y w3_sdxVI @ b_sdxVJ w4_sdxVK)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Either
                                   a_sdy1V
                                   a1_sdy1X>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <Either a_sdy1V a1_sdy1X>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_sdy1V a1_sdy1X -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Either a_sdy1V a1_sdy1X) :: *)))

-- RHS size: {terms: 8, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Read a =>
     forall a1. ReadPrec a1 -> ReadPrec [a1] -> ReadPrec [Either a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy1V)
                 (w_sdy1W [Occ=Once] :: Read a_sdy1V)
                 (@ a1_sdy1X)
                 (w1_sdy1Y [Occ=Once] :: ReadPrec a1_sdy1X)
                 _ [Occ=Dead] ->
                 Data.Functor.Classes.$w$cliftReadListPrec1
                   @ a_sdy1V w_sdy1W @ a1_sdy1X w1_sdy1Y}]
Data.Functor.Classes.$fRead1Either_$cliftReadListPrec
  = \ (@ a_sdy1V)
      (w_sdy1W :: Read a_sdy1V)
      (@ a1_sdy1X)
      (w1_sdy1Y :: ReadPrec a1_sdy1X)
      _ [Occ=Dead] ->
      Data.Functor.Classes.$w$cliftReadListPrec1
        @ a_sdy1V w_sdy1W @ a1_sdy1X w1_sdy1Y

Rec {
-- RHS size: {terms: 21, types: 28, coercions: 23, joins: 0/0}
Data.Functor.Classes.$fRead1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read1 (Either a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_adwaE) (v_X8F :: Read a_adwaE) ->
       Data.Functor.Classes.C:Read1 TYPE: Either a_adwaE
                                    Data.Functor.Classes.$fRead1Either_$cliftReadsPrec
                                      @ a_adwaE v_X8F
                                    Data.Functor.Classes.$fRead1Either_$cliftReadList
                                      @ a_adwaE v_X8F
                                    (Data.Functor.Classes.$fRead1Either7 @ a_adwaE v_X8F)
                                    `cast` (forall (a1 :: <*>_N).
                                            <ReadPrec a1>_R
                                            ->_R <ReadPrec [a1]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Either
                                                                   a_adwaE
                                                                   a1>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                      <Either
                                                                                         a_adwaE
                                                                                         a1>_R)
                                            :: (forall a1.
                                                ReadPrec a1
                                                -> ReadPrec [a1]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Either a_adwaE a1
                                                    -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a1.
                                                    ReadPrec a1
                                                    -> ReadPrec [a1]
                                                    -> ReadPrec (Either a_adwaE a1) :: *))
                                    Data.Functor.Classes.$fRead1Either_$cliftReadListPrec
                                      @ a_adwaE v_X8F]
Data.Functor.Classes.$fRead1Either
  = \ (@ a_XdwYA) ($dRead_XdwYC :: Read a_XdwYA) ->
      Data.Functor.Classes.C:Read1
        @ (Either a_XdwYA)
        (\ (@ a1_sdy1Q)
           (w_sdy1R :: Int -> ReadS a1_sdy1Q)
           _ [Occ=Dead]
           (w2_sdy1T :: Int) ->
           Data.Functor.Classes.$w$cliftReadsPrec2
             @ a_XdwYA $dRead_XdwYC @ a1_sdy1Q w_sdy1R w2_sdy1T)
        (Data.Functor.Classes.$fRead1Either_$cliftReadList
           @ a_XdwYA $dRead_XdwYC)
        ((Data.Functor.Classes.$fRead1Either7 @ a_XdwYA $dRead_XdwYC)
         `cast` (forall (a1 :: <*>_N).
                 <ReadPrec a1>_R
                 ->_R <ReadPrec [a1]>_R
                 ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                     <Either
                                        a_XdwYA
                                        a1>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Either a_XdwYA a1>_R)
                 :: (forall a1.
                     ReadPrec a1
                     -> ReadPrec [a1]
                     -> Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_XdwYA a1 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (forall a1.
                         ReadPrec a1
                         -> ReadPrec [a1] -> ReadPrec (Either a_XdwYA a1) :: *)))
        (\ (@ a1_sdy1X) (w_sdy1Y :: ReadPrec a1_sdy1X) _ [Occ=Dead] ->
           Data.Functor.Classes.$w$cliftReadListPrec1
             @ a_XdwYA $dRead_XdwYC @ a1_sdy1X w_sdy1Y)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Either_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     Read a =>
     forall a1. (Int -> ReadS a1) -> ReadS [a1] -> ReadS [Either a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []]
Data.Functor.Classes.$fRead1Either_$cliftReadList
  = \ (@ a_XdwYC) ($dRead_XdwYE :: Read a_XdwYC) (@ a1_adwT8) ->
      liftReadListDefault
        @ (Either a_XdwYC)
        @ a1_adwT8
        (Data.Functor.Classes.$fRead1Either @ a_XdwYC $dRead_XdwYE)
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$fRead1Identity4 = "Identity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Identity3
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Identity4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity2 :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Identity2
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Identity3

-- RHS size: {terms: 33, types: 38, coercions: 18, joins: 0/0}
Data.Functor.Classes.$w$cliftReadPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Identity a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 211 0}]
Data.Functor.Classes.$w$cliftReadPrec
  = \ (@ a_sdy23)
      (w_sdy24 :: ReadPrec a_sdy23)
      (w1_sdy26 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sdy27)
      (w2_sdy28
         :: Identity a_sdy23 -> Text.ParserCombinators.ReadP.P b_sdy27) ->
      GHC.Read.list3
        @ (Identity a_sdy23)
        ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_X81et)
            (eta_X6k
               :: Identity a_sdy23 -> Text.ParserCombinators.ReadP.P b1_X81et) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 10# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_X81et;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Functor.Classes.$fRead1Identity2
                       @ b1_X81et
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          (((w_sdy24
                             `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdy23>_R
                                     :: (ReadPrec a_sdy23 :: *)
                                        ~R# (Text.ParserCombinators.ReadPrec.Prec
                                             -> Text.ParserCombinators.ReadP.ReadP a_sdy23 :: *)))
                              Data.Functor.Classes.$fRead1Const1)
                           `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdy23>_R
                                   :: (Text.ParserCombinators.ReadP.ReadP a_sdy23 :: *)
                                      ~R# (forall b.
                                           (a_sdy23 -> Text.ParserCombinators.ReadP.P b)
                                           -> Text.ParserCombinators.ReadP.P b :: *)))
                            @ b1_X81et
                            (\ (a2_i88WJ :: a_sdy23) ->
                               eta_X6k
                                 (a2_i88WJ
                                  `cast` (Sym (Data.Functor.Identity.N:Identity[0] <a_sdy23>_R)
                                          :: (a_sdy23 :: *) ~R# (Identity a_sdy23 :: *)))))
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b1_X81et ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Identity
                                   a_sdy23>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Identity a_sdy23>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Identity a_sdy23 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Identity a_sdy23) :: *)))
        w1_sdy26
        @ b_sdy27
        w2_sdy28

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadPrec a
     -> ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Identity a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy23)
                 (w_sdy24 [Occ=Once] :: ReadPrec a_sdy23)
                 _ [Occ=Dead]
                 (w2_sdy26 [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_sdy27)
                 (w3_sdy28 [Occ=Once]
                    :: Identity a_sdy23 -> Text.ParserCombinators.ReadP.P b_sdy27) ->
                 Data.Functor.Classes.$w$cliftReadPrec
                   @ a_sdy23 w_sdy24 w2_sdy26 @ b_sdy27 w3_sdy28}]
Data.Functor.Classes.$fRead1Identity1
  = \ (@ a_sdy23)
      (w_sdy24 :: ReadPrec a_sdy23)
      _ [Occ=Dead]
      (w2_sdy26 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sdy27)
      (w3_sdy28
         :: Identity a_sdy23 -> Text.ParserCombinators.ReadP.P b_sdy27) ->
      Data.Functor.Classes.$w$cliftReadPrec
        @ a_sdy23 w_sdy24 w2_sdy26 @ b_sdy27 w3_sdy28

-- RHS size: {terms: 39, types: 50, coercions: 14, joins: 0/1}
Data.Functor.Classes.$w$cliftReadsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> Int -> ReadS (Identity a)
[GblId,
 Arity=2,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 281 60}]
Data.Functor.Classes.$w$cliftReadsPrec3
  = \ (@ a_sdy2a)
      (w_sdy2b :: Int -> ReadS a_sdy2a)
      (w1_sdy2d :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Identity a_sdy2a)
        (let {
           lvl3_sdybC [Dmd=<L,C(U)>] :: ReadS a_sdy2a
           [LclId]
           lvl3_sdybC = w_sdy2b Data.Functor.Classes.$fRead1Const1 } in
         GHC.Read.list3
           @ (Identity a_sdy2a)
           ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
               (@ b_X81et)
               (eta_X6k
                  :: Identity a_sdy2a -> Text.ParserCombinators.ReadP.P b_X81et) ->
               case c_i88VW of { GHC.Types.I# x_i88VZ ->
               case GHC.Prim.<=# x_i88VZ 10# of {
                 __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_X81et;
                 1# ->
                   case Text.Read.Lex.$wexpect
                          Data.Functor.Classes.$fRead1Identity2
                          @ b_X81et
                          (\ _ [Occ=Dead, OS=OneShot] ->
                             case Text.ParserCombinators.ReadP.$wreadS_to_P
                                    @ a_sdy2a
                                    lvl3_sdybC
                                    @ b_X81et
                                    (\ (a2_i88WJ :: a_sdy2a) ->
                                       eta_X6k
                                         (a2_i88WJ
                                          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                                           <a_sdy2a>_R)
                                                  :: (a_sdy2a :: *) ~R# (Identity a_sdy2a :: *))))
                             of
                             { (# ww1_idxi6 #) ->
                             Text.ParserCombinators.ReadP.Look @ b_X81et ww1_idxi6
                             })
                   of
                   { (# ww1_i88Ww #) ->
                   Text.ParserCombinators.ReadP.Look @ b_X81et ww1_i88Ww
                   }
               }
               })
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Identity
                                      a_sdy2a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Identity a_sdy2a>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Identity a_sdy2a -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec (Identity a_sdy2a) :: *)))
           w1_sdy2d
           @ (Identity a_sdy2a)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Identity a_sdy2a)))

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (Identity a)
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy2a)
                 (w_sdy2b [Occ=Once] :: Int -> ReadS a_sdy2a)
                 _ [Occ=Dead]
                 (w2_sdy2d [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec3
                   @ a_sdy2a w_sdy2b w2_sdy2d}]
Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
  = \ (@ a_sdy2a)
      (w_sdy2b :: Int -> ReadS a_sdy2a)
      _ [Occ=Dead]
      (w2_sdy2d :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec3 @ a_sdy2a w_sdy2b w2_sdy2d

-- RHS size: {terms: 11, types: 18, coercions: 11, joins: 0/0}
Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec
  :: forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [Identity a]
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx2c)
                 (rp_adwdf [Occ=Once] :: ReadPrec a_adx2c)
                 (rl_adwdg [Occ=Once] :: ReadPrec [a_adx2c]) ->
                 list
                   @ (Identity a_adx2c)
                   ((Data.Functor.Classes.$fRead1Identity1
                       @ a_adx2c rp_adwdf rl_adwdg)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Identity
                                              a_adx2c>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Identity a_adx2c>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Identity a_adx2c -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (Identity a_adx2c) :: *)))}]
Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec
  = \ (@ a_adx2c) (rp_adwdf :: ReadPrec a_adx2c) _ [Occ=Dead] ->
      list
        @ (Identity a_adx2c)
        ((\ (w_sdy26 [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_sdy27)
            (w1_sdy28
               :: Identity a_adx2c -> Text.ParserCombinators.ReadP.P b_sdy27) ->
            Data.Functor.Classes.$w$cliftReadPrec
              @ a_adx2c rp_adwdf w_sdy26 @ b_sdy27 w1_sdy28)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Identity
                                   a_adx2c>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Identity a_adx2c>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Identity a_adx2c -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Identity a_adx2c) :: *)))

-- RHS size: {terms: 16, types: 34, coercions: 28, joins: 0/1}
Data.Functor.Classes.$w$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> ReadS [Identity a]
[GblId,
 Arity=1,
 Str=<L,C(C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 60}]
Data.Functor.Classes.$w$cliftReadList
  = \ (@ a_sdy2f) (w_sdy2g :: Int -> ReadS a_sdy2f) ->
      Text.ParserCombinators.ReadP.run
        @ [Identity a_sdy2f]
        (((((list
               @ (Identity a_sdy2f)
               (let {
                  w1_sdy7a [Dmd=<L,C(C1(U))>]
                    :: Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b
                  [LclId, Arity=1, Unf=OtherCon []]
                  w1_sdy7a
                    = Text.ParserCombinators.ReadPrec.readS_to_Prec1
                        @ a_sdy2f w_sdy2g } in
                (\ (w2_sdy26 [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
                   (@ b_sdy27)
                   (w3_sdy28
                      :: Identity a_sdy2f -> Text.ParserCombinators.ReadP.P b_sdy27) ->
                   Data.Functor.Classes.$w$cliftReadPrec
                     @ a_sdy2f
                     (w1_sdy7a
                      `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                             <a_sdy2f>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <a_sdy2f>_R)
                              :: (Text.ParserCombinators.ReadPrec.Prec
                                  -> forall b.
                                     (a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)
                                 ~R# (ReadPrec a_sdy2f :: *)))
                     w2_sdy26
                     @ b_sdy27
                     w3_sdy28)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Identity
                                          a_sdy2f>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Identity a_sdy2f>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Identity a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec (Identity a_sdy2f) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Identity a_sdy2f]>_R
                    :: (ReadPrec [Identity a_sdy2f] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Identity a_sdy2f] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Identity a_sdy2f]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Identity a_sdy2f] :: *)
                     ~R# (forall b.
                          ([Identity a_sdy2f] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Identity a_sdy2f]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Identity a_sdy2f]))

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Identity_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [Identity a]
[GblId,
 Arity=2,
 Str=<L,C(C(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy2f)
                 (w_sdy2g [Occ=Once] :: Int -> ReadS a_sdy2f)
                 _ [Occ=Dead] ->
                 Data.Functor.Classes.$w$cliftReadList @ a_sdy2f w_sdy2g}]
Data.Functor.Classes.$fRead1Identity_$cliftReadList
  = \ (@ a_sdy2f) (w_sdy2g :: Int -> ReadS a_sdy2f) _ [Occ=Dead] ->
      Data.Functor.Classes.$w$cliftReadList @ a_sdy2f w_sdy2g

-- RHS size: {terms: 5, types: 1, coercions: 21, joins: 0/0}
Data.Functor.Classes.$fRead1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Read1 Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read1 TYPE: Identity
                                    Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
                                    Data.Functor.Classes.$fRead1Identity_$cliftReadList
                                    Data.Functor.Classes.$fRead1Identity1
                                    `cast` (forall (a :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Identity
                                                                   a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                     <Identity a>_R)
                                            :: (forall a.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Identity a -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a.
                                                    ReadPrec a
                                                    -> ReadPrec [a] -> ReadPrec (Identity a) :: *))
                                    Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec]
Data.Functor.Classes.$fRead1Identity
  = Data.Functor.Classes.C:Read1
      @ Identity
      Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
      Data.Functor.Classes.$fRead1Identity_$cliftReadList
      (Data.Functor.Classes.$fRead1Identity1
       `cast` (forall (a :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Identity
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Identity a>_R)
               :: (forall a.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Identity a -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a.
                       ReadPrec a -> ReadPrec [a] -> ReadPrec (Identity a) :: *)))
      Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe7 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$fRead1Maybe7 = "Nothing"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Maybe6
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe7

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe_lexeme :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Maybe_lexeme
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Maybe6

-- RHS size: {terms: 13, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe5
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,1*C1(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx47)
                 _ [Occ=Dead]
                 (@ b_i815E)
                 (eta1_X8Y [Occ=Once!]
                    :: Maybe a_adx47 -> Text.ParserCombinators.ReadP.P b_i815E) ->
                 case Text.Read.Lex.$wexpect
                        Data.Functor.Classes.$fRead1Maybe_lexeme
                        @ b_i815E
                        (\ _ [Occ=Dead, OS=OneShot] ->
                           eta1_X8Y (GHC.Base.Nothing @ a_adx47))
                 of
                 { (# ww1_i88Ww [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                 }}]
Data.Functor.Classes.$fRead1Maybe5
  = \ (@ a_adx47)
      _ [Occ=Dead]
      (@ b_i815E)
      (eta1_X8Y
         :: Maybe a_adx47 -> Text.ParserCombinators.ReadP.P b_i815E) ->
      case Text.Read.Lex.$wexpect
             Data.Functor.Classes.$fRead1Maybe_lexeme
             @ b_i815E
             (\ _ [Occ=Dead, OS=OneShot] ->
                eta1_X8Y (GHC.Base.Nothing @ a_adx47))
      of
      { (# ww1_i88Ww #) ->
      Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Maybe4 = "Just"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$fRead1Maybe3
  = GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe2 :: Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$fRead1Maybe2
  = Text.Read.Lex.Ident Data.Functor.Classes.$fRead1Maybe3

-- RHS size: {terms: 39, types: 44, coercions: 26, joins: 0/0}
Data.Functor.Classes.$w$cliftReadPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 291 0}]
Data.Functor.Classes.$w$cliftReadPrec4
  = \ (@ a_sdy2j)
      (w_sdy2k :: ReadPrec a_sdy2j)
      (w1_sdy2m :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sdy2n)
      (w2_sdy2o
         :: Maybe a_sdy2j -> Text.ParserCombinators.ReadP.P b_sdy2n) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_sdy2n
        (GHC.Read.list3
           @ (Maybe a_sdy2j)
           ((Data.Functor.Classes.$fRead1Maybe5 @ a_sdy2j)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Maybe
                                      a_sdy2j>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Maybe a_sdy2j>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Maybe a_sdy2j -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec (Maybe a_sdy2j) :: *)))
           w1_sdy2m
           @ b_sdy2n
           w2_sdy2o)
        (GHC.Read.list3
           @ (Maybe a_sdy2j)
           ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
               (@ b1_X81c7)
               (eta_X6v
                  :: Maybe a_sdy2j -> Text.ParserCombinators.ReadP.P b1_X81c7) ->
               case c_i88VW of { GHC.Types.I# x_i88VZ ->
               case GHC.Prim.<=# x_i88VZ 10# of {
                 __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_X81c7;
                 1# ->
                   case Text.Read.Lex.$wexpect
                          Data.Functor.Classes.$fRead1Maybe2
                          @ b1_X81c7
                          (\ _ [Occ=Dead, OS=OneShot] ->
                             (((w_sdy2k
                                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdy2j>_R
                                        :: (ReadPrec a_sdy2j :: *)
                                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                -> Text.ParserCombinators.ReadP.ReadP
                                                     a_sdy2j :: *)))
                                 Data.Functor.Classes.$fRead1Const1)
                              `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdy2j>_R
                                      :: (Text.ParserCombinators.ReadP.ReadP a_sdy2j :: *)
                                         ~R# (forall b.
                                              (a_sdy2j -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b :: *)))
                               @ b1_X81c7
                               (\ (a2_i88WJ :: a_sdy2j) ->
                                  eta_X6v (GHC.Base.Just @ a_sdy2j a2_i88WJ)))
                   of
                   { (# ww1_i88Ww #) ->
                   Text.ParserCombinators.ReadP.Look @ b1_X81c7 ww1_i88Ww
                   }
               }
               })
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Maybe
                                      a_sdy2j>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Maybe a_sdy2j>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Maybe a_sdy2j -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec (Maybe a_sdy2j) :: *)))
           w1_sdy2m
           @ b_sdy2n
           w2_sdy2o)

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadPrec a
     -> ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy2j)
                 (w_sdy2k [Occ=Once] :: ReadPrec a_sdy2j)
                 _ [Occ=Dead]
                 (w2_sdy2m [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_sdy2n)
                 (w3_sdy2o [Occ=Once]
                    :: Maybe a_sdy2j -> Text.ParserCombinators.ReadP.P b_sdy2n) ->
                 Data.Functor.Classes.$w$cliftReadPrec4
                   @ a_sdy2j w_sdy2k w2_sdy2m @ b_sdy2n w3_sdy2o}]
Data.Functor.Classes.$fRead1Maybe1
  = \ (@ a_sdy2j)
      (w_sdy2k :: ReadPrec a_sdy2j)
      _ [Occ=Dead]
      (w2_sdy2m :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sdy2n)
      (w3_sdy2o
         :: Maybe a_sdy2j -> Text.ParserCombinators.ReadP.P b_sdy2n) ->
      Data.Functor.Classes.$w$cliftReadPrec4
        @ a_sdy2j w_sdy2k w2_sdy2m @ b_sdy2n w3_sdy2o

-- RHS size: {terms: 9, types: 14, coercions: 9, joins: 0/0}
Data.Functor.Classes.$w$cliftReadsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> Int -> ReadS (Maybe a)
[GblId,
 Arity=2,
 Str=<L,C(C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 80 60}]
Data.Functor.Classes.$w$cliftReadsPrec4
  = \ (@ a_sdy2q)
      (w_sdy2r :: Int -> ReadS a_sdy2q)
      (w1_sdy2t :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Maybe a_sdy2q)
        (Data.Functor.Classes.$w$cliftReadPrec4
           @ a_sdy2q
           ((Text.ParserCombinators.ReadPrec.readS_to_Prec1 @ a_sdy2q w_sdy2r)
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <a_sdy2q>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_sdy2q>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (a_sdy2q -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (ReadPrec a_sdy2q :: *)))
           w1_sdy2t
           @ (Maybe a_sdy2q)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Maybe a_sdy2q)))

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (Maybe a)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy2q)
                 (w_sdy2r [Occ=Once] :: Int -> ReadS a_sdy2q)
                 _ [Occ=Dead]
                 (w2_sdy2t [Occ=Once] :: Int) ->
                 Data.Functor.Classes.$w$cliftReadsPrec4
                   @ a_sdy2q w_sdy2r w2_sdy2t}]
Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
  = \ (@ a_sdy2q)
      (w_sdy2r :: Int -> ReadS a_sdy2q)
      _ [Occ=Dead]
      (w2_sdy2t :: Int) ->
      Data.Functor.Classes.$w$cliftReadsPrec4 @ a_sdy2q w_sdy2r w2_sdy2t

-- RHS size: {terms: 11, types: 18, coercions: 11, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec
  :: forall a. ReadPrec a -> ReadPrec [a] -> ReadPrec [Maybe a]
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx4t)
                 (rp_adwdf [Occ=Once] :: ReadPrec a_adx4t)
                 (rl_adwdg [Occ=Once] :: ReadPrec [a_adx4t]) ->
                 list
                   @ (Maybe a_adx4t)
                   ((Data.Functor.Classes.$fRead1Maybe1 @ a_adx4t rp_adwdf rl_adwdg)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Maybe
                                              a_adx4t>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Maybe a_adx4t>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Maybe a_adx4t -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (Maybe a_adx4t) :: *)))}]
Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec
  = \ (@ a_adx4t) (rp_adwdf :: ReadPrec a_adx4t) _ [Occ=Dead] ->
      list
        @ (Maybe a_adx4t)
        ((\ (w_sdy2m [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_sdy2n)
            (w1_sdy2o
               :: Maybe a_adx4t -> Text.ParserCombinators.ReadP.P b_sdy2n) ->
            Data.Functor.Classes.$w$cliftReadPrec4
              @ a_adx4t rp_adwdf w_sdy2m @ b_sdy2n w1_sdy2o)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Maybe
                                   a_adx4t>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Maybe a_adx4t>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Maybe a_adx4t -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Maybe a_adx4t) :: *)))

-- RHS size: {terms: 16, types: 34, coercions: 28, joins: 0/1}
Data.Functor.Classes.$w$cliftReadList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> ReadS [Maybe a]
[GblId,
 Arity=1,
 Str=<L,C(C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 60}]
Data.Functor.Classes.$w$cliftReadList1
  = \ (@ a_sdy2v) (w_sdy2w :: Int -> ReadS a_sdy2v) ->
      Text.ParserCombinators.ReadP.run
        @ [Maybe a_sdy2v]
        (((((list
               @ (Maybe a_sdy2v)
               (let {
                  w1_sdy7g [Dmd=<L,C(C1(U))>]
                    :: Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b
                  [LclId, Arity=1, Unf=OtherCon []]
                  w1_sdy7g
                    = Text.ParserCombinators.ReadPrec.readS_to_Prec1
                        @ a_sdy2v w_sdy2w } in
                (\ (w2_sdy2m [OS=OneShot] :: Text.ParserCombinators.ReadPrec.Prec)
                   (@ b_sdy2n)
                   (w3_sdy2o
                      :: Maybe a_sdy2v -> Text.ParserCombinators.ReadP.P b_sdy2n) ->
                   Data.Functor.Classes.$w$cliftReadPrec4
                     @ a_sdy2v
                     (w1_sdy7g
                      `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                             <a_sdy2v>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <a_sdy2v>_R)
                              :: (Text.ParserCombinators.ReadPrec.Prec
                                  -> forall b.
                                     (a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)
                                 ~R# (ReadPrec a_sdy2v :: *)))
                     w2_sdy2m
                     @ b_sdy2n
                     w3_sdy2o)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Maybe
                                          a_sdy2v>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Maybe a_sdy2v>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Maybe a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec (Maybe a_sdy2v) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Maybe a_sdy2v]>_R
                    :: (ReadPrec [Maybe a_sdy2v] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Maybe a_sdy2v] :: *)))
             Data.Functor.Classes.$fRead1Identity5)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Maybe a_sdy2v]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Maybe a_sdy2v] :: *)
                     ~R# (forall b.
                          ([Maybe a_sdy2v] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Maybe a_sdy2v]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Maybe a_sdy2v]))

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [Maybe a]
[GblId,
 Arity=2,
 Str=<L,C(C(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy2v)
                 (w_sdy2w [Occ=Once] :: Int -> ReadS a_sdy2v)
                 _ [Occ=Dead] ->
                 Data.Functor.Classes.$w$cliftReadList1 @ a_sdy2v w_sdy2w}]
Data.Functor.Classes.$fRead1Maybe_$cliftReadList
  = \ (@ a_sdy2v) (w_sdy2w :: Int -> ReadS a_sdy2v) _ [Occ=Dead] ->
      Data.Functor.Classes.$w$cliftReadList1 @ a_sdy2v w_sdy2w

-- RHS size: {terms: 5, types: 1, coercions: 21, joins: 0/0}
Data.Functor.Classes.$fRead1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Read1 Maybe
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Read1 TYPE: Maybe
                                    Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
                                    Data.Functor.Classes.$fRead1Maybe_$cliftReadList
                                    Data.Functor.Classes.$fRead1Maybe1
                                    `cast` (forall (a :: <*>_N).
                                            <ReadPrec a>_R
                                            ->_R <ReadPrec [a]>_R
                                            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                <Maybe
                                                                   a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                     <Maybe a>_R)
                                            :: (forall a.
                                                ReadPrec a
                                                -> ReadPrec [a]
                                                -> Text.ParserCombinators.ReadPrec.Prec
                                                -> forall b.
                                                   (Maybe a -> Text.ParserCombinators.ReadP.P b)
                                                   -> Text.ParserCombinators.ReadP.P b :: *)
                                               ~R# (forall a.
                                                    ReadPrec a
                                                    -> ReadPrec [a] -> ReadPrec (Maybe a) :: *))
                                    Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec]
Data.Functor.Classes.$fRead1Maybe
  = Data.Functor.Classes.C:Read1
      @ Maybe
      Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
      Data.Functor.Classes.$fRead1Maybe_$cliftReadList
      (Data.Functor.Classes.$fRead1Maybe1
       `cast` (forall (a :: <*>_N).
               <ReadPrec a>_R
               ->_R <ReadPrec [a]>_R
               ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Maybe
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Maybe a>_R)
               :: (forall a.
                   ReadPrec a
                   -> ReadPrec [a]
                   -> Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Maybe a -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (forall a.
                       ReadPrec a -> ReadPrec [a] -> ReadPrec (Maybe a) :: *)))
      Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec

-- RHS size: {terms: 55, types: 90, coercions: 0, joins: 0/3}
readsBinaryWith
  :: forall a b t.
     (Int -> ReadS a)
     -> (Int -> ReadS b) -> String -> (a -> b -> t) -> String -> ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 60 0 0] 350 10}]
readsBinaryWith
  = \ (@ a_adwGC)
      (@ b_adwGD)
      (@ t_adwGE)
      (rp1_adwdH :: Int -> ReadS a_adwGC)
      (rp2_adwdI :: Int -> ReadS b_adwGD)
      (name_adwdJ :: String)
      (cons_adwdK :: a_adwGC -> b_adwGD -> t_adwGE)
      (kw_adwdL :: String)
      (s_adwdM :: String) ->
      case GHC.Base.eqString kw_adwdL name_adwdJ of {
        False -> GHC.Types.[] @ (t_adwGE, String);
        True ->
          letrec {
            go_i7Jcj [Occ=LoopBreaker]
              :: [(a_adwGC, String)] -> [(t_adwGE, String)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i7Jcj
              = \ (ds_i7Jck :: [(a_adwGC, String)]) ->
                  case ds_i7Jck of {
                    [] -> GHC.Types.[] @ (t_adwGE, String);
                    : y_i7Jcp ys_i7Jcq ->
                      case y_i7Jcp of { (x_adwdN, t1_adwdO) ->
                      let {
                        z_X7JlL :: [(t_adwGE, String)]
                        [LclId]
                        z_X7JlL = go_i7Jcj ys_i7Jcq } in
                      letrec {
                        go1_X7JlO [Occ=LoopBreaker]
                          :: [(b_adwGD, String)] -> [(t_adwGE, String)]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go1_X7JlO
                          = \ (ds1_X7JlQ :: [(b_adwGD, String)]) ->
                              case ds1_X7JlQ of {
                                [] -> z_X7JlL;
                                : y1_X7JlY ys1_X7Jm0 ->
                                  case y1_X7JlY of { (y2_adwdP, u_adwdQ) ->
                                  GHC.Types.:
                                    @ (t_adwGE, String)
                                    (cons_adwdK x_adwdN y2_adwdP, u_adwdQ)
                                    (go1_X7JlO ys1_X7Jm0)
                                  }
                              }; } in
                      go1_X7JlO (rp2_adwdI Data.Functor.Classes.$fRead1Const1 t1_adwdO)
                      }
                  }; } in
          go_i7Jcj (rp1_adwdH Data.Functor.Classes.$fRead1Const1 s_adwdM)
      }

-- RHS size: {terms: 32, types: 29, coercions: 8, joins: 0/1}
Data.Functor.Classes.$wreadBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     ReadPrec a
     -> ReadPrec b
     -> String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> (# String -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 60 20 60] 211 0}]
Data.Functor.Classes.$wreadBinaryWith
  = \ (@ a_sdy2K)
      (@ b_sdy2L)
      (@ t_sdy2M)
      (w_sdy2N :: ReadPrec a_sdy2K)
      (w1_sdy2O :: ReadPrec b_sdy2L)
      (w2_sdy2P :: String)
      (w3_sdy2Q :: a_sdy2K -> b_sdy2L -> t_sdy2M)
      (w4_sdy2R :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdy2S)
      (w5_sdy2T :: t_sdy2M -> Text.ParserCombinators.ReadP.P b1_sdy2S) ->
      Text.Read.Lex.$wexpect
        (Text.Read.Lex.Ident w2_sdy2P)
        @ b1_sdy2S
        (\ _ [Occ=Dead, OS=OneShot] ->
           let {
             lvl3_sdxvP :: Text.ParserCombinators.ReadPrec.Prec
             [LclId]
             lvl3_sdxvP
               = case w4_sdy2R of { GHC.Types.I# x_i88Yu ->
                 GHC.Types.I# (GHC.Prim.+# x_i88Yu 1#)
                 } } in
           (((w_sdy2N
              `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_sdy2K>_R
                      :: (ReadPrec a_sdy2K :: *)
                         ~R# (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP a_sdy2K :: *)))
               lvl3_sdxvP)
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_sdy2K>_R
                    :: (Text.ParserCombinators.ReadP.ReadP a_sdy2K :: *)
                       ~R# (forall b.
                            (a_sdy2K -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)))
             @ b1_sdy2S
             (\ (a2_i88WJ :: a_sdy2K) ->
                (((w1_sdy2O
                   `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <b_sdy2L>_R
                           :: (ReadPrec b_sdy2L :: *)
                              ~R# (Text.ParserCombinators.ReadPrec.Prec
                                   -> Text.ParserCombinators.ReadP.ReadP b_sdy2L :: *)))
                    lvl3_sdxvP)
                 `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_sdy2L>_R
                         :: (Text.ParserCombinators.ReadP.ReadP b_sdy2L :: *)
                            ~R# (forall b.
                                 (b_sdy2L -> Text.ParserCombinators.ReadP.P b)
                                 -> Text.ParserCombinators.ReadP.P b :: *)))
                  @ b1_sdy2S
                  (\ (a3_X8937 :: b_sdy2L) ->
                     w5_sdy2T (w3_sdy2Q a2_i88WJ a3_X8937))))

-- RHS size: {terms: 21, types: 33, coercions: 0, joins: 0/0}
Data.Functor.Classes.readBinaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     ReadPrec a
     -> ReadPrec b
     -> String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy2K)
                 (@ b_sdy2L)
                 (@ t_sdy2M)
                 (w_sdy2N [Occ=Once] :: ReadPrec a_sdy2K)
                 (w1_sdy2O [Occ=Once] :: ReadPrec b_sdy2L)
                 (w2_sdy2P [Occ=Once] :: String)
                 (w3_sdy2Q [Occ=Once] :: a_sdy2K -> b_sdy2L -> t_sdy2M)
                 (w4_sdy2R [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b1_sdy2S)
                 (w5_sdy2T [Occ=Once]
                    :: t_sdy2M -> Text.ParserCombinators.ReadP.P b1_sdy2S) ->
                 case Data.Functor.Classes.$wreadBinaryWith
                        @ a_sdy2K
                        @ b_sdy2L
                        @ t_sdy2M
                        w_sdy2N
                        w1_sdy2O
                        w2_sdy2P
                        w3_sdy2Q
                        w4_sdy2R
                        @ b1_sdy2S
                        w5_sdy2T
                 of
                 { (# ww1_sdy4e [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b1_sdy2S ww1_sdy4e
                 }}]
Data.Functor.Classes.readBinaryWith1
  = \ (@ a_sdy2K)
      (@ b_sdy2L)
      (@ t_sdy2M)
      (w_sdy2N :: ReadPrec a_sdy2K)
      (w1_sdy2O :: ReadPrec b_sdy2L)
      (w2_sdy2P :: String)
      (w3_sdy2Q :: a_sdy2K -> b_sdy2L -> t_sdy2M)
      (w4_sdy2R :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_sdy2S)
      (w5_sdy2T :: t_sdy2M -> Text.ParserCombinators.ReadP.P b1_sdy2S) ->
      case Data.Functor.Classes.$wreadBinaryWith
             @ a_sdy2K
             @ b_sdy2L
             @ t_sdy2M
             w_sdy2N
             w1_sdy2O
             w2_sdy2P
             w3_sdy2Q
             w4_sdy2R
             @ b1_sdy2S
             w5_sdy2T
      of
      { (# ww1_sdy4e #) ->
      Text.ParserCombinators.ReadP.Look @ b1_sdy2S ww1_sdy4e
      }

-- RHS size: {terms: 1, types: 0, coercions: 30, joins: 0/0}
readBinaryWith
  :: forall a b t.
     ReadPrec a -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Functor.Classes.readBinaryWith1
               `cast` (forall (a :: <*>_N) (b :: <*>_N) (t :: <*>_N).
                       <ReadPrec a>_R
                       ->_R <ReadPrec b>_R
                       ->_R <String>_R
                       ->_R <a -> b -> t>_R
                       ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <t>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <t>_R)
                       :: (forall a b t.
                           ReadPrec a
                           -> ReadPrec b
                           -> String
                           -> (a -> b -> t)
                           -> Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (t -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (forall a b t.
                               ReadPrec a
                               -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t :: *))}]
readBinaryWith
  = Data.Functor.Classes.readBinaryWith1
    `cast` (forall (a :: <*>_N) (b :: <*>_N) (t :: <*>_N).
            <ReadPrec a>_R
            ->_R <ReadPrec b>_R
            ->_R <String>_R
            ->_R <a -> b -> t>_R
            ->_R (<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <t>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <t>_R)
            :: (forall a b t.
                ReadPrec a
                -> ReadPrec b
                -> String
                -> (a -> b -> t)
                -> Text.ParserCombinators.ReadPrec.Prec
                -> forall b.
                   (t -> Text.ParserCombinators.ReadP.P b)
                   -> Text.ParserCombinators.ReadP.P b :: *)
               ~R# (forall a b t.
                    ReadPrec a
                    -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t :: *))

-- RHS size: {terms: 33, types: 19, coercions: 0, joins: 0/1}
Data.Functor.Classes.$wshowsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> a -> ShowS) -> String -> GHC.Prim.Int# -> a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0] 221 120}]
Data.Functor.Classes.$wshowsUnaryWith
  = \ (@ a_sdy2Y)
      (w_sdy2Z :: Int -> a_sdy2Y -> ShowS)
      (w1_sdy30 :: String)
      (ww_sdy35 :: GHC.Prim.Int#)
      (w2_sdy32 :: a_sdy2Y) ->
      let {
        g_sdxrT [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sdxrT = w_sdy2Z Data.Functor.Classes.$fRead1Const1 w2_sdy32 } in
      case GHC.Prim.># ww_sdy35 10# of {
        __DEFAULT ->
          \ (x_X7RDq :: String) ->
            ++
              @ Char
              w1_sdy30
              (GHC.Types.:
                 @ Char Data.Functor.Classes.showsUnaryWith1 (g_sdxrT x_X7RDq));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (++
                 @ Char
                 w1_sdy30
                 (GHC.Types.:
                    @ Char
                    Data.Functor.Classes.showsUnaryWith1
                    (g_sdxrT (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))
      }

-- RHS size: {terms: 13, types: 11, coercions: 0, joins: 0/0}
showsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> a -> ShowS) -> String -> Int -> a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy2Y)
                 (w_sdy2Z [Occ=Once] :: Int -> a_sdy2Y -> ShowS)
                 (w1_sdy30 [Occ=Once] :: String)
                 (w2_sdy31 [Occ=Once!] :: Int)
                 (w3_sdy32 [Occ=Once] :: a_sdy2Y) ->
                 case w2_sdy31 of { GHC.Types.I# ww1_sdy35 [Occ=Once] ->
                 Data.Functor.Classes.$wshowsUnaryWith
                   @ a_sdy2Y w_sdy2Z w1_sdy30 ww1_sdy35 w3_sdy32
                 }}]
showsUnaryWith
  = \ (@ a_sdy2Y)
      (w_sdy2Z :: Int -> a_sdy2Y -> ShowS)
      (w1_sdy30 :: String)
      (w2_sdy31 :: Int)
      (w3_sdy32 :: a_sdy2Y) ->
      case w2_sdy31 of { GHC.Types.I# ww1_sdy35 ->
      Data.Functor.Classes.$wshowsUnaryWith
        @ a_sdy2Y w_sdy2Z w1_sdy30 ww1_sdy35 w3_sdy32
      }

-- RHS size: {terms: 16, types: 25, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
  :: forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> Int
     -> Const a b
     -> ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwPx)
                 (@ b_adwPy)
                 (sp_adwaj [Occ=Once] :: Int -> a_adwPx -> ShowS)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (d_adwak [Occ=Once] :: Int)
                 (ds3_ddx99 [Occ=Once] :: Const a_adwPx b_adwPy) ->
                 showsUnaryWith
                   @ a_adwPx
                   sp_adwaj
                   Data.Functor.Classes.$fRead1Const3
                   d_adwak
                   (ds3_ddx99
                    `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwPx>_R <b_adwPy>_P
                            :: (Const a_adwPx b_adwPy :: *) ~R# (a_adwPx :: *)))}]
Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
  = \ (@ a_adwPx)
      (@ b_adwPy)
      (sp_adwaj :: Int -> a_adwPx -> ShowS)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (d_adwak :: Int)
      (ds3_ddx99 :: Const a_adwPx b_adwPy) ->
      case d_adwak of { GHC.Types.I# ww1_sdy35 ->
      Data.Functor.Classes.$wshowsUnaryWith
        @ a_adwPx
        sp_adwaj
        Data.Functor.Classes.$fRead1Const3
        ww1_sdy35
        (ds3_ddx99
         `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwPx>_R <b_adwPy>_P
                 :: (Const a_adwPx b_adwPy :: *) ~R# (a_adwPx :: *)))
      }

-- RHS size: {terms: 17, types: 34, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fShow2Const_$cliftShowList2
  :: forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> [Const a b]
     -> ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,A><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwPE)
                 (@ b_adwPF)
                 (sp1_adw9e [Occ=OnceL] :: Int -> a_adwPE -> ShowS)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta_X9t [Occ=Once] :: [Const a_adwPE b_adwPF])
                 (eta1_XiV [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Const a_adwPE b_adwPF)
                   (\ (ds_ddx99 [Occ=Once] :: Const a_adwPE b_adwPF) ->
                      showsUnaryWith
                        @ a_adwPE
                        sp1_adw9e
                        Data.Functor.Classes.$fRead1Const3
                        Data.Functor.Classes.$fRead1Identity5
                        (ds_ddx99
                         `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwPE>_R <b_adwPF>_P
                                 :: (Const a_adwPE b_adwPF :: *) ~R# (a_adwPE :: *))))
                   eta_X9t
                   eta1_XiV}]
Data.Functor.Classes.$fShow2Const_$cliftShowList2
  = \ (@ a_adwPE)
      (@ b_adwPF)
      (sp1_adw9e :: Int -> a_adwPE -> ShowS)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta_X9t :: [Const a_adwPE b_adwPF])
      (eta1_XiV :: String) ->
      GHC.Show.showList__
        @ (Const a_adwPE b_adwPF)
        (\ (ds_ddx99 :: Const a_adwPE b_adwPF) ->
           Data.Functor.Classes.$wshowsUnaryWith
             @ a_adwPE
             sp1_adw9e
             Data.Functor.Classes.$fRead1Const3
             0#
             (ds_ddx99
              `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adwPE>_R <b_adwPF>_P
                      :: (Const a_adwPE b_adwPF :: *) ~R# (a_adwPE :: *))))
        eta_X9t
        eta1_XiV

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Show2 Const
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show2 TYPE: Const
                                    Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
                                    Data.Functor.Classes.$fShow2Const_$cliftShowList2]
Data.Functor.Classes.$fShow2Const
  = Data.Functor.Classes.C:Show2
      @ Const
      Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
      Data.Functor.Classes.$fShow2Const_$cliftShowList2

-- RHS size: {terms: 16, types: 22, coercions: 5, joins: 0/0}
Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS)
     -> ([a1] -> ShowS) -> Int -> Const a a1 -> ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwP4)
                 ($dShow_adwP5 [Occ=Once] :: Show a_adwP4)
                 (@ a1_adwP9)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta2_X9v [Occ=Once] :: Int)
                 (eta3_XiZ [Occ=Once] :: Const a_adwP4 a1_adwP9) ->
                 showsUnaryWith
                   @ a_adwP4
                   (showsPrec @ a_adwP4 $dShow_adwP5)
                   Data.Functor.Classes.$fRead1Const3
                   eta2_X9v
                   (eta3_XiZ
                    `cast` (Data.Functor.Const.N:Const[0]
                                <*>_N <a_adwP4>_R <a1_adwP9>_P
                            :: (Const a_adwP4 a1_adwP9 :: *) ~R# (a_adwP4 :: *)))}]
Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
  = \ (@ a_adwP4)
      ($dShow_adwP5 :: Show a_adwP4)
      (@ a1_adwP9)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta2_X9v :: Int)
      (eta3_XiZ :: Const a_adwP4 a1_adwP9) ->
      case eta2_X9v of { GHC.Types.I# ww1_sdy35 ->
      Data.Functor.Classes.$wshowsUnaryWith
        @ a_adwP4
        (showsPrec @ a_adwP4 $dShow_adwP5)
        Data.Functor.Classes.$fRead1Const3
        ww1_sdy35
        (eta3_XiZ
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N <a_adwP4>_R <a1_adwP9>_P
                 :: (Const a_adwP4 a1_adwP9 :: *) ~R# (a_adwP4 :: *)))
      }

-- RHS size: {terms: 19, types: 34, coercions: 5, joins: 0/1}
Data.Functor.Classes.$fShow1Const_$cliftShowList
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS) -> ([a1] -> ShowS) -> [Const a a1] -> ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,A><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwP4)
                 ($dShow_adwP5 [Occ=OnceL] :: Show a_adwP4)
                 (@ a1_adwPn)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta_X9x [Occ=Once] :: [Const a_adwP4 a1_adwPn])
                 (eta1_Xj3 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Const a_adwP4 a1_adwPn)
                   (\ (eta2_XjX [Occ=Once] :: Const a_adwP4 a1_adwPn) ->
                      showsUnaryWith
                        @ a_adwP4
                        (showsPrec @ a_adwP4 $dShow_adwP5)
                        Data.Functor.Classes.$fRead1Const3
                        Data.Functor.Classes.$fRead1Identity5
                        (eta2_XjX
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <a_adwP4>_R <a1_adwPn>_P
                                 :: (Const a_adwP4 a1_adwPn :: *) ~R# (a_adwP4 :: *))))
                   eta_X9x
                   eta1_Xj3}]
Data.Functor.Classes.$fShow1Const_$cliftShowList
  = \ (@ a_adwP4)
      ($dShow_adwP5 :: Show a_adwP4)
      (@ a1_adwPn)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta_X9x :: [Const a_adwP4 a1_adwPn])
      (eta1_Xj3 :: String) ->
      let {
        lvl3_sdybD [Dmd=<L,C(C1(C(U)))>] :: Int -> a_adwP4 -> ShowS
        [LclId]
        lvl3_sdybD = showsPrec @ a_adwP4 $dShow_adwP5 } in
      GHC.Show.showList__
        @ (Const a_adwP4 a1_adwPn)
        (\ (eta2_XjX :: Const a_adwP4 a1_adwPn) ->
           Data.Functor.Classes.$wshowsUnaryWith
             @ a_adwP4
             lvl3_sdybD
             Data.Functor.Classes.$fRead1Const3
             0#
             (eta2_XjX
              `cast` (Data.Functor.Const.N:Const[0]
                          <*>_N <a_adwP4>_R <a1_adwPn>_P
                      :: (Const a_adwP4 a1_adwPn :: *) ~R# (a_adwP4 :: *))))
        eta_X9x
        eta1_Xj3

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show1 (Const a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_adwaf) (v_X9t :: Show a_adwaf) ->
       Data.Functor.Classes.C:Show1 TYPE: Const a_adwaf
                                    Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
                                      @ a_adwaf v_X9t
                                    Data.Functor.Classes.$fShow1Const_$cliftShowList
                                      @ a_adwaf v_X9t]
Data.Functor.Classes.$fShow1Const
  = \ (@ a_adwP4) ($dShow_adwP5 :: Show a_adwP4) ->
      Data.Functor.Classes.C:Show1
        @ (Const a_adwP4)
        (Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
           @ a_adwP4 $dShow_adwP5)
        (Data.Functor.Classes.$fShow1Const_$cliftShowList
           @ a_adwP4 $dShow_adwP5)

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
  :: forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> Int
     -> Either a b
     -> ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwQg)
                 (@ b_adwQh)
                 (sp1_adwaH [Occ=Once] :: Int -> a_adwQg -> ShowS)
                 _ [Occ=Dead]
                 (ds1_ddx9i [Occ=Once] :: Int -> b_adwQh -> ShowS)
                 _ [Occ=Dead]
                 (d_adwaI [Occ=Once*] :: Int)
                 (ds3_ddx9k [Occ=Once!] :: Either a_adwQg b_adwQh) ->
                 case ds3_ddx9k of {
                   Left x_adwaJ [Occ=Once] ->
                     showsUnaryWith
                       @ a_adwQg
                       sp1_adwaH
                       Data.Functor.Classes.$fRead1Either5
                       d_adwaI
                       x_adwaJ;
                   Right x_adwaM [Occ=Once] ->
                     showsUnaryWith
                       @ b_adwQh
                       ds1_ddx9i
                       Data.Functor.Classes.$fRead1Either2
                       d_adwaI
                       x_adwaM
                 }}]
Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
  = \ (@ a_adwQg)
      (@ b_adwQh)
      (sp1_adwaH :: Int -> a_adwQg -> ShowS)
      _ [Occ=Dead]
      (ds1_ddx9i :: Int -> b_adwQh -> ShowS)
      _ [Occ=Dead]
      (d_adwaI :: Int)
      (ds3_ddx9k :: Either a_adwQg b_adwQh) ->
      case ds3_ddx9k of {
        Left x_adwaJ ->
          case d_adwaI of { GHC.Types.I# ww1_sdy35 ->
          Data.Functor.Classes.$wshowsUnaryWith
            @ a_adwQg
            sp1_adwaH
            Data.Functor.Classes.$fRead1Either5
            ww1_sdy35
            x_adwaJ
          };
        Right x_adwaM ->
          case d_adwaI of { GHC.Types.I# ww1_sdy35 ->
          Data.Functor.Classes.$wshowsUnaryWith
            @ b_adwQh
            ds1_ddx9i
            Data.Functor.Classes.$fRead1Either2
            ww1_sdy35
            x_adwaM
          }
      }

-- RHS size: {terms: 24, types: 28, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftShowList4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> (Int -> b -> ShowS) -> [Either a b] -> String -> String
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 170 0}]
Data.Functor.Classes.$w$cliftShowList4
  = \ (@ a_sdy38)
      (@ b_sdy39)
      (w_sdy3a :: Int -> a_sdy38 -> ShowS)
      (w1_sdy3c :: Int -> b_sdy39 -> ShowS)
      (w2_sdy3e :: [Either a_sdy38 b_sdy39])
      (w3_sdy3f :: String) ->
      GHC.Show.showList__
        @ (Either a_sdy38 b_sdy39)
        (\ (ds_ddx9k :: Either a_sdy38 b_sdy39) ->
           case ds_ddx9k of {
             Left x_adwaJ ->
               Data.Functor.Classes.$wshowsUnaryWith
                 @ a_sdy38 w_sdy3a Data.Functor.Classes.$fRead1Either5 0# x_adwaJ;
             Right x_adwaM ->
               Data.Functor.Classes.$wshowsUnaryWith
                 @ b_sdy39 w1_sdy3c Data.Functor.Classes.$fRead1Either2 0# x_adwaM
           })
        w2_sdy3e
        w3_sdy3f

-- RHS size: {terms: 13, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow2Either_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> (Int -> b -> ShowS)
     -> ([b] -> ShowS)
     -> [Either a b]
     -> ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy38)
                 (@ b_sdy39)
                 (w_sdy3a [Occ=Once] :: Int -> a_sdy38 -> ShowS)
                 _ [Occ=Dead]
                 (w2_sdy3c [Occ=Once] :: Int -> b_sdy39 -> ShowS)
                 _ [Occ=Dead]
                 (w4_sdy3e [Occ=Once] :: [Either a_sdy38 b_sdy39])
                 (w5_sdy3f [Occ=Once] :: String) ->
                 Data.Functor.Classes.$w$cliftShowList4
                   @ a_sdy38 @ b_sdy39 w_sdy3a w2_sdy3c w4_sdy3e w5_sdy3f}]
Data.Functor.Classes.$fShow2Either_$cliftShowList2
  = \ (@ a_sdy38)
      (@ b_sdy39)
      (w_sdy3a :: Int -> a_sdy38 -> ShowS)
      _ [Occ=Dead]
      (w2_sdy3c :: Int -> b_sdy39 -> ShowS)
      _ [Occ=Dead]
      (w4_sdy3e :: [Either a_sdy38 b_sdy39])
      (w5_sdy3f :: String) ->
      Data.Functor.Classes.$w$cliftShowList4
        @ a_sdy38 @ b_sdy39 w_sdy3a w2_sdy3c w4_sdy3e w5_sdy3f

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Show2 Either
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show2 TYPE: Either
                                    Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
                                    Data.Functor.Classes.$fShow2Either_$cliftShowList2]
Data.Functor.Classes.$fShow2Either
  = Data.Functor.Classes.C:Show2
      @ Either
      Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
      Data.Functor.Classes.$fShow2Either_$cliftShowList2

-- RHS size: {terms: 21, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS) -> GHC.Prim.Int# -> Either a a1 -> ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 80] 140 0}]
Data.Functor.Classes.$w$cliftShowsPrec
  = \ (@ a_sdy3h)
      (w_sdy3i :: Show a_sdy3h)
      (@ a1_sdy3j)
      (w1_sdy3k :: Int -> a1_sdy3j -> ShowS)
      (ww_sdy3q :: GHC.Prim.Int#)
      (w2_sdy3n :: Either a_sdy3h a1_sdy3j) ->
      case w2_sdy3n of {
        Left x_adwaJ ->
          Data.Functor.Classes.$wshowsUnaryWith
            @ a_sdy3h
            (showsPrec @ a_sdy3h w_sdy3i)
            Data.Functor.Classes.$fRead1Either5
            ww_sdy3q
            x_adwaJ;
        Right x_adwaM ->
          Data.Functor.Classes.$wshowsUnaryWith
            @ a1_sdy3j
            w1_sdy3k
            Data.Functor.Classes.$fRead1Either2
            ww_sdy3q
            x_adwaM
      }

-- RHS size: {terms: 15, types: 20, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Either_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS)
     -> ([a1] -> ShowS) -> Int -> Either a a1 -> ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy3h)
                 (w_sdy3i [Occ=Once] :: Show a_sdy3h)
                 (@ a1_sdy3j)
                 (w1_sdy3k [Occ=Once] :: Int -> a1_sdy3j -> ShowS)
                 _ [Occ=Dead]
                 (w3_sdy3m [Occ=Once!] :: Int)
                 (w4_sdy3n [Occ=Once] :: Either a_sdy3h a1_sdy3j) ->
                 case w3_sdy3m of { GHC.Types.I# ww1_sdy3q [Occ=Once] ->
                 Data.Functor.Classes.$w$cliftShowsPrec
                   @ a_sdy3h w_sdy3i @ a1_sdy3j w1_sdy3k ww1_sdy3q w4_sdy3n
                 }}]
Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
  = \ (@ a_sdy3h)
      (w_sdy3i :: Show a_sdy3h)
      (@ a1_sdy3j)
      (w1_sdy3k :: Int -> a1_sdy3j -> ShowS)
      _ [Occ=Dead]
      (w3_sdy3m :: Int)
      (w4_sdy3n :: Either a_sdy3h a1_sdy3j) ->
      case w3_sdy3m of { GHC.Types.I# ww1_sdy3q ->
      Data.Functor.Classes.$w$cliftShowsPrec
        @ a_sdy3h w_sdy3i @ a1_sdy3j w1_sdy3k ww1_sdy3q w4_sdy3n
      }

-- RHS size: {terms: 27, types: 31, coercions: 0, joins: 0/1}
Data.Functor.Classes.$w$cliftShowList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS) -> [Either a a1] -> String -> String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0 0] 200 0}]
Data.Functor.Classes.$w$cliftShowList1
  = \ (@ a_sdy3t)
      (w_sdy3u :: Show a_sdy3t)
      (@ a1_sdy3v)
      (w1_sdy3w :: Int -> a1_sdy3v -> ShowS)
      (w2_sdy3y :: [Either a_sdy3t a1_sdy3v])
      (w3_sdy3z :: String) ->
      let {
        lvl3_sdxwg [Dmd=<L,C(C1(C(U)))>] :: Int -> a_sdy3t -> ShowS
        [LclId]
        lvl3_sdxwg = showsPrec @ a_sdy3t w_sdy3u } in
      GHC.Show.showList__
        @ (Either a_sdy3t a1_sdy3v)
        (\ (eta_X9 :: Either a_sdy3t a1_sdy3v) ->
           case eta_X9 of {
             Left x_adwaJ ->
               Data.Functor.Classes.$wshowsUnaryWith
                 @ a_sdy3t
                 lvl3_sdxwg
                 Data.Functor.Classes.$fRead1Either5
                 0#
                 x_adwaJ;
             Right x_adwaM ->
               Data.Functor.Classes.$wshowsUnaryWith
                 @ a1_sdy3v w1_sdy3w Data.Functor.Classes.$fRead1Either2 0# x_adwaM
           })
        w2_sdy3y
        w3_sdy3z

-- RHS size: {terms: 12, types: 19, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Either_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Show a =>
     forall a1.
     (Int -> a1 -> ShowS) -> ([a1] -> ShowS) -> [Either a a1] -> ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy3t)
                 (w_sdy3u [Occ=Once] :: Show a_sdy3t)
                 (@ a1_sdy3v)
                 (w1_sdy3w [Occ=Once] :: Int -> a1_sdy3v -> ShowS)
                 _ [Occ=Dead]
                 (w3_sdy3y [Occ=Once] :: [Either a_sdy3t a1_sdy3v])
                 (w4_sdy3z [Occ=Once] :: String) ->
                 Data.Functor.Classes.$w$cliftShowList1
                   @ a_sdy3t w_sdy3u @ a1_sdy3v w1_sdy3w w3_sdy3y w4_sdy3z}]
Data.Functor.Classes.$fShow1Either_$cliftShowList
  = \ (@ a_sdy3t)
      (w_sdy3u :: Show a_sdy3t)
      (@ a1_sdy3v)
      (w1_sdy3w :: Int -> a1_sdy3v -> ShowS)
      _ [Occ=Dead]
      (w3_sdy3y :: [Either a_sdy3t a1_sdy3v])
      (w4_sdy3z :: String) ->
      Data.Functor.Classes.$w$cliftShowList1
        @ a_sdy3t w_sdy3u @ a1_sdy3v w1_sdy3w w3_sdy3y w4_sdy3z

-- RHS size: {terms: 15, types: 22, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show1 (Either a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_adwaD) (v_X9D :: Show a_adwaD) ->
       Data.Functor.Classes.C:Show1 TYPE: Either a_adwaD
                                    Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
                                      @ a_adwaD v_X9D
                                    Data.Functor.Classes.$fShow1Either_$cliftShowList
                                      @ a_adwaD v_X9D]
Data.Functor.Classes.$fShow1Either
  = \ (@ a_adwPN) ($dShow_adwPO :: Show a_adwPN) ->
      Data.Functor.Classes.C:Show1
        @ (Either a_adwPN)
        (Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
           @ a_adwPN $dShow_adwPO)
        (\ (@ a1_sdy3v)
           (w_sdy3w :: Int -> a1_sdy3v -> ShowS)
           _ [Occ=Dead]
           (w2_sdy3y :: [Either a_adwPN a1_sdy3v])
           (w3_sdy3z :: String) ->
           Data.Functor.Classes.$w$cliftShowList1
             @ a_adwPN $dShow_adwPO @ a1_sdy3v w_sdy3w w2_sdy3y w3_sdy3z)

-- RHS size: {terms: 13, types: 14, coercions: 2, joins: 0/0}
Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> Identity a -> ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_adwZP)
                 (sp_adwat [Occ=Once] :: Int -> a_adwZP -> ShowS)
                 _ [Occ=Dead]
                 (d_adwau [Occ=Once] :: Int)
                 (ds1_ddxc9 [Occ=Once] :: Identity a_adwZP) ->
                 showsUnaryWith
                   @ a_adwZP
                   sp_adwat
                   Data.Functor.Classes.$fRead1Identity3
                   d_adwau
                   (ds1_ddxc9
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_adwZP>_R
                            :: (Identity a_adwZP :: *) ~R# (a_adwZP :: *)))}]
Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
  = \ (@ a_adwZP)
      (sp_adwat :: Int -> a_adwZP -> ShowS)
      _ [Occ=Dead]
      (d_adwau :: Int)
      (ds1_ddxc9 :: Identity a_adwZP) ->
      case d_adwau of { GHC.Types.I# ww1_sdy35 ->
      Data.Functor.Classes.$wshowsUnaryWith
        @ a_adwZP
        sp_adwat
        Data.Functor.Classes.$fRead1Identity3
        ww1_sdy35
        (ds1_ddxc9
         `cast` (Data.Functor.Identity.N:Identity[0] <a_adwZP>_R
                 :: (Identity a_adwZP :: *) ~R# (a_adwZP :: *)))
      }

-- RHS size: {terms: 14, types: 17, coercions: 2, joins: 0/0}
Data.Functor.Classes.$fShow1Identity_$cliftShowList
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Identity a] -> ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adwZV)
                 (sp_adw9U [Occ=OnceL] :: Int -> a_adwZV -> ShowS)
                 _ [Occ=Dead]
                 (eta_X9L [Occ=Once] :: [Identity a_adwZV])
                 (eta1_Xjv [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Identity a_adwZV)
                   (\ (ds_ddxc9 [Occ=Once] :: Identity a_adwZV) ->
                      showsUnaryWith
                        @ a_adwZV
                        sp_adw9U
                        Data.Functor.Classes.$fRead1Identity3
                        Data.Functor.Classes.$fRead1Identity5
                        (ds_ddxc9
                         `cast` (Data.Functor.Identity.N:Identity[0] <a_adwZV>_R
                                 :: (Identity a_adwZV :: *) ~R# (a_adwZV :: *))))
                   eta_X9L
                   eta1_Xjv}]
Data.Functor.Classes.$fShow1Identity_$cliftShowList
  = \ (@ a_adwZV)
      (sp_adw9U :: Int -> a_adwZV -> ShowS)
      _ [Occ=Dead]
      (eta_X9L :: [Identity a_adwZV])
      (eta1_Xjv :: String) ->
      GHC.Show.showList__
        @ (Identity a_adwZV)
        (\ (ds_ddxc9 :: Identity a_adwZV) ->
           Data.Functor.Classes.$wshowsUnaryWith
             @ a_adwZV
             sp_adw9U
             Data.Functor.Classes.$fRead1Identity3
             0#
             (ds_ddxc9
              `cast` (Data.Functor.Identity.N:Identity[0] <a_adwZV>_R
                      :: (Identity a_adwZV :: *) ~R# (a_adwZV :: *))))
        eta_X9L
        eta1_Xjv

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Show1 Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show1 TYPE: Identity
                                    Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
                                    Data.Functor.Classes.$fShow1Identity_$cliftShowList]
Data.Functor.Classes.$fShow1Identity
  = Data.Functor.Classes.C:Show1
      @ Identity
      Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
      Data.Functor.Classes.$fShow1Identity_$cliftShowList

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Maybe1 :: [Char] -> [Char]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Functor.Classes.$fShow1Maybe1
  = ++ @ Char Data.Functor.Classes.$fRead1Maybe6

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> Maybe a -> ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*U(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_adx0M)
                 (ds_ddxco [Occ=Once] :: Int -> a_adx0M -> ShowS)
                 _ [Occ=Dead]
                 (ds2_ddxcq [Occ=Once] :: Int)
                 (ds3_ddxcr [Occ=Once!] :: Maybe a_adx0M) ->
                 case ds3_ddxcr of {
                   Nothing -> Data.Functor.Classes.$fShow1Maybe1;
                   Just x_adwc2 [Occ=Once] ->
                     showsUnaryWith
                       @ a_adx0M
                       ds_ddxco
                       Data.Functor.Classes.$fRead1Maybe3
                       ds2_ddxcq
                       x_adwc2
                 }}]
Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
  = \ (@ a_adx0M)
      (ds_ddxco :: Int -> a_adx0M -> ShowS)
      _ [Occ=Dead]
      (ds2_ddxcq :: Int)
      (ds3_ddxcr :: Maybe a_adx0M) ->
      case ds3_ddxcr of {
        Nothing -> Data.Functor.Classes.$fShow1Maybe1;
        Just x_adwc2 ->
          case ds2_ddxcq of { GHC.Types.I# ww1_sdy35 ->
          Data.Functor.Classes.$wshowsUnaryWith
            @ a_adx0M
            ds_ddxco
            Data.Functor.Classes.$fRead1Maybe3
            ww1_sdy35
            x_adwc2
          }
      }

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
Data.Functor.Classes.$w$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Int -> a -> ShowS) -> [Maybe a] -> String -> String
[GblId,
 Arity=3,
 Str=<L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 120 0}]
Data.Functor.Classes.$w$cliftShowList2
  = \ (@ a_sdy3B)
      (w_sdy3C :: Int -> a_sdy3B -> ShowS)
      (w1_sdy3E :: [Maybe a_sdy3B])
      (w2_sdy3F :: String) ->
      GHC.Show.showList__
        @ (Maybe a_sdy3B)
        (\ (ds_ddxcr :: Maybe a_sdy3B) ->
           case ds_ddxcr of {
             Nothing -> Data.Functor.Classes.$fShow1Maybe1;
             Just x_adwc2 ->
               Data.Functor.Classes.$wshowsUnaryWith
                 @ a_sdy3B w_sdy3C Data.Functor.Classes.$fRead1Maybe3 0# x_adwc2
           })
        w1_sdy3E
        w2_sdy3F

-- RHS size: {terms: 9, types: 13, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Maybe_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Maybe a] -> ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sdy3B)
                 (w_sdy3C [Occ=Once] :: Int -> a_sdy3B -> ShowS)
                 _ [Occ=Dead]
                 (w2_sdy3E [Occ=Once] :: [Maybe a_sdy3B])
                 (w3_sdy3F [Occ=Once] :: String) ->
                 Data.Functor.Classes.$w$cliftShowList2
                   @ a_sdy3B w_sdy3C w2_sdy3E w3_sdy3F}]
Data.Functor.Classes.$fShow1Maybe_$cliftShowList
  = \ (@ a_sdy3B)
      (w_sdy3C :: Int -> a_sdy3B -> ShowS)
      _ [Occ=Dead]
      (w2_sdy3E :: [Maybe a_sdy3B])
      (w3_sdy3F :: String) ->
      Data.Functor.Classes.$w$cliftShowList2
        @ a_sdy3B w_sdy3C w2_sdy3E w3_sdy3F

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Classes.$fShow1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Show1 Maybe
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Functor.Classes.C:Show1 TYPE: Maybe
                                    Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
                                    Data.Functor.Classes.$fShow1Maybe_$cliftShowList]
Data.Functor.Classes.$fShow1Maybe
  = Data.Functor.Classes.C:Show1
      @ Maybe
      Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
      Data.Functor.Classes.$fShow1Maybe_$cliftShowList

-- RHS size: {terms: 46, types: 29, coercions: 0, joins: 0/2}
Data.Functor.Classes.$wshowsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> (Int -> b -> ShowS)
     -> String
     -> GHC.Prim.Int#
     -> a
     -> b
     -> ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0 0 0] 321 120}]
Data.Functor.Classes.$wshowsBinaryWith
  = \ (@ a_sdy3H)
      (@ b_sdy3I)
      (w_sdy3J :: Int -> a_sdy3H -> ShowS)
      (w1_sdy3K :: Int -> b_sdy3I -> ShowS)
      (w2_sdy3L :: String)
      (ww_sdy3R :: GHC.Prim.Int#)
      (w3_sdy3N :: a_sdy3H)
      (w4_sdy3O :: b_sdy3I) ->
      let {
        f_sdxrH [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sdxrH = w_sdy3J Data.Functor.Classes.$fRead1Const1 w3_sdy3N } in
      let {
        g_sdxrF [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sdxrF = w1_sdy3K Data.Functor.Classes.$fRead1Const1 w4_sdy3O } in
      case GHC.Prim.># ww_sdy3R 10# of {
        __DEFAULT ->
          \ (x_X7RDU :: String) ->
            ++
              @ Char
              w2_sdy3L
              (GHC.Types.:
                 @ Char
                 Data.Functor.Classes.showsUnaryWith1
                 (f_sdxrH
                    (GHC.Types.:
                       @ Char Data.Functor.Classes.showsUnaryWith1 (g_sdxrF x_X7RDU))));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (++
                 @ Char
                 w2_sdy3L
                 (GHC.Types.:
                    @ Char
                    Data.Functor.Classes.showsUnaryWith1
                    (f_sdxrH
                       (GHC.Types.:
                          @ Char
                          Data.Functor.Classes.showsUnaryWith1
                          (g_sdxrF (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))))
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
showsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Int -> a -> ShowS)
     -> (Int -> b -> ShowS) -> String -> Int -> a -> b -> ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy3H)
                 (@ b_sdy3I)
                 (w_sdy3J [Occ=Once] :: Int -> a_sdy3H -> ShowS)
                 (w1_sdy3K [Occ=Once] :: Int -> b_sdy3I -> ShowS)
                 (w2_sdy3L [Occ=Once] :: String)
                 (w3_sdy3M [Occ=Once!] :: Int)
                 (w4_sdy3N [Occ=Once] :: a_sdy3H)
                 (w5_sdy3O [Occ=Once] :: b_sdy3I) ->
                 case w3_sdy3M of { GHC.Types.I# ww1_sdy3R [Occ=Once] ->
                 Data.Functor.Classes.$wshowsBinaryWith
                   @ a_sdy3H
                   @ b_sdy3I
                   w_sdy3J
                   w1_sdy3K
                   w2_sdy3L
                   ww1_sdy3R
                   w4_sdy3N
                   w5_sdy3O
                 }}]
showsBinaryWith
  = \ (@ a_sdy3H)
      (@ b_sdy3I)
      (w_sdy3J :: Int -> a_sdy3H -> ShowS)
      (w1_sdy3K :: Int -> b_sdy3I -> ShowS)
      (w2_sdy3L :: String)
      (w3_sdy3M :: Int)
      (w4_sdy3N :: a_sdy3H)
      (w5_sdy3O :: b_sdy3I) ->
      case w3_sdy3M of { GHC.Types.I# ww1_sdy3R ->
      Data.Functor.Classes.$wshowsBinaryWith
        @ a_sdy3H
        @ b_sdy3I
        w_sdy3J
        w1_sdy3K
        w2_sdy3L
        ww1_sdy3R
        w4_sdy3N
        w5_sdy3O
      }

-- RHS size: {terms: 36, types: 52, coercions: 0, joins: 0/1}
readsUnary
  :: forall a t. Read a => String -> (a -> t) -> String -> ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 60 0 0] 220 10}]
readsUnary
  = \ (@ a_adwFr)
      (@ t_adwFs)
      ($dRead_adwFu :: Read a_adwFr)
      (name_adwe7 :: String)
      (cons_adwe8 :: a_adwFr -> t_adwFs)
      (kw_adwe9 :: String)
      (s_adwea :: String) ->
      case GHC.Base.eqString kw_adwe9 name_adwe7 of {
        False -> GHC.Types.[] @ (t_adwFs, String);
        True ->
          letrec {
            go_i7Jcj [Occ=LoopBreaker]
              :: [(a_adwFr, String)] -> [(t_adwFs, String)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i7Jcj
              = \ (ds_i7Jck :: [(a_adwFr, String)]) ->
                  case ds_i7Jck of {
                    [] -> GHC.Types.[] @ (t_adwFs, String);
                    : y_i7Jcp ys_i7Jcq ->
                      case y_i7Jcp of { (x_adweb, t1_adwec) ->
                      GHC.Types.:
                        @ (t_adwFs, String)
                        (cons_adwe8 x_adweb, t1_adwec)
                        (go_i7Jcj ys_i7Jcq)
                      }
                  }; } in
          go_i7Jcj
            (readsPrec
               @ a_adwFr $dRead_adwFu Data.Functor.Classes.$fRead1Const1 s_adwea)
      }

-- RHS size: {terms: 34, types: 19, coercions: 0, joins: 0/1}
Data.Functor.Classes.$wshowsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => String -> GHC.Prim.Int# -> a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0] 231 120}]
Data.Functor.Classes.$wshowsUnary
  = \ (@ a_sdy42)
      (w_sdy43 :: Show a_sdy42)
      (w1_sdy44 :: String)
      (ww_sdy49 :: GHC.Prim.Int#)
      (w2_sdy46 :: a_sdy42) ->
      let {
        g_sdxrx [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sdxrx
          = showsPrec
              @ a_sdy42 w_sdy43 Data.Functor.Classes.$fRead1Const1 w2_sdy46 } in
      case GHC.Prim.># ww_sdy49 10# of {
        __DEFAULT ->
          \ (x_X7RDL :: String) ->
            ++
              @ Char
              w1_sdy44
              (GHC.Types.:
                 @ Char Data.Functor.Classes.showsUnaryWith1 (g_sdxrx x_X7RDL));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (++
                 @ Char
                 w1_sdy44
                 (GHC.Types.:
                    @ Char
                    Data.Functor.Classes.showsUnaryWith1
                    (g_sdxrx (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))
      }

-- RHS size: {terms: 13, types: 10, coercions: 0, joins: 0/0}
showsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => String -> Int -> a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sdy42)
                 (w_sdy43 [Occ=Once] :: Show a_sdy42)
                 (w1_sdy44 [Occ=Once] :: String)
                 (w2_sdy45 [Occ=Once!] :: Int)
                 (w3_sdy46 [Occ=Once] :: a_sdy42) ->
                 case w2_sdy45 of { GHC.Types.I# ww1_sdy49 [Occ=Once] ->
                 Data.Functor.Classes.$wshowsUnary
                   @ a_sdy42 w_sdy43 w1_sdy44 ww1_sdy49 w3_sdy46
                 }}]
showsUnary
  = \ (@ a_sdy42)
      (w_sdy43 :: Show a_sdy42)
      (w1_sdy44 :: String)
      (w2_sdy45 :: Int)
      (w3_sdy46 :: a_sdy42) ->
      case w2_sdy45 of { GHC.Types.I# ww1_sdy49 ->
      Data.Functor.Classes.$wshowsUnary
        @ a_sdy42 w_sdy43 w1_sdy44 ww1_sdy49 w3_sdy46
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$trModule3
  = GHC.Types.TrNameS Data.Functor.Classes.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Data.Functor.Classes.$trModule2 = "Data.Functor.Classes"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$trModule1
  = GHC.Types.TrNameS Data.Functor.Classes.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Classes.$trModule
  = GHC.Types.Module
      Data.Functor.Classes.$trModule3 Data.Functor.Classes.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rdymB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rdymB
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq4 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Classes.$tcEq4
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* $krep_rdymB

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq7 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Classes.$tcEq7
  = GHC.Types.KindRepFun GHC.Types.krep$*->*->* $krep_rdymB

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$tcEq6 = "Eq1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq5 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcEq5
  = GHC.Types.TrNameS Data.Functor.Classes.$tcEq6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq1 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcEq1
  = GHC.Types.TyCon
      71749974434880567##
      7233443027070644957##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcEq5
      0#
      Data.Functor.Classes.$tcEq4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcOrd5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$tcOrd5 = "Ord1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcOrd4 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcOrd4
  = GHC.Types.TrNameS Data.Functor.Classes.$tcOrd5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcOrd1 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcOrd1
  = GHC.Types.TyCon
      11825914698899667233##
      4554948325937498991##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcOrd4
      0#
      Data.Functor.Classes.$tcEq4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcRead5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$tcRead5 = "Read1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcRead4 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcRead4
  = GHC.Types.TrNameS Data.Functor.Classes.$tcRead5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcRead1 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcRead1
  = GHC.Types.TyCon
      14547308444716217043##
      925634574698086715##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcRead4
      0#
      Data.Functor.Classes.$tcEq4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcShow5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$tcShow5 = "Show1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcShow4 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcShow4
  = GHC.Types.TrNameS Data.Functor.Classes.$tcShow5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcShow1 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcShow1
  = GHC.Types.TyCon
      4743290066722511112##
      6779909240154408836##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcShow4
      0#
      Data.Functor.Classes.$tcEq4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq9 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$tcEq9 = "Eq2"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq8 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcEq8
  = GHC.Types.TrNameS Data.Functor.Classes.$tcEq9

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcEq2 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcEq2
  = GHC.Types.TyCon
      16920549266159426738##
      13264288076834164909##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcEq8
      0#
      Data.Functor.Classes.$tcEq7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcOrd7 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Classes.$tcOrd7 = "Ord2"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcOrd6 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcOrd6
  = GHC.Types.TrNameS Data.Functor.Classes.$tcOrd7

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcOrd2 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcOrd2
  = GHC.Types.TyCon
      4167316048525678806##
      17649124474771181823##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcOrd6
      0#
      Data.Functor.Classes.$tcEq7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcRead7 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$tcRead7 = "Read2"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcRead6 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcRead6
  = GHC.Types.TrNameS Data.Functor.Classes.$tcRead7

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcRead2 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcRead2
  = GHC.Types.TyCon
      615267248700376470##
      8978126042197021701##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcRead6
      0#
      Data.Functor.Classes.$tcEq7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcShow7 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Classes.$tcShow7 = "Show2"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcShow6 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Classes.$tcShow6
  = GHC.Types.TrNameS Data.Functor.Classes.$tcShow7

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Classes.$tcShow2 :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Classes.$tcShow2
  = GHC.Types.TyCon
      11321900378419812635##
      1323607160578303441##
      Data.Functor.Classes.$trModule
      Data.Functor.Classes.$tcShow6
      0#
      Data.Functor.Classes.$tcEq7


