
==================== Output Cmm ====================
2018-03-16 16:12:06.392243696 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:06.393337319 UTC

[section ""data" . $fEq1Compose1_rgdPP_closure" {
     $fEq1Compose1_rgdPP_closure:
         const $fEq1Compose1_rgdPP_info;
 },
 $fEq1Compose1_rgdPP_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cge2B,
                       label: $fEq1Compose1_rgdPP_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge2B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge2F; else goto cge2E;
       cge2F: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $fEq1Compose1_rgdPP_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge2E: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgdQm::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgdQm::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.394461309 UTC

[section ""data" . Data.Functor.Compose.$fEq1Compose_closure" {
     Data.Functor.Compose.$fEq1Compose_closure:
         const Data.Functor.Compose.$fEq1Compose_info;
 },
 Data.Functor.Compose.$fEq1Compose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cge2K,
                       label: Data.Functor.Compose.$fEq1Compose_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge2K: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $fEq1Compose1_rgdPP_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.395612964 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure" {
     Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure:
         const Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info;
 },
 sat_sgdQx_entry() //  [R1]
         { info_tbl: [(cge2V,
                       label: sat_sgdQx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge2V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cge2W; else goto cge2X;
       cge2W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge2X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cge2Y,
                       label: Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge2Y: // global
           _sgdQw::P64 = R6;
           _sgdQv::P64 = R5;
           _sgdQu::P64 = R4;
           _sgdQt::P64 = R3;
           _sgdQs::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cge2Z; else goto cge30;
       cge30: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge32; else goto cge31;
       cge32: // global
           HpAlloc = 32;
           goto cge2Z;
       cge2Z: // global
           R6 = _sgdQw::P64;
           R5 = _sgdQv::P64;
           R4 = _sgdQu::P64;
           R3 = _sgdQt::P64;
           R2 = _sgdQs::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge31: // global
           I64[Hp - 24] = sat_sgdQx_info;
           P64[Hp - 8] = _sgdQt::P64;
           P64[Hp] = _sgdQu::P64;
           R2 = _sgdQs::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdQv::P64;
           P64[Sp - 8] = _sgdQw::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.397208964 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose1_closure" {
     Data.Functor.Compose.$fOrd1Compose1_closure:
         const Data.Functor.Compose.$fOrd1Compose1_info;
 },
 sat_sgdQD_entry() //  [R1]
         { info_tbl: [(cge3b,
                       label: sat_sgdQD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge3b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cge3c; else goto cge3d;
       cge3c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cge3e,
                       label: Data.Functor.Compose.$fOrd1Compose1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge3e: // global
           _sgdQC::P64 = R6;
           _sgdQB::P64 = R5;
           _sgdQA::P64 = R4;
           _sgdQz::P64 = R3;
           _sgdQy::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cge3f; else goto cge3g;
       cge3g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge3i; else goto cge3h;
       cge3i: // global
           HpAlloc = 32;
           goto cge3f;
       cge3f: // global
           R6 = _sgdQC::P64;
           R5 = _sgdQB::P64;
           R4 = _sgdQA::P64;
           R3 = _sgdQz::P64;
           R2 = _sgdQy::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge3h: // global
           I64[Hp - 24] = sat_sgdQD_info;
           P64[Hp - 8] = _sgdQz::P64;
           P64[Hp] = _sgdQA::P64;
           R2 = _sgdQy::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdQB::P64;
           P64[Sp - 8] = _sgdQC::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.398975847 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_closure" {
     Data.Functor.Compose.$fOrd1Compose_closure:
         const Data.Functor.Compose.$fOrd1Compose_info;
 },
 sat_sgdQH_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cge3s,
                       label: sat_sgdQH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge3s: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdQG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cge3A,
                       label: sat_sgdQG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge3A: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_entry() //  [R2, R3]
         { info_tbl: [(cge3E,
                       label: Data.Functor.Compose.$fOrd1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge3E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cge3I; else goto cge3H;
       cge3I: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrd1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge3H: // global
           I64[Hp - 64] = sat_sgdQH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdQG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.40030617 UTC

[section ""cstring" . Data.Functor.Compose.$fDataCompose7_bytes" {
     Data.Functor.Compose.$fDataCompose7_bytes:
         I8[] [67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.401036896 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose6_closure" {
     Data.Functor.Compose.$fDataCompose6_closure:
         const Data.Functor.Compose.$fDataCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose6_entry() //  [R1]
         { info_tbl: [(cge3P,
                       label: Data.Functor.Compose.$fDataCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge3P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cge3Q; else goto cge3R;
       cge3Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge3R: // global
           (_cge3M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cge3M::I64 == 0) goto cge3O; else goto cge3N;
       cge3O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cge3N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cge3M::I64;
           R2 = Data.Functor.Compose.$fDataCompose7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.401981976 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose2_closure" {
     Data.Functor.Compose.$fRead1Compose2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.40255819 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose1_closure" {
     Data.Functor.Compose.$fRead1Compose1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.404846546 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info;
         const 0;
 },
 sat_sgdQO_entry() //  [R1]
         { info_tbl: [(cge44,
                       label: sat_sgdQO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge44: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cge45; else goto cge46;
       cge45: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge46: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdQN_entry() //  [R1]
         { info_tbl: [(cge4b,
                       label: sat_sgdQN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge4b: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cge4c; else goto cge4d;
       cge4c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge4d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader_sgdQM_entry() //  [R1]
         { info_tbl: [(cge4e,
                       label: reader_sgdQM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge4e: // global
           _sgdQM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cge4f; else goto cge4g;
       cge4g: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cge4i; else goto cge4h;
       cge4i: // global
           HpAlloc = 80;
           goto cge4f;
       cge4f: // global
           R1 = _sgdQM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge4h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdQM::P64;
           _sgdQI::P64 = P64[_sgdQM::P64 + 16];
           _sgdQJ::P64 = P64[_sgdQM::P64 + 24];
           _sgdQK::P64 = P64[_sgdQM::P64 + 32];
           _sgdQL::P64 = P64[_sgdQM::P64 + 40];
           I64[Hp - 72] = sat_sgdQO_info;
           P64[Hp - 56] = _sgdQJ::P64;
           P64[Hp - 48] = _sgdQK::P64;
           P64[Hp - 40] = _sgdQL::P64;
           I64[Hp - 32] = sat_sgdQN_info;
           P64[Hp - 16] = _sgdQJ::P64;
           P64[Hp - 8] = _sgdQK::P64;
           P64[Hp] = _sgdQL::P64;
           R2 = _sgdQI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdQV_entry() //  [R1, R2]
         { info_tbl: [(cge4C,
                       label: sat_sgdQV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge4C: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdQW_entry() //  [R1, R2]
         { info_tbl: [(cge4F,
                       label: sat_sgdQW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge4F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cge4J; else goto cge4I;
       cge4J: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cge4I: // global
           _sgdQM::P64 = P64[R1 + 7];
           _sgdQR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sgdQV_info;
           P64[Hp] = _sgdQR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Compose.$fRead1Compose1_closure+1;
           R1 = _sgdQM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sgdQP_entry() //  [R1, R2, R3]
         { info_tbl: [(cge4N,
                       label: $wlvl_sgdQP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge4N: // global
           _sgdQR::P64 = R3;
           _sgdQQ::I64 = R2;
           _sgdQP::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cge4O; else goto cge4P;
       cge4P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cge4R; else goto cge4Q;
       cge4R: // global
           HpAlloc = 24;
           goto cge4O;
       cge4O: // global
           R3 = _sgdQR::P64;
           R2 = _sgdQQ::I64;
           R1 = _sgdQP::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge4Q: // global
           if (%MO_S_Gt_W64(_sgdQQ::I64, 10)) goto cge4L; else goto cge4M;
       cge4L: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cge4M: // global
           _sgdQM::P64 = P64[_sgdQP::P64 + 6];
           I64[Hp - 16] = sat_sgdQW_info;
           P64[Hp - 8] = _sgdQM::P64;
           P64[Hp] = _sgdQR::P64;
           I64[Sp - 8] = block_cge4S_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Compose.$fRead1Compose2_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cge4S() //  [R1]
         { info_tbl: [(cge4S,
                       label: block_cge4S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge4S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cge4X; else goto cge4W;
       cge4X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cge4W: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sgdQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cge56,
                       label: lvl8_sgdQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge56: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cge57; else goto cge58;
       cge57: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge58: // global
           I64[Sp - 24] = block_cge53_info;
           _sgdQP::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sgdQP::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uge5c; else goto cge54;
       uge5c: // global
           call _cge53(R1) args: 0, res: 0, upd: 0;
       cge54: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cge53() //  [R1]
         { info_tbl: [(cge53,
                       label: block_cge53_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge53: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sgdQP_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdR6_entry() //  [R1, R2, R3]
         { info_tbl: [(cge5i,
                       label: sat_sgdR6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5i: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cge5l,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5l: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cge5p; else goto cge5o;
       cge5p: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge5o: // global
           I64[Hp - 88] = reader_sgdQM_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = $wlvl_sgdQP_info;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sgdQZ_info;
           P64[Hp - 16] = Hp - 38;
           I64[Hp - 8] = sat_sgdR6_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.409914135 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info;
         const 0;
 },
 sat_sgdRh_entry() //  [R1, R2, R3]
         { info_tbl: [(cge5H,
                       label: sat_sgdRh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cge5I; else goto cge5J;
       cge5I: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge5J: // global
           I64[Sp - 8] = block_cge5E_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cge5E() //  [R1]
         { info_tbl: [(cge5E,
                       label: block_cge5E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cge5M; else goto cge5L;
       cge5M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cge5L: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRc_entry() //  [R1, R2]
         { info_tbl: [(cge5S,
                       label: sat_sgdRc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5S: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sgdRb_entry() //  [R1]
         { info_tbl: [(cge5V,
                       label: ds_sgdRb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5V: // global
           _sgdRb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cge5W; else goto cge5X;
       cge5X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge5Z; else goto cge5Y;
       cge5Z: // global
           HpAlloc = 32;
           goto cge5W;
       cge5W: // global
           R1 = _sgdRb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge5Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdRb::P64;
           _sgdR7::P64 = P64[_sgdRb::P64 + 16];
           _sgdR8::P64 = P64[_sgdRb::P64 + 24];
           _sgdR9::P64 = P64[_sgdRb::P64 + 32];
           _sgdRa::P64 = P64[_sgdRb::P64 + 40];
           I64[Hp - 24] = sat_sgdRh_info;
           P64[Hp - 16] = _sgdRa::P64;
           I64[Hp - 8] = sat_sgdRc_info;
           P64[Hp] = _sgdR9::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sgdR8::P64;
           R2 = _sgdR7::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRj_entry() //  [R1]
         { info_tbl: [(cge69,
                       label: sat_sgdRj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge69: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cge6a; else goto cge6b;
       cge6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRk_entry() //  [R1, R2]
         { info_tbl: [(cge6c,
                       label: sat_sgdRk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge6c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge6g; else goto cge6f;
       cge6g: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cge6f: // global
           _sgdRb::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgdRj_info;
           P64[Hp - 8] = _sgdRb::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cge6h,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge6h: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cge6l; else goto cge6k;
       cge6l: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge6k: // global
           I64[Hp - 56] = ds_sgdRb_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sgdRk_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.412894975 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info;
         const 0;
 },
 sat_sgdRp_entry() //  [R1]
         { info_tbl: [(cge6u,
                       label: sat_sgdRp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge6u: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cge6x,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge6x: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cge6B; else goto cge6A;
       cge6B: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge6A: // global
           I64[Hp - 40] = sat_sgdRp_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.415111909 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_closure" {
     Data.Functor.Compose.$fRead1Compose_closure:
         const Data.Functor.Compose.$fRead1Compose_info;
         const 0;
 },
 sat_sgdRv_entry() //  [R1, R2, R3]
         { info_tbl: [(cge6L,
                       label: sat_sgdRv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge6L: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRu_entry() //  [R1, R2, R3]
         { info_tbl: [(cge6T,
                       label: sat_sgdRu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge6T: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRt_entry() //  [R1]
         { info_tbl: [(cge70,
                       label: sat_sgdRt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cge71; else goto cge72;
       cge71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRs_entry() //  [R1, R2, R3]
         { info_tbl: [(cge78,
                       label: sat_sgdRs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge78: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_entry() //  [R2, R3]
         { info_tbl: [(cge7c,
                       label: Data.Functor.Compose.$fRead1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7c: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cge7g; else goto cge7f;
       cge7g: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge7f: // global
           I64[Hp - 136] = sat_sgdRv_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgdRu_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sgdRt_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sgdRs_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_info;
         const 0;
 },
 sat_sgdRy_entry() //  [R1]
         { info_tbl: [(cge7p,
                       label: sat_sgdRy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cge7q; else goto cge7r;
       cge7q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge7r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cge7s,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge7w; else goto cge7v;
       cge7w: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge7v: // global
           I64[Hp - 24] = sat_sgdRy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.418376239 UTC

[section ""data" . Data.Functor.Compose.$w$cliftShowsPrec_closure" {
     Data.Functor.Compose.$w$cliftShowsPrec_closure:
         const Data.Functor.Compose.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7y: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgdRG_entry() //  [R1]
         { info_tbl: [(cge7K,
                       label: sat_sgdRG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cge7L; else goto cge7M;
       cge7L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge7M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdRF_entry() //  [R1]
         { info_tbl: [(cge7R,
                       label: sat_sgdRF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cge7S; else goto cge7T;
       cge7S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge7T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdRH_entry() //  [R1]
         { info_tbl: [(cge7U,
                       label: sat_sgdRH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7U: // global
           _sgdRH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cge7V; else goto cge7W;
       cge7W: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cge7Y; else goto cge7X;
       cge7Y: // global
           HpAlloc = 80;
           goto cge7V;
       cge7V: // global
           R1 = _sgdRH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge7X: // global
           _sgdRz::P64 = P64[_sgdRH::P64 + 16];
           _sgdRA::P64 = P64[_sgdRH::P64 + 24];
           _sgdRB::P64 = P64[_sgdRH::P64 + 32];
           _sgdRC::P64 = P64[_sgdRH::P64 + 40];
           I64[Hp - 72] = sat_sgdRG_info;
           P64[Hp - 56] = _sgdRA::P64;
           P64[Hp - 48] = _sgdRB::P64;
           P64[Hp - 40] = _sgdRC::P64;
           I64[Hp - 32] = sat_sgdRF_info;
           P64[Hp - 16] = _sgdRA::P64;
           P64[Hp - 8] = _sgdRB::P64;
           P64[Hp] = _sgdRC::P64;
           R2 = _sgdRz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cge7Z,
                       label: Data.Functor.Compose.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge7Z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cge83; else goto cge82;
       cge83: // global
           HpAlloc = 48;
           R1 = Data.Functor.Compose.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cge82: // global
           I64[Hp - 40] = sat_sgdRH_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R5 = P64[Sp];
           R4 = R6;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = Hp - 40;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.420969582 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cge8b,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge8b: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cge8c; else goto cge8d;
       cge8c: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cge8d: // global
           I64[Sp - 40] = block_cge88_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uge8h; else goto cge89;
       uge8h: // global
           call _cge88(R1) args: 0, res: 0, upd: 0;
       cge89: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cge88() //  [R1]
         { info_tbl: [(cge88,
                       label: block_cge88_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge88: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.422329461 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose3_closure" {
     Data.Functor.Compose.$fDataCompose3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.423402424 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_info;
         const 0;
 },
 sat_sgdRX_entry() //  [R1, R2]
         { info_tbl: [(cge8r,
                       label: sat_sgdRX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge8r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cge8s; else goto cge8t;
       cge8s: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cge8t: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgdRW::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgdRW::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cge8u,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge8u: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cge8y; else goto cge8x;
       cge8y: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cge8x: // global
           I64[Hp - 32] = sat_sgdRX_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.425375333 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_closure" {
     Data.Functor.Compose.$fShow1Compose_closure:
         const Data.Functor.Compose.$fShow1Compose_info;
         const 0;
 },
 sat_sgdS1_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cge8I,
                       label: sat_sgdS1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge8I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cge8J; else goto cge8K;
       cge8J: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge8K: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgdS0_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cge8Q,
                       label: sat_sgdS0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge8Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cge8R; else goto cge8S;
       cge8R: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge8S: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_entry() //  [R2, R3]
         { info_tbl: [(cge8U,
                       label: Data.Functor.Compose.$fShow1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge8U: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cge8Y; else goto cge8X;
       cge8Y: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cge8X: // global
           I64[Hp - 64] = sat_sgdS1_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdS0_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.427627913 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c==_closure" {
     Data.Functor.Compose.$fEqCompose_$c==_closure:
         const Data.Functor.Compose.$fEqCompose_$c==_info;
 },
 sat_sgdS7_entry() //  [R1]
         { info_tbl: [(cge9b,
                       label: sat_sgdS7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cge9c; else goto cge9d;
       cge9c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge9d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdS8_entry() //  [R1]
         { info_tbl: [(cge9e,
                       label: sat_sgdS8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9e: // global
           _sgdS8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cge9f; else goto cge9g;
       cge9g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cge9i; else goto cge9h;
       cge9i: // global
           HpAlloc = 24;
           goto cge9f;
       cge9f: // global
           R1 = _sgdS8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge9h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdS8::P64;
           _sgdS3::P64 = P64[_sgdS8::P64 + 16];
           _sgdS4::P64 = P64[_sgdS8::P64 + 24];
           I64[Hp - 16] = sat_sgdS7_info;
           P64[Hp] = _sgdS4::P64;
           R2 = Hp - 16;
           R1 = _sgdS3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cge9j,
                       label: Data.Functor.Compose.$fEqCompose_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge9n; else goto cge9m;
       cge9n: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge9m: // global
           I64[Hp - 24] = sat_sgdS8_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgdS2::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgdS2::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.432909985 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c/=_closure" {
     Data.Functor.Compose.$fEqCompose_$c/=_closure:
         const Data.Functor.Compose.$fEqCompose_$c/=_info;
 },
 sat_sgdSe_entry() //  [R1]
         { info_tbl: [(cge9A,
                       label: sat_sgdSe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cge9B; else goto cge9C;
       cge9B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge9C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSf_entry() //  [R1]
         { info_tbl: [(cge9D,
                       label: sat_sgdSf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9D: // global
           _sgdSf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cge9E; else goto cge9F;
       cge9F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cge9H; else goto cge9G;
       cge9H: // global
           HpAlloc = 24;
           goto cge9E;
       cge9E: // global
           R1 = _sgdSf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSf::P64;
           _sgdSa::P64 = P64[_sgdSf::P64 + 16];
           _sgdSb::P64 = P64[_sgdSf::P64 + 24];
           I64[Hp - 16] = sat_sgdSe_info;
           P64[Hp] = _sgdSb::P64;
           R2 = Hp - 16;
           R1 = _sgdSa::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cge9O,
                       label: Data.Functor.Compose.$fEqCompose_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9O: // global
           _sgdSd::P64 = R6;
           _sgdSc::P64 = R5;
           _sgdSb::P64 = R4;
           _sgdSa::P64 = R3;
           _sgdS9::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cge9P; else goto cge9Q;
       cge9Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cge9S; else goto cge9R;
       cge9S: // global
           HpAlloc = 32;
           goto cge9P;
       cge9P: // global
           R6 = _sgdSd::P64;
           R5 = _sgdSc::P64;
           R4 = _sgdSb::P64;
           R3 = _sgdSa::P64;
           R2 = _sgdS9::P64;
           R1 = Data.Functor.Compose.$fEqCompose_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cge9R: // global
           I64[Hp - 24] = sat_sgdSf_info;
           P64[Hp - 8] = _sgdSa::P64;
           P64[Hp] = _sgdSb::P64;
           I64[Sp - 8] = block_cge9I_info;
           R4 = _sgdSd::P64;
           R3 = _sgdSc::P64;
           R2 = Hp - 24;
           R1 = _sgdS9::P64;
           Sp = Sp - 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cge9I() //  [R1]
         { info_tbl: [(cge9I,
                       label: block_cge9I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge9I: // global
           if (R1 & 7 == 1) goto cge9L; else goto cge9M;
       cge9L: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cge9M: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.435140643 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_closure" {
     Data.Functor.Compose.$fEqCompose_closure:
         const Data.Functor.Compose.$fEqCompose_info;
 },
 sat_sgdSl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgea8,
                       label: sat_sgdSl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgea8: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdSk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeag,
                       label: sat_sgdSk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeag: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fEqCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgeak,
                       label: Data.Functor.Compose.$fEqCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeak: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgeao; else goto cgean;
       cgeao: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgean: // global
           I64[Hp - 80] = sat_sgdSl_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgdSk_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.436920765 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$ccompare_closure" {
     Data.Functor.Compose.$fOrdCompose_$ccompare_closure:
         const Data.Functor.Compose.$fOrdCompose_$ccompare_info;
 },
 sat_sgdSr_entry() //  [R1]
         { info_tbl: [(cgeaB,
                       label: sat_sgdSr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeaB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeaC; else goto cgeaD;
       cgeaC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeaD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSs_entry() //  [R1]
         { info_tbl: [(cgeaE,
                       label: sat_sgdSs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeaE: // global
           _sgdSs::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeaF; else goto cgeaG;
       cgeaG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeaI; else goto cgeaH;
       cgeaI: // global
           HpAlloc = 24;
           goto cgeaF;
       cgeaF: // global
           R1 = _sgdSs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeaH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSs::P64;
           _sgdSn::P64 = P64[_sgdSs::P64 + 16];
           _sgdSo::P64 = P64[_sgdSs::P64 + 24];
           I64[Hp - 16] = sat_sgdSr_info;
           P64[Hp] = _sgdSo::P64;
           R2 = _sgdSn::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgeaJ,
                       label: Data.Functor.Compose.$fOrdCompose_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeaJ: // global
           _sgdSq::P64 = R6;
           _sgdSp::P64 = R5;
           _sgdSo::P64 = R4;
           _sgdSn::P64 = R3;
           _sgdSm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeaK; else goto cgeaL;
       cgeaL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeaN; else goto cgeaM;
       cgeaN: // global
           HpAlloc = 32;
           goto cgeaK;
       cgeaK: // global
           R6 = _sgdSq::P64;
           R5 = _sgdSp::P64;
           R4 = _sgdSo::P64;
           R3 = _sgdSn::P64;
           R2 = _sgdSm::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeaM: // global
           I64[Hp - 24] = sat_sgdSs_info;
           P64[Hp - 8] = _sgdSn::P64;
           P64[Hp] = _sgdSo::P64;
           R2 = _sgdSm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdSp::P64;
           P64[Sp - 8] = _sgdSq::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.439027093 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure" {
     Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure:
         const Data.Functor.Compose.$fOrdCompose_$cp1Ord_info;
 },
 sat_sgdSy_entry() //  [R1]
         { info_tbl: [(cgeaW,
                       label: sat_sgdSy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeaW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeaX; else goto cgeaY;
       cgeaX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeaY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSx_entry() //  [R1]
         { info_tbl: [(cgeb3,
                       label: sat_sgdSx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeb3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeb4; else goto cgeb5;
       cgeb4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeb5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSw_entry() //  [R1]
         { info_tbl: [(cgeba,
                       label: sat_sgdSw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeba: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgebb; else goto cgebc;
       cgebb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgebc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cgebd,
                       label: Data.Functor.Compose.$fOrdCompose_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgebd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgebh; else goto cgebg;
       cgebh: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgebg: // global
           I64[Hp - 64] = sat_sgdSy_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgdSx_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdSw_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fEqCompose_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.441141911 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<_info;
 },
 sat_sgdSE_entry() //  [R1]
         { info_tbl: [(cgebu,
                       label: sat_sgdSE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgebu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgebv; else goto cgebw;
       cgebv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgebw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSF_entry() //  [R1]
         { info_tbl: [(cgebx,
                       label: sat_sgdSF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgebx: // global
           _sgdSF::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeby; else goto cgebz;
       cgebz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgebB; else goto cgebA;
       cgebB: // global
           HpAlloc = 24;
           goto cgeby;
       cgeby: // global
           R1 = _sgdSF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgebA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSF::P64;
           _sgdSA::P64 = P64[_sgdSF::P64 + 16];
           _sgdSB::P64 = P64[_sgdSF::P64 + 24];
           I64[Hp - 16] = sat_sgdSE_info;
           P64[Hp] = _sgdSB::P64;
           R2 = _sgdSA::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgebI,
                       label: Data.Functor.Compose.$fOrdCompose_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgebI: // global
           _sgdSD::P64 = R6;
           _sgdSC::P64 = R5;
           _sgdSB::P64 = R4;
           _sgdSA::P64 = R3;
           _sgdSz::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgebJ; else goto cgebK;
       cgebK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgebM; else goto cgebL;
       cgebM: // global
           HpAlloc = 32;
           goto cgebJ;
       cgebJ: // global
           R6 = _sgdSD::P64;
           R5 = _sgdSC::P64;
           R4 = _sgdSB::P64;
           R3 = _sgdSA::P64;
           R2 = _sgdSz::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgebL: // global
           I64[Hp - 24] = sat_sgdSF_info;
           P64[Hp - 8] = _sgdSA::P64;
           P64[Hp] = _sgdSB::P64;
           I64[Sp - 8] = block_cgebC_info;
           R2 = _sgdSz::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSC::P64;
           P64[Sp - 16] = _sgdSD::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgebC() //  [R1]
         { info_tbl: [(cgebC,
                       label: block_cgebC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgebC: // global
           if (R1 & 7 == 1) goto cgebG; else goto cgebF;
       cgebG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgebF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.443567662 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>=_info;
 },
 sat_sgdSM_entry() //  [R1]
         { info_tbl: [(cgec5,
                       label: sat_sgdSM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgec5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgec6; else goto cgec7;
       cgec6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgec7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSN_entry() //  [R1]
         { info_tbl: [(cgec8,
                       label: sat_sgdSN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgec8: // global
           _sgdSN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgec9; else goto cgeca;
       cgeca: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgecc; else goto cgecb;
       cgecc: // global
           HpAlloc = 24;
           goto cgec9;
       cgec9: // global
           R1 = _sgdSN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgecb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSN::P64;
           _sgdSI::P64 = P64[_sgdSN::P64 + 16];
           _sgdSJ::P64 = P64[_sgdSN::P64 + 24];
           I64[Hp - 16] = sat_sgdSM_info;
           P64[Hp] = _sgdSJ::P64;
           R2 = _sgdSI::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgecj,
                       label: Data.Functor.Compose.$fOrdCompose_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgecj: // global
           _sgdSL::P64 = R6;
           _sgdSK::P64 = R5;
           _sgdSJ::P64 = R4;
           _sgdSI::P64 = R3;
           _sgdSH::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeck; else goto cgecl;
       cgecl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgecn; else goto cgecm;
       cgecn: // global
           HpAlloc = 32;
           goto cgeck;
       cgeck: // global
           R6 = _sgdSL::P64;
           R5 = _sgdSK::P64;
           R4 = _sgdSJ::P64;
           R3 = _sgdSI::P64;
           R2 = _sgdSH::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgecm: // global
           I64[Hp - 24] = sat_sgdSN_info;
           P64[Hp - 8] = _sgdSI::P64;
           P64[Hp] = _sgdSJ::P64;
           I64[Sp - 8] = block_cgecd_info;
           R2 = _sgdSH::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSK::P64;
           P64[Sp - 16] = _sgdSL::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgecd() //  [R1]
         { info_tbl: [(cgecd,
                       label: block_cgecd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgecd: // global
           if (R1 & 7 == 1) goto cgech; else goto cgecg;
       cgech: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgecg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.446058821 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>_info;
 },
 sat_sgdSU_entry() //  [R1]
         { info_tbl: [(cgecG,
                       label: sat_sgdSU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgecG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgecH; else goto cgecI;
       cgecH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgecI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSV_entry() //  [R1]
         { info_tbl: [(cgecJ,
                       label: sat_sgdSV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgecJ: // global
           _sgdSV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgecK; else goto cgecL;
       cgecL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgecN; else goto cgecM;
       cgecN: // global
           HpAlloc = 24;
           goto cgecK;
       cgecK: // global
           R1 = _sgdSV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgecM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSV::P64;
           _sgdSQ::P64 = P64[_sgdSV::P64 + 16];
           _sgdSR::P64 = P64[_sgdSV::P64 + 24];
           I64[Hp - 16] = sat_sgdSU_info;
           P64[Hp] = _sgdSR::P64;
           R2 = _sgdSQ::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgecU,
                       label: Data.Functor.Compose.$fOrdCompose_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgecU: // global
           _sgdST::P64 = R6;
           _sgdSS::P64 = R5;
           _sgdSR::P64 = R4;
           _sgdSQ::P64 = R3;
           _sgdSP::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgecV; else goto cgecW;
       cgecW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgecY; else goto cgecX;
       cgecY: // global
           HpAlloc = 32;
           goto cgecV;
       cgecV: // global
           R6 = _sgdST::P64;
           R5 = _sgdSS::P64;
           R4 = _sgdSR::P64;
           R3 = _sgdSQ::P64;
           R2 = _sgdSP::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgecX: // global
           I64[Hp - 24] = sat_sgdSV_info;
           P64[Hp - 8] = _sgdSQ::P64;
           P64[Hp] = _sgdSR::P64;
           I64[Sp - 8] = block_cgecO_info;
           R2 = _sgdSP::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSS::P64;
           P64[Sp - 16] = _sgdST::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgecO() //  [R1]
         { info_tbl: [(cgecO,
                       label: block_cgecO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgecO: // global
           if (R1 & 7 == 3) goto cgecS; else goto cgecR;
       cgecS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgecR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.448357642 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<=_info;
 },
 sat_sgdT2_entry() //  [R1]
         { info_tbl: [(cgedh,
                       label: sat_sgdT2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgedh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgedi; else goto cgedj;
       cgedi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgedj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdT3_entry() //  [R1]
         { info_tbl: [(cgedk,
                       label: sat_sgdT3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgedk: // global
           _sgdT3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgedl; else goto cgedm;
       cgedm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgedo; else goto cgedn;
       cgedo: // global
           HpAlloc = 24;
           goto cgedl;
       cgedl: // global
           R1 = _sgdT3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgedn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdT3::P64;
           _sgdSY::P64 = P64[_sgdT3::P64 + 16];
           _sgdSZ::P64 = P64[_sgdT3::P64 + 24];
           I64[Hp - 16] = sat_sgdT2_info;
           P64[Hp] = _sgdSZ::P64;
           R2 = _sgdSY::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgedv,
                       label: Data.Functor.Compose.$fOrdCompose_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgedv: // global
           _sgdT1::P64 = R6;
           _sgdT0::P64 = R5;
           _sgdSZ::P64 = R4;
           _sgdSY::P64 = R3;
           _sgdSX::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgedw; else goto cgedx;
       cgedx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgedz; else goto cgedy;
       cgedz: // global
           HpAlloc = 32;
           goto cgedw;
       cgedw: // global
           R6 = _sgdT1::P64;
           R5 = _sgdT0::P64;
           R4 = _sgdSZ::P64;
           R3 = _sgdSY::P64;
           R2 = _sgdSX::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgedy: // global
           I64[Hp - 24] = sat_sgdT3_info;
           P64[Hp - 8] = _sgdSY::P64;
           P64[Hp] = _sgdSZ::P64;
           I64[Sp - 8] = block_cgedp_info;
           R2 = _sgdSX::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdT0::P64;
           P64[Sp - 16] = _sgdT1::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgedp() //  [R1]
         { info_tbl: [(cgedp,
                       label: block_cgedp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgedp: // global
           if (R1 & 7 == 3) goto cgedt; else goto cgeds;
       cgedt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgeds: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.450716314 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmax_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmax_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmax_info;
 },
 sat_sgdTa_entry() //  [R1]
         { info_tbl: [(cgedS,
                       label: sat_sgdTa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgedS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgedT; else goto cgedU;
       cgedT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgedU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTb_entry() //  [R1]
         { info_tbl: [(cgedV,
                       label: sat_sgdTb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgedV: // global
           _sgdTb::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgedW; else goto cgedX;
       cgedX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgedZ; else goto cgedY;
       cgedZ: // global
           HpAlloc = 24;
           goto cgedW;
       cgedW: // global
           R1 = _sgdTb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgedY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTb::P64;
           _sgdT6::P64 = P64[_sgdTb::P64 + 16];
           _sgdT7::P64 = P64[_sgdTb::P64 + 24];
           I64[Hp - 16] = sat_sgdTa_info;
           P64[Hp] = _sgdT7::P64;
           R2 = _sgdT6::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgee6,
                       label: Data.Functor.Compose.$fOrdCompose_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgee6: // global
           _sgdT9::P64 = R6;
           _sgdT8::P64 = R5;
           _sgdT7::P64 = R4;
           _sgdT6::P64 = R3;
           _sgdT5::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgee7; else goto cgee8;
       cgee8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeea; else goto cgee9;
       cgeea: // global
           HpAlloc = 32;
           goto cgee7;
       cgee7: // global
           R6 = _sgdT9::P64;
           R5 = _sgdT8::P64;
           R4 = _sgdT7::P64;
           R3 = _sgdT6::P64;
           R2 = _sgdT5::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgee9: // global
           I64[Hp - 24] = sat_sgdTb_info;
           P64[Hp - 8] = _sgdT6::P64;
           P64[Hp] = _sgdT7::P64;
           I64[Sp - 24] = block_cgee0_info;
           R2 = _sgdT5::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgdT8::P64;
           P64[Sp - 32] = _sgdT9::P64;
           P64[Sp - 16] = _sgdT8::P64;
           P64[Sp - 8] = _sgdT9::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgee0() //  [R1]
         { info_tbl: [(cgee0,
                       label: block_cgee0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgee0: // global
           if (R1 & 7 == 3) goto cgee4; else goto cgee3;
       cgee4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgee3: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.453083907 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmin_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmin_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmin_info;
 },
 sat_sgdTi_entry() //  [R1]
         { info_tbl: [(cgeet,
                       label: sat_sgdTi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeet: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeeu; else goto cgeev;
       cgeeu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeev: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTj_entry() //  [R1]
         { info_tbl: [(cgeew,
                       label: sat_sgdTj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeew: // global
           _sgdTj::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeex; else goto cgeey;
       cgeey: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeeA; else goto cgeez;
       cgeeA: // global
           HpAlloc = 24;
           goto cgeex;
       cgeex: // global
           R1 = _sgdTj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeez: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTj::P64;
           _sgdTe::P64 = P64[_sgdTj::P64 + 16];
           _sgdTf::P64 = P64[_sgdTj::P64 + 24];
           I64[Hp - 16] = sat_sgdTi_info;
           P64[Hp] = _sgdTf::P64;
           R2 = _sgdTe::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgeeH,
                       label: Data.Functor.Compose.$fOrdCompose_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeeH: // global
           _sgdTh::P64 = R6;
           _sgdTg::P64 = R5;
           _sgdTf::P64 = R4;
           _sgdTe::P64 = R3;
           _sgdTd::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgeeI; else goto cgeeJ;
       cgeeJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeeL; else goto cgeeK;
       cgeeL: // global
           HpAlloc = 32;
           goto cgeeI;
       cgeeI: // global
           R6 = _sgdTh::P64;
           R5 = _sgdTg::P64;
           R4 = _sgdTf::P64;
           R3 = _sgdTe::P64;
           R2 = _sgdTd::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeeK: // global
           I64[Hp - 24] = sat_sgdTj_info;
           P64[Hp - 8] = _sgdTe::P64;
           P64[Hp] = _sgdTf::P64;
           I64[Sp - 24] = block_cgeeB_info;
           R2 = _sgdTd::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgdTg::P64;
           P64[Sp - 32] = _sgdTh::P64;
           P64[Sp - 16] = _sgdTg::P64;
           P64[Sp - 8] = _sgdTh::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgeeB() //  [R1]
         { info_tbl: [(cgeeB,
                       label: block_cgeeB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeeB: // global
           if (R1 & 7 == 3) goto cgeeF; else goto cgeeE;
       cgeeF: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgeeE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.456303832 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_closure" {
     Data.Functor.Compose.$fOrdCompose_closure:
         const Data.Functor.Compose.$fOrdCompose_info;
 },
 sat_sgdTv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgef1,
                       label: sat_sgdTv_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgef1: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTu_entry() //  [R1, R2, R3]
         { info_tbl: [(cgef9,
                       label: sat_sgdTu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgef9: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTt_entry() //  [R1, R2, R3]
         { info_tbl: [(cgefh,
                       label: sat_sgdTt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefh: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTs_entry() //  [R1, R2, R3]
         { info_tbl: [(cgefp,
                       label: sat_sgdTs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefp: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTr_entry() //  [R1, R2, R3]
         { info_tbl: [(cgefx,
                       label: sat_sgdTr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefx: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTq_entry() //  [R1, R2, R3]
         { info_tbl: [(cgefF,
                       label: sat_sgdTq_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefF: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTp_entry() //  [R1, R2, R3]
         { info_tbl: [(cgefN,
                       label: sat_sgdTp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefN: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTo_entry() //  [R1]
         { info_tbl: [(cgefU,
                       label: sat_sgdTo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgefV; else goto cgefW;
       cgefV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgefW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgefY,
                       label: Data.Functor.Compose.$fOrdCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgefY: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cgeg2; else goto cgeg1;
       cgeg2: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeg1: // global
           I64[Hp - 328] = sat_sgdTv_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sgdTu_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sgdTt_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sgdTs_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sgdTr_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sgdTq_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sgdTp_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sgdTo_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.459550462 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadPrec_info;
         const 0;
 },
 sat_sgdTA_entry() //  [R1]
         { info_tbl: [(cgegb,
                       label: sat_sgdTA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgegb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgegc; else goto cgegd;
       cgegc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgegd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTz_entry() //  [R1]
         { info_tbl: [(cgegi,
                       label: sat_sgdTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgegi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgegj; else goto cgegk;
       cgegj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgegk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgegl,
                       label: Data.Functor.Compose.$fReadCompose_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgegl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgegp; else goto cgego;
       cgegp: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgego: // global
           I64[Hp - 40] = sat_sgdTA_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgdTz_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.46194864 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadsPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadsPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_info;
         const 0;
 },
 sat_sgdTG_entry() //  [R1]
         { info_tbl: [(cgegC,
                       label: sat_sgdTG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgegC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgegD; else goto cgegE;
       cgegD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgegE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTF_entry() //  [R1]
         { info_tbl: [(cgegJ,
                       label: sat_sgdTF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgegJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgegK; else goto cgegL;
       cgegK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgegL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sgdTE_entry() //  [R1]
         { info_tbl: [(cgegM,
                       label: ds_sgdTE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgegM: // global
           _sgdTE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgegN; else goto cgegO;
       cgegO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgegQ; else goto cgegP;
       cgegQ: // global
           HpAlloc = 48;
           goto cgegN;
       cgegN: // global
           R1 = _sgdTE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgegP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTE::P64;
           _sgdTB::P64 = P64[_sgdTE::P64 + 16];
           _sgdTC::P64 = P64[_sgdTE::P64 + 24];
           _sgdTD::P64 = P64[_sgdTE::P64 + 32];
           I64[Hp - 40] = sat_sgdTG_info;
           P64[Hp - 24] = _sgdTD::P64;
           I64[Hp - 16] = sat_sgdTF_info;
           P64[Hp] = _sgdTD::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgdTC::P64;
           R2 = _sgdTB::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTI_entry() //  [R1]
         { info_tbl: [(cgeh0,
                       label: sat_sgdTI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeh0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeh1; else goto cgeh2;
       cgeh1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeh2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTJ_entry() //  [R1, R2]
         { info_tbl: [(cgeh3,
                       label: sat_sgdTJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeh3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeh7; else goto cgeh6;
       cgeh7: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeh6: // global
           _sgdTE::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgdTI_info;
           P64[Hp - 8] = _sgdTE::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgeh8,
                       label: Data.Functor.Compose.$fReadCompose_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeh8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgehc; else goto cgehb;
       cgehc: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgehb: // global
           I64[Hp - 48] = ds_sgdTE_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sgdTJ_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.464643325 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadListPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadListPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_info;
         const 0;
 },
 sat_sgdTO_entry() //  [R1]
         { info_tbl: [(cgehp,
                       label: sat_sgdTO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgehp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgehq; else goto cgehr;
       cgehq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgehr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTN_entry() //  [R1]
         { info_tbl: [(cgehw,
                       label: sat_sgdTN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgehw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgehx; else goto cgehy;
       cgehx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgehy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTP_entry() //  [R1]
         { info_tbl: [(cgehz,
                       label: sat_sgdTP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgehz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgehD; else goto cgehC;
       cgehD: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgehC: // global
           _sgdTK::P64 = P64[R1 + 16];
           _sgdTL::P64 = P64[R1 + 24];
           _sgdTM::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sgdTO_info;
           P64[Hp - 24] = _sgdTM::P64;
           I64[Hp - 16] = sat_sgdTN_info;
           P64[Hp] = _sgdTM::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgdTL::P64;
           R2 = _sgdTK::P64;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgehE,
                       label: Data.Functor.Compose.$fReadCompose_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgehE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgehI; else goto cgehH;
       cgehI: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgehH: // global
           I64[Hp - 32] = sat_sgdTP_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.466575013 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadList_closure" {
     Data.Functor.Compose.$fReadCompose_$creadList_closure:
         const Data.Functor.Compose.$fReadCompose_$creadList_info;
         const 0;
 },
 sat_sgdTT_entry() //  [R1]
         { info_tbl: [(cgehR,
                       label: sat_sgdTT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgehR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgehS; else goto cgehT;
       cgehS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgehT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgehU,
                       label: Data.Functor.Compose.$fReadCompose_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgehU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgehY; else goto cgehX;
       cgehY: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgehX: // global
           I64[Hp - 32] = sat_sgdTT_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.468448902 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_closure" {
     Data.Functor.Compose.$fReadCompose_closure:
         const Data.Functor.Compose.$fReadCompose_info;
         const 0;
 },
 sat_sgdU0_entry() //  [R1]
         { info_tbl: [(cgei7,
                       label: sat_sgdU0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgei7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgei8; else goto cgei9;
       cgei8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgei9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTZ_entry() //  [R1]
         { info_tbl: [(cgeie,
                       label: sat_sgdTZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeif; else goto cgeig;
       cgeif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTY_entry() //  [R1]
         { info_tbl: [(cgeil,
                       label: sat_sgdTY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeil: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeim; else goto cgein;
       cgeim: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgein: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTX_entry() //  [R1]
         { info_tbl: [(cgeis,
                       label: sat_sgdTX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeit; else goto cgeiu;
       cgeit: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeiu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgeiw,
                       label: Data.Functor.Compose.$fReadCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeiw: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cgeiA; else goto cgeiz;
       cgeiA: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeiz: // global
           I64[Hp - 192] = sat_sgdU0_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sgdTZ_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sgdTY_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgdTX_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.47106317 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_info;
         const 0;
 },
 sat_sgdU9_entry() //  [R1]
         { info_tbl: [(cgeiO,
                       label: sat_sgdU9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeiO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeiP; else goto cgeiQ;
       cgeiP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeiQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdU8_entry() //  [R1]
         { info_tbl: [(cgeiV,
                       label: sat_sgdU8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeiV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeiW; else goto cgeiX;
       cgeiW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeiX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgeiY,
                       label: Data.Functor.Compose.$fShowCompose_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeiY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeiZ; else goto cgej0;
       cgeiZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgej0: // global
           I64[Sp - 40] = block_cgeiF_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugej4; else goto cgeiG;
       ugej4: // global
           call _cgeiF(R1) args: 0, res: 0, upd: 0;
       cgeiG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeiF() //  [R1]
         { info_tbl: [(cgeiF,
                       label: block_cgeiF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeiF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgej3; else goto cgej2;
       cgej3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgej2: // global
           _sgdU7::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sgdU9_info;
           _sgdU3::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgdU3::P64;
           I64[Hp - 16] = sat_sgdU8_info;
           P64[Hp] = _sgdU3::P64;
           R6 = _sgdU7::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.473778015 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshow_closure" {
     Data.Functor.Compose.$fShowCompose_$cshow_closure:
         const Data.Functor.Compose.$fShowCompose_$cshow_info;
         const 0;
 },
 sp_sgdUe_entry() //  [R1]
         { info_tbl: [(cgejd,
                       label: sp_sgdUe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeje; else goto cgejf;
       cgeje: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgejf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sgdUf_entry() //  [R1]
         { info_tbl: [(cgejk,
                       label: sl_sgdUf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgejl; else goto cgejm;
       cgejl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgejm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdUh_entry() //  [R1]
         { info_tbl: [(cgejv,
                       label: sat_sgdUh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgejw; else goto cgejx;
       cgejw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgejx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdUg_entry() //  [R1]
         { info_tbl: [(cgejC,
                       label: sat_sgdUg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgejD; else goto cgejE;
       cgejD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgejE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdUi_entry() //  [R1]
         { info_tbl: [(cgejF,
                       label: sat_sgdUi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejF: // global
           _sgdUi::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cgejG; else goto cgejH;
       cgejH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgejJ; else goto cgejI;
       cgejJ: // global
           HpAlloc = 80;
           goto cgejG;
       cgejG: // global
           R1 = _sgdUi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgejI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdUi::P64;
           _sgdUa::P64 = P64[_sgdUi::P64 + 16];
           _sgdUb::P64 = P64[_sgdUi::P64 + 24];
           _sgdUd::P64 = P64[_sgdUi::P64 + 32];
           _sgdUe::P64 = P64[_sgdUi::P64 + 40];
           _sgdUf::P64 = P64[_sgdUi::P64 + 48];
           I64[Hp - 72] = sat_sgdUh_info;
           P64[Hp - 56] = _sgdUb::P64;
           P64[Hp - 48] = _sgdUe::P64;
           P64[Hp - 40] = _sgdUf::P64;
           I64[Hp - 32] = sat_sgdUg_info;
           P64[Hp - 16] = _sgdUb::P64;
           P64[Hp - 8] = _sgdUe::P64;
           P64[Hp] = _sgdUf::P64;
           R2 = _sgdUa::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 32;
           P64[Sp - 48] = Hp - 72;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sgdUd::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgejL,
                       label: Data.Functor.Compose.$fShowCompose_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejL: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgejP; else goto cgejO;
       cgejP: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgejO: // global
           I64[Hp - 120] = sp_sgdUe_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sgdUf_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgdUi_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = Hp - 120;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 72;
           R3 = Hp - 14;
           R2 = Data.Functor.Compose.$fDataCompose6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.476705058 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowList_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowList_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowList_info;
         const 0;
 },
 lvl8_sgdUp_entry() //  [R1]
         { info_tbl: [(cgejY,
                       label: lvl8_sgdUp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgejY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgejZ; else goto cgek0;
       cgejZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgek0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sgdUq_entry() //  [R1]
         { info_tbl: [(cgek5,
                       label: lvl9_sgdUq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgek5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgek6; else goto cgek7;
       cgek6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgek7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdUs_entry() //  [R1, R2]
         { info_tbl: [(cgekd,
                       label: sat_sgdUs_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgekd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgeke; else goto cgekf;
       cgeke: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgekf: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgdUr::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgdUr::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cgekg,
                       label: Data.Functor.Compose.$fShowCompose_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgekg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgekk; else goto cgekj;
       cgekk: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgekj: // global
           I64[Hp - 80] = lvl8_sgdUp_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sgdUq_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgdUs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.479009981 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_closure" {
     Data.Functor.Compose.$fShowCompose_closure:
         const Data.Functor.Compose.$fShowCompose_info;
         const 0;
 },
 sat_sgdUy_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeku,
                       label: sat_sgdUy_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeku: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUx_entry() //  [R1, R2]
         { info_tbl: [(cgekC,
                       label: sat_sgdUx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgekC: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fShowCompose_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgekK,
                       label: sat_sgdUw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgekK: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgekO,
                       label: Data.Functor.Compose.$fShowCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgekO: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgekS; else goto cgekR;
       cgekS: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgekR: // global
           I64[Hp - 120] = sat_sgdUy_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sgdUx_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sgdUw_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.480887628 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose2_closure" {
     Data.Functor.Compose.$fFunctorCompose2_closure:
         const Data.Functor.Compose.$fFunctorCompose2_info;
 },
 sat_sgdUD_entry() //  [R1]
         { info_tbl: [(cgel1,
                       label: sat_sgdUD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgel1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgel2; else goto cgel3;
       cgel2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgel3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgel4,
                       label: Data.Functor.Compose.$fFunctorCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgel4: // global
           _sgdUC::P64 = R5;
           _sgdUB::P64 = R4;
           _sgdUA::P64 = R3;
           _sgdUz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgel5; else goto cgel6;
       cgel6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgel8; else goto cgel7;
       cgel8: // global
           HpAlloc = 32;
           goto cgel5;
       cgel5: // global
           R5 = _sgdUC::P64;
           R4 = _sgdUB::P64;
           R3 = _sgdUA::P64;
           R2 = _sgdUz::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgel7: // global
           I64[Hp - 24] = sat_sgdUD_info;
           P64[Hp - 8] = _sgdUA::P64;
           P64[Hp] = _sgdUB::P64;
           R2 = _sgdUz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUC::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.482521828 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose1_closure" {
     Data.Functor.Compose.$fFunctorCompose1_closure:
         const Data.Functor.Compose.$fFunctorCompose1_info;
 },
 sat_sgdUJ_entry() //  [R1]
         { info_tbl: [(cgelm,
                       label: sat_sgdUJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgelm: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUK_entry() //  [R1]
         { info_tbl: [(cgelp,
                       label: sat_sgdUK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgelp: // global
           _sgdUK::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgelq; else goto cgelr;
       cgelr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgelt; else goto cgels;
       cgelt: // global
           HpAlloc = 16;
           goto cgelq;
       cgelq: // global
           R1 = _sgdUK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgels: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdUK::P64;
           _sgdUF::P64 = P64[_sgdUK::P64 + 16];
           _sgdUG::P64 = P64[_sgdUK::P64 + 24];
           I64[Hp - 8] = sat_sgdUJ_info;
           P64[Hp] = _sgdUG::P64;
           R2 = _sgdUF::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgelu,
                       label: Data.Functor.Compose.$fFunctorCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgelu: // global
           _sgdUH::P64 = R5;
           _sgdUG::P64 = R4;
           _sgdUF::P64 = R3;
           _sgdUE::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgelv; else goto cgelw;
       cgelw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgely; else goto cgelx;
       cgely: // global
           HpAlloc = 32;
           goto cgelv;
       cgelv: // global
           R5 = _sgdUH::P64;
           R4 = _sgdUG::P64;
           R3 = _sgdUF::P64;
           R2 = _sgdUE::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgelx: // global
           I64[Hp - 24] = sat_sgdUK_info;
           P64[Hp - 8] = _sgdUF::P64;
           P64[Hp] = _sgdUG::P64;
           R2 = _sgdUE::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUH::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.484346386 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose_closure" {
     Data.Functor.Compose.$fFunctorCompose_closure:
         const Data.Functor.Compose.$fFunctorCompose_info;
 },
 sat_sgdUO_entry() //  [R1, R2, R3]
         { info_tbl: [(cgelI,
                       label: sat_sgdUO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgelI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUN_entry() //  [R1, R2, R3]
         { info_tbl: [(cgelQ,
                       label: sat_sgdUN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgelQ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFunctorCompose_entry() //  [R2, R3]
         { info_tbl: [(cgelU,
                       label: Data.Functor.Compose.$fFunctorCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgelU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgelY; else goto cgelX;
       cgelY: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFunctorCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgelX: // global
           I64[Hp - 64] = sat_sgdUO_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdUN_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.48608207 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info;
 },
 sat_sgdUU_entry() //  [R1]
         { info_tbl: [(cgem7,
                       label: sat_sgdUU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgem7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgem8; else goto cgem9;
       cgem8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgem9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgema,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgema: // global
           _sgdUT::P64 = R6;
           _sgdUS::P64 = R5;
           _sgdUR::P64 = R4;
           _sgdUQ::P64 = R3;
           _sgdUP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgemb; else goto cgemc;
       cgemc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgeme; else goto cgemd;
       cgeme: // global
           HpAlloc = 40;
           goto cgemb;
       cgemb: // global
           R6 = _sgdUT::P64;
           R5 = _sgdUS::P64;
           R4 = _sgdUR::P64;
           R3 = _sgdUQ::P64;
           R2 = _sgdUP::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgemd: // global
           I64[Hp - 32] = sat_sgdUU_info;
           P64[Hp - 16] = _sgdUQ::P64;
           P64[Hp - 8] = _sgdUR::P64;
           P64[Hp] = _sgdUS::P64;
           R2 = _sgdUP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgdUR::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgdUT::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.487625182 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfold_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfold_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfold_info;
 },
 sat_sgdUZ_entry() //  [R1]
         { info_tbl: [(cgemn,
                       label: sat_sgdUZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgemn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgemo; else goto cgemp;
       cgemo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgemp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgemq,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgemq: // global
           _sgdUY::P64 = R5;
           _sgdUX::P64 = R4;
           _sgdUW::P64 = R3;
           _sgdUV::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgemr; else goto cgems;
       cgems: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgemu; else goto cgemt;
       cgemu: // global
           HpAlloc = 32;
           goto cgemr;
       cgemr: // global
           R5 = _sgdUY::P64;
           R4 = _sgdUX::P64;
           R3 = _sgdUW::P64;
           R2 = _sgdUV::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgemt: // global
           I64[Hp - 24] = sat_sgdUZ_info;
           P64[Hp - 8] = _sgdUW::P64;
           P64[Hp] = _sgdUX::P64;
           R2 = _sgdUV::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgdUX::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUY::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.488918758 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose1_closure" {
     Data.Functor.Compose.$fFoldableCompose1_closure:
         const Data.Functor.Compose.$fFoldableCompose1_info;
 },
 Data.Functor.Compose.$fFoldableCompose1_entry() //  [R2]
         { info_tbl: [(cgemz,
                       label: Data.Functor.Compose.$fFoldableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgemz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.490188932 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$csum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$csum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$csum_info;
         const 0;
 },
 $dMonoid_sgdV4_entry() //  [R1]
         { info_tbl: [(cgemK,
                       label: $dMonoid_sgdV4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgemK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgemL; else goto cgemM;
       cgemL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgemM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdV5_entry() //  [R1]
         { info_tbl: [(cgemR,
                       label: lvl8_sgdV5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgemR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgemS; else goto cgemT;
       cgemS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgemT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdV7_entry() //  [R1, R2]
         { info_tbl: [(cgemZ,
                       label: sat_sgdV7_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgemZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgen0; else goto cgen1;
       cgen0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgen1: // global
           _sgdV6::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgdV6::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgen2,
                       label: Data.Functor.Compose.$fFoldableCompose_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgen2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgen6; else goto cgen5;
       cgen6: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgen5: // global
           I64[Hp - 80] = $dMonoid_sgdV4_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdV5_info;
           P64[Hp - 40] = R3;
           _cgemG::P64 = Hp - 80;
           P64[Hp - 32] = _cgemG::P64;
           I64[Hp - 24] = sat_sgdV7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgemG::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.491841458 UTC

[section ""cstring" . lvl_rgdPQ_bytes" {
     lvl_rgdPQ_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.492598265 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose2_closure" {
     Data.Functor.Compose.$fFoldableCompose2_closure:
         const Data.Functor.Compose.$fFoldableCompose2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose2_entry() //  [R1]
         { info_tbl: [(cgenf,
                       label: Data.Functor.Compose.$fFoldableCompose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgenf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgeng; else goto cgenh;
       cgeng: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgenh: // global
           (_cgena::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgena::I64 == 0) goto cgenc; else goto cgenb;
       cgenc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgenb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgena::I64;
           I64[Sp - 24] = block_cgend_info;
           R2 = lvl_rgdPQ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgend() //  [R1]
         { info_tbl: [(cgend,
                       label: block_cgend_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgend: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.494352665 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cminimum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cminimum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_info;
         const 0;
 },
 $dMonoid_sgdVc_entry() //  [R1]
         { info_tbl: [(cgent,
                       label: $dMonoid_sgdVc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgent: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgenu; else goto cgenv;
       cgenu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgenv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdVd_entry() //  [R1]
         { info_tbl: [(cgenA,
                       label: lvl8_sgdVd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgenA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgenB; else goto cgenC;
       cgenB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgenC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVh_entry() //  [R1, R2]
         { info_tbl: [(cgenO,
                       label: sat_sgdVh_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgenO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgenP; else goto cgenQ;
       cgenP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgenQ: // global
           I64[Sp - 8] = block_cgenI_info;
           _sgdVe::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgdVe::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgenI() //  [R1]
         { info_tbl: [(cgenI,
                       label: block_cgenI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgenI: // global
           if (R1 & 7 == 1) goto cgenL; else goto cgenM;
       cgenL: // global
           R1 = Data.Functor.Compose.$fFoldableCompose2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgenM: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgenX,
                       label: Data.Functor.Compose.$fFoldableCompose_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgenX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgeo1; else goto cgeo0;
       cgeo1: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeo0: // global
           I64[Hp - 80] = $dMonoid_sgdVc_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdVd_info;
           P64[Hp - 40] = R3;
           _cgenp::P64 = Hp - 80;
           P64[Hp - 32] = _cgenp::P64;
           I64[Hp - 24] = sat_sgdVh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgenp::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.496200635 UTC

[section ""cstring" . lvl1_rgdPR_bytes" {
     lvl1_rgdPR_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.496940561 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose3_closure" {
     Data.Functor.Compose.$fFoldableCompose3_closure:
         const Data.Functor.Compose.$fFoldableCompose3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose3_entry() //  [R1]
         { info_tbl: [(cgeoa,
                       label: Data.Functor.Compose.$fFoldableCompose3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeoa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgeob; else goto cgeoc;
       cgeob: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeoc: // global
           (_cgeo5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgeo5::I64 == 0) goto cgeo7; else goto cgeo6;
       cgeo7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgeo6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgeo5::I64;
           I64[Sp - 24] = block_cgeo8_info;
           R2 = lvl1_rgdPR_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgeo8() //  [R1]
         { info_tbl: [(cgeo8,
                       label: block_cgeo8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeo8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.498671007 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_info;
         const 0;
 },
 $dMonoid_sgdVm_entry() //  [R1]
         { info_tbl: [(cgeoo,
                       label: $dMonoid_sgdVm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeoo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeop; else goto cgeoq;
       cgeop: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeoq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdVn_entry() //  [R1]
         { info_tbl: [(cgeov,
                       label: lvl8_sgdVn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeov: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeow; else goto cgeox;
       cgeow: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeox: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVr_entry() //  [R1, R2]
         { info_tbl: [(cgeoJ,
                       label: sat_sgdVr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeoJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeoK; else goto cgeoL;
       cgeoK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeoL: // global
           I64[Sp - 8] = block_cgeoD_info;
           _sgdVo::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgdVo::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgeoD() //  [R1]
         { info_tbl: [(cgeoD,
                       label: block_cgeoD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeoD: // global
           if (R1 & 7 == 1) goto cgeoG; else goto cgeoH;
       cgeoG: // global
           R1 = Data.Functor.Compose.$fFoldableCompose3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgeoH: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgeoS,
                       label: Data.Functor.Compose.$fFoldableCompose_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeoS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgeoW; else goto cgeoV;
       cgeoW: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeoV: // global
           I64[Hp - 80] = $dMonoid_sgdVm_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdVn_info;
           P64[Hp - 40] = R3;
           _cgeok::P64 = Hp - 80;
           P64[Hp - 32] = _cgeok::P64;
           I64[Hp - 24] = sat_sgdVr_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgeok::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.501144055 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$celem_closure" {
     Data.Functor.Compose.$fFoldableCompose_$celem_closure:
         const Data.Functor.Compose.$fFoldableCompose_$celem_info;
         const 0;
 },
 sat_sgdVx_entry() //  [R1]
         { info_tbl: [(cgep9,
                       label: sat_sgdVx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgep9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgepa; else goto cgepb;
       cgepa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgepb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_sgdVw_entry() //  [R1]
         { info_tbl: [(cgepc,
                       label: lvl8_sgdVw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepc: // global
           _sgdVw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgepd; else goto cgepe;
       cgepe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgepg; else goto cgepf;
       cgepg: // global
           HpAlloc = 32;
           goto cgepd;
       cgepd: // global
           R1 = _sgdVw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgepf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVw::P64;
           _sgdVt::P64 = P64[_sgdVw::P64 + 16];
           _sgdVu::P64 = P64[_sgdVw::P64 + 24];
           _sgdVv::P64 = P64[_sgdVw::P64 + 32];
           I64[Hp - 24] = sat_sgdVx_info;
           P64[Hp - 8] = _sgdVu::P64;
           P64[Hp] = _sgdVv::P64;
           R2 = _sgdVt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVz_entry() //  [R1, R2]
         { info_tbl: [(cgepm,
                       label: sat_sgdVz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgepn; else goto cgepo;
       cgepn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgepo: // global
           _sgdVy::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sgdVy::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgepp,
                       label: Data.Functor.Compose.$fFoldableCompose_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgept; else goto cgeps;
       cgept: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeps: // global
           I64[Hp - 56] = lvl8_sgdVw_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sgdVz_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.503227348 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose7_closure" {
     Data.Functor.Compose.$fFoldableCompose7_closure:
         const Data.Functor.Compose.$fFoldableCompose7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose7_entry() //  [R1]
         { info_tbl: [(cgepA,
                       label: Data.Functor.Compose.$fFoldableCompose7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgepB; else goto cgepC;
       cgepB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgepC: // global
           (_cgepx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgepx::I64 == 0) goto cgepz; else goto cgepy;
       cgepz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgepy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgepx::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.504550941 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_info;
         const 0;
 },
 sat_sgdVH_entry() //  [R1, R2, R3]
         { info_tbl: [(cgepQ,
                       label: sat_sgdVH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepQ: // global
           _sgdVG::P64 = R3;
           R3 = R2;
           R2 = _sgdVG::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdVI_entry() //  [R1]
         { info_tbl: [(cgepT,
                       label: sat_sgdVI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepT: // global
           _sgdVI::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgepU; else goto cgepV;
       cgepV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgepX; else goto cgepW;
       cgepX: // global
           HpAlloc = 16;
           goto cgepU;
       cgepU: // global
           R1 = _sgdVI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgepW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVI::P64;
           _sgdVB::P64 = P64[_sgdVI::P64 + 16];
           _sgdVC::P64 = P64[_sgdVI::P64 + 24];
           I64[Hp - 8] = sat_sgdVH_info;
           P64[Hp] = _sgdVC::P64;
           R2 = _sgdVB::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgepY,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgepY: // global
           _sgdVE::P64 = R6;
           _sgdVD::P64 = R5;
           _sgdVC::P64 = R4;
           _sgdVB::P64 = R3;
           _sgdVA::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgepZ; else goto cgeq0;
       cgeq0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeq2; else goto cgeq1;
       cgeq2: // global
           HpAlloc = 32;
           goto cgepZ;
       cgepZ: // global
           R6 = _sgdVE::P64;
           R5 = _sgdVD::P64;
           R4 = _sgdVC::P64;
           R3 = _sgdVB::P64;
           R2 = _sgdVA::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeq1: // global
           I64[Hp - 24] = sat_sgdVI_info;
           P64[Hp - 8] = _sgdVB::P64;
           P64[Hp] = _sgdVC::P64;
           R2 = _sgdVA::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdVE::P64;
           P64[Sp - 8] = _sgdVD::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.506132539 UTC

[section ""cstring" . lvl2_rgdPS_bytes" {
     lvl2_rgdPS_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.506890028 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose6_closure" {
     Data.Functor.Compose.$fFoldableCompose6_closure:
         const Data.Functor.Compose.$fFoldableCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose6_entry() //  [R1]
         { info_tbl: [(cgeqb,
                       label: Data.Functor.Compose.$fFoldableCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeqb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgeqc; else goto cgeqd;
       cgeqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeqd: // global
           (_cgeq6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgeq6::I64 == 0) goto cgeq8; else goto cgeq7;
       cgeq8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgeq7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgeq6::I64;
           I64[Sp - 24] = block_cgeq9_info;
           R2 = lvl2_rgdPS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgeq9() //  [R1]
         { info_tbl: [(cgeq9,
                       label: block_cgeq9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeq9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.508822708 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info;
         const 0;
 },
 sat_sgdVS_entry() //  [R1]
         { info_tbl: [(cgeqF,
                       label: sat_sgdVS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeqF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeqG; else goto cgeqH;
       cgeqG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeqH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgeqy_info;
           _sgdVM::P64 = P64[R1 + 16];
           _sgdVO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgdVM::P64;
           P64[Sp - 24] = _sgdVO::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugeqO; else goto cgeqz;
       ugeqO: // global
           call _cgeqy(R1) args: 0, res: 0, upd: 0;
       cgeqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgeqy() //  [R1]
         { info_tbl: [(cgeqy,
                       label: block_cgeqy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeqy: // global
           _sgdVO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgeqC; else goto cgeqD;
       cgeqC: // global
           R1 = _sgdVO::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgeqD: // global
           R3 = _sgdVO::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdVT_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeqQ,
                       label: sat_sgdVT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeqQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeqU; else goto cgeqT;
       cgeqU: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeqT: // global
           _sgdVM::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgdVS_info;
           P64[Hp - 32] = _sgdVM::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdVU_entry() //  [R1]
         { info_tbl: [(cgeqV,
                       label: sat_sgdVU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeqV: // global
           _sgdVU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeqW; else goto cgeqX;
       cgeqX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgeqZ; else goto cgeqY;
       cgeqZ: // global
           HpAlloc = 16;
           goto cgeqW;
       cgeqW: // global
           R1 = _sgdVU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeqY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVU::P64;
           _sgdVL::P64 = P64[_sgdVU::P64 + 16];
           _sgdVM::P64 = P64[_sgdVU::P64 + 24];
           I64[Hp - 8] = sat_sgdVT_info;
           P64[Hp] = _sgdVM::P64;
           R2 = _sgdVL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cger6,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cger6: // global
           _sgdVN::P64 = R5;
           _sgdVM::P64 = R4;
           _sgdVL::P64 = R3;
           _sgdVK::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cger7; else goto cger8;
       cger8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgera; else goto cger9;
       cgera: // global
           HpAlloc = 32;
           goto cger7;
       cger7: // global
           R5 = _sgdVN::P64;
           R4 = _sgdVM::P64;
           R3 = _sgdVL::P64;
           R2 = _sgdVK::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cger9: // global
           I64[Hp - 24] = sat_sgdVU_info;
           P64[Hp - 8] = _sgdVL::P64;
           P64[Hp] = _sgdVM::P64;
           I64[Sp - 8] = block_cger0_info;
           R2 = _sgdVK::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdVN::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cger0() //  [R1]
         { info_tbl: [(cger0,
                       label: block_cger0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cger0: // global
           if (R1 & 7 == 1) goto cger3; else goto cger4;
       cger3: // global
           R1 = Data.Functor.Compose.$fFoldableCompose6_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cger4: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.511756723 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info;
         const 0;
 },
 sat_sgdW6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgerw,
                       label: sat_sgdW6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgerw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgerx; else goto cgery;
       cgerx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgery: // global
           I64[Sp - 16] = block_cgeru_info;
           _sgdW3::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgdW3::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeru() //  [R1]
         { info_tbl: [(cgeru,
                       label: block_cgeru_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeru: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdW7_entry() //  [R1]
         { info_tbl: [(cgerA,
                       label: sat_sgdW7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgerA: // global
           _sgdW7::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgerB; else goto cgerC;
       cgerC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgerE; else goto cgerD;
       cgerE: // global
           HpAlloc = 16;
           goto cgerB;
       cgerB: // global
           R1 = _sgdW7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgerD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdW7::P64;
           _sgdVY::P64 = P64[_sgdW7::P64 + 16];
           _sgdVZ::P64 = P64[_sgdW7::P64 + 24];
           I64[Hp - 8] = sat_sgdW6_info;
           P64[Hp] = _sgdVZ::P64;
           R2 = _sgdVY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cgerF,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgerF: // global
           _sgdW1::P64 = R6;
           _sgdW0::P64 = R5;
           _sgdVZ::P64 = R4;
           _sgdVY::P64 = R3;
           _sgdVX::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgerG; else goto cgerH;
       cgerH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgerJ; else goto cgerI;
       cgerJ: // global
           HpAlloc = 32;
           goto cgerG;
       cgerG: // global
           R6 = _sgdW1::P64;
           R5 = _sgdW0::P64;
           R4 = _sgdVZ::P64;
           R3 = _sgdVY::P64;
           R2 = _sgdVX::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgerI: // global
           I64[Hp - 24] = sat_sgdW7_info;
           P64[Hp - 8] = _sgdVY::P64;
           P64[Hp] = _sgdVZ::P64;
           R2 = _sgdVX::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdW1::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgdW0::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.513911056 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_info;
         const 0;
 },
 sat_sgdWd_entry() //  [R1]
         { info_tbl: [(cgerS,
                       label: sat_sgdWd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgerS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgerT; else goto cgerU;
       cgerT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgerU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgerV,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgerV: // global
           _sgdWc::P64 = R6;
           _sgdWb::P64 = R5;
           _sgdWa::P64 = R4;
           _sgdW9::P64 = R3;
           _sgdW8::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgerW; else goto cgerX;
       cgerX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgerZ; else goto cgerY;
       cgerZ: // global
           HpAlloc = 32;
           goto cgerW;
       cgerW: // global
           R6 = _sgdWc::P64;
           R5 = _sgdWb::P64;
           R4 = _sgdWa::P64;
           R3 = _sgdW9::P64;
           R2 = _sgdW8::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgerY: // global
           I64[Hp - 24] = sat_sgdWd_info;
           P64[Hp - 8] = _sgdW9::P64;
           P64[Hp] = _sgdWa::P64;
           R2 = _sgdW8::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdWc::P64;
           P64[Sp - 8] = _sgdWb::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.515752321 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info;
         const 0;
 },
 sat_sgdWn_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgesf,
                       label: sat_sgdWn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgesg; else goto cgesh;
       cgesg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgesh: // global
           I64[Sp - 16] = block_cgesd_info;
           _sgdWk::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgdWk::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgesd() //  [R1]
         { info_tbl: [(cgesd,
                       label: block_cgesd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesd: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdWo_entry() //  [R1]
         { info_tbl: [(cgesj,
                       label: sat_sgdWo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesj: // global
           _sgdWo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgesk; else goto cgesl;
       cgesl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgesn; else goto cgesm;
       cgesn: // global
           HpAlloc = 16;
           goto cgesk;
       cgesk: // global
           R1 = _sgdWo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgesm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdWo::P64;
           _sgdWf::P64 = P64[_sgdWo::P64 + 16];
           _sgdWg::P64 = P64[_sgdWo::P64 + 24];
           I64[Hp - 8] = sat_sgdWn_info;
           P64[Hp] = _sgdWg::P64;
           R2 = _sgdWf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cgeso,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeso: // global
           _sgdWi::P64 = R6;
           _sgdWh::P64 = R5;
           _sgdWg::P64 = R4;
           _sgdWf::P64 = R3;
           _sgdWe::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgesp; else goto cgesq;
       cgesq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgess; else goto cgesr;
       cgess: // global
           HpAlloc = 32;
           goto cgesp;
       cgesp: // global
           R6 = _sgdWi::P64;
           R5 = _sgdWh::P64;
           R4 = _sgdWg::P64;
           R3 = _sgdWf::P64;
           R2 = _sgdWe::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgesr: // global
           I64[Hp - 24] = sat_sgdWo_info;
           P64[Hp - 8] = _sgdWf::P64;
           P64[Hp] = _sgdWg::P64;
           R2 = _sgdWe::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdWi::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgdWh::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.520958923 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose4_closure" {
     Data.Functor.Compose.$fFoldableCompose4_closure:
         const Data.Functor.Compose.$fFoldableCompose4_info;
 },
 Data.Functor.Compose.$fFoldableCompose4_entry() //  [R2, R3, R4]
         { info_tbl: [(cgesA,
                       label: Data.Functor.Compose.$fFoldableCompose4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgesH; else goto cgesI;
       cgesH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgesI: // global
           I64[Sp - 16] = block_cgesx_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugesM; else goto cgesy;
       ugesM: // global
           call _cgesx(R1) args: 0, res: 0, upd: 0;
       cgesy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgesx() //  [R1]
         { info_tbl: [(cgesx,
                       label: block_cgesx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgesL; else goto cgesK;
       cgesL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgesK: // global
           _sgdWu::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgdWu::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.522684635 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$clength_closure" {
     Data.Functor.Compose.$fFoldableCompose_$clength_closure:
         const Data.Functor.Compose.$fFoldableCompose_$clength_info;
         const 0;
 },
 sat_sgdWz_entry() //  [R1]
         { info_tbl: [(cgesV,
                       label: sat_sgdWz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgesW; else goto cgesX;
       cgesW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgesX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose4_closure+3;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgesY,
                       label: Data.Functor.Compose.$fFoldableCompose_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgesY: // global
           _sgdWy::P64 = R4;
           _sgdWx::P64 = R3;
           _sgdWw::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgesZ; else goto cget0;
       cget0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cget2; else goto cget1;
       cget2: // global
           HpAlloc = 24;
           goto cgesZ;
       cgesZ: // global
           R4 = _sgdWy::P64;
           R3 = _sgdWx::P64;
           R2 = _sgdWw::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cget1: // global
           I64[Hp - 16] = sat_sgdWz_info;
           P64[Hp] = _sgdWx::P64;
           R2 = _sgdWw::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgdWy::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = Data.Functor.Compose.$fDataCompose3_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.523937307 UTC

[section ""cstring" . lvl3_rgdPT_bytes" {
     lvl3_rgdPT_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.524736555 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose8_closure" {
     Data.Functor.Compose.$fFoldableCompose8_closure:
         const Data.Functor.Compose.$fFoldableCompose8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose8_entry() //  [R1]
         { info_tbl: [(cgetb,
                       label: Data.Functor.Compose.$fFoldableCompose8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgetb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgetc; else goto cgetd;
       cgetc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgetd: // global
           (_cget6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cget6::I64 == 0) goto cget8; else goto cget7;
       cget8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cget7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cget6::I64;
           I64[Sp - 24] = block_cget9_info;
           R2 = lvl3_rgdPT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cget9() //  [R1]
         { info_tbl: [(cget9,
                       label: block_cget9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cget9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.526697861 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info;
         const 0;
 },
 sat_sgdWJ_entry() //  [R1]
         { info_tbl: [(cgetF,
                       label: sat_sgdWJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgetF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgetG; else goto cgetH;
       cgetG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgetH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgety_info;
           _sgdWD::P64 = P64[R1 + 16];
           _sgdWF::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgdWD::P64;
           P64[Sp - 24] = _sgdWF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugetO; else goto cgetz;
       ugetO: // global
           call _cgety(R1) args: 0, res: 0, upd: 0;
       cgetz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgety() //  [R1]
         { info_tbl: [(cgety,
                       label: block_cgety_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgety: // global
           _sgdWF::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgetC; else goto cgetD;
       cgetC: // global
           R1 = _sgdWF::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgetD: // global
           R3 = P64[R1 + 6];
           R2 = _sgdWF::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdWK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgetQ,
                       label: sat_sgdWK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgetQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgetU; else goto cgetT;
       cgetU: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgetT: // global
           _sgdWD::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgdWJ_info;
           P64[Hp - 32] = _sgdWD::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdWL_entry() //  [R1]
         { info_tbl: [(cgetV,
                       label: sat_sgdWL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgetV: // global
           _sgdWL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgetW; else goto cgetX;
       cgetX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgetZ; else goto cgetY;
       cgetZ: // global
           HpAlloc = 16;
           goto cgetW;
       cgetW: // global
           R1 = _sgdWL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgetY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdWL::P64;
           _sgdWC::P64 = P64[_sgdWL::P64 + 16];
           _sgdWD::P64 = P64[_sgdWL::P64 + 24];
           I64[Hp - 8] = sat_sgdWK_info;
           P64[Hp] = _sgdWD::P64;
           R2 = _sgdWC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgeu6,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeu6: // global
           _sgdWE::P64 = R5;
           _sgdWD::P64 = R4;
           _sgdWC::P64 = R3;
           _sgdWB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgeu7; else goto cgeu8;
       cgeu8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeua; else goto cgeu9;
       cgeua: // global
           HpAlloc = 32;
           goto cgeu7;
       cgeu7: // global
           R5 = _sgdWE::P64;
           R4 = _sgdWD::P64;
           R3 = _sgdWC::P64;
           R2 = _sgdWB::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeu9: // global
           I64[Hp - 24] = sat_sgdWL_info;
           P64[Hp - 8] = _sgdWC::P64;
           P64[Hp] = _sgdWD::P64;
           I64[Sp - 8] = block_cgeu0_info;
           R2 = _sgdWB::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdWE::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cgeu0() //  [R1]
         { info_tbl: [(cgeu0,
                       label: block_cgeu0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeu0: // global
           if (R1 & 7 == 1) goto cgeu3; else goto cgeu4;
       cgeu3: // global
           R1 = Data.Functor.Compose.$fFoldableCompose8_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgeu4: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.529196443 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose5_closure" {
     Data.Functor.Compose.$fFoldableCompose5_closure:
         const Data.Functor.Compose.$fFoldableCompose5_info;
 },
 Data.Functor.Compose.$fFoldableCompose5_entry() //  []
         { info_tbl: [(cgeul,
                       label: Data.Functor.Compose.$fFoldableCompose5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeul: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.530212862 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cnull_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cnull_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cnull_info;
         const 0;
 },
 sat_sgdWT_entry() //  [R1]
         { info_tbl: [(cgeuw,
                       label: sat_sgdWT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeuw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeux; else goto cgeuy;
       cgeux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeuy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose5_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgeuz,
                       label: Data.Functor.Compose.$fFoldableCompose_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeuz: // global
           _sgdWS::P64 = R4;
           _sgdWR::P64 = R3;
           _sgdWQ::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeuA; else goto cgeuB;
       cgeuB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeuD; else goto cgeuC;
       cgeuD: // global
           HpAlloc = 24;
           goto cgeuA;
       cgeuA: // global
           R4 = _sgdWS::P64;
           R3 = _sgdWR::P64;
           R2 = _sgdWQ::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeuC: // global
           I64[Hp - 16] = sat_sgdWT_info;
           P64[Hp] = _sgdWR::P64;
           R2 = _sgdWQ::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdWS::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.532025699 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cproduct_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cproduct_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_info;
         const 0;
 },
 $dMonoid_sgdWX_entry() //  [R1]
         { info_tbl: [(cgeuM,
                       label: $dMonoid_sgdWX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeuM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeuN; else goto cgeuO;
       cgeuN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdWY_entry() //  [R1]
         { info_tbl: [(cgeuT,
                       label: lvl8_sgdWY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeuT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeuU; else goto cgeuV;
       cgeuU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeuV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdX0_entry() //  [R1, R2]
         { info_tbl: [(cgev1,
                       label: sat_sgdX0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgev1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgev2; else goto cgev3;
       cgev2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgev3: // global
           _sgdWZ::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgdWZ::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgev4,
                       label: Data.Functor.Compose.$fFoldableCompose_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgev4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgev8; else goto cgev7;
       cgev8: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgev7: // global
           I64[Hp - 80] = $dMonoid_sgdWX_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdWY_info;
           P64[Hp - 40] = R3;
           _cgeuI::P64 = Hp - 80;
           P64[Hp - 32] = _cgeuI::P64;
           I64[Hp - 24] = sat_sgdX0_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgeuI::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.534046491 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$ctoList_closure" {
     Data.Functor.Compose.$fFoldableCompose_$ctoList_closure:
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_info;
         const 0;
 },
 sat_sgdX4_entry() //  [R1]
         { info_tbl: [(cgevh,
                       label: sat_sgdX4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgevh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgevi; else goto cgevj;
       cgevi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgevj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgevk,
                       label: Data.Functor.Compose.$fFoldableCompose_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgevk: // global
           _sgdX3::P64 = R4;
           _sgdX2::P64 = R3;
           _sgdX1::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgevl; else goto cgevm;
       cgevm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgevo; else goto cgevn;
       cgevo: // global
           HpAlloc = 24;
           goto cgevl;
       cgevl: // global
           R4 = _sgdX3::P64;
           R3 = _sgdX2::P64;
           R2 = _sgdX1::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgevn: // global
           I64[Hp - 16] = sat_sgdX4_info;
           P64[Hp] = _sgdX2::P64;
           R2 = _sgdX1::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdX3::P64;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.537650633 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_closure" {
     Data.Functor.Compose.$fFoldableCompose_closure:
         const Data.Functor.Compose.$fFoldableCompose_info;
         const 0;
 },
 sat_sgdXm_entry() //  [R1, R2]
         { info_tbl: [(cgevy,
                       label: sat_sgdXm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgevy: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXl_entry() //  [R1, R2]
         { info_tbl: [(cgevG,
                       label: sat_sgdXl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgevG: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXk_entry() //  [R1, R2]
         { info_tbl: [(cgevO,
                       label: sat_sgdXk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgevO: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXj_entry() //  [R1, R2]
         { info_tbl: [(cgevW,
                       label: sat_sgdXj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgevW: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXi_entry() //  [R1, R2, R3]
         { info_tbl: [(cgew4,
                       label: sat_sgdXi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgew4: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXh_entry() //  [R1, R2]
         { info_tbl: [(cgewc,
                       label: sat_sgdXh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgewc: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXg_entry() //  [R1, R2]
         { info_tbl: [(cgewk,
                       label: sat_sgdXg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgewk: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXf_entry() //  [R1, R2]
         { info_tbl: [(cgews,
                       label: sat_sgdXf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgews: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXe_entry() //  [R1, R2, R3]
         { info_tbl: [(cgewA,
                       label: sat_sgdXe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgewA: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXd_entry() //  [R1, R2, R3]
         { info_tbl: [(cgewI,
                       label: sat_sgdXd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgewI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgewQ,
                       label: sat_sgdXc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgewQ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXb_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgewY,
                       label: sat_sgdXb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgewY: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXa_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgex6,
                       label: sat_sgdXa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgex6: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgexe,
                       label: sat_sgdX9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexe: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX8_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgexm,
                       label: sat_sgdX8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexm: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX7_entry() //  [R1, R2, R3]
         { info_tbl: [(cgexu,
                       label: sat_sgdX7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_entry() //  [R2, R3]
         { info_tbl: [(cgexy,
                       label: Data.Functor.Compose.$fFoldableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexy: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cgexC; else goto cgexB;
       cgexC: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgexB: // global
           I64[Hp - 512] = sat_sgdXm_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sgdXl_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sgdXk_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sgdXj_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sgdXi_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sgdXh_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sgdXg_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sgdXf_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sgdXe_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sgdXd_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sgdXc_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sgdXb_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sgdXa_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sgdX9_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgdX8_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgdX7_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.541952191 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose1_closure" {
     Data.Functor.Compose.$fTraversableCompose1_closure:
         const Data.Functor.Compose.$fTraversableCompose1_info;
 },
 Data.Functor.Compose.$fTraversableCompose1_entry() //  [R2]
         { info_tbl: [(cgexH,
                       label: Data.Functor.Compose.$fTraversableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.543259944 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure" {
     Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure:
         const Data.Functor.Compose.$fTraversableCompose_$ctraverse_info;
 },
 sat_sgdXu_entry() //  [R1]
         { info_tbl: [(cgexW,
                       label: sat_sgdXu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgexX; else goto cgexY;
       cgexX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgexY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdXv_entry() //  [R1]
         { info_tbl: [(cgexZ,
                       label: sat_sgdXv_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgexZ: // global
           _sgdXv::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cgey0; else goto cgey1;
       cgey1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgey3; else goto cgey2;
       cgey3: // global
           HpAlloc = 40;
           goto cgey0;
       cgey0: // global
           R1 = _sgdXv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgey2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdXv::P64;
           _sgdXo::P64 = P64[_sgdXv::P64 + 16];
           _sgdXp::P64 = P64[_sgdXv::P64 + 24];
           _sgdXq::P64 = P64[_sgdXv::P64 + 32];
           _sgdXr::P64 = P64[_sgdXv::P64 + 40];
           _sgdXs::P64 = P64[_sgdXv::P64 + 48];
           I64[Hp - 32] = sat_sgdXu_info;
           P64[Hp - 16] = _sgdXp::P64;
           P64[Hp - 8] = _sgdXq::P64;
           P64[Hp] = _sgdXr::P64;
           R2 = _sgdXo::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sgdXq::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgdXs::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cgey6,
                       label: Data.Functor.Compose.$fTraversableCompose_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgey6: // global
           _sgdXs::P64 = R6;
           _sgdXr::P64 = R5;
           _sgdXq::P64 = R4;
           _sgdXp::P64 = R3;
           _sgdXo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgey7; else goto cgey8;
       cgey8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeya; else goto cgey9;
       cgeya: // global
           HpAlloc = 56;
           goto cgey7;
       cgey7: // global
           R6 = _sgdXs::P64;
           R5 = _sgdXr::P64;
           R4 = _sgdXq::P64;
           R3 = _sgdXp::P64;
           R2 = _sgdXo::P64;
           R1 = Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgey9: // global
           I64[Hp - 48] = sat_sgdXv_info;
           P64[Hp - 32] = _sgdXo::P64;
           P64[Hp - 24] = _sgdXp::P64;
           P64[Hp - 16] = _sgdXq::P64;
           P64[Hp - 8] = _sgdXr::P64;
           P64[Hp] = _sgdXs::P64;
           I64[Sp - 16] = block_cgey4_info;
           R2 = _sgdXq::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgey4() //  [R1]
         { info_tbl: [(cgey4,
                       label: block_cgey4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgey4: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Compose.$fTraversableCompose1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.545455772 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info;
         const 0;
 },
 sat_sgdXz_entry() //  [R1]
         { info_tbl: [(cgeym,
                       label: sat_sgdXz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeym: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeyn; else goto cgeyo;
       cgeyn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeyo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXy_entry() //  [R1]
         { info_tbl: [(cgeyt,
                       label: sat_sgdXy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeyt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeyu; else goto cgeyv;
       cgeyu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeyv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgeyw,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeyw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgeyA; else goto cgeyz;
       cgeyA: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeyz: // global
           I64[Hp - 40] = sat_sgdXz_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdXy_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFoldableCompose_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.547054253 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info;
 },
 sat_sgdXD_entry() //  [R1]
         { info_tbl: [(cgeyJ,
                       label: sat_sgdXD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeyJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeyK; else goto cgeyL;
       cgeyK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeyL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXC_entry() //  [R1]
         { info_tbl: [(cgeyQ,
                       label: sat_sgdXC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeyQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeyR; else goto cgeyS;
       cgeyR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeyS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgeyT,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeyT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgeyX; else goto cgeyW;
       cgeyX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeyW: // global
           I64[Hp - 40] = sat_sgdXD_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdXC_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.548459497 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequenceA_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgez2,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgez2: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.549505977 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cmapM_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cmapM_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cmapM_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgezb,
                       label: Data.Functor.Compose.$fTraversableCompose_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgezb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgezc; else goto cgezd;
       cgezc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgezd: // global
           I64[Sp - 40] = block_cgez9_info;
           _sgdXH::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sgdXH::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgez9() //  [R1]
         { info_tbl: [(cgez9,
                       label: block_cgez9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgez9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.55079309 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequence_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequence_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequence_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cgezn,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgezn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgezo; else goto cgezp;
       cgezo: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgezp: // global
           I64[Sp - 32] = block_cgezl_info;
           _sgdXN::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgdXN::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgezl() //  [R1]
         { info_tbl: [(cgezl,
                       label: block_cgezl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgezl: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.552788215 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_closure" {
     Data.Functor.Compose.$fTraversableCompose_closure:
         const Data.Functor.Compose.$fTraversableCompose_info;
         const 0;
 },
 sat_sgdXZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgezC,
                       label: sat_sgdXZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgezC: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgezK,
                       label: sat_sgdXY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgezK: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXX_entry() //  [R1, R2, R3]
         { info_tbl: [(cgezS,
                       label: sat_sgdXX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgezS: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXW_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgeA0,
                       label: sat_sgdXW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeA0: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXV_entry() //  [R1]
         { info_tbl: [(cgeA7,
                       label: sat_sgdXV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeA7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeA8; else goto cgeA9;
       cgeA8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeA9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXU_entry() //  [R1]
         { info_tbl: [(cgeAe,
                       label: sat_sgdXU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeAe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeAf; else goto cgeAg;
       cgeAf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeAg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_entry() //  [R2, R3]
         { info_tbl: [(cgeAi,
                       label: Data.Functor.Compose.$fTraversableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeAi: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cgeAm; else goto cgeAl;
       cgeAm: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeAl: // global
           I64[Hp - 208] = sat_sgdXZ_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sgdXY_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sgdXX_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sgdXW_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgdXV_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgdXU_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.555443752 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose4_closure" {
     Data.Functor.Compose.$fApplicativeCompose4_closure:
         const Data.Functor.Compose.$fApplicativeCompose4_info;
 },
 sat_sgdY5_entry() //  [R1]
         { info_tbl: [(cgeAv,
                       label: sat_sgdY5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeAv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeAw; else goto cgeAx;
       cgeAw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeAx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose4_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cgeAy,
                       label: Data.Functor.Compose.$fApplicativeCompose4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeAy: // global
           _sgdY4::P64 = R6;
           _sgdY3::P64 = R5;
           _sgdY2::P64 = R4;
           _sgdY1::P64 = R3;
           _sgdY0::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeAz; else goto cgeAA;
       cgeAA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeAC; else goto cgeAB;
       cgeAC: // global
           HpAlloc = 32;
           goto cgeAz;
       cgeAz: // global
           R6 = _sgdY4::P64;
           R5 = _sgdY3::P64;
           R4 = _sgdY2::P64;
           R3 = _sgdY1::P64;
           R2 = _sgdY0::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeAB: // global
           I64[Hp - 24] = sat_sgdY5_info;
           P64[Hp - 8] = _sgdY1::P64;
           P64[Hp] = _sgdY2::P64;
           R2 = _sgdY0::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdY3::P64;
           P64[Sp - 8] = _sgdY4::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.55696419 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose5_closure" {
     Data.Functor.Compose.$fApplicativeCompose5_closure:
         const Data.Functor.Compose.$fApplicativeCompose5_info;
 },
 sat_sgdYa_entry() //  [R1]
         { info_tbl: [(cgeAL,
                       label: sat_sgdYa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeAL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeAM; else goto cgeAN;
       cgeAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose5_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgeAO,
                       label: Data.Functor.Compose.$fApplicativeCompose5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeAO: // global
           _sgdY9::P64 = R5;
           _sgdY8::P64 = R4;
           _sgdY7::P64 = R3;
           _sgdY6::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeAP; else goto cgeAQ;
       cgeAQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeAS; else goto cgeAR;
       cgeAS: // global
           HpAlloc = 24;
           goto cgeAP;
       cgeAP: // global
           R5 = _sgdY9::P64;
           R4 = _sgdY8::P64;
           R3 = _sgdY7::P64;
           R2 = _sgdY6::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeAR: // global
           I64[Hp - 16] = sat_sgdYa_info;
           P64[Hp] = _sgdY7::P64;
           R2 = _sgdY6::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdY8::P64;
           P64[Sp - 8] = _sgdY9::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.558652425 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose6_closure" {
     Data.Functor.Compose.$fApplicativeCompose6_closure:
         const Data.Functor.Compose.$fApplicativeCompose6_info;
 },
 sat_sgdYe_entry() //  [R1]
         { info_tbl: [(cgeB1,
                       label: sat_sgdYe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeB1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeB2; else goto cgeB3;
       cgeB2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeB3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose6_entry() //  [R2, R3, R4]
         { info_tbl: [(cgeB4,
                       label: Data.Functor.Compose.$fApplicativeCompose6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeB4: // global
           _sgdYd::P64 = R4;
           _sgdYc::P64 = R3;
           _sgdYb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeB5; else goto cgeB6;
       cgeB6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeB8; else goto cgeB7;
       cgeB8: // global
           HpAlloc = 32;
           goto cgeB5;
       cgeB5: // global
           R4 = _sgdYd::P64;
           R3 = _sgdYc::P64;
           R2 = _sgdYb::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeB7: // global
           I64[Hp - 24] = sat_sgdYe_info;
           P64[Hp - 8] = _sgdYc::P64;
           P64[Hp] = _sgdYd::P64;
           R2 = _sgdYb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.560193339 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure" {
     Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure:
         const Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info;
 },
 sat_sgdYi_entry() //  [R1]
         { info_tbl: [(cgeBh,
                       label: sat_sgdYi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeBi; else goto cgeBj;
       cgeBi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeBj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdYh_entry() //  [R1]
         { info_tbl: [(cgeBo,
                       label: sat_sgdYh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeBp; else goto cgeBq;
       cgeBp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeBq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgeBr,
                       label: Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgeBv; else goto cgeBu;
       cgeBv: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeBu: // global
           I64[Hp - 40] = sat_sgdYi_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdYh_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.561620179 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose3_closure" {
     Data.Functor.Compose.$fApplicativeCompose3_closure:
         const Data.Functor.Compose.$fApplicativeCompose3_info;
 },
 Data.Functor.Compose.$fApplicativeCompose3_entry() //  [R3]
         { info_tbl: [(cgeBA,
                       label: Data.Functor.Compose.$fApplicativeCompose3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBA: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.562990372 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose2_closure" {
     Data.Functor.Compose.$fApplicativeCompose2_closure:
         const Data.Functor.Compose.$fApplicativeCompose2_info;
 },
 sat_sgdYs_entry() //  [R1]
         { info_tbl: [(cgeBR,
                       label: sat_sgdYs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeBS; else goto cgeBT;
       cgeBS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeBT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgeBP_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgeBP() //  [R1]
         { info_tbl: [(cgeBP,
                       label: block_cgeBP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Functor.Compose.$fApplicativeCompose3_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYt_entry() //  [R1]
         { info_tbl: [(cgeBZ,
                       label: sat_sgdYt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBZ: // global
           _sgdYt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeC0; else goto cgeC1;
       cgeC1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeC3; else goto cgeC2;
       cgeC3: // global
           HpAlloc = 24;
           goto cgeC0;
       cgeC0: // global
           R1 = _sgdYt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeC2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYt::P64;
           _sgdYl::P64 = P64[_sgdYt::P64 + 16];
           _sgdYm::P64 = P64[_sgdYt::P64 + 24];
           _sgdYn::P64 = P64[_sgdYt::P64 + 32];
           I64[Hp - 16] = sat_sgdYs_info;
           P64[Hp] = _sgdYm::P64;
           I64[Sp - 40] = block_cgeBX_info;
           R2 = _sgdYl::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgdYn::P64;
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgeBX() //  [R1]
         { info_tbl: [(cgeBX,
                       label: block_cgeBX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeBX: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdYp_entry() //  [R1]
         { info_tbl: [(cgeCb,
                       label: sat_sgdYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeCc; else goto cgeCd;
       cgeCc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeCd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgeCe,
                       label: Data.Functor.Compose.$fApplicativeCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCe: // global
           _sgdYo::P64 = R5;
           _sgdYn::P64 = R4;
           _sgdYm::P64 = R3;
           _sgdYl::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeCf; else goto cgeCg;
       cgeCg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgeCi; else goto cgeCh;
       cgeCi: // global
           HpAlloc = 64;
           goto cgeCf;
       cgeCf: // global
           R5 = _sgdYo::P64;
           R4 = _sgdYn::P64;
           R3 = _sgdYm::P64;
           R2 = _sgdYl::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeCh: // global
           I64[Hp - 56] = sat_sgdYt_info;
           P64[Hp - 40] = _sgdYl::P64;
           P64[Hp - 32] = _sgdYm::P64;
           P64[Hp - 24] = _sgdYn::P64;
           I64[Hp - 16] = sat_sgdYp_info;
           P64[Hp] = _sgdYm::P64;
           R2 = _sgdYl::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = _sgdYo::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.565343077 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose1_closure" {
     Data.Functor.Compose.$fApplicativeCompose1_closure:
         const Data.Functor.Compose.$fApplicativeCompose1_info;
 },
 sat_sgdYy_entry() //  [R1]
         { info_tbl: [(cgeCr,
                       label: sat_sgdYy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeCs; else goto cgeCt;
       cgeCs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeCt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose1_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgeCu,
                       label: Data.Functor.Compose.$fApplicativeCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCu: // global
           _sgdYx::P64 = R5;
           _sgdYw::P64 = R4;
           _sgdYv::P64 = R3;
           _sgdYu::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeCv; else goto cgeCw;
       cgeCw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeCy; else goto cgeCx;
       cgeCy: // global
           HpAlloc = 24;
           goto cgeCv;
       cgeCv: // global
           R5 = _sgdYx::P64;
           R4 = _sgdYw::P64;
           R3 = _sgdYv::P64;
           R2 = _sgdYu::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeCx: // global
           I64[Hp - 16] = sat_sgdYy_info;
           P64[Hp] = _sgdYv::P64;
           R2 = _sgdYu::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdYw::P64;
           P64[Sp - 8] = _sgdYx::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.567510774 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_closure" {
     Data.Functor.Compose.$fApplicativeCompose_closure:
         const Data.Functor.Compose.$fApplicativeCompose_info;
 },
 sat_sgdYG_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeCI,
                       label: sat_sgdYG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose1_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYF_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeCQ,
                       label: sat_sgdYF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCQ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgeCY,
                       label: sat_sgdYE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeCY: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fApplicativeCompose4_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYD_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeD6,
                       label: sat_sgdYD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeD6: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose5_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYC_entry() //  [R1, R2]
         { info_tbl: [(cgeDe,
                       label: sat_sgdYC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeDe: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fApplicativeCompose6_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYB_entry() //  [R1]
         { info_tbl: [(cgeDl,
                       label: sat_sgdYB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeDl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeDm; else goto cgeDn;
       cgeDm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeDn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cgeDp,
                       label: Data.Functor.Compose.$fApplicativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeDp: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cgeDt; else goto cgeDs;
       cgeDt: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeDs: // global
           I64[Hp - 200] = sat_sgdYG_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgdYF_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgdYE_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgdYD_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sgdYC_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgdYB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.570214566 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info;
 },
 sat_sgdYJ_entry() //  [R1]
         { info_tbl: [(cgeDC,
                       label: sat_sgdYJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeDC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeDD; else goto cgeDE;
       cgeDD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeDE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgeDF,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeDF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeDJ; else goto cgeDI;
       cgeDJ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeDI: // global
           I64[Hp - 16] = sat_sgdYJ_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.572295207 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$csome_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$csome_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$csome_info;
 },
 sat_sgdYQ_entry() //  [R1]
         { info_tbl: [(cgeE8,
                       label: sat_sgdYQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeE8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeE9; else goto cgeEa;
       cgeE9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeEa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYR_entry() //  [R1]
         { info_tbl: [(cgeEb,
                       label: sat_sgdYR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeEb: // global
           _sgdYR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeEc; else goto cgeEd;
       cgeEd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeEf; else goto cgeEe;
       cgeEf: // global
           HpAlloc = 24;
           goto cgeEc;
       cgeEc: // global
           R1 = _sgdYR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeEe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYR::P64;
           _sgdYL::P64 = P64[_sgdYR::P64 + 16];
           _sgdYO::P64 = P64[_sgdYR::P64 + 24];
           I64[Hp - 16] = sat_sgdYQ_info;
           P64[Hp] = _sgdYL::P64;
           R2 = _sgdYO::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYS_entry() //  [R1]
         { info_tbl: [(cgeEg,
                       label: sat_sgdYS_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeEg: // global
           _sgdYS::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeEh; else goto cgeEi;
       cgeEi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeEk; else goto cgeEj;
       cgeEk: // global
           HpAlloc = 32;
           goto cgeEh;
       cgeEh: // global
           R1 = _sgdYS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeEj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYS::P64;
           _sgdYK::P64 = P64[_sgdYS::P64 + 16];
           _sgdYL::P64 = P64[_sgdYS::P64 + 24];
           _sgdYN::P64 = P64[_sgdYS::P64 + 32];
           _sgdYO::P64 = P64[_sgdYS::P64 + 40];
           I64[Hp - 24] = sat_sgdYR_info;
           P64[Hp - 8] = _sgdYL::P64;
           P64[Hp] = _sgdYO::P64;
           R2 = _sgdYK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgdYN::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdYP_entry() //  [R1]
         { info_tbl: [(cgeEp,
                       label: sat_sgdYP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeEp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeEq; else goto cgeEr;
       cgeEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeEr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sgdYN_entry() //  [R1]
         { info_tbl: [(cgeEs,
                       label: some_v_sgdYN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeEs: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgeEt; else goto cgeEu;
       cgeEt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeEu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgeDS_info;
           _sgdYK::P64 = P64[R1 + 16];
           R2 = _sgdYK::P64;
           P64[Sp - 48] = _sgdYK::P64;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 56;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgeDS() //  [R1]
         { info_tbl: [(cgeDS,
                       label: block_cgeDS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeDS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgeEx; else goto cgeEw;
       cgeEx: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgeEw: // global
           I64[Hp - 64] = sat_sgdYS_info;
           P64[Hp - 48] = P64[Sp + 8];
           _sgdYL::P64 = P64[Sp + 16];
           P64[Hp - 40] = _sgdYL::P64;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sgdYP_info;
           P64[Hp] = _sgdYL::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgeEy,
                       label: Data.Functor.Compose.$fAlternativeCompose_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeEy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgeEC; else goto cgeEB;
       cgeEC: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeEB: // global
           I64[Hp - 32] = some_v_sgdYN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.576044449 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cmany_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cmany_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cmany_info;
 },
 $dApplicative1_sgdYX_entry() //  [R1]
         { info_tbl: [(cgeEP,
                       label: $dApplicative1_sgdYX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeEP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeEQ; else goto cgeER;
       cgeEQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeER: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ0_entry() //  [R1]
         { info_tbl: [(cgeF0,
                       label: sat_sgdZ0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeF0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeF1; else goto cgeF2;
       cgeF1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeF2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdZ1_entry() //  [R1]
         { info_tbl: [(cgeF3,
                       label: sat_sgdZ1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeF3: // global
           _sgdZ1::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeF4; else goto cgeF5;
       cgeF5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeF7; else goto cgeF6;
       cgeF7: // global
           HpAlloc = 24;
           goto cgeF4;
       cgeF4: // global
           R1 = _sgdZ1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeF6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdZ1::P64;
           _sgdYU::P64 = P64[_sgdZ1::P64 + 16];
           _sgdYX::P64 = P64[_sgdZ1::P64 + 24];
           I64[Hp - 16] = sat_sgdZ0_info;
           P64[Hp] = _sgdYU::P64;
           R2 = _sgdYX::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYY_entry() //  [R1]
         { info_tbl: [(cgeFg,
                       label: sat_sgdYY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeFh; else goto cgeFi;
       cgeFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYZ_entry() //  [R1]
         { info_tbl: [(cgeFj,
                       label: sat_sgdYZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFj: // global
           _sgdYZ::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cgeFk; else goto cgeFl;
       cgeFl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeFn; else goto cgeFm;
       cgeFn: // global
           HpAlloc = 24;
           goto cgeFk;
       cgeFk: // global
           R1 = _sgdYZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeFm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYZ::P64;
           _sgdYU::P64 = P64[_sgdYZ::P64 + 16];
           _sgdYV::P64 = P64[_sgdYZ::P64 + 24];
           _sgdYW::P64 = P64[_sgdYZ::P64 + 32];
           _sgdYX::P64 = P64[_sgdYZ::P64 + 40];
           I64[Hp - 16] = sat_sgdYY_info;
           P64[Hp] = _sgdYU::P64;
           R2 = _sgdYX::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgdYV::P64;
           P64[Sp - 24] = _sgdYW::P64;
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_sgdYW_entry() //  [R1]
         { info_tbl: [(cgeFo,
                       label: many_v_sgdYW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFo: // global
           _sgdYW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeFp; else goto cgeFq;
       cgeFq: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgeFs; else goto cgeFr;
       cgeFs: // global
           HpAlloc = 104;
           goto cgeFp;
       cgeFp: // global
           R1 = _sgdYW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeFr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYW::P64;
           _sgdYT::P64 = P64[_sgdYW::P64 + 16];
           _sgdYU::P64 = P64[_sgdYW::P64 + 24];
           _sgdYV::P64 = P64[_sgdYW::P64 + 32];
           I64[Hp - 96] = $dApplicative1_sgdYX_info;
           P64[Hp - 80] = _sgdYT::P64;
           I64[Hp - 72] = sat_sgdZ1_info;
           P64[Hp - 56] = _sgdYU::P64;
           _cgeEL::P64 = Hp - 96;
           P64[Hp - 48] = _cgeEL::P64;
           I64[Hp - 40] = sat_sgdYZ_info;
           P64[Hp - 24] = _sgdYU::P64;
           P64[Hp - 16] = _sgdYV::P64;
           P64[Hp - 8] = _sgdYW::P64;
           P64[Hp] = _cgeEL::P64;
           R2 = _sgdYT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cmany_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgeFt,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgeFx; else goto cgeFw;
       cgeFx: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeFw: // global
           I64[Hp - 32] = many_v_sgdYW_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.579614222 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_closure" {
     Data.Functor.Compose.$fAlternativeCompose_closure:
         const Data.Functor.Compose.$fAlternativeCompose_info;
 },
 sat_sgdZ8_entry() //  [R1, R2]
         { info_tbl: [(cgeFH,
                       label: sat_sgdZ8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFH: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$cmany_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZ7_entry() //  [R1, R2]
         { info_tbl: [(cgeFP,
                       label: sat_sgdZ7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFP: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZ6_entry() //  [R1]
         { info_tbl: [(cgeFW,
                       label: sat_sgdZ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeFW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeFX; else goto cgeFY;
       cgeFX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeFY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ5_entry() //  [R1]
         { info_tbl: [(cgeG3,
                       label: sat_sgdZ5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeG3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeG4; else goto cgeG5;
       cgeG4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeG5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ4_entry() //  [R1]
         { info_tbl: [(cgeGa,
                       label: sat_sgdZ4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeGb; else goto cgeGc;
       cgeGb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeGc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cgeGe,
                       label: Data.Functor.Compose.$fAlternativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGe: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgeGi; else goto cgeGh;
       cgeGi: // global
           HpAlloc = 176;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeGh: // global
           I64[Hp - 168] = sat_sgdZ8_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           I64[Hp - 144] = sat_sgdZ7_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sgdZ6_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sgdZ5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgdZ4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 120;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = Hp - 167;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.582022923 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose1_closure" {
     Data.Functor.Compose.$fGeneric1Compose1_closure:
         const Data.Functor.Compose.$fGeneric1Compose1_info;
 },
 Data.Functor.Compose.$fGeneric1Compose1_entry() //  [R2, R3]
         { info_tbl: [(cgeGn,
                       label: Data.Functor.Compose.$fGeneric1Compose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgeGo; else goto cgeGp;
       cgeGo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeGp: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Generics.$fGeneric1:.:2_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.583003918 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose3_closure" {
     Data.Functor.Compose.$fGeneric1Compose3_closure:
         const Data.Functor.Compose.$fGeneric1Compose3_info;
 },
 Data.Functor.Compose.$fGeneric1Compose3_entry() //  [R2]
         { info_tbl: [(cgeGu,
                       label: Data.Functor.Compose.$fGeneric1Compose3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGu: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.583819502 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose2_closure" {
     Data.Functor.Compose.$fGeneric1Compose2_closure:
         const Data.Functor.Compose.$fGeneric1Compose2_info;
 },
 Data.Functor.Compose.$fGeneric1Compose2_entry() //  [R2, R3]
         { info_tbl: [(cgeGB,
                       label: Data.Functor.Compose.$fGeneric1Compose2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgeGC; else goto cgeGD;
       cgeGC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeGD: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Data.Functor.Compose.$fGeneric1Compose3_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.585060052 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose_closure" {
     Data.Functor.Compose.$fGeneric1Compose_closure:
         const Data.Functor.Compose.$fGeneric1Compose_info;
 },
 sat_sgdZg_entry() //  [R1, R2]
         { info_tbl: [(cgeGN,
                       label: sat_sgdZg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZf_entry() //  [R1, R2]
         { info_tbl: [(cgeGV,
                       label: sat_sgdZf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose2_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fGeneric1Compose_entry() //  [R2]
         { info_tbl: [(cgeGZ,
                       label: Data.Functor.Compose.$fGeneric1Compose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeGZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeH3; else goto cgeH2;
       cgeH3: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeH2: // global
           I64[Hp - 48] = sat_sgdZg_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sgdZf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Generics.C:Generic1_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.586366672 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose1_closure" {
     Data.Functor.Compose.$fGenericCompose1_closure:
         const Data.Functor.Compose.$fGenericCompose1_info;
 },
 Data.Functor.Compose.$fGenericCompose1_entry() //  [R2]
         { info_tbl: [(cgeH8,
                       label: Data.Functor.Compose.$fGenericCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeH8: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.587144622 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose2_closure" {
     Data.Functor.Compose.$fGenericCompose2_closure:
         const Data.Functor.Compose.$fGenericCompose2_info;
 },
 Data.Functor.Compose.$fGenericCompose2_entry() //  [R2]
         { info_tbl: [(cgeHf,
                       label: Data.Functor.Compose.$fGenericCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.587813276 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose_closure" {
     Data.Functor.Compose.$fGenericCompose_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Compose.$fGenericCompose2_closure+1;
         const Data.Functor.Compose.$fGenericCompose1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.58851918 UTC

[section ""data" . Data.Functor.Compose.getCompose1_closure" {
     Data.Functor.Compose.getCompose1_closure:
         const Data.Functor.Compose.getCompose1_info;
 },
 Data.Functor.Compose.getCompose1_entry() //  [R2]
         { info_tbl: [(cgeHm,
                       label: Data.Functor.Compose.getCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.589336427 UTC

[section ""data" . Data.Functor.Compose.getCompose_closure" {
     Data.Functor.Compose.getCompose_closure:
         const Data.Functor.Compose.getCompose_info;
 },
 Data.Functor.Compose.getCompose_entry() //  [R2]
         { info_tbl: [(cgeHt,
                       label: Data.Functor.Compose.getCompose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHt: // global
           R2 = R2;
           call Data.Functor.Compose.getCompose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.590026688 UTC

[section ""cstring" . $cCompose1_rgdPU_bytes" {
     $cCompose1_rgdPU_bytes:
         I8[] [103,101,116,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.5907653 UTC

[section ""data" . $cCompose2_rgdPV_closure" {
     $cCompose2_rgdPV_closure:
         const $cCompose2_rgdPV_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose2_rgdPV_entry() //  [R1]
         { info_tbl: [(cgeHC,
                       label: $cCompose2_rgdPV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeHD; else goto cgeHE;
       cgeHD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeHE: // global
           (_cgeHz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgeHz::I64 == 0) goto cgeHB; else goto cgeHA;
       cgeHB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgeHA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgeHz::I64;
           R2 = $cCompose1_rgdPU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.591633199 UTC

[section ""data" . $cCompose3_rgdPW_closure" {
     $cCompose3_rgdPW_closure:
         const :_con_info;
         const $cCompose2_rgdPV_closure;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.593022905 UTC

[section ""data" . go61_rgdPX_closure" {
     go61_rgdPX_closure:
         const go61_rgdPX_info;
         const 0;
 },
 go61_rgdPX_entry() //  [R2, R3]
         { info_tbl: [(cgeHQ,
                       label: go61_rgdPX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeHR; else goto ugeIu;
       cgeHR: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgdPX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugeIu: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgeHG() args: 0, res: 0, upd: 0;
     }
 },
 _cgeHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHG: // global
           _sgdZk::P64 = P64[Sp];
           I64[Sp] = block_cgeHJ_info;
           R1 = _sgdZk::P64;
           if (R1 & 7 != 0) goto ugeIy; else goto cgeHK;
       ugeIy: // global
           call _cgeHJ(R1) args: 0, res: 0, upd: 0;
       cgeHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeHJ() //  [R1]
         { info_tbl: [(cgeHJ,
                       label: block_cgeHJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHJ: // global
           if (R1 & 7 == 1) goto ugeIv; else goto cgeHO;
       ugeIv: // global
           Sp = Sp + 16;
           call _cgeI6() args: 0, res: 0, upd: 0;
       cgeHO: // global
           I64[Sp - 8] = block_cgeHY_info;
           _sgdZn::P64 = P64[R1 + 6];
           _sgdZo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgdZo::P64;
           P64[Sp + 8] = _sgdZn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugeIz; else goto cgeI0;
       ugeIz: // global
           call _cgeHY(R1) args: 0, res: 0, upd: 0;
       cgeI0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeHY() //  [R1]
         { info_tbl: [(cgeHY,
                       label: block_cgeHY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeHY: // global
           if (R1 & 7 == 1) goto ugeIw; else goto cgeIb;
       ugeIw: // global
           Sp = Sp + 24;
           call _cgeI6() args: 0, res: 0, upd: 0;
       cgeIb: // global
           I64[Sp - 8] = block_cgeI9_info;
           _sgdZq::P64 = P64[R1 + 6];
           _sgdZr::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgdZr::P64;
           P64[Sp + 16] = _sgdZq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugeIC; else goto cgeIc;
       ugeIC: // global
           call _cgeI9(R1) args: 0, res: 0, upd: 0;
       cgeIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeI6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeI6: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgeI9() //  [R1]
         { info_tbl: [(cgeI9,
                       label: block_cgeI9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeI9: // global
           I64[Sp] = block_cgeIg_info;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeIg() //  [R1]
         { info_tbl: [(cgeIg,
                       label: block_cgeIg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeIg: // global
           if (R1 & 7 == 1) goto cgeIn; else goto cgeIr;
       cgeIn: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgeHG() args: 0, res: 0, upd: 0;
       cgeIr: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.597846908 UTC

[section ""data" . $cCompose4_rgdPY_closure" {
     $cCompose4_rgdPY_closure:
         const Data.Data.AlgConstr_con_info;
         const $cCompose5_rgdPZ_closure;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose5_closure" {
     Data.Functor.Compose.$fDataCompose5_closure:
         const :_con_info;
         const Data.Functor.Compose.$cCompose_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose4_closure" {
     Data.Functor.Compose.$fDataCompose4_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Compose.$fDataCompose5_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$tCompose_closure" {
     Data.Functor.Compose.$tCompose_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$fDataCompose4_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$cCompose_closure" {
     Data.Functor.Compose.$cCompose_closure:
         const Data.Data.Constr_con_info;
         const $cCompose4_rgdPY_closure+1;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const $cCompose3_rgdPW_closure+2;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Compose.$tCompose_closure+1;
         const 0;
 },
 section ""data" . $cCompose5_rgdPZ_closure" {
     $cCompose5_rgdPZ_closure:
         const $cCompose5_rgdPZ_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose5_rgdPZ_entry() //  [R1]
         { info_tbl: [(cgeIL,
                       label: $cCompose5_rgdPZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeIM; else goto cgeIN;
       cgeIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeIN: // global
           (_cgeII::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgeII::I64 == 0) goto cgeIK; else goto cgeIJ;
       cgeIK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgeIJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgeII::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Compose.$fDataCompose5_closure+2;
           Sp = Sp - 16;
           call go61_rgdPX_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.599163802 UTC

[section ""cstring" . Data.Functor.Compose.$trModule4_bytes" {
     Data.Functor.Compose.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.599774765 UTC

[section ""data" . Data.Functor.Compose.$trModule3_closure" {
     Data.Functor.Compose.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.600303146 UTC

[section ""cstring" . Data.Functor.Compose.$trModule2_bytes" {
     Data.Functor.Compose.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.600851498 UTC

[section ""data" . Data.Functor.Compose.$trModule1_closure" {
     Data.Functor.Compose.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.601458232 UTC

[section ""data" . Data.Functor.Compose.$trModule_closure" {
     Data.Functor.Compose.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Compose.$trModule3_closure+1;
         const Data.Functor.Compose.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.60202893 UTC

[section ""data" . $krep_rgdQ0_closure" {
     $krep_rgdQ0_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.602577739 UTC

[section ""data" . $krep1_rgdQ1_closure" {
     $krep1_rgdQ1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.603141531 UTC

[section ""data" . $krep2_rgdQ2_closure" {
     $krep2_rgdQ2_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.603723533 UTC

[section ""data" . $krep3_rgdQ3_closure" {
     $krep3_rgdQ3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgdQ2_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.604277441 UTC

[section ""data" . $krep4_rgdQ4_closure" {
     $krep4_rgdQ4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep2_rgdQ2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.604855941 UTC

[section ""data" . $krep5_rgdQ5_closure" {
     $krep5_rgdQ5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rgdQ4_closure+4;
         const $krep1_rgdQ1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.605507187 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose9_closure" {
     Data.Functor.Compose.$fDataCompose9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgdQ3_closure+4;
         const $krep5_rgdQ5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.606098174 UTC

[section ""data" . $krep6_rgdQ6_closure" {
     $krep6_rgdQ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.606639161 UTC

[section ""data" . $krep7_rgdQ7_closure" {
     $krep7_rgdQ7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.60722168 UTC

[section ""data" . $krep8_rgdQ8_closure" {
     $krep8_rgdQ8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.607760426 UTC

[section ""data" . $krep9_rgdQ9_closure" {
     $krep9_rgdQ9_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep8_rgdQ8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.608303216 UTC

[section ""data" . $krep10_rgdQa_closure" {
     $krep10_rgdQa_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep9_rgdQ9_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.608880069 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose10_closure" {
     Data.Functor.Compose.$fDataCompose10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$fDataCompose7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.609500639 UTC

[section ""data" . Data.Functor.Compose.$tcCompose_closure" {
     Data.Functor.Compose.$tcCompose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$fDataCompose10_closure+1;
         const Data.Functor.Compose.$fDataCompose9_closure+4;
         const 6729400645769595507;
         const 7487202375031942550;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.610137819 UTC

[section ""data" . $krep11_rgdQb_closure" {
     $krep11_rgdQb_closure:
         const :_con_info;
         const $krep8_rgdQ8_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.610718325 UTC

[section ""data" . $krep12_rgdQc_closure" {
     $krep12_rgdQc_closure:
         const :_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep11_rgdQb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.611286328 UTC

[section ""data" . $krep13_rgdQd_closure" {
     $krep13_rgdQd_closure:
         const :_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep12_rgdQc_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.611869917 UTC

[section ""data" . $krep14_rgdQe_closure" {
     $krep14_rgdQe_closure:
         const :_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep13_rgdQd_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.612462438 UTC

[section ""data" . $krep15_rgdQf_closure" {
     $krep15_rgdQf_closure:
         const :_con_info;
         const $krep2_rgdQ2_closure+2;
         const $krep14_rgdQe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.613062615 UTC

[section ""data" . $krep16_rgdQg_closure" {
     $krep16_rgdQg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Compose.$tcCompose_closure+1;
         const $krep15_rgdQf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.613697583 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose1_closure" {
     Data.Functor.Compose.$tc'Compose1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rgdQa_closure+3;
         const $krep16_rgdQg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.614253677 UTC

[section ""cstring" . Data.Functor.Compose.$tc'Compose3_bytes" {
     Data.Functor.Compose.$tc'Compose3_bytes:
         I8[] [39,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.614810222 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose2_closure" {
     Data.Functor.Compose.$tc'Compose2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$tc'Compose3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.61535979 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose_closure" {
     Data.Functor.Compose.$tc'Compose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$tc'Compose2_closure+1;
         const Data.Functor.Compose.$tc'Compose1_closure+4;
         const 7236514282653524344;
         const 13791541438620948974;
         const 5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.616692185 UTC

[section ""data" . Data.Functor.Compose.$w$cp1Data_closure" {
     Data.Functor.Compose.$w$cp1Data_closure:
         const Data.Functor.Compose.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Compose.$w$cp1Data_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgeJ3,
                       label: Data.Functor.Compose.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJ3: // global
           _sgdZD::P64 = R6;
           _sgdZC::P64 = R5;
           _sgdZB::P64 = R4;
           _sgdZA::P64 = R3;
           _sgdZz::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cgeJ7; else goto cgeJ8;
       cgeJ8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgeJa; else goto cgeJ9;
       cgeJa: // global
           HpAlloc = 80;
           goto cgeJ7;
       cgeJ7: // global
           R6 = _sgdZD::P64;
           R5 = _sgdZC::P64;
           R4 = _sgdZB::P64;
           R3 = _sgdZA::P64;
           R2 = _sgdZz::P64;
           R1 = Data.Functor.Compose.$w$cp1Data_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeJ9: // global
           I64[Hp - 72] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 64] = _sgdZD::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sgdZC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           I64[Sp - 32] = block_cgeIW_info;
           R6 = 2;
           R5 = Data.Functor.Compose.$fDataCompose10_closure+1;
           R4 = Data.Functor.Compose.$trModule_closure+1;
           R3 = 7487202375031942550;
           R2 = 6729400645769595507;
           P64[Sp - 48] = Data.Functor.Compose.$fDataCompose9_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sgdZz::P64;
           P64[Sp - 16] = _sgdZA::P64;
           P64[Sp - 8] = _sgdZB::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgeIW() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgeIW,
                       label: block_cgeIW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeIW: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgeIX() args: 0, res: 0, upd: 0;
     }
 },
 _cgeIX() //  []
         { info_tbl: [(cgeIX,
                       label: block_cgeIX_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeIX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgeJd; else goto cgeJc;
       cgeJd: // global
           HpAlloc = 48;
           I64[Sp] = block_cgeIX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cgeJc: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cgeJ1_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeJ1() //  [R1]
         { info_tbl: [(cgeJ1,
                       label: block_cgeJ1_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJ1: // global
           I64[Sp] = block_cgeJ6_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeJ6() //  [R1]
         { info_tbl: [(cgeJ6,
                       label: block_cgeJ6_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJ6: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.618952475 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose8_closure" {
     Data.Functor.Compose.$fDataCompose8_closure:
         const Data.Functor.Compose.$fDataCompose8_info;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose8_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgeJp,
                       label: Data.Functor.Compose.$fDataCompose8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJp: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.619842511 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose2_closure" {
     Data.Functor.Compose.$fDataCompose2_closure:
         const Data.Functor.Compose.$fDataCompose2_info;
 },
 Data.Functor.Compose.$fDataCompose2_entry() //  [R2]
         { info_tbl: [(cgeJw,
                       label: Data.Functor.Compose.$fDataCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJw: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.620558162 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose1_closure" {
     Data.Functor.Compose.$fDataCompose1_closure:
         const (,)_con_info;
         const Data.Functor.Compose.$fDataCompose2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.623322513 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMp_closure" {
     Data.Functor.Compose.$w$cgmapMp_closure:
         const Data.Functor.Compose.$w$cgmapMp_info;
 },
 lvl8_sge02_entry() //  [R1]
         { info_tbl: [(cgeJH,
                       label: lvl8_sge02_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeJI; else goto cgeJJ;
       cgeJI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeJJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge0p_entry() //  [R1, R2]
         { info_tbl: [(cgeJW,
                       label: sat_sge0p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeJX; else goto cgeJY;
       cgeJX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeJY: // global
           I64[Sp - 24] = block_cgeJT_info;
           _sge02::P64 = P64[R1 + 7];
           _sge03::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sge02::P64;
           P64[Sp - 8] = _sge03::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugeKg; else goto cgeJU;
       ugeKg: // global
           call _cgeJT(R1) args: 0, res: 0, upd: 0;
       cgeJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeJT() //  [R1]
         { info_tbl: [(cgeJT,
                       label: block_cgeJT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJT: // global
           I64[Sp - 8] = block_cgeK1_info;
           _sge0m::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge0m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugeKf; else goto cgeK3;
       ugeKf: // global
           call _cgeK1(R1) args: 0, res: 0, upd: 0;
       cgeK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeK1() //  [R1]
         { info_tbl: [(cgeK1,
                       label: block_cgeK1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeK1: // global
           if (R1 & 7 == 1) goto cgeK9; else goto cgeKd;
       cgeK9: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgeKd: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0h_entry() //  [R1]
         { info_tbl: [(cgeKC,
                       label: sat_sge0h_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeKC: // global
           _sge0h::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeKD; else goto cgeKE;
       cgeKE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeKG; else goto cgeKF;
       cgeKG: // global
           HpAlloc = 56;
           goto cgeKD;
       cgeKD: // global
           R1 = _sge0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeKF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0h::P64;
           _sge01::P64 = P64[_sge0h::P64 + 16];
           _sge03::P64 = P64[_sge0h::P64 + 24];
           _sge08::P64 = P64[_sge0h::P64 + 32];
           _sge09::P64 = P64[_sge0h::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge08::P64;
           P64[Hp - 24] = _sge01::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sge09::P64;
           R2 = _sge03::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge0d_entry() //  [R1, R2]
         { info_tbl: [(cgeKS,
                       label: sat_sge0d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeKS: // global
           _sge0a::P64 = R2;
           _sge0d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeKT; else goto cgeKU;
       cgeKU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeKW; else goto cgeKV;
       cgeKW: // global
           HpAlloc = 56;
           goto cgeKT;
       cgeKT: // global
           R2 = _sge0a::P64;
           R1 = _sge0d::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeKV: // global
           _sge03::P64 = P64[_sge0d::P64 + 7];
           _sge08::P64 = P64[_sge0d::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge08::P64;
           P64[Hp - 24] = _sge0a::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge03::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0e_entry() //  [R1]
         { info_tbl: [(cgeKX,
                       label: sat_sge0e_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeKX: // global
           _sge0e::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeKY; else goto cgeKZ;
       cgeKZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeL1; else goto cgeL0;
       cgeL1: // global
           HpAlloc = 24;
           goto cgeKY;
       cgeKY: // global
           R1 = _sge0e::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeL0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0e::P64;
           _sge03::P64 = P64[_sge0e::P64 + 16];
           _sge04::P64 = P64[_sge0e::P64 + 24];
           _sge08::P64 = P64[_sge0e::P64 + 32];
           I64[Hp - 16] = sat_sge0d_info;
           P64[Hp - 8] = _sge03::P64;
           P64[Hp] = _sge08::P64;
           R2 = _sge03::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sge04::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sge0i_entry() //  [R1, R2]
         { info_tbl: [(cgeL2,
                       label: sat_sge0i_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeL2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeL3; else goto cgeL4;
       cgeL3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeL4: // global
           I64[Sp - 40] = block_cgeKr_info;
           _sgdZZ::P64 = P64[R1 + 7];
           _sge01::P64 = P64[R1 + 15];
           _sge03::P64 = P64[R1 + 23];
           _sge04::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgdZZ::P64;
           P64[Sp - 24] = _sge01::P64;
           P64[Sp - 16] = _sge03::P64;
           P64[Sp - 8] = _sge04::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugeL8; else goto cgeKs;
       ugeL8: // global
           call _cgeKr(R1) args: 0, res: 0, upd: 0;
       cgeKs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeKr() //  [R1]
         { info_tbl: [(cgeKr,
                       label: block_cgeKr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeKr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgeL7; else goto cgeL6;
       cgeL7: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeL6: // global
           _sge08::P64 = P64[R1 + 7];
           _sge09::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sge0h_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sge03::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sge03::P64;
           P64[Hp - 48] = _sge08::P64;
           P64[Hp - 40] = _sge09::P64;
           I64[Hp - 32] = sat_sge0e_info;
           P64[Hp - 16] = _sge03::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sge08::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sge05_entry() //  [R1]
         { info_tbl: [(cgeLd,
                       label: sat_sge05_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeLe; else goto cgeLf;
       cgeLe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeLf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge0j_entry() //  [R1]
         { info_tbl: [(cgeLg,
                       label: sat_sge0j_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLg: // global
           _sge0j::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeLh; else goto cgeLi;
       cgeLi: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgeLk; else goto cgeLj;
       cgeLk: // global
           HpAlloc = 104;
           goto cgeLh;
       cgeLh: // global
           R1 = _sge0j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeLj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0j::P64;
           _sgdZY::P64 = P64[_sge0j::P64 + 16];
           _sgdZZ::P64 = P64[_sge0j::P64 + 24];
           _sge00::P64 = P64[_sge0j::P64 + 32];
           _sge01::P64 = P64[_sge0j::P64 + 40];
           _sge03::P64 = P64[_sge0j::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sge00::P64;
           P64[Hp - 72] = _sgdZY::P64;
           P64[Hp - 64] = _sge01::P64;
           I64[Hp - 56] = sat_sge0i_info;
           P64[Hp - 48] = _sgdZZ::P64;
           P64[Hp - 40] = _sge01::P64;
           P64[Hp - 32] = _sge03::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sge05_info;
           P64[Hp] = _sge03::P64;
           R2 = _sge03::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgeLl,
                       label: Data.Functor.Compose.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLl: // global
           _sge01::P64 = R5;
           _sge00::P64 = R4;
           _sgdZZ::P64 = R3;
           _sgdZY::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgeLm; else goto cgeLn;
       cgeLn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeLp; else goto cgeLo;
       cgeLp: // global
           HpAlloc = 24;
           goto cgeLm;
       cgeLm: // global
           R5 = _sge01::P64;
           R4 = _sge00::P64;
           R3 = _sgdZZ::P64;
           R2 = _sgdZY::P64;
           R1 = Data.Functor.Compose.$w$cgmapMp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeLo: // global
           I64[Hp - 16] = lvl8_sge02_info;
           P64[Hp] = _sgdZZ::P64;
           I64[Sp - 48] = block_cgeJK_info;
           R2 = _sgdZZ::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgdZY::P64;
           P64[Sp - 24] = _sgdZZ::P64;
           P64[Sp - 16] = _sge00::P64;
           P64[Sp - 8] = _sge01::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeJK() //  [R1]
         { info_tbl: [(cgeJK,
                       label: block_cgeJK_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeJK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgeLs; else goto cgeLr;
       cgeLs: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeLr: // global
           I64[Hp - 72] = sat_sge0p_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sge0j_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.62955853 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMp_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMp_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMp_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLu: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_entry() //  []
         { info_tbl: [(cgeLy,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLy: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.631230938 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapM_closure" {
     Data.Functor.Compose.$w$cgmapM_closure:
         const Data.Functor.Compose.$w$cgmapM_info;
 },
 sat_sge0I_entry() //  [R1, R2]
         { info_tbl: [(cgeLR,
                       label: sat_sge0I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLR: // global
           _sge0G::P64 = R2;
           _sge0I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeLS; else goto cgeLT;
       cgeLT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeLV; else goto cgeLU;
       cgeLV: // global
           HpAlloc = 32;
           goto cgeLS;
       cgeLS: // global
           R2 = _sge0G::P64;
           R1 = _sge0I::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeLU: // global
           _sge0A::P64 = P64[_sge0I::P64 + 7];
           _sge0F::P64 = P64[_sge0I::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sge0F::P64;
           P64[Hp] = _sge0G::P64;
           R2 = _sge0A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0J_entry() //  [R1, R2]
         { info_tbl: [(cgeLW,
                       label: sat_sge0J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeLW: // global
           _sge0F::P64 = R2;
           _sge0J::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgeLX; else goto cgeLY;
       cgeLY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeM0; else goto cgeLZ;
       cgeM0: // global
           HpAlloc = 24;
           goto cgeLX;
       cgeLX: // global
           R2 = _sge0F::P64;
           R1 = _sge0J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeLZ: // global
           _sge0A::P64 = P64[_sge0J::P64 + 7];
           _sge0D::P64 = P64[_sge0J::P64 + 15];
           I64[Hp - 16] = sat_sge0I_info;
           P64[Hp - 8] = _sge0A::P64;
           P64[Hp] = _sge0F::P64;
           R2 = _sge0A::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sge0D::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sge0E_entry() //  [R1]
         { info_tbl: [(cgeM5,
                       label: sat_sge0E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeM5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeM6; else goto cgeM7;
       cgeM6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeM7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgeM8,
                       label: Data.Functor.Compose.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeM8: // global
           _sge0C::P64 = R5;
           _sge0B::P64 = R4;
           _sge0A::P64 = R3;
           _sge0z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgeM9; else goto cgeMa;
       cgeMa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgeMc; else goto cgeMb;
       cgeMc: // global
           HpAlloc = 88;
           goto cgeM9;
       cgeM9: // global
           R5 = _sge0C::P64;
           R4 = _sge0B::P64;
           R3 = _sge0A::P64;
           R2 = _sge0z::P64;
           R1 = Data.Functor.Compose.$w$cgmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeMb: // global
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = _sge0B::P64;
           P64[Hp - 56] = _sge0z::P64;
           P64[Hp - 48] = _sge0C::P64;
           I64[Hp - 40] = sat_sge0J_info;
           P64[Hp - 32] = _sge0A::P64;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = sat_sge0E_info;
           P64[Hp] = _sge0A::P64;
           R2 = _sge0A::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.63354841 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapM_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapM_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapM_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMe: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_entry() //  []
         { info_tbl: [(cgeMi,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMi: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.636815418 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMo_closure" {
     Data.Functor.Compose.$w$cgmapMo_closure:
         const Data.Functor.Compose.$w$cgmapMo_info;
 },
 lvl8_sge0X_entry() //  [R1]
         { info_tbl: [(cgeMt,
                       label: lvl8_sge0X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeMu; else goto cgeMv;
       cgeMu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeMv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1n_entry() //  [R1, R2]
         { info_tbl: [(cgeMI,
                       label: sat_sge1n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeMJ; else goto cgeMK;
       cgeMJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeMK: // global
           I64[Sp - 24] = block_cgeMF_info;
           _sge0X::P64 = P64[R1 + 7];
           _sge0Y::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sge0X::P64;
           P64[Sp - 8] = _sge0Y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugeN2; else goto cgeMG;
       ugeN2: // global
           call _cgeMF(R1) args: 0, res: 0, upd: 0;
       cgeMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeMF() //  [R1]
         { info_tbl: [(cgeMF,
                       label: block_cgeMF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMF: // global
           I64[Sp - 8] = block_cgeMN_info;
           _sge1k::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge1k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugeN1; else goto cgeMP;
       ugeN1: // global
           call _cgeMN(R1) args: 0, res: 0, upd: 0;
       cgeMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeMN() //  [R1]
         { info_tbl: [(cgeMN,
                       label: block_cgeMN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMN: // global
           if (R1 & 7 == 1) goto cgeMV; else goto cgeMZ;
       cgeMV: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgeMZ: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge1d_entry() //  [R1]
         { info_tbl: [(cgeNt,
                       label: sat_sge1d_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeNt: // global
           _sge1d::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeNu; else goto cgeNv;
       cgeNv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeNx; else goto cgeNw;
       cgeNx: // global
           HpAlloc = 56;
           goto cgeNu;
       cgeNu: // global
           R1 = _sge1d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeNw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1d::P64;
           _sge0W::P64 = P64[_sge1d::P64 + 16];
           _sge0Y::P64 = P64[_sge1d::P64 + 24];
           _sge13::P64 = P64[_sge1d::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge0W::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sge0Y::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge19_entry() //  [R1, R2]
         { info_tbl: [(cgeNJ,
                       label: sat_sge19_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeNJ: // global
           _sge16::P64 = R2;
           _sge19::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeNK; else goto cgeNL;
       cgeNL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeNN; else goto cgeNM;
       cgeNN: // global
           HpAlloc = 56;
           goto cgeNK;
       cgeNK: // global
           R2 = _sge16::P64;
           R1 = _sge19::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeNM: // global
           _sge0Y::P64 = P64[_sge19::P64 + 7];
           _sge13::P64 = P64[_sge19::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge16::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge0Y::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge1a_entry() //  [R1]
         { info_tbl: [(cgeNO,
                       label: sat_sge1a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeNO: // global
           _sge1a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeNP; else goto cgeNQ;
       cgeNQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeNS; else goto cgeNR;
       cgeNS: // global
           HpAlloc = 24;
           goto cgeNP;
       cgeNP: // global
           R1 = _sge1a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeNR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1a::P64;
           _sge0Y::P64 = P64[_sge1a::P64 + 16];
           _sge0Z::P64 = P64[_sge1a::P64 + 24];
           _sge13::P64 = P64[_sge1a::P64 + 32];
           I64[Hp - 16] = sat_sge19_info;
           P64[Hp - 8] = _sge0Y::P64;
           P64[Hp] = _sge13::P64;
           R2 = _sge0Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sge0Z::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sge1g_entry() //  [R1, R2]
         { info_tbl: [(cgeNT,
                       label: sat_sge1g_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeNT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgeNU; else goto cgeNV;
       cgeNU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeNV: // global
           I64[Sp - 40] = block_cgeNd_info;
           _sge0U::P64 = P64[R1 + 7];
           _sge0W::P64 = P64[R1 + 15];
           _sge0Y::P64 = P64[R1 + 23];
           _sge0Z::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sge0U::P64;
           P64[Sp - 24] = _sge0W::P64;
           P64[Sp - 16] = _sge0Y::P64;
           P64[Sp - 8] = _sge0Z::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugeOc; else goto cgeNe;
       ugeOc: // global
           call _cgeNd(R1) args: 0, res: 0, upd: 0;
       cgeNe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeNd() //  [R1]
         { info_tbl: [(cgeNd,
                       label: block_cgeNd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeNd: // global
           I64[Sp - 8] = block_cgeNi_info;
           _sge13::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge13::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugeOb; else goto cgeNj;
       ugeOb: // global
           call _cgeNi(R1) args: 0, res: 0, upd: 0;
       cgeNj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeNi() //  [R1]
         { info_tbl: [(cgeNi,
                       label: block_cgeNi_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeNi: // global
           _sge0W::P64 = P64[Sp + 24];
           _sge0Y::P64 = P64[Sp + 32];
           _sge13::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgeNY; else goto cgeO2;
       cgeNY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgeO1; else goto cgeO0;
       cgeO1: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeO0: // global
           I64[Hp - 72] = sat_sge1d_info;
           P64[Hp - 56] = _sge0W::P64;
           P64[Hp - 48] = _sge0Y::P64;
           P64[Hp - 40] = _sge13::P64;
           I64[Hp - 32] = sat_sge1a_info;
           P64[Hp - 16] = _sge0Y::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sge13::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgeO2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgeO7; else goto cgeO6;
       cgeO7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeO6: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge0W::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge0Y::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge10_entry() //  [R1]
         { info_tbl: [(cgeOh,
                       label: sat_sge10_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeOi; else goto cgeOj;
       cgeOi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeOj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge1h_entry() //  [R1]
         { info_tbl: [(cgeOk,
                       label: sat_sge1h_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOk: // global
           _sge1h::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeOl; else goto cgeOm;
       cgeOm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgeOo; else goto cgeOn;
       cgeOo: // global
           HpAlloc = 104;
           goto cgeOl;
       cgeOl: // global
           R1 = _sge1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1h::P64;
           _sge0T::P64 = P64[_sge1h::P64 + 16];
           _sge0U::P64 = P64[_sge1h::P64 + 24];
           _sge0V::P64 = P64[_sge1h::P64 + 32];
           _sge0W::P64 = P64[_sge1h::P64 + 40];
           _sge0Y::P64 = P64[_sge1h::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sge0V::P64;
           P64[Hp - 72] = _sge0T::P64;
           P64[Hp - 64] = _sge0W::P64;
           I64[Hp - 56] = sat_sge1g_info;
           P64[Hp - 48] = _sge0U::P64;
           P64[Hp - 40] = _sge0W::P64;
           P64[Hp - 32] = _sge0Y::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sge10_info;
           P64[Hp] = _sge0Y::P64;
           R2 = _sge0Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgeOp,
                       label: Data.Functor.Compose.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOp: // global
           _sge0W::P64 = R5;
           _sge0V::P64 = R4;
           _sge0U::P64 = R3;
           _sge0T::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgeOq; else goto cgeOr;
       cgeOr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeOt; else goto cgeOs;
       cgeOt: // global
           HpAlloc = 24;
           goto cgeOq;
       cgeOq: // global
           R5 = _sge0W::P64;
           R4 = _sge0V::P64;
           R3 = _sge0U::P64;
           R2 = _sge0T::P64;
           R1 = Data.Functor.Compose.$w$cgmapMo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeOs: // global
           I64[Hp - 16] = lvl8_sge0X_info;
           P64[Hp] = _sge0U::P64;
           I64[Sp - 48] = block_cgeMw_info;
           R2 = _sge0U::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sge0T::P64;
           P64[Sp - 24] = _sge0U::P64;
           P64[Sp - 16] = _sge0V::P64;
           P64[Sp - 8] = _sge0W::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeMw() //  [R1]
         { info_tbl: [(cgeMw,
                       label: block_cgeMw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeMw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgeOw; else goto cgeOv;
       cgeOw: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeOv: // global
           I64[Hp - 72] = sat_sge1n_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sge1h_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.642676444 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMo_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMo_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMo_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOy: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_entry() //  []
         { info_tbl: [(cgeOC,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOC: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.643815592 UTC

[section ""data" . lvl4_rgdQh_closure" {
     lvl4_rgdQh_closure:
         const lvl4_rgdQh_info;
         const 0;
 },
 lvl4_rgdQh_entry() //  []
         { info_tbl: [(cgeOJ,
                       label: lvl4_rgdQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOJ: // global
           R1 = Data.Functor.Compose.$cCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.644642143 UTC

[section ""data" . lvl5_rgdQi_closure" {
     lvl5_rgdQi_closure:
         const lvl5_rgdQi_info;
         const 0;
 },
 lvl5_rgdQi_entry() //  []
         { info_tbl: [(cgeOQ,
                       label: lvl5_rgdQi_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOQ: // global
           R1 = Data.Functor.Compose.$tCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.645487916 UTC

[section ""data" . lvl6_rgdQj_closure" {
     lvl6_rgdQj_closure:
         const lvl6_rgdQj_info;
 },
 lvl6_rgdQj_entry() //  []
         { info_tbl: [(cgeOX,
                       label: lvl6_rgdQj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeOX: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.648006213 UTC

[section ""data" . lvl7_rgdQk_closure" {
     lvl7_rgdQk_closure:
         const lvl7_rgdQk_info;
 },
 lvl7_rgdQk_entry() //  []
         { info_tbl: [(cgeP4,
                       label: lvl7_rgdQk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeP4: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.651389812 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_closure" {
     Data.Functor.Compose.$fDataCompose_closure:
         const Data.Functor.Compose.$fDataCompose_info;
         const 0;
 },
 sat_sge2v_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgePg,
                       label: sat_sge2v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgePg: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2r_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgePo,
                       label: sat_sge2r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgePo: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2n_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgePw,
                       label: sat_sge2n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgePw: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2j_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgePH,
                       label: sat_sge2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgePH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgePI; else goto cgePJ;
       cgePI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgePJ: // global
           I64[Sp - 32] = block_cgePE_info;
           _sge1I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _sge1I::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugePR; else goto cgePF;
       ugePR: // global
           call _cgePE(R1) args: 0, res: 0, upd: 0;
       cgePF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgePE() //  [R1]
         { info_tbl: [(cgePE,
                       label: block_cgePE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgePE: // global
           if (I64[R1 + 7] == 0) goto cgePQ; else goto cgePP;
       cgePQ: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgePP: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2c_entry() //  [R1, R2, R3]
         { info_tbl: [(cgePZ,
                       label: sat_sge2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgePZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgeQ3; else goto cgeQ2;
       cgeQ3: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeQ2: // global
           _sge1I::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = _sge1I::P64;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge28_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgeQa,
                       label: sat_sge28_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeQa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgeQe; else goto cgeQd;
       cgeQe: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeQd: // global
           _sge1I::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sge1I::P64;
           P64[Hp] = R5;
           R3 = R3;
           _sge23::P64 = R2;
           R2 = Hp - 32;
           R1 = _sge23::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge22_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgeQl,
                       label: sat_sge22_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeQl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgeQp; else goto cgeQo;
       cgeQp: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeQo: // global
           _sge1I::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sge1I::P64;
           P64[Hp] = R5;
           _sge1Y::P64 = R3;
           R3 = Hp - 32;
           _sge1X::P64 = R2;
           R2 = _sge1Y::P64;
           R1 = _sge1X::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1W_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeQv,
                       label: sat_sge1W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeQv: // global
           R3 = R3;
           _sge1U::P64 = R2;
           R2 = P64[R1 + 6];
           R1 = _sge1U::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1S_entry() //  [R1]
         { info_tbl: [(cgeQH,
                       label: sat_sge1S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeQH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeQI; else goto cgeQJ;
       cgeQI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeQJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgeQK,
                       label: sat_sge1T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeQK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeQO; else goto cgeQN;
       cgeQO: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeQN: // global
           _sge1I::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sge1S_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sge1P::P64 = R2;
           R2 = _sge1I::P64;
           R1 = _sge1P::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1N_entry() //  [R1]
         { info_tbl: [(cgeQY,
                       label: sat_sge1N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeQY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeQZ; else goto cgeR0;
       cgeQZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeR0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1O_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgeR1,
                       label: sat_sge1O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeR1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeR5; else goto cgeR4;
       cgeR5: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeR4: // global
           _sge1I::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sge1N_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           _sge1K::P64 = R2;
           R2 = _sge1I::P64;
           R1 = _sge1K::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1J_entry() //  [R1]
         { info_tbl: [(cgeRa,
                       label: sat_sge1J_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeRb; else goto cgeRc;
       cgeRb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeRc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fDataCompose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgeRe,
                       label: Data.Functor.Compose.$fDataCompose_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRe: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto cgeRi; else goto cgeRh;
       cgeRi: // global
           HpAlloc = 344;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fDataCompose_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgeRh: // global
           I64[Hp - 336] = sat_sge2v_info;
           _sge1I::P64 = P64[Sp];
           P64[Hp - 328] = _sge1I::P64;
           I64[Hp - 320] = sat_sge2r_info;
           P64[Hp - 312] = _sge1I::P64;
           I64[Hp - 304] = sat_sge2n_info;
           P64[Hp - 296] = _sge1I::P64;
           I64[Hp - 288] = sat_sge2j_info;
           P64[Hp - 280] = _sge1I::P64;
           I64[Hp - 272] = sat_sge2c_info;
           P64[Hp - 264] = _sge1I::P64;
           I64[Hp - 256] = sat_sge28_info;
           P64[Hp - 248] = _sge1I::P64;
           I64[Hp - 240] = sat_sge22_info;
           P64[Hp - 232] = _sge1I::P64;
           I64[Hp - 224] = sat_sge1W_info;
           P64[Hp - 216] = _sge1I::P64;
           I64[Hp - 208] = sat_sge1T_info;
           P64[Hp - 200] = _sge1I::P64;
           I64[Hp - 192] = sat_sge1O_info;
           P64[Hp - 184] = _sge1I::P64;
           I64[Hp - 176] = sat_sge1J_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 189;
           P64[Hp - 96] = Hp - 205;
           P64[Hp - 88] = lvl4_rgdQh_closure+1;
           P64[Hp - 80] = lvl5_rgdQi_closure+1;
           P64[Hp - 72] = lvl6_rgdQj_closure+2;
           P64[Hp - 64] = lvl7_rgdQk_closure+2;
           P64[Hp - 56] = Hp - 222;
           P64[Hp - 48] = Hp - 236;
           P64[Hp - 40] = Hp - 252;
           P64[Hp - 32] = Hp - 270;
           P64[Hp - 24] = Hp - 285;
           P64[Hp - 16] = Hp - 301;
           P64[Hp - 8] = Hp - 317;
           P64[Hp] = Hp - 333;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.656343404 UTC

[section ""relreadonly" . Sge5q_srt" {
     Sge5q_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Compose.$fRead1Compose2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
         const Data.Functor.Compose.$fRead1Compose_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$w$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
         const Data.Functor.Compose.$fShow1Compose_closure;
         const Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadList_closure;
         const Data.Functor.Compose.$fReadCompose_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
         const Data.Functor.Compose.$fShowCompose_$cshow_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowList_closure;
         const Data.Functor.Compose.$fShowCompose_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Compose.$fFoldableCompose_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Compose.$fFoldableCompose2_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Compose.$fFoldableCompose3_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Compose.$fFoldableCompose_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Compose.$fFoldableCompose7_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
         const Data.Functor.Compose.$fFoldableCompose6_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$clength_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
         const Data.Functor.Compose.$fFoldableCompose8_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
         const Data.Functor.Compose.$fFoldableCompose_closure;
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
         const Data.Functor.Compose.$fTraversableCompose_closure;
         const GHC.List.badHead_closure;
         const go61_rgdPX_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Compose.$fDataCompose5_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Compose.$w$cp1Data_closure;
         const Data.Functor.Compose.$cCompose_closure;
         const Data.Functor.Compose.$tCompose_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Compose.$fDataCompose_closure;
         const lvl4_rgdQh_closure;
         const lvl5_rgdQi_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.65733128 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:06.658209441 UTC

[section ""data" . $fEq1Compose1_rgdPP_closure" {
     $fEq1Compose1_rgdPP_closure:
         const $fEq1Compose1_rgdPP_info;
 },
 $fEq1Compose1_rgdPP_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgeRo,
                       label: $fEq1Compose1_rgdPP_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeRs; else goto cgeRr;
       cgeRs: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $fEq1Compose1_rgdPP_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeRr: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgdQm::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgdQm::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.659241637 UTC

[section ""data" . Data.Functor.Compose.$fEq1Compose_closure" {
     Data.Functor.Compose.$fEq1Compose_closure:
         const Data.Functor.Compose.$fEq1Compose_info;
 },
 Data.Functor.Compose.$fEq1Compose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgeRx,
                       label: Data.Functor.Compose.$fEq1Compose_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $fEq1Compose1_rgdPP_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.660361672 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure" {
     Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure:
         const Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info;
 },
 sat_sgdQx_entry() //  [R1]
         { info_tbl: [(cgeRI,
                       label: sat_sgdQx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeRJ; else goto cgeRK;
       cgeRJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeRK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgeRL,
                       label: Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRL: // global
           _sgdQw::P64 = R6;
           _sgdQv::P64 = R5;
           _sgdQu::P64 = R4;
           _sgdQt::P64 = R3;
           _sgdQs::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeRM; else goto cgeRN;
       cgeRN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeRP; else goto cgeRO;
       cgeRP: // global
           HpAlloc = 32;
           goto cgeRM;
       cgeRM: // global
           R6 = _sgdQw::P64;
           R5 = _sgdQv::P64;
           R4 = _sgdQu::P64;
           R3 = _sgdQt::P64;
           R2 = _sgdQs::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeRO: // global
           I64[Hp - 24] = sat_sgdQx_info;
           P64[Hp - 8] = _sgdQt::P64;
           P64[Hp] = _sgdQu::P64;
           R2 = _sgdQs::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdQv::P64;
           P64[Sp - 8] = _sgdQw::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.661964235 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose1_closure" {
     Data.Functor.Compose.$fOrd1Compose1_closure:
         const Data.Functor.Compose.$fOrd1Compose1_info;
 },
 sat_sgdQD_entry() //  [R1]
         { info_tbl: [(cgeRY,
                       label: sat_sgdQD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeRY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgeRZ; else goto cgeS0;
       cgeRZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeS0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgeS1,
                       label: Data.Functor.Compose.$fOrd1Compose1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeS1: // global
           _sgdQC::P64 = R6;
           _sgdQB::P64 = R5;
           _sgdQA::P64 = R4;
           _sgdQz::P64 = R3;
           _sgdQy::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeS2; else goto cgeS3;
       cgeS3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeS5; else goto cgeS4;
       cgeS5: // global
           HpAlloc = 32;
           goto cgeS2;
       cgeS2: // global
           R6 = _sgdQC::P64;
           R5 = _sgdQB::P64;
           R4 = _sgdQA::P64;
           R3 = _sgdQz::P64;
           R2 = _sgdQy::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeS4: // global
           I64[Hp - 24] = sat_sgdQD_info;
           P64[Hp - 8] = _sgdQz::P64;
           P64[Hp] = _sgdQA::P64;
           R2 = _sgdQy::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdQB::P64;
           P64[Sp - 8] = _sgdQC::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.663607365 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_closure" {
     Data.Functor.Compose.$fOrd1Compose_closure:
         const Data.Functor.Compose.$fOrd1Compose_info;
 },
 sat_sgdQH_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgeSf,
                       label: sat_sgdQH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeSf: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdQG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgeSn,
                       label: sat_sgdQG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeSn: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_entry() //  [R2, R3]
         { info_tbl: [(cgeSr,
                       label: Data.Functor.Compose.$fOrd1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeSr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgeSv; else goto cgeSu;
       cgeSv: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrd1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeSu: // global
           I64[Hp - 64] = sat_sgdQH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdQG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.664846364 UTC

[section ""cstring" . Data.Functor.Compose.$fDataCompose7_bytes" {
     Data.Functor.Compose.$fDataCompose7_bytes:
         I8[] [67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.665588071 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose6_closure" {
     Data.Functor.Compose.$fDataCompose6_closure:
         const Data.Functor.Compose.$fDataCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose6_entry() //  [R1]
         { info_tbl: [(cgeSC,
                       label: Data.Functor.Compose.$fDataCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeSC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeSD; else goto cgeSE;
       cgeSD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeSE: // global
           (_cgeSz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgeSz::I64 == 0) goto cgeSB; else goto cgeSA;
       cgeSB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgeSA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgeSz::I64;
           R2 = Data.Functor.Compose.$fDataCompose7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.666439372 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose2_closure" {
     Data.Functor.Compose.$fRead1Compose2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.666951884 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose1_closure" {
     Data.Functor.Compose.$fRead1Compose1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.669120595 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info;
         const 0;
 },
 sat_sgdQO_entry() //  [R1]
         { info_tbl: [(cgeSR,
                       label: sat_sgdQO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeSR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeSS; else goto cgeST;
       cgeSS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeST: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdQN_entry() //  [R1]
         { info_tbl: [(cgeSY,
                       label: sat_sgdQN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeSY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeSZ; else goto cgeT0;
       cgeSZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeT0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader_sgdQM_entry() //  [R1]
         { info_tbl: [(cgeT1,
                       label: reader_sgdQM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeT1: // global
           _sgdQM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgeT2; else goto cgeT3;
       cgeT3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgeT5; else goto cgeT4;
       cgeT5: // global
           HpAlloc = 80;
           goto cgeT2;
       cgeT2: // global
           R1 = _sgdQM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeT4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdQM::P64;
           _sgdQI::P64 = P64[_sgdQM::P64 + 16];
           _sgdQJ::P64 = P64[_sgdQM::P64 + 24];
           _sgdQK::P64 = P64[_sgdQM::P64 + 32];
           _sgdQL::P64 = P64[_sgdQM::P64 + 40];
           I64[Hp - 72] = sat_sgdQO_info;
           P64[Hp - 56] = _sgdQJ::P64;
           P64[Hp - 48] = _sgdQK::P64;
           P64[Hp - 40] = _sgdQL::P64;
           I64[Hp - 32] = sat_sgdQN_info;
           P64[Hp - 16] = _sgdQJ::P64;
           P64[Hp - 8] = _sgdQK::P64;
           P64[Hp] = _sgdQL::P64;
           R2 = _sgdQI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdQV_entry() //  [R1, R2]
         { info_tbl: [(cgeTp,
                       label: sat_sgdQV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeTp: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdQW_entry() //  [R1, R2]
         { info_tbl: [(cgeTs,
                       label: sat_sgdQW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeTs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgeTw; else goto cgeTv;
       cgeTw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeTv: // global
           _sgdQM::P64 = P64[R1 + 7];
           _sgdQR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sgdQV_info;
           P64[Hp] = _sgdQR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Compose.$fRead1Compose1_closure+1;
           R1 = _sgdQM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sgdQP_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeTA,
                       label: $wlvl_sgdQP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeTA: // global
           _sgdQR::P64 = R3;
           _sgdQQ::I64 = R2;
           _sgdQP::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgeTB; else goto cgeTC;
       cgeTC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeTE; else goto cgeTD;
       cgeTE: // global
           HpAlloc = 24;
           goto cgeTB;
       cgeTB: // global
           R3 = _sgdQR::P64;
           R2 = _sgdQQ::I64;
           R1 = _sgdQP::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeTD: // global
           if (%MO_S_Gt_W64(_sgdQQ::I64, 10)) goto cgeTy; else goto cgeTz;
       cgeTy: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgeTz: // global
           _sgdQM::P64 = P64[_sgdQP::P64 + 6];
           I64[Hp - 16] = sat_sgdQW_info;
           P64[Hp - 8] = _sgdQM::P64;
           P64[Hp] = _sgdQR::P64;
           I64[Sp - 8] = block_cgeTF_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Compose.$fRead1Compose2_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeTF() //  [R1]
         { info_tbl: [(cgeTF,
                       label: block_cgeTF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeTF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgeTK; else goto cgeTJ;
       cgeTK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeTJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sgdQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeTT,
                       label: lvl8_sgdQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeTT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgeTU; else goto cgeTV;
       cgeTU: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeTV: // global
           I64[Sp - 24] = block_cgeTQ_info;
           _sgdQP::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sgdQP::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugeTZ; else goto cgeTR;
       ugeTZ: // global
           call _cgeTQ(R1) args: 0, res: 0, upd: 0;
       cgeTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeTQ() //  [R1]
         { info_tbl: [(cgeTQ,
                       label: block_cgeTQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeTQ: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sgdQP_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdR6_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeU5,
                       label: sat_sgdR6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeU5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgeU8,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeU8: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgeUc; else goto cgeUb;
       cgeUc: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeUb: // global
           I64[Hp - 88] = reader_sgdQM_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = $wlvl_sgdQP_info;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sgdQZ_info;
           P64[Hp - 16] = Hp - 38;
           I64[Hp - 8] = sat_sgdR6_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.673924875 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info;
         const 0;
 },
 sat_sgdRh_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeUt,
                       label: sat_sgdRh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeUt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgeUu; else goto cgeUv;
       cgeUu: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeUv: // global
           I64[Sp - 8] = block_cgeUq_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgeUq() //  [R1]
         { info_tbl: [(cgeUq,
                       label: block_cgeUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeUq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgeUy; else goto cgeUx;
       cgeUy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgeUx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRc_entry() //  [R1, R2]
         { info_tbl: [(cgeUE,
                       label: sat_sgdRc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeUE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sgdRb_entry() //  [R1]
         { info_tbl: [(cgeUH,
                       label: ds_sgdRb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeUH: // global
           _sgdRb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeUI; else goto cgeUJ;
       cgeUJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeUL; else goto cgeUK;
       cgeUL: // global
           HpAlloc = 32;
           goto cgeUI;
       cgeUI: // global
           R1 = _sgdRb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeUK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdRb::P64;
           _sgdR7::P64 = P64[_sgdRb::P64 + 16];
           _sgdR8::P64 = P64[_sgdRb::P64 + 24];
           _sgdR9::P64 = P64[_sgdRb::P64 + 32];
           _sgdRa::P64 = P64[_sgdRb::P64 + 40];
           I64[Hp - 24] = sat_sgdRh_info;
           P64[Hp - 16] = _sgdRa::P64;
           I64[Hp - 8] = sat_sgdRc_info;
           P64[Hp] = _sgdR9::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sgdR8::P64;
           R2 = _sgdR7::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRj_entry() //  [R1]
         { info_tbl: [(cgeUV,
                       label: sat_sgdRj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeUV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeUW; else goto cgeUX;
       cgeUW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeUX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRk_entry() //  [R1, R2]
         { info_tbl: [(cgeUY,
                       label: sat_sgdRk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeUY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeV2; else goto cgeV1;
       cgeV2: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeV1: // global
           _sgdRb::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgdRj_info;
           P64[Hp - 8] = _sgdRb::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cgeV3,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeV3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgeV7; else goto cgeV6;
       cgeV7: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeV6: // global
           I64[Hp - 56] = ds_sgdRb_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sgdRk_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.676639552 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info;
         const 0;
 },
 sat_sgdRp_entry() //  [R1]
         { info_tbl: [(cgeVg,
                       label: sat_sgdRp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVg: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgeVj,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgeVn; else goto cgeVm;
       cgeVn: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeVm: // global
           I64[Hp - 40] = sat_sgdRp_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.678677791 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_closure" {
     Data.Functor.Compose.$fRead1Compose_closure:
         const Data.Functor.Compose.$fRead1Compose_info;
         const 0;
 },
 sat_sgdRv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeVx,
                       label: sat_sgdRv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVx: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRu_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeVF,
                       label: sat_sgdRu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVF: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRt_entry() //  [R1]
         { info_tbl: [(cgeVM,
                       label: sat_sgdRt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeVN; else goto cgeVO;
       cgeVN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeVO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRs_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeVU,
                       label: sat_sgdRs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVU: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_entry() //  [R2, R3]
         { info_tbl: [(cgeVY,
                       label: Data.Functor.Compose.$fRead1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeVY: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgeW2; else goto cgeW1;
       cgeW2: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeW1: // global
           I64[Hp - 136] = sat_sgdRv_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgdRu_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sgdRt_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sgdRs_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_info;
         const 0;
 },
 sat_sgdRy_entry() //  [R1]
         { info_tbl: [(cgeWb,
                       label: sat_sgdRy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeWc; else goto cgeWd;
       cgeWc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgeWe,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeWi; else goto cgeWh;
       cgeWi: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeWh: // global
           I64[Hp - 24] = sat_sgdRy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.682105163 UTC

[section ""data" . Data.Functor.Compose.$w$cliftShowsPrec_closure" {
     Data.Functor.Compose.$w$cliftShowsPrec_closure:
         const Data.Functor.Compose.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWk: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgdRG_entry() //  [R1]
         { info_tbl: [(cgeWw,
                       label: sat_sgdRG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeWx; else goto cgeWy;
       cgeWx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeWy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdRF_entry() //  [R1]
         { info_tbl: [(cgeWD,
                       label: sat_sgdRF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeWE; else goto cgeWF;
       cgeWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdRH_entry() //  [R1]
         { info_tbl: [(cgeWG,
                       label: sat_sgdRH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWG: // global
           _sgdRH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgeWH; else goto cgeWI;
       cgeWI: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgeWK; else goto cgeWJ;
       cgeWK: // global
           HpAlloc = 80;
           goto cgeWH;
       cgeWH: // global
           R1 = _sgdRH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeWJ: // global
           _sgdRz::P64 = P64[_sgdRH::P64 + 16];
           _sgdRA::P64 = P64[_sgdRH::P64 + 24];
           _sgdRB::P64 = P64[_sgdRH::P64 + 32];
           _sgdRC::P64 = P64[_sgdRH::P64 + 40];
           I64[Hp - 72] = sat_sgdRG_info;
           P64[Hp - 56] = _sgdRA::P64;
           P64[Hp - 48] = _sgdRB::P64;
           P64[Hp - 40] = _sgdRC::P64;
           I64[Hp - 32] = sat_sgdRF_info;
           P64[Hp - 16] = _sgdRA::P64;
           P64[Hp - 8] = _sgdRB::P64;
           P64[Hp] = _sgdRC::P64;
           R2 = _sgdRz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgeWL,
                       label: Data.Functor.Compose.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgeWP; else goto cgeWO;
       cgeWP: // global
           HpAlloc = 48;
           R1 = Data.Functor.Compose.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cgeWO: // global
           I64[Hp - 40] = sat_sgdRH_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R5 = P64[Sp];
           R4 = R6;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = Hp - 40;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.684506936 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cgeWX,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeWY; else goto cgeWZ;
       cgeWY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgeWZ: // global
           I64[Sp - 40] = block_cgeWU_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugeX3; else goto cgeWV;
       ugeX3: // global
           call _cgeWU(R1) args: 0, res: 0, upd: 0;
       cgeWV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeWU() //  [R1]
         { info_tbl: [(cgeWU,
                       label: block_cgeWU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeWU: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.68570748 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose3_closure" {
     Data.Functor.Compose.$fDataCompose3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.686650347 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_info;
         const 0;
 },
 sat_sgdRX_entry() //  [R1, R2]
         { info_tbl: [(cgeXd,
                       label: sat_sgdRX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeXd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgeXe; else goto cgeXf;
       cgeXe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgeXf: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgdRW::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgdRW::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cgeXg,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeXg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgeXk; else goto cgeXj;
       cgeXk: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgeXj: // global
           I64[Hp - 32] = sat_sgdRX_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.688382363 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_closure" {
     Data.Functor.Compose.$fShow1Compose_closure:
         const Data.Functor.Compose.$fShow1Compose_info;
         const 0;
 },
 sat_sgdS1_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgeXu,
                       label: sat_sgdS1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeXu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgeXv; else goto cgeXw;
       cgeXv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeXw: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgdS0_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgeXC,
                       label: sat_sgdS0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeXC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgeXD; else goto cgeXE;
       cgeXD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeXE: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_entry() //  [R2, R3]
         { info_tbl: [(cgeXG,
                       label: Data.Functor.Compose.$fShow1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeXG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgeXK; else goto cgeXJ;
       cgeXK: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeXJ: // global
           I64[Hp - 64] = sat_sgdS1_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdS0_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.690479957 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c==_closure" {
     Data.Functor.Compose.$fEqCompose_$c==_closure:
         const Data.Functor.Compose.$fEqCompose_$c==_info;
 },
 sat_sgdS7_entry() //  [R1]
         { info_tbl: [(cgeXX,
                       label: sat_sgdS7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeXX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeXY; else goto cgeXZ;
       cgeXY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeXZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdS8_entry() //  [R1]
         { info_tbl: [(cgeY0,
                       label: sat_sgdS8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeY0: // global
           _sgdS8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeY1; else goto cgeY2;
       cgeY2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeY4; else goto cgeY3;
       cgeY4: // global
           HpAlloc = 24;
           goto cgeY1;
       cgeY1: // global
           R1 = _sgdS8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeY3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdS8::P64;
           _sgdS3::P64 = P64[_sgdS8::P64 + 16];
           _sgdS4::P64 = P64[_sgdS8::P64 + 24];
           I64[Hp - 16] = sat_sgdS7_info;
           P64[Hp] = _sgdS4::P64;
           R2 = Hp - 16;
           R1 = _sgdS3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgeY5,
                       label: Data.Functor.Compose.$fEqCompose_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeY5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeY9; else goto cgeY8;
       cgeY9: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeY8: // global
           I64[Hp - 24] = sat_sgdS8_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgdS2::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgdS2::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.692522478 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c/=_closure" {
     Data.Functor.Compose.$fEqCompose_$c/=_closure:
         const Data.Functor.Compose.$fEqCompose_$c/=_info;
 },
 sat_sgdSe_entry() //  [R1]
         { info_tbl: [(cgeYm,
                       label: sat_sgdSe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeYn; else goto cgeYo;
       cgeYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSf_entry() //  [R1]
         { info_tbl: [(cgeYp,
                       label: sat_sgdSf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeYp: // global
           _sgdSf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgeYq; else goto cgeYr;
       cgeYr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeYt; else goto cgeYs;
       cgeYt: // global
           HpAlloc = 24;
           goto cgeYq;
       cgeYq: // global
           R1 = _sgdSf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeYs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSf::P64;
           _sgdSa::P64 = P64[_sgdSf::P64 + 16];
           _sgdSb::P64 = P64[_sgdSf::P64 + 24];
           I64[Hp - 16] = sat_sgdSe_info;
           P64[Hp] = _sgdSb::P64;
           R2 = Hp - 16;
           R1 = _sgdSa::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgeYA,
                       label: Data.Functor.Compose.$fEqCompose_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeYA: // global
           _sgdSd::P64 = R6;
           _sgdSc::P64 = R5;
           _sgdSb::P64 = R4;
           _sgdSa::P64 = R3;
           _sgdS9::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cgeYB; else goto cgeYC;
       cgeYC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeYE; else goto cgeYD;
       cgeYE: // global
           HpAlloc = 32;
           goto cgeYB;
       cgeYB: // global
           R6 = _sgdSd::P64;
           R5 = _sgdSc::P64;
           R4 = _sgdSb::P64;
           R3 = _sgdSa::P64;
           R2 = _sgdS9::P64;
           R1 = Data.Functor.Compose.$fEqCompose_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeYD: // global
           I64[Hp - 24] = sat_sgdSf_info;
           P64[Hp - 8] = _sgdSa::P64;
           P64[Hp] = _sgdSb::P64;
           I64[Sp - 8] = block_cgeYu_info;
           R4 = _sgdSd::P64;
           R3 = _sgdSc::P64;
           R2 = Hp - 24;
           R1 = _sgdS9::P64;
           Sp = Sp - 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgeYu() //  [R1]
         { info_tbl: [(cgeYu,
                       label: block_cgeYu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeYu: // global
           if (R1 & 7 == 1) goto cgeYx; else goto cgeYy;
       cgeYx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgeYy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.69477217 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_closure" {
     Data.Functor.Compose.$fEqCompose_closure:
         const Data.Functor.Compose.$fEqCompose_info;
 },
 sat_sgdSl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeYU,
                       label: sat_sgdSl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeYU: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdSk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgeZ2,
                       label: sat_sgdSk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZ2: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fEqCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgeZ6,
                       label: Data.Functor.Compose.$fEqCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZ6: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgeZa; else goto cgeZ9;
       cgeZa: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeZ9: // global
           I64[Hp - 80] = sat_sgdSl_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgdSk_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.696580888 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$ccompare_closure" {
     Data.Functor.Compose.$fOrdCompose_$ccompare_closure:
         const Data.Functor.Compose.$fOrdCompose_$ccompare_info;
 },
 sat_sgdSr_entry() //  [R1]
         { info_tbl: [(cgeZn,
                       label: sat_sgdSr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeZo; else goto cgeZp;
       cgeZo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeZp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSs_entry() //  [R1]
         { info_tbl: [(cgeZq,
                       label: sat_sgdSs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZq: // global
           _sgdSs::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeZr; else goto cgeZs;
       cgeZs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgeZu; else goto cgeZt;
       cgeZu: // global
           HpAlloc = 24;
           goto cgeZr;
       cgeZr: // global
           R1 = _sgdSs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeZt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSs::P64;
           _sgdSn::P64 = P64[_sgdSs::P64 + 16];
           _sgdSo::P64 = P64[_sgdSs::P64 + 24];
           I64[Hp - 16] = sat_sgdSr_info;
           P64[Hp] = _sgdSo::P64;
           R2 = _sgdSn::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgeZv,
                       label: Data.Functor.Compose.$fOrdCompose_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZv: // global
           _sgdSq::P64 = R6;
           _sgdSp::P64 = R5;
           _sgdSo::P64 = R4;
           _sgdSn::P64 = R3;
           _sgdSm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgeZw; else goto cgeZx;
       cgeZx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgeZz; else goto cgeZy;
       cgeZz: // global
           HpAlloc = 32;
           goto cgeZw;
       cgeZw: // global
           R6 = _sgdSq::P64;
           R5 = _sgdSp::P64;
           R4 = _sgdSo::P64;
           R3 = _sgdSn::P64;
           R2 = _sgdSm::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgeZy: // global
           I64[Hp - 24] = sat_sgdSs_info;
           P64[Hp - 8] = _sgdSn::P64;
           P64[Hp] = _sgdSo::P64;
           R2 = _sgdSm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdSp::P64;
           P64[Sp - 8] = _sgdSq::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.69887102 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure" {
     Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure:
         const Data.Functor.Compose.$fOrdCompose_$cp1Ord_info;
 },
 sat_sgdSy_entry() //  [R1]
         { info_tbl: [(cgeZI,
                       label: sat_sgdSy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeZJ; else goto cgeZK;
       cgeZJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeZK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSx_entry() //  [R1]
         { info_tbl: [(cgeZP,
                       label: sat_sgdSx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeZQ; else goto cgeZR;
       cgeZQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeZR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSw_entry() //  [R1]
         { info_tbl: [(cgeZW,
                       label: sat_sgdSw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgeZX; else goto cgeZY;
       cgeZX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgeZY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cgeZZ,
                       label: Data.Functor.Compose.$fOrdCompose_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgeZZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgf03; else goto cgf02;
       cgf03: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf02: // global
           I64[Hp - 64] = sat_sgdSy_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgdSx_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdSw_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fEqCompose_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.700976004 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<_info;
 },
 sat_sgdSE_entry() //  [R1]
         { info_tbl: [(cgf0g,
                       label: sat_sgdSE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf0h; else goto cgf0i;
       cgf0h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf0i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSF_entry() //  [R1]
         { info_tbl: [(cgf0j,
                       label: sat_sgdSF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0j: // global
           _sgdSF::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgf0k; else goto cgf0l;
       cgf0l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgf0n; else goto cgf0m;
       cgf0n: // global
           HpAlloc = 24;
           goto cgf0k;
       cgf0k: // global
           R1 = _sgdSF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf0m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSF::P64;
           _sgdSA::P64 = P64[_sgdSF::P64 + 16];
           _sgdSB::P64 = P64[_sgdSF::P64 + 24];
           I64[Hp - 16] = sat_sgdSE_info;
           P64[Hp] = _sgdSB::P64;
           R2 = _sgdSA::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgf0u,
                       label: Data.Functor.Compose.$fOrdCompose_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0u: // global
           _sgdSD::P64 = R6;
           _sgdSC::P64 = R5;
           _sgdSB::P64 = R4;
           _sgdSA::P64 = R3;
           _sgdSz::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgf0v; else goto cgf0w;
       cgf0w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf0y; else goto cgf0x;
       cgf0y: // global
           HpAlloc = 32;
           goto cgf0v;
       cgf0v: // global
           R6 = _sgdSD::P64;
           R5 = _sgdSC::P64;
           R4 = _sgdSB::P64;
           R3 = _sgdSA::P64;
           R2 = _sgdSz::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf0x: // global
           I64[Hp - 24] = sat_sgdSF_info;
           P64[Hp - 8] = _sgdSA::P64;
           P64[Hp] = _sgdSB::P64;
           I64[Sp - 8] = block_cgf0o_info;
           R2 = _sgdSz::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSC::P64;
           P64[Sp - 16] = _sgdSD::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgf0o() //  [R1]
         { info_tbl: [(cgf0o,
                       label: block_cgf0o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0o: // global
           if (R1 & 7 == 1) goto cgf0s; else goto cgf0r;
       cgf0s: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgf0r: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.703356787 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>=_info;
 },
 sat_sgdSM_entry() //  [R1]
         { info_tbl: [(cgf0R,
                       label: sat_sgdSM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf0S; else goto cgf0T;
       cgf0S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf0T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSN_entry() //  [R1]
         { info_tbl: [(cgf0U,
                       label: sat_sgdSN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0U: // global
           _sgdSN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgf0V; else goto cgf0W;
       cgf0W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgf0Y; else goto cgf0X;
       cgf0Y: // global
           HpAlloc = 24;
           goto cgf0V;
       cgf0V: // global
           R1 = _sgdSN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf0X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSN::P64;
           _sgdSI::P64 = P64[_sgdSN::P64 + 16];
           _sgdSJ::P64 = P64[_sgdSN::P64 + 24];
           I64[Hp - 16] = sat_sgdSM_info;
           P64[Hp] = _sgdSJ::P64;
           R2 = _sgdSI::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgf15,
                       label: Data.Functor.Compose.$fOrdCompose_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf15: // global
           _sgdSL::P64 = R6;
           _sgdSK::P64 = R5;
           _sgdSJ::P64 = R4;
           _sgdSI::P64 = R3;
           _sgdSH::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgf16; else goto cgf17;
       cgf17: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf19; else goto cgf18;
       cgf19: // global
           HpAlloc = 32;
           goto cgf16;
       cgf16: // global
           R6 = _sgdSL::P64;
           R5 = _sgdSK::P64;
           R4 = _sgdSJ::P64;
           R3 = _sgdSI::P64;
           R2 = _sgdSH::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf18: // global
           I64[Hp - 24] = sat_sgdSN_info;
           P64[Hp - 8] = _sgdSI::P64;
           P64[Hp] = _sgdSJ::P64;
           I64[Sp - 8] = block_cgf0Z_info;
           R2 = _sgdSH::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSK::P64;
           P64[Sp - 16] = _sgdSL::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgf0Z() //  [R1]
         { info_tbl: [(cgf0Z,
                       label: block_cgf0Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf0Z: // global
           if (R1 & 7 == 1) goto cgf13; else goto cgf12;
       cgf13: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgf12: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.705721461 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>_info;
 },
 sat_sgdSU_entry() //  [R1]
         { info_tbl: [(cgf1s,
                       label: sat_sgdSU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf1s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf1t; else goto cgf1u;
       cgf1t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf1u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSV_entry() //  [R1]
         { info_tbl: [(cgf1v,
                       label: sat_sgdSV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf1v: // global
           _sgdSV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgf1w; else goto cgf1x;
       cgf1x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgf1z; else goto cgf1y;
       cgf1z: // global
           HpAlloc = 24;
           goto cgf1w;
       cgf1w: // global
           R1 = _sgdSV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf1y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSV::P64;
           _sgdSQ::P64 = P64[_sgdSV::P64 + 16];
           _sgdSR::P64 = P64[_sgdSV::P64 + 24];
           I64[Hp - 16] = sat_sgdSU_info;
           P64[Hp] = _sgdSR::P64;
           R2 = _sgdSQ::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgf1G,
                       label: Data.Functor.Compose.$fOrdCompose_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf1G: // global
           _sgdST::P64 = R6;
           _sgdSS::P64 = R5;
           _sgdSR::P64 = R4;
           _sgdSQ::P64 = R3;
           _sgdSP::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgf1H; else goto cgf1I;
       cgf1I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf1K; else goto cgf1J;
       cgf1K: // global
           HpAlloc = 32;
           goto cgf1H;
       cgf1H: // global
           R6 = _sgdST::P64;
           R5 = _sgdSS::P64;
           R4 = _sgdSR::P64;
           R3 = _sgdSQ::P64;
           R2 = _sgdSP::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf1J: // global
           I64[Hp - 24] = sat_sgdSV_info;
           P64[Hp - 8] = _sgdSQ::P64;
           P64[Hp] = _sgdSR::P64;
           I64[Sp - 8] = block_cgf1A_info;
           R2 = _sgdSP::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSS::P64;
           P64[Sp - 16] = _sgdST::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgf1A() //  [R1]
         { info_tbl: [(cgf1A,
                       label: block_cgf1A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf1A: // global
           if (R1 & 7 == 3) goto cgf1E; else goto cgf1D;
       cgf1E: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgf1D: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.708071085 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<=_info;
 },
 sat_sgdT2_entry() //  [R1]
         { info_tbl: [(cgf23,
                       label: sat_sgdT2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf23: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf24; else goto cgf25;
       cgf24: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf25: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdT3_entry() //  [R1]
         { info_tbl: [(cgf26,
                       label: sat_sgdT3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf26: // global
           _sgdT3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgf27; else goto cgf28;
       cgf28: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgf2a; else goto cgf29;
       cgf2a: // global
           HpAlloc = 24;
           goto cgf27;
       cgf27: // global
           R1 = _sgdT3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf29: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdT3::P64;
           _sgdSY::P64 = P64[_sgdT3::P64 + 16];
           _sgdSZ::P64 = P64[_sgdT3::P64 + 24];
           I64[Hp - 16] = sat_sgdT2_info;
           P64[Hp] = _sgdSZ::P64;
           R2 = _sgdSY::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgf2h,
                       label: Data.Functor.Compose.$fOrdCompose_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf2h: // global
           _sgdT1::P64 = R6;
           _sgdT0::P64 = R5;
           _sgdSZ::P64 = R4;
           _sgdSY::P64 = R3;
           _sgdSX::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgf2i; else goto cgf2j;
       cgf2j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf2l; else goto cgf2k;
       cgf2l: // global
           HpAlloc = 32;
           goto cgf2i;
       cgf2i: // global
           R6 = _sgdT1::P64;
           R5 = _sgdT0::P64;
           R4 = _sgdSZ::P64;
           R3 = _sgdSY::P64;
           R2 = _sgdSX::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf2k: // global
           I64[Hp - 24] = sat_sgdT3_info;
           P64[Hp - 8] = _sgdSY::P64;
           P64[Hp] = _sgdSZ::P64;
           I64[Sp - 8] = block_cgf2b_info;
           R2 = _sgdSX::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdT0::P64;
           P64[Sp - 16] = _sgdT1::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgf2b() //  [R1]
         { info_tbl: [(cgf2b,
                       label: block_cgf2b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf2b: // global
           if (R1 & 7 == 3) goto cgf2f; else goto cgf2e;
       cgf2f: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgf2e: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.710425647 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmax_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmax_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmax_info;
 },
 sat_sgdTa_entry() //  [R1]
         { info_tbl: [(cgf2E,
                       label: sat_sgdTa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf2E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf2F; else goto cgf2G;
       cgf2F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf2G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTb_entry() //  [R1]
         { info_tbl: [(cgf2H,
                       label: sat_sgdTb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf2H: // global
           _sgdTb::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgf2I; else goto cgf2J;
       cgf2J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgf2L; else goto cgf2K;
       cgf2L: // global
           HpAlloc = 24;
           goto cgf2I;
       cgf2I: // global
           R1 = _sgdTb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf2K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTb::P64;
           _sgdT6::P64 = P64[_sgdTb::P64 + 16];
           _sgdT7::P64 = P64[_sgdTb::P64 + 24];
           I64[Hp - 16] = sat_sgdTa_info;
           P64[Hp] = _sgdT7::P64;
           R2 = _sgdT6::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgf2S,
                       label: Data.Functor.Compose.$fOrdCompose_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf2S: // global
           _sgdT9::P64 = R6;
           _sgdT8::P64 = R5;
           _sgdT7::P64 = R4;
           _sgdT6::P64 = R3;
           _sgdT5::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgf2T; else goto cgf2U;
       cgf2U: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf2W; else goto cgf2V;
       cgf2W: // global
           HpAlloc = 32;
           goto cgf2T;
       cgf2T: // global
           R6 = _sgdT9::P64;
           R5 = _sgdT8::P64;
           R4 = _sgdT7::P64;
           R3 = _sgdT6::P64;
           R2 = _sgdT5::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf2V: // global
           I64[Hp - 24] = sat_sgdTb_info;
           P64[Hp - 8] = _sgdT6::P64;
           P64[Hp] = _sgdT7::P64;
           I64[Sp - 24] = block_cgf2M_info;
           R2 = _sgdT5::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgdT8::P64;
           P64[Sp - 32] = _sgdT9::P64;
           P64[Sp - 16] = _sgdT8::P64;
           P64[Sp - 8] = _sgdT9::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgf2M() //  [R1]
         { info_tbl: [(cgf2M,
                       label: block_cgf2M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf2M: // global
           if (R1 & 7 == 3) goto cgf2Q; else goto cgf2P;
       cgf2Q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgf2P: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.712853602 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmin_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmin_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmin_info;
 },
 sat_sgdTi_entry() //  [R1]
         { info_tbl: [(cgf3f,
                       label: sat_sgdTi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf3f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf3g; else goto cgf3h;
       cgf3g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf3h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTj_entry() //  [R1]
         { info_tbl: [(cgf3i,
                       label: sat_sgdTj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf3i: // global
           _sgdTj::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgf3j; else goto cgf3k;
       cgf3k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgf3m; else goto cgf3l;
       cgf3m: // global
           HpAlloc = 24;
           goto cgf3j;
       cgf3j: // global
           R1 = _sgdTj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf3l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTj::P64;
           _sgdTe::P64 = P64[_sgdTj::P64 + 16];
           _sgdTf::P64 = P64[_sgdTj::P64 + 24];
           I64[Hp - 16] = sat_sgdTi_info;
           P64[Hp] = _sgdTf::P64;
           R2 = _sgdTe::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgf3t,
                       label: Data.Functor.Compose.$fOrdCompose_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf3t: // global
           _sgdTh::P64 = R6;
           _sgdTg::P64 = R5;
           _sgdTf::P64 = R4;
           _sgdTe::P64 = R3;
           _sgdTd::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgf3u; else goto cgf3v;
       cgf3v: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf3x; else goto cgf3w;
       cgf3x: // global
           HpAlloc = 32;
           goto cgf3u;
       cgf3u: // global
           R6 = _sgdTh::P64;
           R5 = _sgdTg::P64;
           R4 = _sgdTf::P64;
           R3 = _sgdTe::P64;
           R2 = _sgdTd::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf3w: // global
           I64[Hp - 24] = sat_sgdTj_info;
           P64[Hp - 8] = _sgdTe::P64;
           P64[Hp] = _sgdTf::P64;
           I64[Sp - 24] = block_cgf3n_info;
           R2 = _sgdTd::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgdTg::P64;
           P64[Sp - 32] = _sgdTh::P64;
           P64[Sp - 16] = _sgdTg::P64;
           P64[Sp - 8] = _sgdTh::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgf3n() //  [R1]
         { info_tbl: [(cgf3n,
                       label: block_cgf3n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf3n: // global
           if (R1 & 7 == 3) goto cgf3r; else goto cgf3q;
       cgf3r: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgf3q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.715981939 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_closure" {
     Data.Functor.Compose.$fOrdCompose_closure:
         const Data.Functor.Compose.$fOrdCompose_info;
 },
 sat_sgdTv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf3N,
                       label: sat_sgdTv_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf3N: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTu_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf3V,
                       label: sat_sgdTu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf3V: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTt_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf43,
                       label: sat_sgdTt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf43: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTs_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf4b,
                       label: sat_sgdTs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4b: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTr_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf4j,
                       label: sat_sgdTr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4j: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTq_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf4r,
                       label: sat_sgdTq_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4r: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTp_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf4z,
                       label: sat_sgdTp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4z: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTo_entry() //  [R1]
         { info_tbl: [(cgf4G,
                       label: sat_sgdTo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf4H; else goto cgf4I;
       cgf4H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf4I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgf4K,
                       label: Data.Functor.Compose.$fOrdCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4K: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cgf4O; else goto cgf4N;
       cgf4O: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf4N: // global
           I64[Hp - 328] = sat_sgdTv_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sgdTu_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sgdTt_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sgdTs_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sgdTr_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sgdTq_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sgdTp_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sgdTo_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.719282472 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadPrec_info;
         const 0;
 },
 sat_sgdTA_entry() //  [R1]
         { info_tbl: [(cgf4X,
                       label: sat_sgdTA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf4Y; else goto cgf4Z;
       cgf4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf4Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTz_entry() //  [R1]
         { info_tbl: [(cgf54,
                       label: sat_sgdTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf55; else goto cgf56;
       cgf55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf56: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgf57,
                       label: Data.Functor.Compose.$fReadCompose_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf57: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgf5b; else goto cgf5a;
       cgf5b: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf5a: // global
           I64[Hp - 40] = sat_sgdTA_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgdTz_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.721545039 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadsPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadsPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_info;
         const 0;
 },
 sat_sgdTG_entry() //  [R1]
         { info_tbl: [(cgf5o,
                       label: sat_sgdTG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf5o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf5p; else goto cgf5q;
       cgf5p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf5q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTF_entry() //  [R1]
         { info_tbl: [(cgf5v,
                       label: sat_sgdTF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf5w; else goto cgf5x;
       cgf5w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf5x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sgdTE_entry() //  [R1]
         { info_tbl: [(cgf5y,
                       label: ds_sgdTE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf5y: // global
           _sgdTE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgf5z; else goto cgf5A;
       cgf5A: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgf5C; else goto cgf5B;
       cgf5C: // global
           HpAlloc = 48;
           goto cgf5z;
       cgf5z: // global
           R1 = _sgdTE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTE::P64;
           _sgdTB::P64 = P64[_sgdTE::P64 + 16];
           _sgdTC::P64 = P64[_sgdTE::P64 + 24];
           _sgdTD::P64 = P64[_sgdTE::P64 + 32];
           I64[Hp - 40] = sat_sgdTG_info;
           P64[Hp - 24] = _sgdTD::P64;
           I64[Hp - 16] = sat_sgdTF_info;
           P64[Hp] = _sgdTD::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgdTC::P64;
           R2 = _sgdTB::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTI_entry() //  [R1]
         { info_tbl: [(cgf5M,
                       label: sat_sgdTI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf5M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf5N; else goto cgf5O;
       cgf5N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf5O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTJ_entry() //  [R1, R2]
         { info_tbl: [(cgf5P,
                       label: sat_sgdTJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf5P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf5T; else goto cgf5S;
       cgf5T: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgf5S: // global
           _sgdTE::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgdTI_info;
           P64[Hp - 8] = _sgdTE::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgf5U,
                       label: Data.Functor.Compose.$fReadCompose_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf5U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgf5Y; else goto cgf5X;
       cgf5Y: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf5X: // global
           I64[Hp - 48] = ds_sgdTE_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sgdTJ_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.724387949 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadListPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadListPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_info;
         const 0;
 },
 sat_sgdTO_entry() //  [R1]
         { info_tbl: [(cgf6b,
                       label: sat_sgdTO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf6c; else goto cgf6d;
       cgf6c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf6d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTN_entry() //  [R1]
         { info_tbl: [(cgf6i,
                       label: sat_sgdTN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf6j; else goto cgf6k;
       cgf6j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTP_entry() //  [R1]
         { info_tbl: [(cgf6l,
                       label: sat_sgdTP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgf6p; else goto cgf6o;
       cgf6p: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf6o: // global
           _sgdTK::P64 = P64[R1 + 16];
           _sgdTL::P64 = P64[R1 + 24];
           _sgdTM::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sgdTO_info;
           P64[Hp - 24] = _sgdTM::P64;
           I64[Hp - 16] = sat_sgdTN_info;
           P64[Hp] = _sgdTM::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgdTL::P64;
           R2 = _sgdTK::P64;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgf6q,
                       label: Data.Functor.Compose.$fReadCompose_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgf6u; else goto cgf6t;
       cgf6u: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf6t: // global
           I64[Hp - 32] = sat_sgdTP_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.726733303 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadList_closure" {
     Data.Functor.Compose.$fReadCompose_$creadList_closure:
         const Data.Functor.Compose.$fReadCompose_$creadList_info;
         const 0;
 },
 sat_sgdTT_entry() //  [R1]
         { info_tbl: [(cgf6D,
                       label: sat_sgdTT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6D: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgf6E; else goto cgf6F;
       cgf6E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf6F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgf6G,
                       label: Data.Functor.Compose.$fReadCompose_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6G: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgf6K; else goto cgf6J;
       cgf6K: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf6J: // global
           I64[Hp - 32] = sat_sgdTT_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.728691562 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_closure" {
     Data.Functor.Compose.$fReadCompose_closure:
         const Data.Functor.Compose.$fReadCompose_info;
         const 0;
 },
 sat_sgdU0_entry() //  [R1]
         { info_tbl: [(cgf6T,
                       label: sat_sgdU0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf6T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf6U; else goto cgf6V;
       cgf6U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf6V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTZ_entry() //  [R1]
         { info_tbl: [(cgf70,
                       label: sat_sgdTZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf71; else goto cgf72;
       cgf71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTY_entry() //  [R1]
         { info_tbl: [(cgf77,
                       label: sat_sgdTY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf78; else goto cgf79;
       cgf78: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTX_entry() //  [R1]
         { info_tbl: [(cgf7e,
                       label: sat_sgdTX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf7f; else goto cgf7g;
       cgf7f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf7g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgf7i,
                       label: Data.Functor.Compose.$fReadCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7i: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cgf7m; else goto cgf7l;
       cgf7m: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf7l: // global
           I64[Hp - 192] = sat_sgdU0_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sgdTZ_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sgdTY_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgdTX_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.73137983 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_info;
         const 0;
 },
 sat_sgdU9_entry() //  [R1]
         { info_tbl: [(cgf7A,
                       label: sat_sgdU9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf7B; else goto cgf7C;
       cgf7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdU8_entry() //  [R1]
         { info_tbl: [(cgf7H,
                       label: sat_sgdU8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf7I; else goto cgf7J;
       cgf7I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf7J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgf7K,
                       label: Data.Functor.Compose.$fShowCompose_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgf7L; else goto cgf7M;
       cgf7L: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf7M: // global
           I64[Sp - 40] = block_cgf7r_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugf7Q; else goto cgf7s;
       ugf7Q: // global
           call _cgf7r(R1) args: 0, res: 0, upd: 0;
       cgf7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgf7r() //  [R1]
         { info_tbl: [(cgf7r,
                       label: block_cgf7r_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7r: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgf7P; else goto cgf7O;
       cgf7P: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgf7O: // global
           _sgdU7::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sgdU9_info;
           _sgdU3::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgdU3::P64;
           I64[Hp - 16] = sat_sgdU8_info;
           P64[Hp] = _sgdU3::P64;
           R6 = _sgdU7::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.734197439 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshow_closure" {
     Data.Functor.Compose.$fShowCompose_$cshow_closure:
         const Data.Functor.Compose.$fShowCompose_$cshow_info;
         const 0;
 },
 sp_sgdUe_entry() //  [R1]
         { info_tbl: [(cgf7Z,
                       label: sp_sgdUe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf80; else goto cgf81;
       cgf80: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf81: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sgdUf_entry() //  [R1]
         { info_tbl: [(cgf86,
                       label: sl_sgdUf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf86: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf87; else goto cgf88;
       cgf87: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf88: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdUh_entry() //  [R1]
         { info_tbl: [(cgf8h,
                       label: sat_sgdUh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8h: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgf8i; else goto cgf8j;
       cgf8i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf8j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdUg_entry() //  [R1]
         { info_tbl: [(cgf8o,
                       label: sat_sgdUg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgf8p; else goto cgf8q;
       cgf8p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf8q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdUi_entry() //  [R1]
         { info_tbl: [(cgf8r,
                       label: sat_sgdUi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8r: // global
           _sgdUi::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cgf8s; else goto cgf8t;
       cgf8t: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgf8v; else goto cgf8u;
       cgf8v: // global
           HpAlloc = 80;
           goto cgf8s;
       cgf8s: // global
           R1 = _sgdUi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf8u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdUi::P64;
           _sgdUa::P64 = P64[_sgdUi::P64 + 16];
           _sgdUb::P64 = P64[_sgdUi::P64 + 24];
           _sgdUd::P64 = P64[_sgdUi::P64 + 32];
           _sgdUe::P64 = P64[_sgdUi::P64 + 40];
           _sgdUf::P64 = P64[_sgdUi::P64 + 48];
           I64[Hp - 72] = sat_sgdUh_info;
           P64[Hp - 56] = _sgdUb::P64;
           P64[Hp - 48] = _sgdUe::P64;
           P64[Hp - 40] = _sgdUf::P64;
           I64[Hp - 32] = sat_sgdUg_info;
           P64[Hp - 16] = _sgdUb::P64;
           P64[Hp - 8] = _sgdUe::P64;
           P64[Hp] = _sgdUf::P64;
           R2 = _sgdUa::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 32;
           P64[Sp - 48] = Hp - 72;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sgdUd::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgf8x,
                       label: Data.Functor.Compose.$fShowCompose_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8x: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgf8B; else goto cgf8A;
       cgf8B: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf8A: // global
           I64[Hp - 120] = sp_sgdUe_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sgdUf_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgdUi_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = Hp - 120;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 72;
           R3 = Hp - 14;
           R2 = Data.Functor.Compose.$fDataCompose6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.737350128 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowList_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowList_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowList_info;
         const 0;
 },
 lvl8_sgdUp_entry() //  [R1]
         { info_tbl: [(cgf8K,
                       label: lvl8_sgdUp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf8L; else goto cgf8M;
       cgf8L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf8M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sgdUq_entry() //  [R1]
         { info_tbl: [(cgf8R,
                       label: lvl9_sgdUq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgf8S; else goto cgf8T;
       cgf8S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf8T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdUs_entry() //  [R1, R2]
         { info_tbl: [(cgf8Z,
                       label: sat_sgdUs_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf8Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgf90; else goto cgf91;
       cgf90: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgf91: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgdUr::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgdUr::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cgf92,
                       label: Data.Functor.Compose.$fShowCompose_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf92: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgf96; else goto cgf95;
       cgf96: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf95: // global
           I64[Hp - 80] = lvl8_sgdUp_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sgdUq_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgdUs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.742436814 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_closure" {
     Data.Functor.Compose.$fShowCompose_closure:
         const Data.Functor.Compose.$fShowCompose_info;
         const 0;
 },
 sat_sgdUy_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf9g,
                       label: sat_sgdUy_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf9g: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUx_entry() //  [R1, R2]
         { info_tbl: [(cgf9o,
                       label: sat_sgdUx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf9o: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fShowCompose_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgf9w,
                       label: sat_sgdUw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf9w: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgf9A,
                       label: Data.Functor.Compose.$fShowCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf9A: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgf9E; else goto cgf9D;
       cgf9E: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf9D: // global
           I64[Hp - 120] = sat_sgdUy_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sgdUx_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sgdUw_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.744562667 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose2_closure" {
     Data.Functor.Compose.$fFunctorCompose2_closure:
         const Data.Functor.Compose.$fFunctorCompose2_info;
 },
 sat_sgdUD_entry() //  [R1]
         { info_tbl: [(cgf9N,
                       label: sat_sgdUD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf9N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgf9O; else goto cgf9P;
       cgf9O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgf9P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgf9Q,
                       label: Data.Functor.Compose.$fFunctorCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf9Q: // global
           _sgdUC::P64 = R5;
           _sgdUB::P64 = R4;
           _sgdUA::P64 = R3;
           _sgdUz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgf9R; else goto cgf9S;
       cgf9S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgf9U; else goto cgf9T;
       cgf9U: // global
           HpAlloc = 32;
           goto cgf9R;
       cgf9R: // global
           R5 = _sgdUC::P64;
           R4 = _sgdUB::P64;
           R3 = _sgdUA::P64;
           R2 = _sgdUz::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf9T: // global
           I64[Hp - 24] = sat_sgdUD_info;
           P64[Hp - 8] = _sgdUA::P64;
           P64[Hp] = _sgdUB::P64;
           R2 = _sgdUz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUC::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.746245609 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose1_closure" {
     Data.Functor.Compose.$fFunctorCompose1_closure:
         const Data.Functor.Compose.$fFunctorCompose1_info;
 },
 sat_sgdUJ_entry() //  [R1]
         { info_tbl: [(cgfa8,
                       label: sat_sgdUJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfa8: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUK_entry() //  [R1]
         { info_tbl: [(cgfab,
                       label: sat_sgdUK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfab: // global
           _sgdUK::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfac; else goto cgfad;
       cgfad: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfaf; else goto cgfae;
       cgfaf: // global
           HpAlloc = 16;
           goto cgfac;
       cgfac: // global
           R1 = _sgdUK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfae: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdUK::P64;
           _sgdUF::P64 = P64[_sgdUK::P64 + 16];
           _sgdUG::P64 = P64[_sgdUK::P64 + 24];
           I64[Hp - 8] = sat_sgdUJ_info;
           P64[Hp] = _sgdUG::P64;
           R2 = _sgdUF::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgfag,
                       label: Data.Functor.Compose.$fFunctorCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfag: // global
           _sgdUH::P64 = R5;
           _sgdUG::P64 = R4;
           _sgdUF::P64 = R3;
           _sgdUE::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgfah; else goto cgfai;
       cgfai: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfak; else goto cgfaj;
       cgfak: // global
           HpAlloc = 32;
           goto cgfah;
       cgfah: // global
           R5 = _sgdUH::P64;
           R4 = _sgdUG::P64;
           R3 = _sgdUF::P64;
           R2 = _sgdUE::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfaj: // global
           I64[Hp - 24] = sat_sgdUK_info;
           P64[Hp - 8] = _sgdUF::P64;
           P64[Hp] = _sgdUG::P64;
           R2 = _sgdUE::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUH::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.748125612 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose_closure" {
     Data.Functor.Compose.$fFunctorCompose_closure:
         const Data.Functor.Compose.$fFunctorCompose_info;
 },
 sat_sgdUO_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfau,
                       label: sat_sgdUO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfau: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUN_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfaC,
                       label: sat_sgdUN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfaC: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFunctorCompose_entry() //  [R2, R3]
         { info_tbl: [(cgfaG,
                       label: Data.Functor.Compose.$fFunctorCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfaG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgfaK; else goto cgfaJ;
       cgfaK: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFunctorCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfaJ: // global
           I64[Hp - 64] = sat_sgdUO_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdUN_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.749813397 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info;
 },
 sat_sgdUU_entry() //  [R1]
         { info_tbl: [(cgfaT,
                       label: sat_sgdUU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfaT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfaU; else goto cgfaV;
       cgfaU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfaV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgfaW,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfaW: // global
           _sgdUT::P64 = R6;
           _sgdUS::P64 = R5;
           _sgdUR::P64 = R4;
           _sgdUQ::P64 = R3;
           _sgdUP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfaX; else goto cgfaY;
       cgfaY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfb0; else goto cgfaZ;
       cgfb0: // global
           HpAlloc = 40;
           goto cgfaX;
       cgfaX: // global
           R6 = _sgdUT::P64;
           R5 = _sgdUS::P64;
           R4 = _sgdUR::P64;
           R3 = _sgdUQ::P64;
           R2 = _sgdUP::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfaZ: // global
           I64[Hp - 32] = sat_sgdUU_info;
           P64[Hp - 16] = _sgdUQ::P64;
           P64[Hp - 8] = _sgdUR::P64;
           P64[Hp] = _sgdUS::P64;
           R2 = _sgdUP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgdUR::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgdUT::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.75137075 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfold_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfold_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfold_info;
 },
 sat_sgdUZ_entry() //  [R1]
         { info_tbl: [(cgfb9,
                       label: sat_sgdUZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfb9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfba; else goto cgfbb;
       cgfba: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfbb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgfbc,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbc: // global
           _sgdUY::P64 = R5;
           _sgdUX::P64 = R4;
           _sgdUW::P64 = R3;
           _sgdUV::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfbd; else goto cgfbe;
       cgfbe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfbg; else goto cgfbf;
       cgfbg: // global
           HpAlloc = 32;
           goto cgfbd;
       cgfbd: // global
           R5 = _sgdUY::P64;
           R4 = _sgdUX::P64;
           R3 = _sgdUW::P64;
           R2 = _sgdUV::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfbf: // global
           I64[Hp - 24] = sat_sgdUZ_info;
           P64[Hp - 8] = _sgdUW::P64;
           P64[Hp] = _sgdUX::P64;
           R2 = _sgdUV::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgdUX::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUY::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.752664181 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose1_closure" {
     Data.Functor.Compose.$fFoldableCompose1_closure:
         const Data.Functor.Compose.$fFoldableCompose1_info;
 },
 Data.Functor.Compose.$fFoldableCompose1_entry() //  [R2]
         { info_tbl: [(cgfbl,
                       label: Data.Functor.Compose.$fFoldableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbl: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.754005188 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$csum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$csum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$csum_info;
         const 0;
 },
 $dMonoid_sgdV4_entry() //  [R1]
         { info_tbl: [(cgfbw,
                       label: $dMonoid_sgdV4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfbx; else goto cgfby;
       cgfbx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfby: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdV5_entry() //  [R1]
         { info_tbl: [(cgfbD,
                       label: lvl8_sgdV5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfbE; else goto cgfbF;
       cgfbE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfbF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdV7_entry() //  [R1, R2]
         { info_tbl: [(cgfbL,
                       label: sat_sgdV7_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfbM; else goto cgfbN;
       cgfbM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfbN: // global
           _sgdV6::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgdV6::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cgfbO,
                       label: Data.Functor.Compose.$fFoldableCompose_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfbS; else goto cgfbR;
       cgfbS: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfbR: // global
           I64[Hp - 80] = $dMonoid_sgdV4_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdV5_info;
           P64[Hp - 40] = R3;
           _cgfbs::P64 = Hp - 80;
           P64[Hp - 32] = _cgfbs::P64;
           I64[Hp - 24] = sat_sgdV7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgfbs::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.755692035 UTC

[section ""cstring" . lvl_rgdPQ_bytes" {
     lvl_rgdPQ_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.756499764 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose2_closure" {
     Data.Functor.Compose.$fFoldableCompose2_closure:
         const Data.Functor.Compose.$fFoldableCompose2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose2_entry() //  [R1]
         { info_tbl: [(cgfc1,
                       label: Data.Functor.Compose.$fFoldableCompose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfc1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfc2; else goto cgfc3;
       cgfc2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfc3: // global
           (_cgfbW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfbW::I64 == 0) goto cgfbY; else goto cgfbX;
       cgfbY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfbX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfbW::I64;
           I64[Sp - 24] = block_cgfbZ_info;
           R2 = lvl_rgdPQ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfbZ() //  [R1]
         { info_tbl: [(cgfbZ,
                       label: block_cgfbZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfbZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.758287421 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cminimum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cminimum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_info;
         const 0;
 },
 $dMonoid_sgdVc_entry() //  [R1]
         { info_tbl: [(cgfcf,
                       label: $dMonoid_sgdVc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfcg; else goto cgfch;
       cgfcg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfch: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdVd_entry() //  [R1]
         { info_tbl: [(cgfcm,
                       label: lvl8_sgdVd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfcn; else goto cgfco;
       cgfcn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfco: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVh_entry() //  [R1, R2]
         { info_tbl: [(cgfcA,
                       label: sat_sgdVh_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfcB; else goto cgfcC;
       cgfcB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfcC: // global
           I64[Sp - 8] = block_cgfcu_info;
           _sgdVe::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgdVe::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfcu() //  [R1]
         { info_tbl: [(cgfcu,
                       label: block_cgfcu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcu: // global
           if (R1 & 7 == 1) goto cgfcx; else goto cgfcy;
       cgfcx: // global
           R1 = Data.Functor.Compose.$fFoldableCompose2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfcy: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgfcJ,
                       label: Data.Functor.Compose.$fFoldableCompose_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcJ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfcN; else goto cgfcM;
       cgfcN: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfcM: // global
           I64[Hp - 80] = $dMonoid_sgdVc_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdVd_info;
           P64[Hp - 40] = R3;
           _cgfcb::P64 = Hp - 80;
           P64[Hp - 32] = _cgfcb::P64;
           I64[Hp - 24] = sat_sgdVh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgfcb::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.760167311 UTC

[section ""cstring" . lvl1_rgdPR_bytes" {
     lvl1_rgdPR_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.760975832 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose3_closure" {
     Data.Functor.Compose.$fFoldableCompose3_closure:
         const Data.Functor.Compose.$fFoldableCompose3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose3_entry() //  [R1]
         { info_tbl: [(cgfcW,
                       label: Data.Functor.Compose.$fFoldableCompose3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfcX; else goto cgfcY;
       cgfcX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfcY: // global
           (_cgfcR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfcR::I64 == 0) goto cgfcT; else goto cgfcS;
       cgfcT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfcS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfcR::I64;
           I64[Sp - 24] = block_cgfcU_info;
           R2 = lvl1_rgdPR_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfcU() //  [R1]
         { info_tbl: [(cgfcU,
                       label: block_cgfcU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfcU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.762716861 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_info;
         const 0;
 },
 $dMonoid_sgdVm_entry() //  [R1]
         { info_tbl: [(cgfda,
                       label: $dMonoid_sgdVm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfdb; else goto cgfdc;
       cgfdb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfdc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdVn_entry() //  [R1]
         { info_tbl: [(cgfdh,
                       label: lvl8_sgdVn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfdh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfdi; else goto cgfdj;
       cgfdi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfdj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVr_entry() //  [R1, R2]
         { info_tbl: [(cgfdv,
                       label: sat_sgdVr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfdv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfdw; else goto cgfdx;
       cgfdw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfdx: // global
           I64[Sp - 8] = block_cgfdp_info;
           _sgdVo::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgdVo::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfdp() //  [R1]
         { info_tbl: [(cgfdp,
                       label: block_cgfdp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfdp: // global
           if (R1 & 7 == 1) goto cgfds; else goto cgfdt;
       cgfds: // global
           R1 = Data.Functor.Compose.$fFoldableCompose3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfdt: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgfdE,
                       label: Data.Functor.Compose.$fFoldableCompose_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfdE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfdI; else goto cgfdH;
       cgfdI: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfdH: // global
           I64[Hp - 80] = $dMonoid_sgdVm_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdVn_info;
           P64[Hp - 40] = R3;
           _cgfd6::P64 = Hp - 80;
           P64[Hp - 32] = _cgfd6::P64;
           I64[Hp - 24] = sat_sgdVr_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgfd6::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.765184602 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$celem_closure" {
     Data.Functor.Compose.$fFoldableCompose_$celem_closure:
         const Data.Functor.Compose.$fFoldableCompose_$celem_info;
         const 0;
 },
 sat_sgdVx_entry() //  [R1]
         { info_tbl: [(cgfdV,
                       label: sat_sgdVx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfdV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfdW; else goto cgfdX;
       cgfdW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfdX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_sgdVw_entry() //  [R1]
         { info_tbl: [(cgfdY,
                       label: lvl8_sgdVw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfdY: // global
           _sgdVw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfdZ; else goto cgfe0;
       cgfe0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfe2; else goto cgfe1;
       cgfe2: // global
           HpAlloc = 32;
           goto cgfdZ;
       cgfdZ: // global
           R1 = _sgdVw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfe1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVw::P64;
           _sgdVt::P64 = P64[_sgdVw::P64 + 16];
           _sgdVu::P64 = P64[_sgdVw::P64 + 24];
           _sgdVv::P64 = P64[_sgdVw::P64 + 32];
           I64[Hp - 24] = sat_sgdVx_info;
           P64[Hp - 8] = _sgdVu::P64;
           P64[Hp] = _sgdVv::P64;
           R2 = _sgdVt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVz_entry() //  [R1, R2]
         { info_tbl: [(cgfe8,
                       label: sat_sgdVz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfe8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfe9; else goto cgfea;
       cgfe9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfea: // global
           _sgdVy::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sgdVy::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cgfeb,
                       label: Data.Functor.Compose.$fFoldableCompose_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfeb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgfef; else goto cgfee;
       cgfef: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfee: // global
           I64[Hp - 56] = lvl8_sgdVw_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sgdVz_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.767212209 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose7_closure" {
     Data.Functor.Compose.$fFoldableCompose7_closure:
         const Data.Functor.Compose.$fFoldableCompose7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose7_entry() //  [R1]
         { info_tbl: [(cgfem,
                       label: Data.Functor.Compose.$fFoldableCompose7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfem: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfen; else goto cgfeo;
       cgfen: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfeo: // global
           (_cgfej::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfej::I64 == 0) goto cgfel; else goto cgfek;
       cgfel: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfek: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfej::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.768556479 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_info;
         const 0;
 },
 sat_sgdVH_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfeC,
                       label: sat_sgdVH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfeC: // global
           _sgdVG::P64 = R3;
           R3 = R2;
           R2 = _sgdVG::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdVI_entry() //  [R1]
         { info_tbl: [(cgfeF,
                       label: sat_sgdVI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfeF: // global
           _sgdVI::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfeG; else goto cgfeH;
       cgfeH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfeJ; else goto cgfeI;
       cgfeJ: // global
           HpAlloc = 16;
           goto cgfeG;
       cgfeG: // global
           R1 = _sgdVI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfeI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVI::P64;
           _sgdVB::P64 = P64[_sgdVI::P64 + 16];
           _sgdVC::P64 = P64[_sgdVI::P64 + 24];
           I64[Hp - 8] = sat_sgdVH_info;
           P64[Hp] = _sgdVC::P64;
           R2 = _sgdVB::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgfeK,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfeK: // global
           _sgdVE::P64 = R6;
           _sgdVD::P64 = R5;
           _sgdVC::P64 = R4;
           _sgdVB::P64 = R3;
           _sgdVA::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfeL; else goto cgfeM;
       cgfeM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfeO; else goto cgfeN;
       cgfeO: // global
           HpAlloc = 32;
           goto cgfeL;
       cgfeL: // global
           R6 = _sgdVE::P64;
           R5 = _sgdVD::P64;
           R4 = _sgdVC::P64;
           R3 = _sgdVB::P64;
           R2 = _sgdVA::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfeN: // global
           I64[Hp - 24] = sat_sgdVI_info;
           P64[Hp - 8] = _sgdVB::P64;
           P64[Hp] = _sgdVC::P64;
           R2 = _sgdVA::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdVE::P64;
           P64[Sp - 8] = _sgdVD::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.770364275 UTC

[section ""cstring" . lvl2_rgdPS_bytes" {
     lvl2_rgdPS_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.771113185 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose6_closure" {
     Data.Functor.Compose.$fFoldableCompose6_closure:
         const Data.Functor.Compose.$fFoldableCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose6_entry() //  [R1]
         { info_tbl: [(cgfeX,
                       label: Data.Functor.Compose.$fFoldableCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfeX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfeY; else goto cgfeZ;
       cgfeY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfeZ: // global
           (_cgfeS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfeS::I64 == 0) goto cgfeU; else goto cgfeT;
       cgfeU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfeT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfeS::I64;
           I64[Sp - 24] = block_cgfeV_info;
           R2 = lvl2_rgdPS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfeV() //  [R1]
         { info_tbl: [(cgfeV,
                       label: block_cgfeV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfeV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.773119864 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info;
         const 0;
 },
 sat_sgdVS_entry() //  [R1]
         { info_tbl: [(cgffr,
                       label: sat_sgdVS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgffr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgffs; else goto cgfft;
       cgffs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfft: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgffk_info;
           _sgdVM::P64 = P64[R1 + 16];
           _sgdVO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgdVM::P64;
           P64[Sp - 24] = _sgdVO::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugffA; else goto cgffl;
       ugffA: // global
           call _cgffk(R1) args: 0, res: 0, upd: 0;
       cgffl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgffk() //  [R1]
         { info_tbl: [(cgffk,
                       label: block_cgffk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgffk: // global
           _sgdVO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgffo; else goto cgffp;
       cgffo: // global
           R1 = _sgdVO::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgffp: // global
           R3 = _sgdVO::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdVT_entry() //  [R1, R2, R3]
         { info_tbl: [(cgffC,
                       label: sat_sgdVT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgffC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgffG; else goto cgffF;
       cgffG: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgffF: // global
           _sgdVM::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgdVS_info;
           P64[Hp - 32] = _sgdVM::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdVU_entry() //  [R1]
         { info_tbl: [(cgffH,
                       label: sat_sgdVU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgffH: // global
           _sgdVU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgffI; else goto cgffJ;
       cgffJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgffL; else goto cgffK;
       cgffL: // global
           HpAlloc = 16;
           goto cgffI;
       cgffI: // global
           R1 = _sgdVU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgffK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVU::P64;
           _sgdVL::P64 = P64[_sgdVU::P64 + 16];
           _sgdVM::P64 = P64[_sgdVU::P64 + 24];
           I64[Hp - 8] = sat_sgdVT_info;
           P64[Hp] = _sgdVM::P64;
           R2 = _sgdVL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgffS,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgffS: // global
           _sgdVN::P64 = R5;
           _sgdVM::P64 = R4;
           _sgdVL::P64 = R3;
           _sgdVK::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgffT; else goto cgffU;
       cgffU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgffW; else goto cgffV;
       cgffW: // global
           HpAlloc = 32;
           goto cgffT;
       cgffT: // global
           R5 = _sgdVN::P64;
           R4 = _sgdVM::P64;
           R3 = _sgdVL::P64;
           R2 = _sgdVK::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgffV: // global
           I64[Hp - 24] = sat_sgdVU_info;
           P64[Hp - 8] = _sgdVL::P64;
           P64[Hp] = _sgdVM::P64;
           I64[Sp - 8] = block_cgffM_info;
           R2 = _sgdVK::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdVN::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cgffM() //  [R1]
         { info_tbl: [(cgffM,
                       label: block_cgffM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgffM: // global
           if (R1 & 7 == 1) goto cgffP; else goto cgffQ;
       cgffP: // global
           R1 = Data.Functor.Compose.$fFoldableCompose6_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgffQ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.776151744 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info;
         const 0;
 },
 sat_sgdW6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfgi,
                       label: sat_sgdW6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfgj; else goto cgfgk;
       cgfgj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfgk: // global
           I64[Sp - 16] = block_cgfgg_info;
           _sgdW3::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgdW3::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfgg() //  [R1]
         { info_tbl: [(cgfgg,
                       label: block_cgfgg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgg: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdW7_entry() //  [R1]
         { info_tbl: [(cgfgm,
                       label: sat_sgdW7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgm: // global
           _sgdW7::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfgn; else goto cgfgo;
       cgfgo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfgq; else goto cgfgp;
       cgfgq: // global
           HpAlloc = 16;
           goto cgfgn;
       cgfgn: // global
           R1 = _sgdW7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfgp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdW7::P64;
           _sgdVY::P64 = P64[_sgdW7::P64 + 16];
           _sgdVZ::P64 = P64[_sgdW7::P64 + 24];
           I64[Hp - 8] = sat_sgdW6_info;
           P64[Hp] = _sgdVZ::P64;
           R2 = _sgdVY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cgfgr,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgr: // global
           _sgdW1::P64 = R6;
           _sgdW0::P64 = R5;
           _sgdVZ::P64 = R4;
           _sgdVY::P64 = R3;
           _sgdVX::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfgs; else goto cgfgt;
       cgfgt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfgv; else goto cgfgu;
       cgfgv: // global
           HpAlloc = 32;
           goto cgfgs;
       cgfgs: // global
           R6 = _sgdW1::P64;
           R5 = _sgdW0::P64;
           R4 = _sgdVZ::P64;
           R3 = _sgdVY::P64;
           R2 = _sgdVX::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfgu: // global
           I64[Hp - 24] = sat_sgdW7_info;
           P64[Hp - 8] = _sgdVY::P64;
           P64[Hp] = _sgdVZ::P64;
           R2 = _sgdVX::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdW1::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgdW0::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.778331767 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_info;
         const 0;
 },
 sat_sgdWd_entry() //  [R1]
         { info_tbl: [(cgfgE,
                       label: sat_sgdWd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfgF; else goto cgfgG;
       cgfgF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfgG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgfgH,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgH: // global
           _sgdWc::P64 = R6;
           _sgdWb::P64 = R5;
           _sgdWa::P64 = R4;
           _sgdW9::P64 = R3;
           _sgdW8::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfgI; else goto cgfgJ;
       cgfgJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfgL; else goto cgfgK;
       cgfgL: // global
           HpAlloc = 32;
           goto cgfgI;
       cgfgI: // global
           R6 = _sgdWc::P64;
           R5 = _sgdWb::P64;
           R4 = _sgdWa::P64;
           R3 = _sgdW9::P64;
           R2 = _sgdW8::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfgK: // global
           I64[Hp - 24] = sat_sgdWd_info;
           P64[Hp - 8] = _sgdW9::P64;
           P64[Hp] = _sgdWa::P64;
           R2 = _sgdW8::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdWc::P64;
           P64[Sp - 8] = _sgdWb::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.780202378 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info;
         const 0;
 },
 sat_sgdWn_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfh1,
                       label: sat_sgdWn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfh1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfh2; else goto cgfh3;
       cgfh2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfh3: // global
           I64[Sp - 16] = block_cgfgZ_info;
           _sgdWk::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgdWk::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfgZ() //  [R1]
         { info_tbl: [(cgfgZ,
                       label: block_cgfgZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfgZ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdWo_entry() //  [R1]
         { info_tbl: [(cgfh5,
                       label: sat_sgdWo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfh5: // global
           _sgdWo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfh6; else goto cgfh7;
       cgfh7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfh9; else goto cgfh8;
       cgfh9: // global
           HpAlloc = 16;
           goto cgfh6;
       cgfh6: // global
           R1 = _sgdWo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfh8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdWo::P64;
           _sgdWf::P64 = P64[_sgdWo::P64 + 16];
           _sgdWg::P64 = P64[_sgdWo::P64 + 24];
           I64[Hp - 8] = sat_sgdWn_info;
           P64[Hp] = _sgdWg::P64;
           R2 = _sgdWf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cgfha,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfha: // global
           _sgdWi::P64 = R6;
           _sgdWh::P64 = R5;
           _sgdWg::P64 = R4;
           _sgdWf::P64 = R3;
           _sgdWe::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfhb; else goto cgfhc;
       cgfhc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfhe; else goto cgfhd;
       cgfhe: // global
           HpAlloc = 32;
           goto cgfhb;
       cgfhb: // global
           R6 = _sgdWi::P64;
           R5 = _sgdWh::P64;
           R4 = _sgdWg::P64;
           R3 = _sgdWf::P64;
           R2 = _sgdWe::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfhd: // global
           I64[Hp - 24] = sat_sgdWo_info;
           P64[Hp - 8] = _sgdWf::P64;
           P64[Hp] = _sgdWg::P64;
           R2 = _sgdWe::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdWi::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgdWh::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.782704937 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose4_closure" {
     Data.Functor.Compose.$fFoldableCompose4_closure:
         const Data.Functor.Compose.$fFoldableCompose4_info;
 },
 Data.Functor.Compose.$fFoldableCompose4_entry() //  [R2, R3, R4]
         { info_tbl: [(cgfhm,
                       label: Data.Functor.Compose.$fFoldableCompose4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfhm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfht; else goto cgfhu;
       cgfht: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfhu: // global
           I64[Sp - 16] = block_cgfhj_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugfhy; else goto cgfhk;
       ugfhy: // global
           call _cgfhj(R1) args: 0, res: 0, upd: 0;
       cgfhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfhj() //  [R1]
         { info_tbl: [(cgfhj,
                       label: block_cgfhj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfhx; else goto cgfhw;
       cgfhx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfhw: // global
           _sgdWu::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgdWu::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.784168849 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$clength_closure" {
     Data.Functor.Compose.$fFoldableCompose_$clength_closure:
         const Data.Functor.Compose.$fFoldableCompose_$clength_info;
         const 0;
 },
 sat_sgdWz_entry() //  [R1]
         { info_tbl: [(cgfhH,
                       label: sat_sgdWz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfhH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfhI; else goto cgfhJ;
       cgfhI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfhJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose4_closure+3;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgfhK,
                       label: Data.Functor.Compose.$fFoldableCompose_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfhK: // global
           _sgdWy::P64 = R4;
           _sgdWx::P64 = R3;
           _sgdWw::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfhL; else goto cgfhM;
       cgfhM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfhO; else goto cgfhN;
       cgfhO: // global
           HpAlloc = 24;
           goto cgfhL;
       cgfhL: // global
           R4 = _sgdWy::P64;
           R3 = _sgdWx::P64;
           R2 = _sgdWw::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfhN: // global
           I64[Hp - 16] = sat_sgdWz_info;
           P64[Hp] = _sgdWx::P64;
           R2 = _sgdWw::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgdWy::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = Data.Functor.Compose.$fDataCompose3_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.785449651 UTC

[section ""cstring" . lvl3_rgdPT_bytes" {
     lvl3_rgdPT_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.786232129 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose8_closure" {
     Data.Functor.Compose.$fFoldableCompose8_closure:
         const Data.Functor.Compose.$fFoldableCompose8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose8_entry() //  [R1]
         { info_tbl: [(cgfhX,
                       label: Data.Functor.Compose.$fFoldableCompose8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfhX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfhY; else goto cgfhZ;
       cgfhY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfhZ: // global
           (_cgfhS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfhS::I64 == 0) goto cgfhU; else goto cgfhT;
       cgfhU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfhT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfhS::I64;
           I64[Sp - 24] = block_cgfhV_info;
           R2 = lvl3_rgdPT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfhV() //  [R1]
         { info_tbl: [(cgfhV,
                       label: block_cgfhV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfhV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.788255359 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info;
         const 0;
 },
 sat_sgdWJ_entry() //  [R1]
         { info_tbl: [(cgfir,
                       label: sat_sgdWJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfir: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfis; else goto cgfit;
       cgfis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgfik_info;
           _sgdWD::P64 = P64[R1 + 16];
           _sgdWF::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgdWD::P64;
           P64[Sp - 24] = _sgdWF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugfiA; else goto cgfil;
       ugfiA: // global
           call _cgfik(R1) args: 0, res: 0, upd: 0;
       cgfil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgfik() //  [R1]
         { info_tbl: [(cgfik,
                       label: block_cgfik_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfik: // global
           _sgdWF::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgfio; else goto cgfip;
       cgfio: // global
           R1 = _sgdWF::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgfip: // global
           R3 = P64[R1 + 6];
           R2 = _sgdWF::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdWK_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfiC,
                       label: sat_sgdWK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfiC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfiG; else goto cgfiF;
       cgfiG: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfiF: // global
           _sgdWD::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgdWJ_info;
           P64[Hp - 32] = _sgdWD::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdWL_entry() //  [R1]
         { info_tbl: [(cgfiH,
                       label: sat_sgdWL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfiH: // global
           _sgdWL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfiI; else goto cgfiJ;
       cgfiJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfiL; else goto cgfiK;
       cgfiL: // global
           HpAlloc = 16;
           goto cgfiI;
       cgfiI: // global
           R1 = _sgdWL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfiK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdWL::P64;
           _sgdWC::P64 = P64[_sgdWL::P64 + 16];
           _sgdWD::P64 = P64[_sgdWL::P64 + 24];
           I64[Hp - 8] = sat_sgdWK_info;
           P64[Hp] = _sgdWD::P64;
           R2 = _sgdWC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cgfiS,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfiS: // global
           _sgdWE::P64 = R5;
           _sgdWD::P64 = R4;
           _sgdWC::P64 = R3;
           _sgdWB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfiT; else goto cgfiU;
       cgfiU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfiW; else goto cgfiV;
       cgfiW: // global
           HpAlloc = 32;
           goto cgfiT;
       cgfiT: // global
           R5 = _sgdWE::P64;
           R4 = _sgdWD::P64;
           R3 = _sgdWC::P64;
           R2 = _sgdWB::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfiV: // global
           I64[Hp - 24] = sat_sgdWL_info;
           P64[Hp - 8] = _sgdWC::P64;
           P64[Hp] = _sgdWD::P64;
           I64[Sp - 8] = block_cgfiM_info;
           R2 = _sgdWB::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdWE::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cgfiM() //  [R1]
         { info_tbl: [(cgfiM,
                       label: block_cgfiM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfiM: // global
           if (R1 & 7 == 1) goto cgfiP; else goto cgfiQ;
       cgfiP: // global
           R1 = Data.Functor.Compose.$fFoldableCompose8_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfiQ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.790872576 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose5_closure" {
     Data.Functor.Compose.$fFoldableCompose5_closure:
         const Data.Functor.Compose.$fFoldableCompose5_info;
 },
 Data.Functor.Compose.$fFoldableCompose5_entry() //  []
         { info_tbl: [(cgfj7,
                       label: Data.Functor.Compose.$fFoldableCompose5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfj7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.791873343 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cnull_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cnull_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cnull_info;
         const 0;
 },
 sat_sgdWT_entry() //  [R1]
         { info_tbl: [(cgfji,
                       label: sat_sgdWT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfji: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfjj; else goto cgfjk;
       cgfjj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfjk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose5_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgfjl,
                       label: Data.Functor.Compose.$fFoldableCompose_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfjl: // global
           _sgdWS::P64 = R4;
           _sgdWR::P64 = R3;
           _sgdWQ::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfjm; else goto cgfjn;
       cgfjn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfjp; else goto cgfjo;
       cgfjp: // global
           HpAlloc = 24;
           goto cgfjm;
       cgfjm: // global
           R4 = _sgdWS::P64;
           R3 = _sgdWR::P64;
           R2 = _sgdWQ::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfjo: // global
           I64[Hp - 16] = sat_sgdWT_info;
           P64[Hp] = _sgdWR::P64;
           R2 = _sgdWQ::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdWS::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.793915497 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cproduct_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cproduct_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_info;
         const 0;
 },
 $dMonoid_sgdWX_entry() //  [R1]
         { info_tbl: [(cgfjy,
                       label: $dMonoid_sgdWX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfjy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfjz; else goto cgfjA;
       cgfjz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfjA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdWY_entry() //  [R1]
         { info_tbl: [(cgfjF,
                       label: lvl8_sgdWY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfjF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfjG; else goto cgfjH;
       cgfjG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfjH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdX0_entry() //  [R1, R2]
         { info_tbl: [(cgfjN,
                       label: sat_sgdX0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfjN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfjO; else goto cgfjP;
       cgfjO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfjP: // global
           _sgdWZ::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgdWZ::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgfjQ,
                       label: Data.Functor.Compose.$fFoldableCompose_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfjQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfjU; else goto cgfjT;
       cgfjU: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfjT: // global
           I64[Hp - 80] = $dMonoid_sgdWX_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdWY_info;
           P64[Hp - 40] = R3;
           _cgfju::P64 = Hp - 80;
           P64[Hp - 32] = _cgfju::P64;
           I64[Hp - 24] = sat_sgdX0_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cgfju::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.796005659 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$ctoList_closure" {
     Data.Functor.Compose.$fFoldableCompose_$ctoList_closure:
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_info;
         const 0;
 },
 sat_sgdX4_entry() //  [R1]
         { info_tbl: [(cgfk3,
                       label: sat_sgdX4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfk3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfk4; else goto cgfk5;
       cgfk4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfk5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgfk6,
                       label: Data.Functor.Compose.$fFoldableCompose_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfk6: // global
           _sgdX3::P64 = R4;
           _sgdX2::P64 = R3;
           _sgdX1::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfk7; else goto cgfk8;
       cgfk8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfka; else goto cgfk9;
       cgfka: // global
           HpAlloc = 24;
           goto cgfk7;
       cgfk7: // global
           R4 = _sgdX3::P64;
           R3 = _sgdX2::P64;
           R2 = _sgdX1::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfk9: // global
           I64[Hp - 16] = sat_sgdX4_info;
           P64[Hp] = _sgdX2::P64;
           R2 = _sgdX1::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdX3::P64;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.799463621 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_closure" {
     Data.Functor.Compose.$fFoldableCompose_closure:
         const Data.Functor.Compose.$fFoldableCompose_info;
         const 0;
 },
 sat_sgdXm_entry() //  [R1, R2]
         { info_tbl: [(cgfkk,
                       label: sat_sgdXm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfkk: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXl_entry() //  [R1, R2]
         { info_tbl: [(cgfks,
                       label: sat_sgdXl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfks: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXk_entry() //  [R1, R2]
         { info_tbl: [(cgfkA,
                       label: sat_sgdXk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfkA: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXj_entry() //  [R1, R2]
         { info_tbl: [(cgfkI,
                       label: sat_sgdXj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfkI: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXi_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfkQ,
                       label: sat_sgdXi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfkQ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXh_entry() //  [R1, R2]
         { info_tbl: [(cgfkY,
                       label: sat_sgdXh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfkY: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXg_entry() //  [R1, R2]
         { info_tbl: [(cgfl6,
                       label: sat_sgdXg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfl6: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXf_entry() //  [R1, R2]
         { info_tbl: [(cgfle,
                       label: sat_sgdXf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfle: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXe_entry() //  [R1, R2, R3]
         { info_tbl: [(cgflm,
                       label: sat_sgdXe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgflm: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXd_entry() //  [R1, R2, R3]
         { info_tbl: [(cgflu,
                       label: sat_sgdXd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgflu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgflC,
                       label: sat_sgdXc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgflC: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXb_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgflK,
                       label: sat_sgdXb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgflK: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXa_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgflS,
                       label: sat_sgdXa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgflS: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfm0,
                       label: sat_sgdX9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfm0: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX8_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfm8,
                       label: sat_sgdX8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfm8: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX7_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfmg,
                       label: sat_sgdX7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmg: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_entry() //  [R2, R3]
         { info_tbl: [(cgfmk,
                       label: Data.Functor.Compose.$fFoldableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmk: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cgfmo; else goto cgfmn;
       cgfmo: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfmn: // global
           I64[Hp - 512] = sat_sgdXm_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sgdXl_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sgdXk_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sgdXj_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sgdXi_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sgdXh_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sgdXg_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sgdXf_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sgdXe_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sgdXd_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sgdXc_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sgdXb_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sgdXa_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sgdX9_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgdX8_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgdX7_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.80399176 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose1_closure" {
     Data.Functor.Compose.$fTraversableCompose1_closure:
         const Data.Functor.Compose.$fTraversableCompose1_info;
 },
 Data.Functor.Compose.$fTraversableCompose1_entry() //  [R2]
         { info_tbl: [(cgfmt,
                       label: Data.Functor.Compose.$fTraversableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.805386155 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure" {
     Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure:
         const Data.Functor.Compose.$fTraversableCompose_$ctraverse_info;
 },
 sat_sgdXu_entry() //  [R1]
         { info_tbl: [(cgfmI,
                       label: sat_sgdXu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfmJ; else goto cgfmK;
       cgfmJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfmK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdXv_entry() //  [R1]
         { info_tbl: [(cgfmL,
                       label: sat_sgdXv_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmL: // global
           _sgdXv::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfmM; else goto cgfmN;
       cgfmN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfmP; else goto cgfmO;
       cgfmP: // global
           HpAlloc = 40;
           goto cgfmM;
       cgfmM: // global
           R1 = _sgdXv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfmO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdXv::P64;
           _sgdXo::P64 = P64[_sgdXv::P64 + 16];
           _sgdXp::P64 = P64[_sgdXv::P64 + 24];
           _sgdXq::P64 = P64[_sgdXv::P64 + 32];
           _sgdXr::P64 = P64[_sgdXv::P64 + 40];
           _sgdXs::P64 = P64[_sgdXv::P64 + 48];
           I64[Hp - 32] = sat_sgdXu_info;
           P64[Hp - 16] = _sgdXp::P64;
           P64[Hp - 8] = _sgdXq::P64;
           P64[Hp] = _sgdXr::P64;
           R2 = _sgdXo::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sgdXq::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgdXs::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cgfmS,
                       label: Data.Functor.Compose.$fTraversableCompose_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmS: // global
           _sgdXs::P64 = R6;
           _sgdXr::P64 = R5;
           _sgdXq::P64 = R4;
           _sgdXp::P64 = R3;
           _sgdXo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgfmT; else goto cgfmU;
       cgfmU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfmW; else goto cgfmV;
       cgfmW: // global
           HpAlloc = 56;
           goto cgfmT;
       cgfmT: // global
           R6 = _sgdXs::P64;
           R5 = _sgdXr::P64;
           R4 = _sgdXq::P64;
           R3 = _sgdXp::P64;
           R2 = _sgdXo::P64;
           R1 = Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfmV: // global
           I64[Hp - 48] = sat_sgdXv_info;
           P64[Hp - 32] = _sgdXo::P64;
           P64[Hp - 24] = _sgdXp::P64;
           P64[Hp - 16] = _sgdXq::P64;
           P64[Hp - 8] = _sgdXr::P64;
           P64[Hp] = _sgdXs::P64;
           I64[Sp - 16] = block_cgfmQ_info;
           R2 = _sgdXq::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfmQ() //  [R1]
         { info_tbl: [(cgfmQ,
                       label: block_cgfmQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfmQ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Compose.$fTraversableCompose1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.807629755 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info;
         const 0;
 },
 sat_sgdXz_entry() //  [R1]
         { info_tbl: [(cgfn8,
                       label: sat_sgdXz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfn8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfn9; else goto cgfna;
       cgfn9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfna: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXy_entry() //  [R1]
         { info_tbl: [(cgfnf,
                       label: sat_sgdXy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfng; else goto cgfnh;
       cgfng: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfnh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgfni,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfni: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgfnm; else goto cgfnl;
       cgfnm: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfnl: // global
           I64[Hp - 40] = sat_sgdXz_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdXy_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFoldableCompose_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.809520948 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info;
 },
 sat_sgdXD_entry() //  [R1]
         { info_tbl: [(cgfnv,
                       label: sat_sgdXD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfnw; else goto cgfnx;
       cgfnw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfnx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXC_entry() //  [R1]
         { info_tbl: [(cgfnC,
                       label: sat_sgdXC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfnD; else goto cgfnE;
       cgfnD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfnE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgfnF,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgfnJ; else goto cgfnI;
       cgfnJ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfnI: // global
           I64[Hp - 40] = sat_sgdXD_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdXC_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.810884834 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequenceA_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgfnO,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnO: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.811930113 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cmapM_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cmapM_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cmapM_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgfnX,
                       label: Data.Functor.Compose.$fTraversableCompose_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfnY; else goto cgfnZ;
       cgfnY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfnZ: // global
           I64[Sp - 40] = block_cgfnV_info;
           _sgdXH::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sgdXH::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfnV() //  [R1]
         { info_tbl: [(cgfnV,
                       label: block_cgfnV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfnV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.813341906 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequence_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequence_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequence_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cgfo9,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfo9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfoa; else goto cgfob;
       cgfoa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfob: // global
           I64[Sp - 32] = block_cgfo7_info;
           _sgdXN::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgdXN::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfo7() //  [R1]
         { info_tbl: [(cgfo7,
                       label: block_cgfo7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfo7: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.815387865 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_closure" {
     Data.Functor.Compose.$fTraversableCompose_closure:
         const Data.Functor.Compose.$fTraversableCompose_info;
         const 0;
 },
 sat_sgdXZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfoo,
                       label: sat_sgdXZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfoo: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfow,
                       label: sat_sgdXY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfow: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXX_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfoE,
                       label: sat_sgdXX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfoE: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXW_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfoM,
                       label: sat_sgdXW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfoM: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXV_entry() //  [R1]
         { info_tbl: [(cgfoT,
                       label: sat_sgdXV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfoT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfoU; else goto cgfoV;
       cgfoU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfoV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXU_entry() //  [R1]
         { info_tbl: [(cgfp0,
                       label: sat_sgdXU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfp0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfp1; else goto cgfp2;
       cgfp1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfp2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_entry() //  [R2, R3]
         { info_tbl: [(cgfp4,
                       label: Data.Functor.Compose.$fTraversableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfp4: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cgfp8; else goto cgfp7;
       cgfp8: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfp7: // global
           I64[Hp - 208] = sat_sgdXZ_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sgdXY_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sgdXX_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sgdXW_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgdXV_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgdXU_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.818107333 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose4_closure" {
     Data.Functor.Compose.$fApplicativeCompose4_closure:
         const Data.Functor.Compose.$fApplicativeCompose4_info;
 },
 sat_sgdY5_entry() //  [R1]
         { info_tbl: [(cgfph,
                       label: sat_sgdY5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfph: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfpi; else goto cgfpj;
       cgfpi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfpj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose4_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cgfpk,
                       label: Data.Functor.Compose.$fApplicativeCompose4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfpk: // global
           _sgdY4::P64 = R6;
           _sgdY3::P64 = R5;
           _sgdY2::P64 = R4;
           _sgdY1::P64 = R3;
           _sgdY0::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfpl; else goto cgfpm;
       cgfpm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfpo; else goto cgfpn;
       cgfpo: // global
           HpAlloc = 32;
           goto cgfpl;
       cgfpl: // global
           R6 = _sgdY4::P64;
           R5 = _sgdY3::P64;
           R4 = _sgdY2::P64;
           R3 = _sgdY1::P64;
           R2 = _sgdY0::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfpn: // global
           I64[Hp - 24] = sat_sgdY5_info;
           P64[Hp - 8] = _sgdY1::P64;
           P64[Hp] = _sgdY2::P64;
           R2 = _sgdY0::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdY3::P64;
           P64[Sp - 8] = _sgdY4::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.819673005 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose5_closure" {
     Data.Functor.Compose.$fApplicativeCompose5_closure:
         const Data.Functor.Compose.$fApplicativeCompose5_info;
 },
 sat_sgdYa_entry() //  [R1]
         { info_tbl: [(cgfpx,
                       label: sat_sgdYa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfpx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfpy; else goto cgfpz;
       cgfpy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfpz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose5_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgfpA,
                       label: Data.Functor.Compose.$fApplicativeCompose5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfpA: // global
           _sgdY9::P64 = R5;
           _sgdY8::P64 = R4;
           _sgdY7::P64 = R3;
           _sgdY6::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfpB; else goto cgfpC;
       cgfpC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfpE; else goto cgfpD;
       cgfpE: // global
           HpAlloc = 24;
           goto cgfpB;
       cgfpB: // global
           R5 = _sgdY9::P64;
           R4 = _sgdY8::P64;
           R3 = _sgdY7::P64;
           R2 = _sgdY6::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfpD: // global
           I64[Hp - 16] = sat_sgdYa_info;
           P64[Hp] = _sgdY7::P64;
           R2 = _sgdY6::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdY8::P64;
           P64[Sp - 8] = _sgdY9::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.824086855 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose6_closure" {
     Data.Functor.Compose.$fApplicativeCompose6_closure:
         const Data.Functor.Compose.$fApplicativeCompose6_info;
 },
 sat_sgdYe_entry() //  [R1]
         { info_tbl: [(cgfpN,
                       label: sat_sgdYe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfpN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfpO; else goto cgfpP;
       cgfpO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfpP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose6_entry() //  [R2, R3, R4]
         { info_tbl: [(cgfpQ,
                       label: Data.Functor.Compose.$fApplicativeCompose6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfpQ: // global
           _sgdYd::P64 = R4;
           _sgdYc::P64 = R3;
           _sgdYb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfpR; else goto cgfpS;
       cgfpS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfpU; else goto cgfpT;
       cgfpU: // global
           HpAlloc = 32;
           goto cgfpR;
       cgfpR: // global
           R4 = _sgdYd::P64;
           R3 = _sgdYc::P64;
           R2 = _sgdYb::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfpT: // global
           I64[Hp - 24] = sat_sgdYe_info;
           P64[Hp - 8] = _sgdYc::P64;
           P64[Hp] = _sgdYd::P64;
           R2 = _sgdYb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.826105463 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure" {
     Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure:
         const Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info;
 },
 sat_sgdYi_entry() //  [R1]
         { info_tbl: [(cgfq3,
                       label: sat_sgdYi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfq3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfq4; else goto cgfq5;
       cgfq4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfq5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdYh_entry() //  [R1]
         { info_tbl: [(cgfqa,
                       label: sat_sgdYh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfqb; else goto cgfqc;
       cgfqb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfqc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgfqd,
                       label: Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgfqh; else goto cgfqg;
       cgfqh: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfqg: // global
           I64[Hp - 40] = sat_sgdYi_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdYh_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.827528843 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose3_closure" {
     Data.Functor.Compose.$fApplicativeCompose3_closure:
         const Data.Functor.Compose.$fApplicativeCompose3_info;
 },
 Data.Functor.Compose.$fApplicativeCompose3_entry() //  [R3]
         { info_tbl: [(cgfqm,
                       label: Data.Functor.Compose.$fApplicativeCompose3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqm: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.828928434 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose2_closure" {
     Data.Functor.Compose.$fApplicativeCompose2_closure:
         const Data.Functor.Compose.$fApplicativeCompose2_info;
 },
 sat_sgdYs_entry() //  [R1]
         { info_tbl: [(cgfqD,
                       label: sat_sgdYs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfqE; else goto cgfqF;
       cgfqE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgfqB_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfqB() //  [R1]
         { info_tbl: [(cgfqB,
                       label: block_cgfqB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Functor.Compose.$fApplicativeCompose3_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYt_entry() //  [R1]
         { info_tbl: [(cgfqL,
                       label: sat_sgdYt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqL: // global
           _sgdYt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfqM; else goto cgfqN;
       cgfqN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfqP; else goto cgfqO;
       cgfqP: // global
           HpAlloc = 24;
           goto cgfqM;
       cgfqM: // global
           R1 = _sgdYt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfqO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYt::P64;
           _sgdYl::P64 = P64[_sgdYt::P64 + 16];
           _sgdYm::P64 = P64[_sgdYt::P64 + 24];
           _sgdYn::P64 = P64[_sgdYt::P64 + 32];
           I64[Hp - 16] = sat_sgdYs_info;
           P64[Hp] = _sgdYm::P64;
           I64[Sp - 40] = block_cgfqJ_info;
           R2 = _sgdYl::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgdYn::P64;
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfqJ() //  [R1]
         { info_tbl: [(cgfqJ,
                       label: block_cgfqJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdYp_entry() //  [R1]
         { info_tbl: [(cgfqX,
                       label: sat_sgdYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfqX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfqY; else goto cgfqZ;
       cgfqY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfqZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgfr0,
                       label: Data.Functor.Compose.$fApplicativeCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfr0: // global
           _sgdYo::P64 = R5;
           _sgdYn::P64 = R4;
           _sgdYm::P64 = R3;
           _sgdYl::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfr1; else goto cgfr2;
       cgfr2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgfr4; else goto cgfr3;
       cgfr4: // global
           HpAlloc = 64;
           goto cgfr1;
       cgfr1: // global
           R5 = _sgdYo::P64;
           R4 = _sgdYn::P64;
           R3 = _sgdYm::P64;
           R2 = _sgdYl::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfr3: // global
           I64[Hp - 56] = sat_sgdYt_info;
           P64[Hp - 40] = _sgdYl::P64;
           P64[Hp - 32] = _sgdYm::P64;
           P64[Hp - 24] = _sgdYn::P64;
           I64[Hp - 16] = sat_sgdYp_info;
           P64[Hp] = _sgdYm::P64;
           R2 = _sgdYl::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = _sgdYo::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.83149892 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose1_closure" {
     Data.Functor.Compose.$fApplicativeCompose1_closure:
         const Data.Functor.Compose.$fApplicativeCompose1_info;
 },
 sat_sgdYy_entry() //  [R1]
         { info_tbl: [(cgfrd,
                       label: sat_sgdYy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfrd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfre; else goto cgfrf;
       cgfre: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfrf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose1_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgfrg,
                       label: Data.Functor.Compose.$fApplicativeCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfrg: // global
           _sgdYx::P64 = R5;
           _sgdYw::P64 = R4;
           _sgdYv::P64 = R3;
           _sgdYu::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfrh; else goto cgfri;
       cgfri: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfrk; else goto cgfrj;
       cgfrk: // global
           HpAlloc = 24;
           goto cgfrh;
       cgfrh: // global
           R5 = _sgdYx::P64;
           R4 = _sgdYw::P64;
           R3 = _sgdYv::P64;
           R2 = _sgdYu::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfrj: // global
           I64[Hp - 16] = sat_sgdYy_info;
           P64[Hp] = _sgdYv::P64;
           R2 = _sgdYu::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdYw::P64;
           P64[Sp - 8] = _sgdYx::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.833730324 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_closure" {
     Data.Functor.Compose.$fApplicativeCompose_closure:
         const Data.Functor.Compose.$fApplicativeCompose_info;
 },
 sat_sgdYG_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfru,
                       label: sat_sgdYG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfru: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose1_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYF_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfrC,
                       label: sat_sgdYF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfrC: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfrK,
                       label: sat_sgdYE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfrK: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fApplicativeCompose4_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYD_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfrS,
                       label: sat_sgdYD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfrS: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose5_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYC_entry() //  [R1, R2]
         { info_tbl: [(cgfs0,
                       label: sat_sgdYC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfs0: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fApplicativeCompose6_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYB_entry() //  [R1]
         { info_tbl: [(cgfs7,
                       label: sat_sgdYB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfs7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfs8; else goto cgfs9;
       cgfs8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfs9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cgfsb,
                       label: Data.Functor.Compose.$fApplicativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfsb: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cgfsf; else goto cgfse;
       cgfsf: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfse: // global
           I64[Hp - 200] = sat_sgdYG_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgdYF_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgdYE_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgdYD_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sgdYC_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgdYB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.836215624 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info;
 },
 sat_sgdYJ_entry() //  [R1]
         { info_tbl: [(cgfso,
                       label: sat_sgdYJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfso: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfsp; else goto cgfsq;
       cgfsp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfsq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgfsr,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfsr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfsv; else goto cgfsu;
       cgfsv: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfsu: // global
           I64[Hp - 16] = sat_sgdYJ_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.838315198 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$csome_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$csome_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$csome_info;
 },
 sat_sgdYQ_entry() //  [R1]
         { info_tbl: [(cgfsU,
                       label: sat_sgdYQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfsU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfsV; else goto cgfsW;
       cgfsV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfsW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYR_entry() //  [R1]
         { info_tbl: [(cgfsX,
                       label: sat_sgdYR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfsX: // global
           _sgdYR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfsY; else goto cgfsZ;
       cgfsZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgft1; else goto cgft0;
       cgft1: // global
           HpAlloc = 24;
           goto cgfsY;
       cgfsY: // global
           R1 = _sgdYR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgft0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYR::P64;
           _sgdYL::P64 = P64[_sgdYR::P64 + 16];
           _sgdYO::P64 = P64[_sgdYR::P64 + 24];
           I64[Hp - 16] = sat_sgdYQ_info;
           P64[Hp] = _sgdYL::P64;
           R2 = _sgdYO::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYS_entry() //  [R1]
         { info_tbl: [(cgft2,
                       label: sat_sgdYS_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgft2: // global
           _sgdYS::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgft3; else goto cgft4;
       cgft4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgft6; else goto cgft5;
       cgft6: // global
           HpAlloc = 32;
           goto cgft3;
       cgft3: // global
           R1 = _sgdYS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgft5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYS::P64;
           _sgdYK::P64 = P64[_sgdYS::P64 + 16];
           _sgdYL::P64 = P64[_sgdYS::P64 + 24];
           _sgdYN::P64 = P64[_sgdYS::P64 + 32];
           _sgdYO::P64 = P64[_sgdYS::P64 + 40];
           I64[Hp - 24] = sat_sgdYR_info;
           P64[Hp - 8] = _sgdYL::P64;
           P64[Hp] = _sgdYO::P64;
           R2 = _sgdYK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgdYN::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdYP_entry() //  [R1]
         { info_tbl: [(cgftb,
                       label: sat_sgdYP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgftb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgftc; else goto cgftd;
       cgftc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgftd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sgdYN_entry() //  [R1]
         { info_tbl: [(cgfte,
                       label: some_v_sgdYN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfte: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgftf; else goto cgftg;
       cgftf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgftg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgfsE_info;
           _sgdYK::P64 = P64[R1 + 16];
           R2 = _sgdYK::P64;
           P64[Sp - 48] = _sgdYK::P64;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 56;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgfsE() //  [R1]
         { info_tbl: [(cgfsE,
                       label: block_cgfsE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfsE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgftj; else goto cgfti;
       cgftj: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgfti: // global
           I64[Hp - 64] = sat_sgdYS_info;
           P64[Hp - 48] = P64[Sp + 8];
           _sgdYL::P64 = P64[Sp + 16];
           P64[Hp - 40] = _sgdYL::P64;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sgdYP_info;
           P64[Hp] = _sgdYL::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgftk,
                       label: Data.Functor.Compose.$fAlternativeCompose_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgftk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfto; else goto cgftn;
       cgfto: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgftn: // global
           I64[Hp - 32] = some_v_sgdYN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.842061199 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cmany_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cmany_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cmany_info;
 },
 $dApplicative1_sgdYX_entry() //  [R1]
         { info_tbl: [(cgftB,
                       label: $dApplicative1_sgdYX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgftB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgftC; else goto cgftD;
       cgftC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgftD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ0_entry() //  [R1]
         { info_tbl: [(cgftM,
                       label: sat_sgdZ0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgftM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgftN; else goto cgftO;
       cgftN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgftO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdZ1_entry() //  [R1]
         { info_tbl: [(cgftP,
                       label: sat_sgdZ1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgftP: // global
           _sgdZ1::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgftQ; else goto cgftR;
       cgftR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgftT; else goto cgftS;
       cgftT: // global
           HpAlloc = 24;
           goto cgftQ;
       cgftQ: // global
           R1 = _sgdZ1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgftS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdZ1::P64;
           _sgdYU::P64 = P64[_sgdZ1::P64 + 16];
           _sgdYX::P64 = P64[_sgdZ1::P64 + 24];
           I64[Hp - 16] = sat_sgdZ0_info;
           P64[Hp] = _sgdYU::P64;
           R2 = _sgdYX::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYY_entry() //  [R1]
         { info_tbl: [(cgfu2,
                       label: sat_sgdYY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfu2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfu3; else goto cgfu4;
       cgfu3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfu4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYZ_entry() //  [R1]
         { info_tbl: [(cgfu5,
                       label: sat_sgdYZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfu5: // global
           _sgdYZ::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfu6; else goto cgfu7;
       cgfu7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfu9; else goto cgfu8;
       cgfu9: // global
           HpAlloc = 24;
           goto cgfu6;
       cgfu6: // global
           R1 = _sgdYZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfu8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYZ::P64;
           _sgdYU::P64 = P64[_sgdYZ::P64 + 16];
           _sgdYV::P64 = P64[_sgdYZ::P64 + 24];
           _sgdYW::P64 = P64[_sgdYZ::P64 + 32];
           _sgdYX::P64 = P64[_sgdYZ::P64 + 40];
           I64[Hp - 16] = sat_sgdYY_info;
           P64[Hp] = _sgdYU::P64;
           R2 = _sgdYX::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgdYV::P64;
           P64[Sp - 24] = _sgdYW::P64;
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_sgdYW_entry() //  [R1]
         { info_tbl: [(cgfua,
                       label: many_v_sgdYW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfua: // global
           _sgdYW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfub; else goto cgfuc;
       cgfuc: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgfue; else goto cgfud;
       cgfue: // global
           HpAlloc = 104;
           goto cgfub;
       cgfub: // global
           R1 = _sgdYW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfud: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYW::P64;
           _sgdYT::P64 = P64[_sgdYW::P64 + 16];
           _sgdYU::P64 = P64[_sgdYW::P64 + 24];
           _sgdYV::P64 = P64[_sgdYW::P64 + 32];
           I64[Hp - 96] = $dApplicative1_sgdYX_info;
           P64[Hp - 80] = _sgdYT::P64;
           I64[Hp - 72] = sat_sgdZ1_info;
           P64[Hp - 56] = _sgdYU::P64;
           _cgftx::P64 = Hp - 96;
           P64[Hp - 48] = _cgftx::P64;
           I64[Hp - 40] = sat_sgdYZ_info;
           P64[Hp - 24] = _sgdYU::P64;
           P64[Hp - 16] = _sgdYV::P64;
           P64[Hp - 8] = _sgdYW::P64;
           P64[Hp] = _cgftx::P64;
           R2 = _sgdYT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cmany_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgfuf,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfuf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfuj; else goto cgfui;
       cgfuj: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfui: // global
           I64[Hp - 32] = many_v_sgdYW_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.845938687 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_closure" {
     Data.Functor.Compose.$fAlternativeCompose_closure:
         const Data.Functor.Compose.$fAlternativeCompose_info;
 },
 sat_sgdZ8_entry() //  [R1, R2]
         { info_tbl: [(cgfut,
                       label: sat_sgdZ8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfut: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$cmany_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZ7_entry() //  [R1, R2]
         { info_tbl: [(cgfuB,
                       label: sat_sgdZ7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfuB: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZ6_entry() //  [R1]
         { info_tbl: [(cgfuI,
                       label: sat_sgdZ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfuI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfuJ; else goto cgfuK;
       cgfuJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfuK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ5_entry() //  [R1]
         { info_tbl: [(cgfuP,
                       label: sat_sgdZ5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfuQ; else goto cgfuR;
       cgfuQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfuR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ4_entry() //  [R1]
         { info_tbl: [(cgfuW,
                       label: sat_sgdZ4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfuW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfuX; else goto cgfuY;
       cgfuX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfuY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cgfv0,
                       label: Data.Functor.Compose.$fAlternativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfv0: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgfv4; else goto cgfv3;
       cgfv4: // global
           HpAlloc = 176;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfv3: // global
           I64[Hp - 168] = sat_sgdZ8_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           I64[Hp - 144] = sat_sgdZ7_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sgdZ6_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sgdZ5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgdZ4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 120;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = Hp - 167;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.848082401 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose1_closure" {
     Data.Functor.Compose.$fGeneric1Compose1_closure:
         const Data.Functor.Compose.$fGeneric1Compose1_info;
 },
 Data.Functor.Compose.$fGeneric1Compose1_entry() //  [R2, R3]
         { info_tbl: [(cgfv9,
                       label: Data.Functor.Compose.$fGeneric1Compose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfv9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfva; else goto cgfvb;
       cgfva: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfvb: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Generics.$fGeneric1:.:2_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.849053531 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose3_closure" {
     Data.Functor.Compose.$fGeneric1Compose3_closure:
         const Data.Functor.Compose.$fGeneric1Compose3_info;
 },
 Data.Functor.Compose.$fGeneric1Compose3_entry() //  [R2]
         { info_tbl: [(cgfvg,
                       label: Data.Functor.Compose.$fGeneric1Compose3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfvg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.849931545 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose2_closure" {
     Data.Functor.Compose.$fGeneric1Compose2_closure:
         const Data.Functor.Compose.$fGeneric1Compose2_info;
 },
 Data.Functor.Compose.$fGeneric1Compose2_entry() //  [R2, R3]
         { info_tbl: [(cgfvn,
                       label: Data.Functor.Compose.$fGeneric1Compose2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfvn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfvo; else goto cgfvp;
       cgfvo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfvp: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Data.Functor.Compose.$fGeneric1Compose3_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.851182827 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose_closure" {
     Data.Functor.Compose.$fGeneric1Compose_closure:
         const Data.Functor.Compose.$fGeneric1Compose_info;
 },
 sat_sgdZg_entry() //  [R1, R2]
         { info_tbl: [(cgfvz,
                       label: sat_sgdZg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfvz: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZf_entry() //  [R1, R2]
         { info_tbl: [(cgfvH,
                       label: sat_sgdZf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfvH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose2_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fGeneric1Compose_entry() //  [R2]
         { info_tbl: [(cgfvL,
                       label: Data.Functor.Compose.$fGeneric1Compose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfvL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfvP; else goto cgfvO;
       cgfvP: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfvO: // global
           I64[Hp - 48] = sat_sgdZg_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sgdZf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Generics.C:Generic1_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.852462939 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose1_closure" {
     Data.Functor.Compose.$fGenericCompose1_closure:
         const Data.Functor.Compose.$fGenericCompose1_info;
 },
 Data.Functor.Compose.$fGenericCompose1_entry() //  [R2]
         { info_tbl: [(cgfvU,
                       label: Data.Functor.Compose.$fGenericCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfvU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.853296615 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose2_closure" {
     Data.Functor.Compose.$fGenericCompose2_closure:
         const Data.Functor.Compose.$fGenericCompose2_info;
 },
 Data.Functor.Compose.$fGenericCompose2_entry() //  [R2]
         { info_tbl: [(cgfw1,
                       label: Data.Functor.Compose.$fGenericCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfw1: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.853990615 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose_closure" {
     Data.Functor.Compose.$fGenericCompose_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Compose.$fGenericCompose2_closure+1;
         const Data.Functor.Compose.$fGenericCompose1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.854705336 UTC

[section ""data" . Data.Functor.Compose.getCompose1_closure" {
     Data.Functor.Compose.getCompose1_closure:
         const Data.Functor.Compose.getCompose1_info;
 },
 Data.Functor.Compose.getCompose1_entry() //  [R2]
         { info_tbl: [(cgfw8,
                       label: Data.Functor.Compose.getCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfw8: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.855492363 UTC

[section ""data" . Data.Functor.Compose.getCompose_closure" {
     Data.Functor.Compose.getCompose_closure:
         const Data.Functor.Compose.getCompose_info;
 },
 Data.Functor.Compose.getCompose_entry() //  [R2]
         { info_tbl: [(cgfwf,
                       label: Data.Functor.Compose.getCompose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwf: // global
           R2 = R2;
           call Data.Functor.Compose.getCompose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.856148201 UTC

[section ""cstring" . $cCompose1_rgdPU_bytes" {
     $cCompose1_rgdPU_bytes:
         I8[] [103,101,116,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.856875001 UTC

[section ""data" . $cCompose2_rgdPV_closure" {
     $cCompose2_rgdPV_closure:
         const $cCompose2_rgdPV_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose2_rgdPV_entry() //  [R1]
         { info_tbl: [(cgfwo,
                       label: $cCompose2_rgdPV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfwp; else goto cgfwq;
       cgfwp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfwq: // global
           (_cgfwl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfwl::I64 == 0) goto cgfwn; else goto cgfwm;
       cgfwn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfwm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfwl::I64;
           R2 = $cCompose1_rgdPU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.857904569 UTC

[section ""data" . $cCompose3_rgdPW_closure" {
     $cCompose3_rgdPW_closure:
         const :_con_info;
         const $cCompose2_rgdPV_closure;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.859262898 UTC

[section ""data" . go61_rgdPX_closure" {
     go61_rgdPX_closure:
         const go61_rgdPX_info;
         const 0;
 },
 go61_rgdPX_entry() //  [R2, R3]
         { info_tbl: [(cgfwC,
                       label: go61_rgdPX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfwD; else goto ugfxg;
       cgfwD: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgdPX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugfxg: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgfws() args: 0, res: 0, upd: 0;
     }
 },
 _cgfws() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfws: // global
           _sgdZk::P64 = P64[Sp];
           I64[Sp] = block_cgfwv_info;
           R1 = _sgdZk::P64;
           if (R1 & 7 != 0) goto ugfxk; else goto cgfww;
       ugfxk: // global
           call _cgfwv(R1) args: 0, res: 0, upd: 0;
       cgfww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfwv() //  [R1]
         { info_tbl: [(cgfwv,
                       label: block_cgfwv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwv: // global
           if (R1 & 7 == 1) goto ugfxh; else goto cgfwA;
       ugfxh: // global
           Sp = Sp + 16;
           call _cgfwS() args: 0, res: 0, upd: 0;
       cgfwA: // global
           I64[Sp - 8] = block_cgfwK_info;
           _sgdZn::P64 = P64[R1 + 6];
           _sgdZo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgdZo::P64;
           P64[Sp + 8] = _sgdZn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugfxl; else goto cgfwM;
       ugfxl: // global
           call _cgfwK(R1) args: 0, res: 0, upd: 0;
       cgfwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfwK() //  [R1]
         { info_tbl: [(cgfwK,
                       label: block_cgfwK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwK: // global
           if (R1 & 7 == 1) goto ugfxi; else goto cgfwX;
       ugfxi: // global
           Sp = Sp + 24;
           call _cgfwS() args: 0, res: 0, upd: 0;
       cgfwX: // global
           I64[Sp - 8] = block_cgfwV_info;
           _sgdZq::P64 = P64[R1 + 6];
           _sgdZr::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgdZr::P64;
           P64[Sp + 16] = _sgdZq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugfxo; else goto cgfwY;
       ugfxo: // global
           call _cgfwV(R1) args: 0, res: 0, upd: 0;
       cgfwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfwS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwS: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgfwV() //  [R1]
         { info_tbl: [(cgfwV,
                       label: block_cgfwV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfwV: // global
           I64[Sp] = block_cgfx2_info;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfx2() //  [R1]
         { info_tbl: [(cgfx2,
                       label: block_cgfx2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfx2: // global
           if (R1 & 7 == 1) goto cgfx9; else goto cgfxd;
       cgfx9: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgfws() args: 0, res: 0, upd: 0;
       cgfxd: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.861494532 UTC

[section ""data" . $cCompose4_rgdPY_closure" {
     $cCompose4_rgdPY_closure:
         const Data.Data.AlgConstr_con_info;
         const $cCompose5_rgdPZ_closure;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose5_closure" {
     Data.Functor.Compose.$fDataCompose5_closure:
         const :_con_info;
         const Data.Functor.Compose.$cCompose_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose4_closure" {
     Data.Functor.Compose.$fDataCompose4_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Compose.$fDataCompose5_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$tCompose_closure" {
     Data.Functor.Compose.$tCompose_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$fDataCompose4_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$cCompose_closure" {
     Data.Functor.Compose.$cCompose_closure:
         const Data.Data.Constr_con_info;
         const $cCompose4_rgdPY_closure+1;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const $cCompose3_rgdPW_closure+2;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Compose.$tCompose_closure+1;
         const 0;
 },
 section ""data" . $cCompose5_rgdPZ_closure" {
     $cCompose5_rgdPZ_closure:
         const $cCompose5_rgdPZ_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose5_rgdPZ_entry() //  [R1]
         { info_tbl: [(cgfxx,
                       label: $cCompose5_rgdPZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfxx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfxy; else goto cgfxz;
       cgfxy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfxz: // global
           (_cgfxu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfxu::I64 == 0) goto cgfxw; else goto cgfxv;
       cgfxw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfxv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfxu::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Compose.$fDataCompose5_closure+2;
           Sp = Sp - 16;
           call go61_rgdPX_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.862679997 UTC

[section ""cstring" . Data.Functor.Compose.$trModule4_bytes" {
     Data.Functor.Compose.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.863244166 UTC

[section ""data" . Data.Functor.Compose.$trModule3_closure" {
     Data.Functor.Compose.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.863811122 UTC

[section ""cstring" . Data.Functor.Compose.$trModule2_bytes" {
     Data.Functor.Compose.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.864375377 UTC

[section ""data" . Data.Functor.Compose.$trModule1_closure" {
     Data.Functor.Compose.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.864936621 UTC

[section ""data" . Data.Functor.Compose.$trModule_closure" {
     Data.Functor.Compose.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Compose.$trModule3_closure+1;
         const Data.Functor.Compose.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.865589009 UTC

[section ""data" . $krep_rgdQ0_closure" {
     $krep_rgdQ0_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.866189849 UTC

[section ""data" . $krep1_rgdQ1_closure" {
     $krep1_rgdQ1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.866762155 UTC

[section ""data" . $krep2_rgdQ2_closure" {
     $krep2_rgdQ2_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.8673161 UTC

[section ""data" . $krep3_rgdQ3_closure" {
     $krep3_rgdQ3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgdQ2_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.86785094 UTC

[section ""data" . $krep4_rgdQ4_closure" {
     $krep4_rgdQ4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep2_rgdQ2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.868397825 UTC

[section ""data" . $krep5_rgdQ5_closure" {
     $krep5_rgdQ5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rgdQ4_closure+4;
         const $krep1_rgdQ1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.868993477 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose9_closure" {
     Data.Functor.Compose.$fDataCompose9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgdQ3_closure+4;
         const $krep5_rgdQ5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.869881835 UTC

[section ""data" . $krep6_rgdQ6_closure" {
     $krep6_rgdQ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.870422017 UTC

[section ""data" . $krep7_rgdQ7_closure" {
     $krep7_rgdQ7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.87098204 UTC

[section ""data" . $krep8_rgdQ8_closure" {
     $krep8_rgdQ8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.871521394 UTC

[section ""data" . $krep9_rgdQ9_closure" {
     $krep9_rgdQ9_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep8_rgdQ8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.872105182 UTC

[section ""data" . $krep10_rgdQa_closure" {
     $krep10_rgdQa_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep9_rgdQ9_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.872699401 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose10_closure" {
     Data.Functor.Compose.$fDataCompose10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$fDataCompose7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.873288191 UTC

[section ""data" . Data.Functor.Compose.$tcCompose_closure" {
     Data.Functor.Compose.$tcCompose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$fDataCompose10_closure+1;
         const Data.Functor.Compose.$fDataCompose9_closure+4;
         const 6729400645769595507;
         const 7487202375031942550;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.875820493 UTC

[section ""data" . $krep11_rgdQb_closure" {
     $krep11_rgdQb_closure:
         const :_con_info;
         const $krep8_rgdQ8_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.87642431 UTC

[section ""data" . $krep12_rgdQc_closure" {
     $krep12_rgdQc_closure:
         const :_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep11_rgdQb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.877009927 UTC

[section ""data" . $krep13_rgdQd_closure" {
     $krep13_rgdQd_closure:
         const :_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep12_rgdQc_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.877620492 UTC

[section ""data" . $krep14_rgdQe_closure" {
     $krep14_rgdQe_closure:
         const :_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep13_rgdQd_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.878192821 UTC

[section ""data" . $krep15_rgdQf_closure" {
     $krep15_rgdQf_closure:
         const :_con_info;
         const $krep2_rgdQ2_closure+2;
         const $krep14_rgdQe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.878741231 UTC

[section ""data" . $krep16_rgdQg_closure" {
     $krep16_rgdQg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Compose.$tcCompose_closure+1;
         const $krep15_rgdQf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.879295737 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose1_closure" {
     Data.Functor.Compose.$tc'Compose1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rgdQa_closure+3;
         const $krep16_rgdQg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.879854313 UTC

[section ""cstring" . Data.Functor.Compose.$tc'Compose3_bytes" {
     Data.Functor.Compose.$tc'Compose3_bytes:
         I8[] [39,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.880427318 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose2_closure" {
     Data.Functor.Compose.$tc'Compose2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$tc'Compose3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.880999652 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose_closure" {
     Data.Functor.Compose.$tc'Compose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$tc'Compose2_closure+1;
         const Data.Functor.Compose.$tc'Compose1_closure+4;
         const 7236514282653524344;
         const 13791541438620948974;
         const 5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.882380283 UTC

[section ""data" . Data.Functor.Compose.$w$cp1Data_closure" {
     Data.Functor.Compose.$w$cp1Data_closure:
         const Data.Functor.Compose.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Compose.$w$cp1Data_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgfxP,
                       label: Data.Functor.Compose.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfxP: // global
           _sgdZD::P64 = R6;
           _sgdZC::P64 = R5;
           _sgdZB::P64 = R4;
           _sgdZA::P64 = R3;
           _sgdZz::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cgfxT; else goto cgfxU;
       cgfxU: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgfxW; else goto cgfxV;
       cgfxW: // global
           HpAlloc = 80;
           goto cgfxT;
       cgfxT: // global
           R6 = _sgdZD::P64;
           R5 = _sgdZC::P64;
           R4 = _sgdZB::P64;
           R3 = _sgdZA::P64;
           R2 = _sgdZz::P64;
           R1 = Data.Functor.Compose.$w$cp1Data_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfxV: // global
           I64[Hp - 72] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 64] = _sgdZD::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sgdZC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           I64[Sp - 32] = block_cgfxI_info;
           R6 = 2;
           R5 = Data.Functor.Compose.$fDataCompose10_closure+1;
           R4 = Data.Functor.Compose.$trModule_closure+1;
           R3 = 7487202375031942550;
           R2 = 6729400645769595507;
           P64[Sp - 48] = Data.Functor.Compose.$fDataCompose9_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sgdZz::P64;
           P64[Sp - 16] = _sgdZA::P64;
           P64[Sp - 8] = _sgdZB::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgfxI() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgfxI,
                       label: block_cgfxI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfxI: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgfxJ() args: 0, res: 0, upd: 0;
     }
 },
 _cgfxJ() //  []
         { info_tbl: [(cgfxJ,
                       label: block_cgfxJ_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfxJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgfxZ; else goto cgfxY;
       cgfxZ: // global
           HpAlloc = 48;
           I64[Sp] = block_cgfxJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cgfxY: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cgfxN_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfxN() //  [R1]
         { info_tbl: [(cgfxN,
                       label: block_cgfxN_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfxN: // global
           I64[Sp] = block_cgfxS_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfxS() //  [R1]
         { info_tbl: [(cgfxS,
                       label: block_cgfxS_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfxS: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.884493784 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose8_closure" {
     Data.Functor.Compose.$fDataCompose8_closure:
         const Data.Functor.Compose.$fDataCompose8_info;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose8_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgfyb,
                       label: Data.Functor.Compose.$fDataCompose8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.88573455 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose2_closure" {
     Data.Functor.Compose.$fDataCompose2_closure:
         const Data.Functor.Compose.$fDataCompose2_info;
 },
 Data.Functor.Compose.$fDataCompose2_entry() //  [R2]
         { info_tbl: [(cgfyi,
                       label: Data.Functor.Compose.$fDataCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyi: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.886390968 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose1_closure" {
     Data.Functor.Compose.$fDataCompose1_closure:
         const (,)_con_info;
         const Data.Functor.Compose.$fDataCompose2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.889008655 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMp_closure" {
     Data.Functor.Compose.$w$cgmapMp_closure:
         const Data.Functor.Compose.$w$cgmapMp_info;
 },
 lvl8_sge02_entry() //  [R1]
         { info_tbl: [(cgfyt,
                       label: lvl8_sge02_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfyu; else goto cgfyv;
       cgfyu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfyv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge0p_entry() //  [R1, R2]
         { info_tbl: [(cgfyI,
                       label: sat_sge0p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfyJ; else goto cgfyK;
       cgfyJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfyK: // global
           I64[Sp - 24] = block_cgfyF_info;
           _sge02::P64 = P64[R1 + 7];
           _sge03::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sge02::P64;
           P64[Sp - 8] = _sge03::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugfz2; else goto cgfyG;
       ugfz2: // global
           call _cgfyF(R1) args: 0, res: 0, upd: 0;
       cgfyG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfyF() //  [R1]
         { info_tbl: [(cgfyF,
                       label: block_cgfyF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyF: // global
           I64[Sp - 8] = block_cgfyN_info;
           _sge0m::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge0m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugfz1; else goto cgfyP;
       ugfz1: // global
           call _cgfyN(R1) args: 0, res: 0, upd: 0;
       cgfyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfyN() //  [R1]
         { info_tbl: [(cgfyN,
                       label: block_cgfyN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyN: // global
           if (R1 & 7 == 1) goto cgfyV; else goto cgfyZ;
       cgfyV: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfyZ: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0h_entry() //  [R1]
         { info_tbl: [(cgfzo,
                       label: sat_sge0h_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfzo: // global
           _sge0h::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfzp; else goto cgfzq;
       cgfzq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfzs; else goto cgfzr;
       cgfzs: // global
           HpAlloc = 56;
           goto cgfzp;
       cgfzp: // global
           R1 = _sge0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfzr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0h::P64;
           _sge01::P64 = P64[_sge0h::P64 + 16];
           _sge03::P64 = P64[_sge0h::P64 + 24];
           _sge08::P64 = P64[_sge0h::P64 + 32];
           _sge09::P64 = P64[_sge0h::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge08::P64;
           P64[Hp - 24] = _sge01::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sge09::P64;
           R2 = _sge03::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge0d_entry() //  [R1, R2]
         { info_tbl: [(cgfzE,
                       label: sat_sge0d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfzE: // global
           _sge0a::P64 = R2;
           _sge0d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfzF; else goto cgfzG;
       cgfzG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfzI; else goto cgfzH;
       cgfzI: // global
           HpAlloc = 56;
           goto cgfzF;
       cgfzF: // global
           R2 = _sge0a::P64;
           R1 = _sge0d::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfzH: // global
           _sge03::P64 = P64[_sge0d::P64 + 7];
           _sge08::P64 = P64[_sge0d::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge08::P64;
           P64[Hp - 24] = _sge0a::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge03::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0e_entry() //  [R1]
         { info_tbl: [(cgfzJ,
                       label: sat_sge0e_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfzJ: // global
           _sge0e::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfzK; else goto cgfzL;
       cgfzL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfzN; else goto cgfzM;
       cgfzN: // global
           HpAlloc = 24;
           goto cgfzK;
       cgfzK: // global
           R1 = _sge0e::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfzM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0e::P64;
           _sge03::P64 = P64[_sge0e::P64 + 16];
           _sge04::P64 = P64[_sge0e::P64 + 24];
           _sge08::P64 = P64[_sge0e::P64 + 32];
           I64[Hp - 16] = sat_sge0d_info;
           P64[Hp - 8] = _sge03::P64;
           P64[Hp] = _sge08::P64;
           R2 = _sge03::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sge04::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sge0i_entry() //  [R1, R2]
         { info_tbl: [(cgfzO,
                       label: sat_sge0i_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfzO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfzP; else goto cgfzQ;
       cgfzP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfzQ: // global
           I64[Sp - 40] = block_cgfzd_info;
           _sgdZZ::P64 = P64[R1 + 7];
           _sge01::P64 = P64[R1 + 15];
           _sge03::P64 = P64[R1 + 23];
           _sge04::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgdZZ::P64;
           P64[Sp - 24] = _sge01::P64;
           P64[Sp - 16] = _sge03::P64;
           P64[Sp - 8] = _sge04::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugfzU; else goto cgfze;
       ugfzU: // global
           call _cgfzd(R1) args: 0, res: 0, upd: 0;
       cgfze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfzd() //  [R1]
         { info_tbl: [(cgfzd,
                       label: block_cgfzd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfzd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfzT; else goto cgfzS;
       cgfzT: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfzS: // global
           _sge08::P64 = P64[R1 + 7];
           _sge09::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sge0h_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sge03::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sge03::P64;
           P64[Hp - 48] = _sge08::P64;
           P64[Hp - 40] = _sge09::P64;
           I64[Hp - 32] = sat_sge0e_info;
           P64[Hp - 16] = _sge03::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sge08::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sge05_entry() //  [R1]
         { info_tbl: [(cgfzZ,
                       label: sat_sge05_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfzZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfA0; else goto cgfA1;
       cgfA0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfA1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge0j_entry() //  [R1]
         { info_tbl: [(cgfA2,
                       label: sat_sge0j_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfA2: // global
           _sge0j::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfA3; else goto cgfA4;
       cgfA4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgfA6; else goto cgfA5;
       cgfA6: // global
           HpAlloc = 104;
           goto cgfA3;
       cgfA3: // global
           R1 = _sge0j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfA5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0j::P64;
           _sgdZY::P64 = P64[_sge0j::P64 + 16];
           _sgdZZ::P64 = P64[_sge0j::P64 + 24];
           _sge00::P64 = P64[_sge0j::P64 + 32];
           _sge01::P64 = P64[_sge0j::P64 + 40];
           _sge03::P64 = P64[_sge0j::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sge00::P64;
           P64[Hp - 72] = _sgdZY::P64;
           P64[Hp - 64] = _sge01::P64;
           I64[Hp - 56] = sat_sge0i_info;
           P64[Hp - 48] = _sgdZZ::P64;
           P64[Hp - 40] = _sge01::P64;
           P64[Hp - 32] = _sge03::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sge05_info;
           P64[Hp] = _sge03::P64;
           R2 = _sge03::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgfA7,
                       label: Data.Functor.Compose.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfA7: // global
           _sge01::P64 = R5;
           _sge00::P64 = R4;
           _sgdZZ::P64 = R3;
           _sgdZY::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfA8; else goto cgfA9;
       cgfA9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfAb; else goto cgfAa;
       cgfAb: // global
           HpAlloc = 24;
           goto cgfA8;
       cgfA8: // global
           R5 = _sge01::P64;
           R4 = _sge00::P64;
           R3 = _sgdZZ::P64;
           R2 = _sgdZY::P64;
           R1 = Data.Functor.Compose.$w$cgmapMp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfAa: // global
           I64[Hp - 16] = lvl8_sge02_info;
           P64[Hp] = _sgdZZ::P64;
           I64[Sp - 48] = block_cgfyw_info;
           R2 = _sgdZZ::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgdZY::P64;
           P64[Sp - 24] = _sgdZZ::P64;
           P64[Sp - 16] = _sge00::P64;
           P64[Sp - 8] = _sge01::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfyw() //  [R1]
         { info_tbl: [(cgfyw,
                       label: block_cgfyw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfyw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgfAe; else goto cgfAd;
       cgfAe: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfAd: // global
           I64[Hp - 72] = sat_sge0p_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sge0j_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.894204322 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMp_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMp_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMp_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfAg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_entry() //  []
         { info_tbl: [(cgfAk,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfAk: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.895843964 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapM_closure" {
     Data.Functor.Compose.$w$cgmapM_closure:
         const Data.Functor.Compose.$w$cgmapM_info;
 },
 sat_sge0I_entry() //  [R1, R2]
         { info_tbl: [(cgfAD,
                       label: sat_sge0I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfAD: // global
           _sge0G::P64 = R2;
           _sge0I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfAE; else goto cgfAF;
       cgfAF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfAH; else goto cgfAG;
       cgfAH: // global
           HpAlloc = 32;
           goto cgfAE;
       cgfAE: // global
           R2 = _sge0G::P64;
           R1 = _sge0I::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfAG: // global
           _sge0A::P64 = P64[_sge0I::P64 + 7];
           _sge0F::P64 = P64[_sge0I::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sge0F::P64;
           P64[Hp] = _sge0G::P64;
           R2 = _sge0A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0J_entry() //  [R1, R2]
         { info_tbl: [(cgfAI,
                       label: sat_sge0J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfAI: // global
           _sge0F::P64 = R2;
           _sge0J::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgfAJ; else goto cgfAK;
       cgfAK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfAM; else goto cgfAL;
       cgfAM: // global
           HpAlloc = 24;
           goto cgfAJ;
       cgfAJ: // global
           R2 = _sge0F::P64;
           R1 = _sge0J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfAL: // global
           _sge0A::P64 = P64[_sge0J::P64 + 7];
           _sge0D::P64 = P64[_sge0J::P64 + 15];
           I64[Hp - 16] = sat_sge0I_info;
           P64[Hp - 8] = _sge0A::P64;
           P64[Hp] = _sge0F::P64;
           R2 = _sge0A::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sge0D::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sge0E_entry() //  [R1]
         { info_tbl: [(cgfAR,
                       label: sat_sge0E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfAR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfAS; else goto cgfAT;
       cgfAS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfAT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgfAU,
                       label: Data.Functor.Compose.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfAU: // global
           _sge0C::P64 = R5;
           _sge0B::P64 = R4;
           _sge0A::P64 = R3;
           _sge0z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgfAV; else goto cgfAW;
       cgfAW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfAY; else goto cgfAX;
       cgfAY: // global
           HpAlloc = 88;
           goto cgfAV;
       cgfAV: // global
           R5 = _sge0C::P64;
           R4 = _sge0B::P64;
           R3 = _sge0A::P64;
           R2 = _sge0z::P64;
           R1 = Data.Functor.Compose.$w$cgmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfAX: // global
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = _sge0B::P64;
           P64[Hp - 56] = _sge0z::P64;
           P64[Hp - 48] = _sge0C::P64;
           I64[Hp - 40] = sat_sge0J_info;
           P64[Hp - 32] = _sge0A::P64;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = sat_sge0E_info;
           P64[Hp] = _sge0A::P64;
           R2 = _sge0A::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.898058052 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapM_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapM_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapM_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfB0: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_entry() //  []
         { info_tbl: [(cgfB4,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfB4: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.901407042 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMo_closure" {
     Data.Functor.Compose.$w$cgmapMo_closure:
         const Data.Functor.Compose.$w$cgmapMo_info;
 },
 lvl8_sge0X_entry() //  [R1]
         { info_tbl: [(cgfBf,
                       label: lvl8_sge0X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfBf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfBg; else goto cgfBh;
       cgfBg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfBh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1n_entry() //  [R1, R2]
         { info_tbl: [(cgfBu,
                       label: sat_sge1n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfBu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfBv; else goto cgfBw;
       cgfBv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfBw: // global
           I64[Sp - 24] = block_cgfBr_info;
           _sge0X::P64 = P64[R1 + 7];
           _sge0Y::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sge0X::P64;
           P64[Sp - 8] = _sge0Y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugfBO; else goto cgfBs;
       ugfBO: // global
           call _cgfBr(R1) args: 0, res: 0, upd: 0;
       cgfBs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfBr() //  [R1]
         { info_tbl: [(cgfBr,
                       label: block_cgfBr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfBr: // global
           I64[Sp - 8] = block_cgfBz_info;
           _sge1k::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge1k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugfBN; else goto cgfBB;
       ugfBN: // global
           call _cgfBz(R1) args: 0, res: 0, upd: 0;
       cgfBB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfBz() //  [R1]
         { info_tbl: [(cgfBz,
                       label: block_cgfBz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfBz: // global
           if (R1 & 7 == 1) goto cgfBH; else goto cgfBL;
       cgfBH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfBL: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge1d_entry() //  [R1]
         { info_tbl: [(cgfCf,
                       label: sat_sge1d_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfCf: // global
           _sge1d::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfCg; else goto cgfCh;
       cgfCh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfCj; else goto cgfCi;
       cgfCj: // global
           HpAlloc = 56;
           goto cgfCg;
       cgfCg: // global
           R1 = _sge1d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfCi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1d::P64;
           _sge0W::P64 = P64[_sge1d::P64 + 16];
           _sge0Y::P64 = P64[_sge1d::P64 + 24];
           _sge13::P64 = P64[_sge1d::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge0W::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sge0Y::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge19_entry() //  [R1, R2]
         { info_tbl: [(cgfCv,
                       label: sat_sge19_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfCv: // global
           _sge16::P64 = R2;
           _sge19::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfCw; else goto cgfCx;
       cgfCx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfCz; else goto cgfCy;
       cgfCz: // global
           HpAlloc = 56;
           goto cgfCw;
       cgfCw: // global
           R2 = _sge16::P64;
           R1 = _sge19::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfCy: // global
           _sge0Y::P64 = P64[_sge19::P64 + 7];
           _sge13::P64 = P64[_sge19::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge16::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge0Y::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge1a_entry() //  [R1]
         { info_tbl: [(cgfCA,
                       label: sat_sge1a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfCA: // global
           _sge1a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfCB; else goto cgfCC;
       cgfCC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfCE; else goto cgfCD;
       cgfCE: // global
           HpAlloc = 24;
           goto cgfCB;
       cgfCB: // global
           R1 = _sge1a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfCD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1a::P64;
           _sge0Y::P64 = P64[_sge1a::P64 + 16];
           _sge0Z::P64 = P64[_sge1a::P64 + 24];
           _sge13::P64 = P64[_sge1a::P64 + 32];
           I64[Hp - 16] = sat_sge19_info;
           P64[Hp - 8] = _sge0Y::P64;
           P64[Hp] = _sge13::P64;
           R2 = _sge0Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sge0Z::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sge1g_entry() //  [R1, R2]
         { info_tbl: [(cgfCF,
                       label: sat_sge1g_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfCF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgfCG; else goto cgfCH;
       cgfCG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfCH: // global
           I64[Sp - 40] = block_cgfBZ_info;
           _sge0U::P64 = P64[R1 + 7];
           _sge0W::P64 = P64[R1 + 15];
           _sge0Y::P64 = P64[R1 + 23];
           _sge0Z::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sge0U::P64;
           P64[Sp - 24] = _sge0W::P64;
           P64[Sp - 16] = _sge0Y::P64;
           P64[Sp - 8] = _sge0Z::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugfCY; else goto cgfC0;
       ugfCY: // global
           call _cgfBZ(R1) args: 0, res: 0, upd: 0;
       cgfC0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfBZ() //  [R1]
         { info_tbl: [(cgfBZ,
                       label: block_cgfBZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfBZ: // global
           I64[Sp - 8] = block_cgfC4_info;
           _sge13::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge13::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugfCX; else goto cgfC5;
       ugfCX: // global
           call _cgfC4(R1) args: 0, res: 0, upd: 0;
       cgfC5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfC4() //  [R1]
         { info_tbl: [(cgfC4,
                       label: block_cgfC4_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfC4: // global
           _sge0W::P64 = P64[Sp + 24];
           _sge0Y::P64 = P64[Sp + 32];
           _sge13::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgfCK; else goto cgfCO;
       cgfCK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgfCN; else goto cgfCM;
       cgfCN: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfCM: // global
           I64[Hp - 72] = sat_sge1d_info;
           P64[Hp - 56] = _sge0W::P64;
           P64[Hp - 48] = _sge0Y::P64;
           P64[Hp - 40] = _sge13::P64;
           I64[Hp - 32] = sat_sge1a_info;
           P64[Hp - 16] = _sge0Y::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sge13::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgfCO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgfCT; else goto cgfCS;
       cgfCT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfCS: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge0W::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge0Y::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge10_entry() //  [R1]
         { info_tbl: [(cgfD3,
                       label: sat_sge10_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfD3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfD4; else goto cgfD5;
       cgfD4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfD5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge1h_entry() //  [R1]
         { info_tbl: [(cgfD6,
                       label: sat_sge1h_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfD6: // global
           _sge1h::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfD7; else goto cgfD8;
       cgfD8: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgfDa; else goto cgfD9;
       cgfDa: // global
           HpAlloc = 104;
           goto cgfD7;
       cgfD7: // global
           R1 = _sge1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfD9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1h::P64;
           _sge0T::P64 = P64[_sge1h::P64 + 16];
           _sge0U::P64 = P64[_sge1h::P64 + 24];
           _sge0V::P64 = P64[_sge1h::P64 + 32];
           _sge0W::P64 = P64[_sge1h::P64 + 40];
           _sge0Y::P64 = P64[_sge1h::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sge0V::P64;
           P64[Hp - 72] = _sge0T::P64;
           P64[Hp - 64] = _sge0W::P64;
           I64[Hp - 56] = sat_sge1g_info;
           P64[Hp - 48] = _sge0U::P64;
           P64[Hp - 40] = _sge0W::P64;
           P64[Hp - 32] = _sge0Y::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sge10_info;
           P64[Hp] = _sge0Y::P64;
           R2 = _sge0Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgfDb,
                       label: Data.Functor.Compose.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDb: // global
           _sge0W::P64 = R5;
           _sge0V::P64 = R4;
           _sge0U::P64 = R3;
           _sge0T::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgfDc; else goto cgfDd;
       cgfDd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfDf; else goto cgfDe;
       cgfDf: // global
           HpAlloc = 24;
           goto cgfDc;
       cgfDc: // global
           R5 = _sge0W::P64;
           R4 = _sge0V::P64;
           R3 = _sge0U::P64;
           R2 = _sge0T::P64;
           R1 = Data.Functor.Compose.$w$cgmapMo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfDe: // global
           I64[Hp - 16] = lvl8_sge0X_info;
           P64[Hp] = _sge0U::P64;
           I64[Sp - 48] = block_cgfBi_info;
           R2 = _sge0U::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sge0T::P64;
           P64[Sp - 24] = _sge0U::P64;
           P64[Sp - 16] = _sge0V::P64;
           P64[Sp - 8] = _sge0W::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfBi() //  [R1]
         { info_tbl: [(cgfBi,
                       label: block_cgfBi_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfBi: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgfDi; else goto cgfDh;
       cgfDi: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfDh: // global
           I64[Hp - 72] = sat_sge1n_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sge1h_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.906997835 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMo_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMo_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMo_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDk: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_entry() //  []
         { info_tbl: [(cgfDo,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDo: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.908070705 UTC

[section ""data" . lvl4_rgdQh_closure" {
     lvl4_rgdQh_closure:
         const lvl4_rgdQh_info;
         const 0;
 },
 lvl4_rgdQh_entry() //  []
         { info_tbl: [(cgfDv,
                       label: lvl4_rgdQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDv: // global
           R1 = Data.Functor.Compose.$cCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.908892021 UTC

[section ""data" . lvl5_rgdQi_closure" {
     lvl5_rgdQi_closure:
         const lvl5_rgdQi_info;
         const 0;
 },
 lvl5_rgdQi_entry() //  []
         { info_tbl: [(cgfDC,
                       label: lvl5_rgdQi_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDC: // global
           R1 = Data.Functor.Compose.$tCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.909720861 UTC

[section ""data" . lvl6_rgdQj_closure" {
     lvl6_rgdQj_closure:
         const lvl6_rgdQj_info;
 },
 lvl6_rgdQj_entry() //  []
         { info_tbl: [(cgfDJ,
                       label: lvl6_rgdQj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.910549931 UTC

[section ""data" . lvl7_rgdQk_closure" {
     lvl7_rgdQk_closure:
         const lvl7_rgdQk_info;
 },
 lvl7_rgdQk_entry() //  []
         { info_tbl: [(cgfDQ,
                       label: lvl7_rgdQk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfDQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.913899324 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_closure" {
     Data.Functor.Compose.$fDataCompose_closure:
         const Data.Functor.Compose.$fDataCompose_info;
         const 0;
 },
 sat_sge2v_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfE2,
                       label: sat_sge2v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfE2: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2r_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfEa,
                       label: sat_sge2r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfEa: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2n_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfEi,
                       label: sat_sge2n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfEi: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2j_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfEt,
                       label: sat_sge2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfEt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfEu; else goto cgfEv;
       cgfEu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfEv: // global
           I64[Sp - 32] = block_cgfEq_info;
           _sge1I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _sge1I::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugfED; else goto cgfEr;
       ugfED: // global
           call _cgfEq(R1) args: 0, res: 0, upd: 0;
       cgfEr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfEq() //  [R1]
         { info_tbl: [(cgfEq,
                       label: block_cgfEq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfEq: // global
           if (I64[R1 + 7] == 0) goto cgfEC; else goto cgfEB;
       cgfEC: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfEB: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2c_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfEL,
                       label: sat_sge2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfEL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgfEP; else goto cgfEO;
       cgfEP: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfEO: // global
           _sge1I::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = _sge1I::P64;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge28_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgfEW,
                       label: sat_sge28_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfEW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfF0; else goto cgfEZ;
       cgfF0: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfEZ: // global
           _sge1I::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sge1I::P64;
           P64[Hp] = R5;
           R3 = R3;
           _sge23::P64 = R2;
           R2 = Hp - 32;
           R1 = _sge23::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge22_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgfF7,
                       label: sat_sge22_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfF7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfFb; else goto cgfFa;
       cgfFb: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfFa: // global
           _sge1I::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sge1I::P64;
           P64[Hp] = R5;
           _sge1Y::P64 = R3;
           R3 = Hp - 32;
           _sge1X::P64 = R2;
           R2 = _sge1Y::P64;
           R1 = _sge1X::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1W_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfFh,
                       label: sat_sge1W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfFh: // global
           R3 = R3;
           _sge1U::P64 = R2;
           R2 = P64[R1 + 6];
           R1 = _sge1U::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1S_entry() //  [R1]
         { info_tbl: [(cgfFt,
                       label: sat_sge1S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfFu; else goto cgfFv;
       cgfFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfFw,
                       label: sat_sge1T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfFw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfFA; else goto cgfFz;
       cgfFA: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfFz: // global
           _sge1I::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sge1S_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sge1P::P64 = R2;
           R2 = _sge1I::P64;
           R1 = _sge1P::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1N_entry() //  [R1]
         { info_tbl: [(cgfFK,
                       label: sat_sge1N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfFK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfFL; else goto cgfFM;
       cgfFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfFM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1O_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfFN,
                       label: sat_sge1O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfFN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfFR; else goto cgfFQ;
       cgfFR: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfFQ: // global
           _sge1I::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sge1N_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           _sge1K::P64 = R2;
           R2 = _sge1I::P64;
           R1 = _sge1K::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1J_entry() //  [R1]
         { info_tbl: [(cgfFW,
                       label: sat_sge1J_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfFW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfFX; else goto cgfFY;
       cgfFX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfFY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fDataCompose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgfG0,
                       label: Data.Functor.Compose.$fDataCompose_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfG0: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto cgfG4; else goto cgfG3;
       cgfG4: // global
           HpAlloc = 344;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fDataCompose_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgfG3: // global
           I64[Hp - 336] = sat_sge2v_info;
           _sge1I::P64 = P64[Sp];
           P64[Hp - 328] = _sge1I::P64;
           I64[Hp - 320] = sat_sge2r_info;
           P64[Hp - 312] = _sge1I::P64;
           I64[Hp - 304] = sat_sge2n_info;
           P64[Hp - 296] = _sge1I::P64;
           I64[Hp - 288] = sat_sge2j_info;
           P64[Hp - 280] = _sge1I::P64;
           I64[Hp - 272] = sat_sge2c_info;
           P64[Hp - 264] = _sge1I::P64;
           I64[Hp - 256] = sat_sge28_info;
           P64[Hp - 248] = _sge1I::P64;
           I64[Hp - 240] = sat_sge22_info;
           P64[Hp - 232] = _sge1I::P64;
           I64[Hp - 224] = sat_sge1W_info;
           P64[Hp - 216] = _sge1I::P64;
           I64[Hp - 208] = sat_sge1T_info;
           P64[Hp - 200] = _sge1I::P64;
           I64[Hp - 192] = sat_sge1O_info;
           P64[Hp - 184] = _sge1I::P64;
           I64[Hp - 176] = sat_sge1J_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 189;
           P64[Hp - 96] = Hp - 205;
           P64[Hp - 88] = lvl4_rgdQh_closure+1;
           P64[Hp - 80] = lvl5_rgdQi_closure+1;
           P64[Hp - 72] = lvl6_rgdQj_closure+2;
           P64[Hp - 64] = lvl7_rgdQk_closure+2;
           P64[Hp - 56] = Hp - 222;
           P64[Hp - 48] = Hp - 236;
           P64[Hp - 40] = Hp - 252;
           P64[Hp - 32] = Hp - 270;
           P64[Hp - 24] = Hp - 285;
           P64[Hp - 16] = Hp - 301;
           P64[Hp - 8] = Hp - 317;
           P64[Hp] = Hp - 333;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.918765039 UTC

[section ""relreadonly" . Sge5q_srt" {
     Sge5q_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Compose.$fRead1Compose2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
         const Data.Functor.Compose.$fRead1Compose_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$w$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
         const Data.Functor.Compose.$fShow1Compose_closure;
         const Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadList_closure;
         const Data.Functor.Compose.$fReadCompose_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
         const Data.Functor.Compose.$fShowCompose_$cshow_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowList_closure;
         const Data.Functor.Compose.$fShowCompose_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Compose.$fFoldableCompose_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Compose.$fFoldableCompose2_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Compose.$fFoldableCompose3_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Compose.$fFoldableCompose_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Compose.$fFoldableCompose7_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
         const Data.Functor.Compose.$fFoldableCompose6_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$clength_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
         const Data.Functor.Compose.$fFoldableCompose8_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
         const Data.Functor.Compose.$fFoldableCompose_closure;
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
         const Data.Functor.Compose.$fTraversableCompose_closure;
         const GHC.List.badHead_closure;
         const go61_rgdPX_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Compose.$fDataCompose5_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Compose.$w$cp1Data_closure;
         const Data.Functor.Compose.$cCompose_closure;
         const Data.Functor.Compose.$tCompose_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Compose.$fDataCompose_closure;
         const lvl4_rgdQh_closure;
         const lvl5_rgdQi_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.919975339 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:06.921498494 UTC

[section ""data" . $fEq1Compose1_rgdPP_closure" {
     $fEq1Compose1_rgdPP_closure:
         const $fEq1Compose1_rgdPP_info;
 },
 $fEq1Compose1_rgdPP_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgfGa,
                       label: $fEq1Compose1_rgdPP_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfGa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfGe; else goto cgfGd;
       cgfGe: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $fEq1Compose1_rgdPP_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfGd: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgdQm::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgdQm::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.925536212 UTC

[section ""data" . Data.Functor.Compose.$fEq1Compose_closure" {
     Data.Functor.Compose.$fEq1Compose_closure:
         const Data.Functor.Compose.$fEq1Compose_info;
 },
 Data.Functor.Compose.$fEq1Compose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgfGn,
                       label: Data.Functor.Compose.$fEq1Compose_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfGn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $fEq1Compose1_rgdPP_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.930378992 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure" {
     Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure:
         const Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info;
 },
 sat_sgdQx_entry() //  [R1]
         { info_tbl: [(cgfGC,
                       label: sat_sgdQx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfGC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfGD; else goto cgfGE;
       cgfGD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfGE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgfGF,
                       label: Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfGF: // global
           _sgdQw::P64 = R6;
           _sgdQv::P64 = R5;
           _sgdQu::P64 = R4;
           _sgdQt::P64 = R3;
           _sgdQs::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfGG; else goto cgfGH;
       cgfGH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfGJ; else goto cgfGI;
       cgfGJ: // global
           HpAlloc = 32;
           goto cgfGG;
       cgfGG: // global
           R6 = _sgdQw::P64;
           R5 = _sgdQv::P64;
           R4 = _sgdQu::P64;
           R3 = _sgdQt::P64;
           R2 = _sgdQs::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfGI: // global
           I64[Hp - 24] = sat_sgdQx_info;
           P64[Hp - 8] = _sgdQt::P64;
           P64[Hp] = _sgdQu::P64;
           R2 = _sgdQs::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdQv::P64;
           P64[Sp - 8] = _sgdQw::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.939175569 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose1_closure" {
     Data.Functor.Compose.$fOrd1Compose1_closure:
         const Data.Functor.Compose.$fOrd1Compose1_info;
 },
 sat_sgdQD_entry() //  [R1]
         { info_tbl: [(cgfH3,
                       label: sat_sgdQD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfH3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgfH4; else goto cgfH5;
       cgfH4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfH5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgfH6,
                       label: Data.Functor.Compose.$fOrd1Compose1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfH6: // global
           _sgdQC::P64 = R6;
           _sgdQB::P64 = R5;
           _sgdQA::P64 = R4;
           _sgdQz::P64 = R3;
           _sgdQy::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfH7; else goto cgfH8;
       cgfH8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfHa; else goto cgfH9;
       cgfHa: // global
           HpAlloc = 32;
           goto cgfH7;
       cgfH7: // global
           R6 = _sgdQC::P64;
           R5 = _sgdQB::P64;
           R4 = _sgdQA::P64;
           R3 = _sgdQz::P64;
           R2 = _sgdQy::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfH9: // global
           I64[Hp - 24] = sat_sgdQD_info;
           P64[Hp - 8] = _sgdQz::P64;
           P64[Hp] = _sgdQA::P64;
           R2 = _sgdQy::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdQB::P64;
           P64[Sp - 8] = _sgdQC::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.94888091 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_closure" {
     Data.Functor.Compose.$fOrd1Compose_closure:
         const Data.Functor.Compose.$fOrd1Compose_info;
 },
 sat_sgdQH_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfHv,
                       label: sat_sgdQH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfHv: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdQG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgfHD,
                       label: sat_sgdQG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfHD: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_entry() //  [R2, R3]
         { info_tbl: [(cgfHH,
                       label: Data.Functor.Compose.$fOrd1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfHH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgfHL; else goto cgfHK;
       cgfHL: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrd1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfHK: // global
           I64[Hp - 64] = sat_sgdQH_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdQG_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.956059597 UTC

[section ""cstring" . Data.Functor.Compose.$fDataCompose7_bytes" {
     Data.Functor.Compose.$fDataCompose7_bytes:
         I8[] [67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.958122863 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose6_closure" {
     Data.Functor.Compose.$fDataCompose6_closure:
         const Data.Functor.Compose.$fDataCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose6_entry() //  [R1]
         { info_tbl: [(cgfI6,
                       label: Data.Functor.Compose.$fDataCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfI6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfI7; else goto cgfI8;
       cgfI7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfI8: // global
           (_cgfI3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgfI3::I64 == 0) goto cgfI5; else goto cgfI4;
       cgfI5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgfI4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgfI3::I64;
           R2 = Data.Functor.Compose.$fDataCompose7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.962050774 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose2_closure" {
     Data.Functor.Compose.$fRead1Compose2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.963793232 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose1_closure" {
     Data.Functor.Compose.$fRead1Compose1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.967268789 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info;
         const 0;
 },
 sat_sgdQO_entry() //  [R1]
         { info_tbl: [(cgfIu,
                       label: sat_sgdQO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfIu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfIv; else goto cgfIw;
       cgfIv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfIw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdQN_entry() //  [R1]
         { info_tbl: [(cgfIB,
                       label: sat_sgdQN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfIB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfIC; else goto cgfID;
       cgfIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfID: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader_sgdQM_entry() //  [R1]
         { info_tbl: [(cgfIE,
                       label: reader_sgdQM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfIE: // global
           _sgdQM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfIF; else goto cgfIG;
       cgfIG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgfII; else goto cgfIH;
       cgfII: // global
           HpAlloc = 80;
           goto cgfIF;
       cgfIF: // global
           R1 = _sgdQM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfIH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdQM::P64;
           _sgdQI::P64 = P64[_sgdQM::P64 + 16];
           _sgdQJ::P64 = P64[_sgdQM::P64 + 24];
           _sgdQK::P64 = P64[_sgdQM::P64 + 32];
           _sgdQL::P64 = P64[_sgdQM::P64 + 40];
           I64[Hp - 72] = sat_sgdQO_info;
           P64[Hp - 56] = _sgdQJ::P64;
           P64[Hp - 48] = _sgdQK::P64;
           P64[Hp - 40] = _sgdQL::P64;
           I64[Hp - 32] = sat_sgdQN_info;
           P64[Hp - 16] = _sgdQJ::P64;
           P64[Hp - 8] = _sgdQK::P64;
           P64[Hp] = _sgdQL::P64;
           R2 = _sgdQI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdQV_entry() //  [R1, R2]
         { info_tbl: [(cgfJ2,
                       label: sat_sgdQV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJ2: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdQW_entry() //  [R1, R2]
         { info_tbl: [(cgfJ5,
                       label: sat_sgdQW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJ5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfJ9; else goto cgfJ8;
       cgfJ9: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfJ8: // global
           _sgdQM::P64 = P64[R1 + 7];
           _sgdQR::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sgdQV_info;
           P64[Hp] = _sgdQR::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Compose.$fRead1Compose1_closure+1;
           R1 = _sgdQM::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sgdQP_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfJd,
                       label: $wlvl_sgdQP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJd: // global
           _sgdQR::P64 = R3;
           _sgdQQ::I64 = R2;
           _sgdQP::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgfJe; else goto cgfJf;
       cgfJf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfJh; else goto cgfJg;
       cgfJh: // global
           HpAlloc = 24;
           goto cgfJe;
       cgfJe: // global
           R3 = _sgdQR::P64;
           R2 = _sgdQQ::I64;
           R1 = _sgdQP::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfJg: // global
           if (%MO_S_Gt_W64(_sgdQQ::I64, 10)) goto cgfJb; else goto cgfJc;
       cgfJb: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgfJc: // global
           _sgdQM::P64 = P64[_sgdQP::P64 + 6];
           I64[Hp - 16] = sat_sgdQW_info;
           P64[Hp - 8] = _sgdQM::P64;
           P64[Hp] = _sgdQR::P64;
           I64[Sp - 8] = block_cgfJi_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Compose.$fRead1Compose2_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfJi() //  [R1]
         { info_tbl: [(cgfJi,
                       label: block_cgfJi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfJn; else goto cgfJm;
       cgfJn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfJm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sgdQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfJw,
                       label: lvl8_sgdQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgfJx; else goto cgfJy;
       cgfJx: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfJy: // global
           I64[Sp - 24] = block_cgfJt_info;
           _sgdQP::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sgdQP::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugfJC; else goto cgfJu;
       ugfJC: // global
           call _cgfJt(R1) args: 0, res: 0, upd: 0;
       cgfJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfJt() //  [R1]
         { info_tbl: [(cgfJt,
                       label: block_cgfJt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJt: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sgdQP_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdR6_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfJI,
                       label: sat_sgdR6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cgfJL,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfJL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgfJP; else goto cgfJO;
       cgfJP: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfJO: // global
           I64[Hp - 88] = reader_sgdQM_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = $wlvl_sgdQP_info;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sgdQZ_info;
           P64[Hp - 16] = Hp - 38;
           I64[Hp - 8] = sat_sgdR6_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:06.992736833 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info;
         const 0;
 },
 sat_sgdRh_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfKW,
                       label: sat_sgdRh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfKW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgfKX; else goto cgfKY;
       cgfKX: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfKY: // global
           I64[Sp - 8] = block_cgfKT_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgfKT() //  [R1]
         { info_tbl: [(cgfKT,
                       label: block_cgfKT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfKT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgfL1; else goto cgfL0;
       cgfL1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgfL0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRc_entry() //  [R1, R2]
         { info_tbl: [(cgfL7,
                       label: sat_sgdRc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfL7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sgdRb_entry() //  [R1]
         { info_tbl: [(cgfLa,
                       label: ds_sgdRb_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfLa: // global
           _sgdRb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfLb; else goto cgfLc;
       cgfLc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfLe; else goto cgfLd;
       cgfLe: // global
           HpAlloc = 32;
           goto cgfLb;
       cgfLb: // global
           R1 = _sgdRb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfLd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdRb::P64;
           _sgdR7::P64 = P64[_sgdRb::P64 + 16];
           _sgdR8::P64 = P64[_sgdRb::P64 + 24];
           _sgdR9::P64 = P64[_sgdRb::P64 + 32];
           _sgdRa::P64 = P64[_sgdRb::P64 + 40];
           I64[Hp - 24] = sat_sgdRh_info;
           P64[Hp - 16] = _sgdRa::P64;
           I64[Hp - 8] = sat_sgdRc_info;
           P64[Hp] = _sgdR9::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sgdR8::P64;
           R2 = _sgdR7::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRj_entry() //  [R1]
         { info_tbl: [(cgfLo,
                       label: sat_sgdRj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfLo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfLp; else goto cgfLq;
       cgfLp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfLq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRk_entry() //  [R1, R2]
         { info_tbl: [(cgfLr,
                       label: sat_sgdRk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfLr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfLv; else goto cgfLu;
       cgfLv: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfLu: // global
           _sgdRb::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgdRj_info;
           P64[Hp - 8] = _sgdRb::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cgfLw,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfLw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgfLA; else goto cgfLz;
       cgfLA: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfLz: // global
           I64[Hp - 56] = ds_sgdRb_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sgdRk_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.008422745 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info;
         const 0;
 },
 sat_sgdRp_entry() //  [R1]
         { info_tbl: [(cgfMb,
                       label: sat_sgdRp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfMb: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cgfMe,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfMe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgfMi; else goto cgfMh;
       cgfMi: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfMh: // global
           I64[Hp - 40] = sat_sgdRp_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.015130569 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_closure" {
     Data.Functor.Compose.$fRead1Compose_closure:
         const Data.Functor.Compose.$fRead1Compose_info;
         const 0;
 },
 sat_sgdRv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfMz,
                       label: sat_sgdRv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfMz: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRu_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfMH,
                       label: sat_sgdRu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfMH: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdRt_entry() //  [R1]
         { info_tbl: [(cgfMO,
                       label: sat_sgdRt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfMO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfMP; else goto cgfMQ;
       cgfMP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfMQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdRs_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfMW,
                       label: sat_sgdRs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfMW: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_entry() //  [R2, R3]
         { info_tbl: [(cgfN0,
                       label: Data.Functor.Compose.$fRead1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfN0: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgfN4; else goto cgfN3;
       cgfN4: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfN3: // global
           I64[Hp - 136] = sat_sgdRv_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgdRu_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sgdRt_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sgdRs_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_info;
         const 0;
 },
 sat_sgdRy_entry() //  [R1]
         { info_tbl: [(cgfNd,
                       label: sat_sgdRy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfNe; else goto cgfNf;
       cgfNe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cgfNg,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfNg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfNk; else goto cgfNj;
       cgfNk: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfNj: // global
           I64[Hp - 24] = sat_sgdRy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.031727492 UTC

[section ""data" . Data.Functor.Compose.$w$cliftShowsPrec_closure" {
     Data.Functor.Compose.$w$cliftShowsPrec_closure:
         const Data.Functor.Compose.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfNQ: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgdRG_entry() //  [R1]
         { info_tbl: [(cgfO2,
                       label: sat_sgdRG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfO2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfO3; else goto cgfO4;
       cgfO3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfO4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdRF_entry() //  [R1]
         { info_tbl: [(cgfO9,
                       label: sat_sgdRF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfO9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfOa; else goto cgfOb;
       cgfOa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfOb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdRH_entry() //  [R1]
         { info_tbl: [(cgfOc,
                       label: sat_sgdRH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfOc: // global
           _sgdRH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgfOd; else goto cgfOe;
       cgfOe: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgfOg; else goto cgfOf;
       cgfOg: // global
           HpAlloc = 80;
           goto cgfOd;
       cgfOd: // global
           R1 = _sgdRH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfOf: // global
           _sgdRz::P64 = P64[_sgdRH::P64 + 16];
           _sgdRA::P64 = P64[_sgdRH::P64 + 24];
           _sgdRB::P64 = P64[_sgdRH::P64 + 32];
           _sgdRC::P64 = P64[_sgdRH::P64 + 40];
           I64[Hp - 72] = sat_sgdRG_info;
           P64[Hp - 56] = _sgdRA::P64;
           P64[Hp - 48] = _sgdRB::P64;
           P64[Hp - 40] = _sgdRC::P64;
           I64[Hp - 32] = sat_sgdRF_info;
           P64[Hp - 16] = _sgdRA::P64;
           P64[Hp - 8] = _sgdRB::P64;
           P64[Hp] = _sgdRC::P64;
           R2 = _sgdRz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgfOh,
                       label: Data.Functor.Compose.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfOh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgfOl; else goto cgfOk;
       cgfOl: // global
           HpAlloc = 48;
           R1 = Data.Functor.Compose.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cgfOk: // global
           I64[Hp - 40] = sat_sgdRH_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R5 = P64[Sp];
           R4 = R6;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = Hp - 40;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.043489873 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cgfOR,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfOR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgfOS; else goto cgfOT;
       cgfOS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgfOT: // global
           I64[Sp - 40] = block_cgfOO_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugfOX; else goto cgfOP;
       ugfOX: // global
           call _cgfOO(R1) args: 0, res: 0, upd: 0;
       cgfOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfOO() //  [R1]
         { info_tbl: [(cgfOO,
                       label: block_cgfOO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfOO: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.049381749 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose3_closure" {
     Data.Functor.Compose.$fDataCompose3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.051609422 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_info;
         const 0;
 },
 sat_sgdRX_entry() //  [R1, R2]
         { info_tbl: [(cgfPh,
                       label: sat_sgdRX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfPh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgfPi; else goto cgfPj;
       cgfPi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgfPj: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgdRW::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgdRW::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cgfPk,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfPk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgfPo; else goto cgfPn;
       cgfPo: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgfPn: // global
           I64[Hp - 32] = sat_sgdRX_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.059136218 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_closure" {
     Data.Functor.Compose.$fShow1Compose_closure:
         const Data.Functor.Compose.$fShow1Compose_info;
         const 0;
 },
 sat_sgdS1_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgfPG,
                       label: sat_sgdS1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfPG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgfPH; else goto cgfPI;
       cgfPH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfPI: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgdS0_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgfPO,
                       label: sat_sgdS0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfPO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgfPP; else goto cgfPQ;
       cgfPP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfPQ: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_entry() //  [R2, R3]
         { info_tbl: [(cgfPS,
                       label: Data.Functor.Compose.$fShow1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfPS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgfPW; else goto cgfPV;
       cgfPW: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfPV: // global
           I64[Hp - 64] = sat_sgdS1_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdS0_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.067641139 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c==_closure" {
     Data.Functor.Compose.$fEqCompose_$c==_closure:
         const Data.Functor.Compose.$fEqCompose_$c==_info;
 },
 sat_sgdS7_entry() //  [R1]
         { info_tbl: [(cgfQo,
                       label: sat_sgdS7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfQo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfQp; else goto cgfQq;
       cgfQp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfQq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdS8_entry() //  [R1]
         { info_tbl: [(cgfQr,
                       label: sat_sgdS8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfQr: // global
           _sgdS8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfQs; else goto cgfQt;
       cgfQt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfQv; else goto cgfQu;
       cgfQv: // global
           HpAlloc = 24;
           goto cgfQs;
       cgfQs: // global
           R1 = _sgdS8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdS8::P64;
           _sgdS3::P64 = P64[_sgdS8::P64 + 16];
           _sgdS4::P64 = P64[_sgdS8::P64 + 24];
           I64[Hp - 16] = sat_sgdS7_info;
           P64[Hp] = _sgdS4::P64;
           R2 = Hp - 16;
           R1 = _sgdS3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgfQw,
                       label: Data.Functor.Compose.$fEqCompose_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfQw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfQA; else goto cgfQz;
       cgfQA: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfQz: // global
           I64[Hp - 24] = sat_sgdS8_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgdS2::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgdS2::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.076151244 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c/=_closure" {
     Data.Functor.Compose.$fEqCompose_$c/=_closure:
         const Data.Functor.Compose.$fEqCompose_$c/=_info;
 },
 sat_sgdSe_entry() //  [R1]
         { info_tbl: [(cgfQZ,
                       label: sat_sgdSe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfQZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfR0; else goto cgfR1;
       cgfR0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfR1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSf_entry() //  [R1]
         { info_tbl: [(cgfR2,
                       label: sat_sgdSf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfR2: // global
           _sgdSf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgfR3; else goto cgfR4;
       cgfR4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfR6; else goto cgfR5;
       cgfR6: // global
           HpAlloc = 24;
           goto cgfR3;
       cgfR3: // global
           R1 = _sgdSf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSf::P64;
           _sgdSa::P64 = P64[_sgdSf::P64 + 16];
           _sgdSb::P64 = P64[_sgdSf::P64 + 24];
           I64[Hp - 16] = sat_sgdSe_info;
           P64[Hp] = _sgdSb::P64;
           R2 = Hp - 16;
           R1 = _sgdSa::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgfRd,
                       label: Data.Functor.Compose.$fEqCompose_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfRd: // global
           _sgdSd::P64 = R6;
           _sgdSc::P64 = R5;
           _sgdSb::P64 = R4;
           _sgdSa::P64 = R3;
           _sgdS9::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cgfRe; else goto cgfRf;
       cgfRf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfRh; else goto cgfRg;
       cgfRh: // global
           HpAlloc = 32;
           goto cgfRe;
       cgfRe: // global
           R6 = _sgdSd::P64;
           R5 = _sgdSc::P64;
           R4 = _sgdSb::P64;
           R3 = _sgdSa::P64;
           R2 = _sgdS9::P64;
           R1 = Data.Functor.Compose.$fEqCompose_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfRg: // global
           I64[Hp - 24] = sat_sgdSf_info;
           P64[Hp - 8] = _sgdSa::P64;
           P64[Hp] = _sgdSb::P64;
           I64[Sp - 8] = block_cgfR7_info;
           R4 = _sgdSd::P64;
           R3 = _sgdSc::P64;
           R2 = Hp - 24;
           R1 = _sgdS9::P64;
           Sp = Sp - 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgfR7() //  [R1]
         { info_tbl: [(cgfR7,
                       label: block_cgfR7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfR7: // global
           if (R1 & 7 == 1) goto cgfRa; else goto cgfRb;
       cgfRa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgfRb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.086813323 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_closure" {
     Data.Functor.Compose.$fEqCompose_closure:
         const Data.Functor.Compose.$fEqCompose_info;
 },
 sat_sgdSl_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfRR,
                       label: sat_sgdSl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfRR: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdSk_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfRZ,
                       label: sat_sgdSk_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfRZ: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fEqCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgfS3,
                       label: Data.Functor.Compose.$fEqCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfS3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgfS7; else goto cgfS6;
       cgfS7: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfS6: // global
           I64[Hp - 80] = sat_sgdSl_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgdSk_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.094646596 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$ccompare_closure" {
     Data.Functor.Compose.$fOrdCompose_$ccompare_closure:
         const Data.Functor.Compose.$fOrdCompose_$ccompare_info;
 },
 sat_sgdSr_entry() //  [R1]
         { info_tbl: [(cgfSx,
                       label: sat_sgdSr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfSx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfSy; else goto cgfSz;
       cgfSy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfSz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSs_entry() //  [R1]
         { info_tbl: [(cgfSA,
                       label: sat_sgdSs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfSA: // global
           _sgdSs::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfSB; else goto cgfSC;
       cgfSC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfSE; else goto cgfSD;
       cgfSE: // global
           HpAlloc = 24;
           goto cgfSB;
       cgfSB: // global
           R1 = _sgdSs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfSD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSs::P64;
           _sgdSn::P64 = P64[_sgdSs::P64 + 16];
           _sgdSo::P64 = P64[_sgdSs::P64 + 24];
           I64[Hp - 16] = sat_sgdSr_info;
           P64[Hp] = _sgdSo::P64;
           R2 = _sgdSn::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cgfSF,
                       label: Data.Functor.Compose.$fOrdCompose_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfSF: // global
           _sgdSq::P64 = R6;
           _sgdSp::P64 = R5;
           _sgdSo::P64 = R4;
           _sgdSn::P64 = R3;
           _sgdSm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfSG; else goto cgfSH;
       cgfSH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfSJ; else goto cgfSI;
       cgfSJ: // global
           HpAlloc = 32;
           goto cgfSG;
       cgfSG: // global
           R6 = _sgdSq::P64;
           R5 = _sgdSp::P64;
           R4 = _sgdSo::P64;
           R3 = _sgdSn::P64;
           R2 = _sgdSm::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfSI: // global
           I64[Hp - 24] = sat_sgdSs_info;
           P64[Hp - 8] = _sgdSn::P64;
           P64[Hp] = _sgdSo::P64;
           R2 = _sgdSm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdSp::P64;
           P64[Sp - 8] = _sgdSq::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.103956739 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure" {
     Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure:
         const Data.Functor.Compose.$fOrdCompose_$cp1Ord_info;
 },
 sat_sgdSy_entry() //  [R1]
         { info_tbl: [(cgfT7,
                       label: sat_sgdSy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfT7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfT8; else goto cgfT9;
       cgfT8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfT9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSx_entry() //  [R1]
         { info_tbl: [(cgfTe,
                       label: sat_sgdSx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfTe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfTf; else goto cgfTg;
       cgfTf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfTg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSw_entry() //  [R1]
         { info_tbl: [(cgfTl,
                       label: sat_sgdSw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfTl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfTm; else goto cgfTn;
       cgfTm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfTn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cgfTo,
                       label: Data.Functor.Compose.$fOrdCompose_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfTo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgfTs; else goto cgfTr;
       cgfTs: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfTr: // global
           I64[Hp - 64] = sat_sgdSy_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgdSx_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdSw_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fEqCompose_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.113811518 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<_info;
 },
 sat_sgdSE_entry() //  [R1]
         { info_tbl: [(cgfTV,
                       label: sat_sgdSE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfTV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfTW; else goto cgfTX;
       cgfTW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfTX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSF_entry() //  [R1]
         { info_tbl: [(cgfTY,
                       label: sat_sgdSF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfTY: // global
           _sgdSF::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfTZ; else goto cgfU0;
       cgfU0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfU2; else goto cgfU1;
       cgfU2: // global
           HpAlloc = 24;
           goto cgfTZ;
       cgfTZ: // global
           R1 = _sgdSF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfU1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSF::P64;
           _sgdSA::P64 = P64[_sgdSF::P64 + 16];
           _sgdSB::P64 = P64[_sgdSF::P64 + 24];
           I64[Hp - 16] = sat_sgdSE_info;
           P64[Hp] = _sgdSB::P64;
           R2 = _sgdSA::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgfU9,
                       label: Data.Functor.Compose.$fOrdCompose_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfU9: // global
           _sgdSD::P64 = R6;
           _sgdSC::P64 = R5;
           _sgdSB::P64 = R4;
           _sgdSA::P64 = R3;
           _sgdSz::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfUa; else goto cgfUb;
       cgfUb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfUd; else goto cgfUc;
       cgfUd: // global
           HpAlloc = 32;
           goto cgfUa;
       cgfUa: // global
           R6 = _sgdSD::P64;
           R5 = _sgdSC::P64;
           R4 = _sgdSB::P64;
           R3 = _sgdSA::P64;
           R2 = _sgdSz::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfUc: // global
           I64[Hp - 24] = sat_sgdSF_info;
           P64[Hp - 8] = _sgdSA::P64;
           P64[Hp] = _sgdSB::P64;
           I64[Sp - 8] = block_cgfU3_info;
           R2 = _sgdSz::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSC::P64;
           P64[Sp - 16] = _sgdSD::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfU3() //  [R1]
         { info_tbl: [(cgfU3,
                       label: block_cgfU3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfU3: // global
           if (R1 & 7 == 1) goto cgfU7; else goto cgfU6;
       cgfU7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgfU6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.12453208 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>=_info;
 },
 sat_sgdSM_entry() //  [R1]
         { info_tbl: [(cgfUS,
                       label: sat_sgdSM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfUS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfUT; else goto cgfUU;
       cgfUT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfUU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSN_entry() //  [R1]
         { info_tbl: [(cgfUV,
                       label: sat_sgdSN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfUV: // global
           _sgdSN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfUW; else goto cgfUX;
       cgfUX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfUZ; else goto cgfUY;
       cgfUZ: // global
           HpAlloc = 24;
           goto cgfUW;
       cgfUW: // global
           R1 = _sgdSN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfUY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSN::P64;
           _sgdSI::P64 = P64[_sgdSN::P64 + 16];
           _sgdSJ::P64 = P64[_sgdSN::P64 + 24];
           I64[Hp - 16] = sat_sgdSM_info;
           P64[Hp] = _sgdSJ::P64;
           R2 = _sgdSI::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgfV6,
                       label: Data.Functor.Compose.$fOrdCompose_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfV6: // global
           _sgdSL::P64 = R6;
           _sgdSK::P64 = R5;
           _sgdSJ::P64 = R4;
           _sgdSI::P64 = R3;
           _sgdSH::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfV7; else goto cgfV8;
       cgfV8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfVa; else goto cgfV9;
       cgfVa: // global
           HpAlloc = 32;
           goto cgfV7;
       cgfV7: // global
           R6 = _sgdSL::P64;
           R5 = _sgdSK::P64;
           R4 = _sgdSJ::P64;
           R3 = _sgdSI::P64;
           R2 = _sgdSH::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfV9: // global
           I64[Hp - 24] = sat_sgdSN_info;
           P64[Hp - 8] = _sgdSI::P64;
           P64[Hp] = _sgdSJ::P64;
           I64[Sp - 8] = block_cgfV0_info;
           R2 = _sgdSH::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSK::P64;
           P64[Sp - 16] = _sgdSL::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfV0() //  [R1]
         { info_tbl: [(cgfV0,
                       label: block_cgfV0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfV0: // global
           if (R1 & 7 == 1) goto cgfV4; else goto cgfV3;
       cgfV4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgfV3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.135218777 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>_info;
 },
 sat_sgdSU_entry() //  [R1]
         { info_tbl: [(cgfVP,
                       label: sat_sgdSU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfVP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfVQ; else goto cgfVR;
       cgfVQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfVR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdSV_entry() //  [R1]
         { info_tbl: [(cgfVS,
                       label: sat_sgdSV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfVS: // global
           _sgdSV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfVT; else goto cgfVU;
       cgfVU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfVW; else goto cgfVV;
       cgfVW: // global
           HpAlloc = 24;
           goto cgfVT;
       cgfVT: // global
           R1 = _sgdSV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfVV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdSV::P64;
           _sgdSQ::P64 = P64[_sgdSV::P64 + 16];
           _sgdSR::P64 = P64[_sgdSV::P64 + 24];
           I64[Hp - 16] = sat_sgdSU_info;
           P64[Hp] = _sgdSR::P64;
           R2 = _sgdSQ::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cgfW3,
                       label: Data.Functor.Compose.$fOrdCompose_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfW3: // global
           _sgdST::P64 = R6;
           _sgdSS::P64 = R5;
           _sgdSR::P64 = R4;
           _sgdSQ::P64 = R3;
           _sgdSP::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfW4; else goto cgfW5;
       cgfW5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfW7; else goto cgfW6;
       cgfW7: // global
           HpAlloc = 32;
           goto cgfW4;
       cgfW4: // global
           R6 = _sgdST::P64;
           R5 = _sgdSS::P64;
           R4 = _sgdSR::P64;
           R3 = _sgdSQ::P64;
           R2 = _sgdSP::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfW6: // global
           I64[Hp - 24] = sat_sgdSV_info;
           P64[Hp - 8] = _sgdSQ::P64;
           P64[Hp] = _sgdSR::P64;
           I64[Sp - 8] = block_cgfVX_info;
           R2 = _sgdSP::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdSS::P64;
           P64[Sp - 16] = _sgdST::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfVX() //  [R1]
         { info_tbl: [(cgfVX,
                       label: block_cgfVX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfVX: // global
           if (R1 & 7 == 3) goto cgfW1; else goto cgfW0;
       cgfW1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgfW0: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.146335184 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<=_info;
 },
 sat_sgdT2_entry() //  [R1]
         { info_tbl: [(cgfWM,
                       label: sat_sgdT2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfWM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfWN; else goto cgfWO;
       cgfWN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfWO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdT3_entry() //  [R1]
         { info_tbl: [(cgfWP,
                       label: sat_sgdT3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfWP: // global
           _sgdT3::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfWQ; else goto cgfWR;
       cgfWR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfWT; else goto cgfWS;
       cgfWT: // global
           HpAlloc = 24;
           goto cgfWQ;
       cgfWQ: // global
           R1 = _sgdT3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfWS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdT3::P64;
           _sgdSY::P64 = P64[_sgdT3::P64 + 16];
           _sgdSZ::P64 = P64[_sgdT3::P64 + 24];
           I64[Hp - 16] = sat_sgdT2_info;
           P64[Hp] = _sgdSZ::P64;
           R2 = _sgdSY::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cgfX0,
                       label: Data.Functor.Compose.$fOrdCompose_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfX0: // global
           _sgdT1::P64 = R6;
           _sgdT0::P64 = R5;
           _sgdSZ::P64 = R4;
           _sgdSY::P64 = R3;
           _sgdSX::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgfX1; else goto cgfX2;
       cgfX2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfX4; else goto cgfX3;
       cgfX4: // global
           HpAlloc = 32;
           goto cgfX1;
       cgfX1: // global
           R6 = _sgdT1::P64;
           R5 = _sgdT0::P64;
           R4 = _sgdSZ::P64;
           R3 = _sgdSY::P64;
           R2 = _sgdSX::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfX3: // global
           I64[Hp - 24] = sat_sgdT3_info;
           P64[Hp - 8] = _sgdSY::P64;
           P64[Hp] = _sgdSZ::P64;
           I64[Sp - 8] = block_cgfWU_info;
           R2 = _sgdSX::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdT0::P64;
           P64[Sp - 16] = _sgdT1::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfWU() //  [R1]
         { info_tbl: [(cgfWU,
                       label: block_cgfWU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfWU: // global
           if (R1 & 7 == 3) goto cgfWY; else goto cgfWX;
       cgfWY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgfWX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.15686943 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmax_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmax_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmax_info;
 },
 sat_sgdTa_entry() //  [R1]
         { info_tbl: [(cgfXJ,
                       label: sat_sgdTa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfXJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfXK; else goto cgfXL;
       cgfXK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfXL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTb_entry() //  [R1]
         { info_tbl: [(cgfXM,
                       label: sat_sgdTb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfXM: // global
           _sgdTb::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfXN; else goto cgfXO;
       cgfXO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfXQ; else goto cgfXP;
       cgfXQ: // global
           HpAlloc = 24;
           goto cgfXN;
       cgfXN: // global
           R1 = _sgdTb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfXP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTb::P64;
           _sgdT6::P64 = P64[_sgdTb::P64 + 16];
           _sgdT7::P64 = P64[_sgdTb::P64 + 24];
           I64[Hp - 16] = sat_sgdTa_info;
           P64[Hp] = _sgdT7::P64;
           R2 = _sgdT6::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgfXX,
                       label: Data.Functor.Compose.$fOrdCompose_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfXX: // global
           _sgdT9::P64 = R6;
           _sgdT8::P64 = R5;
           _sgdT7::P64 = R4;
           _sgdT6::P64 = R3;
           _sgdT5::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgfXY; else goto cgfXZ;
       cgfXZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfY1; else goto cgfY0;
       cgfY1: // global
           HpAlloc = 32;
           goto cgfXY;
       cgfXY: // global
           R6 = _sgdT9::P64;
           R5 = _sgdT8::P64;
           R4 = _sgdT7::P64;
           R3 = _sgdT6::P64;
           R2 = _sgdT5::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfY0: // global
           I64[Hp - 24] = sat_sgdTb_info;
           P64[Hp - 8] = _sgdT6::P64;
           P64[Hp] = _sgdT7::P64;
           I64[Sp - 24] = block_cgfXR_info;
           R2 = _sgdT5::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgdT8::P64;
           P64[Sp - 32] = _sgdT9::P64;
           P64[Sp - 16] = _sgdT8::P64;
           P64[Sp - 8] = _sgdT9::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfXR() //  [R1]
         { info_tbl: [(cgfXR,
                       label: block_cgfXR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfXR: // global
           if (R1 & 7 == 3) goto cgfXV; else goto cgfXU;
       cgfXV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfXU: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.167886809 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmin_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmin_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmin_info;
 },
 sat_sgdTi_entry() //  [R1]
         { info_tbl: [(cgfYE,
                       label: sat_sgdTi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfYE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfYF; else goto cgfYG;
       cgfYF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfYG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTj_entry() //  [R1]
         { info_tbl: [(cgfYH,
                       label: sat_sgdTj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfYH: // global
           _sgdTj::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgfYI; else goto cgfYJ;
       cgfYJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgfYL; else goto cgfYK;
       cgfYL: // global
           HpAlloc = 24;
           goto cgfYI;
       cgfYI: // global
           R1 = _sgdTj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfYK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTj::P64;
           _sgdTe::P64 = P64[_sgdTj::P64 + 16];
           _sgdTf::P64 = P64[_sgdTj::P64 + 24];
           I64[Hp - 16] = sat_sgdTi_info;
           P64[Hp] = _sgdTf::P64;
           R2 = _sgdTe::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cgfYS,
                       label: Data.Functor.Compose.$fOrdCompose_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfYS: // global
           _sgdTh::P64 = R6;
           _sgdTg::P64 = R5;
           _sgdTf::P64 = R4;
           _sgdTe::P64 = R3;
           _sgdTd::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cgfYT; else goto cgfYU;
       cgfYU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgfYW; else goto cgfYV;
       cgfYW: // global
           HpAlloc = 32;
           goto cgfYT;
       cgfYT: // global
           R6 = _sgdTh::P64;
           R5 = _sgdTg::P64;
           R4 = _sgdTf::P64;
           R3 = _sgdTe::P64;
           R2 = _sgdTd::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfYV: // global
           I64[Hp - 24] = sat_sgdTj_info;
           P64[Hp - 8] = _sgdTe::P64;
           P64[Hp] = _sgdTf::P64;
           I64[Sp - 24] = block_cgfYM_info;
           R2 = _sgdTd::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgdTg::P64;
           P64[Sp - 32] = _sgdTh::P64;
           P64[Sp - 16] = _sgdTg::P64;
           P64[Sp - 8] = _sgdTh::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cgfYM() //  [R1]
         { info_tbl: [(cgfYM,
                       label: block_cgfYM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfYM: // global
           if (R1 & 7 == 3) goto cgfYQ; else goto cgfYP;
       cgfYQ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgfYP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.179490057 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_closure" {
     Data.Functor.Compose.$fOrdCompose_closure:
         const Data.Functor.Compose.$fOrdCompose_info;
 },
 sat_sgdTv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfZw,
                       label: sat_sgdTv_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfZw: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTu_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfZE,
                       label: sat_sgdTu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfZE: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTt_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfZM,
                       label: sat_sgdTt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfZM: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTs_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfZU,
                       label: sat_sgdTs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfZU: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTr_entry() //  [R1, R2, R3]
         { info_tbl: [(cgg02,
                       label: sat_sgdTr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg02: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTq_entry() //  [R1, R2, R3]
         { info_tbl: [(cgg0a,
                       label: sat_sgdTq_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg0a: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTp_entry() //  [R1, R2, R3]
         { info_tbl: [(cgg0i,
                       label: sat_sgdTp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg0i: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdTo_entry() //  [R1]
         { info_tbl: [(cgg0p,
                       label: sat_sgdTo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg0p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg0q; else goto cgg0r;
       cgg0q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg0r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgg0t,
                       label: Data.Functor.Compose.$fOrdCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg0t: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cgg0x; else goto cgg0w;
       cgg0x: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg0w: // global
           I64[Hp - 328] = sat_sgdTv_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sgdTu_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sgdTt_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sgdTs_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sgdTr_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sgdTq_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sgdTp_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sgdTo_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.199258838 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadPrec_info;
         const 0;
 },
 sat_sgdTA_entry() //  [R1]
         { info_tbl: [(cgg1i,
                       label: sat_sgdTA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg1i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg1j; else goto cgg1k;
       cgg1j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg1k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTz_entry() //  [R1]
         { info_tbl: [(cgg1p,
                       label: sat_sgdTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg1q; else goto cgg1r;
       cgg1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg1r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgg1s,
                       label: Data.Functor.Compose.$fReadCompose_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg1s: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgg1w; else goto cgg1v;
       cgg1w: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg1v: // global
           I64[Hp - 40] = sat_sgdTA_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgdTz_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.207348575 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadsPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadsPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_info;
         const 0;
 },
 sat_sgdTG_entry() //  [R1]
         { info_tbl: [(cgg1V,
                       label: sat_sgdTG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg1V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg1W; else goto cgg1X;
       cgg1W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg1X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTF_entry() //  [R1]
         { info_tbl: [(cgg22,
                       label: sat_sgdTF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg22: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg23; else goto cgg24;
       cgg23: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg24: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sgdTE_entry() //  [R1]
         { info_tbl: [(cgg25,
                       label: ds_sgdTE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg25: // global
           _sgdTE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgg26; else goto cgg27;
       cgg27: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgg29; else goto cgg28;
       cgg29: // global
           HpAlloc = 48;
           goto cgg26;
       cgg26: // global
           R1 = _sgdTE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg28: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdTE::P64;
           _sgdTB::P64 = P64[_sgdTE::P64 + 16];
           _sgdTC::P64 = P64[_sgdTE::P64 + 24];
           _sgdTD::P64 = P64[_sgdTE::P64 + 32];
           I64[Hp - 40] = sat_sgdTG_info;
           P64[Hp - 24] = _sgdTD::P64;
           I64[Hp - 16] = sat_sgdTF_info;
           P64[Hp] = _sgdTD::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgdTC::P64;
           R2 = _sgdTB::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTI_entry() //  [R1]
         { info_tbl: [(cgg2j,
                       label: sat_sgdTI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg2j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg2k; else goto cgg2l;
       cgg2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg2l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTJ_entry() //  [R1, R2]
         { info_tbl: [(cgg2m,
                       label: sat_sgdTJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg2m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgg2q; else goto cgg2p;
       cgg2q: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgg2p: // global
           _sgdTE::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgdTI_info;
           P64[Hp - 8] = _sgdTE::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cgg2r,
                       label: Data.Functor.Compose.$fReadCompose_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg2r: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgg2v; else goto cgg2u;
       cgg2v: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg2u: // global
           I64[Hp - 48] = ds_sgdTE_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sgdTJ_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.222201262 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadListPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadListPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_info;
         const 0;
 },
 sat_sgdTO_entry() //  [R1]
         { info_tbl: [(cgg37,
                       label: sat_sgdTO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg37: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg38; else goto cgg39;
       cgg38: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg39: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTN_entry() //  [R1]
         { info_tbl: [(cgg3e,
                       label: sat_sgdTN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg3f; else goto cgg3g;
       cgg3f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg3g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTP_entry() //  [R1]
         { info_tbl: [(cgg3h,
                       label: sat_sgdTP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg3h: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgg3l; else goto cgg3k;
       cgg3l: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg3k: // global
           _sgdTK::P64 = P64[R1 + 16];
           _sgdTL::P64 = P64[R1 + 24];
           _sgdTM::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sgdTO_info;
           P64[Hp - 24] = _sgdTM::P64;
           I64[Hp - 16] = sat_sgdTN_info;
           P64[Hp] = _sgdTM::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgdTL::P64;
           R2 = _sgdTK::P64;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cgg3m,
                       label: Data.Functor.Compose.$fReadCompose_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg3m: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgg3q; else goto cgg3p;
       cgg3q: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg3p: // global
           I64[Hp - 32] = sat_sgdTP_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.232239885 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadList_closure" {
     Data.Functor.Compose.$fReadCompose_$creadList_closure:
         const Data.Functor.Compose.$fReadCompose_$creadList_info;
         const 0;
 },
 sat_sgdTT_entry() //  [R1]
         { info_tbl: [(cgg3O,
                       label: sat_sgdTT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg3O: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgg3P; else goto cgg3Q;
       cgg3P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg3Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cgg3R,
                       label: Data.Functor.Compose.$fReadCompose_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg3R: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgg3V; else goto cgg3U;
       cgg3V: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg3U: // global
           I64[Hp - 32] = sat_sgdTT_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.239183448 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_closure" {
     Data.Functor.Compose.$fReadCompose_closure:
         const Data.Functor.Compose.$fReadCompose_info;
         const 0;
 },
 sat_sgdU0_entry() //  [R1]
         { info_tbl: [(cgg4c,
                       label: sat_sgdU0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg4c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg4d; else goto cgg4e;
       cgg4d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg4e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTZ_entry() //  [R1]
         { info_tbl: [(cgg4j,
                       label: sat_sgdTZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg4j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg4k; else goto cgg4l;
       cgg4k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg4l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTY_entry() //  [R1]
         { info_tbl: [(cgg4q,
                       label: sat_sgdTY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg4q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg4r; else goto cgg4s;
       cgg4r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg4s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdTX_entry() //  [R1]
         { info_tbl: [(cgg4x,
                       label: sat_sgdTX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg4x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg4y; else goto cgg4z;
       cgg4y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgg4B,
                       label: Data.Functor.Compose.$fReadCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg4B: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cgg4F; else goto cgg4E;
       cgg4F: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg4E: // global
           I64[Hp - 192] = sat_sgdU0_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sgdTZ_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sgdTY_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgdTX_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.25175233 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_info;
         const 0;
 },
 sat_sgdU9_entry() //  [R1]
         { info_tbl: [(cgg5i,
                       label: sat_sgdU9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg5i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg5j; else goto cgg5k;
       cgg5j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg5k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdU8_entry() //  [R1]
         { info_tbl: [(cgg5p,
                       label: sat_sgdU8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg5p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg5q; else goto cgg5r;
       cgg5q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg5r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgg5s,
                       label: Data.Functor.Compose.$fShowCompose_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg5s: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgg5t; else goto cgg5u;
       cgg5t: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg5u: // global
           I64[Sp - 40] = block_cgg59_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugg5y; else goto cgg5a;
       ugg5y: // global
           call _cgg59(R1) args: 0, res: 0, upd: 0;
       cgg5a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgg59() //  [R1]
         { info_tbl: [(cgg59,
                       label: block_cgg59_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg59: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgg5x; else goto cgg5w;
       cgg5x: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgg5w: // global
           _sgdU7::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sgdU9_info;
           _sgdU3::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgdU3::P64;
           I64[Hp - 16] = sat_sgdU8_info;
           P64[Hp] = _sgdU3::P64;
           R6 = _sgdU7::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.262544906 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshow_closure" {
     Data.Functor.Compose.$fShowCompose_$cshow_closure:
         const Data.Functor.Compose.$fShowCompose_$cshow_info;
         const 0;
 },
 sp_sgdUe_entry() //  [R1]
         { info_tbl: [(cgg5Y,
                       label: sp_sgdUe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg5Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg5Z; else goto cgg60;
       cgg5Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg60: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sgdUf_entry() //  [R1]
         { info_tbl: [(cgg65,
                       label: sl_sgdUf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg65: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg66; else goto cgg67;
       cgg66: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg67: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdUh_entry() //  [R1]
         { info_tbl: [(cgg6g,
                       label: sat_sgdUh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg6g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgg6h; else goto cgg6i;
       cgg6h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg6i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdUg_entry() //  [R1]
         { info_tbl: [(cgg6n,
                       label: sat_sgdUg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg6n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgg6o; else goto cgg6p;
       cgg6o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg6p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdUi_entry() //  [R1]
         { info_tbl: [(cgg6q,
                       label: sat_sgdUi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg6q: // global
           _sgdUi::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cgg6r; else goto cgg6s;
       cgg6s: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgg6u; else goto cgg6t;
       cgg6u: // global
           HpAlloc = 80;
           goto cgg6r;
       cgg6r: // global
           R1 = _sgdUi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg6t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdUi::P64;
           _sgdUa::P64 = P64[_sgdUi::P64 + 16];
           _sgdUb::P64 = P64[_sgdUi::P64 + 24];
           _sgdUd::P64 = P64[_sgdUi::P64 + 32];
           _sgdUe::P64 = P64[_sgdUi::P64 + 40];
           _sgdUf::P64 = P64[_sgdUi::P64 + 48];
           I64[Hp - 72] = sat_sgdUh_info;
           P64[Hp - 56] = _sgdUb::P64;
           P64[Hp - 48] = _sgdUe::P64;
           P64[Hp - 40] = _sgdUf::P64;
           I64[Hp - 32] = sat_sgdUg_info;
           P64[Hp - 16] = _sgdUb::P64;
           P64[Hp - 8] = _sgdUe::P64;
           P64[Hp] = _sgdUf::P64;
           R2 = _sgdUa::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 32;
           P64[Sp - 48] = Hp - 72;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sgdUd::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cgg6w,
                       label: Data.Functor.Compose.$fShowCompose_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg6w: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgg6A; else goto cgg6z;
       cgg6A: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg6z: // global
           I64[Hp - 120] = sp_sgdUe_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sgdUf_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgdUi_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = Hp - 120;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 72;
           R3 = Hp - 14;
           R2 = Data.Functor.Compose.$fDataCompose6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.27808931 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowList_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowList_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowList_info;
         const 0;
 },
 lvl8_sgdUp_entry() //  [R1]
         { info_tbl: [(cgg7g,
                       label: lvl8_sgdUp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg7g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg7h; else goto cgg7i;
       cgg7h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg7i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sgdUq_entry() //  [R1]
         { info_tbl: [(cgg7n,
                       label: lvl9_sgdUq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg7n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg7o; else goto cgg7p;
       cgg7o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg7p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdUs_entry() //  [R1, R2]
         { info_tbl: [(cgg7v,
                       label: sat_sgdUs_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg7v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgg7w; else goto cgg7x;
       cgg7w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgg7x: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgdUr::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgdUr::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cgg7y,
                       label: Data.Functor.Compose.$fShowCompose_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg7y: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgg7C; else goto cgg7B;
       cgg7C: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg7B: // global
           I64[Hp - 80] = lvl8_sgdUp_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sgdUq_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgdUs_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.28858687 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_closure" {
     Data.Functor.Compose.$fShowCompose_closure:
         const Data.Functor.Compose.$fShowCompose_info;
         const 0;
 },
 sat_sgdUy_entry() //  [R1, R2, R3]
         { info_tbl: [(cgg84,
                       label: sat_sgdUy_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg84: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUx_entry() //  [R1, R2]
         { info_tbl: [(cgg8c,
                       label: sat_sgdUx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg8c: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fShowCompose_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgg8k,
                       label: sat_sgdUw_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg8k: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cgg8o,
                       label: Data.Functor.Compose.$fShowCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg8o: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgg8s; else goto cgg8r;
       cgg8s: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg8r: // global
           I64[Hp - 120] = sat_sgdUy_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sgdUx_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sgdUw_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.298450899 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose2_closure" {
     Data.Functor.Compose.$fFunctorCompose2_closure:
         const Data.Functor.Compose.$fFunctorCompose2_info;
 },
 sat_sgdUD_entry() //  [R1]
         { info_tbl: [(cgg8S,
                       label: sat_sgdUD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg8S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgg8T; else goto cgg8U;
       cgg8T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg8U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgg8V,
                       label: Data.Functor.Compose.$fFunctorCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg8V: // global
           _sgdUC::P64 = R5;
           _sgdUB::P64 = R4;
           _sgdUA::P64 = R3;
           _sgdUz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgg8W; else goto cgg8X;
       cgg8X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgg8Z; else goto cgg8Y;
       cgg8Z: // global
           HpAlloc = 32;
           goto cgg8W;
       cgg8W: // global
           R5 = _sgdUC::P64;
           R4 = _sgdUB::P64;
           R3 = _sgdUA::P64;
           R2 = _sgdUz::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg8Y: // global
           I64[Hp - 24] = sat_sgdUD_info;
           P64[Hp - 8] = _sgdUA::P64;
           P64[Hp] = _sgdUB::P64;
           R2 = _sgdUz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUC::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.305579929 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose1_closure" {
     Data.Functor.Compose.$fFunctorCompose1_closure:
         const Data.Functor.Compose.$fFunctorCompose1_info;
 },
 sat_sgdUJ_entry() //  [R1]
         { info_tbl: [(cgg9o,
                       label: sat_sgdUJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg9o: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUK_entry() //  [R1]
         { info_tbl: [(cgg9r,
                       label: sat_sgdUK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg9r: // global
           _sgdUK::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgg9s; else goto cgg9t;
       cgg9t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgg9v; else goto cgg9u;
       cgg9v: // global
           HpAlloc = 16;
           goto cgg9s;
       cgg9s: // global
           R1 = _sgdUK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg9u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdUK::P64;
           _sgdUF::P64 = P64[_sgdUK::P64 + 16];
           _sgdUG::P64 = P64[_sgdUK::P64 + 24];
           I64[Hp - 8] = sat_sgdUJ_info;
           P64[Hp] = _sgdUG::P64;
           R2 = _sgdUF::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgg9w,
                       label: Data.Functor.Compose.$fFunctorCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg9w: // global
           _sgdUH::P64 = R5;
           _sgdUG::P64 = R4;
           _sgdUF::P64 = R3;
           _sgdUE::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgg9x; else goto cgg9y;
       cgg9y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgg9A; else goto cgg9z;
       cgg9A: // global
           HpAlloc = 32;
           goto cgg9x;
       cgg9x: // global
           R5 = _sgdUH::P64;
           R4 = _sgdUG::P64;
           R3 = _sgdUF::P64;
           R2 = _sgdUE::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgg9z: // global
           I64[Hp - 24] = sat_sgdUK_info;
           P64[Hp - 8] = _sgdUF::P64;
           P64[Hp] = _sgdUG::P64;
           R2 = _sgdUE::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUH::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.314079522 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose_closure" {
     Data.Functor.Compose.$fFunctorCompose_closure:
         const Data.Functor.Compose.$fFunctorCompose_info;
 },
 sat_sgdUO_entry() //  [R1, R2, R3]
         { info_tbl: [(cgg9Y,
                       label: sat_sgdUO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg9Y: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdUN_entry() //  [R1, R2, R3]
         { info_tbl: [(cgga6,
                       label: sat_sgdUN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgga6: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFunctorCompose_entry() //  [R2, R3]
         { info_tbl: [(cggaa,
                       label: Data.Functor.Compose.$fFunctorCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggaa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cggae; else goto cggad;
       cggae: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFunctorCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggad: // global
           I64[Hp - 64] = sat_sgdUO_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgdUN_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.321375216 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info;
 },
 sat_sgdUU_entry() //  [R1]
         { info_tbl: [(cggaA,
                       label: sat_sgdUU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggaA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggaB; else goto cggaC;
       cggaB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggaC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cggaD,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggaD: // global
           _sgdUT::P64 = R6;
           _sgdUS::P64 = R5;
           _sgdUR::P64 = R4;
           _sgdUQ::P64 = R3;
           _sgdUP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cggaE; else goto cggaF;
       cggaF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cggaH; else goto cggaG;
       cggaH: // global
           HpAlloc = 40;
           goto cggaE;
       cggaE: // global
           R6 = _sgdUT::P64;
           R5 = _sgdUS::P64;
           R4 = _sgdUR::P64;
           R3 = _sgdUQ::P64;
           R2 = _sgdUP::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggaG: // global
           I64[Hp - 32] = sat_sgdUU_info;
           P64[Hp - 16] = _sgdUQ::P64;
           P64[Hp - 8] = _sgdUR::P64;
           P64[Hp] = _sgdUS::P64;
           R2 = _sgdUP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgdUR::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgdUT::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.327614994 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfold_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfold_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfold_info;
 },
 sat_sgdUZ_entry() //  [R1]
         { info_tbl: [(cggb2,
                       label: sat_sgdUZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggb2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggb3; else goto cggb4;
       cggb3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggb4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cggb5,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggb5: // global
           _sgdUY::P64 = R5;
           _sgdUX::P64 = R4;
           _sgdUW::P64 = R3;
           _sgdUV::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cggb6; else goto cggb7;
       cggb7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggb9; else goto cggb8;
       cggb9: // global
           HpAlloc = 32;
           goto cggb6;
       cggb6: // global
           R5 = _sgdUY::P64;
           R4 = _sgdUX::P64;
           R3 = _sgdUW::P64;
           R2 = _sgdUV::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggb8: // global
           I64[Hp - 24] = sat_sgdUZ_info;
           P64[Hp - 8] = _sgdUW::P64;
           P64[Hp] = _sgdUX::P64;
           R2 = _sgdUV::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgdUX::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgdUY::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.333907279 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose1_closure" {
     Data.Functor.Compose.$fFoldableCompose1_closure:
         const Data.Functor.Compose.$fFoldableCompose1_info;
 },
 Data.Functor.Compose.$fFoldableCompose1_entry() //  [R2]
         { info_tbl: [(cggbp,
                       label: Data.Functor.Compose.$fFoldableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggbp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.337614526 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$csum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$csum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$csum_info;
         const 0;
 },
 $dMonoid_sgdV4_entry() //  [R1]
         { info_tbl: [(cggbE,
                       label: $dMonoid_sgdV4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggbE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggbF; else goto cggbG;
       cggbF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggbG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdV5_entry() //  [R1]
         { info_tbl: [(cggbL,
                       label: lvl8_sgdV5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggbL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggbM; else goto cggbN;
       cggbM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggbN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdV7_entry() //  [R1, R2]
         { info_tbl: [(cggbT,
                       label: sat_sgdV7_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggbT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggbU; else goto cggbV;
       cggbU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggbV: // global
           _sgdV6::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgdV6::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cggbW,
                       label: Data.Functor.Compose.$fFoldableCompose_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggbW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cggc0; else goto cggbZ;
       cggc0: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggbZ: // global
           I64[Hp - 80] = $dMonoid_sgdV4_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdV5_info;
           P64[Hp - 40] = R3;
           _cggbA::P64 = Hp - 80;
           P64[Hp - 32] = _cggbA::P64;
           I64[Hp - 24] = sat_sgdV7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cggbA::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.347792006 UTC

[section ""cstring" . lvl_rgdPQ_bytes" {
     lvl_rgdPQ_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.34971528 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose2_closure" {
     Data.Functor.Compose.$fFoldableCompose2_closure:
         const Data.Functor.Compose.$fFoldableCompose2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose2_entry() //  [R1]
         { info_tbl: [(cggcv,
                       label: Data.Functor.Compose.$fFoldableCompose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggcv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cggcw; else goto cggcx;
       cggcw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggcx: // global
           (_cggcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cggcq::I64 == 0) goto cggcs; else goto cggcr;
       cggcs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cggcr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cggcq::I64;
           I64[Sp - 24] = block_cggct_info;
           R2 = lvl_rgdPQ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cggct() //  [R1]
         { info_tbl: [(cggct,
                       label: block_cggct_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggct: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.355852361 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cminimum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cminimum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_info;
         const 0;
 },
 $dMonoid_sgdVc_entry() //  [R1]
         { info_tbl: [(cggcT,
                       label: $dMonoid_sgdVc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggcT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggcU; else goto cggcV;
       cggcU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggcV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdVd_entry() //  [R1]
         { info_tbl: [(cggd0,
                       label: lvl8_sgdVd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggd0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggd1; else goto cggd2;
       cggd1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggd2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVh_entry() //  [R1, R2]
         { info_tbl: [(cggde,
                       label: sat_sgdVh_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggde: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggdf; else goto cggdg;
       cggdf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggdg: // global
           I64[Sp - 8] = block_cggd8_info;
           _sgdVe::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgdVe::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cggd8() //  [R1]
         { info_tbl: [(cggd8,
                       label: block_cggd8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggd8: // global
           if (R1 & 7 == 1) goto cggdb; else goto cggdc;
       cggdb: // global
           R1 = Data.Functor.Compose.$fFoldableCompose2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cggdc: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cggdn,
                       label: Data.Functor.Compose.$fFoldableCompose_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggdn: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cggdr; else goto cggdq;
       cggdr: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggdq: // global
           I64[Hp - 80] = $dMonoid_sgdVc_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdVd_info;
           P64[Hp - 40] = R3;
           _cggcP::P64 = Hp - 80;
           P64[Hp - 32] = _cggcP::P64;
           I64[Hp - 24] = sat_sgdVh_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cggcP::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.367377056 UTC

[section ""cstring" . lvl1_rgdPR_bytes" {
     lvl1_rgdPR_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.369375998 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose3_closure" {
     Data.Functor.Compose.$fFoldableCompose3_closure:
         const Data.Functor.Compose.$fFoldableCompose3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose3_entry() //  [R1]
         { info_tbl: [(cgge1,
                       label: Data.Functor.Compose.$fFoldableCompose3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgge1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgge2; else goto cgge3;
       cgge2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgge3: // global
           (_cggdW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cggdW::I64 == 0) goto cggdY; else goto cggdX;
       cggdY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cggdX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cggdW::I64;
           I64[Sp - 24] = block_cggdZ_info;
           R2 = lvl1_rgdPR_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cggdZ() //  [R1]
         { info_tbl: [(cggdZ,
                       label: block_cggdZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggdZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.375369863 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_info;
         const 0;
 },
 $dMonoid_sgdVm_entry() //  [R1]
         { info_tbl: [(cggep,
                       label: $dMonoid_sgdVm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggeq; else goto cgger;
       cggeq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgger: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdVn_entry() //  [R1]
         { info_tbl: [(cggew,
                       label: lvl8_sgdVn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggew: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggex; else goto cggey;
       cggex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggey: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVr_entry() //  [R1, R2]
         { info_tbl: [(cggeK,
                       label: sat_sgdVr_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggeK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggeL; else goto cggeM;
       cggeL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggeM: // global
           I64[Sp - 8] = block_cggeE_info;
           _sgdVo::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgdVo::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cggeE() //  [R1]
         { info_tbl: [(cggeE,
                       label: block_cggeE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggeE: // global
           if (R1 & 7 == 1) goto cggeH; else goto cggeI;
       cggeH: // global
           R1 = Data.Functor.Compose.$fFoldableCompose3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cggeI: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cggeT,
                       label: Data.Functor.Compose.$fFoldableCompose_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggeT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cggeX; else goto cggeW;
       cggeX: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggeW: // global
           I64[Hp - 80] = $dMonoid_sgdVm_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdVn_info;
           P64[Hp - 40] = R3;
           _cggel::P64 = Hp - 80;
           P64[Hp - 32] = _cggel::P64;
           I64[Hp - 24] = sat_sgdVr_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cggel::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.387803725 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$celem_closure" {
     Data.Functor.Compose.$fFoldableCompose_$celem_closure:
         const Data.Functor.Compose.$fFoldableCompose_$celem_info;
         const 0;
 },
 sat_sgdVx_entry() //  [R1]
         { info_tbl: [(cggfA,
                       label: sat_sgdVx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggfA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggfB; else goto cggfC;
       cggfB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggfC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_sgdVw_entry() //  [R1]
         { info_tbl: [(cggfD,
                       label: lvl8_sgdVw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggfD: // global
           _sgdVw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggfE; else goto cggfF;
       cggfF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggfH; else goto cggfG;
       cggfH: // global
           HpAlloc = 32;
           goto cggfE;
       cggfE: // global
           R1 = _sgdVw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggfG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVw::P64;
           _sgdVt::P64 = P64[_sgdVw::P64 + 16];
           _sgdVu::P64 = P64[_sgdVw::P64 + 24];
           _sgdVv::P64 = P64[_sgdVw::P64 + 32];
           I64[Hp - 24] = sat_sgdVx_info;
           P64[Hp - 8] = _sgdVu::P64;
           P64[Hp] = _sgdVv::P64;
           R2 = _sgdVt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdVz_entry() //  [R1, R2]
         { info_tbl: [(cggfN,
                       label: sat_sgdVz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggfN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggfO; else goto cggfP;
       cggfO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggfP: // global
           _sgdVy::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sgdVy::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cggfQ,
                       label: Data.Functor.Compose.$fFoldableCompose_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggfQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cggfU; else goto cggfT;
       cggfU: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggfT: // global
           I64[Hp - 56] = lvl8_sgdVw_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sgdVz_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.398160968 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose7_closure" {
     Data.Functor.Compose.$fFoldableCompose7_closure:
         const Data.Functor.Compose.$fFoldableCompose7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose7_entry() //  [R1]
         { info_tbl: [(cgggm,
                       label: Data.Functor.Compose.$fFoldableCompose7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgggm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgggn; else goto cgggo;
       cgggn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgggo: // global
           (_cgggj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgggj::I64 == 0) goto cgggl; else goto cgggk;
       cgggl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgggk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgggj::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.402512838 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_info;
         const 0;
 },
 sat_sgdVH_entry() //  [R1, R2, R3]
         { info_tbl: [(cgggJ,
                       label: sat_sgdVH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgggJ: // global
           _sgdVG::P64 = R3;
           R3 = R2;
           R2 = _sgdVG::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdVI_entry() //  [R1]
         { info_tbl: [(cgggM,
                       label: sat_sgdVI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgggM: // global
           _sgdVI::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgggN; else goto cgggO;
       cgggO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgggQ; else goto cgggP;
       cgggQ: // global
           HpAlloc = 16;
           goto cgggN;
       cgggN: // global
           R1 = _sgdVI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgggP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVI::P64;
           _sgdVB::P64 = P64[_sgdVI::P64 + 16];
           _sgdVC::P64 = P64[_sgdVI::P64 + 24];
           I64[Hp - 8] = sat_sgdVH_info;
           P64[Hp] = _sgdVC::P64;
           R2 = _sgdVB::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cgggR,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgggR: // global
           _sgdVE::P64 = R6;
           _sgdVD::P64 = R5;
           _sgdVC::P64 = R4;
           _sgdVB::P64 = R3;
           _sgdVA::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgggS; else goto cgggT;
       cgggT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgggV; else goto cgggU;
       cgggV: // global
           HpAlloc = 32;
           goto cgggS;
       cgggS: // global
           R6 = _sgdVE::P64;
           R5 = _sgdVD::P64;
           R4 = _sgdVC::P64;
           R3 = _sgdVB::P64;
           R2 = _sgdVA::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgggU: // global
           I64[Hp - 24] = sat_sgdVI_info;
           P64[Hp - 8] = _sgdVB::P64;
           P64[Hp] = _sgdVC::P64;
           R2 = _sgdVA::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdVE::P64;
           P64[Sp - 8] = _sgdVD::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.41078672 UTC

[section ""cstring" . lvl2_rgdPS_bytes" {
     lvl2_rgdPS_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.412671118 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose6_closure" {
     Data.Functor.Compose.$fFoldableCompose6_closure:
         const Data.Functor.Compose.$fFoldableCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose6_entry() //  [R1]
         { info_tbl: [(cgghj,
                       label: Data.Functor.Compose.$fFoldableCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgghj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgghk; else goto cgghl;
       cgghk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgghl: // global
           (_cgghe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgghe::I64 == 0) goto cgghg; else goto cgghf;
       cgghg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgghf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgghe::I64;
           I64[Sp - 24] = block_cgghh_info;
           R2 = lvl2_rgdPS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgghh() //  [R1]
         { info_tbl: [(cgghh,
                       label: block_cgghh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgghh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.420259197 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info;
         const 0;
 },
 sat_sgdVS_entry() //  [R1]
         { info_tbl: [(cgghX,
                       label: sat_sgdVS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgghX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgghY; else goto cgghZ;
       cgghY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgghZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgghQ_info;
           _sgdVM::P64 = P64[R1 + 16];
           _sgdVO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgdVM::P64;
           P64[Sp - 24] = _sgdVO::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uggi6; else goto cgghR;
       uggi6: // global
           call _cgghQ(R1) args: 0, res: 0, upd: 0;
       cgghR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgghQ() //  [R1]
         { info_tbl: [(cgghQ,
                       label: block_cgghQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgghQ: // global
           _sgdVO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cgghU; else goto cgghV;
       cgghU: // global
           R1 = _sgdVO::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgghV: // global
           R3 = _sgdVO::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdVT_entry() //  [R1, R2, R3]
         { info_tbl: [(cggi8,
                       label: sat_sgdVT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggi8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggic; else goto cggib;
       cggic: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggib: // global
           _sgdVM::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgdVS_info;
           P64[Hp - 32] = _sgdVM::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdVU_entry() //  [R1]
         { info_tbl: [(cggid,
                       label: sat_sgdVU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggid: // global
           _sgdVU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggie; else goto cggif;
       cggif: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cggih; else goto cggig;
       cggih: // global
           HpAlloc = 16;
           goto cggie;
       cggie: // global
           R1 = _sgdVU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdVU::P64;
           _sgdVL::P64 = P64[_sgdVU::P64 + 16];
           _sgdVM::P64 = P64[_sgdVU::P64 + 24];
           I64[Hp - 8] = sat_sgdVT_info;
           P64[Hp] = _sgdVM::P64;
           R2 = _sgdVL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cggio,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggio: // global
           _sgdVN::P64 = R5;
           _sgdVM::P64 = R4;
           _sgdVL::P64 = R3;
           _sgdVK::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cggip; else goto cggiq;
       cggiq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggis; else goto cggir;
       cggis: // global
           HpAlloc = 32;
           goto cggip;
       cggip: // global
           R5 = _sgdVN::P64;
           R4 = _sgdVM::P64;
           R3 = _sgdVL::P64;
           R2 = _sgdVK::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggir: // global
           I64[Hp - 24] = sat_sgdVU_info;
           P64[Hp - 8] = _sgdVL::P64;
           P64[Hp] = _sgdVM::P64;
           I64[Sp - 8] = block_cggii_info;
           R2 = _sgdVK::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdVN::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cggii() //  [R1]
         { info_tbl: [(cggii,
                       label: block_cggii_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggii: // global
           if (R1 & 7 == 1) goto cggil; else goto cggim;
       cggil: // global
           R1 = Data.Functor.Compose.$fFoldableCompose6_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cggim: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.435012986 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info;
         const 0;
 },
 sat_sgdW6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggjj,
                       label: sat_sgdW6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggjj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggjk; else goto cggjl;
       cggjk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggjl: // global
           I64[Sp - 16] = block_cggjh_info;
           _sgdW3::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgdW3::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggjh() //  [R1]
         { info_tbl: [(cggjh,
                       label: block_cggjh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggjh: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdW7_entry() //  [R1]
         { info_tbl: [(cggjn,
                       label: sat_sgdW7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggjn: // global
           _sgdW7::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggjo; else goto cggjp;
       cggjp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cggjr; else goto cggjq;
       cggjr: // global
           HpAlloc = 16;
           goto cggjo;
       cggjo: // global
           R1 = _sgdW7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdW7::P64;
           _sgdVY::P64 = P64[_sgdW7::P64 + 16];
           _sgdVZ::P64 = P64[_sgdW7::P64 + 24];
           I64[Hp - 8] = sat_sgdW6_info;
           P64[Hp] = _sgdVZ::P64;
           R2 = _sgdVY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cggjs,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggjs: // global
           _sgdW1::P64 = R6;
           _sgdW0::P64 = R5;
           _sgdVZ::P64 = R4;
           _sgdVY::P64 = R3;
           _sgdVX::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cggjt; else goto cggju;
       cggju: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggjw; else goto cggjv;
       cggjw: // global
           HpAlloc = 32;
           goto cggjt;
       cggjt: // global
           R6 = _sgdW1::P64;
           R5 = _sgdW0::P64;
           R4 = _sgdVZ::P64;
           R3 = _sgdVY::P64;
           R2 = _sgdVX::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggjv: // global
           I64[Hp - 24] = sat_sgdW7_info;
           P64[Hp - 8] = _sgdVY::P64;
           P64[Hp] = _sgdVZ::P64;
           R2 = _sgdVX::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdW1::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgdW0::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.445730783 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_info;
         const 0;
 },
 sat_sgdWd_entry() //  [R1]
         { info_tbl: [(cggjX,
                       label: sat_sgdWd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggjX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggjY; else goto cggjZ;
       cggjY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggjZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cggk0,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggk0: // global
           _sgdWc::P64 = R6;
           _sgdWb::P64 = R5;
           _sgdWa::P64 = R4;
           _sgdW9::P64 = R3;
           _sgdW8::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cggk1; else goto cggk2;
       cggk2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggk4; else goto cggk3;
       cggk4: // global
           HpAlloc = 32;
           goto cggk1;
       cggk1: // global
           R6 = _sgdWc::P64;
           R5 = _sgdWb::P64;
           R4 = _sgdWa::P64;
           R3 = _sgdW9::P64;
           R2 = _sgdW8::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggk3: // global
           I64[Hp - 24] = sat_sgdWd_info;
           P64[Hp - 8] = _sgdW9::P64;
           P64[Hp] = _sgdWa::P64;
           R2 = _sgdW8::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdWc::P64;
           P64[Sp - 8] = _sgdWb::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.452478972 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info;
         const 0;
 },
 sat_sgdWn_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggkv,
                       label: sat_sgdWn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggkv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggkw; else goto cggkx;
       cggkw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggkx: // global
           I64[Sp - 16] = block_cggkt_info;
           _sgdWk::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgdWk::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggkt() //  [R1]
         { info_tbl: [(cggkt,
                       label: block_cggkt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggkt: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdWo_entry() //  [R1]
         { info_tbl: [(cggkz,
                       label: sat_sgdWo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggkz: // global
           _sgdWo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggkA; else goto cggkB;
       cggkB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cggkD; else goto cggkC;
       cggkD: // global
           HpAlloc = 16;
           goto cggkA;
       cggkA: // global
           R1 = _sgdWo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggkC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdWo::P64;
           _sgdWf::P64 = P64[_sgdWo::P64 + 16];
           _sgdWg::P64 = P64[_sgdWo::P64 + 24];
           I64[Hp - 8] = sat_sgdWn_info;
           P64[Hp] = _sgdWg::P64;
           R2 = _sgdWf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cggkE,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggkE: // global
           _sgdWi::P64 = R6;
           _sgdWh::P64 = R5;
           _sgdWg::P64 = R4;
           _sgdWf::P64 = R3;
           _sgdWe::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cggkF; else goto cggkG;
       cggkG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggkI; else goto cggkH;
       cggkI: // global
           HpAlloc = 32;
           goto cggkF;
       cggkF: // global
           R6 = _sgdWi::P64;
           R5 = _sgdWh::P64;
           R4 = _sgdWg::P64;
           R3 = _sgdWf::P64;
           R2 = _sgdWe::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggkH: // global
           I64[Hp - 24] = sat_sgdWo_info;
           P64[Hp - 8] = _sgdWf::P64;
           P64[Hp] = _sgdWg::P64;
           R2 = _sgdWe::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdWi::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgdWh::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.463294477 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose4_closure" {
     Data.Functor.Compose.$fFoldableCompose4_closure:
         const Data.Functor.Compose.$fFoldableCompose4_info;
 },
 Data.Functor.Compose.$fFoldableCompose4_entry() //  [R2, R3, R4]
         { info_tbl: [(cggl8,
                       label: Data.Functor.Compose.$fFoldableCompose4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggl8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgglf; else goto cgglg;
       cgglf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgglg: // global
           I64[Sp - 16] = block_cggl5_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugglk; else goto cggl6;
       ugglk: // global
           call _cggl5(R1) args: 0, res: 0, upd: 0;
       cggl6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggl5() //  [R1]
         { info_tbl: [(cggl5,
                       label: block_cggl5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggl5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgglj; else goto cggli;
       cgglj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cggli: // global
           _sgdWu::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgdWu::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.469526687 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$clength_closure" {
     Data.Functor.Compose.$fFoldableCompose_$clength_closure:
         const Data.Functor.Compose.$fFoldableCompose_$clength_info;
         const 0;
 },
 sat_sgdWz_entry() //  [R1]
         { info_tbl: [(cgglD,
                       label: sat_sgdWz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgglD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgglE; else goto cgglF;
       cgglE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgglF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose4_closure+3;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgglG,
                       label: Data.Functor.Compose.$fFoldableCompose_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgglG: // global
           _sgdWy::P64 = R4;
           _sgdWx::P64 = R3;
           _sgdWw::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgglH; else goto cgglI;
       cgglI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgglK; else goto cgglJ;
       cgglK: // global
           HpAlloc = 24;
           goto cgglH;
       cgglH: // global
           R4 = _sgdWy::P64;
           R3 = _sgdWx::P64;
           R2 = _sgdWw::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgglJ: // global
           I64[Hp - 16] = sat_sgdWz_info;
           P64[Hp] = _sgdWx::P64;
           R2 = _sgdWw::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgdWy::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = Data.Functor.Compose.$fDataCompose3_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.475371566 UTC

[section ""cstring" . lvl3_rgdPT_bytes" {
     lvl3_rgdPT_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.47733005 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose8_closure" {
     Data.Functor.Compose.$fFoldableCompose8_closure:
         const Data.Functor.Compose.$fFoldableCompose8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose8_entry() //  [R1]
         { info_tbl: [(cggm4,
                       label: Data.Functor.Compose.$fFoldableCompose8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggm4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cggm5; else goto cggm6;
       cggm5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggm6: // global
           (_cgglZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgglZ::I64 == 0) goto cggm1; else goto cggm0;
       cggm1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cggm0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgglZ::I64;
           I64[Sp - 24] = block_cggm2_info;
           R2 = lvl3_rgdPT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cggm2() //  [R1]
         { info_tbl: [(cggm2,
                       label: block_cggm2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggm2: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.483679418 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info;
         const 0;
 },
 sat_sgdWJ_entry() //  [R1]
         { info_tbl: [(cggmI,
                       label: sat_sgdWJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggmI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggmJ; else goto cggmK;
       cggmJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggmK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cggmB_info;
           _sgdWD::P64 = P64[R1 + 16];
           _sgdWF::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgdWD::P64;
           P64[Sp - 24] = _sgdWF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uggmR; else goto cggmC;
       uggmR: // global
           call _cggmB(R1) args: 0, res: 0, upd: 0;
       cggmC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cggmB() //  [R1]
         { info_tbl: [(cggmB,
                       label: block_cggmB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggmB: // global
           _sgdWF::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cggmF; else goto cggmG;
       cggmF: // global
           R1 = _sgdWF::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cggmG: // global
           R3 = P64[R1 + 6];
           R2 = _sgdWF::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdWK_entry() //  [R1, R2, R3]
         { info_tbl: [(cggmT,
                       label: sat_sgdWK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggmT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggmX; else goto cggmW;
       cggmX: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggmW: // global
           _sgdWD::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgdWJ_info;
           P64[Hp - 32] = _sgdWD::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdWL_entry() //  [R1]
         { info_tbl: [(cggmY,
                       label: sat_sgdWL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggmY: // global
           _sgdWL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggmZ; else goto cggn0;
       cggn0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cggn2; else goto cggn1;
       cggn2: // global
           HpAlloc = 16;
           goto cggmZ;
       cggmZ: // global
           R1 = _sgdWL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggn1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdWL::P64;
           _sgdWC::P64 = P64[_sgdWL::P64 + 16];
           _sgdWD::P64 = P64[_sgdWL::P64 + 24];
           I64[Hp - 8] = sat_sgdWK_info;
           P64[Hp] = _sgdWD::P64;
           R2 = _sgdWC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cggn9,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggn9: // global
           _sgdWE::P64 = R5;
           _sgdWD::P64 = R4;
           _sgdWC::P64 = R3;
           _sgdWB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cggna; else goto cggnb;
       cggnb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggnd; else goto cggnc;
       cggnd: // global
           HpAlloc = 32;
           goto cggna;
       cggna: // global
           R5 = _sgdWE::P64;
           R4 = _sgdWD::P64;
           R3 = _sgdWC::P64;
           R2 = _sgdWB::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggnc: // global
           I64[Hp - 24] = sat_sgdWL_info;
           P64[Hp - 8] = _sgdWC::P64;
           P64[Hp] = _sgdWD::P64;
           I64[Sp - 8] = block_cggn3_info;
           R2 = _sgdWB::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgdWE::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cggn3() //  [R1]
         { info_tbl: [(cggn3,
                       label: block_cggn3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggn3: // global
           if (R1 & 7 == 1) goto cggn6; else goto cggn7;
       cggn6: // global
           R1 = Data.Functor.Compose.$fFoldableCompose8_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cggn7: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.497342122 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose5_closure" {
     Data.Functor.Compose.$fFoldableCompose5_closure:
         const Data.Functor.Compose.$fFoldableCompose5_info;
 },
 Data.Functor.Compose.$fFoldableCompose5_entry() //  []
         { info_tbl: [(cggnT,
                       label: Data.Functor.Compose.$fFoldableCompose5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggnT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.502059509 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cnull_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cnull_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cnull_info;
         const 0;
 },
 sat_sgdWT_entry() //  [R1]
         { info_tbl: [(cggo9,
                       label: sat_sgdWT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggo9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggoa; else goto cggob;
       cggoa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose5_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cggoc,
                       label: Data.Functor.Compose.$fFoldableCompose_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggoc: // global
           _sgdWS::P64 = R4;
           _sgdWR::P64 = R3;
           _sgdWQ::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cggod; else goto cggoe;
       cggoe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggog; else goto cggof;
       cggog: // global
           HpAlloc = 24;
           goto cggod;
       cggod: // global
           R4 = _sgdWS::P64;
           R3 = _sgdWR::P64;
           R2 = _sgdWQ::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggof: // global
           I64[Hp - 16] = sat_sgdWT_info;
           P64[Hp] = _sgdWR::P64;
           R2 = _sgdWQ::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdWS::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.508654413 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cproduct_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cproduct_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_info;
         const 0;
 },
 $dMonoid_sgdWX_entry() //  [R1]
         { info_tbl: [(cggoz,
                       label: $dMonoid_sgdWX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggoz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggoA; else goto cggoB;
       cggoA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggoB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgdWY_entry() //  [R1]
         { info_tbl: [(cggoG,
                       label: lvl8_sgdWY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggoG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggoH; else goto cggoI;
       cggoH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggoI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdX0_entry() //  [R1, R2]
         { info_tbl: [(cggoO,
                       label: sat_sgdX0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggoO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggoP; else goto cggoQ;
       cggoP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggoQ: // global
           _sgdWZ::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgdWZ::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cggoR,
                       label: Data.Functor.Compose.$fFoldableCompose_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggoR: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cggoV; else goto cggoU;
       cggoV: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggoU: // global
           I64[Hp - 80] = $dMonoid_sgdWX_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgdWY_info;
           P64[Hp - 40] = R3;
           _cggov::P64 = Hp - 80;
           P64[Hp - 32] = _cggov::P64;
           I64[Hp - 24] = sat_sgdX0_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cggov::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.518954239 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$ctoList_closure" {
     Data.Functor.Compose.$fFoldableCompose_$ctoList_closure:
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_info;
         const 0;
 },
 sat_sgdX4_entry() //  [R1]
         { info_tbl: [(cggpp,
                       label: sat_sgdX4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggpp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggpq; else goto cggpr;
       cggpq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggpr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cggps,
                       label: Data.Functor.Compose.$fFoldableCompose_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggps: // global
           _sgdX3::P64 = R4;
           _sgdX2::P64 = R3;
           _sgdX1::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cggpt; else goto cggpu;
       cggpu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggpw; else goto cggpv;
       cggpw: // global
           HpAlloc = 24;
           goto cggpt;
       cggpt: // global
           R4 = _sgdX3::P64;
           R3 = _sgdX2::P64;
           R2 = _sgdX1::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggpv: // global
           I64[Hp - 16] = sat_sgdX4_info;
           P64[Hp] = _sgdX2::P64;
           R2 = _sgdX1::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdX3::P64;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.527129652 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_closure" {
     Data.Functor.Compose.$fFoldableCompose_closure:
         const Data.Functor.Compose.$fFoldableCompose_info;
         const 0;
 },
 sat_sgdXm_entry() //  [R1, R2]
         { info_tbl: [(cggpQ,
                       label: sat_sgdXm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggpQ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXl_entry() //  [R1, R2]
         { info_tbl: [(cggpY,
                       label: sat_sgdXl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggpY: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXk_entry() //  [R1, R2]
         { info_tbl: [(cggq6,
                       label: sat_sgdXk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggq6: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXj_entry() //  [R1, R2]
         { info_tbl: [(cggqe,
                       label: sat_sgdXj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggqe: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXi_entry() //  [R1, R2, R3]
         { info_tbl: [(cggqm,
                       label: sat_sgdXi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggqm: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXh_entry() //  [R1, R2]
         { info_tbl: [(cggqu,
                       label: sat_sgdXh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggqu: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXg_entry() //  [R1, R2]
         { info_tbl: [(cggqC,
                       label: sat_sgdXg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggqC: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXf_entry() //  [R1, R2]
         { info_tbl: [(cggqK,
                       label: sat_sgdXf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggqK: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXe_entry() //  [R1, R2, R3]
         { info_tbl: [(cggqS,
                       label: sat_sgdXe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggqS: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXd_entry() //  [R1, R2, R3]
         { info_tbl: [(cggr0,
                       label: sat_sgdXd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggr0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggr8,
                       label: sat_sgdXc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggr8: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXb_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggrg,
                       label: sat_sgdXb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggrg: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXa_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggro,
                       label: sat_sgdXa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggro: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggrw,
                       label: sat_sgdX9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggrw: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX8_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggrE,
                       label: sat_sgdX8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggrE: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdX7_entry() //  [R1, R2, R3]
         { info_tbl: [(cggrM,
                       label: sat_sgdX7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggrM: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_entry() //  [R2, R3]
         { info_tbl: [(cggrQ,
                       label: Data.Functor.Compose.$fFoldableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggrQ: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cggrU; else goto cggrT;
       cggrU: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggrT: // global
           I64[Hp - 512] = sat_sgdXm_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sgdXl_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sgdXk_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sgdXj_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sgdXi_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sgdXh_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sgdXg_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sgdXf_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sgdXe_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sgdXd_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sgdXc_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sgdXb_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sgdXa_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sgdX9_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgdX8_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgdX7_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.55927125 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose1_closure" {
     Data.Functor.Compose.$fTraversableCompose1_closure:
         const Data.Functor.Compose.$fTraversableCompose1_info;
 },
 Data.Functor.Compose.$fTraversableCompose1_entry() //  [R2]
         { info_tbl: [(cggt6,
                       label: Data.Functor.Compose.$fTraversableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggt6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.563468714 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure" {
     Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure:
         const Data.Functor.Compose.$fTraversableCompose_$ctraverse_info;
 },
 sat_sgdXu_entry() //  [R1]
         { info_tbl: [(cggtp,
                       label: sat_sgdXu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggtp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggtq; else goto cggtr;
       cggtq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggtr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdXv_entry() //  [R1]
         { info_tbl: [(cggts,
                       label: sat_sgdXv_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggts: // global
           _sgdXv::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cggtt; else goto cggtu;
       cggtu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cggtw; else goto cggtv;
       cggtw: // global
           HpAlloc = 40;
           goto cggtt;
       cggtt: // global
           R1 = _sgdXv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggtv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdXv::P64;
           _sgdXo::P64 = P64[_sgdXv::P64 + 16];
           _sgdXp::P64 = P64[_sgdXv::P64 + 24];
           _sgdXq::P64 = P64[_sgdXv::P64 + 32];
           _sgdXr::P64 = P64[_sgdXv::P64 + 40];
           _sgdXs::P64 = P64[_sgdXv::P64 + 48];
           I64[Hp - 32] = sat_sgdXu_info;
           P64[Hp - 16] = _sgdXp::P64;
           P64[Hp - 8] = _sgdXq::P64;
           P64[Hp] = _sgdXr::P64;
           R2 = _sgdXo::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sgdXq::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgdXs::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cggtz,
                       label: Data.Functor.Compose.$fTraversableCompose_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggtz: // global
           _sgdXs::P64 = R6;
           _sgdXr::P64 = R5;
           _sgdXq::P64 = R4;
           _sgdXp::P64 = R3;
           _sgdXo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cggtA; else goto cggtB;
       cggtB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggtD; else goto cggtC;
       cggtD: // global
           HpAlloc = 56;
           goto cggtA;
       cggtA: // global
           R6 = _sgdXs::P64;
           R5 = _sgdXr::P64;
           R4 = _sgdXq::P64;
           R3 = _sgdXp::P64;
           R2 = _sgdXo::P64;
           R1 = Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggtC: // global
           I64[Hp - 48] = sat_sgdXv_info;
           P64[Hp - 32] = _sgdXo::P64;
           P64[Hp - 24] = _sgdXp::P64;
           P64[Hp - 16] = _sgdXq::P64;
           P64[Hp - 8] = _sgdXr::P64;
           P64[Hp] = _sgdXs::P64;
           I64[Sp - 16] = block_cggtx_info;
           R2 = _sgdXq::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggtx() //  [R1]
         { info_tbl: [(cggtx,
                       label: block_cggtx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggtx: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Compose.$fTraversableCompose1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.574466902 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info;
         const 0;
 },
 sat_sgdXz_entry() //  [R1]
         { info_tbl: [(cggu9,
                       label: sat_sgdXz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggu9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggua; else goto cggub;
       cggua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXy_entry() //  [R1]
         { info_tbl: [(cggug,
                       label: sat_sgdXy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgguh; else goto cggui;
       cgguh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggui: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgguj,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgguj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cggun; else goto cggum;
       cggun: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggum: // global
           I64[Hp - 40] = sat_sgdXz_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdXy_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFoldableCompose_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.582926606 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info;
 },
 sat_sgdXD_entry() //  [R1]
         { info_tbl: [(cgguI,
                       label: sat_sgdXD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgguI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgguJ; else goto cgguK;
       cgguJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgguK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXC_entry() //  [R1]
         { info_tbl: [(cgguP,
                       label: sat_sgdXC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgguP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgguQ; else goto cgguR;
       cgguQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgguR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgguS,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgguS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgguW; else goto cgguV;
       cgguW: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgguV: // global
           I64[Hp - 40] = sat_sgdXD_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdXC_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.59060786 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequenceA_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cggvd,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggvd: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.594385123 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cmapM_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cmapM_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cmapM_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cggvq,
                       label: Data.Functor.Compose.$fTraversableCompose_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggvq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggvr; else goto cggvs;
       cggvr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggvs: // global
           I64[Sp - 40] = block_cggvo_info;
           _sgdXH::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sgdXH::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggvo() //  [R1]
         { info_tbl: [(cggvo,
                       label: block_cggvo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggvo: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.600178598 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequence_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequence_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequence_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cggvK,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggvK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggvL; else goto cggvM;
       cggvL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggvM: // global
           I64[Sp - 32] = block_cggvI_info;
           _sgdXN::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgdXN::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggvI() //  [R1]
         { info_tbl: [(cggvI,
                       label: block_cggvI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggvI: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.607045152 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_closure" {
     Data.Functor.Compose.$fTraversableCompose_closure:
         const Data.Functor.Compose.$fTraversableCompose_info;
         const 0;
 },
 sat_sgdXZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cggw7,
                       label: sat_sgdXZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggw7: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggwf,
                       label: sat_sgdXY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggwf: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXX_entry() //  [R1, R2, R3]
         { info_tbl: [(cggwn,
                       label: sat_sgdXX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggwn: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXW_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggwv,
                       label: sat_sgdXW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggwv: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdXV_entry() //  [R1]
         { info_tbl: [(cggwC,
                       label: sat_sgdXV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggwC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggwD; else goto cggwE;
       cggwD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggwE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdXU_entry() //  [R1]
         { info_tbl: [(cggwJ,
                       label: sat_sgdXU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggwJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggwK; else goto cggwL;
       cggwK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggwL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_entry() //  [R2, R3]
         { info_tbl: [(cggwN,
                       label: Data.Functor.Compose.$fTraversableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggwN: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cggwR; else goto cggwQ;
       cggwR: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggwQ: // global
           I64[Hp - 208] = sat_sgdXZ_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sgdXY_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sgdXX_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sgdXW_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgdXV_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgdXU_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.62284995 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose4_closure" {
     Data.Functor.Compose.$fApplicativeCompose4_closure:
         const Data.Functor.Compose.$fApplicativeCompose4_info;
 },
 sat_sgdY5_entry() //  [R1]
         { info_tbl: [(cggxv,
                       label: sat_sgdY5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggxv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggxw; else goto cggxx;
       cggxw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggxx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose4_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cggxy,
                       label: Data.Functor.Compose.$fApplicativeCompose4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggxy: // global
           _sgdY4::P64 = R6;
           _sgdY3::P64 = R5;
           _sgdY2::P64 = R4;
           _sgdY1::P64 = R3;
           _sgdY0::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cggxz; else goto cggxA;
       cggxA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggxC; else goto cggxB;
       cggxC: // global
           HpAlloc = 32;
           goto cggxz;
       cggxz: // global
           R6 = _sgdY4::P64;
           R5 = _sgdY3::P64;
           R4 = _sgdY2::P64;
           R3 = _sgdY1::P64;
           R2 = _sgdY0::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggxB: // global
           I64[Hp - 24] = sat_sgdY5_info;
           P64[Hp - 8] = _sgdY1::P64;
           P64[Hp] = _sgdY2::P64;
           R2 = _sgdY0::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgdY3::P64;
           P64[Sp - 8] = _sgdY4::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.62946351 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose5_closure" {
     Data.Functor.Compose.$fApplicativeCompose5_closure:
         const Data.Functor.Compose.$fApplicativeCompose5_info;
 },
 sat_sgdYa_entry() //  [R1]
         { info_tbl: [(cggxW,
                       label: sat_sgdYa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggxW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggxX; else goto cggxY;
       cggxX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggxY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose5_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cggxZ,
                       label: Data.Functor.Compose.$fApplicativeCompose5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggxZ: // global
           _sgdY9::P64 = R5;
           _sgdY8::P64 = R4;
           _sgdY7::P64 = R3;
           _sgdY6::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cggy0; else goto cggy1;
       cggy1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggy3; else goto cggy2;
       cggy3: // global
           HpAlloc = 24;
           goto cggy0;
       cggy0: // global
           R5 = _sgdY9::P64;
           R4 = _sgdY8::P64;
           R3 = _sgdY7::P64;
           R2 = _sgdY6::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggy2: // global
           I64[Hp - 16] = sat_sgdYa_info;
           P64[Hp] = _sgdY7::P64;
           R2 = _sgdY6::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdY8::P64;
           P64[Sp - 8] = _sgdY9::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.635524179 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose6_closure" {
     Data.Functor.Compose.$fApplicativeCompose6_closure:
         const Data.Functor.Compose.$fApplicativeCompose6_info;
 },
 sat_sgdYe_entry() //  [R1]
         { info_tbl: [(cggym,
                       label: sat_sgdYe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggym: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggyn; else goto cggyo;
       cggyn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggyo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose6_entry() //  [R2, R3, R4]
         { info_tbl: [(cggyp,
                       label: Data.Functor.Compose.$fApplicativeCompose6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggyp: // global
           _sgdYd::P64 = R4;
           _sgdYc::P64 = R3;
           _sgdYb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cggyq; else goto cggyr;
       cggyr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggyt; else goto cggys;
       cggyt: // global
           HpAlloc = 32;
           goto cggyq;
       cggyq: // global
           R4 = _sgdYd::P64;
           R3 = _sgdYc::P64;
           R2 = _sgdYb::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggys: // global
           I64[Hp - 24] = sat_sgdYe_info;
           P64[Hp - 8] = _sgdYc::P64;
           P64[Hp] = _sgdYd::P64;
           R2 = _sgdYb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.641927119 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure" {
     Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure:
         const Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info;
 },
 sat_sgdYi_entry() //  [R1]
         { info_tbl: [(cggyN,
                       label: sat_sgdYi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggyN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggyO; else goto cggyP;
       cggyO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggyP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdYh_entry() //  [R1]
         { info_tbl: [(cggyU,
                       label: sat_sgdYh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggyU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggyV; else goto cggyW;
       cggyV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggyW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cggyX,
                       label: Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggyX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cggz1; else goto cggz0;
       cggz1: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggz0: // global
           I64[Hp - 40] = sat_sgdYi_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgdYh_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.649186073 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose3_closure" {
     Data.Functor.Compose.$fApplicativeCompose3_closure:
         const Data.Functor.Compose.$fApplicativeCompose3_info;
 },
 Data.Functor.Compose.$fApplicativeCompose3_entry() //  [R3]
         { info_tbl: [(cggzi,
                       label: Data.Functor.Compose.$fApplicativeCompose3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggzi: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.653684769 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose2_closure" {
     Data.Functor.Compose.$fApplicativeCompose2_closure:
         const Data.Functor.Compose.$fApplicativeCompose2_info;
 },
 sat_sgdYs_entry() //  [R1]
         { info_tbl: [(cggzD,
                       label: sat_sgdYs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggzD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggzE; else goto cggzF;
       cggzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cggzB_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cggzB() //  [R1]
         { info_tbl: [(cggzB,
                       label: block_cggzB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggzB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Functor.Compose.$fApplicativeCompose3_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYt_entry() //  [R1]
         { info_tbl: [(cggzL,
                       label: sat_sgdYt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggzL: // global
           _sgdYt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggzM; else goto cggzN;
       cggzN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggzP; else goto cggzO;
       cggzP: // global
           HpAlloc = 24;
           goto cggzM;
       cggzM: // global
           R1 = _sgdYt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggzO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYt::P64;
           _sgdYl::P64 = P64[_sgdYt::P64 + 16];
           _sgdYm::P64 = P64[_sgdYt::P64 + 24];
           _sgdYn::P64 = P64[_sgdYt::P64 + 32];
           I64[Hp - 16] = sat_sgdYs_info;
           P64[Hp] = _sgdYm::P64;
           I64[Sp - 40] = block_cggzJ_info;
           R2 = _sgdYl::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgdYn::P64;
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cggzJ() //  [R1]
         { info_tbl: [(cggzJ,
                       label: block_cggzJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggzJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdYp_entry() //  [R1]
         { info_tbl: [(cggzX,
                       label: sat_sgdYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggzX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggzY; else goto cggzZ;
       cggzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cggA0,
                       label: Data.Functor.Compose.$fApplicativeCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggA0: // global
           _sgdYo::P64 = R5;
           _sgdYn::P64 = R4;
           _sgdYm::P64 = R3;
           _sgdYl::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cggA1; else goto cggA2;
       cggA2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cggA4; else goto cggA3;
       cggA4: // global
           HpAlloc = 64;
           goto cggA1;
       cggA1: // global
           R5 = _sgdYo::P64;
           R4 = _sgdYn::P64;
           R3 = _sgdYm::P64;
           R2 = _sgdYl::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggA3: // global
           I64[Hp - 56] = sat_sgdYt_info;
           P64[Hp - 40] = _sgdYl::P64;
           P64[Hp - 32] = _sgdYm::P64;
           P64[Hp - 24] = _sgdYn::P64;
           I64[Hp - 16] = sat_sgdYp_info;
           P64[Hp] = _sgdYm::P64;
           R2 = _sgdYl::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = _sgdYo::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.667194917 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose1_closure" {
     Data.Functor.Compose.$fApplicativeCompose1_closure:
         const Data.Functor.Compose.$fApplicativeCompose1_info;
 },
 sat_sgdYy_entry() //  [R1]
         { info_tbl: [(cggAD,
                       label: sat_sgdYy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggAD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggAE; else goto cggAF;
       cggAE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggAF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose1_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cggAG,
                       label: Data.Functor.Compose.$fApplicativeCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggAG: // global
           _sgdYx::P64 = R5;
           _sgdYw::P64 = R4;
           _sgdYv::P64 = R3;
           _sgdYu::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cggAH; else goto cggAI;
       cggAI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggAK; else goto cggAJ;
       cggAK: // global
           HpAlloc = 24;
           goto cggAH;
       cggAH: // global
           R5 = _sgdYx::P64;
           R4 = _sgdYw::P64;
           R3 = _sgdYv::P64;
           R2 = _sgdYu::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggAJ: // global
           I64[Hp - 16] = sat_sgdYy_info;
           P64[Hp] = _sgdYv::P64;
           R2 = _sgdYu::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgdYw::P64;
           P64[Sp - 8] = _sgdYx::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.674013829 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_closure" {
     Data.Functor.Compose.$fApplicativeCompose_closure:
         const Data.Functor.Compose.$fApplicativeCompose_info;
 },
 sat_sgdYG_entry() //  [R1, R2, R3]
         { info_tbl: [(cggB4,
                       label: sat_sgdYG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggB4: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose1_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYF_entry() //  [R1, R2, R3]
         { info_tbl: [(cggBc,
                       label: sat_sgdYF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggBc: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggBk,
                       label: sat_sgdYE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggBk: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fApplicativeCompose4_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYD_entry() //  [R1, R2, R3]
         { info_tbl: [(cggBs,
                       label: sat_sgdYD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggBs: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose5_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYC_entry() //  [R1, R2]
         { info_tbl: [(cggBA,
                       label: sat_sgdYC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggBA: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fApplicativeCompose6_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdYB_entry() //  [R1]
         { info_tbl: [(cggBH,
                       label: sat_sgdYB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggBH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggBI; else goto cggBJ;
       cggBI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggBJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cggBL,
                       label: Data.Functor.Compose.$fApplicativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggBL: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cggBP; else goto cggBO;
       cggBP: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggBO: // global
           I64[Hp - 200] = sat_sgdYG_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgdYF_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgdYE_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgdYD_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sgdYC_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgdYB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.688583848 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info;
 },
 sat_sgdYJ_entry() //  [R1]
         { info_tbl: [(cggCs,
                       label: sat_sgdYJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggCs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggCt; else goto cggCu;
       cggCt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggCu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cggCv,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggCv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggCz; else goto cggCy;
       cggCz: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggCy: // global
           I64[Hp - 16] = sat_sgdYJ_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.695728543 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$csome_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$csome_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$csome_info;
 },
 sat_sgdYQ_entry() //  [R1]
         { info_tbl: [(cggD6,
                       label: sat_sgdYQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggD6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggD7; else goto cggD8;
       cggD7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggD8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYR_entry() //  [R1]
         { info_tbl: [(cggD9,
                       label: sat_sgdYR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggD9: // global
           _sgdYR::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cggDa; else goto cggDb;
       cggDb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggDd; else goto cggDc;
       cggDd: // global
           HpAlloc = 24;
           goto cggDa;
       cggDa: // global
           R1 = _sgdYR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYR::P64;
           _sgdYL::P64 = P64[_sgdYR::P64 + 16];
           _sgdYO::P64 = P64[_sgdYR::P64 + 24];
           I64[Hp - 16] = sat_sgdYQ_info;
           P64[Hp] = _sgdYL::P64;
           R2 = _sgdYO::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYS_entry() //  [R1]
         { info_tbl: [(cggDe,
                       label: sat_sgdYS_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggDe: // global
           _sgdYS::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggDf; else goto cggDg;
       cggDg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggDi; else goto cggDh;
       cggDi: // global
           HpAlloc = 32;
           goto cggDf;
       cggDf: // global
           R1 = _sgdYS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggDh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYS::P64;
           _sgdYK::P64 = P64[_sgdYS::P64 + 16];
           _sgdYL::P64 = P64[_sgdYS::P64 + 24];
           _sgdYN::P64 = P64[_sgdYS::P64 + 32];
           _sgdYO::P64 = P64[_sgdYS::P64 + 40];
           I64[Hp - 24] = sat_sgdYR_info;
           P64[Hp - 8] = _sgdYL::P64;
           P64[Hp] = _sgdYO::P64;
           R2 = _sgdYK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgdYN::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgdYP_entry() //  [R1]
         { info_tbl: [(cggDn,
                       label: sat_sgdYP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggDn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggDo; else goto cggDp;
       cggDo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggDp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sgdYN_entry() //  [R1]
         { info_tbl: [(cggDq,
                       label: some_v_sgdYN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggDq: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cggDr; else goto cggDs;
       cggDr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggDs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cggCQ_info;
           _sgdYK::P64 = P64[R1 + 16];
           R2 = _sgdYK::P64;
           P64[Sp - 48] = _sgdYK::P64;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 56;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cggCQ() //  [R1]
         { info_tbl: [(cggCQ,
                       label: block_cggCQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggCQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cggDv; else goto cggDu;
       cggDv: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cggDu: // global
           I64[Hp - 64] = sat_sgdYS_info;
           P64[Hp - 48] = P64[Sp + 8];
           _sgdYL::P64 = P64[Sp + 16];
           P64[Hp - 40] = _sgdYL::P64;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sgdYP_info;
           P64[Hp] = _sgdYL::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cggDw,
                       label: Data.Functor.Compose.$fAlternativeCompose_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggDw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cggDA; else goto cggDz;
       cggDA: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggDz: // global
           I64[Hp - 32] = some_v_sgdYN_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.713505566 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cmany_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cmany_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cmany_info;
 },
 $dApplicative1_sgdYX_entry() //  [R1]
         { info_tbl: [(cggEm,
                       label: $dApplicative1_sgdYX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggEm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggEn; else goto cggEo;
       cggEn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggEo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ0_entry() //  [R1]
         { info_tbl: [(cggEx,
                       label: sat_sgdZ0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggEx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggEy; else goto cggEz;
       cggEy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggEz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdZ1_entry() //  [R1]
         { info_tbl: [(cggEA,
                       label: sat_sgdZ1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggEA: // global
           _sgdZ1::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cggEB; else goto cggEC;
       cggEC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggEE; else goto cggED;
       cggEE: // global
           HpAlloc = 24;
           goto cggEB;
       cggEB: // global
           R1 = _sgdZ1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggED: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdZ1::P64;
           _sgdYU::P64 = P64[_sgdZ1::P64 + 16];
           _sgdYX::P64 = P64[_sgdZ1::P64 + 24];
           I64[Hp - 16] = sat_sgdZ0_info;
           P64[Hp] = _sgdYU::P64;
           R2 = _sgdYX::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYY_entry() //  [R1]
         { info_tbl: [(cggEN,
                       label: sat_sgdYY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggEN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggEO; else goto cggEP;
       cggEO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggEP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgdYZ_entry() //  [R1]
         { info_tbl: [(cggEQ,
                       label: sat_sgdYZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggEQ: // global
           _sgdYZ::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cggER; else goto cggES;
       cggES: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggEU; else goto cggET;
       cggEU: // global
           HpAlloc = 24;
           goto cggER;
       cggER: // global
           R1 = _sgdYZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggET: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYZ::P64;
           _sgdYU::P64 = P64[_sgdYZ::P64 + 16];
           _sgdYV::P64 = P64[_sgdYZ::P64 + 24];
           _sgdYW::P64 = P64[_sgdYZ::P64 + 32];
           _sgdYX::P64 = P64[_sgdYZ::P64 + 40];
           I64[Hp - 16] = sat_sgdYY_info;
           P64[Hp] = _sgdYU::P64;
           R2 = _sgdYX::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgdYV::P64;
           P64[Sp - 24] = _sgdYW::P64;
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_sgdYW_entry() //  [R1]
         { info_tbl: [(cggEV,
                       label: many_v_sgdYW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggEV: // global
           _sgdYW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggEW; else goto cggEX;
       cggEX: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cggEZ; else goto cggEY;
       cggEZ: // global
           HpAlloc = 104;
           goto cggEW;
       cggEW: // global
           R1 = _sgdYW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggEY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgdYW::P64;
           _sgdYT::P64 = P64[_sgdYW::P64 + 16];
           _sgdYU::P64 = P64[_sgdYW::P64 + 24];
           _sgdYV::P64 = P64[_sgdYW::P64 + 32];
           I64[Hp - 96] = $dApplicative1_sgdYX_info;
           P64[Hp - 80] = _sgdYT::P64;
           I64[Hp - 72] = sat_sgdZ1_info;
           P64[Hp - 56] = _sgdYU::P64;
           _cggEi::P64 = Hp - 96;
           P64[Hp - 48] = _cggEi::P64;
           I64[Hp - 40] = sat_sgdYZ_info;
           P64[Hp - 24] = _sgdYU::P64;
           P64[Hp - 16] = _sgdYV::P64;
           P64[Hp - 8] = _sgdYW::P64;
           P64[Hp] = _cggEi::P64;
           R2 = _sgdYT::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cmany_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cggF0,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggF0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cggF4; else goto cggF3;
       cggF4: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggF3: // global
           I64[Hp - 32] = many_v_sgdYW_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.73051619 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_closure" {
     Data.Functor.Compose.$fAlternativeCompose_closure:
         const Data.Functor.Compose.$fAlternativeCompose_info;
 },
 sat_sgdZ8_entry() //  [R1, R2]
         { info_tbl: [(cggFK,
                       label: sat_sgdZ8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggFK: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$cmany_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZ7_entry() //  [R1, R2]
         { info_tbl: [(cggFS,
                       label: sat_sgdZ7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggFS: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZ6_entry() //  [R1]
         { info_tbl: [(cggFZ,
                       label: sat_sgdZ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggFZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggG0; else goto cggG1;
       cggG0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggG1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ5_entry() //  [R1]
         { info_tbl: [(cggG6,
                       label: sat_sgdZ5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggG6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggG7; else goto cggG8;
       cggG7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggG8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgdZ4_entry() //  [R1]
         { info_tbl: [(cggGd,
                       label: sat_sgdZ4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggGd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggGe; else goto cggGf;
       cggGe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggGf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cggGh,
                       label: Data.Functor.Compose.$fAlternativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggGh: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cggGl; else goto cggGk;
       cggGl: // global
           HpAlloc = 176;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggGk: // global
           I64[Hp - 168] = sat_sgdZ8_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           I64[Hp - 144] = sat_sgdZ7_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sgdZ6_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sgdZ5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgdZ4_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 120;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = Hp - 167;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.74385054 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose1_closure" {
     Data.Functor.Compose.$fGeneric1Compose1_closure:
         const Data.Functor.Compose.$fGeneric1Compose1_info;
 },
 Data.Functor.Compose.$fGeneric1Compose1_entry() //  [R2, R3]
         { info_tbl: [(cggGS,
                       label: Data.Functor.Compose.$fGeneric1Compose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggGS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cggGT; else goto cggGU;
       cggGT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggGU: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Generics.$fGeneric1:.:2_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.747482064 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose3_closure" {
     Data.Functor.Compose.$fGeneric1Compose3_closure:
         const Data.Functor.Compose.$fGeneric1Compose3_info;
 },
 Data.Functor.Compose.$fGeneric1Compose3_entry() //  [R2]
         { info_tbl: [(cggH4,
                       label: Data.Functor.Compose.$fGeneric1Compose3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggH4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.750661722 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose2_closure" {
     Data.Functor.Compose.$fGeneric1Compose2_closure:
         const Data.Functor.Compose.$fGeneric1Compose2_info;
 },
 Data.Functor.Compose.$fGeneric1Compose2_entry() //  [R2, R3]
         { info_tbl: [(cggHf,
                       label: Data.Functor.Compose.$fGeneric1Compose2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggHf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cggHg; else goto cggHh;
       cggHg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggHh: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Data.Functor.Compose.$fGeneric1Compose3_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.75458638 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose_closure" {
     Data.Functor.Compose.$fGeneric1Compose_closure:
         const Data.Functor.Compose.$fGeneric1Compose_info;
 },
 sat_sgdZg_entry() //  [R1, R2]
         { info_tbl: [(cggHw,
                       label: sat_sgdZg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggHw: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgdZf_entry() //  [R1, R2]
         { info_tbl: [(cggHE,
                       label: sat_sgdZf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggHE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose2_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fGeneric1Compose_entry() //  [R2]
         { info_tbl: [(cggHI,
                       label: Data.Functor.Compose.$fGeneric1Compose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggHI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggHM; else goto cggHL;
       cggHM: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggHL: // global
           I64[Hp - 48] = sat_sgdZg_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sgdZf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Generics.C:Generic1_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.761637806 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose1_closure" {
     Data.Functor.Compose.$fGenericCompose1_closure:
         const Data.Functor.Compose.$fGenericCompose1_info;
 },
 Data.Functor.Compose.$fGenericCompose1_entry() //  [R2]
         { info_tbl: [(cggI4,
                       label: Data.Functor.Compose.$fGenericCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggI4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.764899362 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose2_closure" {
     Data.Functor.Compose.$fGenericCompose2_closure:
         const Data.Functor.Compose.$fGenericCompose2_info;
 },
 Data.Functor.Compose.$fGenericCompose2_entry() //  [R2]
         { info_tbl: [(cggIf,
                       label: Data.Functor.Compose.$fGenericCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggIf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.768745197 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose_closure" {
     Data.Functor.Compose.$fGenericCompose_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Compose.$fGenericCompose2_closure+1;
         const Data.Functor.Compose.$fGenericCompose1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.77098678 UTC

[section ""data" . Data.Functor.Compose.getCompose1_closure" {
     Data.Functor.Compose.getCompose1_closure:
         const Data.Functor.Compose.getCompose1_info;
 },
 Data.Functor.Compose.getCompose1_entry() //  [R2]
         { info_tbl: [(cggIr,
                       label: Data.Functor.Compose.getCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggIr: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.774329877 UTC

[section ""data" . Data.Functor.Compose.getCompose_closure" {
     Data.Functor.Compose.getCompose_closure:
         const Data.Functor.Compose.getCompose_info;
 },
 Data.Functor.Compose.getCompose_entry() //  [R2]
         { info_tbl: [(cggIC,
                       label: Data.Functor.Compose.getCompose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggIC: // global
           R2 = R2;
           call Data.Functor.Compose.getCompose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.778002242 UTC

[section ""cstring" . $cCompose1_rgdPU_bytes" {
     $cCompose1_rgdPU_bytes:
         I8[] [103,101,116,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.779819325 UTC

[section ""data" . $cCompose2_rgdPV_closure" {
     $cCompose2_rgdPV_closure:
         const $cCompose2_rgdPV_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose2_rgdPV_entry() //  [R1]
         { info_tbl: [(cggIQ,
                       label: $cCompose2_rgdPV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggIQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggIR; else goto cggIS;
       cggIR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggIS: // global
           (_cggIN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cggIN::I64 == 0) goto cggIP; else goto cggIO;
       cggIP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cggIO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cggIN::I64;
           R2 = $cCompose1_rgdPU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.78364438 UTC

[section ""data" . $cCompose3_rgdPW_closure" {
     $cCompose3_rgdPW_closure:
         const :_con_info;
         const $cCompose2_rgdPV_closure;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.786250874 UTC

[section ""data" . go61_rgdPX_closure" {
     go61_rgdPX_closure:
         const go61_rgdPX_info;
         const 0;
 },
 go61_rgdPX_entry() //  [R2, R3]
         { info_tbl: [(cggJc,
                       label: go61_rgdPX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggJd; else goto uggJQ;
       cggJd: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgdPX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uggJQ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cggJ2() args: 0, res: 0, upd: 0;
     }
 },
 _cggJ2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJ2: // global
           _sgdZk::P64 = P64[Sp];
           I64[Sp] = block_cggJ5_info;
           R1 = _sgdZk::P64;
           if (R1 & 7 != 0) goto uggJU; else goto cggJ6;
       uggJU: // global
           call _cggJ5(R1) args: 0, res: 0, upd: 0;
       cggJ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggJ5() //  [R1]
         { info_tbl: [(cggJ5,
                       label: block_cggJ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJ5: // global
           if (R1 & 7 == 1) goto uggJR; else goto cggJa;
       uggJR: // global
           Sp = Sp + 16;
           call _cggJs() args: 0, res: 0, upd: 0;
       cggJa: // global
           I64[Sp - 8] = block_cggJk_info;
           _sgdZn::P64 = P64[R1 + 6];
           _sgdZo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgdZo::P64;
           P64[Sp + 8] = _sgdZn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uggJV; else goto cggJm;
       uggJV: // global
           call _cggJk(R1) args: 0, res: 0, upd: 0;
       cggJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggJk() //  [R1]
         { info_tbl: [(cggJk,
                       label: block_cggJk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJk: // global
           if (R1 & 7 == 1) goto uggJS; else goto cggJx;
       uggJS: // global
           Sp = Sp + 24;
           call _cggJs() args: 0, res: 0, upd: 0;
       cggJx: // global
           I64[Sp - 8] = block_cggJv_info;
           _sgdZq::P64 = P64[R1 + 6];
           _sgdZr::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgdZr::P64;
           P64[Sp + 16] = _sgdZq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uggJY; else goto cggJy;
       uggJY: // global
           call _cggJv(R1) args: 0, res: 0, upd: 0;
       cggJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggJs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJs: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cggJv() //  [R1]
         { info_tbl: [(cggJv,
                       label: block_cggJv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJv: // global
           I64[Sp] = block_cggJC_info;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggJC() //  [R1]
         { info_tbl: [(cggJC,
                       label: block_cggJC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggJC: // global
           if (R1 & 7 == 1) goto cggJJ; else goto cggJN;
       cggJJ: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cggJ2() args: 0, res: 0, upd: 0;
       cggJN: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.799321274 UTC

[section ""data" . $cCompose4_rgdPY_closure" {
     $cCompose4_rgdPY_closure:
         const Data.Data.AlgConstr_con_info;
         const $cCompose5_rgdPZ_closure;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose5_closure" {
     Data.Functor.Compose.$fDataCompose5_closure:
         const :_con_info;
         const Data.Functor.Compose.$cCompose_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose4_closure" {
     Data.Functor.Compose.$fDataCompose4_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Compose.$fDataCompose5_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$tCompose_closure" {
     Data.Functor.Compose.$tCompose_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$fDataCompose4_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$cCompose_closure" {
     Data.Functor.Compose.$cCompose_closure:
         const Data.Data.Constr_con_info;
         const $cCompose4_rgdPY_closure+1;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const $cCompose3_rgdPW_closure+2;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Compose.$tCompose_closure+1;
         const 0;
 },
 section ""data" . $cCompose5_rgdPZ_closure" {
     $cCompose5_rgdPZ_closure:
         const $cCompose5_rgdPZ_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose5_rgdPZ_entry() //  [R1]
         { info_tbl: [(cggKF,
                       label: $cCompose5_rgdPZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggKF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggKG; else goto cggKH;
       cggKG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggKH: // global
           (_cggKC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cggKC::I64 == 0) goto cggKE; else goto cggKD;
       cggKE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cggKD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cggKC::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Compose.$fDataCompose5_closure+2;
           Sp = Sp - 16;
           call go61_rgdPX_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.807454407 UTC

[section ""cstring" . Data.Functor.Compose.$trModule4_bytes" {
     Data.Functor.Compose.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.809127073 UTC

[section ""data" . Data.Functor.Compose.$trModule3_closure" {
     Data.Functor.Compose.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.81080309 UTC

[section ""cstring" . Data.Functor.Compose.$trModule2_bytes" {
     Data.Functor.Compose.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.812378343 UTC

[section ""data" . Data.Functor.Compose.$trModule1_closure" {
     Data.Functor.Compose.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.814276144 UTC

[section ""data" . Data.Functor.Compose.$trModule_closure" {
     Data.Functor.Compose.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Compose.$trModule3_closure+1;
         const Data.Functor.Compose.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.815950714 UTC

[section ""data" . $krep_rgdQ0_closure" {
     $krep_rgdQ0_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.817638197 UTC

[section ""data" . $krep1_rgdQ1_closure" {
     $krep1_rgdQ1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.819250482 UTC

[section ""data" . $krep2_rgdQ2_closure" {
     $krep2_rgdQ2_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.820912834 UTC

[section ""data" . $krep3_rgdQ3_closure" {
     $krep3_rgdQ3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgdQ2_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.822635056 UTC

[section ""data" . $krep4_rgdQ4_closure" {
     $krep4_rgdQ4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep2_rgdQ2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.824308963 UTC

[section ""data" . $krep5_rgdQ5_closure" {
     $krep5_rgdQ5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rgdQ4_closure+4;
         const $krep1_rgdQ1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.826401779 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose9_closure" {
     Data.Functor.Compose.$fDataCompose9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgdQ3_closure+4;
         const $krep5_rgdQ5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.828676261 UTC

[section ""data" . $krep6_rgdQ6_closure" {
     $krep6_rgdQ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.830348416 UTC

[section ""data" . $krep7_rgdQ7_closure" {
     $krep7_rgdQ7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.831989744 UTC

[section ""data" . $krep8_rgdQ8_closure" {
     $krep8_rgdQ8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.833901246 UTC

[section ""data" . $krep9_rgdQ9_closure" {
     $krep9_rgdQ9_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep8_rgdQ8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.835612324 UTC

[section ""data" . $krep10_rgdQa_closure" {
     $krep10_rgdQa_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep9_rgdQ9_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.837281439 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose10_closure" {
     Data.Functor.Compose.$fDataCompose10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$fDataCompose7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.838936063 UTC

[section ""data" . Data.Functor.Compose.$tcCompose_closure" {
     Data.Functor.Compose.$tcCompose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$fDataCompose10_closure+1;
         const Data.Functor.Compose.$fDataCompose9_closure+4;
         const 6729400645769595507;
         const 7487202375031942550;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.840768785 UTC

[section ""data" . $krep11_rgdQb_closure" {
     $krep11_rgdQb_closure:
         const :_con_info;
         const $krep8_rgdQ8_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.842473532 UTC

[section ""data" . $krep12_rgdQc_closure" {
     $krep12_rgdQc_closure:
         const :_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep11_rgdQb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.844115357 UTC

[section ""data" . $krep13_rgdQd_closure" {
     $krep13_rgdQd_closure:
         const :_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep12_rgdQc_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.845858847 UTC

[section ""data" . $krep14_rgdQe_closure" {
     $krep14_rgdQe_closure:
         const :_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep13_rgdQd_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.847549153 UTC

[section ""data" . $krep15_rgdQf_closure" {
     $krep15_rgdQf_closure:
         const :_con_info;
         const $krep2_rgdQ2_closure+2;
         const $krep14_rgdQe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.849418315 UTC

[section ""data" . $krep16_rgdQg_closure" {
     $krep16_rgdQg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Compose.$tcCompose_closure+1;
         const $krep15_rgdQf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.85116708 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose1_closure" {
     Data.Functor.Compose.$tc'Compose1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rgdQa_closure+3;
         const $krep16_rgdQg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.853944747 UTC

[section ""cstring" . Data.Functor.Compose.$tc'Compose3_bytes" {
     Data.Functor.Compose.$tc'Compose3_bytes:
         I8[] [39,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.855739328 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose2_closure" {
     Data.Functor.Compose.$tc'Compose2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$tc'Compose3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.857403946 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose_closure" {
     Data.Functor.Compose.$tc'Compose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$tc'Compose2_closure+1;
         const Data.Functor.Compose.$tc'Compose1_closure+4;
         const 7236514282653524344;
         const 13791541438620948974;
         const 5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.859902259 UTC

[section ""data" . Data.Functor.Compose.$w$cp1Data_closure" {
     Data.Functor.Compose.$w$cp1Data_closure:
         const Data.Functor.Compose.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Compose.$w$cp1Data_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cggLC,
                       label: Data.Functor.Compose.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggLC: // global
           _sgdZD::P64 = R6;
           _sgdZC::P64 = R5;
           _sgdZB::P64 = R4;
           _sgdZA::P64 = R3;
           _sgdZz::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cggLG; else goto cggLH;
       cggLH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cggLJ; else goto cggLI;
       cggLJ: // global
           HpAlloc = 80;
           goto cggLG;
       cggLG: // global
           R6 = _sgdZD::P64;
           R5 = _sgdZC::P64;
           R4 = _sgdZB::P64;
           R3 = _sgdZA::P64;
           R2 = _sgdZz::P64;
           R1 = Data.Functor.Compose.$w$cp1Data_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggLI: // global
           I64[Hp - 72] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 64] = _sgdZD::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sgdZC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           I64[Sp - 32] = block_cggLv_info;
           R6 = 2;
           R5 = Data.Functor.Compose.$fDataCompose10_closure+1;
           R4 = Data.Functor.Compose.$trModule_closure+1;
           R3 = 7487202375031942550;
           R2 = 6729400645769595507;
           P64[Sp - 48] = Data.Functor.Compose.$fDataCompose9_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sgdZz::P64;
           P64[Sp - 16] = _sgdZA::P64;
           P64[Sp - 8] = _sgdZB::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cggLv() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cggLv,
                       label: block_cggLv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggLv: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cggLw() args: 0, res: 0, upd: 0;
     }
 },
 _cggLw() //  []
         { info_tbl: [(cggLw,
                       label: block_cggLw_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggLw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cggLM; else goto cggLL;
       cggLM: // global
           HpAlloc = 48;
           I64[Sp] = block_cggLw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cggLL: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cggLA_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggLA() //  [R1]
         { info_tbl: [(cggLA,
                       label: block_cggLA_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggLA: // global
           I64[Sp] = block_cggLF_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggLF() //  [R1]
         { info_tbl: [(cggLF,
                       label: block_cggLF_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggLF: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.871522164 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose8_closure" {
     Data.Functor.Compose.$fDataCompose8_closure:
         const Data.Functor.Compose.$fDataCompose8_info;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose8_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cggMo,
                       label: Data.Functor.Compose.$fDataCompose8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggMo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.875554938 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose2_closure" {
     Data.Functor.Compose.$fDataCompose2_closure:
         const Data.Functor.Compose.$fDataCompose2_info;
 },
 Data.Functor.Compose.$fDataCompose2_entry() //  [R2]
         { info_tbl: [(cggMz,
                       label: Data.Functor.Compose.$fDataCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggMz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.878784117 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose1_closure" {
     Data.Functor.Compose.$fDataCompose1_closure:
         const (,)_con_info;
         const Data.Functor.Compose.$fDataCompose2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.882653043 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMp_closure" {
     Data.Functor.Compose.$w$cgmapMp_closure:
         const Data.Functor.Compose.$w$cgmapMp_info;
 },
 lvl8_sge02_entry() //  [R1]
         { info_tbl: [(cggMP,
                       label: lvl8_sge02_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggMP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggMQ; else goto cggMR;
       cggMQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggMR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge0p_entry() //  [R1, R2]
         { info_tbl: [(cggN4,
                       label: sat_sge0p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggN4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggN5; else goto cggN6;
       cggN5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggN6: // global
           I64[Sp - 24] = block_cggN1_info;
           _sge02::P64 = P64[R1 + 7];
           _sge03::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sge02::P64;
           P64[Sp - 8] = _sge03::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uggNo; else goto cggN2;
       uggNo: // global
           call _cggN1(R1) args: 0, res: 0, upd: 0;
       cggN2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggN1() //  [R1]
         { info_tbl: [(cggN1,
                       label: block_cggN1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggN1: // global
           I64[Sp - 8] = block_cggN9_info;
           _sge0m::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge0m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uggNn; else goto cggNb;
       uggNn: // global
           call _cggN9(R1) args: 0, res: 0, upd: 0;
       cggNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggN9() //  [R1]
         { info_tbl: [(cggN9,
                       label: block_cggN9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggN9: // global
           if (R1 & 7 == 1) goto cggNh; else goto cggNl;
       cggNh: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cggNl: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0h_entry() //  [R1]
         { info_tbl: [(cggNK,
                       label: sat_sge0h_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggNK: // global
           _sge0h::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cggNL; else goto cggNM;
       cggNM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggNO; else goto cggNN;
       cggNO: // global
           HpAlloc = 56;
           goto cggNL;
       cggNL: // global
           R1 = _sge0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggNN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0h::P64;
           _sge01::P64 = P64[_sge0h::P64 + 16];
           _sge03::P64 = P64[_sge0h::P64 + 24];
           _sge08::P64 = P64[_sge0h::P64 + 32];
           _sge09::P64 = P64[_sge0h::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge08::P64;
           P64[Hp - 24] = _sge01::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sge09::P64;
           R2 = _sge03::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge0d_entry() //  [R1, R2]
         { info_tbl: [(cggO0,
                       label: sat_sge0d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggO0: // global
           _sge0a::P64 = R2;
           _sge0d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cggO1; else goto cggO2;
       cggO2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggO4; else goto cggO3;
       cggO4: // global
           HpAlloc = 56;
           goto cggO1;
       cggO1: // global
           R2 = _sge0a::P64;
           R1 = _sge0d::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggO3: // global
           _sge03::P64 = P64[_sge0d::P64 + 7];
           _sge08::P64 = P64[_sge0d::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge08::P64;
           P64[Hp - 24] = _sge0a::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge03::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0e_entry() //  [R1]
         { info_tbl: [(cggO5,
                       label: sat_sge0e_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggO5: // global
           _sge0e::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggO6; else goto cggO7;
       cggO7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggO9; else goto cggO8;
       cggO9: // global
           HpAlloc = 24;
           goto cggO6;
       cggO6: // global
           R1 = _sge0e::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0e::P64;
           _sge03::P64 = P64[_sge0e::P64 + 16];
           _sge04::P64 = P64[_sge0e::P64 + 24];
           _sge08::P64 = P64[_sge0e::P64 + 32];
           I64[Hp - 16] = sat_sge0d_info;
           P64[Hp - 8] = _sge03::P64;
           P64[Hp] = _sge08::P64;
           R2 = _sge03::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sge04::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sge0i_entry() //  [R1, R2]
         { info_tbl: [(cggOa,
                       label: sat_sge0i_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggOa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cggOb; else goto cggOc;
       cggOb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggOc: // global
           I64[Sp - 40] = block_cggNz_info;
           _sgdZZ::P64 = P64[R1 + 7];
           _sge01::P64 = P64[R1 + 15];
           _sge03::P64 = P64[R1 + 23];
           _sge04::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgdZZ::P64;
           P64[Sp - 24] = _sge01::P64;
           P64[Sp - 16] = _sge03::P64;
           P64[Sp - 8] = _sge04::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uggOg; else goto cggNA;
       uggOg: // global
           call _cggNz(R1) args: 0, res: 0, upd: 0;
       cggNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggNz() //  [R1]
         { info_tbl: [(cggNz,
                       label: block_cggNz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggNz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cggOf; else goto cggOe;
       cggOf: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cggOe: // global
           _sge08::P64 = P64[R1 + 7];
           _sge09::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sge0h_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sge03::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sge03::P64;
           P64[Hp - 48] = _sge08::P64;
           P64[Hp - 40] = _sge09::P64;
           I64[Hp - 32] = sat_sge0e_info;
           P64[Hp - 16] = _sge03::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sge08::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sge05_entry() //  [R1]
         { info_tbl: [(cggOl,
                       label: sat_sge05_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggOl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggOm; else goto cggOn;
       cggOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge0j_entry() //  [R1]
         { info_tbl: [(cggOo,
                       label: sat_sge0j_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggOo: // global
           _sge0j::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggOp; else goto cggOq;
       cggOq: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cggOs; else goto cggOr;
       cggOs: // global
           HpAlloc = 104;
           goto cggOp;
       cggOp: // global
           R1 = _sge0j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggOr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge0j::P64;
           _sgdZY::P64 = P64[_sge0j::P64 + 16];
           _sgdZZ::P64 = P64[_sge0j::P64 + 24];
           _sge00::P64 = P64[_sge0j::P64 + 32];
           _sge01::P64 = P64[_sge0j::P64 + 40];
           _sge03::P64 = P64[_sge0j::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sge00::P64;
           P64[Hp - 72] = _sgdZY::P64;
           P64[Hp - 64] = _sge01::P64;
           I64[Hp - 56] = sat_sge0i_info;
           P64[Hp - 48] = _sgdZZ::P64;
           P64[Hp - 40] = _sge01::P64;
           P64[Hp - 32] = _sge03::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sge05_info;
           P64[Hp] = _sge03::P64;
           R2 = _sge03::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cggOt,
                       label: Data.Functor.Compose.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggOt: // global
           _sge01::P64 = R5;
           _sge00::P64 = R4;
           _sgdZZ::P64 = R3;
           _sgdZY::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cggOu; else goto cggOv;
       cggOv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggOx; else goto cggOw;
       cggOx: // global
           HpAlloc = 24;
           goto cggOu;
       cggOu: // global
           R5 = _sge01::P64;
           R4 = _sge00::P64;
           R3 = _sgdZZ::P64;
           R2 = _sgdZY::P64;
           R1 = Data.Functor.Compose.$w$cgmapMp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggOw: // global
           I64[Hp - 16] = lvl8_sge02_info;
           P64[Hp] = _sgdZZ::P64;
           I64[Sp - 48] = block_cggMS_info;
           R2 = _sgdZZ::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgdZY::P64;
           P64[Sp - 24] = _sgdZZ::P64;
           P64[Sp - 16] = _sge00::P64;
           P64[Sp - 8] = _sge01::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggMS() //  [R1]
         { info_tbl: [(cggMS,
                       label: block_cggMS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggMS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cggOA; else goto cggOz;
       cggOA: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cggOz: // global
           I64[Hp - 72] = sat_sge0p_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sge0j_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.913062902 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMp_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMp_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMp_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggPP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_entry() //  []
         { info_tbl: [(cggPT,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggPT: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.91852669 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapM_closure" {
     Data.Functor.Compose.$w$cgmapM_closure:
         const Data.Functor.Compose.$w$cgmapM_info;
 },
 sat_sge0I_entry() //  [R1, R2]
         { info_tbl: [(cggQi,
                       label: sat_sge0I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggQi: // global
           _sge0G::P64 = R2;
           _sge0I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cggQj; else goto cggQk;
       cggQk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cggQm; else goto cggQl;
       cggQm: // global
           HpAlloc = 32;
           goto cggQj;
       cggQj: // global
           R2 = _sge0G::P64;
           R1 = _sge0I::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggQl: // global
           _sge0A::P64 = P64[_sge0I::P64 + 7];
           _sge0F::P64 = P64[_sge0I::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sge0F::P64;
           P64[Hp] = _sge0G::P64;
           R2 = _sge0A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge0J_entry() //  [R1, R2]
         { info_tbl: [(cggQn,
                       label: sat_sge0J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggQn: // global
           _sge0F::P64 = R2;
           _sge0J::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cggQo; else goto cggQp;
       cggQp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggQr; else goto cggQq;
       cggQr: // global
           HpAlloc = 24;
           goto cggQo;
       cggQo: // global
           R2 = _sge0F::P64;
           R1 = _sge0J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggQq: // global
           _sge0A::P64 = P64[_sge0J::P64 + 7];
           _sge0D::P64 = P64[_sge0J::P64 + 15];
           I64[Hp - 16] = sat_sge0I_info;
           P64[Hp - 8] = _sge0A::P64;
           P64[Hp] = _sge0F::P64;
           R2 = _sge0A::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sge0D::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sge0E_entry() //  [R1]
         { info_tbl: [(cggQw,
                       label: sat_sge0E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggQw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggQx; else goto cggQy;
       cggQx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggQy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cggQz,
                       label: Data.Functor.Compose.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggQz: // global
           _sge0C::P64 = R5;
           _sge0B::P64 = R4;
           _sge0A::P64 = R3;
           _sge0z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cggQA; else goto cggQB;
       cggQB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cggQD; else goto cggQC;
       cggQD: // global
           HpAlloc = 88;
           goto cggQA;
       cggQA: // global
           R5 = _sge0C::P64;
           R4 = _sge0B::P64;
           R3 = _sge0A::P64;
           R2 = _sge0z::P64;
           R1 = Data.Functor.Compose.$w$cgmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggQC: // global
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = _sge0B::P64;
           P64[Hp - 56] = _sge0z::P64;
           P64[Hp - 48] = _sge0C::P64;
           I64[Hp - 40] = sat_sge0J_info;
           P64[Hp - 32] = _sge0A::P64;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = sat_sge0E_info;
           P64[Hp] = _sge0A::P64;
           R2 = _sge0A::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.929072642 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapM_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapM_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapM_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggR1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_entry() //  []
         { info_tbl: [(cggR5,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggR5: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.936606941 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMo_closure" {
     Data.Functor.Compose.$w$cgmapMo_closure:
         const Data.Functor.Compose.$w$cgmapMo_info;
 },
 lvl8_sge0X_entry() //  [R1]
         { info_tbl: [(cggRm,
                       label: lvl8_sge0X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggRm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggRn; else goto cggRo;
       cggRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1n_entry() //  [R1, R2]
         { info_tbl: [(cggRB,
                       label: sat_sge1n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggRB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggRC; else goto cggRD;
       cggRC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggRD: // global
           I64[Sp - 24] = block_cggRy_info;
           _sge0X::P64 = P64[R1 + 7];
           _sge0Y::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sge0X::P64;
           P64[Sp - 8] = _sge0Y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uggRV; else goto cggRz;
       uggRV: // global
           call _cggRy(R1) args: 0, res: 0, upd: 0;
       cggRz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggRy() //  [R1]
         { info_tbl: [(cggRy,
                       label: block_cggRy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggRy: // global
           I64[Sp - 8] = block_cggRG_info;
           _sge1k::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge1k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uggRU; else goto cggRI;
       uggRU: // global
           call _cggRG(R1) args: 0, res: 0, upd: 0;
       cggRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggRG() //  [R1]
         { info_tbl: [(cggRG,
                       label: block_cggRG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggRG: // global
           if (R1 & 7 == 1) goto cggRO; else goto cggRS;
       cggRO: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cggRS: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge1d_entry() //  [R1]
         { info_tbl: [(cggSm,
                       label: sat_sge1d_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggSm: // global
           _sge1d::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cggSn; else goto cggSo;
       cggSo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggSq; else goto cggSp;
       cggSq: // global
           HpAlloc = 56;
           goto cggSn;
       cggSn: // global
           R1 = _sge1d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggSp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1d::P64;
           _sge0W::P64 = P64[_sge1d::P64 + 16];
           _sge0Y::P64 = P64[_sge1d::P64 + 24];
           _sge13::P64 = P64[_sge1d::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge0W::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sge0Y::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge19_entry() //  [R1, R2]
         { info_tbl: [(cggSC,
                       label: sat_sge19_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggSC: // global
           _sge16::P64 = R2;
           _sge19::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cggSD; else goto cggSE;
       cggSE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggSG; else goto cggSF;
       cggSG: // global
           HpAlloc = 56;
           goto cggSD;
       cggSD: // global
           R2 = _sge16::P64;
           R1 = _sge19::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggSF: // global
           _sge0Y::P64 = P64[_sge19::P64 + 7];
           _sge13::P64 = P64[_sge19::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge16::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge0Y::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge1a_entry() //  [R1]
         { info_tbl: [(cggSH,
                       label: sat_sge1a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggSH: // global
           _sge1a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggSI; else goto cggSJ;
       cggSJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggSL; else goto cggSK;
       cggSL: // global
           HpAlloc = 24;
           goto cggSI;
       cggSI: // global
           R1 = _sge1a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggSK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1a::P64;
           _sge0Y::P64 = P64[_sge1a::P64 + 16];
           _sge0Z::P64 = P64[_sge1a::P64 + 24];
           _sge13::P64 = P64[_sge1a::P64 + 32];
           I64[Hp - 16] = sat_sge19_info;
           P64[Hp - 8] = _sge0Y::P64;
           P64[Hp] = _sge13::P64;
           R2 = _sge0Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sge0Z::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sge1g_entry() //  [R1, R2]
         { info_tbl: [(cggSM,
                       label: sat_sge1g_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggSM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cggSN; else goto cggSO;
       cggSN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cggSO: // global
           I64[Sp - 40] = block_cggS6_info;
           _sge0U::P64 = P64[R1 + 7];
           _sge0W::P64 = P64[R1 + 15];
           _sge0Y::P64 = P64[R1 + 23];
           _sge0Z::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sge0U::P64;
           P64[Sp - 24] = _sge0W::P64;
           P64[Sp - 16] = _sge0Y::P64;
           P64[Sp - 8] = _sge0Z::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uggT5; else goto cggS7;
       uggT5: // global
           call _cggS6(R1) args: 0, res: 0, upd: 0;
       cggS7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggS6() //  [R1]
         { info_tbl: [(cggS6,
                       label: block_cggS6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggS6: // global
           I64[Sp - 8] = block_cggSb_info;
           _sge13::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sge13::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uggT4; else goto cggSc;
       uggT4: // global
           call _cggSb(R1) args: 0, res: 0, upd: 0;
       cggSc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggSb() //  [R1]
         { info_tbl: [(cggSb,
                       label: block_cggSb_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggSb: // global
           _sge0W::P64 = P64[Sp + 24];
           _sge0Y::P64 = P64[Sp + 32];
           _sge13::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cggSR; else goto cggSV;
       cggSR: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cggSU; else goto cggST;
       cggSU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cggST: // global
           I64[Hp - 72] = sat_sge1d_info;
           P64[Hp - 56] = _sge0W::P64;
           P64[Hp - 48] = _sge0Y::P64;
           P64[Hp - 40] = _sge13::P64;
           I64[Hp - 32] = sat_sge1a_info;
           P64[Hp - 16] = _sge0Y::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sge13::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cggSV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cggT0; else goto cggSZ;
       cggT0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cggSZ: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sge13::P64;
           P64[Hp - 24] = _sge0W::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sge0Y::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sge10_entry() //  [R1]
         { info_tbl: [(cggTa,
                       label: sat_sge10_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggTa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggTb; else goto cggTc;
       cggTb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggTc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sge1h_entry() //  [R1]
         { info_tbl: [(cggTd,
                       label: sat_sge1h_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggTd: // global
           _sge1h::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cggTe; else goto cggTf;
       cggTf: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cggTh; else goto cggTg;
       cggTh: // global
           HpAlloc = 104;
           goto cggTe;
       cggTe: // global
           R1 = _sge1h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggTg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sge1h::P64;
           _sge0T::P64 = P64[_sge1h::P64 + 16];
           _sge0U::P64 = P64[_sge1h::P64 + 24];
           _sge0V::P64 = P64[_sge1h::P64 + 32];
           _sge0W::P64 = P64[_sge1h::P64 + 40];
           _sge0Y::P64 = P64[_sge1h::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sge0V::P64;
           P64[Hp - 72] = _sge0T::P64;
           P64[Hp - 64] = _sge0W::P64;
           I64[Hp - 56] = sat_sge1g_info;
           P64[Hp - 48] = _sge0U::P64;
           P64[Hp - 40] = _sge0W::P64;
           P64[Hp - 32] = _sge0Y::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sge10_info;
           P64[Hp] = _sge0Y::P64;
           R2 = _sge0Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cggTi,
                       label: Data.Functor.Compose.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggTi: // global
           _sge0W::P64 = R5;
           _sge0V::P64 = R4;
           _sge0U::P64 = R3;
           _sge0T::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cggTj; else goto cggTk;
       cggTk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggTm; else goto cggTl;
       cggTm: // global
           HpAlloc = 24;
           goto cggTj;
       cggTj: // global
           R5 = _sge0W::P64;
           R4 = _sge0V::P64;
           R3 = _sge0U::P64;
           R2 = _sge0T::P64;
           R1 = Data.Functor.Compose.$w$cgmapMo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggTl: // global
           I64[Hp - 16] = lvl8_sge0X_info;
           P64[Hp] = _sge0U::P64;
           I64[Sp - 48] = block_cggRp_info;
           R2 = _sge0U::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sge0T::P64;
           P64[Sp - 24] = _sge0U::P64;
           P64[Sp - 16] = _sge0V::P64;
           P64[Sp - 8] = _sge0W::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cggRp() //  [R1]
         { info_tbl: [(cggRp,
                       label: block_cggRp_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggRp: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cggTp; else goto cggTo;
       cggTp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cggTo: // global
           I64[Hp - 72] = sat_sge1n_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sge1h_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.968688294 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMo_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMo_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMo_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggUL: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_entry() //  []
         { info_tbl: [(cggUP,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggUP: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.973528716 UTC

[section ""data" . lvl4_rgdQh_closure" {
     lvl4_rgdQh_closure:
         const lvl4_rgdQh_info;
         const 0;
 },
 lvl4_rgdQh_entry() //  []
         { info_tbl: [(cggV2,
                       label: lvl4_rgdQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggV2: // global
           R1 = Data.Functor.Compose.$cCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.977318825 UTC

[section ""data" . lvl5_rgdQi_closure" {
     lvl5_rgdQi_closure:
         const lvl5_rgdQi_info;
         const 0;
 },
 lvl5_rgdQi_entry() //  []
         { info_tbl: [(cggVe,
                       label: lvl5_rgdQi_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggVe: // global
           R1 = Data.Functor.Compose.$tCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.980517967 UTC

[section ""data" . lvl6_rgdQj_closure" {
     lvl6_rgdQj_closure:
         const lvl6_rgdQj_info;
 },
 lvl6_rgdQj_entry() //  []
         { info_tbl: [(cggVq,
                       label: lvl6_rgdQj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggVq: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.983572504 UTC

[section ""data" . lvl7_rgdQk_closure" {
     lvl7_rgdQk_closure:
         const lvl7_rgdQk_info;
 },
 lvl7_rgdQk_entry() //  []
         { info_tbl: [(cggVC,
                       label: lvl7_rgdQk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggVC: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:07.98960568 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_closure" {
     Data.Functor.Compose.$fDataCompose_closure:
         const Data.Functor.Compose.$fDataCompose_info;
         const 0;
 },
 sat_sge2v_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggVT,
                       label: sat_sge2v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggVT: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2r_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggW1,
                       label: sat_sge2r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggW1: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2n_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggW9,
                       label: sat_sge2n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggW9: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2j_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggWk,
                       label: sat_sge2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggWk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cggWl; else goto cggWm;
       cggWl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggWm: // global
           I64[Sp - 32] = block_cggWh_info;
           _sge1I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _sge1I::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uggWu; else goto cggWi;
       uggWu: // global
           call _cggWh(R1) args: 0, res: 0, upd: 0;
       cggWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cggWh() //  [R1]
         { info_tbl: [(cggWh,
                       label: block_cggWh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggWh: // global
           if (I64[R1 + 7] == 0) goto cggWt; else goto cggWs;
       cggWt: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggWs: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge2c_entry() //  [R1, R2, R3]
         { info_tbl: [(cggWC,
                       label: sat_sge2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggWC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cggWG; else goto cggWF;
       cggWG: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cggWF: // global
           _sge1I::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = _sge1I::P64;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge28_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cggWN,
                       label: sat_sge28_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggWN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cggWR; else goto cggWQ;
       cggWR: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggWQ: // global
           _sge1I::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sge1I::P64;
           P64[Hp] = R5;
           R3 = R3;
           _sge23::P64 = R2;
           R2 = Hp - 32;
           R1 = _sge23::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge22_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cggWY,
                       label: sat_sge22_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggWY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cggX2; else goto cggX1;
       cggX2: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggX1: // global
           _sge1I::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sge1I::P64;
           P64[Hp] = R5;
           _sge1Y::P64 = R3;
           R3 = Hp - 32;
           _sge1X::P64 = R2;
           R2 = _sge1Y::P64;
           R1 = _sge1X::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1W_entry() //  [R1, R2, R3]
         { info_tbl: [(cggX8,
                       label: sat_sge1W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggX8: // global
           R3 = R3;
           _sge1U::P64 = R2;
           R2 = P64[R1 + 6];
           R1 = _sge1U::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1S_entry() //  [R1]
         { info_tbl: [(cggXk,
                       label: sat_sge1S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggXk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggXl; else goto cggXm;
       cggXl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggXm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggXn,
                       label: sat_sge1T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggXn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggXr; else goto cggXq;
       cggXr: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggXq: // global
           _sge1I::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sge1S_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sge1P::P64 = R2;
           R2 = _sge1I::P64;
           R1 = _sge1P::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1N_entry() //  [R1]
         { info_tbl: [(cggXB,
                       label: sat_sge1N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggXB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggXC; else goto cggXD;
       cggXC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggXD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sge1O_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cggXE,
                       label: sat_sge1O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggXE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cggXI; else goto cggXH;
       cggXI: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggXH: // global
           _sge1I::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sge1N_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           _sge1K::P64 = R2;
           R2 = _sge1I::P64;
           R1 = _sge1K::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sge1J_entry() //  [R1]
         { info_tbl: [(cggXN,
                       label: sat_sge1J_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggXN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggXO; else goto cggXP;
       cggXO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggXP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fDataCompose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cggXR,
                       label: Data.Functor.Compose.$fDataCompose_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggXR: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto cggXV; else goto cggXU;
       cggXV: // global
           HpAlloc = 344;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fDataCompose_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cggXU: // global
           I64[Hp - 336] = sat_sge2v_info;
           _sge1I::P64 = P64[Sp];
           P64[Hp - 328] = _sge1I::P64;
           I64[Hp - 320] = sat_sge2r_info;
           P64[Hp - 312] = _sge1I::P64;
           I64[Hp - 304] = sat_sge2n_info;
           P64[Hp - 296] = _sge1I::P64;
           I64[Hp - 288] = sat_sge2j_info;
           P64[Hp - 280] = _sge1I::P64;
           I64[Hp - 272] = sat_sge2c_info;
           P64[Hp - 264] = _sge1I::P64;
           I64[Hp - 256] = sat_sge28_info;
           P64[Hp - 248] = _sge1I::P64;
           I64[Hp - 240] = sat_sge22_info;
           P64[Hp - 232] = _sge1I::P64;
           I64[Hp - 224] = sat_sge1W_info;
           P64[Hp - 216] = _sge1I::P64;
           I64[Hp - 208] = sat_sge1T_info;
           P64[Hp - 200] = _sge1I::P64;
           I64[Hp - 192] = sat_sge1O_info;
           P64[Hp - 184] = _sge1I::P64;
           I64[Hp - 176] = sat_sge1J_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 189;
           P64[Hp - 96] = Hp - 205;
           P64[Hp - 88] = lvl4_rgdQh_closure+1;
           P64[Hp - 80] = lvl5_rgdQi_closure+1;
           P64[Hp - 72] = lvl6_rgdQj_closure+2;
           P64[Hp - 64] = lvl7_rgdQk_closure+2;
           P64[Hp - 56] = Hp - 222;
           P64[Hp - 48] = Hp - 236;
           P64[Hp - 40] = Hp - 252;
           P64[Hp - 32] = Hp - 270;
           P64[Hp - 24] = Hp - 285;
           P64[Hp - 16] = Hp - 301;
           P64[Hp - 8] = Hp - 317;
           P64[Hp] = Hp - 333;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:08.020189592 UTC

[section ""relreadonly" . Sge5q_srt" {
     Sge5q_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Compose.$fRead1Compose2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
         const Data.Functor.Compose.$fRead1Compose_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$w$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
         const Data.Functor.Compose.$fShow1Compose_closure;
         const Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadList_closure;
         const Data.Functor.Compose.$fReadCompose_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
         const Data.Functor.Compose.$fShowCompose_$cshow_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowList_closure;
         const Data.Functor.Compose.$fShowCompose_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Compose.$fFoldableCompose_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Compose.$fFoldableCompose2_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Compose.$fFoldableCompose3_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Compose.$fFoldableCompose_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Compose.$fFoldableCompose7_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
         const Data.Functor.Compose.$fFoldableCompose6_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$clength_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
         const Data.Functor.Compose.$fFoldableCompose8_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
         const Data.Functor.Compose.$fFoldableCompose_closure;
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
         const Data.Functor.Compose.$fTraversableCompose_closure;
         const GHC.List.badHead_closure;
         const go61_rgdPX_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Compose.$fDataCompose5_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Compose.$w$cp1Data_closure;
         const Data.Functor.Compose.$cCompose_closure;
         const Data.Functor.Compose.$tCompose_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Compose.$fDataCompose_closure;
         const lvl4_rgdQh_closure;
         const lvl5_rgdQi_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.524405892 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:11.52590242 UTC

[section ""data" . $fEq1Compose1_rgdPP_closure" {
     $fEq1Compose1_rgdPP_closure:
         const $fEq1Compose1_rgdPP_info;
 },
 $fEq1Compose1_rgdPP_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cghbf,
                       label: $fEq1Compose1_rgdPP_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghbf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghbj; else goto cghbi;
       cghbj: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $fEq1Compose1_rgdPP_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghbi: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sggZ0::P64 = R2;
           R2 = Hp - 24;
           R1 = _sggZ0::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.529998764 UTC

[section ""data" . Data.Functor.Compose.$fEq1Compose_closure" {
     Data.Functor.Compose.$fEq1Compose_closure:
         const Data.Functor.Compose.$fEq1Compose_info;
 },
 Data.Functor.Compose.$fEq1Compose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cghbt,
                       label: Data.Functor.Compose.$fEq1Compose_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghbt: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $fEq1Compose1_rgdPP_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.533722303 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure" {
     Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure:
         const Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info;
 },
 sat_sggZb_entry() //  [R1]
         { info_tbl: [(cghbI,
                       label: sat_sggZb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghbI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghbJ; else goto cghbK;
       cghbJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghbK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cghbL,
                       label: Data.Functor.Compose.$fOrd1Compose_$cliftCompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghbL: // global
           _sggZa::P64 = R6;
           _sggZ9::P64 = R5;
           _sggZ8::P64 = R4;
           _sggZ7::P64 = R3;
           _sggZ6::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cghbM; else goto cghbN;
       cghbN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghbP; else goto cghbO;
       cghbP: // global
           HpAlloc = 32;
           goto cghbM;
       cghbM: // global
           R6 = _sggZa::P64;
           R5 = _sggZ9::P64;
           R4 = _sggZ8::P64;
           R3 = _sggZ7::P64;
           R2 = _sggZ6::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose_$cliftCompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghbO: // global
           I64[Hp - 24] = sat_sggZb_info;
           P64[Hp - 8] = _sggZ7::P64;
           P64[Hp] = _sggZ8::P64;
           R2 = _sggZ6::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sggZ9::P64;
           P64[Sp - 8] = _sggZa::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.540191011 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose1_closure" {
     Data.Functor.Compose.$fOrd1Compose1_closure:
         const Data.Functor.Compose.$fOrd1Compose1_info;
 },
 sat_sggZh_entry() //  [R1]
         { info_tbl: [(cghcd,
                       label: sat_sggZh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghcd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghce; else goto cghcf;
       cghce: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghcf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrd1Compose1_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cghcg,
                       label: Data.Functor.Compose.$fOrd1Compose1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghcg: // global
           _sggZg::P64 = R6;
           _sggZf::P64 = R5;
           _sggZe::P64 = R4;
           _sggZd::P64 = R3;
           _sggZc::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cghch; else goto cghci;
       cghci: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghck; else goto cghcj;
       cghck: // global
           HpAlloc = 32;
           goto cghch;
       cghch: // global
           R6 = _sggZg::P64;
           R5 = _sggZf::P64;
           R4 = _sggZe::P64;
           R3 = _sggZd::P64;
           R2 = _sggZc::P64;
           R1 = Data.Functor.Compose.$fOrd1Compose1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghcj: // global
           I64[Hp - 24] = sat_sggZh_info;
           P64[Hp - 8] = _sggZd::P64;
           P64[Hp] = _sggZe::P64;
           R2 = _sggZc::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sggZf::P64;
           P64[Sp - 8] = _sggZg::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.546825667 UTC

[section ""data" . Data.Functor.Compose.$fOrd1Compose_closure" {
     Data.Functor.Compose.$fOrd1Compose_closure:
         const Data.Functor.Compose.$fOrd1Compose_info;
 },
 sat_sggZl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cghcJ,
                       label: sat_sggZl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghcJ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose_$cliftCompare_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sggZk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cghcR,
                       label: sat_sggZk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghcR: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fOrd1Compose1_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fOrd1Compose_entry() //  [R2, R3]
         { info_tbl: [(cghcV,
                       label: Data.Functor.Compose.$fOrd1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghcV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cghcZ; else goto cghcY;
       cghcZ: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrd1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghcY: // global
           I64[Hp - 64] = sat_sggZl_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sggZk_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Ord1_con_info;
           P64[Hp - 8] = Hp - 37;
           P64[Hp] = Hp - 61;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.554133813 UTC

[section ""cstring" . Data.Functor.Compose.$fDataCompose7_bytes" {
     Data.Functor.Compose.$fDataCompose7_bytes:
         I8[] [67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.556076875 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose6_closure" {
     Data.Functor.Compose.$fDataCompose6_closure:
         const Data.Functor.Compose.$fDataCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose6_entry() //  [R1]
         { info_tbl: [(cghdn,
                       label: Data.Functor.Compose.$fDataCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghdn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghdo; else goto cghdp;
       cghdo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghdp: // global
           (_cghdk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cghdk::I64 == 0) goto cghdm; else goto cghdl;
       cghdm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cghdl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cghdk::I64;
           R2 = Data.Functor.Compose.$fDataCompose7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.561415096 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose2_closure" {
     Data.Functor.Compose.$fRead1Compose2_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.563091007 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose1_closure" {
     Data.Functor.Compose.$fRead1Compose1_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.567031413 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info;
         const 0;
 },
 sat_sggZs_entry() //  [R1]
         { info_tbl: [(cghdM,
                       label: sat_sggZs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghdM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghdN; else goto cghdO;
       cghdN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghdO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadListPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sggZr_entry() //  [R1]
         { info_tbl: [(cghdT,
                       label: sat_sggZr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghdT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghdU; else goto cghdV;
       cghdU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghdV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 reader_sggZq_entry() //  [R1]
         { info_tbl: [(cghdW,
                       label: reader_sggZq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghdW: // global
           _sggZq::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghdX; else goto cghdY;
       cghdY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cghe0; else goto cghdZ;
       cghe0: // global
           HpAlloc = 80;
           goto cghdX;
       cghdX: // global
           R1 = _sggZq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghdZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sggZq::P64;
           _sggZm::P64 = P64[_sggZq::P64 + 16];
           _sggZn::P64 = P64[_sggZq::P64 + 24];
           _sggZo::P64 = P64[_sggZq::P64 + 32];
           _sggZp::P64 = P64[_sggZq::P64 + 40];
           I64[Hp - 72] = sat_sggZs_info;
           P64[Hp - 56] = _sggZn::P64;
           P64[Hp - 48] = _sggZo::P64;
           P64[Hp - 40] = _sggZp::P64;
           I64[Hp - 32] = sat_sggZr_info;
           P64[Hp - 16] = _sggZn::P64;
           P64[Hp - 8] = _sggZo::P64;
           P64[Hp] = _sggZp::P64;
           R2 = _sggZm::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftReadPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sggZz_entry() //  [R1, R2]
         { info_tbl: [(cghek,
                       label: sat_sggZz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghek: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sggZA_entry() //  [R1, R2]
         { info_tbl: [(cghen,
                       label: sat_sggZA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghen: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgher; else goto cgheq;
       cgher: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgheq: // global
           _sggZq::P64 = P64[R1 + 7];
           _sggZv::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sggZz_info;
           P64[Hp] = _sggZv::P64;
           R3 = Hp - 7;
           R2 = Data.Functor.Compose.$fRead1Compose1_closure+1;
           R1 = _sggZq::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wlvl_sggZt_entry() //  [R1, R2, R3]
         { info_tbl: [(cghev,
                       label: $wlvl_sggZt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghev: // global
           _sggZv::P64 = R3;
           _sggZu::I64 = R2;
           _sggZt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cghew; else goto cghex;
       cghex: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghez; else goto cghey;
       cghez: // global
           HpAlloc = 24;
           goto cghew;
       cghew: // global
           R3 = _sggZv::P64;
           R2 = _sggZu::I64;
           R1 = _sggZt::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghey: // global
           if (%MO_S_Gt_W64(_sggZu::I64, 10)) goto cghet; else goto cgheu;
       cghet: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgheu: // global
           _sggZq::P64 = P64[_sggZt::P64 + 6];
           I64[Hp - 16] = sat_sggZA_info;
           P64[Hp - 8] = _sggZq::P64;
           P64[Hp] = _sggZv::P64;
           I64[Sp - 8] = block_cgheA_info;
           R3 = Hp - 15;
           R2 = Data.Functor.Compose.$fRead1Compose2_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgheA() //  [R1]
         { info_tbl: [(cgheA,
                       label: block_cgheA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgheA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgheF; else goto cgheE;
       cgheF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgheE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl8_sggZD_entry() //  [R1, R2, R3]
         { info_tbl: [(cgheO,
                       label: lvl8_sggZD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgheO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgheP; else goto cgheQ;
       cgheP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgheQ: // global
           I64[Sp - 24] = block_cgheL_info;
           _sggZt::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sggZt::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugheU; else goto cgheM;
       ugheU: // global
           call _cgheL(R1) args: 0, res: 0, upd: 0;
       cgheM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgheL() //  [R1]
         { info_tbl: [(cgheL,
                       label: block_cgheL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgheL: // global
           R3 = P64[Sp + 16];
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call $wlvl_sggZt_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sggZK_entry() //  [R1, R2, R3]
         { info_tbl: [(cghf0,
                       label: sat_sggZK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghf0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cghf3,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghf3: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cghf7; else goto cghf6;
       cghf7: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghf6: // global
           I64[Hp - 88] = reader_sggZq_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           I64[Hp - 40] = $wlvl_sggZt_info;
           P64[Hp - 32] = Hp - 88;
           I64[Hp - 24] = lvl8_sggZD_info;
           P64[Hp - 16] = Hp - 38;
           I64[Hp - 8] = sat_sggZK_info;
           P64[Hp] = Hp - 22;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.591904433 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info;
         const 0;
 },
 sat_sggZV_entry() //  [R1, R2, R3]
         { info_tbl: [(cghgx,
                       label: sat_sggZV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghgx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cghgy; else goto cghgz;
       cghgy: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghgz: // global
           I64[Sp - 8] = block_cghgu_info;
           R3 = R3;
           R2 = P64[R1 + 6];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cghgu() //  [R1]
         { info_tbl: [(cghgu,
                       label: block_cghgu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghgu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghgC; else goto cghgB;
       cghgC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cghgB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sggZQ_entry() //  [R1, R2]
         { info_tbl: [(cghgI,
                       label: sat_sggZQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghgI: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadPrec.readS_to_Prec1_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 ds_sggZP_entry() //  [R1]
         { info_tbl: [(cghgL,
                       label: ds_sggZP_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghgL: // global
           _sggZP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cghgM; else goto cghgN;
       cghgN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghgP; else goto cghgO;
       cghgP: // global
           HpAlloc = 32;
           goto cghgM;
       cghgM: // global
           R1 = _sggZP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sggZP::P64;
           _sggZL::P64 = P64[_sggZP::P64 + 16];
           _sggZM::P64 = P64[_sggZP::P64 + 24];
           _sggZN::P64 = P64[_sggZP::P64 + 32];
           _sggZO::P64 = P64[_sggZP::P64 + 40];
           I64[Hp - 24] = sat_sggZV_info;
           P64[Hp - 16] = _sggZO::P64;
           I64[Hp - 8] = sat_sggZQ_info;
           P64[Hp] = _sggZN::P64;
           R5 = Hp - 22;
           R4 = Hp - 7;
           R3 = _sggZM::P64;
           R2 = _sggZL::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sggZX_entry() //  [R1]
         { info_tbl: [(cghgZ,
                       label: sat_sggZX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghgZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghh0; else goto cghh1;
       cghh0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghh1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sggZY_entry() //  [R1, R2]
         { info_tbl: [(cghh2,
                       label: sat_sggZY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghh2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghh6; else goto cghh5;
       cghh6: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghh5: // global
           _sggZP::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sggZX_info;
           P64[Hp - 8] = _sggZP::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cghh7,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghh7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cghhb; else goto cghha;
       cghhb: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghha: // global
           I64[Hp - 56] = ds_sggZP_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           I64[Hp - 8] = sat_sggZY_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.607698097 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info;
         const 0;
 },
 sat_sgh03_entry() //  [R1]
         { info_tbl: [(cghhX,
                       label: sat_sgh03_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghhX: // global
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cghi0,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghi0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cghi4; else goto cghi3;
       cghi4: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghi3: // global
           I64[Hp - 40] = sat_sgh03_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.613976724 UTC

[section ""data" . Data.Functor.Compose.$fRead1Compose_closure" {
     Data.Functor.Compose.$fRead1Compose_closure:
         const Data.Functor.Compose.$fRead1Compose_info;
         const 0;
 },
 sat_sgh09_entry() //  [R1, R2, R3]
         { info_tbl: [(cghim,
                       label: sat_sgh09_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghim: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_entry(R5,
                                                                             R4,
                                                                             R3,
                                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh08_entry() //  [R1, R2, R3]
         { info_tbl: [(cghiu,
                       label: sat_sgh08_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghiu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh07_entry() //  [R1]
         { info_tbl: [(cghiB,
                       label: sat_sgh07_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghiB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghiC; else goto cghiD;
       cghiC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghiD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh06_entry() //  [R1, R2, R3]
         { info_tbl: [(cghiJ,
                       label: sat_sgh06_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghiJ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_entry(R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fRead1Compose_entry() //  [R2, R3]
         { info_tbl: [(cghiN,
                       label: Data.Functor.Compose.$fRead1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghiN: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cghiR; else goto cghiQ;
       cghiR: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghiQ: // global
           I64[Hp - 136] = sat_sgh09_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgh08_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sgh07_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sgh06_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Data.Functor.Classes.C:Read1_con_info;
           P64[Hp - 24] = Hp - 54;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 134;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure" {
     Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure:
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_info;
         const 0;
 },
 sat_sgh0c_entry() //  [R1]
         { info_tbl: [(cghj0,
                       label: sat_sgh0c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghj0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghj1; else goto cghj2;
       cghj1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghj2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_entry(R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fRead1Compose_$cliftReadList_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cghj3,
                       label: Data.Functor.Compose.$fRead1Compose_$cliftReadList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghj3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghj7; else goto cghj6;
       cghj7: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghj6: // global
           I64[Hp - 24] = sat_sgh0c_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Data.Functor.Classes.liftReadListDefault_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.630479317 UTC

[section ""data" . Data.Functor.Compose.$w$cliftShowsPrec_closure" {
     Data.Functor.Compose.$w$cliftShowsPrec_closure:
         const Data.Functor.Compose.$w$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$w$cliftShowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghjM: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgh0k_entry() //  [R1]
         { info_tbl: [(cghjY,
                       label: sat_sgh0k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghjY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghjZ; else goto cghk0;
       cghjZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghk0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh0j_entry() //  [R1]
         { info_tbl: [(cghk5,
                       label: sat_sgh0j_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghk5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghk6; else goto cghk7;
       cghk6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghk7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh0l_entry() //  [R1]
         { info_tbl: [(cghk8,
                       label: sat_sgh0l_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghk8: // global
           _sgh0l::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cghk9; else goto cghka;
       cghka: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cghkc; else goto cghkb;
       cghkc: // global
           HpAlloc = 80;
           goto cghk9;
       cghk9: // global
           R1 = _sgh0l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghkb: // global
           _sgh0d::P64 = P64[_sgh0l::P64 + 16];
           _sgh0e::P64 = P64[_sgh0l::P64 + 24];
           _sgh0f::P64 = P64[_sgh0l::P64 + 32];
           _sgh0g::P64 = P64[_sgh0l::P64 + 40];
           I64[Hp - 72] = sat_sgh0k_info;
           P64[Hp - 56] = _sgh0e::P64;
           P64[Hp - 48] = _sgh0f::P64;
           P64[Hp - 40] = _sgh0g::P64;
           I64[Hp - 32] = sat_sgh0j_info;
           P64[Hp - 16] = _sgh0e::P64;
           P64[Hp - 8] = _sgh0f::P64;
           P64[Hp] = _sgh0g::P64;
           R2 = _sgh0d::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$w$cliftShowsPrec_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cghkd,
                       label: Data.Functor.Compose.$w$cliftShowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghkd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cghkh; else goto cghkg;
       cghkh: // global
           HpAlloc = 48;
           R1 = Data.Functor.Compose.$w$cliftShowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cghkg: // global
           I64[Hp - 40] = sat_sgh0l_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R5 = P64[Sp];
           R4 = R6;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = Hp - 40;
           Sp = Sp + 8;
           call Data.Functor.Classes.$wshowsUnaryWith_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.642827201 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info;
         const 0;
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry() //  [R2,
                                                                  R3, R4, R5, R6]
         { info_tbl: [(cghkV,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghkV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghkW; else goto cghkX;
       cghkW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cghkX: // global
           I64[Sp - 40] = block_cghkS_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ughl1; else goto cghkT;
       ughl1: // global
           call _cghkS(R1) args: 0, res: 0, upd: 0;
       cghkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghkS() //  [R1]
         { info_tbl: [(cghkS,
                       label: block_cghkS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghkS: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.648939308 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose3_closure" {
     Data.Functor.Compose.$fDataCompose3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.651060096 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure" {
     Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure:
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_info;
         const 0;
 },
 sat_sgh0B_entry() //  [R1, R2]
         { info_tbl: [(cghlm,
                       label: sat_sgh0B_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghlm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cghln; else goto cghlo;
       cghln: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghlo: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgh0A::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgh0A::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry() //  [R2,
                                                                 R3, R4, R5, R6]
         { info_tbl: [(cghlp,
                       label: Data.Functor.Compose.$fShow1Compose_$cliftShowList_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghlp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cghlt; else goto cghls;
       cghlt: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cghls: // global
           I64[Hp - 32] = sat_sgh0B_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = P64[Sp];
           R3 = R6;
           R2 = Hp - 31;
           Sp = Sp + 8;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.657367875 UTC

[section ""data" . Data.Functor.Compose.$fShow1Compose_closure" {
     Data.Functor.Compose.$fShow1Compose_closure:
         const Data.Functor.Compose.$fShow1Compose_info;
         const 0;
 },
 sat_sgh0F_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cghlM,
                       label: sat_sgh0F_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghlM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cghlN; else goto cghlO;
       cghlN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghlO: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowList_entry(R6,
                                                                         R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_sgh0E_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cghlU,
                       label: sat_sgh0E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghlU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cghlV; else goto cghlW;
       cghlV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghlW: // global
           R6 = R4;
           _B1::P64 = R5;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_entry(R6,
                                                                          R5,
                                                                          R4,
                                                                          R3,
                                                                          R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShow1Compose_entry() //  [R2, R3]
         { info_tbl: [(cghlY,
                       label: Data.Functor.Compose.$fShow1Compose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghlY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cghm2; else goto cghm1;
       cghm2: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShow1Compose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghm1: // global
           I64[Hp - 64] = sat_sgh0F_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgh0E_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Data.Functor.Classes.C:Show1_con_info;
           P64[Hp - 8] = Hp - 36;
           P64[Hp] = Hp - 60;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.665737146 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c==_closure" {
     Data.Functor.Compose.$fEqCompose_$c==_closure:
         const Data.Functor.Compose.$fEqCompose_$c==_info;
 },
 sat_sgh0L_entry() //  [R1]
         { info_tbl: [(cghmx,
                       label: sat_sgh0L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghmx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghmy; else goto cghmz;
       cghmy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghmz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh0M_entry() //  [R1]
         { info_tbl: [(cghmA,
                       label: sat_sgh0M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghmA: // global
           _sgh0M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cghmB; else goto cghmC;
       cghmC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghmE; else goto cghmD;
       cghmE: // global
           HpAlloc = 24;
           goto cghmB;
       cghmB: // global
           R1 = _sgh0M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghmD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh0M::P64;
           _sgh0H::P64 = P64[_sgh0M::P64 + 16];
           _sgh0I::P64 = P64[_sgh0M::P64 + 24];
           I64[Hp - 16] = sat_sgh0L_info;
           P64[Hp] = _sgh0I::P64;
           R2 = Hp - 16;
           R1 = _sgh0H::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c==_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cghmF,
                       label: Data.Functor.Compose.$fEqCompose_$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghmF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghmJ; else goto cghmI;
       cghmJ: // global
           HpAlloc = 32;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghmI: // global
           I64[Hp - 24] = sat_sgh0M_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = R6;
           R3 = R5;
           _sgh0G::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgh0G::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.674186569 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_$c/=_closure" {
     Data.Functor.Compose.$fEqCompose_$c/=_closure:
         const Data.Functor.Compose.$fEqCompose_$c/=_info;
 },
 sat_sgh0S_entry() //  [R1]
         { info_tbl: [(cghnc,
                       label: sat_sgh0S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghnc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghnd; else goto cghne;
       cghnd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghne: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh0T_entry() //  [R1]
         { info_tbl: [(cghnf,
                       label: sat_sgh0T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghnf: // global
           _sgh0T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cghng; else goto cghnh;
       cghnh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghnj; else goto cghni;
       cghnj: // global
           HpAlloc = 24;
           goto cghng;
       cghng: // global
           R1 = _sgh0T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghni: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh0T::P64;
           _sgh0O::P64 = P64[_sgh0T::P64 + 16];
           _sgh0P::P64 = P64[_sgh0T::P64 + 24];
           I64[Hp - 16] = sat_sgh0S_info;
           P64[Hp] = _sgh0P::P64;
           R2 = Hp - 16;
           R1 = _sgh0O::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fEqCompose_$c/=_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cghnq,
                       label: Data.Functor.Compose.$fEqCompose_$c/=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghnq: // global
           _sgh0R::P64 = R6;
           _sgh0Q::P64 = R5;
           _sgh0P::P64 = R4;
           _sgh0O::P64 = R3;
           _sgh0N::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cghnr; else goto cghns;
       cghns: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghnu; else goto cghnt;
       cghnu: // global
           HpAlloc = 32;
           goto cghnr;
       cghnr: // global
           R6 = _sgh0R::P64;
           R5 = _sgh0Q::P64;
           R4 = _sgh0P::P64;
           R3 = _sgh0O::P64;
           R2 = _sgh0N::P64;
           R1 = Data.Functor.Compose.$fEqCompose_$c/=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghnt: // global
           I64[Hp - 24] = sat_sgh0T_info;
           P64[Hp - 8] = _sgh0O::P64;
           P64[Hp] = _sgh0P::P64;
           I64[Sp - 8] = block_cghnk_info;
           R4 = _sgh0R::P64;
           R3 = _sgh0Q::P64;
           R2 = Hp - 24;
           R1 = _sgh0N::P64;
           Sp = Sp - 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghnk() //  [R1]
         { info_tbl: [(cghnk,
                       label: block_cghnk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghnk: // global
           if (R1 & 7 == 1) goto cghnn; else goto cghno;
       cghnn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cghno: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.68565445 UTC

[section ""data" . Data.Functor.Compose.$fEqCompose_closure" {
     Data.Functor.Compose.$fEqCompose_closure:
         const Data.Functor.Compose.$fEqCompose_info;
 },
 sat_sgh0Z_entry() //  [R1, R2, R3]
         { info_tbl: [(cghob,
                       label: sat_sgh0Z_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghob: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c/=_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh0Y_entry() //  [R1, R2, R3]
         { info_tbl: [(cghoj,
                       label: sat_sgh0Y_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghoj: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fEqCompose_$c==_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fEqCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cghon,
                       label: Data.Functor.Compose.$fEqCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghon: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cghor; else goto cghoq;
       cghor: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fEqCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghoq: // global
           I64[Hp - 80] = sat_sgh0Z_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sgh0Y_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 78;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.69308765 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$ccompare_closure" {
     Data.Functor.Compose.$fOrdCompose_$ccompare_closure:
         const Data.Functor.Compose.$fOrdCompose_$ccompare_info;
 },
 sat_sgh15_entry() //  [R1]
         { info_tbl: [(cghoU,
                       label: sat_sgh15_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghoU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghoV; else goto cghoW;
       cghoV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghoW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh16_entry() //  [R1]
         { info_tbl: [(cghoX,
                       label: sat_sgh16_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghoX: // global
           _sgh16::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghoY; else goto cghoZ;
       cghoZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghp1; else goto cghp0;
       cghp1: // global
           HpAlloc = 24;
           goto cghoY;
       cghoY: // global
           R1 = _sgh16::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghp0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh16::P64;
           _sgh11::P64 = P64[_sgh16::P64 + 16];
           _sgh12::P64 = P64[_sgh16::P64 + 24];
           I64[Hp - 16] = sat_sgh15_info;
           P64[Hp] = _sgh12::P64;
           R2 = _sgh11::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$ccompare_entry() //  [R2, R3,
                                                          R4, R5, R6]
         { info_tbl: [(cghp2,
                       label: Data.Functor.Compose.$fOrdCompose_$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghp2: // global
           _sgh14::P64 = R6;
           _sgh13::P64 = R5;
           _sgh12::P64 = R4;
           _sgh11::P64 = R3;
           _sgh10::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cghp3; else goto cghp4;
       cghp4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghp6; else goto cghp5;
       cghp6: // global
           HpAlloc = 32;
           goto cghp3;
       cghp3: // global
           R6 = _sgh14::P64;
           R5 = _sgh13::P64;
           R4 = _sgh12::P64;
           R3 = _sgh11::P64;
           R2 = _sgh10::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghp5: // global
           I64[Hp - 24] = sat_sgh16_info;
           P64[Hp - 8] = _sgh11::P64;
           P64[Hp] = _sgh12::P64;
           R2 = _sgh10::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgh13::P64;
           P64[Sp - 8] = _sgh14::P64;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.701875319 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure" {
     Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure:
         const Data.Functor.Compose.$fOrdCompose_$cp1Ord_info;
 },
 sat_sgh1c_entry() //  [R1]
         { info_tbl: [(cghpA,
                       label: sat_sgh1c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghpA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghpB; else goto cghpC;
       cghpB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghpC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1b_entry() //  [R1]
         { info_tbl: [(cghpH,
                       label: sat_sgh1b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghpH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghpI; else goto cghpJ;
       cghpI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghpJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1a_entry() //  [R1]
         { info_tbl: [(cghpO,
                       label: sat_sgh1a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghpO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghpP; else goto cghpQ;
       cghpP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghpQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Classes.$p1Ord1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry() //  [R2, R3, R4]
         { info_tbl: [(cghpR,
                       label: Data.Functor.Compose.$fOrdCompose_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghpR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cghpV; else goto cghpU;
       cghpV: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_$cp1Ord_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghpU: // global
           I64[Hp - 64] = sat_sgh1c_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgh1b_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgh1a_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fEqCompose_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.711709914 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<_info;
 },
 sat_sgh1i_entry() //  [R1]
         { info_tbl: [(cghqu,
                       label: sat_sgh1i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghqu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghqv; else goto cghqw;
       cghqv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghqw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1j_entry() //  [R1]
         { info_tbl: [(cghqx,
                       label: sat_sgh1j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghqx: // global
           _sgh1j::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghqy; else goto cghqz;
       cghqz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghqB; else goto cghqA;
       cghqB: // global
           HpAlloc = 24;
           goto cghqy;
       cghqy: // global
           R1 = _sgh1j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghqA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh1j::P64;
           _sgh1e::P64 = P64[_sgh1j::P64 + 16];
           _sgh1f::P64 = P64[_sgh1j::P64 + 24];
           I64[Hp - 16] = sat_sgh1i_info;
           P64[Hp] = _sgh1f::P64;
           R2 = _sgh1e::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cghqI,
                       label: Data.Functor.Compose.$fOrdCompose_$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghqI: // global
           _sgh1h::P64 = R6;
           _sgh1g::P64 = R5;
           _sgh1f::P64 = R4;
           _sgh1e::P64 = R3;
           _sgh1d::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghqJ; else goto cghqK;
       cghqK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghqM; else goto cghqL;
       cghqM: // global
           HpAlloc = 32;
           goto cghqJ;
       cghqJ: // global
           R6 = _sgh1h::P64;
           R5 = _sgh1g::P64;
           R4 = _sgh1f::P64;
           R3 = _sgh1e::P64;
           R2 = _sgh1d::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghqL: // global
           I64[Hp - 24] = sat_sgh1j_info;
           P64[Hp - 8] = _sgh1e::P64;
           P64[Hp] = _sgh1f::P64;
           I64[Sp - 8] = block_cghqC_info;
           R2 = _sgh1d::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh1g::P64;
           P64[Sp - 16] = _sgh1h::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghqC() //  [R1]
         { info_tbl: [(cghqC,
                       label: block_cghqC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghqC: // global
           if (R1 & 7 == 1) goto cghqG; else goto cghqF;
       cghqG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cghqF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.722717282 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>=_info;
 },
 sat_sgh1q_entry() //  [R1]
         { info_tbl: [(cghrA,
                       label: sat_sgh1q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghrA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghrB; else goto cghrC;
       cghrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1r_entry() //  [R1]
         { info_tbl: [(cghrD,
                       label: sat_sgh1r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghrD: // global
           _sgh1r::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghrE; else goto cghrF;
       cghrF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghrH; else goto cghrG;
       cghrH: // global
           HpAlloc = 24;
           goto cghrE;
       cghrE: // global
           R1 = _sgh1r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghrG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh1r::P64;
           _sgh1m::P64 = P64[_sgh1r::P64 + 16];
           _sgh1n::P64 = P64[_sgh1r::P64 + 24];
           I64[Hp - 16] = sat_sgh1q_info;
           P64[Hp] = _sgh1n::P64;
           R2 = _sgh1m::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cghrO,
                       label: Data.Functor.Compose.$fOrdCompose_$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghrO: // global
           _sgh1p::P64 = R6;
           _sgh1o::P64 = R5;
           _sgh1n::P64 = R4;
           _sgh1m::P64 = R3;
           _sgh1l::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghrP; else goto cghrQ;
       cghrQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghrS; else goto cghrR;
       cghrS: // global
           HpAlloc = 32;
           goto cghrP;
       cghrP: // global
           R6 = _sgh1p::P64;
           R5 = _sgh1o::P64;
           R4 = _sgh1n::P64;
           R3 = _sgh1m::P64;
           R2 = _sgh1l::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghrR: // global
           I64[Hp - 24] = sat_sgh1r_info;
           P64[Hp - 8] = _sgh1m::P64;
           P64[Hp] = _sgh1n::P64;
           I64[Sp - 8] = block_cghrI_info;
           R2 = _sgh1l::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh1o::P64;
           P64[Sp - 16] = _sgh1p::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghrI() //  [R1]
         { info_tbl: [(cghrI,
                       label: block_cghrI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghrI: // global
           if (R1 & 7 == 1) goto cghrM; else goto cghrL;
       cghrM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cghrL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.73319651 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c>_closure" {
     Data.Functor.Compose.$fOrdCompose_$c>_closure:
         const Data.Functor.Compose.$fOrdCompose_$c>_info;
 },
 sat_sgh1y_entry() //  [R1]
         { info_tbl: [(cghsG,
                       label: sat_sgh1y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghsG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghsH; else goto cghsI;
       cghsH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghsI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1z_entry() //  [R1]
         { info_tbl: [(cghsJ,
                       label: sat_sgh1z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghsJ: // global
           _sgh1z::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghsK; else goto cghsL;
       cghsL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghsN; else goto cghsM;
       cghsN: // global
           HpAlloc = 24;
           goto cghsK;
       cghsK: // global
           R1 = _sgh1z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghsM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh1z::P64;
           _sgh1u::P64 = P64[_sgh1z::P64 + 16];
           _sgh1v::P64 = P64[_sgh1z::P64 + 24];
           I64[Hp - 16] = sat_sgh1y_info;
           P64[Hp] = _sgh1v::P64;
           R2 = _sgh1u::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c>_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cghsU,
                       label: Data.Functor.Compose.$fOrdCompose_$c>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghsU: // global
           _sgh1x::P64 = R6;
           _sgh1w::P64 = R5;
           _sgh1v::P64 = R4;
           _sgh1u::P64 = R3;
           _sgh1t::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghsV; else goto cghsW;
       cghsW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghsY; else goto cghsX;
       cghsY: // global
           HpAlloc = 32;
           goto cghsV;
       cghsV: // global
           R6 = _sgh1x::P64;
           R5 = _sgh1w::P64;
           R4 = _sgh1v::P64;
           R3 = _sgh1u::P64;
           R2 = _sgh1t::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghsX: // global
           I64[Hp - 24] = sat_sgh1z_info;
           P64[Hp - 8] = _sgh1u::P64;
           P64[Hp] = _sgh1v::P64;
           I64[Sp - 8] = block_cghsO_info;
           R2 = _sgh1t::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh1w::P64;
           P64[Sp - 16] = _sgh1x::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghsO() //  [R1]
         { info_tbl: [(cghsO,
                       label: block_cghsO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghsO: // global
           if (R1 & 7 == 3) goto cghsS; else goto cghsR;
       cghsS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cghsR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.74414921 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$c<=_closure" {
     Data.Functor.Compose.$fOrdCompose_$c<=_closure:
         const Data.Functor.Compose.$fOrdCompose_$c<=_info;
 },
 sat_sgh1G_entry() //  [R1]
         { info_tbl: [(cghtM,
                       label: sat_sgh1G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghtM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghtN; else goto cghtO;
       cghtN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghtO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1H_entry() //  [R1]
         { info_tbl: [(cghtP,
                       label: sat_sgh1H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghtP: // global
           _sgh1H::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghtQ; else goto cghtR;
       cghtR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghtT; else goto cghtS;
       cghtT: // global
           HpAlloc = 24;
           goto cghtQ;
       cghtQ: // global
           R1 = _sgh1H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghtS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh1H::P64;
           _sgh1C::P64 = P64[_sgh1H::P64 + 16];
           _sgh1D::P64 = P64[_sgh1H::P64 + 24];
           I64[Hp - 16] = sat_sgh1G_info;
           P64[Hp] = _sgh1D::P64;
           R2 = _sgh1C::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$c<=_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cghu0,
                       label: Data.Functor.Compose.$fOrdCompose_$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghu0: // global
           _sgh1F::P64 = R6;
           _sgh1E::P64 = R5;
           _sgh1D::P64 = R4;
           _sgh1C::P64 = R3;
           _sgh1B::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghu1; else goto cghu2;
       cghu2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghu4; else goto cghu3;
       cghu4: // global
           HpAlloc = 32;
           goto cghu1;
       cghu1: // global
           R6 = _sgh1F::P64;
           R5 = _sgh1E::P64;
           R4 = _sgh1D::P64;
           R3 = _sgh1C::P64;
           R2 = _sgh1B::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghu3: // global
           I64[Hp - 24] = sat_sgh1H_info;
           P64[Hp - 8] = _sgh1C::P64;
           P64[Hp] = _sgh1D::P64;
           I64[Sp - 8] = block_cghtU_info;
           R2 = _sgh1B::P64;
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh1E::P64;
           P64[Sp - 16] = _sgh1F::P64;
           Sp = Sp - 40;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghtU() //  [R1]
         { info_tbl: [(cghtU,
                       label: block_cghtU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghtU: // global
           if (R1 & 7 == 3) goto cghtY; else goto cghtX;
       cghtY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cghtX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.754675921 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmax_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmax_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmax_info;
 },
 sat_sgh1O_entry() //  [R1]
         { info_tbl: [(cghuS,
                       label: sat_sgh1O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghuS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghuT; else goto cghuU;
       cghuT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghuU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1P_entry() //  [R1]
         { info_tbl: [(cghuV,
                       label: sat_sgh1P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghuV: // global
           _sgh1P::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghuW; else goto cghuX;
       cghuX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghuZ; else goto cghuY;
       cghuZ: // global
           HpAlloc = 24;
           goto cghuW;
       cghuW: // global
           R1 = _sgh1P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghuY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh1P::P64;
           _sgh1K::P64 = P64[_sgh1P::P64 + 16];
           _sgh1L::P64 = P64[_sgh1P::P64 + 24];
           I64[Hp - 16] = sat_sgh1O_info;
           P64[Hp] = _sgh1L::P64;
           R2 = _sgh1K::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmax_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cghv6,
                       label: Data.Functor.Compose.$fOrdCompose_$cmax_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghv6: // global
           _sgh1N::P64 = R6;
           _sgh1M::P64 = R5;
           _sgh1L::P64 = R4;
           _sgh1K::P64 = R3;
           _sgh1J::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cghv7; else goto cghv8;
       cghv8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghva; else goto cghv9;
       cghva: // global
           HpAlloc = 32;
           goto cghv7;
       cghv7: // global
           R6 = _sgh1N::P64;
           R5 = _sgh1M::P64;
           R4 = _sgh1L::P64;
           R3 = _sgh1K::P64;
           R2 = _sgh1J::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmax_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghv9: // global
           I64[Hp - 24] = sat_sgh1P_info;
           P64[Hp - 8] = _sgh1K::P64;
           P64[Hp] = _sgh1L::P64;
           I64[Sp - 24] = block_cghv0_info;
           R2 = _sgh1J::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgh1M::P64;
           P64[Sp - 32] = _sgh1N::P64;
           P64[Sp - 16] = _sgh1M::P64;
           P64[Sp - 8] = _sgh1N::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghv0() //  [R1]
         { info_tbl: [(cghv0,
                       label: block_cghv0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghv0: // global
           if (R1 & 7 == 3) goto cghv4; else goto cghv3;
       cghv4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cghv3: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.766268715 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_$cmin_closure" {
     Data.Functor.Compose.$fOrdCompose_$cmin_closure:
         const Data.Functor.Compose.$fOrdCompose_$cmin_info;
 },
 sat_sgh1W_entry() //  [R1]
         { info_tbl: [(cghvU,
                       label: sat_sgh1W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghvU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghvV; else goto cghvW;
       cghvV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghvW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh1X_entry() //  [R1]
         { info_tbl: [(cghvX,
                       label: sat_sgh1X_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghvX: // global
           _sgh1X::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghvY; else goto cghvZ;
       cghvZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghw1; else goto cghw0;
       cghw1: // global
           HpAlloc = 24;
           goto cghvY;
       cghvY: // global
           R1 = _sgh1X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghw0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh1X::P64;
           _sgh1S::P64 = P64[_sgh1X::P64 + 16];
           _sgh1T::P64 = P64[_sgh1X::P64 + 24];
           I64[Hp - 16] = sat_sgh1W_info;
           P64[Hp] = _sgh1T::P64;
           R2 = _sgh1S::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_$cmin_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cghw8,
                       label: Data.Functor.Compose.$fOrdCompose_$cmin_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghw8: // global
           _sgh1V::P64 = R6;
           _sgh1U::P64 = R5;
           _sgh1T::P64 = R4;
           _sgh1S::P64 = R3;
           _sgh1R::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cghw9; else goto cghwa;
       cghwa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghwc; else goto cghwb;
       cghwc: // global
           HpAlloc = 32;
           goto cghw9;
       cghw9: // global
           R6 = _sgh1V::P64;
           R5 = _sgh1U::P64;
           R4 = _sgh1T::P64;
           R3 = _sgh1S::P64;
           R2 = _sgh1R::P64;
           R1 = Data.Functor.Compose.$fOrdCompose_$cmin_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghwb: // global
           I64[Hp - 24] = sat_sgh1X_info;
           P64[Hp - 8] = _sgh1S::P64;
           P64[Hp] = _sgh1T::P64;
           I64[Sp - 24] = block_cghw2_info;
           R2 = _sgh1R::P64;
           I64[Sp - 56] = stg_ap_ppp_info;
           P64[Sp - 48] = Hp - 24;
           P64[Sp - 40] = _sgh1U::P64;
           P64[Sp - 32] = _sgh1V::P64;
           P64[Sp - 16] = _sgh1U::P64;
           P64[Sp - 8] = _sgh1V::P64;
           Sp = Sp - 56;
           call Data.Functor.Classes.liftCompare_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghw2() //  [R1]
         { info_tbl: [(cghw2,
                       label: block_cghw2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghw2: // global
           if (R1 & 7 == 3) goto cghw6; else goto cghw5;
       cghw6: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cghw5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.777561472 UTC

[section ""data" . Data.Functor.Compose.$fOrdCompose_closure" {
     Data.Functor.Compose.$fOrdCompose_closure:
         const Data.Functor.Compose.$fOrdCompose_info;
 },
 sat_sgh29_entry() //  [R1, R2, R3]
         { info_tbl: [(cghwT,
                       label: sat_sgh29_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghwT: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmin_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh28_entry() //  [R1, R2, R3]
         { info_tbl: [(cghx1,
                       label: sat_sgh28_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghx1: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$cmax_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh27_entry() //  [R1, R2, R3]
         { info_tbl: [(cghx9,
                       label: sat_sgh27_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghx9: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh26_entry() //  [R1, R2, R3]
         { info_tbl: [(cghxh,
                       label: sat_sgh26_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghxh: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c>_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh25_entry() //  [R1, R2, R3]
         { info_tbl: [(cghxp,
                       label: sat_sgh25_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghxp: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<=_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh24_entry() //  [R1, R2, R3]
         { info_tbl: [(cghxx,
                       label: sat_sgh24_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghxx: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$c<_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh23_entry() //  [R1, R2, R3]
         { info_tbl: [(cghxF,
                       label: sat_sgh23_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghxF: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fOrdCompose_$ccompare_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh22_entry() //  [R1]
         { info_tbl: [(cghxM,
                       label: sat_sgh22_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghxM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghxN; else goto cghxO;
       cghxN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghxO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fOrdCompose_$cp1Ord_entry(R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fOrdCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cghxQ,
                       label: Data.Functor.Compose.$fOrdCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghxQ: // global
           Hp = Hp + 336;
           if (Hp > HpLim) (likely: False) goto cghxU; else goto cghxT;
       cghxU: // global
           HpAlloc = 336;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fOrdCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghxT: // global
           I64[Hp - 328] = sat_sgh29_info;
           P64[Hp - 320] = R2;
           P64[Hp - 312] = R3;
           P64[Hp - 304] = R4;
           I64[Hp - 296] = sat_sgh28_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           P64[Hp - 272] = R4;
           I64[Hp - 264] = sat_sgh27_info;
           P64[Hp - 256] = R2;
           P64[Hp - 248] = R3;
           P64[Hp - 240] = R4;
           I64[Hp - 232] = sat_sgh26_info;
           P64[Hp - 224] = R2;
           P64[Hp - 216] = R3;
           P64[Hp - 208] = R4;
           I64[Hp - 200] = sat_sgh25_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           P64[Hp - 176] = R4;
           I64[Hp - 168] = sat_sgh24_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = sat_sgh23_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = sat_sgh22_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 104;
           P64[Hp - 48] = Hp - 134;
           P64[Hp - 40] = Hp - 166;
           P64[Hp - 32] = Hp - 198;
           P64[Hp - 24] = Hp - 230;
           P64[Hp - 16] = Hp - 262;
           P64[Hp - 8] = Hp - 294;
           P64[Hp] = Hp - 326;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.796218516 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadPrec_info;
         const 0;
 },
 sat_sgh2e_entry() //  [R1]
         { info_tbl: [(cghyP,
                       label: sat_sgh2e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghyQ; else goto cghyR;
       cghyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghyR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2d_entry() //  [R1]
         { info_tbl: [(cghyW,
                       label: sat_sgh2d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghyX; else goto cghyY;
       cghyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cghyZ,
                       label: Data.Functor.Compose.$fReadCompose_$creadPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghyZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cghz3; else goto cghz2;
       cghz3: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghz2: // global
           I64[Hp - 40] = sat_sgh2e_info;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sgh2d_info;
           P64[Hp] = R4;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.805333221 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadsPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadsPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_info;
         const 0;
 },
 sat_sgh2k_entry() //  [R1]
         { info_tbl: [(cghzw,
                       label: sat_sgh2k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghzw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghzx; else goto cghzy;
       cghzx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghzy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2j_entry() //  [R1]
         { info_tbl: [(cghzD,
                       label: sat_sgh2j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghzE; else goto cghzF;
       cghzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sgh2i_entry() //  [R1]
         { info_tbl: [(cghzG,
                       label: ds_sgh2i_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghzG: // global
           _sgh2i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cghzH; else goto cghzI;
       cghzI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cghzK; else goto cghzJ;
       cghzK: // global
           HpAlloc = 48;
           goto cghzH;
       cghzH: // global
           R1 = _sgh2i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghzJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh2i::P64;
           _sgh2f::P64 = P64[_sgh2i::P64 + 16];
           _sgh2g::P64 = P64[_sgh2i::P64 + 24];
           _sgh2h::P64 = P64[_sgh2i::P64 + 32];
           I64[Hp - 40] = sat_sgh2k_info;
           P64[Hp - 24] = _sgh2h::P64;
           I64[Hp - 16] = sat_sgh2j_info;
           P64[Hp] = _sgh2h::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgh2g::P64;
           R2 = _sgh2f::P64;
           Sp = Sp - 16;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2m_entry() //  [R1]
         { info_tbl: [(cghzU,
                       label: sat_sgh2m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghzU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghzV; else goto cghzW;
       cghzV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghzW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2n_entry() //  [R1, R2]
         { info_tbl: [(cghzX,
                       label: sat_sgh2n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghzX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghA1; else goto cghA0;
       cghA1: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghA0: // global
           _sgh2i::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgh2m_info;
           P64[Hp - 8] = _sgh2i::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cghA2,
                       label: Data.Functor.Compose.$fReadCompose_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghA2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cghA6; else goto cghA5;
       cghA6: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghA5: // global
           I64[Hp - 48] = ds_sgh2i_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sgh2n_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.81953447 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadListPrec_closure" {
     Data.Functor.Compose.$fReadCompose_$creadListPrec_closure:
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_info;
         const 0;
 },
 sat_sgh2s_entry() //  [R1]
         { info_tbl: [(cghAT,
                       label: sat_sgh2s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghAT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghAU; else goto cghAV;
       cghAU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghAV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2r_entry() //  [R1]
         { info_tbl: [(cghB0,
                       label: sat_sgh2r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghB0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghB1; else goto cghB2;
       cghB1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghB2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Read.readPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2t_entry() //  [R1]
         { info_tbl: [(cghB3,
                       label: sat_sgh2t_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghB3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cghB7; else goto cghB6;
       cghB7: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghB6: // global
           _sgh2o::P64 = P64[R1 + 16];
           _sgh2p::P64 = P64[R1 + 24];
           _sgh2q::P64 = P64[R1 + 32];
           I64[Hp - 40] = sat_sgh2s_info;
           P64[Hp - 24] = _sgh2q::P64;
           I64[Hp - 16] = sat_sgh2r_info;
           P64[Hp] = _sgh2q::P64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = _sgh2p::P64;
           R2 = _sgh2o::P64;
           call Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadListPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cghB8,
                       label: Data.Functor.Compose.$fReadCompose_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghB8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cghBc; else goto cghBb;
       cghBc: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghBb: // global
           I64[Hp - 32] = sat_sgh2t_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.829988242 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_$creadList_closure" {
     Data.Functor.Compose.$fReadCompose_$creadList_closure:
         const Data.Functor.Compose.$fReadCompose_$creadList_info;
         const 0;
 },
 sat_sgh2x_entry() //  [R1]
         { info_tbl: [(cghBF,
                       label: sat_sgh2x_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghBF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghBG; else goto cghBH;
       cghBG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghBH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_$creadList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cghBI,
                       label: Data.Functor.Compose.$fReadCompose_$creadList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghBI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cghBM; else goto cghBL;
       cghBM: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_$creadList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghBL: // global
           I64[Hp - 32] = sat_sgh2x_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.836953897 UTC

[section ""data" . Data.Functor.Compose.$fReadCompose_closure" {
     Data.Functor.Compose.$fReadCompose_closure:
         const Data.Functor.Compose.$fReadCompose_info;
         const 0;
 },
 sat_sgh2E_entry() //  [R1]
         { info_tbl: [(cghCa,
                       label: sat_sgh2E_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghCa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghCb; else goto cghCc;
       cghCb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghCc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadListPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2D_entry() //  [R1]
         { info_tbl: [(cghCh,
                       label: sat_sgh2D_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghCi; else goto cghCj;
       cghCi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghCj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2C_entry() //  [R1]
         { info_tbl: [(cghCo,
                       label: sat_sgh2C_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghCo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghCp; else goto cghCq;
       cghCp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghCq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadList_entry(R4,
                                                                    R3,
                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2B_entry() //  [R1]
         { info_tbl: [(cghCv,
                       label: sat_sgh2B_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghCv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghCw; else goto cghCx;
       cghCw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghCx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fReadCompose_$creadsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fReadCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cghCz,
                       label: Data.Functor.Compose.$fReadCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghCz: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cghCD; else goto cghCC;
       cghCD: // global
           HpAlloc = 200;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fReadCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghCC: // global
           I64[Hp - 192] = sat_sgh2E_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           I64[Hp - 152] = sat_sgh2D_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_sgh2C_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgh2B_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.850233448 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_info;
         const 0;
 },
 sat_sgh2N_entry() //  [R1]
         { info_tbl: [(cghDp,
                       label: sat_sgh2N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghDp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghDq; else goto cghDr;
       cghDq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghDr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2M_entry() //  [R1]
         { info_tbl: [(cghDw,
                       label: sat_sgh2M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghDx; else goto cghDy;
       cghDx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghDy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cghDz,
                       label: Data.Functor.Compose.$fShowCompose_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghDz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghDA; else goto cghDB;
       cghDA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghDB: // global
           I64[Sp - 40] = block_cghDg_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ughDF; else goto cghDh;
       ughDF: // global
           call _cghDg(R1) args: 0, res: 0, upd: 0;
       cghDh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghDg() //  [R1]
         { info_tbl: [(cghDg,
                       label: block_cghDg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghDg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cghDE; else goto cghDD;
       cghDE: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cghDD: // global
           _sgh2L::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sgh2N_info;
           _sgh2H::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgh2H::P64;
           I64[Hp - 16] = sat_sgh2M_info;
           P64[Hp] = _sgh2H::P64;
           R6 = _sgh2L::I64;
           R5 = Hp - 40;
           R4 = Hp - 16;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.860676615 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshow_closure" {
     Data.Functor.Compose.$fShowCompose_$cshow_closure:
         const Data.Functor.Compose.$fShowCompose_$cshow_info;
         const 0;
 },
 sp_sgh2S_entry() //  [R1]
         { info_tbl: [(cghEa,
                       label: sp_sgh2S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghEb; else goto cghEc;
       cghEb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghEc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sl_sgh2T_entry() //  [R1]
         { info_tbl: [(cghEh,
                       label: sl_sgh2T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghEh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghEi; else goto cghEj;
       cghEi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghEj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh2V_entry() //  [R1]
         { info_tbl: [(cghEs,
                       label: sat_sgh2V_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghEs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghEt; else goto cghEu;
       cghEt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghEu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh2U_entry() //  [R1]
         { info_tbl: [(cghEz,
                       label: sat_sgh2U_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghEz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghEA; else goto cghEB;
       cghEA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghEB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh2W_entry() //  [R1]
         { info_tbl: [(cghEC,
                       label: sat_sgh2W_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghEC: // global
           _sgh2W::P64 = R1;
           if ((Sp + -64) < SpLim) (likely: False) goto cghED; else goto cghEE;
       cghEE: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cghEG; else goto cghEF;
       cghEG: // global
           HpAlloc = 80;
           goto cghED;
       cghED: // global
           R1 = _sgh2W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghEF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh2W::P64;
           _sgh2O::P64 = P64[_sgh2W::P64 + 16];
           _sgh2P::P64 = P64[_sgh2W::P64 + 24];
           _sgh2R::P64 = P64[_sgh2W::P64 + 32];
           _sgh2S::P64 = P64[_sgh2W::P64 + 40];
           _sgh2T::P64 = P64[_sgh2W::P64 + 48];
           I64[Hp - 72] = sat_sgh2V_info;
           P64[Hp - 56] = _sgh2P::P64;
           P64[Hp - 48] = _sgh2S::P64;
           P64[Hp - 40] = _sgh2T::P64;
           I64[Hp - 32] = sat_sgh2U_info;
           P64[Hp - 16] = _sgh2P::P64;
           P64[Hp - 8] = _sgh2S::P64;
           P64[Hp] = _sgh2T::P64;
           R2 = _sgh2O::P64;
           I64[Sp - 64] = stg_ap_ppppp_info;
           P64[Sp - 56] = Hp - 32;
           P64[Sp - 48] = Hp - 72;
           P64[Sp - 40] = Data.Functor.Classes.$fRead1Const1_closure;
           P64[Sp - 32] = _sgh2R::P64;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 64;
           call Data.Functor.Classes.liftShowsPrec_entry(R2) args: 72, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshow_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cghEI,
                       label: Data.Functor.Compose.$fShowCompose_$cshow_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghEI: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cghEM; else goto cghEL;
       cghEM: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshow_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghEL: // global
           I64[Hp - 120] = sp_sgh2S_info;
           P64[Hp - 104] = R4;
           I64[Hp - 96] = sl_sgh2T_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sgh2W_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = Hp - 120;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Data.Functor.Classes.showsUnaryWith1_closure;
           P64[Hp] = Hp - 72;
           R3 = Hp - 14;
           R2 = Data.Functor.Compose.$fDataCompose6_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.875993259 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_$cshowList_closure" {
     Data.Functor.Compose.$fShowCompose_$cshowList_closure:
         const Data.Functor.Compose.$fShowCompose_$cshowList_info;
         const 0;
 },
 lvl8_sgh33_entry() //  [R1]
         { info_tbl: [(cghFK,
                       label: lvl8_sgh33_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghFK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghFL; else goto cghFM;
       cghFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghFM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl9_sgh34_entry() //  [R1]
         { info_tbl: [(cghFR,
                       label: lvl9_sgh34_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghFR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghFS; else goto cghFT;
       cghFS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghFT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.showList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh36_entry() //  [R1, R2]
         { info_tbl: [(cghFZ,
                       label: sat_sgh36_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghFZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cghG0; else goto cghG1;
       cghG0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghG1: // global
           R6 = 0;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _sgh35::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sgh35::P64;
           Sp = Sp - 8;
           call Data.Functor.Compose.$w$cliftShowsPrec_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 16, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_$cshowList_entry() //  [R2, R3,
                                                            R4, R5, R6]
         { info_tbl: [(cghG2,
                       label: Data.Functor.Compose.$fShowCompose_$cshowList_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghG2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cghG6; else goto cghG5;
       cghG6: // global
           HpAlloc = 88;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_$cshowList_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghG5: // global
           I64[Hp - 80] = lvl8_sgh33_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl9_sgh34_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sgh36_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = R6;
           R3 = R5;
           R2 = Hp - 31;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.886290054 UTC

[section ""data" . Data.Functor.Compose.$fShowCompose_closure" {
     Data.Functor.Compose.$fShowCompose_closure:
         const Data.Functor.Compose.$fShowCompose_info;
         const 0;
 },
 sat_sgh3c_entry() //  [R1, R2, R3]
         { info_tbl: [(cghGD,
                       label: sat_sgh3c_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghGD: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowList_entry(R6,
                                                                    R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh3b_entry() //  [R1, R2]
         { info_tbl: [(cghGL,
                       label: sat_sgh3b_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghGL: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fShowCompose_$cshow_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh3a_entry() //  [R1, R2, R3]
         { info_tbl: [(cghGT,
                       label: sat_sgh3a_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghGT: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fShowCompose_$cshowsPrec_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fShowCompose_entry() //  [R2, R3, R4]
         { info_tbl: [(cghGX,
                       label: Data.Functor.Compose.$fShowCompose_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghGX: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cghH1; else goto cghH0;
       cghH1: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fShowCompose_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghH0: // global
           I64[Hp - 120] = sat_sgh3c_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sgh3b_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sgh3a_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 118;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.897306053 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose2_closure" {
     Data.Functor.Compose.$fFunctorCompose2_closure:
         const Data.Functor.Compose.$fFunctorCompose2_info;
 },
 sat_sgh3h_entry() //  [R1]
         { info_tbl: [(cghHv,
                       label: sat_sgh3h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghHv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghHw; else goto cghHx;
       cghHw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghHx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cghHy,
                       label: Data.Functor.Compose.$fFunctorCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghHy: // global
           _sgh3g::P64 = R5;
           _sgh3f::P64 = R4;
           _sgh3e::P64 = R3;
           _sgh3d::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cghHz; else goto cghHA;
       cghHA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghHC; else goto cghHB;
       cghHC: // global
           HpAlloc = 32;
           goto cghHz;
       cghHz: // global
           R5 = _sgh3g::P64;
           R4 = _sgh3f::P64;
           R3 = _sgh3e::P64;
           R2 = _sgh3d::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghHB: // global
           I64[Hp - 24] = sat_sgh3h_info;
           P64[Hp - 8] = _sgh3e::P64;
           P64[Hp] = _sgh3f::P64;
           R2 = _sgh3d::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgh3g::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.903883536 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose1_closure" {
     Data.Functor.Compose.$fFunctorCompose1_closure:
         const Data.Functor.Compose.$fFunctorCompose1_info;
 },
 sat_sgh3n_entry() //  [R1]
         { info_tbl: [(cghI5,
                       label: sat_sgh3n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghI5: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh3o_entry() //  [R1]
         { info_tbl: [(cghI8,
                       label: sat_sgh3o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghI8: // global
           _sgh3o::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cghI9; else goto cghIa;
       cghIa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghIc; else goto cghIb;
       cghIc: // global
           HpAlloc = 16;
           goto cghI9;
       cghI9: // global
           R1 = _sgh3o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghIb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh3o::P64;
           _sgh3j::P64 = P64[_sgh3o::P64 + 16];
           _sgh3k::P64 = P64[_sgh3o::P64 + 24];
           I64[Hp - 8] = sat_sgh3n_info;
           P64[Hp] = _sgh3k::P64;
           R2 = _sgh3j::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFunctorCompose1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cghId,
                       label: Data.Functor.Compose.$fFunctorCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghId: // global
           _sgh3l::P64 = R5;
           _sgh3k::P64 = R4;
           _sgh3j::P64 = R3;
           _sgh3i::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cghIe; else goto cghIf;
       cghIf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghIh; else goto cghIg;
       cghIh: // global
           HpAlloc = 32;
           goto cghIe;
       cghIe: // global
           R5 = _sgh3l::P64;
           R4 = _sgh3k::P64;
           R3 = _sgh3j::P64;
           R2 = _sgh3i::P64;
           R1 = Data.Functor.Compose.$fFunctorCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghIg: // global
           I64[Hp - 24] = sat_sgh3o_info;
           P64[Hp - 8] = _sgh3j::P64;
           P64[Hp] = _sgh3k::P64;
           R2 = _sgh3i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgh3l::P64;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.912531634 UTC

[section ""data" . Data.Functor.Compose.$fFunctorCompose_closure" {
     Data.Functor.Compose.$fFunctorCompose_closure:
         const Data.Functor.Compose.$fFunctorCompose_info;
 },
 sat_sgh3s_entry() //  [R1, R2, R3]
         { info_tbl: [(cghIK,
                       label: sat_sgh3s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghIK: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh3r_entry() //  [R1, R2, R3]
         { info_tbl: [(cghIS,
                       label: sat_sgh3r_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghIS: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFunctorCompose2_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFunctorCompose_entry() //  [R2, R3]
         { info_tbl: [(cghIW,
                       label: Data.Functor.Compose.$fFunctorCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghIW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cghJ0; else goto cghIZ;
       cghJ0: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFunctorCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghIZ: // global
           I64[Hp - 64] = sat_sgh3s_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sgh3r_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.920363155 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info;
 },
 sat_sgh3y_entry() //  [R1]
         { info_tbl: [(cghJp,
                       label: sat_sgh3y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghJp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghJq; else goto cghJr;
       cghJq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghJr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cghJs,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldMap_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghJs: // global
           _sgh3x::P64 = R6;
           _sgh3w::P64 = R5;
           _sgh3v::P64 = R4;
           _sgh3u::P64 = R3;
           _sgh3t::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cghJt; else goto cghJu;
       cghJu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cghJw; else goto cghJv;
       cghJw: // global
           HpAlloc = 40;
           goto cghJt;
       cghJt: // global
           R6 = _sgh3x::P64;
           R5 = _sgh3w::P64;
           R4 = _sgh3v::P64;
           R3 = _sgh3u::P64;
           R2 = _sgh3t::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldMap_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghJv: // global
           I64[Hp - 32] = sat_sgh3y_info;
           P64[Hp - 16] = _sgh3u::P64;
           P64[Hp - 8] = _sgh3v::P64;
           P64[Hp] = _sgh3w::P64;
           R2 = _sgh3t::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgh3v::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sgh3x::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.927778435 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfold_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfold_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfold_info;
 },
 sat_sgh3D_entry() //  [R1]
         { info_tbl: [(cghJV,
                       label: sat_sgh3D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghJV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghJW; else goto cghJX;
       cghJW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghJX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfold_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cghJY,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfold_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghJY: // global
           _sgh3C::P64 = R5;
           _sgh3B::P64 = R4;
           _sgh3A::P64 = R3;
           _sgh3z::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cghJZ; else goto cghK0;
       cghK0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghK2; else goto cghK1;
       cghK2: // global
           HpAlloc = 32;
           goto cghJZ;
       cghJZ: // global
           R5 = _sgh3C::P64;
           R4 = _sgh3B::P64;
           R3 = _sgh3A::P64;
           R2 = _sgh3z::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfold_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghK1: // global
           I64[Hp - 24] = sat_sgh3D_info;
           P64[Hp - 8] = _sgh3A::P64;
           P64[Hp] = _sgh3B::P64;
           R2 = _sgh3z::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sgh3B::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgh3C::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.934856984 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose1_closure" {
     Data.Functor.Compose.$fFoldableCompose1_closure:
         const Data.Functor.Compose.$fFoldableCompose1_info;
 },
 Data.Functor.Compose.$fFoldableCompose1_entry() //  [R2]
         { info_tbl: [(cghKo,
                       label: Data.Functor.Compose.$fFoldableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghKo: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.938868425 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$csum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$csum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$csum_info;
         const 0;
 },
 $dMonoid_sgh3I_entry() //  [R1]
         { info_tbl: [(cghKD,
                       label: $dMonoid_sgh3I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghKD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghKE; else goto cghKF;
       cghKE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghKF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgh3J_entry() //  [R1]
         { info_tbl: [(cghKK,
                       label: lvl8_sgh3J_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghKK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghKL; else goto cghKM;
       cghKL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghKM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh3L_entry() //  [R1, R2]
         { info_tbl: [(cghKS,
                       label: sat_sgh3L_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghKS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghKT; else goto cghKU;
       cghKT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghKU: // global
           _sgh3K::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgh3K::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$csum_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cghKV,
                       label: Data.Functor.Compose.$fFoldableCompose_$csum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghKV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cghKZ; else goto cghKY;
       cghKZ: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$csum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghKY: // global
           I64[Hp - 80] = $dMonoid_sgh3I_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgh3J_info;
           P64[Hp - 40] = R3;
           _cghKz::P64 = Hp - 80;
           P64[Hp - 32] = _cghKz::P64;
           I64[Hp - 24] = sat_sgh3L_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cghKz::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.949039441 UTC

[section ""cstring" . lvl_rgdPQ_bytes" {
     lvl_rgdPQ_bytes:
         I8[] [109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.951094094 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose2_closure" {
     Data.Functor.Compose.$fFoldableCompose2_closure:
         const Data.Functor.Compose.$fFoldableCompose2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose2_entry() //  [R1]
         { info_tbl: [(cghLC,
                       label: Data.Functor.Compose.$fFoldableCompose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghLC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cghLD; else goto cghLE;
       cghLD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghLE: // global
           (_cghLx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cghLx::I64 == 0) goto cghLz; else goto cghLy;
       cghLz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cghLy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cghLx::I64;
           I64[Sp - 24] = block_cghLA_info;
           R2 = lvl_rgdPQ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cghLA() //  [R1]
         { info_tbl: [(cghLA,
                       label: block_cghLA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghLA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.958087615 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cminimum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cminimum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_info;
         const 0;
 },
 $dMonoid_sgh3Q_entry() //  [R1]
         { info_tbl: [(cghM2,
                       label: $dMonoid_sgh3Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghM2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghM3; else goto cghM4;
       cghM3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghM4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgh3R_entry() //  [R1]
         { info_tbl: [(cghM9,
                       label: lvl8_sgh3R_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghM9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghMa; else goto cghMb;
       cghMa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghMb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh3V_entry() //  [R1, R2]
         { info_tbl: [(cghMn,
                       label: sat_sgh3V_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghMn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghMo; else goto cghMp;
       cghMo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghMp: // global
           I64[Sp - 8] = block_cghMh_info;
           _sgh3S::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgh3S::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghMh() //  [R1]
         { info_tbl: [(cghMh,
                       label: block_cghMh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghMh: // global
           if (R1 & 7 == 1) goto cghMk; else goto cghMl;
       cghMk: // global
           R1 = Data.Functor.Compose.$fFoldableCompose2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cghMl: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cminimum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cghMw,
                       label: Data.Functor.Compose.$fFoldableCompose_$cminimum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghMw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cghMA; else goto cghMz;
       cghMA: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghMz: // global
           I64[Hp - 80] = $dMonoid_sgh3Q_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgh3R_info;
           P64[Hp - 40] = R3;
           _cghLY::P64 = Hp - 80;
           P64[Hp - 32] = _cghLY::P64;
           I64[Hp - 24] = sat_sgh3V_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cghLY::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.970206722 UTC

[section ""cstring" . lvl1_rgdPR_bytes" {
     lvl1_rgdPR_bytes:
         I8[] [109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.972211347 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose3_closure" {
     Data.Functor.Compose.$fFoldableCompose3_closure:
         const Data.Functor.Compose.$fFoldableCompose3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose3_entry() //  [R1]
         { info_tbl: [(cghNk,
                       label: Data.Functor.Compose.$fFoldableCompose3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghNk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cghNl; else goto cghNm;
       cghNl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghNm: // global
           (_cghNf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cghNf::I64 == 0) goto cghNh; else goto cghNg;
       cghNh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cghNg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cghNf::I64;
           I64[Sp - 24] = block_cghNi_info;
           R2 = lvl1_rgdPR_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cghNi() //  [R1]
         { info_tbl: [(cghNi,
                       label: block_cghNi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghNi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.979213348 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_info;
         const 0;
 },
 $dMonoid_sgh40_entry() //  [R1]
         { info_tbl: [(cghNK,
                       label: $dMonoid_sgh40_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghNK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghNL; else goto cghNM;
       cghNL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghNM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgh41_entry() //  [R1]
         { info_tbl: [(cghNR,
                       label: lvl8_sgh41_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghNR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghNS; else goto cghNT;
       cghNS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghNT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh45_entry() //  [R1, R2]
         { info_tbl: [(cghO5,
                       label: sat_sgh45_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghO5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghO6; else goto cghO7;
       cghO6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghO7: // global
           I64[Sp - 8] = block_cghNZ_info;
           _sgh42::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_ppp_info;
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = _sgh42::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cghNZ() //  [R1]
         { info_tbl: [(cghNZ,
                       label: block_cghNZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghNZ: // global
           if (R1 & 7 == 1) goto cghO2; else goto cghO3;
       cghO2: // global
           R1 = Data.Functor.Compose.$fFoldableCompose3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cghO3: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cghOe,
                       label: Data.Functor.Compose.$fFoldableCompose_$cmaximum_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghOe: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cghOi; else goto cghOh;
       cghOi: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghOh: // global
           I64[Hp - 80] = $dMonoid_sgh40_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgh41_info;
           P64[Hp - 40] = R3;
           _cghNG::P64 = Hp - 80;
           P64[Hp - 32] = _cghNG::P64;
           I64[Hp - 24] = sat_sgh45_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cghNG::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:11.992128965 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$celem_closure" {
     Data.Functor.Compose.$fFoldableCompose_$celem_closure:
         const Data.Functor.Compose.$fFoldableCompose_$celem_info;
         const 0;
 },
 sat_sgh4b_entry() //  [R1]
         { info_tbl: [(cghP5,
                       label: sat_sgh4b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghP5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghP6; else goto cghP7;
       cghP6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghP7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl8_sgh4a_entry() //  [R1]
         { info_tbl: [(cghP8,
                       label: lvl8_sgh4a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghP8: // global
           _sgh4a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghP9; else goto cghPa;
       cghPa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghPc; else goto cghPb;
       cghPc: // global
           HpAlloc = 32;
           goto cghP9;
       cghP9: // global
           R1 = _sgh4a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghPb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh4a::P64;
           _sgh47::P64 = P64[_sgh4a::P64 + 16];
           _sgh48::P64 = P64[_sgh4a::P64 + 24];
           _sgh49::P64 = P64[_sgh4a::P64 + 32];
           I64[Hp - 24] = sat_sgh4b_info;
           P64[Hp - 8] = _sgh48::P64;
           P64[Hp] = _sgh49::P64;
           R2 = _sgh47::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh4d_entry() //  [R1, R2]
         { info_tbl: [(cghPi,
                       label: sat_sgh4d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghPi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghPj; else goto cghPk;
       cghPj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghPk: // global
           _sgh4c::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _sgh4c::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$celem_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cghPl,
                       label: Data.Functor.Compose.$fFoldableCompose_$celem_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghPl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cghPp; else goto cghPo;
       cghPp: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$celem_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghPo: // global
           I64[Hp - 56] = lvl8_sgh4a_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sgh4d_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.002561277 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose7_closure" {
     Data.Functor.Compose.$fFoldableCompose7_closure:
         const Data.Functor.Compose.$fFoldableCompose7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose7_entry() //  [R1]
         { info_tbl: [(cghQ1,
                       label: Data.Functor.Compose.$fFoldableCompose7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghQ2; else goto cghQ3;
       cghQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghQ3: // global
           (_cghPY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cghPY::I64 == 0) goto cghQ0; else goto cghPZ;
       cghQ0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cghPZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cghPY::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.00718899 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_info;
         const 0;
 },
 sat_sgh4l_entry() //  [R1, R2, R3]
         { info_tbl: [(cghQp,
                       label: sat_sgh4l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghQp: // global
           _sgh4k::P64 = R3;
           R3 = R2;
           R2 = _sgh4k::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh4m_entry() //  [R1]
         { info_tbl: [(cghQs,
                       label: sat_sgh4m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghQs: // global
           _sgh4m::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghQt; else goto cghQu;
       cghQu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghQw; else goto cghQv;
       cghQw: // global
           HpAlloc = 16;
           goto cghQt;
       cghQt: // global
           R1 = _sgh4m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh4m::P64;
           _sgh4f::P64 = P64[_sgh4m::P64 + 16];
           _sgh4g::P64 = P64[_sgh4m::P64 + 24];
           I64[Hp - 8] = sat_sgh4l_info;
           P64[Hp] = _sgh4g::P64;
           R2 = _sgh4f::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cghQx,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghQx: // global
           _sgh4i::P64 = R6;
           _sgh4h::P64 = R5;
           _sgh4g::P64 = R4;
           _sgh4f::P64 = R3;
           _sgh4e::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghQy; else goto cghQz;
       cghQz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghQB; else goto cghQA;
       cghQB: // global
           HpAlloc = 32;
           goto cghQy;
       cghQy: // global
           R6 = _sgh4i::P64;
           R5 = _sgh4h::P64;
           R4 = _sgh4g::P64;
           R3 = _sgh4f::P64;
           R2 = _sgh4e::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghQA: // global
           I64[Hp - 24] = sat_sgh4m_info;
           P64[Hp - 8] = _sgh4f::P64;
           P64[Hp] = _sgh4g::P64;
           R2 = _sgh4e::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgh4i::P64;
           P64[Sp - 8] = _sgh4h::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.016509788 UTC

[section ""cstring" . lvl2_rgdPS_bytes" {
     lvl2_rgdPS_bytes:
         I8[] [102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.018525714 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose6_closure" {
     Data.Functor.Compose.$fFoldableCompose6_closure:
         const Data.Functor.Compose.$fFoldableCompose6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose6_entry() //  [R1]
         { info_tbl: [(cghR6,
                       label: Data.Functor.Compose.$fFoldableCompose6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghR6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cghR7; else goto cghR8;
       cghR7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghR8: // global
           (_cghR1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cghR1::I64 == 0) goto cghR3; else goto cghR2;
       cghR3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cghR2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cghR1::I64;
           I64[Sp - 24] = block_cghR4_info;
           R2 = lvl2_rgdPS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cghR4() //  [R1]
         { info_tbl: [(cghR4,
                       label: block_cghR4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghR4: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.025178162 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info;
         const 0;
 },
 sat_sgh4w_entry() //  [R1]
         { info_tbl: [(cghRM,
                       label: sat_sgh4w_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghRM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghRN; else goto cghRO;
       cghRN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghRO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cghRF_info;
           _sgh4q::P64 = P64[R1 + 16];
           _sgh4s::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgh4q::P64;
           P64[Sp - 24] = _sgh4s::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ughRV; else goto cghRG;
       ughRV: // global
           call _cghRF(R1) args: 0, res: 0, upd: 0;
       cghRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cghRF() //  [R1]
         { info_tbl: [(cghRF,
                       label: block_cghRF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghRF: // global
           _sgh4s::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cghRJ; else goto cghRK;
       cghRJ: // global
           R1 = _sgh4s::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cghRK: // global
           R3 = _sgh4s::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh4x_entry() //  [R1, R2, R3]
         { info_tbl: [(cghRX,
                       label: sat_sgh4x_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghRX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cghS1; else goto cghS0;
       cghS1: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghS0: // global
           _sgh4q::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgh4w_info;
           P64[Hp - 32] = _sgh4q::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh4y_entry() //  [R1]
         { info_tbl: [(cghS2,
                       label: sat_sgh4y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghS2: // global
           _sgh4y::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghS3; else goto cghS4;
       cghS4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghS6; else goto cghS5;
       cghS6: // global
           HpAlloc = 16;
           goto cghS3;
       cghS3: // global
           R1 = _sgh4y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghS5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh4y::P64;
           _sgh4p::P64 = P64[_sgh4y::P64 + 16];
           _sgh4q::P64 = P64[_sgh4y::P64 + 24];
           I64[Hp - 8] = sat_sgh4x_info;
           P64[Hp] = _sgh4q::P64;
           R2 = _sgh4p::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cghSd,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghSd: // global
           _sgh4r::P64 = R5;
           _sgh4q::P64 = R4;
           _sgh4p::P64 = R3;
           _sgh4o::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cghSe; else goto cghSf;
       cghSf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghSh; else goto cghSg;
       cghSh: // global
           HpAlloc = 32;
           goto cghSe;
       cghSe: // global
           R5 = _sgh4r::P64;
           R4 = _sgh4q::P64;
           R3 = _sgh4p::P64;
           R2 = _sgh4o::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghSg: // global
           I64[Hp - 24] = sat_sgh4y_info;
           P64[Hp - 8] = _sgh4p::P64;
           P64[Hp] = _sgh4q::P64;
           I64[Sp - 8] = block_cghS7_info;
           R2 = _sgh4o::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh4r::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cghS7() //  [R1]
         { info_tbl: [(cghS7,
                       label: block_cghS7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghS7: // global
           if (R1 & 7 == 1) goto cghSa; else goto cghSb;
       cghSa: // global
           R1 = Data.Functor.Compose.$fFoldableCompose6_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cghSb: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.040756023 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info;
         const 0;
 },
 sat_sgh4K_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cghTm,
                       label: sat_sgh4K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghTm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghTn; else goto cghTo;
       cghTn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghTo: // global
           I64[Sp - 16] = block_cghTk_info;
           _sgh4H::P64 = R3;
           R3 = R4;
           R2 = R2;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgh4H::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghTk() //  [R1]
         { info_tbl: [(cghTk,
                       label: block_cghTk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghTk: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh4L_entry() //  [R1]
         { info_tbl: [(cghTq,
                       label: sat_sgh4L_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghTq: // global
           _sgh4L::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghTr; else goto cghTs;
       cghTs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghTu; else goto cghTt;
       cghTu: // global
           HpAlloc = 16;
           goto cghTr;
       cghTr: // global
           R1 = _sgh4L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghTt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh4L::P64;
           _sgh4C::P64 = P64[_sgh4L::P64 + 16];
           _sgh4D::P64 = P64[_sgh4L::P64 + 24];
           I64[Hp - 8] = sat_sgh4K_info;
           P64[Hp] = _sgh4D::P64;
           R2 = _sgh4C::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cghTv,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghTv: // global
           _sgh4F::P64 = R6;
           _sgh4E::P64 = R5;
           _sgh4D::P64 = R4;
           _sgh4C::P64 = R3;
           _sgh4B::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cghTw; else goto cghTx;
       cghTx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghTz; else goto cghTy;
       cghTz: // global
           HpAlloc = 32;
           goto cghTw;
       cghTw: // global
           R6 = _sgh4F::P64;
           R5 = _sgh4E::P64;
           R4 = _sgh4D::P64;
           R3 = _sgh4C::P64;
           R2 = _sgh4B::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghTy: // global
           I64[Hp - 24] = sat_sgh4L_info;
           P64[Hp - 8] = _sgh4C::P64;
           P64[Hp] = _sgh4D::P64;
           R2 = _sgh4B::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Compose.$fFoldableCompose7_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh4F::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgh4E::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.052714766 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_info;
         const 0;
 },
 sat_sgh4R_entry() //  [R1]
         { info_tbl: [(cghUa,
                       label: sat_sgh4R_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghUa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghUb; else goto cghUc;
       cghUb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghUc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry() //  [R2, R3,
                                                             R4, R5, R6]
         { info_tbl: [(cghUd,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghUd: // global
           _sgh4Q::P64 = R6;
           _sgh4P::P64 = R5;
           _sgh4O::P64 = R4;
           _sgh4N::P64 = R3;
           _sgh4M::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghUe; else goto cghUf;
       cghUf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghUh; else goto cghUg;
       cghUh: // global
           HpAlloc = 32;
           goto cghUe;
       cghUe: // global
           R6 = _sgh4Q::P64;
           R5 = _sgh4P::P64;
           R4 = _sgh4O::P64;
           R3 = _sgh4N::P64;
           R2 = _sgh4M::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghUg: // global
           I64[Hp - 24] = sat_sgh4R_info;
           P64[Hp - 8] = _sgh4N::P64;
           P64[Hp] = _sgh4O::P64;
           R2 = _sgh4M::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgh4Q::P64;
           P64[Sp - 8] = _sgh4P::P64;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.063042432 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info;
         const 0;
 },
 sat_sgh51_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cghUO,
                       label: sat_sgh51_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghUO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghUP; else goto cghUQ;
       cghUP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghUQ: // global
           I64[Sp - 16] = block_cghUM_info;
           _sgh4Y::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sgh4Y::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghUM() //  [R1]
         { info_tbl: [(cghUM,
                       label: block_cghUM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghUM: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh52_entry() //  [R1]
         { info_tbl: [(cghUS,
                       label: sat_sgh52_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghUS: // global
           _sgh52::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghUT; else goto cghUU;
       cghUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghUW; else goto cghUV;
       cghUW: // global
           HpAlloc = 16;
           goto cghUT;
       cghUT: // global
           R1 = _sgh52::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh52::P64;
           _sgh4T::P64 = P64[_sgh52::P64 + 16];
           _sgh4U::P64 = P64[_sgh52::P64 + 24];
           I64[Hp - 8] = sat_sgh51_info;
           P64[Hp] = _sgh4U::P64;
           R2 = _sgh4T::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 5;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry() //  [R2,
                                                              R3, R4, R5, R6]
         { info_tbl: [(cghUX,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghUX: // global
           _sgh4W::P64 = R6;
           _sgh4V::P64 = R5;
           _sgh4U::P64 = R4;
           _sgh4T::P64 = R3;
           _sgh4S::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cghUY; else goto cghUZ;
       cghUZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghV1; else goto cghV0;
       cghV1: // global
           HpAlloc = 32;
           goto cghUY;
       cghUY: // global
           R6 = _sgh4W::P64;
           R5 = _sgh4V::P64;
           R4 = _sgh4U::P64;
           R3 = _sgh4T::P64;
           R2 = _sgh4S::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghV0: // global
           I64[Hp - 24] = sat_sgh52_info;
           P64[Hp - 8] = _sgh4T::P64;
           P64[Hp] = _sgh4U::P64;
           R2 = _sgh4S::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh4W::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = _sgh4V::P64;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.075742179 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose4_closure" {
     Data.Functor.Compose.$fFoldableCompose4_closure:
         const Data.Functor.Compose.$fFoldableCompose4_info;
 },
 Data.Functor.Compose.$fFoldableCompose4_entry() //  [R2, R3, R4]
         { info_tbl: [(cghVB,
                       label: Data.Functor.Compose.$fFoldableCompose4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghVI; else goto cghVJ;
       cghVI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghVJ: // global
           I64[Sp - 16] = block_cghVy_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ughVN; else goto cghVz;
       ughVN: // global
           call _cghVy(R1) args: 0, res: 0, upd: 0;
       cghVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghVy() //  [R1]
         { info_tbl: [(cghVy,
                       label: block_cghVy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghVy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghVM; else goto cghVL;
       cghVM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cghVL: // global
           _sgh58::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgh58::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.082130092 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$clength_closure" {
     Data.Functor.Compose.$fFoldableCompose_$clength_closure:
         const Data.Functor.Compose.$fFoldableCompose_$clength_info;
         const 0;
 },
 sat_sgh5d_entry() //  [R1]
         { info_tbl: [(cghW8,
                       label: sat_sgh5d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghW8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghW9; else goto cghWa;
       cghW9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghWa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose4_closure+3;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$clength_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cghWb,
                       label: Data.Functor.Compose.$fFoldableCompose_$clength_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghWb: // global
           _sgh5c::P64 = R4;
           _sgh5b::P64 = R3;
           _sgh5a::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cghWc; else goto cghWd;
       cghWd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghWf; else goto cghWe;
       cghWf: // global
           HpAlloc = 24;
           goto cghWc;
       cghWc: // global
           R4 = _sgh5c::P64;
           R3 = _sgh5b::P64;
           R2 = _sgh5a::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$clength_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghWe: // global
           I64[Hp - 16] = sat_sgh5d_info;
           P64[Hp] = _sgh5b::P64;
           R2 = _sgh5a::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgh5c::P64;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = Data.Functor.Compose.$fDataCompose3_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.088386124 UTC

[section ""cstring" . lvl3_rgdPT_bytes" {
     lvl3_rgdPT_bytes:
         I8[] [102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.09042936 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose8_closure" {
     Data.Functor.Compose.$fFoldableCompose8_closure:
         const Data.Functor.Compose.$fFoldableCompose8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Compose.$fFoldableCompose8_entry() //  [R1]
         { info_tbl: [(cghWJ,
                       label: Data.Functor.Compose.$fFoldableCompose8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghWJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cghWK; else goto cghWL;
       cghWK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghWL: // global
           (_cghWE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cghWE::I64 == 0) goto cghWG; else goto cghWF;
       cghWG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cghWF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cghWE::I64;
           I64[Sp - 24] = block_cghWH_info;
           R2 = lvl3_rgdPT_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cghWH() //  [R1]
         { info_tbl: [(cghWH,
                       label: block_cghWH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghWH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.097557414 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info;
         const 0;
 },
 sat_sgh5n_entry() //  [R1]
         { info_tbl: [(cghXp,
                       label: sat_sgh5n_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghXp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghXq; else goto cghXr;
       cghXq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghXr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cghXi_info;
           _sgh5h::P64 = P64[R1 + 16];
           _sgh5j::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sgh5h::P64;
           P64[Sp - 24] = _sgh5j::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ughXy; else goto cghXj;
       ughXy: // global
           call _cghXi(R1) args: 0, res: 0, upd: 0;
       cghXj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cghXi() //  [R1]
         { info_tbl: [(cghXi,
                       label: block_cghXi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghXi: // global
           _sgh5j::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cghXm; else goto cghXn;
       cghXm: // global
           R1 = _sgh5j::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cghXn: // global
           R3 = P64[R1 + 6];
           R2 = _sgh5j::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh5o_entry() //  [R1, R2, R3]
         { info_tbl: [(cghXA,
                       label: sat_sgh5o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghXA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cghXE; else goto cghXD;
       cghXE: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cghXD: // global
           _sgh5h::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sgh5n_info;
           P64[Hp - 32] = _sgh5h::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5p_entry() //  [R1]
         { info_tbl: [(cghXF,
                       label: sat_sgh5p_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghXF: // global
           _sgh5p::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cghXG; else goto cghXH;
       cghXH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cghXJ; else goto cghXI;
       cghXJ: // global
           HpAlloc = 16;
           goto cghXG;
       cghXG: // global
           R1 = _sgh5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghXI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh5p::P64;
           _sgh5g::P64 = P64[_sgh5p::P64 + 16];
           _sgh5h::P64 = P64[_sgh5p::P64 + 24];
           I64[Hp - 8] = sat_sgh5o_info;
           P64[Hp] = _sgh5h::P64;
           R2 = _sgh5g::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 6;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cghXQ,
                       label: Data.Functor.Compose.$fFoldableCompose_$cfoldr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghXQ: // global
           _sgh5i::P64 = R5;
           _sgh5h::P64 = R4;
           _sgh5g::P64 = R3;
           _sgh5f::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cghXR; else goto cghXS;
       cghXS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cghXU; else goto cghXT;
       cghXU: // global
           HpAlloc = 32;
           goto cghXR;
       cghXR: // global
           R5 = _sgh5i::P64;
           R4 = _sgh5h::P64;
           R3 = _sgh5g::P64;
           R2 = _sgh5f::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghXT: // global
           I64[Hp - 24] = sat_sgh5p_info;
           P64[Hp - 8] = _sgh5g::P64;
           P64[Hp] = _sgh5h::P64;
           I64[Sp - 8] = block_cghXK_info;
           R2 = _sgh5f::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sgh5i::P64;
           P64[Sp - 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 48;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cghXK() //  [R1]
         { info_tbl: [(cghXK,
                       label: block_cghXK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghXK: // global
           if (R1 & 7 == 1) goto cghXN; else goto cghXO;
       cghXN: // global
           R1 = Data.Functor.Compose.$fFoldableCompose8_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cghXO: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.112118126 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose5_closure" {
     Data.Functor.Compose.$fFoldableCompose5_closure:
         const Data.Functor.Compose.$fFoldableCompose5_info;
 },
 Data.Functor.Compose.$fFoldableCompose5_entry() //  []
         { info_tbl: [(cghYO,
                       label: Data.Functor.Compose.$fFoldableCompose5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghYO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.1157384 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cnull_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cnull_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cnull_info;
         const 0;
 },
 sat_sgh5x_entry() //  [R1]
         { info_tbl: [(cghZ5,
                       label: sat_sgh5x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghZ5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghZ6; else goto cghZ7;
       cghZ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghZ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose5_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cnull_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cghZ8,
                       label: Data.Functor.Compose.$fFoldableCompose_$cnull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghZ8: // global
           _sgh5w::P64 = R4;
           _sgh5v::P64 = R3;
           _sgh5u::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cghZ9; else goto cghZa;
       cghZa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cghZc; else goto cghZb;
       cghZc: // global
           HpAlloc = 24;
           goto cghZ9;
       cghZ9: // global
           R4 = _sgh5w::P64;
           R3 = _sgh5v::P64;
           R2 = _sgh5u::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghZb: // global
           I64[Hp - 16] = sat_sgh5x_info;
           P64[Hp] = _sgh5v::P64;
           R2 = _sgh5u::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgh5w::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.122625498 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$cproduct_closure" {
     Data.Functor.Compose.$fFoldableCompose_$cproduct_closure:
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_info;
         const 0;
 },
 $dMonoid_sgh5B_entry() //  [R1]
         { info_tbl: [(cghZE,
                       label: $dMonoid_sgh5B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghZE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cghZF; else goto cghZG;
       cghZF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghZG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_sgh5C_entry() //  [R1]
         { info_tbl: [(cghZL,
                       label: lvl8_sgh5C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghZL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghZM; else goto cghZN;
       cghZM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghZN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Functor.Compose.$fFoldableCompose1_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh5E_entry() //  [R1, R2]
         { info_tbl: [(cghZT,
                       label: sat_sgh5E_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghZT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cghZU; else goto cghZV;
       cghZU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cghZV: // global
           _sgh5D::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = _sgh5D::P64;
           Sp = Sp - 32;
           call Data.Foldable.foldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$cproduct_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cghZW,
                       label: Data.Functor.Compose.$fFoldableCompose_$cproduct_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghZW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgi00; else goto cghZZ;
       cgi00: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cghZZ: // global
           I64[Hp - 80] = $dMonoid_sgh5B_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl8_sgh5C_info;
           P64[Hp - 40] = R3;
           _cghZA::P64 = Hp - 80;
           P64[Hp - 32] = _cghZA::P64;
           I64[Hp - 24] = sat_sgh5E_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _cghZA::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.133226861 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_$ctoList_closure" {
     Data.Functor.Compose.$fFoldableCompose_$ctoList_closure:
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_info;
         const 0;
 },
 sat_sgh5I_entry() //  [R1]
         { info_tbl: [(cgi0C,
                       label: sat_sgh5I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi0C: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgi0D; else goto cgi0E;
       cgi0D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi0E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_$ctoList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cgi0F,
                       label: Data.Functor.Compose.$fFoldableCompose_$ctoList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi0F: // global
           _sgh5H::P64 = R4;
           _sgh5G::P64 = R3;
           _sgh5F::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgi0G; else goto cgi0H;
       cgi0H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgi0J; else goto cgi0I;
       cgi0J: // global
           HpAlloc = 24;
           goto cgi0G;
       cgi0G: // global
           R4 = _sgh5H::P64;
           R3 = _sgh5G::P64;
           R2 = _sgh5F::P64;
           R1 = Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi0I: // global
           I64[Hp - 16] = sat_sgh5I_info;
           P64[Hp] = _sgh5G::P64;
           R2 = _sgh5F::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgh5H::P64;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Foldable.foldMap_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.142579303 UTC

[section ""data" . Data.Functor.Compose.$fFoldableCompose_closure" {
     Data.Functor.Compose.$fFoldableCompose_closure:
         const Data.Functor.Compose.$fFoldableCompose_info;
         const 0;
 },
 sat_sgh60_entry() //  [R1, R2]
         { info_tbl: [(cgi1d,
                       label: sat_sgh60_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1d: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cproduct_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5Z_entry() //  [R1, R2]
         { info_tbl: [(cgi1l,
                       label: sat_sgh5Z_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1l: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$csum_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5Y_entry() //  [R1, R2]
         { info_tbl: [(cgi1t,
                       label: sat_sgh5Y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1t: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cminimum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5X_entry() //  [R1, R2]
         { info_tbl: [(cgi1B,
                       label: sat_sgh5X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1B: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cmaximum_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5W_entry() //  [R1, R2, R3]
         { info_tbl: [(cgi1J,
                       label: sat_sgh5W_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1J: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$celem_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5V_entry() //  [R1, R2]
         { info_tbl: [(cgi1R,
                       label: sat_sgh5V_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1R: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$clength_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5U_entry() //  [R1, R2]
         { info_tbl: [(cgi1Z,
                       label: sat_sgh5U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1Z: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$cnull_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5T_entry() //  [R1, R2]
         { info_tbl: [(cgi27,
                       label: sat_sgh5T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi27: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fFoldableCompose_$ctoList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5S_entry() //  [R1, R2, R3]
         { info_tbl: [(cgi2f,
                       label: sat_sgh5S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi2f: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5R_entry() //  [R1, R2, R3]
         { info_tbl: [(cgi2n,
                       label: sat_sgh5R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi2n: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr1_entry(R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5Q_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi2v,
                       label: sat_sgh5Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi2v: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5P_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi2D,
                       label: sat_sgh5P_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi2D: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldl_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5O_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi2L,
                       label: sat_sgh5O_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi2L: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr'_entry(R6,
                                                                      R5,
                                                                      R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5N_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi2T,
                       label: sat_sgh5N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi2T: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldr_entry(R6,
                                                                     R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5M_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi31,
                       label: sat_sgh5M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi31: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fFoldableCompose_$cfoldMap_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh5L_entry() //  [R1, R2, R3]
         { info_tbl: [(cgi39,
                       label: sat_sgh5L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi39: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fFoldableCompose_$cfold_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fFoldableCompose_entry() //  [R2, R3]
         { info_tbl: [(cgi3d,
                       label: Data.Functor.Compose.$fFoldableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi3d: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cgi3h; else goto cgi3g;
       cgi3h: // global
           HpAlloc = 520;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fFoldableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi3g: // global
           I64[Hp - 512] = sat_sgh60_info;
           P64[Hp - 504] = R2;
           P64[Hp - 496] = R3;
           I64[Hp - 488] = sat_sgh5Z_info;
           P64[Hp - 480] = R2;
           P64[Hp - 472] = R3;
           I64[Hp - 464] = sat_sgh5Y_info;
           P64[Hp - 456] = R2;
           P64[Hp - 448] = R3;
           I64[Hp - 440] = sat_sgh5X_info;
           P64[Hp - 432] = R2;
           P64[Hp - 424] = R3;
           I64[Hp - 416] = sat_sgh5W_info;
           P64[Hp - 408] = R2;
           P64[Hp - 400] = R3;
           I64[Hp - 392] = sat_sgh5V_info;
           P64[Hp - 384] = R2;
           P64[Hp - 376] = R3;
           I64[Hp - 368] = sat_sgh5U_info;
           P64[Hp - 360] = R2;
           P64[Hp - 352] = R3;
           I64[Hp - 344] = sat_sgh5T_info;
           P64[Hp - 336] = R2;
           P64[Hp - 328] = R3;
           I64[Hp - 320] = sat_sgh5S_info;
           P64[Hp - 312] = R2;
           P64[Hp - 304] = R3;
           I64[Hp - 296] = sat_sgh5R_info;
           P64[Hp - 288] = R2;
           P64[Hp - 280] = R3;
           I64[Hp - 272] = sat_sgh5Q_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_sgh5P_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_sgh5O_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_sgh5N_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgh5M_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgh5L_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = Data.Foldable.C:Foldable_con_info;
           P64[Hp - 120] = Hp - 150;
           P64[Hp - 112] = Hp - 173;
           P64[Hp - 104] = Hp - 197;
           P64[Hp - 96] = Hp - 221;
           P64[Hp - 88] = Hp - 245;
           P64[Hp - 80] = Hp - 269;
           P64[Hp - 72] = Hp - 294;
           P64[Hp - 64] = Hp - 318;
           P64[Hp - 56] = Hp - 343;
           P64[Hp - 48] = Hp - 367;
           P64[Hp - 40] = Hp - 391;
           P64[Hp - 32] = Hp - 414;
           P64[Hp - 24] = Hp - 439;
           P64[Hp - 16] = Hp - 463;
           P64[Hp - 8] = Hp - 487;
           P64[Hp] = Hp - 511;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.174147198 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose1_closure" {
     Data.Functor.Compose.$fTraversableCompose1_closure:
         const Data.Functor.Compose.$fTraversableCompose1_info;
 },
 Data.Functor.Compose.$fTraversableCompose1_entry() //  [R2]
         { info_tbl: [(cgi4K,
                       label: Data.Functor.Compose.$fTraversableCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi4K: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.178626337 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure" {
     Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure:
         const Data.Functor.Compose.$fTraversableCompose_$ctraverse_info;
 },
 sat_sgh68_entry() //  [R1]
         { info_tbl: [(cgi53,
                       label: sat_sgh68_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi53: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgi54; else goto cgi55;
       cgi54: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi55: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh69_entry() //  [R1]
         { info_tbl: [(cgi56,
                       label: sat_sgh69_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi56: // global
           _sgh69::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cgi57; else goto cgi58;
       cgi58: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgi5a; else goto cgi59;
       cgi5a: // global
           HpAlloc = 40;
           goto cgi57;
       cgi57: // global
           R1 = _sgh69::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi59: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh69::P64;
           _sgh62::P64 = P64[_sgh69::P64 + 16];
           _sgh63::P64 = P64[_sgh69::P64 + 24];
           _sgh64::P64 = P64[_sgh69::P64 + 32];
           _sgh65::P64 = P64[_sgh69::P64 + 40];
           _sgh66::P64 = P64[_sgh69::P64 + 48];
           I64[Hp - 32] = sat_sgh68_info;
           P64[Hp - 16] = _sgh63::P64;
           P64[Hp - 8] = _sgh64::P64;
           P64[Hp] = _sgh65::P64;
           R2 = _sgh62::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sgh64::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgh66::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry() //  [R2,
                                                                   R3, R4, R5, R6]
         { info_tbl: [(cgi5d,
                       label: Data.Functor.Compose.$fTraversableCompose_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi5d: // global
           _sgh66::P64 = R6;
           _sgh65::P64 = R5;
           _sgh64::P64 = R4;
           _sgh63::P64 = R3;
           _sgh62::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgi5e; else goto cgi5f;
       cgi5f: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgi5h; else goto cgi5g;
       cgi5h: // global
           HpAlloc = 56;
           goto cgi5e;
       cgi5e: // global
           R6 = _sgh66::P64;
           R5 = _sgh65::P64;
           R4 = _sgh64::P64;
           R3 = _sgh63::P64;
           R2 = _sgh62::P64;
           R1 = Data.Functor.Compose.$fTraversableCompose_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi5g: // global
           I64[Hp - 48] = sat_sgh69_info;
           P64[Hp - 32] = _sgh62::P64;
           P64[Hp - 24] = _sgh63::P64;
           P64[Hp - 16] = _sgh64::P64;
           P64[Hp - 8] = _sgh65::P64;
           P64[Hp] = _sgh66::P64;
           I64[Sp - 16] = block_cgi5b_info;
           R2 = _sgh64::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgi5b() //  [R1]
         { info_tbl: [(cgi5b,
                       label: block_cgi5b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi5b: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Functor.Compose.$fTraversableCompose1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.189776454 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info;
         const 0;
 },
 sat_sgh6d_entry() //  [R1]
         { info_tbl: [(cgi5W,
                       label: sat_sgh6d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi5W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgi5X; else goto cgi5Y;
       cgi5X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi5Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh6c_entry() //  [R1]
         { info_tbl: [(cgi63,
                       label: sat_sgh6c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi63: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgi64; else goto cgi65;
       cgi64: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi65: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgi66,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi66: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgi6a; else goto cgi69;
       cgi6a: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi69: // global
           I64[Hp - 40] = sat_sgh6d_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgh6c_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFoldableCompose_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.19764976 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info;
 },
 sat_sgh6h_entry() //  [R1]
         { info_tbl: [(cgi6z,
                       label: sat_sgh6h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgi6A; else goto cgi6B;
       cgi6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi6B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh6g_entry() //  [R1]
         { info_tbl: [(cgi6G,
                       label: sat_sgh6g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi6G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgi6H; else goto cgi6I;
       cgi6H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi6I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgi6J,
                       label: Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi6J: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgi6N; else goto cgi6M;
       cgi6N: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi6M: // global
           I64[Hp - 40] = sat_sgh6h_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgh6g_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.205175082 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequenceA_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequenceA_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cgi78,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi78: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.208938006 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$cmapM_closure" {
     Data.Functor.Compose.$fTraversableCompose_$cmapM_closure:
         const Data.Functor.Compose.$fTraversableCompose_$cmapM_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$cmapM_entry() //  [R2,
                                                               R3, R4, R5, R6]
         { info_tbl: [(cgi7m,
                       label: Data.Functor.Compose.$fTraversableCompose_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi7m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgi7n; else goto cgi7o;
       cgi7n: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi7o: // global
           I64[Sp - 40] = block_cgi7k_info;
           _sgh6l::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sgh6l::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgi7k() //  [R1]
         { info_tbl: [(cgi7k,
                       label: block_cgi7k_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi7k: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.215373341 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_$csequence_closure" {
     Data.Functor.Compose.$fTraversableCompose_$csequence_closure:
         const Data.Functor.Compose.$fTraversableCompose_$csequence_info;
 },
 Data.Functor.Compose.$fTraversableCompose_$csequence_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cgi7H,
                       label: Data.Functor.Compose.$fTraversableCompose_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi7H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgi7I; else goto cgi7J;
       cgi7I: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi7J: // global
           I64[Sp - 32] = block_cgi7F_info;
           _sgh6r::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgh6r::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgi7F() //  [R1]
         { info_tbl: [(cgi7F,
                       label: block_cgi7F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi7F: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.222263869 UTC

[section ""data" . Data.Functor.Compose.$fTraversableCompose_closure" {
     Data.Functor.Compose.$fTraversableCompose_closure:
         const Data.Functor.Compose.$fTraversableCompose_info;
         const 0;
 },
 sat_sgh6D_entry() //  [R1, R2, R3]
         { info_tbl: [(cgi86,
                       label: sat_sgh6D_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi86: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequence_entry(R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh6C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi8e,
                       label: sat_sgh6C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi8e: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$cmapM_entry(R6,
                                                                       R5,
                                                                       R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh6B_entry() //  [R1, R2, R3]
         { info_tbl: [(cgi8m,
                       label: sat_sgh6B_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi8m: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fTraversableCompose_$csequenceA_entry(R5,
                                                                            R4,
                                                                            R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh6A_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgi8u,
                       label: sat_sgh6A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi8u: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fTraversableCompose_$ctraverse_entry(R6,
                                                                           R5,
                                                                           R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh6z_entry() //  [R1]
         { info_tbl: [(cgi8B,
                       label: sat_sgh6z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi8B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgi8C; else goto cgi8D;
       cgi8C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi8D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh6y_entry() //  [R1]
         { info_tbl: [(cgi8I,
                       label: sat_sgh6y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi8I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgi8J; else goto cgi8K;
       cgi8J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi8K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fTraversableCompose_$cp1Traversable_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fTraversableCompose_entry() //  [R2, R3]
         { info_tbl: [(cgi8M,
                       label: Data.Functor.Compose.$fTraversableCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi8M: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cgi8Q; else goto cgi8P;
       cgi8Q: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fTraversableCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi8P: // global
           I64[Hp - 208] = sat_sgh6D_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sgh6C_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sgh6B_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sgh6A_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sgh6z_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgh6y_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.23755376 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose4_closure" {
     Data.Functor.Compose.$fApplicativeCompose4_closure:
         const Data.Functor.Compose.$fApplicativeCompose4_info;
 },
 sat_sgh6J_entry() //  [R1]
         { info_tbl: [(cgi9D,
                       label: sat_sgh6J_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi9D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgi9E; else goto cgi9F;
       cgi9E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi9F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose4_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cgi9G,
                       label: Data.Functor.Compose.$fApplicativeCompose4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi9G: // global
           _sgh6I::P64 = R6;
           _sgh6H::P64 = R5;
           _sgh6G::P64 = R4;
           _sgh6F::P64 = R3;
           _sgh6E::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgi9H; else goto cgi9I;
       cgi9I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgi9K; else goto cgi9J;
       cgi9K: // global
           HpAlloc = 32;
           goto cgi9H;
       cgi9H: // global
           R6 = _sgh6I::P64;
           R5 = _sgh6H::P64;
           R4 = _sgh6G::P64;
           R3 = _sgh6F::P64;
           R2 = _sgh6E::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi9J: // global
           I64[Hp - 24] = sat_sgh6J_info;
           P64[Hp - 8] = _sgh6F::P64;
           P64[Hp] = _sgh6G::P64;
           R2 = _sgh6E::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 24;
           P64[Sp - 16] = _sgh6H::P64;
           P64[Sp - 8] = _sgh6I::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.244048963 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose5_closure" {
     Data.Functor.Compose.$fApplicativeCompose5_closure:
         const Data.Functor.Compose.$fApplicativeCompose5_info;
 },
 sat_sgh6O_entry() //  [R1]
         { info_tbl: [(cgia8,
                       label: sat_sgh6O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgia8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgia9; else goto cgiaa;
       cgia9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiaa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose5_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgiab,
                       label: Data.Functor.Compose.$fApplicativeCompose5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiab: // global
           _sgh6N::P64 = R5;
           _sgh6M::P64 = R4;
           _sgh6L::P64 = R3;
           _sgh6K::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgiac; else goto cgiad;
       cgiad: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgiaf; else goto cgiae;
       cgiaf: // global
           HpAlloc = 24;
           goto cgiac;
       cgiac: // global
           R5 = _sgh6N::P64;
           R4 = _sgh6M::P64;
           R3 = _sgh6L::P64;
           R2 = _sgh6K::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiae: // global
           I64[Hp - 16] = sat_sgh6O_info;
           P64[Hp] = _sgh6L::P64;
           R2 = _sgh6K::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgh6M::P64;
           P64[Sp - 8] = _sgh6N::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.250391152 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose6_closure" {
     Data.Functor.Compose.$fApplicativeCompose6_closure:
         const Data.Functor.Compose.$fApplicativeCompose6_info;
 },
 sat_sgh6S_entry() //  [R1]
         { info_tbl: [(cgiaB,
                       label: sat_sgh6S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiaB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgiaC; else goto cgiaD;
       cgiaC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiaD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose6_entry() //  [R2, R3, R4]
         { info_tbl: [(cgiaE,
                       label: Data.Functor.Compose.$fApplicativeCompose6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiaE: // global
           _sgh6R::P64 = R4;
           _sgh6Q::P64 = R3;
           _sgh6P::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cgiaF; else goto cgiaG;
       cgiaG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgiaI; else goto cgiaH;
       cgiaI: // global
           HpAlloc = 32;
           goto cgiaF;
       cgiaF: // global
           R4 = _sgh6R::P64;
           R3 = _sgh6Q::P64;
           R2 = _sgh6P::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose6_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiaH: // global
           I64[Hp - 24] = sat_sgh6S_info;
           P64[Hp - 8] = _sgh6Q::P64;
           P64[Hp] = _sgh6R::P64;
           R2 = _sgh6P::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.258345749 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure" {
     Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure:
         const Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info;
 },
 sat_sgh6W_entry() //  [R1]
         { info_tbl: [(cgib6,
                       label: sat_sgh6W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgib6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgib7; else goto cgib8;
       cgib7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgib8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh6V_entry() //  [R1]
         { info_tbl: [(cgibd,
                       label: sat_sgh6V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgibd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgibe; else goto cgibf;
       cgibe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgibf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgibg,
                       label: Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgibg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgibk; else goto cgibj;
       cgibk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgibj: // global
           I64[Hp - 40] = sat_sgh6W_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sgh6V_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fFunctorCompose_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.266001539 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose3_closure" {
     Data.Functor.Compose.$fApplicativeCompose3_closure:
         const Data.Functor.Compose.$fApplicativeCompose3_info;
 },
 Data.Functor.Compose.$fApplicativeCompose3_entry() //  [R3]
         { info_tbl: [(cgibF,
                       label: Data.Functor.Compose.$fApplicativeCompose3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgibF: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.270145612 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose2_closure" {
     Data.Functor.Compose.$fApplicativeCompose2_closure:
         const Data.Functor.Compose.$fApplicativeCompose2_info;
 },
 sat_sgh76_entry() //  [R1]
         { info_tbl: [(cgic0,
                       label: sat_sgh76_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgic0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgic1; else goto cgic2;
       cgic1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgic2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgibY_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgibY() //  [R1]
         { info_tbl: [(cgibY,
                       label: block_cgibY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgibY: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Functor.Compose.$fApplicativeCompose3_closure+2;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh77_entry() //  [R1]
         { info_tbl: [(cgic8,
                       label: sat_sgh77_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgic8: // global
           _sgh77::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgic9; else goto cgica;
       cgica: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgicc; else goto cgicb;
       cgicc: // global
           HpAlloc = 24;
           goto cgic9;
       cgic9: // global
           R1 = _sgh77::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgicb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh77::P64;
           _sgh6Z::P64 = P64[_sgh77::P64 + 16];
           _sgh70::P64 = P64[_sgh77::P64 + 24];
           _sgh71::P64 = P64[_sgh77::P64 + 32];
           I64[Hp - 16] = sat_sgh76_info;
           P64[Hp] = _sgh70::P64;
           I64[Sp - 40] = block_cgic6_info;
           R2 = _sgh6Z::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgh71::P64;
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgic6() //  [R1]
         { info_tbl: [(cgic6,
                       label: block_cgic6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgic6: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh73_entry() //  [R1]
         { info_tbl: [(cgick,
                       label: sat_sgh73_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgick: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgicl; else goto cgicm;
       cgicl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgicm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose2_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgicn,
                       label: Data.Functor.Compose.$fApplicativeCompose2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgicn: // global
           _sgh72::P64 = R5;
           _sgh71::P64 = R4;
           _sgh70::P64 = R3;
           _sgh6Z::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgico; else goto cgicp;
       cgicp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgicr; else goto cgicq;
       cgicr: // global
           HpAlloc = 64;
           goto cgico;
       cgico: // global
           R5 = _sgh72::P64;
           R4 = _sgh71::P64;
           R3 = _sgh70::P64;
           R2 = _sgh6Z::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgicq: // global
           I64[Hp - 56] = sat_sgh77_info;
           P64[Hp - 40] = _sgh6Z::P64;
           P64[Hp - 32] = _sgh70::P64;
           P64[Hp - 24] = _sgh71::P64;
           I64[Hp - 16] = sat_sgh73_info;
           P64[Hp] = _sgh70::P64;
           R2 = _sgh6Z::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = _sgh72::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.284113176 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose1_closure" {
     Data.Functor.Compose.$fApplicativeCompose1_closure:
         const Data.Functor.Compose.$fApplicativeCompose1_info;
 },
 sat_sgh7c_entry() //  [R1]
         { info_tbl: [(cgidc,
                       label: sat_sgh7c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgidc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgidd; else goto cgide;
       cgidd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgide: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose1_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cgidf,
                       label: Data.Functor.Compose.$fApplicativeCompose1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgidf: // global
           _sgh7b::P64 = R5;
           _sgh7a::P64 = R4;
           _sgh79::P64 = R3;
           _sgh78::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgidg; else goto cgidh;
       cgidh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgidj; else goto cgidi;
       cgidj: // global
           HpAlloc = 24;
           goto cgidg;
       cgidg: // global
           R5 = _sgh7b::P64;
           R4 = _sgh7a::P64;
           R3 = _sgh79::P64;
           R2 = _sgh78::P64;
           R1 = Data.Functor.Compose.$fApplicativeCompose1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgidi: // global
           I64[Hp - 16] = sat_sgh7c_info;
           P64[Hp] = _sgh79::P64;
           R2 = _sgh78::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sgh7a::P64;
           P64[Sp - 8] = _sgh7b::P64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.291327232 UTC

[section ""data" . Data.Functor.Compose.$fApplicativeCompose_closure" {
     Data.Functor.Compose.$fApplicativeCompose_closure:
         const Data.Functor.Compose.$fApplicativeCompose_info;
 },
 sat_sgh7k_entry() //  [R1, R2, R3]
         { info_tbl: [(cgidJ,
                       label: sat_sgh7k_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgidJ: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose1_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7j_entry() //  [R1, R2, R3]
         { info_tbl: [(cgidR,
                       label: sat_sgh7j_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgidR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose2_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7i_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgidZ,
                       label: sat_sgh7i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgidZ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$fApplicativeCompose4_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7h_entry() //  [R1, R2, R3]
         { info_tbl: [(cgie7,
                       label: sat_sgh7h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgie7: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Functor.Compose.$fApplicativeCompose5_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7g_entry() //  [R1, R2]
         { info_tbl: [(cgief,
                       label: sat_sgh7g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgief: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fApplicativeCompose6_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7f_entry() //  [R1]
         { info_tbl: [(cgiem,
                       label: sat_sgh7f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiem: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgien; else goto cgieo;
       cgien: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgieo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fApplicativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cgieq,
                       label: Data.Functor.Compose.$fApplicativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgieq: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cgieu; else goto cgiet;
       cgieu: // global
           HpAlloc = 208;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fApplicativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiet: // global
           I64[Hp - 200] = sat_sgh7k_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_sgh7j_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_sgh7i_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_sgh7h_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sgh7g_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sgh7f_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 103;
           P64[Hp - 24] = Hp - 126;
           P64[Hp - 16] = Hp - 149;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 198;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.307276999 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info;
 },
 sat_sgh7n_entry() //  [R1]
         { info_tbl: [(cgiff,
                       label: sat_sgh7n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiff: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgifg; else goto cgifh;
       cgifg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgifh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(cgifi,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgifi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgifm; else goto cgifl;
       cgifm: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgifl: // global
           I64[Hp - 16] = sat_sgh7n_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 16;
           call Data.Functor.Compose.$fApplicativeCompose_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.316099446 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$csome_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$csome_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$csome_info;
 },
 sat_sgh7u_entry() //  [R1]
         { info_tbl: [(cgifV,
                       label: sat_sgh7u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgifV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgifW; else goto cgifX;
       cgifW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgifX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh7v_entry() //  [R1]
         { info_tbl: [(cgifY,
                       label: sat_sgh7v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgifY: // global
           _sgh7v::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgifZ; else goto cgig0;
       cgig0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgig2; else goto cgig1;
       cgig2: // global
           HpAlloc = 24;
           goto cgifZ;
       cgifZ: // global
           R1 = _sgh7v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgig1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh7v::P64;
           _sgh7p::P64 = P64[_sgh7v::P64 + 16];
           _sgh7s::P64 = P64[_sgh7v::P64 + 24];
           I64[Hp - 16] = sat_sgh7u_info;
           P64[Hp] = _sgh7p::P64;
           R2 = _sgh7s::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh7w_entry() //  [R1]
         { info_tbl: [(cgig3,
                       label: sat_sgh7w_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgig3: // global
           _sgh7w::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgig4; else goto cgig5;
       cgig5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgig7; else goto cgig6;
       cgig7: // global
           HpAlloc = 32;
           goto cgig4;
       cgig4: // global
           R1 = _sgh7w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgig6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh7w::P64;
           _sgh7o::P64 = P64[_sgh7w::P64 + 16];
           _sgh7p::P64 = P64[_sgh7w::P64 + 24];
           _sgh7r::P64 = P64[_sgh7w::P64 + 32];
           _sgh7s::P64 = P64[_sgh7w::P64 + 40];
           I64[Hp - 24] = sat_sgh7v_info;
           P64[Hp - 8] = _sgh7p::P64;
           P64[Hp] = _sgh7s::P64;
           R2 = _sgh7o::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgh7r::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh7t_entry() //  [R1]
         { info_tbl: [(cgigc,
                       label: sat_sgh7t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgigc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgigd; else goto cgige;
       cgigd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgige: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sgh7r_entry() //  [R1]
         { info_tbl: [(cgigf,
                       label: some_v_sgh7r_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgigf: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgigg; else goto cgigh;
       cgigg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgigh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgifF_info;
           _sgh7o::P64 = P64[R1 + 16];
           R2 = _sgh7o::P64;
           P64[Sp - 48] = _sgh7o::P64;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 56;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgifF() //  [R1]
         { info_tbl: [(cgifF,
                       label: block_cgifF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgifF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgigk; else goto cgigj;
       cgigk: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgigj: // global
           I64[Hp - 64] = sat_sgh7w_info;
           P64[Hp - 48] = P64[Sp + 8];
           _sgh7p::P64 = P64[Sp + 16];
           P64[Hp - 40] = _sgh7p::P64;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sgh7t_info;
           P64[Hp] = _sgh7p::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$csome_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgigl,
                       label: Data.Functor.Compose.$fAlternativeCompose_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgigl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgigp; else goto cgigo;
       cgigp: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgigo: // global
           I64[Hp - 32] = some_v_sgh7r_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.334559115 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_$cmany_closure" {
     Data.Functor.Compose.$fAlternativeCompose_$cmany_closure:
         const Data.Functor.Compose.$fAlternativeCompose_$cmany_info;
 },
 $dApplicative1_sgh7B_entry() //  [R1]
         { info_tbl: [(cgihv,
                       label: $dApplicative1_sgh7B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgihv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgihw; else goto cgihx;
       cgihw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgihx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh7E_entry() //  [R1]
         { info_tbl: [(cgihG,
                       label: sat_sgh7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgihG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgihH; else goto cgihI;
       cgihH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgihI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh7F_entry() //  [R1]
         { info_tbl: [(cgihJ,
                       label: sat_sgh7F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgihJ: // global
           _sgh7F::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgihK; else goto cgihL;
       cgihL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgihN; else goto cgihM;
       cgihN: // global
           HpAlloc = 24;
           goto cgihK;
       cgihK: // global
           R1 = _sgh7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgihM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh7F::P64;
           _sgh7y::P64 = P64[_sgh7F::P64 + 16];
           _sgh7B::P64 = P64[_sgh7F::P64 + 24];
           I64[Hp - 16] = sat_sgh7E_info;
           P64[Hp] = _sgh7y::P64;
           R2 = _sgh7B::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh7C_entry() //  [R1]
         { info_tbl: [(cgihW,
                       label: sat_sgh7C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgihW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgihX; else goto cgihY;
       cgihX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgihY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh7D_entry() //  [R1]
         { info_tbl: [(cgihZ,
                       label: sat_sgh7D_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgihZ: // global
           _sgh7D::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cgii0; else goto cgii1;
       cgii1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgii3; else goto cgii2;
       cgii3: // global
           HpAlloc = 24;
           goto cgii0;
       cgii0: // global
           R1 = _sgh7D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgii2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh7D::P64;
           _sgh7y::P64 = P64[_sgh7D::P64 + 16];
           _sgh7z::P64 = P64[_sgh7D::P64 + 24];
           _sgh7A::P64 = P64[_sgh7D::P64 + 32];
           _sgh7B::P64 = P64[_sgh7D::P64 + 40];
           I64[Hp - 16] = sat_sgh7C_info;
           P64[Hp] = _sgh7y::P64;
           R2 = _sgh7B::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgh7z::P64;
           P64[Sp - 24] = _sgh7A::P64;
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_sgh7A_entry() //  [R1]
         { info_tbl: [(cgii4,
                       label: many_v_sgh7A_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgii4: // global
           _sgh7A::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgii5; else goto cgii6;
       cgii6: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgii8; else goto cgii7;
       cgii8: // global
           HpAlloc = 104;
           goto cgii5;
       cgii5: // global
           R1 = _sgh7A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgii7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh7A::P64;
           _sgh7x::P64 = P64[_sgh7A::P64 + 16];
           _sgh7y::P64 = P64[_sgh7A::P64 + 24];
           _sgh7z::P64 = P64[_sgh7A::P64 + 32];
           I64[Hp - 96] = $dApplicative1_sgh7B_info;
           P64[Hp - 80] = _sgh7x::P64;
           I64[Hp - 72] = sat_sgh7F_info;
           P64[Hp - 56] = _sgh7y::P64;
           _cgihr::P64 = Hp - 96;
           P64[Hp - 48] = _cgihr::P64;
           I64[Hp - 40] = sat_sgh7D_info;
           P64[Hp - 24] = _sgh7y::P64;
           P64[Hp - 16] = _sgh7z::P64;
           P64[Hp - 8] = _sgh7A::P64;
           P64[Hp] = _cgihr::P64;
           R2 = _sgh7x::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_$cmany_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cgii9,
                       label: Data.Functor.Compose.$fAlternativeCompose_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgii9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgiid; else goto cgiic;
       cgiid: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiic: // global
           I64[Hp - 32] = many_v_sgh7A_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.353699721 UTC

[section ""data" . Data.Functor.Compose.$fAlternativeCompose_closure" {
     Data.Functor.Compose.$fAlternativeCompose_closure:
         const Data.Functor.Compose.$fAlternativeCompose_info;
 },
 sat_sgh7M_entry() //  [R1, R2]
         { info_tbl: [(cgije,
                       label: sat_sgh7M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgije: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$cmany_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7L_entry() //  [R1, R2]
         { info_tbl: [(cgijm,
                       label: sat_sgh7L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgijm: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fAlternativeCompose_$csome_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7K_entry() //  [R1]
         { info_tbl: [(cgijt,
                       label: sat_sgh7K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgijt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiju; else goto cgijv;
       cgiju: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgijv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh7J_entry() //  [R1]
         { info_tbl: [(cgijA,
                       label: sat_sgh7J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgijA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgijB; else goto cgijC;
       cgijB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgijC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh7I_entry() //  [R1]
         { info_tbl: [(cgijH,
                       label: sat_sgh7I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgijH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgijI; else goto cgijJ;
       cgijI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgijJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative_entry(R3,
                                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fAlternativeCompose_entry() //  [R2, R3]
         { info_tbl: [(cgijL,
                       label: Data.Functor.Compose.$fAlternativeCompose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgijL: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgijP; else goto cgijO;
       cgijP: // global
           HpAlloc = 176;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fAlternativeCompose_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgijO: // global
           I64[Hp - 168] = sat_sgh7M_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           I64[Hp - 144] = sat_sgh7L_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_sgh7K_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sgh7J_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgh7I_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 120;
           P64[Hp - 8] = Hp - 143;
           P64[Hp] = Hp - 167;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.36734742 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose1_closure" {
     Data.Functor.Compose.$fGeneric1Compose1_closure:
         const Data.Functor.Compose.$fGeneric1Compose1_info;
 },
 Data.Functor.Compose.$fGeneric1Compose1_entry() //  [R2, R3]
         { info_tbl: [(cgikv,
                       label: Data.Functor.Compose.$fGeneric1Compose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgikv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgikw; else goto cgikx;
       cgikw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgikx: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = GHC.Generics.$fGeneric1:.:2_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.3717899 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose3_closure" {
     Data.Functor.Compose.$fGeneric1Compose3_closure:
         const Data.Functor.Compose.$fGeneric1Compose3_info;
 },
 Data.Functor.Compose.$fGeneric1Compose3_entry() //  [R2]
         { info_tbl: [(cgikK,
                       label: Data.Functor.Compose.$fGeneric1Compose3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgikK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.375273642 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose2_closure" {
     Data.Functor.Compose.$fGeneric1Compose2_closure:
         const Data.Functor.Compose.$fGeneric1Compose2_info;
 },
 Data.Functor.Compose.$fGeneric1Compose2_entry() //  [R2, R3]
         { info_tbl: [(cgikV,
                       label: Data.Functor.Compose.$fGeneric1Compose2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgikV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgikW; else goto cgikX;
       cgikW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgikX: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Data.Functor.Compose.$fGeneric1Compose3_closure+1;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.379718477 UTC

[section ""data" . Data.Functor.Compose.$fGeneric1Compose_closure" {
     Data.Functor.Compose.$fGeneric1Compose_closure:
         const Data.Functor.Compose.$fGeneric1Compose_info;
 },
 sat_sgh7U_entry() //  [R1, R2]
         { info_tbl: [(cgile,
                       label: sat_sgh7U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgile: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgh7T_entry() //  [R1, R2]
         { info_tbl: [(cgilm,
                       label: sat_sgh7T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgilm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Compose.$fGeneric1Compose2_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fGeneric1Compose_entry() //  [R2]
         { info_tbl: [(cgilq,
                       label: Data.Functor.Compose.$fGeneric1Compose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgilq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgilu; else goto cgilt;
       cgilu: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Compose.$fGeneric1Compose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgilt: // global
           I64[Hp - 48] = sat_sgh7U_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sgh7T_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Generics.C:Generic1_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.387716937 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose1_closure" {
     Data.Functor.Compose.$fGenericCompose1_closure:
         const Data.Functor.Compose.$fGenericCompose1_info;
 },
 Data.Functor.Compose.$fGenericCompose1_entry() //  [R2]
         { info_tbl: [(cgilP,
                       label: Data.Functor.Compose.$fGenericCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgilP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.39127306 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose2_closure" {
     Data.Functor.Compose.$fGenericCompose2_closure:
         const Data.Functor.Compose.$fGenericCompose2_info;
 },
 Data.Functor.Compose.$fGenericCompose2_entry() //  [R2]
         { info_tbl: [(cgim0,
                       label: Data.Functor.Compose.$fGenericCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgim0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.394663211 UTC

[section ""data" . Data.Functor.Compose.$fGenericCompose_closure" {
     Data.Functor.Compose.$fGenericCompose_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Compose.$fGenericCompose2_closure+1;
         const Data.Functor.Compose.$fGenericCompose1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.39679474 UTC

[section ""data" . Data.Functor.Compose.getCompose1_closure" {
     Data.Functor.Compose.getCompose1_closure:
         const Data.Functor.Compose.getCompose1_info;
 },
 Data.Functor.Compose.getCompose1_entry() //  [R2]
         { info_tbl: [(cgimc,
                       label: Data.Functor.Compose.getCompose1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgimc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.400312412 UTC

[section ""data" . Data.Functor.Compose.getCompose_closure" {
     Data.Functor.Compose.getCompose_closure:
         const Data.Functor.Compose.getCompose_info;
 },
 Data.Functor.Compose.getCompose_entry() //  [R2]
         { info_tbl: [(cgimn,
                       label: Data.Functor.Compose.getCompose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgimn: // global
           R2 = R2;
           call Data.Functor.Compose.getCompose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.40341918 UTC

[section ""cstring" . $cCompose1_rgdPU_bytes" {
     $cCompose1_rgdPU_bytes:
         I8[] [103,101,116,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.405676486 UTC

[section ""data" . $cCompose2_rgdPV_closure" {
     $cCompose2_rgdPV_closure:
         const $cCompose2_rgdPV_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose2_rgdPV_entry() //  [R1]
         { info_tbl: [(cgimB,
                       label: $cCompose2_rgdPV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgimB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgimC; else goto cgimD;
       cgimC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgimD: // global
           (_cgimy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgimy::I64 == 0) goto cgimA; else goto cgimz;
       cgimA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgimz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgimy::I64;
           R2 = $cCompose1_rgdPU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.409640347 UTC

[section ""data" . $cCompose3_rgdPW_closure" {
     $cCompose3_rgdPW_closure:
         const :_con_info;
         const $cCompose2_rgdPV_closure;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.412264621 UTC

[section ""data" . go61_rgdPX_closure" {
     go61_rgdPX_closure:
         const go61_rgdPX_info;
         const 0;
 },
 go61_rgdPX_entry() //  [R2, R3]
         { info_tbl: [(cgimY,
                       label: go61_rgdPX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgimY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgimZ; else goto uginC;
       cgimZ: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgdPX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uginC: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgimO() args: 0, res: 0, upd: 0;
     }
 },
 _cgimO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgimO: // global
           _sgh7Y::P64 = P64[Sp];
           I64[Sp] = block_cgimR_info;
           R1 = _sgh7Y::P64;
           if (R1 & 7 != 0) goto uginG; else goto cgimS;
       uginG: // global
           call _cgimR(R1) args: 0, res: 0, upd: 0;
       cgimS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgimR() //  [R1]
         { info_tbl: [(cgimR,
                       label: block_cgimR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgimR: // global
           if (R1 & 7 == 1) goto uginD; else goto cgimW;
       uginD: // global
           Sp = Sp + 16;
           call _cgine() args: 0, res: 0, upd: 0;
       cgimW: // global
           I64[Sp - 8] = block_cgin6_info;
           _sgh81::P64 = P64[R1 + 6];
           _sgh82::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgh82::P64;
           P64[Sp + 8] = _sgh81::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uginH; else goto cgin8;
       uginH: // global
           call _cgin6(R1) args: 0, res: 0, upd: 0;
       cgin8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgin6() //  [R1]
         { info_tbl: [(cgin6,
                       label: block_cgin6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgin6: // global
           if (R1 & 7 == 1) goto uginE; else goto cginj;
       uginE: // global
           Sp = Sp + 24;
           call _cgine() args: 0, res: 0, upd: 0;
       cginj: // global
           I64[Sp - 8] = block_cginh_info;
           _sgh84::P64 = P64[R1 + 6];
           _sgh85::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgh85::P64;
           P64[Sp + 16] = _sgh84::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uginK; else goto cgink;
       uginK: // global
           call _cginh(R1) args: 0, res: 0, upd: 0;
       cgink: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgine() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgine: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cginh() //  [R1]
         { info_tbl: [(cginh,
                       label: block_cginh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cginh: // global
           I64[Sp] = block_cgino_info;
           R3 = Data.Functor.Compose.$fDataCompose6_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgino() //  [R1]
         { info_tbl: [(cgino,
                       label: block_cgino_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgino: // global
           if (R1 & 7 == 1) goto cginv; else goto cginz;
       cginv: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgimO() args: 0, res: 0, upd: 0;
       cginz: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.427241989 UTC

[section ""data" . $cCompose4_rgdPY_closure" {
     $cCompose4_rgdPY_closure:
         const Data.Data.AlgConstr_con_info;
         const $cCompose5_rgdPZ_closure;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose5_closure" {
     Data.Functor.Compose.$fDataCompose5_closure:
         const :_con_info;
         const Data.Functor.Compose.$cCompose_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$fDataCompose4_closure" {
     Data.Functor.Compose.$fDataCompose4_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Functor.Compose.$fDataCompose5_closure+2;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$tCompose_closure" {
     Data.Functor.Compose.$tCompose_closure:
         const Data.Data.DataType_con_info;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$fDataCompose4_closure+1;
         const 0;
 },
 section ""data" . Data.Functor.Compose.$cCompose_closure" {
     Data.Functor.Compose.$cCompose_closure:
         const Data.Data.Constr_con_info;
         const $cCompose4_rgdPY_closure+1;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const $cCompose3_rgdPW_closure+2;
         const Data.Data.Prefix_closure+1;
         const Data.Functor.Compose.$tCompose_closure+1;
         const 0;
 },
 section ""data" . $cCompose5_rgdPZ_closure" {
     $cCompose5_rgdPZ_closure:
         const $cCompose5_rgdPZ_info;
         const 0;
         const 0;
         const 0;
 },
 $cCompose5_rgdPZ_entry() //  [R1]
         { info_tbl: [(cgiov,
                       label: $cCompose5_rgdPZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiov: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiow; else goto cgiox;
       cgiow: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiox: // global
           (_cgios::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgios::I64 == 0) goto cgiou; else goto cgiot;
       cgiou: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgiot: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgios::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Functor.Compose.$fDataCompose5_closure+2;
           Sp = Sp - 16;
           call go61_rgdPX_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.434888061 UTC

[section ""cstring" . Data.Functor.Compose.$trModule4_bytes" {
     Data.Functor.Compose.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.436661387 UTC

[section ""data" . Data.Functor.Compose.$trModule3_closure" {
     Data.Functor.Compose.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.438654184 UTC

[section ""cstring" . Data.Functor.Compose.$trModule2_bytes" {
     Data.Functor.Compose.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.440332706 UTC

[section ""data" . Data.Functor.Compose.$trModule1_closure" {
     Data.Functor.Compose.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.442103333 UTC

[section ""data" . Data.Functor.Compose.$trModule_closure" {
     Data.Functor.Compose.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Compose.$trModule3_closure+1;
         const Data.Functor.Compose.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.443896347 UTC

[section ""data" . $krep_rgdQ0_closure" {
     $krep_rgdQ0_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.446095852 UTC

[section ""data" . $krep1_rgdQ1_closure" {
     $krep1_rgdQ1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.447881792 UTC

[section ""data" . $krep2_rgdQ2_closure" {
     $krep2_rgdQ2_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.449970666 UTC

[section ""data" . $krep3_rgdQ3_closure" {
     $krep3_rgdQ3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rgdQ2_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.451662482 UTC

[section ""data" . $krep4_rgdQ4_closure" {
     $krep4_rgdQ4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep2_rgdQ2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.453379886 UTC

[section ""data" . $krep5_rgdQ5_closure" {
     $krep5_rgdQ5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rgdQ4_closure+4;
         const $krep1_rgdQ1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.455109304 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose9_closure" {
     Data.Functor.Compose.$fDataCompose9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rgdQ3_closure+4;
         const $krep5_rgdQ5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.456892023 UTC

[section ""data" . $krep6_rgdQ6_closure" {
     $krep6_rgdQ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.458663604 UTC

[section ""data" . $krep7_rgdQ7_closure" {
     $krep7_rgdQ7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.460402999 UTC

[section ""data" . $krep8_rgdQ8_closure" {
     $krep8_rgdQ8_closure:
         const GHC.Types.KindRepVar_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.46243257 UTC

[section ""data" . $krep9_rgdQ9_closure" {
     $krep9_rgdQ9_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep8_rgdQ8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.464193795 UTC

[section ""data" . $krep10_rgdQa_closure" {
     $krep10_rgdQa_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep9_rgdQ9_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.465991981 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose10_closure" {
     Data.Functor.Compose.$fDataCompose10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$fDataCompose7_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.467755558 UTC

[section ""data" . Data.Functor.Compose.$tcCompose_closure" {
     Data.Functor.Compose.$tcCompose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$fDataCompose10_closure+1;
         const Data.Functor.Compose.$fDataCompose9_closure+4;
         const 6729400645769595507;
         const 7487202375031942550;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.469662467 UTC

[section ""data" . $krep11_rgdQb_closure" {
     $krep11_rgdQb_closure:
         const :_con_info;
         const $krep8_rgdQ8_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.471394244 UTC

[section ""data" . $krep12_rgdQc_closure" {
     $krep12_rgdQc_closure:
         const :_con_info;
         const $krep6_rgdQ6_closure+2;
         const $krep11_rgdQb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.474156322 UTC

[section ""data" . $krep13_rgdQd_closure" {
     $krep13_rgdQd_closure:
         const :_con_info;
         const $krep7_rgdQ7_closure+2;
         const $krep12_rgdQc_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.475820622 UTC

[section ""data" . $krep14_rgdQe_closure" {
     $krep14_rgdQe_closure:
         const :_con_info;
         const $krep_rgdQ0_closure+2;
         const $krep13_rgdQd_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.477567757 UTC

[section ""data" . $krep15_rgdQf_closure" {
     $krep15_rgdQf_closure:
         const :_con_info;
         const $krep2_rgdQ2_closure+2;
         const $krep14_rgdQe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.479290956 UTC

[section ""data" . $krep16_rgdQg_closure" {
     $krep16_rgdQg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Compose.$tcCompose_closure+1;
         const $krep15_rgdQf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.48101857 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose1_closure" {
     Data.Functor.Compose.$tc'Compose1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rgdQa_closure+3;
         const $krep16_rgdQg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.482881564 UTC

[section ""cstring" . Data.Functor.Compose.$tc'Compose3_bytes" {
     Data.Functor.Compose.$tc'Compose3_bytes:
         I8[] [39,67,111,109,112,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.484666572 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose2_closure" {
     Data.Functor.Compose.$tc'Compose2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Compose.$tc'Compose3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.486736468 UTC

[section ""data" . Data.Functor.Compose.$tc'Compose_closure" {
     Data.Functor.Compose.$tc'Compose_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Compose.$trModule_closure+1;
         const Data.Functor.Compose.$tc'Compose2_closure+1;
         const Data.Functor.Compose.$tc'Compose1_closure+4;
         const 7236514282653524344;
         const 13791541438620948974;
         const 5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.489199946 UTC

[section ""data" . Data.Functor.Compose.$w$cp1Data_closure" {
     Data.Functor.Compose.$w$cp1Data_closure:
         const Data.Functor.Compose.$w$cp1Data_info;
         const 0;
 },
 Data.Functor.Compose.$w$cp1Data_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgipt,
                       label: Data.Functor.Compose.$w$cp1Data_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgipt: // global
           _sgh8h::P64 = R6;
           _sgh8g::P64 = R5;
           _sgh8f::P64 = R4;
           _sgh8e::P64 = R3;
           _sgh8d::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cgipx; else goto cgipy;
       cgipy: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgipA; else goto cgipz;
       cgipA: // global
           HpAlloc = 80;
           goto cgipx;
       cgipx: // global
           R6 = _sgh8h::P64;
           R5 = _sgh8g::P64;
           R4 = _sgh8f::P64;
           R3 = _sgh8e::P64;
           R2 = _sgh8d::P64;
           R1 = Data.Functor.Compose.$w$cp1Data_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgipz: // global
           I64[Hp - 72] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 64] = _sgh8h::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = Data.Typeable.Internal.SomeTypeRep_con_info;
           P64[Hp - 24] = _sgh8g::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           I64[Sp - 32] = block_cgipm_info;
           R6 = 2;
           R5 = Data.Functor.Compose.$fDataCompose10_closure+1;
           R4 = Data.Functor.Compose.$trModule_closure+1;
           R3 = 7487202375031942550;
           R2 = 6729400645769595507;
           P64[Sp - 48] = Data.Functor.Compose.$fDataCompose9_closure+4;
           P64[Sp - 40] = Hp - 14;
           P64[Sp - 24] = _sgh8d::P64;
           P64[Sp - 16] = _sgh8e::P64;
           P64[Sp - 8] = _sgh8f::P64;
           Sp = Sp - 48;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgipm() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgipm,
                       label: block_cgipm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgipm: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgipn() args: 0, res: 0, upd: 0;
     }
 },
 _cgipn() //  []
         { info_tbl: [(cgipn,
                       label: block_cgipn_info
                       rep:StackRep [True, False, False, False, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgipn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgipD; else goto cgipC;
       cgipD: // global
           HpAlloc = 48;
           I64[Sp] = block_cgipn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cgipC: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           I64[Sp + 40] = block_cgipr_info;
           R3 = P64[Sp + 56];
           R2 = Hp - 38;
           Sp = Sp + 40;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgipr() //  [R1]
         { info_tbl: [(cgipr,
                       label: block_cgipr_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgipr: // global
           I64[Sp] = block_cgipw_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgipw() //  [R1]
         { info_tbl: [(cgipw,
                       label: block_cgipw_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgipw: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.502518252 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose8_closure" {
     Data.Functor.Compose.$fDataCompose8_closure:
         const Data.Functor.Compose.$fDataCompose8_info;
         const 0;
 },
 Data.Functor.Compose.$fDataCompose8_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cgiqr,
                       label: Data.Functor.Compose.$fDataCompose8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiqr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp + 8;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.506905367 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose2_closure" {
     Data.Functor.Compose.$fDataCompose2_closure:
         const Data.Functor.Compose.$fDataCompose2_info;
 },
 Data.Functor.Compose.$fDataCompose2_entry() //  [R2]
         { info_tbl: [(cgiqC,
                       label: Data.Functor.Compose.$fDataCompose2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiqC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.510251223 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose1_closure" {
     Data.Functor.Compose.$fDataCompose1_closure:
         const (,)_con_info;
         const Data.Functor.Compose.$fDataCompose2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.514448072 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMp_closure" {
     Data.Functor.Compose.$w$cgmapMp_closure:
         const Data.Functor.Compose.$w$cgmapMp_info;
 },
 lvl8_sgh8G_entry() //  [R1]
         { info_tbl: [(cgiqS,
                       label: lvl8_sgh8G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiqS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiqT; else goto cgiqU;
       cgiqT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiqU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgh93_entry() //  [R1, R2]
         { info_tbl: [(cgir7,
                       label: sat_sgh93_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgir7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgir8; else goto cgir9;
       cgir8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgir9: // global
           I64[Sp - 24] = block_cgir4_info;
           _sgh8G::P64 = P64[R1 + 7];
           _sgh8H::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgh8G::P64;
           P64[Sp - 8] = _sgh8H::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugirr; else goto cgir5;
       ugirr: // global
           call _cgir4(R1) args: 0, res: 0, upd: 0;
       cgir5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgir4() //  [R1]
         { info_tbl: [(cgir4,
                       label: block_cgir4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgir4: // global
           I64[Sp - 8] = block_cgirc_info;
           _sgh90::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgh90::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugirq; else goto cgire;
       ugirq: // global
           call _cgirc(R1) args: 0, res: 0, upd: 0;
       cgire: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgirc() //  [R1]
         { info_tbl: [(cgirc,
                       label: block_cgirc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgirc: // global
           if (R1 & 7 == 1) goto cgirk; else goto cgiro;
       cgirk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgiro: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgh8V_entry() //  [R1]
         { info_tbl: [(cgirN,
                       label: sat_sgh8V_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgirN: // global
           _sgh8V::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgirO; else goto cgirP;
       cgirP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgirR; else goto cgirQ;
       cgirR: // global
           HpAlloc = 56;
           goto cgirO;
       cgirO: // global
           R1 = _sgh8V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgirQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh8V::P64;
           _sgh8F::P64 = P64[_sgh8V::P64 + 16];
           _sgh8H::P64 = P64[_sgh8V::P64 + 24];
           _sgh8M::P64 = P64[_sgh8V::P64 + 32];
           _sgh8N::P64 = P64[_sgh8V::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgh8M::P64;
           P64[Hp - 24] = _sgh8F::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sgh8N::P64;
           R2 = _sgh8H::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh8R_entry() //  [R1, R2]
         { info_tbl: [(cgis3,
                       label: sat_sgh8R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgis3: // global
           _sgh8O::P64 = R2;
           _sgh8R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgis4; else goto cgis5;
       cgis5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgis7; else goto cgis6;
       cgis7: // global
           HpAlloc = 56;
           goto cgis4;
       cgis4: // global
           R2 = _sgh8O::P64;
           R1 = _sgh8R::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgis6: // global
           _sgh8H::P64 = P64[_sgh8R::P64 + 7];
           _sgh8M::P64 = P64[_sgh8R::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgh8M::P64;
           P64[Hp - 24] = _sgh8O::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgh8H::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgh8S_entry() //  [R1]
         { info_tbl: [(cgis8,
                       label: sat_sgh8S_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgis8: // global
           _sgh8S::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgis9; else goto cgisa;
       cgisa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgisc; else goto cgisb;
       cgisc: // global
           HpAlloc = 24;
           goto cgis9;
       cgis9: // global
           R1 = _sgh8S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgisb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh8S::P64;
           _sgh8H::P64 = P64[_sgh8S::P64 + 16];
           _sgh8I::P64 = P64[_sgh8S::P64 + 24];
           _sgh8M::P64 = P64[_sgh8S::P64 + 32];
           I64[Hp - 16] = sat_sgh8R_info;
           P64[Hp - 8] = _sgh8H::P64;
           P64[Hp] = _sgh8M::P64;
           R2 = _sgh8H::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgh8I::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh8W_entry() //  [R1, R2]
         { info_tbl: [(cgisd,
                       label: sat_sgh8W_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgisd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgise; else goto cgisf;
       cgise: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgisf: // global
           I64[Sp - 40] = block_cgirC_info;
           _sgh8D::P64 = P64[R1 + 7];
           _sgh8F::P64 = P64[R1 + 15];
           _sgh8H::P64 = P64[R1 + 23];
           _sgh8I::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgh8D::P64;
           P64[Sp - 24] = _sgh8F::P64;
           P64[Sp - 16] = _sgh8H::P64;
           P64[Sp - 8] = _sgh8I::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugisj; else goto cgirD;
       ugisj: // global
           call _cgirC(R1) args: 0, res: 0, upd: 0;
       cgirD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgirC() //  [R1]
         { info_tbl: [(cgirC,
                       label: block_cgirC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgirC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgisi; else goto cgish;
       cgisi: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgish: // global
           _sgh8M::P64 = P64[R1 + 7];
           _sgh8N::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgh8V_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sgh8H::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sgh8H::P64;
           P64[Hp - 48] = _sgh8M::P64;
           P64[Hp - 40] = _sgh8N::P64;
           I64[Hp - 32] = sat_sgh8S_info;
           P64[Hp - 16] = _sgh8H::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sgh8M::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgh8J_entry() //  [R1]
         { info_tbl: [(cgiso,
                       label: sat_sgh8J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiso: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgisp; else goto cgisq;
       cgisp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgisq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh8X_entry() //  [R1]
         { info_tbl: [(cgisr,
                       label: sat_sgh8X_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgisr: // global
           _sgh8X::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgiss; else goto cgist;
       cgist: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgisv; else goto cgisu;
       cgisv: // global
           HpAlloc = 104;
           goto cgiss;
       cgiss: // global
           R1 = _sgh8X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgisu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh8X::P64;
           _sgh8C::P64 = P64[_sgh8X::P64 + 16];
           _sgh8D::P64 = P64[_sgh8X::P64 + 24];
           _sgh8E::P64 = P64[_sgh8X::P64 + 32];
           _sgh8F::P64 = P64[_sgh8X::P64 + 40];
           _sgh8H::P64 = P64[_sgh8X::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sgh8E::P64;
           P64[Hp - 72] = _sgh8C::P64;
           P64[Hp - 64] = _sgh8F::P64;
           I64[Hp - 56] = sat_sgh8W_info;
           P64[Hp - 48] = _sgh8D::P64;
           P64[Hp - 40] = _sgh8F::P64;
           P64[Hp - 32] = _sgh8H::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sgh8J_info;
           P64[Hp] = _sgh8H::P64;
           R2 = _sgh8H::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgisw,
                       label: Data.Functor.Compose.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgisw: // global
           _sgh8F::P64 = R5;
           _sgh8E::P64 = R4;
           _sgh8D::P64 = R3;
           _sgh8C::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgisx; else goto cgisy;
       cgisy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgisA; else goto cgisz;
       cgisA: // global
           HpAlloc = 24;
           goto cgisx;
       cgisx: // global
           R5 = _sgh8F::P64;
           R4 = _sgh8E::P64;
           R3 = _sgh8D::P64;
           R2 = _sgh8C::P64;
           R1 = Data.Functor.Compose.$w$cgmapMp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgisz: // global
           I64[Hp - 16] = lvl8_sgh8G_info;
           P64[Hp] = _sgh8D::P64;
           I64[Sp - 48] = block_cgiqV_info;
           R2 = _sgh8D::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgh8C::P64;
           P64[Sp - 24] = _sgh8D::P64;
           P64[Sp - 16] = _sgh8E::P64;
           P64[Sp - 8] = _sgh8F::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgiqV() //  [R1]
         { info_tbl: [(cgiqV,
                       label: block_cgiqV_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiqV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgisD; else goto cgisC;
       cgisD: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgisC: // global
           I64[Hp - 72] = sat_sgh93_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sgh8X_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.545782054 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMp_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMp_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMp_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiup: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMp_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMp_entry() //  []
         { info_tbl: [(cgiut,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMp_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiut: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.552096968 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapM_closure" {
     Data.Functor.Compose.$w$cgmapM_closure:
         const Data.Functor.Compose.$w$cgmapM_info;
 },
 sat_sgh9m_entry() //  [R1, R2]
         { info_tbl: [(cgiuS,
                       label: sat_sgh9m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiuS: // global
           _sgh9k::P64 = R2;
           _sgh9m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgiuT; else goto cgiuU;
       cgiuU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgiuW; else goto cgiuV;
       cgiuW: // global
           HpAlloc = 32;
           goto cgiuT;
       cgiuT: // global
           R2 = _sgh9k::P64;
           R1 = _sgh9m::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgiuV: // global
           _sgh9e::P64 = P64[_sgh9m::P64 + 7];
           _sgh9j::P64 = P64[_sgh9m::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgh9j::P64;
           P64[Hp] = _sgh9k::P64;
           R2 = _sgh9e::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgh9n_entry() //  [R1, R2]
         { info_tbl: [(cgiuX,
                       label: sat_sgh9n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiuX: // global
           _sgh9j::P64 = R2;
           _sgh9n::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgiuY; else goto cgiuZ;
       cgiuZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgiv1; else goto cgiv0;
       cgiv1: // global
           HpAlloc = 24;
           goto cgiuY;
       cgiuY: // global
           R2 = _sgh9j::P64;
           R1 = _sgh9n::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgiv0: // global
           _sgh9e::P64 = P64[_sgh9n::P64 + 7];
           _sgh9h::P64 = P64[_sgh9n::P64 + 15];
           I64[Hp - 16] = sat_sgh9m_info;
           P64[Hp - 8] = _sgh9e::P64;
           P64[Hp] = _sgh9j::P64;
           R2 = _sgh9e::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgh9h::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgh9i_entry() //  [R1]
         { info_tbl: [(cgiv6,
                       label: sat_sgh9i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiv6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgiv7; else goto cgiv8;
       cgiv7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiv8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgiv9,
                       label: Data.Functor.Compose.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiv9: // global
           _sgh9g::P64 = R5;
           _sgh9f::P64 = R4;
           _sgh9e::P64 = R3;
           _sgh9d::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgiva; else goto cgivb;
       cgivb: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgivd; else goto cgivc;
       cgivd: // global
           HpAlloc = 88;
           goto cgiva;
       cgiva: // global
           R5 = _sgh9g::P64;
           R4 = _sgh9f::P64;
           R3 = _sgh9e::P64;
           R2 = _sgh9d::P64;
           R1 = Data.Functor.Compose.$w$cgmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgivc: // global
           I64[Hp - 80] = stg_ap_3_upd_info;
           P64[Hp - 64] = _sgh9f::P64;
           P64[Hp - 56] = _sgh9d::P64;
           P64[Hp - 48] = _sgh9g::P64;
           I64[Hp - 40] = sat_sgh9n_info;
           P64[Hp - 32] = _sgh9e::P64;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = sat_sgh9i_info;
           P64[Hp] = _sgh9e::P64;
           R2 = _sgh9e::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.563866935 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapM_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapM_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapM_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgivM: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapM_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2,
                                                                 R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapM_entry() //  []
         { info_tbl: [(cgivQ,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapM_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgivQ: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.571422054 UTC

[section ""data" . Data.Functor.Compose.$w$cgmapMo_closure" {
     Data.Functor.Compose.$w$cgmapMo_closure:
         const Data.Functor.Compose.$w$cgmapMo_info;
 },
 lvl8_sgh9B_entry() //  [R1]
         { info_tbl: [(cgiw7,
                       label: lvl8_sgh9B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiw7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiw8; else goto cgiw9;
       cgiw8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiw9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgha1_entry() //  [R1, R2]
         { info_tbl: [(cgiwm,
                       label: sat_sgha1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiwm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgiwn; else goto cgiwo;
       cgiwn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgiwo: // global
           I64[Sp - 24] = block_cgiwj_info;
           _sgh9B::P64 = P64[R1 + 7];
           _sgh9C::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgh9B::P64;
           P64[Sp - 8] = _sgh9C::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugiwG; else goto cgiwk;
       ugiwG: // global
           call _cgiwj(R1) args: 0, res: 0, upd: 0;
       cgiwk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgiwj() //  [R1]
         { info_tbl: [(cgiwj,
                       label: block_cgiwj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiwj: // global
           I64[Sp - 8] = block_cgiwr_info;
           _sgh9Y::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgh9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugiwF; else goto cgiwt;
       ugiwF: // global
           call _cgiwr(R1) args: 0, res: 0, upd: 0;
       cgiwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgiwr() //  [R1]
         { info_tbl: [(cgiwr,
                       label: block_cgiwr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiwr: // global
           if (R1 & 7 == 1) goto cgiwz; else goto cgiwD;
       cgiwz: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgiwD: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgh9R_entry() //  [R1]
         { info_tbl: [(cgix7,
                       label: sat_sgh9R_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgix7: // global
           _sgh9R::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgix8; else goto cgix9;
       cgix9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgixb; else goto cgixa;
       cgixb: // global
           HpAlloc = 56;
           goto cgix8;
       cgix8: // global
           R1 = _sgh9R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgixa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh9R::P64;
           _sgh9A::P64 = P64[_sgh9R::P64 + 16];
           _sgh9C::P64 = P64[_sgh9R::P64 + 24];
           _sgh9H::P64 = P64[_sgh9R::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgh9H::P64;
           P64[Hp - 24] = _sgh9A::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sgh9C::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh9N_entry() //  [R1, R2]
         { info_tbl: [(cgixn,
                       label: sat_sgh9N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgixn: // global
           _sgh9K::P64 = R2;
           _sgh9N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgixo; else goto cgixp;
       cgixp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgixr; else goto cgixq;
       cgixr: // global
           HpAlloc = 56;
           goto cgixo;
       cgixo: // global
           R2 = _sgh9K::P64;
           R1 = _sgh9N::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgixq: // global
           _sgh9C::P64 = P64[_sgh9N::P64 + 7];
           _sgh9H::P64 = P64[_sgh9N::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgh9H::P64;
           P64[Hp - 24] = _sgh9K::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgh9C::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgh9O_entry() //  [R1]
         { info_tbl: [(cgixs,
                       label: sat_sgh9O_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgixs: // global
           _sgh9O::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgixt; else goto cgixu;
       cgixu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgixw; else goto cgixv;
       cgixw: // global
           HpAlloc = 24;
           goto cgixt;
       cgixt: // global
           R1 = _sgh9O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgixv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh9O::P64;
           _sgh9C::P64 = P64[_sgh9O::P64 + 16];
           _sgh9D::P64 = P64[_sgh9O::P64 + 24];
           _sgh9H::P64 = P64[_sgh9O::P64 + 32];
           I64[Hp - 16] = sat_sgh9N_info;
           P64[Hp - 8] = _sgh9C::P64;
           P64[Hp] = _sgh9H::P64;
           R2 = _sgh9C::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgh9D::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgh9U_entry() //  [R1, R2]
         { info_tbl: [(cgixx,
                       label: sat_sgh9U_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgixx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgixy; else goto cgixz;
       cgixy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgixz: // global
           I64[Sp - 40] = block_cgiwR_info;
           _sgh9y::P64 = P64[R1 + 7];
           _sgh9A::P64 = P64[R1 + 15];
           _sgh9C::P64 = P64[R1 + 23];
           _sgh9D::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgh9y::P64;
           P64[Sp - 24] = _sgh9A::P64;
           P64[Sp - 16] = _sgh9C::P64;
           P64[Sp - 8] = _sgh9D::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugixQ; else goto cgiwS;
       ugixQ: // global
           call _cgiwR(R1) args: 0, res: 0, upd: 0;
       cgiwS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgiwR() //  [R1]
         { info_tbl: [(cgiwR,
                       label: block_cgiwR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiwR: // global
           I64[Sp - 8] = block_cgiwW_info;
           _sgh9H::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgh9H::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugixP; else goto cgiwX;
       ugixP: // global
           call _cgiwW(R1) args: 0, res: 0, upd: 0;
       cgiwX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgiwW() //  [R1]
         { info_tbl: [(cgiwW,
                       label: block_cgiwW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiwW: // global
           _sgh9A::P64 = P64[Sp + 24];
           _sgh9C::P64 = P64[Sp + 32];
           _sgh9H::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgixC; else goto cgixG;
       cgixC: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgixF; else goto cgixE;
       cgixF: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgixE: // global
           I64[Hp - 72] = sat_sgh9R_info;
           P64[Hp - 56] = _sgh9A::P64;
           P64[Hp - 48] = _sgh9C::P64;
           P64[Hp - 40] = _sgh9H::P64;
           I64[Hp - 32] = sat_sgh9O_info;
           P64[Hp - 16] = _sgh9C::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgh9H::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgixG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgixL; else goto cgixK;
       cgixL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgixK: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgh9H::P64;
           P64[Hp - 24] = _sgh9A::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgh9C::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgh9E_entry() //  [R1]
         { info_tbl: [(cgixV,
                       label: sat_sgh9E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgixV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgixW; else goto cgixX;
       cgixW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgixX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Functor.Compose.$fDataCompose1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgh9V_entry() //  [R1]
         { info_tbl: [(cgixY,
                       label: sat_sgh9V_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgixY: // global
           _sgh9V::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgixZ; else goto cgiy0;
       cgiy0: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgiy2; else goto cgiy1;
       cgiy2: // global
           HpAlloc = 104;
           goto cgixZ;
       cgixZ: // global
           R1 = _sgh9V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiy1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgh9V::P64;
           _sgh9x::P64 = P64[_sgh9V::P64 + 16];
           _sgh9y::P64 = P64[_sgh9V::P64 + 24];
           _sgh9z::P64 = P64[_sgh9V::P64 + 32];
           _sgh9A::P64 = P64[_sgh9V::P64 + 40];
           _sgh9C::P64 = P64[_sgh9V::P64 + 48];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = _sgh9z::P64;
           P64[Hp - 72] = _sgh9x::P64;
           P64[Hp - 64] = _sgh9A::P64;
           I64[Hp - 56] = sat_sgh9U_info;
           P64[Hp - 48] = _sgh9y::P64;
           P64[Hp - 40] = _sgh9A::P64;
           P64[Hp - 32] = _sgh9C::P64;
           P64[Hp - 24] = Hp - 96;
           I64[Hp - 16] = sat_sgh9E_info;
           P64[Hp] = _sgh9C::P64;
           R2 = _sgh9C::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$w$cgmapMo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgiy3,
                       label: Data.Functor.Compose.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiy3: // global
           _sgh9A::P64 = R5;
           _sgh9z::P64 = R4;
           _sgh9y::P64 = R3;
           _sgh9x::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cgiy4; else goto cgiy5;
       cgiy5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgiy7; else goto cgiy6;
       cgiy7: // global
           HpAlloc = 24;
           goto cgiy4;
       cgiy4: // global
           R5 = _sgh9A::P64;
           R4 = _sgh9z::P64;
           R3 = _sgh9y::P64;
           R2 = _sgh9x::P64;
           R1 = Data.Functor.Compose.$w$cgmapMo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiy6: // global
           I64[Hp - 16] = lvl8_sgh9B_info;
           P64[Hp] = _sgh9y::P64;
           I64[Sp - 48] = block_cgiwa_info;
           R2 = _sgh9y::P64;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = _sgh9x::P64;
           P64[Sp - 24] = _sgh9y::P64;
           P64[Sp - 16] = _sgh9z::P64;
           P64[Sp - 8] = _sgh9A::P64;
           Sp = Sp - 48;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgiwa() //  [R1]
         { info_tbl: [(cgiwa,
                       label: block_cgiwa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiwa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgiya; else goto cgiy9;
       cgiya: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgiy9: // global
           I64[Hp - 72] = sat_sgha1_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = R1;
           I64[Hp - 48] = sat_sgh9V_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 48;
           P64[Sp + 40] = Hp - 71;
           Sp = Sp + 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.60644214 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_$cgmapMo_closure" {
     Data.Functor.Compose.$fDataCompose_$cgmapMo_closure:
         const Data.Functor.Compose.$fDataCompose_$cgmapMo_info;
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiAb: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Functor.Compose.$fDataCompose_$cgmapMo_entry(R6,
                                                                  R5,
                                                                  R4,
                                                                  R3,
                                                                  R2,
                                                                  R1) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Compose.$fDataCompose_$cgmapMo_entry() //  []
         { info_tbl: [(cgiAf,
                       label: Data.Functor.Compose.$fDataCompose_$cgmapMo_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiAf: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp + 32;
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.611550651 UTC

[section ""data" . lvl4_rgdQh_closure" {
     lvl4_rgdQh_closure:
         const lvl4_rgdQh_info;
         const 0;
 },
 lvl4_rgdQh_entry() //  []
         { info_tbl: [(cgiAs,
                       label: lvl4_rgdQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiAs: // global
           R1 = Data.Functor.Compose.$cCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.615044721 UTC

[section ""data" . lvl5_rgdQi_closure" {
     lvl5_rgdQi_closure:
         const lvl5_rgdQi_info;
         const 0;
 },
 lvl5_rgdQi_entry() //  []
         { info_tbl: [(cgiAE,
                       label: lvl5_rgdQi_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiAE: // global
           R1 = Data.Functor.Compose.$tCompose_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.618766459 UTC

[section ""data" . lvl6_rgdQj_closure" {
     lvl6_rgdQj_closure:
         const lvl6_rgdQj_info;
 },
 lvl6_rgdQj_entry() //  []
         { info_tbl: [(cgiAQ,
                       label: lvl6_rgdQj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiAQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.62238553 UTC

[section ""data" . lvl7_rgdQk_closure" {
     lvl7_rgdQk_closure:
         const lvl7_rgdQk_info;
 },
 lvl7_rgdQk_entry() //  []
         { info_tbl: [(cgiB3,
                       label: lvl7_rgdQk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiB3: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.628290845 UTC

[section ""data" . Data.Functor.Compose.$fDataCompose_closure" {
     Data.Functor.Compose.$fDataCompose_closure:
         const Data.Functor.Compose.$fDataCompose_info;
         const 0;
 },
 sat_sghb9_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgiBl,
                       label: sat_sghb9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiBl: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghb5_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgiBt,
                       label: sat_sghb5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiBt: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapMp_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghb1_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgiBB,
                       label: sat_sghb1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiBB: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Functor.Compose.$w$cgmapM_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghaX_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgiBM,
                       label: sat_sghaX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiBM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgiBN; else goto cgiBO;
       cgiBN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiBO: // global
           I64[Sp - 32] = block_cgiBJ_info;
           _sgham::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 24] = _sgham::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugiBW; else goto cgiBK;
       ugiBW: // global
           call _cgiBJ(R1) args: 0, res: 0, upd: 0;
       cgiBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgiBJ() //  [R1]
         { info_tbl: [(cgiBJ,
                       label: block_cgiBJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiBJ: // global
           if (I64[R1 + 7] == 0) goto cgiBV; else goto cgiBU;
       cgiBV: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiBU: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghaQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgiC4,
                       label: sat_sghaQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiC4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgiC8; else goto cgiC7;
       cgiC8: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiC7: // global
           _sgham::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = _sgham::P64;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghaM_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgiCf,
                       label: sat_sghaM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiCf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgiCj; else goto cgiCi;
       cgiCj: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiCi: // global
           _sgham::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sgham::P64;
           P64[Hp] = R5;
           R3 = R3;
           _sghaH::P64 = R2;
           R2 = Hp - 32;
           R1 = _sghaH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghaG_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgiCq,
                       label: sat_sghaG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiCq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgiCu; else goto cgiCt;
       cgiCu: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiCt: // global
           _sgham::P64 = P64[R1 + 4];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = _sgham::P64;
           P64[Hp] = R5;
           _sghaC::P64 = R3;
           R3 = Hp - 32;
           _sghaB::P64 = R2;
           R2 = _sghaC::P64;
           R1 = _sghaB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghaA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgiCA,
                       label: sat_sghaA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiCA: // global
           R3 = R3;
           _sghay::P64 = R2;
           R2 = P64[R1 + 6];
           R1 = _sghay::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghaw_entry() //  [R1]
         { info_tbl: [(cgiCM,
                       label: sat_sghaw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiCM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiCN; else goto cgiCO;
       cgiCN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiCO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sghax_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgiCP,
                       label: sat_sghax_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiCP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgiCT; else goto cgiCS;
       cgiCT: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiCS: // global
           _sgham::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sghaw_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sghat::P64 = R2;
           R2 = _sgham::P64;
           R1 = _sghat::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghar_entry() //  [R1]
         { info_tbl: [(cgiD3,
                       label: sat_sghar_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiD3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiD4; else goto cgiD5;
       cgiD4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiD5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Functor.Compose.$fDataCompose2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sghas_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgiD6,
                       label: sat_sghas_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiD6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgiDa; else goto cgiD9;
       cgiDa: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgiD9: // global
           _sgham::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_sghar_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           _sghao::P64 = R2;
           R2 = _sgham::P64;
           R1 = _sghao::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sghan_entry() //  [R1]
         { info_tbl: [(cgiDf,
                       label: sat_sghan_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiDf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgiDg; else goto cgiDh;
       cgiDg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiDh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Compose.$w$cp1Data_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Compose.$fDataCompose_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgiDj,
                       label: Data.Functor.Compose.$fDataCompose_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiDj: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto cgiDn; else goto cgiDm;
       cgiDn: // global
           HpAlloc = 344;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Compose.$fDataCompose_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgiDm: // global
           I64[Hp - 336] = sat_sghb9_info;
           _sgham::P64 = P64[Sp];
           P64[Hp - 328] = _sgham::P64;
           I64[Hp - 320] = sat_sghb5_info;
           P64[Hp - 312] = _sgham::P64;
           I64[Hp - 304] = sat_sghb1_info;
           P64[Hp - 296] = _sgham::P64;
           I64[Hp - 288] = sat_sghaX_info;
           P64[Hp - 280] = _sgham::P64;
           I64[Hp - 272] = sat_sghaQ_info;
           P64[Hp - 264] = _sgham::P64;
           I64[Hp - 256] = sat_sghaM_info;
           P64[Hp - 248] = _sgham::P64;
           I64[Hp - 240] = sat_sghaG_info;
           P64[Hp - 232] = _sgham::P64;
           I64[Hp - 224] = sat_sghaA_info;
           P64[Hp - 216] = _sgham::P64;
           I64[Hp - 208] = sat_sghax_info;
           P64[Hp - 200] = _sgham::P64;
           I64[Hp - 192] = sat_sghas_info;
           P64[Hp - 184] = _sgham::P64;
           I64[Hp - 176] = sat_sghan_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 189;
           P64[Hp - 96] = Hp - 205;
           P64[Hp - 88] = lvl4_rgdQh_closure+1;
           P64[Hp - 80] = lvl5_rgdQi_closure+1;
           P64[Hp - 72] = lvl6_rgdQj_closure+2;
           P64[Hp - 64] = lvl7_rgdQk_closure+2;
           P64[Hp - 56] = Hp - 222;
           P64[Hp - 48] = Hp - 236;
           P64[Hp - 40] = Hp - 252;
           P64[Hp - 32] = Hp - 270;
           P64[Hp - 24] = Hp - 285;
           P64[Hp - 16] = Hp - 301;
           P64[Hp - 8] = Hp - 317;
           P64[Hp] = Hp - 333;
           R1 = Hp - 119;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:12.66195237 UTC

[section ""relreadonly" . Sghf8_srt" {
     Sghf8_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Data.Functor.Compose.$fRead1Compose2_closure;
         const GHC.Read.list3_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec_closure;
         const Data.Functor.Compose.$fRead1Compose_$cliftReadList_closure;
         const Data.Functor.Compose.$fRead1Compose_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Functor.Compose.$w$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec_closure;
         const Data.Functor.Compose.$fShow1Compose_$cliftShowList_closure;
         const Data.Functor.Compose.$fShow1Compose_closure;
         const Data.Functor.Compose.$fReadCompose_$creadPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadsPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadListPrec_closure;
         const Data.Functor.Compose.$fReadCompose_$creadList_closure;
         const Data.Functor.Compose.$fReadCompose_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowsPrec_closure;
         const Data.Functor.Compose.$fShowCompose_$cshow_closure;
         const Data.Functor.Compose.$fShowCompose_$cshowList_closure;
         const Data.Functor.Compose.$fShowCompose_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Functor.Compose.$fFoldableCompose_$csum_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Functor.Compose.$fFoldableCompose2_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cminimum_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Compose.$fFoldableCompose3_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cmaximum_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Functor.Compose.$fFoldableCompose_$celem_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Functor.Compose.$fFoldableCompose7_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl1_closure;
         const Data.Functor.Compose.$fFoldableCompose6_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldl'_closure;
         const Data.Functor.Compose.$fFoldableCompose_$clength_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cfoldr1_closure;
         const Data.Functor.Compose.$fFoldableCompose8_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cnull_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$cproduct_closure;
         const Data.Functor.Compose.$fFoldableCompose_$ctoList_closure;
         const Data.Functor.Compose.$fFoldableCompose_closure;
         const Data.Functor.Compose.$fTraversableCompose_$cp2Traversable_closure;
         const Data.Functor.Compose.$fTraversableCompose_closure;
         const GHC.List.badHead_closure;
         const go61_rgdPX_closure;
         const Data.Functor.Compose.$fDataCompose6_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Functor.Compose.$fDataCompose5_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Functor.Compose.$w$cp1Data_closure;
         const Data.Functor.Compose.$cCompose_closure;
         const Data.Functor.Compose.$tCompose_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Functor.Compose.$fDataCompose_closure;
         const lvl4_rgdQh_closure;
         const lvl5_rgdQi_closure;
 }]

