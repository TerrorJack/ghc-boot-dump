
==================== Tidy Core ====================
2018-03-16 16:11:54.467197261 UTC

Result size of Tidy Core
  = {terms: 3,524, types: 10,491, coercions: 1,135, joins: 0/48}

-- RHS size: {terms: 27, types: 56, coercions: 4, joins: 0/0}
Data.Functor.Product.$fEq1Product_$cliftEq
  :: forall (f :: * -> *) (g :: * -> *).
     (Eq1 f, Eq1 g) =>
     forall a b.
     (a -> b -> Bool) -> Product f g a -> Product f g b -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag476 :: * -> *))
                 (@ (g_ag477 :: * -> *))
                 ($dEq1_ag478 [Occ=Once] :: Eq1 f_ag476)
                 ($dEq2_ag479 [Occ=Once] :: Eq1 g_ag477)
                 (@ a_ag47d)
                 (@ b_ag47e)
                 (eq_ag3Fs :: a_ag47d -> b_ag47e -> Bool)
                 (ds_dg4e5 [Occ=Once!] :: Product f_ag476 g_ag477 a_ag47d)
                 (ds1_dg4e6 [Occ=Once!] :: Product f_ag476 g_ag477 b_ag47e) ->
                 case ds_dg4e5 of { Pair x1_ag3Ft [Occ=Once] y1_ag3Fu [Occ=Once] ->
                 case ds1_dg4e6 of { Pair x2_ag3Fv [Occ=Once] y2_ag3Fw [Occ=Once] ->
                 case ($dEq1_ag478
                       `cast` (Data.Functor.Classes.N:Eq1[0] <f_ag476>_N
                               :: (Eq1 f_ag476 :: Constraint)
                                  ~R# (forall a b.
                                       (a -> b -> Bool) -> f_ag476 a -> f_ag476 b -> Bool :: *)))
                        @ a_ag47d @ b_ag47e eq_ag3Fs x1_ag3Ft x2_ag3Fv
                 of {
                   False -> GHC.Types.False;
                   True ->
                     ($dEq2_ag479
                      `cast` (Data.Functor.Classes.N:Eq1[0] <g_ag477>_N
                              :: (Eq1 g_ag477 :: Constraint)
                                 ~R# (forall a b.
                                      (a -> b -> Bool) -> g_ag477 a -> g_ag477 b -> Bool :: *)))
                       @ a_ag47d @ b_ag47e eq_ag3Fs y1_ag3Fu y2_ag3Fw
                 }
                 }
                 }}]
Data.Functor.Product.$fEq1Product_$cliftEq
  = \ (@ (f_ag476 :: * -> *))
      (@ (g_ag477 :: * -> *))
      ($dEq1_ag478 :: Eq1 f_ag476)
      ($dEq2_ag479 :: Eq1 g_ag477)
      (@ a_ag47d)
      (@ b_ag47e)
      (eq_ag3Fs :: a_ag47d -> b_ag47e -> Bool)
      (ds_dg4e5 :: Product f_ag476 g_ag477 a_ag47d)
      (ds1_dg4e6 :: Product f_ag476 g_ag477 b_ag47e) ->
      case ds_dg4e5 of { Pair x1_ag3Ft y1_ag3Fu ->
      case ds1_dg4e6 of { Pair x2_ag3Fv y2_ag3Fw ->
      case ($dEq1_ag478
            `cast` (Data.Functor.Classes.N:Eq1[0] <f_ag476>_N
                    :: (Eq1 f_ag476 :: Constraint)
                       ~R# (forall a b.
                            (a -> b -> Bool) -> f_ag476 a -> f_ag476 b -> Bool :: *)))
             @ a_ag47d @ b_ag47e eq_ag3Fs x1_ag3Ft x2_ag3Fv
      of {
        False -> GHC.Types.False;
        True ->
          ($dEq2_ag479
           `cast` (Data.Functor.Classes.N:Eq1[0] <g_ag477>_N
                   :: (Eq1 g_ag477 :: Constraint)
                      ~R# (forall a b.
                           (a -> b -> Bool) -> g_ag477 a -> g_ag477 b -> Bool :: *)))
            @ a_ag47d @ b_ag47e eq_ag3Fs y1_ag3Fu y2_ag3Fw
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
Data.Functor.Product.$fEq1Product [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Eq1 f, Eq1 g) =>
     Eq1 (Product f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Functor.Product.$fEq1Product_$cliftEq
               `cast` (forall (f :: <* -> *>_N) (g :: <* -> *>_N).
                       <Eq1 f>_R
                       ->_R <Eq1 g>_R
                       ->_R Sym (Data.Functor.Classes.N:Eq1[0] <Product f g>_N)
                       :: (forall (f :: * -> *) (g :: * -> *).
                           (Eq1 f, Eq1 g) =>
                           forall a b.
                           (a -> b -> Bool) -> Product f g a -> Product f g b -> Bool :: *)
                          ~R# (forall (f :: * -> *) (g :: * -> *).
                               (Eq1 f, Eq1 g) =>
                               Eq1 (Product f g) :: *))}]
Data.Functor.Product.$fEq1Product
  = Data.Functor.Product.$fEq1Product_$cliftEq
    `cast` (forall (f :: <* -> *>_N) (g :: <* -> *>_N).
            <Eq1 f>_R
            ->_R <Eq1 g>_R
            ->_R Sym (Data.Functor.Classes.N:Eq1[0] <Product f g>_N)
            :: (forall (f :: * -> *) (g :: * -> *).
                (Eq1 f, Eq1 g) =>
                forall a b.
                (a -> b -> Bool) -> Product f g a -> Product f g b -> Bool :: *)
               ~R# (forall (f :: * -> *) (g :: * -> *).
                    (Eq1 f, Eq1 g) =>
                    Eq1 (Product f g) :: *))

-- RHS size: {terms: 27, types: 34, coercions: 0, joins: 0/0}
Data.Functor.Product.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Ord1 f, Ord1 g) =>
     forall a b.
     (a -> b -> Ordering) -> f a -> g a -> f b -> g b -> Ordering
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 0 0 0] 130 20}]
Data.Functor.Product.$w$cliftCompare
  = \ (@ (f_sg4Ol :: * -> *))
      (@ (g_sg4Om :: * -> *))
      (w_sg4On :: Ord1 f_sg4Ol)
      (w1_sg4Oo :: Ord1 g_sg4Om)
      (@ a_sg4Op)
      (@ b_sg4Oq)
      (w2_sg4Or :: a_sg4Op -> b_sg4Oq -> Ordering)
      (ww_sg4Ow :: f_sg4Ol a_sg4Op)
      (ww1_sg4Ox :: g_sg4Om a_sg4Op)
      (ww2_sg4OB :: f_sg4Ol b_sg4Oq)
      (ww3_sg4OC :: g_sg4Om b_sg4Oq) ->
      case liftCompare
             @ f_sg4Ol w_sg4On @ a_sg4Op @ b_sg4Oq w2_sg4Or ww_sg4Ow ww2_sg4OB
      of {
        LT -> GHC.Types.LT;
        EQ ->
          liftCompare
            @ g_sg4Om
            w1_sg4Oo
            @ a_sg4Op
            @ b_sg4Oq
            w2_sg4Or
            ww1_sg4Ox
            ww3_sg4OC;
        GT -> GHC.Types.GT
      }

-- RHS size: {terms: 23, types: 55, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrd1Product_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Ord1 f, Ord1 g) =>
     forall a b.
     (a -> b -> Ordering) -> Product f g a -> Product f g b -> Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Ol :: * -> *))
                 (@ (g_sg4Om :: * -> *))
                 (w_sg4On [Occ=Once] :: Ord1 f_sg4Ol)
                 (w1_sg4Oo [Occ=Once] :: Ord1 g_sg4Om)
                 (@ a_sg4Op)
                 (@ b_sg4Oq)
                 (w2_sg4Or [Occ=Once] :: a_sg4Op -> b_sg4Oq -> Ordering)
                 (w3_sg4Os [Occ=Once!] :: Product f_sg4Ol g_sg4Om a_sg4Op)
                 (w4_sg4Ot [Occ=Once!] :: Product f_sg4Ol g_sg4Om b_sg4Oq) ->
                 case w3_sg4Os of
                 { Pair ww1_sg4Ow [Occ=Once] ww2_sg4Ox [Occ=Once] ->
                 case w4_sg4Ot of
                 { Pair ww4_sg4OB [Occ=Once] ww5_sg4OC [Occ=Once] ->
                 Data.Functor.Product.$w$cliftCompare
                   @ f_sg4Ol
                   @ g_sg4Om
                   w_sg4On
                   w1_sg4Oo
                   @ a_sg4Op
                   @ b_sg4Oq
                   w2_sg4Or
                   ww1_sg4Ow
                   ww2_sg4Ox
                   ww4_sg4OB
                   ww5_sg4OC
                 }
                 }}]
Data.Functor.Product.$fOrd1Product_$cliftCompare
  = \ (@ (f_sg4Ol :: * -> *))
      (@ (g_sg4Om :: * -> *))
      (w_sg4On :: Ord1 f_sg4Ol)
      (w1_sg4Oo :: Ord1 g_sg4Om)
      (@ a_sg4Op)
      (@ b_sg4Oq)
      (w2_sg4Or :: a_sg4Op -> b_sg4Oq -> Ordering)
      (w3_sg4Os :: Product f_sg4Ol g_sg4Om a_sg4Op)
      (w4_sg4Ot :: Product f_sg4Ol g_sg4Om b_sg4Oq) ->
      case w3_sg4Os of { Pair ww1_sg4Ow ww2_sg4Ox ->
      case w4_sg4Ot of { Pair ww4_sg4OB ww5_sg4OC ->
      Data.Functor.Product.$w$cliftCompare
        @ f_sg4Ol
        @ g_sg4Om
        w_sg4On
        w1_sg4Oo
        @ a_sg4Op
        @ b_sg4Oq
        w2_sg4Or
        ww1_sg4Ow
        ww2_sg4Ox
        ww4_sg4OB
        ww5_sg4OC
      }
      }

-- RHS size: {terms: 25, types: 34, coercions: 4, joins: 0/0}
Data.Functor.Product.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Ord1 f, Ord1 g) =>
     forall a b. (a -> b -> Bool) -> f a -> g a -> f b -> g b -> Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 0 0 0] 120 10}]
Data.Functor.Product.$w$cp1Ord1
  = \ (@ (f_sg4OF :: * -> *))
      (@ (g_sg4OG :: * -> *))
      (w_sg4OH :: Ord1 f_sg4OF)
      (w1_sg4OI :: Ord1 g_sg4OG)
      (@ a_sg4OJ)
      (@ b_sg4OK)
      (w2_sg4OL :: a_sg4OJ -> b_sg4OK -> Bool)
      (ww_sg4OQ :: f_sg4OF a_sg4OJ)
      (ww1_sg4OR :: g_sg4OG a_sg4OJ)
      (ww2_sg4OV :: f_sg4OF b_sg4OK)
      (ww3_sg4OW :: g_sg4OG b_sg4OK) ->
      case ((Data.Functor.Classes.$p1Ord1 @ f_sg4OF w_sg4OH)
            `cast` (Data.Functor.Classes.N:Eq1[0] <f_sg4OF>_N
                    :: (Eq1 f_sg4OF :: Constraint)
                       ~R# (forall a b.
                            (a -> b -> Bool) -> f_sg4OF a -> f_sg4OF b -> Bool :: *)))
             @ a_sg4OJ @ b_sg4OK w2_sg4OL ww_sg4OQ ww2_sg4OV
      of {
        False -> GHC.Types.False;
        True ->
          ((Data.Functor.Classes.$p1Ord1 @ g_sg4OG w1_sg4OI)
           `cast` (Data.Functor.Classes.N:Eq1[0] <g_sg4OG>_N
                   :: (Eq1 g_sg4OG :: Constraint)
                      ~R# (forall a b.
                           (a -> b -> Bool) -> g_sg4OG a -> g_sg4OG b -> Bool :: *)))
            @ a_sg4OJ @ b_sg4OK w2_sg4OL ww1_sg4OR ww3_sg4OW
      }

-- RHS size: {terms: 23, types: 55, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrd1Product1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Ord1 f, Ord1 g) =>
     forall a b.
     (a -> b -> Bool) -> Product f g a -> Product f g b -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4OF :: * -> *))
                 (@ (g_sg4OG :: * -> *))
                 (w_sg4OH [Occ=Once] :: Ord1 f_sg4OF)
                 (w1_sg4OI [Occ=Once] :: Ord1 g_sg4OG)
                 (@ a_sg4OJ)
                 (@ b_sg4OK)
                 (w2_sg4OL [Occ=Once] :: a_sg4OJ -> b_sg4OK -> Bool)
                 (w3_sg4OM [Occ=Once!] :: Product f_sg4OF g_sg4OG a_sg4OJ)
                 (w4_sg4ON [Occ=Once!] :: Product f_sg4OF g_sg4OG b_sg4OK) ->
                 case w3_sg4OM of
                 { Pair ww1_sg4OQ [Occ=Once] ww2_sg4OR [Occ=Once] ->
                 case w4_sg4ON of
                 { Pair ww4_sg4OV [Occ=Once] ww5_sg4OW [Occ=Once] ->
                 Data.Functor.Product.$w$cp1Ord1
                   @ f_sg4OF
                   @ g_sg4OG
                   w_sg4OH
                   w1_sg4OI
                   @ a_sg4OJ
                   @ b_sg4OK
                   w2_sg4OL
                   ww1_sg4OQ
                   ww2_sg4OR
                   ww4_sg4OV
                   ww5_sg4OW
                 }
                 }}]
Data.Functor.Product.$fOrd1Product1
  = \ (@ (f_sg4OF :: * -> *))
      (@ (g_sg4OG :: * -> *))
      (w_sg4OH :: Ord1 f_sg4OF)
      (w1_sg4OI :: Ord1 g_sg4OG)
      (@ a_sg4OJ)
      (@ b_sg4OK)
      (w2_sg4OL :: a_sg4OJ -> b_sg4OK -> Bool)
      (w3_sg4OM :: Product f_sg4OF g_sg4OG a_sg4OJ)
      (w4_sg4ON :: Product f_sg4OF g_sg4OG b_sg4OK) ->
      case w3_sg4OM of { Pair ww1_sg4OQ ww2_sg4OR ->
      case w4_sg4ON of { Pair ww4_sg4OV ww5_sg4OW ->
      Data.Functor.Product.$w$cp1Ord1
        @ f_sg4OF
        @ g_sg4OG
        w_sg4OH
        w1_sg4OI
        @ a_sg4OJ
        @ b_sg4OK
        w2_sg4OL
        ww1_sg4OQ
        ww2_sg4OR
        ww4_sg4OV
        ww5_sg4OW
      }
      }

-- RHS size: {terms: 11, types: 21, coercions: 7, joins: 0/0}
Data.Functor.Product.$fOrd1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Ord1 f, Ord1 g) =>
     Ord1 (Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(C1(C1(U))),C(C1(C1(U))))>m,
 Unf=DFun: \ (@ (f_ag3Fj :: * -> *))
             (@ (g_ag3Fk :: * -> *))
             (v_B1 :: Ord1 f_ag3Fj)
             (v1_B2 :: Ord1 g_ag3Fk) ->
       Data.Functor.Classes.C:Ord1 TYPE: Product f_ag3Fj g_ag3Fk
                                   (Data.Functor.Product.$fOrd1Product1
                                      @ f_ag3Fj @ g_ag3Fk v_B1 v1_B2)
                                   `cast` (Sym (Data.Functor.Classes.N:Eq1[0]
                                                    <Product f_ag3Fj g_ag3Fk>_N)
                                           :: (forall a b.
                                               (a -> b -> Bool)
                                               -> Product f_ag3Fj g_ag3Fk a
                                               -> Product f_ag3Fj g_ag3Fk b
                                               -> Bool :: *)
                                              ~R# (Eq1 (Product f_ag3Fj g_ag3Fk) :: Constraint))
                                   Data.Functor.Product.$fOrd1Product_$cliftCompare
                                     @ f_ag3Fj @ g_ag3Fk v_B1 v1_B2]
Data.Functor.Product.$fOrd1Product
  = \ (@ (f_Xg499 :: * -> *))
      (@ (g_Xg49b :: * -> *))
      ($dOrd1_Xg49d :: Ord1 f_Xg499)
      ($dOrd2_Xg49f :: Ord1 g_Xg49b) ->
      Data.Functor.Classes.C:Ord1
        @ (Product f_Xg499 g_Xg49b)
        ((Data.Functor.Product.$fOrd1Product1
            @ f_Xg499 @ g_Xg49b $dOrd1_Xg49d $dOrd2_Xg49f)
         `cast` (Sym (Data.Functor.Classes.N:Eq1[0]
                          <Product f_Xg499 g_Xg49b>_N)
                 :: (forall a b.
                     (a -> b -> Bool)
                     -> Product f_Xg499 g_Xg49b a
                     -> Product f_Xg499 g_Xg49b b
                     -> Bool :: *)
                    ~R# (Eq1 (Product f_Xg499 g_Xg49b) :: Constraint)))
        (Data.Functor.Product.$fOrd1Product_$cliftCompare
           @ f_Xg499 @ g_Xg49b $dOrd1_Xg49d $dOrd2_Xg49f)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Product.$fRead1Product3 = "Pair"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Product.$fRead1Product2
  = GHC.CString.unpackCString# Data.Functor.Product.$fRead1Product3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$fRead1Product1
  = Text.Read.Lex.Ident Data.Functor.Product.$fRead1Product2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product_lvl3
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$fRead1Product_lvl3 = GHC.Types.I# 11#

-- RHS size: {terms: 62, types: 122, coercions: 50, joins: 0/4}
Data.Functor.Product.$fRead1Product_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Read1 f, Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0] 451 60}]
Data.Functor.Product.$fRead1Product_$cliftReadPrec
  = \ (@ (f_ag45N :: * -> *))
      (@ (g_ag45O :: * -> *))
      ($dRead1_ag45P :: Read1 f_ag45N)
      ($dRead2_ag45Q :: Read1 g_ag45O)
      (@ a_ag46b)
      (rp_ag3Fh :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag46b)
      (rl_ag3Fi :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag46b]) ->
      let {
        reader_sg4o2 [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.ReadPrec (f_ag45N a_ag46b)
        [LclId]
        reader_sg4o2
          = liftReadPrec
              @ f_ag45N $dRead1_ag45P @ a_ag46b rp_ag3Fh rl_ag3Fi } in
      let {
        reader1_sg4o1 [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.ReadPrec (g_ag45O a_ag46b)
        [LclId]
        reader1_sg4o1
          = liftReadPrec
              @ g_ag45O $dRead2_ag45Q @ a_ag46b rp_ag3Fh rl_ag3Fi } in
      let {
        $wlvl_sg4P6 [InlPrag=NOUSERINLINE[0], Dmd=<L,C(C1(U))>]
          :: GHC.Prim.Int#
             -> forall b.
                (Product f_ag45N g_ag45O a_ag46b
                 -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []]
        $wlvl_sg4P6
          = \ (ww_sg4P4 :: GHC.Prim.Int#)
              (@ b_sg4P0)
              (w_sg4P1
                 :: Product f_ag45N g_ag45O a_ag46b
                    -> Text.ParserCombinators.ReadP.P b_sg4P0) ->
              case GHC.Prim.<=# ww_sg4P4 10# of {
                __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_sg4P0;
                1# ->
                  case Text.Read.Lex.$wexpect
                         Data.Functor.Product.$fRead1Product1
                         @ b_sg4P0
                         (\ _ [Occ=Dead, OS=OneShot] ->
                            (((reader_sg4o2
                               `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                           <f_ag45N a_ag46b>_R
                                       :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (f_ag45N a_ag46b) :: *)
                                          ~R# (Text.ParserCombinators.ReadPrec.Prec
                                               -> Text.ParserCombinators.ReadP.ReadP
                                                    (f_ag45N a_ag46b) :: *)))
                                Data.Functor.Product.$fRead1Product_lvl3)
                             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <f_ag45N a_ag46b>_R
                                     :: (Text.ParserCombinators.ReadP.ReadP (f_ag45N a_ag46b) :: *)
                                        ~R# (forall b.
                                             (f_ag45N a_ag46b -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)))
                              @ b_sg4P0
                              (\ (a2_i88WJ :: f_ag45N a_ag46b) ->
                                 (((reader1_sg4o1
                                    `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <g_ag45O a_ag46b>_R
                                            :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                  (g_ag45O a_ag46b) :: *)
                                               ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                    -> Text.ParserCombinators.ReadP.ReadP
                                                         (g_ag45O a_ag46b) :: *)))
                                     Data.Functor.Product.$fRead1Product_lvl3)
                                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <g_ag45O a_ag46b>_R
                                          :: (Text.ParserCombinators.ReadP.ReadP
                                                (g_ag45O a_ag46b) :: *)
                                             ~R# (forall b.
                                                  (g_ag45O a_ag46b
                                                   -> Text.ParserCombinators.ReadP.P b)
                                                  -> Text.ParserCombinators.ReadP.P b :: *)))
                                   @ b_sg4P0
                                   (\ (a3_X8937 :: g_ag45O a_ag46b) ->
                                      w_sg4P1
                                        (Data.Functor.Product.Pair
                                           @ * @ f_ag45N @ g_ag45O @ a_ag46b a2_i88WJ a3_X8937))))
                  of
                  { (# ww2_sdy4e #) ->
                  Text.ParserCombinators.ReadP.Look @ b_sg4P0 ww2_sdy4e
                  }
              } } in
      let {
        lvl9_sg4o8 [InlPrag=NOUSERINLINE[0], Dmd=<L,C(C(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (Product f_ag45N g_ag45O a_ag46b
                 -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId,
         Arity=2,
         Str=<S(S),1*U(U)><L,C(U)>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (w_sg4OZ [Occ=Once!]
                            :: Text.ParserCombinators.ReadPrec.Prec)
                         (@ b_sg4P0)
                         (w1_sg4P1 [Occ=Once]
                            :: Product f_ag45N g_ag45O a_ag46b
                               -> Text.ParserCombinators.ReadP.P b_sg4P0) ->
                         case w_sg4OZ of { GHC.Types.I# ww1_sg4P4 [Occ=Once] ->
                         $wlvl_sg4P6 ww1_sg4P4 @ b_sg4P0 w1_sg4P1
                         }}]
        lvl9_sg4o8
          = \ (w_sg4OZ :: Text.ParserCombinators.ReadPrec.Prec)
              (@ b_sg4P0)
              (w1_sg4P1
                 :: Product f_ag45N g_ag45O a_ag46b
                    -> Text.ParserCombinators.ReadP.P b_sg4P0) ->
              case w_sg4OZ of { GHC.Types.I# ww1_sg4P4 ->
              $wlvl_sg4P6 ww1_sg4P4 @ b_sg4P0 w1_sg4P1
              } } in
      (\ (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
         (@ b_i815e)
         (eta1_B1
            :: Product f_ag45N g_ag45O a_ag46b
               -> Text.ParserCombinators.ReadP.P b_i815e) ->
         GHC.Read.list3
           @ (Product f_ag45N g_ag45O a_ag46b)
           (lvl9_sg4o8
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Product
                                      f_ag45N
                                      g_ag45O
                                      a_ag46b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Product f_ag45N g_ag45O a_ag46b>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Product f_ag45N g_ag45O a_ag46b
                            -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                              (Product f_ag45N g_ag45O a_ag46b) :: *)))
           eta_B2
           @ b_i815e
           eta1_B1)
      `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                             <Product
                                f_ag45N
                                g_ag45O
                                a_ag46b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Product f_ag45N g_ag45O a_ag46b>_R)
              :: (Text.ParserCombinators.ReadPrec.Prec
                  -> forall b.
                     (Product f_ag45N g_ag45O a_ag46b
                      -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)
                 ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                        (Product f_ag45N g_ag45O a_ag46b) :: *))

-- RHS size: {terms: 28, types: 69, coercions: 34, joins: 0/1}
Data.Functor.Product.$fRead1Product_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Read1 f, Read1 g) =>
     forall a.
     (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (Product f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 210 60}]
Data.Functor.Product.$fRead1Product_$cliftReadsPrec
  = \ (@ (f_ag45N :: * -> *))
      (@ (g_ag45O :: * -> *))
      ($dRead1_ag45P :: Read1 f_ag45N)
      ($dRead2_ag45Q :: Read1 g_ag45O)
      (@ a_ag45U)
      (rp_adwa1 :: Int -> ReadS a_ag45U)
      (rl_adwa2 :: ReadS [a_ag45U]) ->
      let {
        ds_sg4nW [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.ReadPrec
               (Product f_ag45N g_ag45O a_ag45U)
        [LclId]
        ds_sg4nW
          = Data.Functor.Product.$fRead1Product_$cliftReadPrec
              @ f_ag45N
              @ g_ag45O
              $dRead1_ag45P
              $dRead2_ag45Q
              @ a_ag45U
              ((Text.ParserCombinators.ReadPrec.readS_to_Prec1
                  @ a_ag45U rp_adwa1)
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <a_ag45U>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <a_ag45U>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              (a_ag45U -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (Text.ParserCombinators.ReadPrec.ReadPrec a_ag45U :: *)))
              ((\ _ [Occ=Dead]
                  (@ b_idxi2)
                  (w1_idxi3
                     :: [a_ag45U] -> Text.ParserCombinators.ReadP.P b_idxi2) ->
                  case Text.ParserCombinators.ReadP.$wreadS_to_P
                         @ [a_ag45U] rl_adwa2 @ b_idxi2 w1_idxi3
                  of
                  { (# ww1_idxi6 #) ->
                  Text.ParserCombinators.ReadP.Look @ b_idxi2 ww1_idxi6
                  })
               `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <[a_ag45U]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <[a_ag45U]>_R)
                       :: (Text.ParserCombinators.ReadPrec.Prec
                           -> forall b.
                              ([a_ag45U] -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                 [a_ag45U] :: *))) } in
      \ (n_idx7Z :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (Product f_ag45N g_ag45O a_ag45U)
          ((((ds_sg4nW
              `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Product f_ag45N g_ag45O a_ag45U>_R
                      :: (Text.ParserCombinators.ReadPrec.ReadPrec
                            (Product f_ag45N g_ag45O a_ag45U) :: *)
                         ~R# (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP
                                   (Product f_ag45N g_ag45O a_ag45U) :: *)))
               n_idx7Z)
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                        <Product f_ag45N g_ag45O a_ag45U>_R
                    :: (Text.ParserCombinators.ReadP.ReadP
                          (Product f_ag45N g_ag45O a_ag45U) :: *)
                       ~R# (forall b.
                            (Product f_ag45N g_ag45O a_ag45U
                             -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)))
             @ (Product f_ag45N g_ag45O a_ag45U)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (Product f_ag45N g_ag45O a_ag45U)))

-- RHS size: {terms: 13, types: 28, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Read1 f, Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [Product f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag45N :: * -> *))
                 (@ (g_ag45O :: * -> *))
                 ($dRead1_ag45P [Occ=Once] :: Read1 f_ag45N)
                 ($dRead2_ag45Q [Occ=Once] :: Read1 g_ag45O)
                 (@ a_ag46x)
                 (rp_adwdf [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag46x)
                 (rl_adwdg [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag46x]) ->
                 GHC.Read.list
                   @ (Product f_ag45N g_ag45O a_ag46x)
                   (Data.Functor.Product.$fRead1Product_$cliftReadPrec
                      @ f_ag45N
                      @ g_ag45O
                      $dRead1_ag45P
                      $dRead2_ag45Q
                      @ a_ag46x
                      rp_adwdf
                      rl_adwdg)}]
Data.Functor.Product.$fRead1Product_$cliftReadListPrec
  = \ (@ (f_ag45N :: * -> *))
      (@ (g_ag45O :: * -> *))
      ($dRead1_ag45P :: Read1 f_ag45N)
      ($dRead2_ag45Q :: Read1 g_ag45O)
      (@ a_ag46x)
      (rp_adwdf :: Text.ParserCombinators.ReadPrec.ReadPrec a_ag46x)
      (rl_adwdg :: Text.ParserCombinators.ReadPrec.ReadPrec [a_ag46x]) ->
      GHC.Read.list
        @ (Product f_ag45N g_ag45O a_ag46x)
        (Data.Functor.Product.$fRead1Product_$cliftReadPrec
           @ f_ag45N
           @ g_ag45O
           $dRead1_ag45P
           $dRead2_ag45Q
           @ a_ag46x
           rp_adwdf
           rl_adwdg)

Rec {
-- RHS size: {terms: 17, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Read1 f, Read1 g) =>
     Read1 (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>m,
 Unf=DFun: \ (@ (f_ag3Ff :: * -> *))
             (@ (g_ag3Fg :: * -> *))
             (v_B1 :: Read1 f_ag3Ff)
             (v1_B2 :: Read1 g_ag3Fg) ->
       Data.Functor.Classes.C:Read1 TYPE: Product f_ag3Ff g_ag3Fg
                                    Data.Functor.Product.$fRead1Product_$cliftReadsPrec
                                      @ f_ag3Ff @ g_ag3Fg v_B1 v1_B2
                                    Data.Functor.Product.$fRead1Product_$cliftReadList
                                      @ f_ag3Ff @ g_ag3Fg v_B1 v1_B2
                                    Data.Functor.Product.$fRead1Product_$cliftReadPrec
                                      @ f_ag3Ff @ g_ag3Fg v_B1 v1_B2
                                    Data.Functor.Product.$fRead1Product_$cliftReadListPrec
                                      @ f_ag3Ff @ g_ag3Fg v_B1 v1_B2]
Data.Functor.Product.$fRead1Product
  = \ (@ (f_ag45N :: * -> *))
      (@ (g_ag45O :: * -> *))
      ($dRead1_ag45P :: Read1 f_ag45N)
      ($dRead2_ag45Q :: Read1 g_ag45O) ->
      Data.Functor.Classes.C:Read1
        @ (Product f_ag45N g_ag45O)
        (Data.Functor.Product.$fRead1Product_$cliftReadsPrec
           @ f_ag45N @ g_ag45O $dRead1_ag45P $dRead2_ag45Q)
        (Data.Functor.Product.$fRead1Product_$cliftReadList
           @ f_ag45N @ g_ag45O $dRead1_ag45P $dRead2_ag45Q)
        (Data.Functor.Product.$fRead1Product_$cliftReadPrec
           @ f_ag45N @ g_ag45O $dRead1_ag45P $dRead2_ag45Q)
        (Data.Functor.Product.$fRead1Product_$cliftReadListPrec
           @ f_ag45N @ g_ag45O $dRead1_ag45P $dRead2_ag45Q)

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
Data.Functor.Product.$fRead1Product_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Read1 f, Read1 g) =>
     forall a. (Int -> ReadS a) -> ReadS [a] -> ReadS [Product f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)>,
 Unf=OtherCon []]
Data.Functor.Product.$fRead1Product_$cliftReadList
  = \ (@ (f_ag45N :: * -> *))
      (@ (g_ag45O :: * -> *))
      ($dRead1_ag45P :: Read1 f_ag45N)
      ($dRead2_ag45Q :: Read1 g_ag45O)
      (@ a_ag462) ->
      liftReadListDefault
        @ (Product f_ag45N g_ag45O)
        @ a_ag462
        (Data.Functor.Product.$fRead1Product
           @ f_ag45N @ g_ag45O $dRead1_ag45P $dRead2_ag45Q)
end Rec }

-- RHS size: {terms: 23, types: 33, coercions: 0, joins: 0/0}
Data.Functor.Product.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Show1 f, Show1 g) =>
     forall a.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS) -> GHC.Prim.Int# -> f a -> g a -> ShowS
[GblId,
 Arity=7,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 0 0 0] 150 0}]
Data.Functor.Product.$w$cliftShowsPrec
  = \ (@ (f_sg4Pp :: * -> *))
      (@ (g_sg4Pq :: * -> *))
      (w_sg4Pr :: Show1 f_sg4Pp)
      (w1_sg4Ps :: Show1 g_sg4Pq)
      (@ a_sg4Pt)
      (w2_sg4Pu :: Int -> a_sg4Pt -> ShowS)
      (w3_sg4Pv :: [a_sg4Pt] -> ShowS)
      (ww_sg4PA :: GHC.Prim.Int#)
      (ww1_sg4PE :: f_sg4Pp a_sg4Pt)
      (ww2_sg4PF :: g_sg4Pq a_sg4Pt) ->
      Data.Functor.Classes.$wshowsBinaryWith
        @ (f_sg4Pp a_sg4Pt)
        @ (g_sg4Pq a_sg4Pt)
        (liftShowsPrec @ f_sg4Pp w_sg4Pr @ a_sg4Pt w2_sg4Pu w3_sg4Pv)
        (liftShowsPrec @ g_sg4Pq w1_sg4Ps @ a_sg4Pt w2_sg4Pu w3_sg4Pv)
        Data.Functor.Product.$fRead1Product2
        ww_sg4PA
        ww1_sg4PE
        ww2_sg4PF

-- RHS size: {terms: 23, types: 42, coercions: 0, joins: 0/0}
Data.Functor.Product.$fShow1Product_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Show1 f, Show1 g) =>
     forall a.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS) -> Int -> Product f g a -> ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U><L,U><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Pp :: * -> *))
                 (@ (g_sg4Pq :: * -> *))
                 (w_sg4Pr [Occ=Once] :: Show1 f_sg4Pp)
                 (w1_sg4Ps [Occ=Once] :: Show1 g_sg4Pq)
                 (@ a_sg4Pt)
                 (w2_sg4Pu [Occ=Once] :: Int -> a_sg4Pt -> ShowS)
                 (w3_sg4Pv [Occ=Once] :: [a_sg4Pt] -> ShowS)
                 (w4_sg4Pw [Occ=Once!] :: Int)
                 (w5_sg4Px [Occ=Once!] :: Product f_sg4Pp g_sg4Pq a_sg4Pt) ->
                 case w4_sg4Pw of { GHC.Types.I# ww1_sg4PA [Occ=Once] ->
                 case w5_sg4Px of
                 { Pair ww3_sg4PE [Occ=Once] ww4_sg4PF [Occ=Once] ->
                 Data.Functor.Product.$w$cliftShowsPrec
                   @ f_sg4Pp
                   @ g_sg4Pq
                   w_sg4Pr
                   w1_sg4Ps
                   @ a_sg4Pt
                   w2_sg4Pu
                   w3_sg4Pv
                   ww1_sg4PA
                   ww3_sg4PE
                   ww4_sg4PF
                 }
                 }}]
Data.Functor.Product.$fShow1Product_$cliftShowsPrec
  = \ (@ (f_sg4Pp :: * -> *))
      (@ (g_sg4Pq :: * -> *))
      (w_sg4Pr :: Show1 f_sg4Pp)
      (w1_sg4Ps :: Show1 g_sg4Pq)
      (@ a_sg4Pt)
      (w2_sg4Pu :: Int -> a_sg4Pt -> ShowS)
      (w3_sg4Pv :: [a_sg4Pt] -> ShowS)
      (w4_sg4Pw :: Int)
      (w5_sg4Px :: Product f_sg4Pp g_sg4Pq a_sg4Pt) ->
      case w4_sg4Pw of { GHC.Types.I# ww1_sg4PA ->
      case w5_sg4Px of { Pair ww3_sg4PE ww4_sg4PF ->
      Data.Functor.Product.$w$cliftShowsPrec
        @ f_sg4Pp
        @ g_sg4Pq
        w_sg4Pr
        w1_sg4Ps
        @ a_sg4Pt
        w2_sg4Pu
        w3_sg4Pv
        ww1_sg4PA
        ww3_sg4PE
        ww4_sg4PF
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$fFoldableProduct4 = GHC.Types.I# 0#

-- RHS size: {terms: 24, types: 53, coercions: 0, joins: 0/0}
Data.Functor.Product.$fShow1Product_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Show1 f, Show1 g) =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Product f g a] -> ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U><L,U><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag45l :: * -> *))
                 (@ (g_ag45m :: * -> *))
                 ($dShow1_ag45n [Occ=Once] :: Show1 f_ag45l)
                 ($dShow2_ag45o [Occ=Once] :: Show1 g_ag45m)
                 (@ a_ag45G)
                 (sp_adw9U [Occ=Once] :: Int -> a_ag45G -> ShowS)
                 (sl_adw9V [Occ=Once] :: [a_ag45G] -> ShowS)
                 (eta_B2 [Occ=Once] :: [Product f_ag45l g_ag45m a_ag45G])
                 (eta1_B1 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Product f_ag45l g_ag45m a_ag45G)
                   (Data.Functor.Product.$fShow1Product_$cliftShowsPrec
                      @ f_ag45l
                      @ g_ag45m
                      $dShow1_ag45n
                      $dShow2_ag45o
                      @ a_ag45G
                      sp_adw9U
                      sl_adw9V
                      Data.Functor.Product.$fFoldableProduct4)
                   eta_B2
                   eta1_B1}]
Data.Functor.Product.$fShow1Product_$cliftShowList
  = \ (@ (f_ag45l :: * -> *))
      (@ (g_ag45m :: * -> *))
      ($dShow1_ag45n :: Show1 f_ag45l)
      ($dShow2_ag45o :: Show1 g_ag45m)
      (@ a_ag45G)
      (sp_adw9U :: Int -> a_ag45G -> ShowS)
      (sl_adw9V :: [a_ag45G] -> ShowS)
      (eta_B2 :: [Product f_ag45l g_ag45m a_ag45G])
      (eta1_B1 :: String) ->
      GHC.Show.showList__
        @ (Product f_ag45l g_ag45m a_ag45G)
        (\ (w_sg4Px :: Product f_ag45l g_ag45m a_ag45G) ->
           case w_sg4Px of { Pair ww1_sg4PE ww2_sg4PF ->
           Data.Functor.Product.$w$cliftShowsPrec
             @ f_ag45l
             @ g_ag45m
             $dShow1_ag45n
             $dShow2_ag45o
             @ a_ag45G
             sp_adw9U
             sl_adw9V
             0#
             ww1_sg4PE
             ww2_sg4PF
           })
        eta_B2
        eta1_B1

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Product.$fShow1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Show1 f, Show1 g) =>
     Show1 (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)>m,
 Unf=DFun: \ (@ (f_ag3F8 :: * -> *))
             (@ (g_ag3F9 :: * -> *))
             (v_B1 :: Show1 f_ag3F8)
             (v1_B2 :: Show1 g_ag3F9) ->
       Data.Functor.Classes.C:Show1 TYPE: Product f_ag3F8 g_ag3F9
                                    Data.Functor.Product.$fShow1Product_$cliftShowsPrec
                                      @ f_ag3F8 @ g_ag3F9 v_B1 v1_B2
                                    Data.Functor.Product.$fShow1Product_$cliftShowList
                                      @ f_ag3F8 @ g_ag3F9 v_B1 v1_B2]
Data.Functor.Product.$fShow1Product
  = \ (@ (f_ag45l :: * -> *))
      (@ (g_ag45m :: * -> *))
      ($dShow1_ag45n :: Show1 f_ag45l)
      ($dShow2_ag45o :: Show1 g_ag45m) ->
      Data.Functor.Classes.C:Show1
        @ (Product f_ag45l g_ag45m)
        (Data.Functor.Product.$fShow1Product_$cliftShowsPrec
           @ f_ag45l @ g_ag45m $dShow1_ag45n $dShow2_ag45o)
        (Data.Functor.Product.$fShow1Product_$cliftShowList
           @ f_ag45l @ g_ag45m $dShow1_ag45n $dShow2_ag45o)

-- RHS size: {terms: 25, types: 33, coercions: 4, joins: 0/1}
Data.Functor.Product.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Eq1 f, Eq1 g, Eq a) =>
     f a -> g a -> f a -> g a -> Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 30 0 0 0 0] 130 10}]
Data.Functor.Product.$w$c==
  = \ (@ (f_sg4PI :: * -> *))
      (@ (g_sg4PJ :: * -> *))
      (@ a_sg4PK)
      (w_sg4PL :: Eq1 f_sg4PI)
      (w1_sg4PM :: Eq1 g_sg4PJ)
      (w2_sg4PN :: Eq a_sg4PK)
      (ww_sg4PS :: f_sg4PI a_sg4PK)
      (ww1_sg4PT :: g_sg4PJ a_sg4PK)
      (ww2_sg4PX :: f_sg4PI a_sg4PK)
      (ww3_sg4PY :: g_sg4PJ a_sg4PK) ->
      let {
        eq_sg4nU :: a_sg4PK -> a_sg4PK -> Bool
        [LclId]
        eq_sg4nU = == @ a_sg4PK w2_sg4PN } in
      case (w_sg4PL
            `cast` (Data.Functor.Classes.N:Eq1[0] <f_sg4PI>_N
                    :: (Eq1 f_sg4PI :: Constraint)
                       ~R# (forall a b.
                            (a -> b -> Bool) -> f_sg4PI a -> f_sg4PI b -> Bool :: *)))
             @ a_sg4PK @ a_sg4PK eq_sg4nU ww_sg4PS ww2_sg4PX
      of {
        False -> GHC.Types.False;
        True ->
          (w1_sg4PM
           `cast` (Data.Functor.Classes.N:Eq1[0] <g_sg4PJ>_N
                   :: (Eq1 g_sg4PJ :: Constraint)
                      ~R# (forall a b.
                           (a -> b -> Bool) -> g_sg4PJ a -> g_sg4PJ b -> Bool :: *)))
            @ a_sg4PK @ a_sg4PK eq_sg4nU ww1_sg4PT ww3_sg4PY
      }

-- RHS size: {terms: 22, types: 51, coercions: 0, joins: 0/0}
Data.Functor.Product.$fEqProduct_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Eq1 f, Eq1 g, Eq a) =>
     Product f g a -> Product f g a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4PI :: * -> *))
                 (@ (g_sg4PJ :: * -> *))
                 (@ a_sg4PK)
                 (w_sg4PL [Occ=Once] :: Eq1 f_sg4PI)
                 (w1_sg4PM [Occ=Once] :: Eq1 g_sg4PJ)
                 (w2_sg4PN [Occ=Once] :: Eq a_sg4PK)
                 (w3_sg4PO [Occ=Once!] :: Product f_sg4PI g_sg4PJ a_sg4PK)
                 (w4_sg4PP [Occ=Once!] :: Product f_sg4PI g_sg4PJ a_sg4PK) ->
                 case w3_sg4PO of
                 { Pair ww1_sg4PS [Occ=Once] ww2_sg4PT [Occ=Once] ->
                 case w4_sg4PP of
                 { Pair ww4_sg4PX [Occ=Once] ww5_sg4PY [Occ=Once] ->
                 Data.Functor.Product.$w$c==
                   @ f_sg4PI
                   @ g_sg4PJ
                   @ a_sg4PK
                   w_sg4PL
                   w1_sg4PM
                   w2_sg4PN
                   ww1_sg4PS
                   ww2_sg4PT
                   ww4_sg4PX
                   ww5_sg4PY
                 }
                 }}]
Data.Functor.Product.$fEqProduct_$c==
  = \ (@ (f_sg4PI :: * -> *))
      (@ (g_sg4PJ :: * -> *))
      (@ a_sg4PK)
      (w_sg4PL :: Eq1 f_sg4PI)
      (w1_sg4PM :: Eq1 g_sg4PJ)
      (w2_sg4PN :: Eq a_sg4PK)
      (w3_sg4PO :: Product f_sg4PI g_sg4PJ a_sg4PK)
      (w4_sg4PP :: Product f_sg4PI g_sg4PJ a_sg4PK) ->
      case w3_sg4PO of { Pair ww1_sg4PS ww2_sg4PT ->
      case w4_sg4PP of { Pair ww4_sg4PX ww5_sg4PY ->
      Data.Functor.Product.$w$c==
        @ f_sg4PI
        @ g_sg4PJ
        @ a_sg4PK
        w_sg4PL
        w1_sg4PM
        w2_sg4PN
        ww1_sg4PS
        ww2_sg4PT
        ww4_sg4PX
        ww5_sg4PY
      }
      }

-- RHS size: {terms: 34, types: 58, coercions: 4, joins: 0/1}
Data.Functor.Product.$fEqProduct_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Eq1 f, Eq1 g, Eq a) =>
     Product f g a -> Product f g a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,1*U(1*U,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_ag450 :: * -> *))
                 (@ (g_ag451 :: * -> *))
                 (@ a_ag452)
                 ($dEq1_ag453 [Occ=Once] :: Eq1 f_ag450)
                 ($dEq2_ag454 [Occ=Once] :: Eq1 g_ag451)
                 ($dEq_ag455 [Occ=Once] :: Eq a_ag452)
                 (x_a22b [Occ=Once] :: Product f_ag450 g_ag451 a_ag452)
                 (y_a22c [Occ=Once] :: Product f_ag450 g_ag451 a_ag452) ->
                 case Data.Functor.Product.$fEqProduct_$c==
                        @ f_ag450
                        @ g_ag451
                        @ a_ag452
                        $dEq1_ag453
                        $dEq2_ag454
                        $dEq_ag455
                        x_a22b
                        y_a22c
                 of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }}]
Data.Functor.Product.$fEqProduct_$c/=
  = \ (@ (f_ag450 :: * -> *))
      (@ (g_ag451 :: * -> *))
      (@ a_ag452)
      ($dEq1_ag453 :: Eq1 f_ag450)
      ($dEq2_ag454 :: Eq1 g_ag451)
      ($dEq_ag455 :: Eq a_ag452)
      (eta_B2 :: Product f_ag450 g_ag451 a_ag452)
      (eta1_B1 :: Product f_ag450 g_ag451 a_ag452) ->
      case eta_B2 of { Pair ww1_sg4PS ww2_sg4PT ->
      case eta1_B1 of { Pair ww4_sg4PX ww5_sg4PY ->
      let {
        eq_sg4nU :: a_ag452 -> a_ag452 -> Bool
        [LclId]
        eq_sg4nU = == @ a_ag452 $dEq_ag455 } in
      case ($dEq1_ag453
            `cast` (Data.Functor.Classes.N:Eq1[0] <f_ag450>_N
                    :: (Eq1 f_ag450 :: Constraint)
                       ~R# (forall a b.
                            (a -> b -> Bool) -> f_ag450 a -> f_ag450 b -> Bool :: *)))
             @ a_ag452 @ a_ag452 eq_sg4nU ww1_sg4PS ww4_sg4PX
      of {
        False -> GHC.Types.True;
        True ->
          case ($dEq2_ag454
                `cast` (Data.Functor.Classes.N:Eq1[0] <g_ag451>_N
                        :: (Eq1 g_ag451 :: Constraint)
                           ~R# (forall a b.
                                (a -> b -> Bool) -> g_ag451 a -> g_ag451 b -> Bool :: *)))
                 @ a_ag452 @ a_ag452 eq_sg4nU ww2_sg4PT ww5_sg4PY
          of {
            False -> GHC.Types.True;
            True -> GHC.Types.False
          }
      }
      }
      }

-- RHS size: {terms: 15, types: 28, coercions: 0, joins: 0/0}
Data.Functor.Product.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Eq1 f, Eq1 g, Eq a) =>
     Eq (Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,U(U,A)>m,
 Unf=DFun: \ (@ (f_ag3F5 :: * -> *))
             (@ (g_ag3F6 :: * -> *))
             (@ a_ag3F7)
             (v_B1 :: Eq1 f_ag3F5)
             (v1_B2 :: Eq1 g_ag3F6)
             (v2_B3 :: Eq a_ag3F7) ->
       GHC.Classes.C:Eq TYPE: Product f_ag3F5 g_ag3F6 a_ag3F7
                        Data.Functor.Product.$fEqProduct_$c==
                          @ f_ag3F5 @ g_ag3F6 @ a_ag3F7 v_B1 v1_B2 v2_B3
                        Data.Functor.Product.$fEqProduct_$c/=
                          @ f_ag3F5 @ g_ag3F6 @ a_ag3F7 v_B1 v1_B2 v2_B3]
Data.Functor.Product.$fEqProduct
  = \ (@ (f_ag450 :: * -> *))
      (@ (g_ag451 :: * -> *))
      (@ a_ag452)
      ($dEq1_ag453 :: Eq1 f_ag450)
      ($dEq2_ag454 :: Eq1 g_ag451)
      ($dEq_ag455 :: Eq a_ag452) ->
      GHC.Classes.C:Eq
        @ (Product f_ag450 g_ag451 a_ag452)
        (Data.Functor.Product.$fEqProduct_$c==
           @ f_ag450 @ g_ag451 @ a_ag452 $dEq1_ag453 $dEq2_ag454 $dEq_ag455)
        (Data.Functor.Product.$fEqProduct_$c/=
           @ f_ag450 @ g_ag451 @ a_ag452 $dEq1_ag453 $dEq2_ag454 $dEq_ag455)

-- RHS size: {terms: 33, types: 59, coercions: 0, joins: 0/1}
Data.Functor.Product.$fOrdProduct_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag44c :: * -> *))
                 (@ (g_ag44d :: * -> *))
                 (@ a_ag44e)
                 ($dOrd1_ag44f [Occ=Once] :: Ord1 f_ag44c)
                 ($dOrd2_ag44g [Occ=Once] :: Ord1 g_ag44d)
                 ($dOrd_ag44h [Occ=Once] :: Ord a_ag44e)
                 (eta_B2 [Occ=Once] :: Product f_ag44c g_ag44d a_ag44e)
                 (eta1_B1 [Occ=Once] :: Product f_ag44c g_ag44d a_ag44e) ->
                 Data.Functor.Product.$fOrd1Product_$cliftCompare
                   @ f_ag44c
                   @ g_ag44d
                   $dOrd1_ag44f
                   $dOrd2_ag44g
                   @ a_ag44e
                   @ a_ag44e
                   (compare @ a_ag44e $dOrd_ag44h)
                   eta_B2
                   eta1_B1}]
Data.Functor.Product.$fOrdProduct_$ccompare
  = \ (@ (f_ag44c :: * -> *))
      (@ (g_ag44d :: * -> *))
      (@ a_ag44e)
      ($dOrd1_ag44f :: Ord1 f_ag44c)
      ($dOrd2_ag44g :: Ord1 g_ag44d)
      ($dOrd_ag44h :: Ord a_ag44e)
      (eta_B2 :: Product f_ag44c g_ag44d a_ag44e)
      (eta1_B1 :: Product f_ag44c g_ag44d a_ag44e) ->
      case eta_B2 of { Pair ww1_sg4Ow ww2_sg4Ox ->
      case eta1_B1 of { Pair ww4_sg4OB ww5_sg4OC ->
      let {
        w_sg4Or :: a_ag44e -> a_ag44e -> Ordering
        [LclId]
        w_sg4Or = compare @ a_ag44e $dOrd_ag44h } in
      case liftCompare
             @ f_ag44c
             $dOrd1_ag44f
             @ a_ag44e
             @ a_ag44e
             w_sg4Or
             ww1_sg4Ow
             ww4_sg4OB
      of {
        LT -> GHC.Types.LT;
        EQ ->
          liftCompare
            @ g_ag44d
            $dOrd2_ag44g
            @ a_ag44e
            @ a_ag44e
            w_sg4Or
            ww2_sg4Ox
            ww5_sg4OC;
        GT -> GHC.Types.GT
      }
      }
      }

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrdProduct_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Eq (Product f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag44c :: * -> *))
                 (@ (g_ag44d :: * -> *))
                 (@ a_ag44e)
                 ($dOrd1_ag44f [Occ=Once] :: Ord1 f_ag44c)
                 ($dOrd2_ag44g [Occ=Once] :: Ord1 g_ag44d)
                 ($dOrd_ag44h [Occ=Once] :: Ord a_ag44e) ->
                 Data.Functor.Product.$fEqProduct
                   @ f_ag44c
                   @ g_ag44d
                   @ a_ag44e
                   (Data.Functor.Classes.$p1Ord1 @ f_ag44c $dOrd1_ag44f)
                   (Data.Functor.Classes.$p1Ord1 @ g_ag44d $dOrd2_ag44g)
                   (GHC.Classes.$p1Ord @ a_ag44e $dOrd_ag44h)}]
Data.Functor.Product.$fOrdProduct_$cp1Ord
  = \ (@ (f_ag44c :: * -> *))
      (@ (g_ag44d :: * -> *))
      (@ a_ag44e)
      ($dOrd1_ag44f :: Ord1 f_ag44c)
      ($dOrd2_ag44g :: Ord1 g_ag44d)
      ($dOrd_ag44h :: Ord a_ag44e) ->
      Data.Functor.Product.$fEqProduct
        @ f_ag44c
        @ g_ag44d
        @ a_ag44e
        (Data.Functor.Classes.$p1Ord1 @ f_ag44c $dOrd1_ag44f)
        (Data.Functor.Classes.$p1Ord1 @ g_ag44d $dOrd2_ag44g)
        (GHC.Classes.$p1Ord @ a_ag44e $dOrd_ag44h)

-- RHS size: {terms: 34, types: 36, coercions: 0, joins: 0/1}
Data.Functor.Product.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     f a -> g a -> f a -> g a -> Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0 0] 180 40}]
Data.Functor.Product.$w$c<
  = \ (@ (f_sg4Q1 :: * -> *))
      (@ (g_sg4Q2 :: * -> *))
      (@ a_sg4Q3)
      (w_sg4Q4 :: Ord1 f_sg4Q1)
      (w1_sg4Q5 :: Ord1 g_sg4Q2)
      (w2_sg4Q6 :: Ord a_sg4Q3)
      (ww_sg4Qb :: f_sg4Q1 a_sg4Q3)
      (ww1_sg4Qc :: g_sg4Q2 a_sg4Q3)
      (ww2_sg4Qg :: f_sg4Q1 a_sg4Q3)
      (ww3_sg4Qh :: g_sg4Q2 a_sg4Q3) ->
      let {
        comp_ag3Fl :: a_sg4Q3 -> a_sg4Q3 -> Ordering
        [LclId]
        comp_ag3Fl = compare @ a_sg4Q3 w2_sg4Q6 } in
      case liftCompare
             @ f_sg4Q1 w_sg4Q4 @ a_sg4Q3 @ a_sg4Q3 comp_ag3Fl ww_sg4Qb ww2_sg4Qg
      of {
        LT -> GHC.Types.True;
        EQ ->
          case liftCompare
                 @ g_sg4Q2
                 w1_sg4Q5
                 @ a_sg4Q3
                 @ a_sg4Q3
                 comp_ag3Fl
                 ww1_sg4Qc
                 ww3_sg4Qh
          of {
            __DEFAULT -> GHC.Types.False;
            LT -> GHC.Types.True
          };
        GT -> GHC.Types.False
      }

-- RHS size: {terms: 22, types: 51, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrdProduct_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Q1 :: * -> *))
                 (@ (g_sg4Q2 :: * -> *))
                 (@ a_sg4Q3)
                 (w_sg4Q4 [Occ=Once] :: Ord1 f_sg4Q1)
                 (w1_sg4Q5 [Occ=Once] :: Ord1 g_sg4Q2)
                 (w2_sg4Q6 [Occ=Once] :: Ord a_sg4Q3)
                 (w3_sg4Q7 [Occ=Once!] :: Product f_sg4Q1 g_sg4Q2 a_sg4Q3)
                 (w4_sg4Q8 [Occ=Once!] :: Product f_sg4Q1 g_sg4Q2 a_sg4Q3) ->
                 case w3_sg4Q7 of
                 { Pair ww1_sg4Qb [Occ=Once] ww2_sg4Qc [Occ=Once] ->
                 case w4_sg4Q8 of
                 { Pair ww4_sg4Qg [Occ=Once] ww5_sg4Qh [Occ=Once] ->
                 Data.Functor.Product.$w$c<
                   @ f_sg4Q1
                   @ g_sg4Q2
                   @ a_sg4Q3
                   w_sg4Q4
                   w1_sg4Q5
                   w2_sg4Q6
                   ww1_sg4Qb
                   ww2_sg4Qc
                   ww4_sg4Qg
                   ww5_sg4Qh
                 }
                 }}]
Data.Functor.Product.$fOrdProduct_$c<
  = \ (@ (f_sg4Q1 :: * -> *))
      (@ (g_sg4Q2 :: * -> *))
      (@ a_sg4Q3)
      (w_sg4Q4 :: Ord1 f_sg4Q1)
      (w1_sg4Q5 :: Ord1 g_sg4Q2)
      (w2_sg4Q6 :: Ord a_sg4Q3)
      (w3_sg4Q7 :: Product f_sg4Q1 g_sg4Q2 a_sg4Q3)
      (w4_sg4Q8 :: Product f_sg4Q1 g_sg4Q2 a_sg4Q3) ->
      case w3_sg4Q7 of { Pair ww1_sg4Qb ww2_sg4Qc ->
      case w4_sg4Q8 of { Pair ww4_sg4Qg ww5_sg4Qh ->
      Data.Functor.Product.$w$c<
        @ f_sg4Q1
        @ g_sg4Q2
        @ a_sg4Q3
        w_sg4Q4
        w1_sg4Q5
        w2_sg4Q6
        ww1_sg4Qb
        ww2_sg4Qc
        ww4_sg4Qg
        ww5_sg4Qh
      }
      }

-- RHS size: {terms: 34, types: 36, coercions: 0, joins: 0/1}
Data.Functor.Product.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     f a -> g a -> f a -> g a -> Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0 0] 180 40}]
Data.Functor.Product.$w$c>=
  = \ (@ (f_sg4Qk :: * -> *))
      (@ (g_sg4Ql :: * -> *))
      (@ a_sg4Qm)
      (w_sg4Qn :: Ord1 f_sg4Qk)
      (w1_sg4Qo :: Ord1 g_sg4Ql)
      (w2_sg4Qp :: Ord a_sg4Qm)
      (ww_sg4Qu :: f_sg4Qk a_sg4Qm)
      (ww1_sg4Qv :: g_sg4Ql a_sg4Qm)
      (ww2_sg4Qz :: f_sg4Qk a_sg4Qm)
      (ww3_sg4QA :: g_sg4Ql a_sg4Qm) ->
      let {
        comp_ag3Fl :: a_sg4Qm -> a_sg4Qm -> Ordering
        [LclId]
        comp_ag3Fl = compare @ a_sg4Qm w2_sg4Qp } in
      case liftCompare
             @ f_sg4Qk w_sg4Qn @ a_sg4Qm @ a_sg4Qm comp_ag3Fl ww_sg4Qu ww2_sg4Qz
      of {
        LT -> GHC.Types.False;
        EQ ->
          case liftCompare
                 @ g_sg4Ql
                 w1_sg4Qo
                 @ a_sg4Qm
                 @ a_sg4Qm
                 comp_ag3Fl
                 ww1_sg4Qv
                 ww3_sg4QA
          of {
            __DEFAULT -> GHC.Types.True;
            LT -> GHC.Types.False
          };
        GT -> GHC.Types.True
      }

-- RHS size: {terms: 22, types: 51, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrdProduct_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Qk :: * -> *))
                 (@ (g_sg4Ql :: * -> *))
                 (@ a_sg4Qm)
                 (w_sg4Qn [Occ=Once] :: Ord1 f_sg4Qk)
                 (w1_sg4Qo [Occ=Once] :: Ord1 g_sg4Ql)
                 (w2_sg4Qp [Occ=Once] :: Ord a_sg4Qm)
                 (w3_sg4Qq [Occ=Once!] :: Product f_sg4Qk g_sg4Ql a_sg4Qm)
                 (w4_sg4Qr [Occ=Once!] :: Product f_sg4Qk g_sg4Ql a_sg4Qm) ->
                 case w3_sg4Qq of
                 { Pair ww1_sg4Qu [Occ=Once] ww2_sg4Qv [Occ=Once] ->
                 case w4_sg4Qr of
                 { Pair ww4_sg4Qz [Occ=Once] ww5_sg4QA [Occ=Once] ->
                 Data.Functor.Product.$w$c>=
                   @ f_sg4Qk
                   @ g_sg4Ql
                   @ a_sg4Qm
                   w_sg4Qn
                   w1_sg4Qo
                   w2_sg4Qp
                   ww1_sg4Qu
                   ww2_sg4Qv
                   ww4_sg4Qz
                   ww5_sg4QA
                 }
                 }}]
Data.Functor.Product.$fOrdProduct_$c>=
  = \ (@ (f_sg4Qk :: * -> *))
      (@ (g_sg4Ql :: * -> *))
      (@ a_sg4Qm)
      (w_sg4Qn :: Ord1 f_sg4Qk)
      (w1_sg4Qo :: Ord1 g_sg4Ql)
      (w2_sg4Qp :: Ord a_sg4Qm)
      (w3_sg4Qq :: Product f_sg4Qk g_sg4Ql a_sg4Qm)
      (w4_sg4Qr :: Product f_sg4Qk g_sg4Ql a_sg4Qm) ->
      case w3_sg4Qq of { Pair ww1_sg4Qu ww2_sg4Qv ->
      case w4_sg4Qr of { Pair ww4_sg4Qz ww5_sg4QA ->
      Data.Functor.Product.$w$c>=
        @ f_sg4Qk
        @ g_sg4Ql
        @ a_sg4Qm
        w_sg4Qn
        w1_sg4Qo
        w2_sg4Qp
        ww1_sg4Qu
        ww2_sg4Qv
        ww4_sg4Qz
        ww5_sg4QA
      }
      }

-- RHS size: {terms: 34, types: 36, coercions: 0, joins: 0/1}
Data.Functor.Product.$w$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     f a -> g a -> f a -> g a -> Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0 0] 180 40}]
Data.Functor.Product.$w$c>
  = \ (@ (f_sg4QD :: * -> *))
      (@ (g_sg4QE :: * -> *))
      (@ a_sg4QF)
      (w_sg4QG :: Ord1 f_sg4QD)
      (w1_sg4QH :: Ord1 g_sg4QE)
      (w2_sg4QI :: Ord a_sg4QF)
      (ww_sg4QN :: f_sg4QD a_sg4QF)
      (ww1_sg4QO :: g_sg4QE a_sg4QF)
      (ww2_sg4QS :: f_sg4QD a_sg4QF)
      (ww3_sg4QT :: g_sg4QE a_sg4QF) ->
      let {
        comp_ag3Fl :: a_sg4QF -> a_sg4QF -> Ordering
        [LclId]
        comp_ag3Fl = compare @ a_sg4QF w2_sg4QI } in
      case liftCompare
             @ f_sg4QD w_sg4QG @ a_sg4QF @ a_sg4QF comp_ag3Fl ww_sg4QN ww2_sg4QS
      of {
        LT -> GHC.Types.False;
        EQ ->
          case liftCompare
                 @ g_sg4QE
                 w1_sg4QH
                 @ a_sg4QF
                 @ a_sg4QF
                 comp_ag3Fl
                 ww1_sg4QO
                 ww3_sg4QT
          of {
            __DEFAULT -> GHC.Types.False;
            GT -> GHC.Types.True
          };
        GT -> GHC.Types.True
      }

-- RHS size: {terms: 22, types: 51, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrdProduct_$c> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4QD :: * -> *))
                 (@ (g_sg4QE :: * -> *))
                 (@ a_sg4QF)
                 (w_sg4QG [Occ=Once] :: Ord1 f_sg4QD)
                 (w1_sg4QH [Occ=Once] :: Ord1 g_sg4QE)
                 (w2_sg4QI [Occ=Once] :: Ord a_sg4QF)
                 (w3_sg4QJ [Occ=Once!] :: Product f_sg4QD g_sg4QE a_sg4QF)
                 (w4_sg4QK [Occ=Once!] :: Product f_sg4QD g_sg4QE a_sg4QF) ->
                 case w3_sg4QJ of
                 { Pair ww1_sg4QN [Occ=Once] ww2_sg4QO [Occ=Once] ->
                 case w4_sg4QK of
                 { Pair ww4_sg4QS [Occ=Once] ww5_sg4QT [Occ=Once] ->
                 Data.Functor.Product.$w$c>
                   @ f_sg4QD
                   @ g_sg4QE
                   @ a_sg4QF
                   w_sg4QG
                   w1_sg4QH
                   w2_sg4QI
                   ww1_sg4QN
                   ww2_sg4QO
                   ww4_sg4QS
                   ww5_sg4QT
                 }
                 }}]
Data.Functor.Product.$fOrdProduct_$c>
  = \ (@ (f_sg4QD :: * -> *))
      (@ (g_sg4QE :: * -> *))
      (@ a_sg4QF)
      (w_sg4QG :: Ord1 f_sg4QD)
      (w1_sg4QH :: Ord1 g_sg4QE)
      (w2_sg4QI :: Ord a_sg4QF)
      (w3_sg4QJ :: Product f_sg4QD g_sg4QE a_sg4QF)
      (w4_sg4QK :: Product f_sg4QD g_sg4QE a_sg4QF) ->
      case w3_sg4QJ of { Pair ww1_sg4QN ww2_sg4QO ->
      case w4_sg4QK of { Pair ww4_sg4QS ww5_sg4QT ->
      Data.Functor.Product.$w$c>
        @ f_sg4QD
        @ g_sg4QE
        @ a_sg4QF
        w_sg4QG
        w1_sg4QH
        w2_sg4QI
        ww1_sg4QN
        ww2_sg4QO
        ww4_sg4QS
        ww5_sg4QT
      }
      }

-- RHS size: {terms: 34, types: 36, coercions: 0, joins: 0/1}
Data.Functor.Product.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     f a -> g a -> f a -> g a -> Bool
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0 0] 180 40}]
Data.Functor.Product.$w$c<=
  = \ (@ (f_sg4QW :: * -> *))
      (@ (g_sg4QX :: * -> *))
      (@ a_sg4QY)
      (w_sg4QZ :: Ord1 f_sg4QW)
      (w1_sg4R0 :: Ord1 g_sg4QX)
      (w2_sg4R1 :: Ord a_sg4QY)
      (ww_sg4R6 :: f_sg4QW a_sg4QY)
      (ww1_sg4R7 :: g_sg4QX a_sg4QY)
      (ww2_sg4Rb :: f_sg4QW a_sg4QY)
      (ww3_sg4Rc :: g_sg4QX a_sg4QY) ->
      let {
        comp_ag3Fl :: a_sg4QY -> a_sg4QY -> Ordering
        [LclId]
        comp_ag3Fl = compare @ a_sg4QY w2_sg4R1 } in
      case liftCompare
             @ f_sg4QW w_sg4QZ @ a_sg4QY @ a_sg4QY comp_ag3Fl ww_sg4R6 ww2_sg4Rb
      of {
        LT -> GHC.Types.True;
        EQ ->
          case liftCompare
                 @ g_sg4QX
                 w1_sg4R0
                 @ a_sg4QY
                 @ a_sg4QY
                 comp_ag3Fl
                 ww1_sg4R7
                 ww3_sg4Rc
          of {
            __DEFAULT -> GHC.Types.True;
            GT -> GHC.Types.False
          };
        GT -> GHC.Types.False
      }

-- RHS size: {terms: 22, types: 51, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrdProduct_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4QW :: * -> *))
                 (@ (g_sg4QX :: * -> *))
                 (@ a_sg4QY)
                 (w_sg4QZ [Occ=Once] :: Ord1 f_sg4QW)
                 (w1_sg4R0 [Occ=Once] :: Ord1 g_sg4QX)
                 (w2_sg4R1 [Occ=Once] :: Ord a_sg4QY)
                 (w3_sg4R2 [Occ=Once!] :: Product f_sg4QW g_sg4QX a_sg4QY)
                 (w4_sg4R3 [Occ=Once!] :: Product f_sg4QW g_sg4QX a_sg4QY) ->
                 case w3_sg4R2 of
                 { Pair ww1_sg4R6 [Occ=Once] ww2_sg4R7 [Occ=Once] ->
                 case w4_sg4R3 of
                 { Pair ww4_sg4Rb [Occ=Once] ww5_sg4Rc [Occ=Once] ->
                 Data.Functor.Product.$w$c<=
                   @ f_sg4QW
                   @ g_sg4QX
                   @ a_sg4QY
                   w_sg4QZ
                   w1_sg4R0
                   w2_sg4R1
                   ww1_sg4R6
                   ww2_sg4R7
                   ww4_sg4Rb
                   ww5_sg4Rc
                 }
                 }}]
Data.Functor.Product.$fOrdProduct_$c<=
  = \ (@ (f_sg4QW :: * -> *))
      (@ (g_sg4QX :: * -> *))
      (@ a_sg4QY)
      (w_sg4QZ :: Ord1 f_sg4QW)
      (w1_sg4R0 :: Ord1 g_sg4QX)
      (w2_sg4R1 :: Ord a_sg4QY)
      (w3_sg4R2 :: Product f_sg4QW g_sg4QX a_sg4QY)
      (w4_sg4R3 :: Product f_sg4QW g_sg4QX a_sg4QY) ->
      case w3_sg4R2 of { Pair ww1_sg4R6 ww2_sg4R7 ->
      case w4_sg4R3 of { Pair ww4_sg4Rb ww5_sg4Rc ->
      Data.Functor.Product.$w$c<=
        @ f_sg4QW
        @ g_sg4QX
        @ a_sg4QY
        w_sg4QZ
        w1_sg4R0
        w2_sg4R1
        ww1_sg4R6
        ww2_sg4R7
        ww4_sg4Rb
        ww5_sg4Rc
      }
      }

-- RHS size: {terms: 38, types: 60, coercions: 0, joins: 0/1}
Data.Functor.Product.$fOrdProduct_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag44c :: * -> *))
                 (@ (g_ag44d :: * -> *))
                 (@ a_ag44e)
                 ($dOrd1_ag44f [Occ=Once] :: Ord1 f_ag44c)
                 ($dOrd2_ag44g [Occ=Once] :: Ord1 g_ag44d)
                 ($dOrd_ag44h [Occ=Once] :: Ord a_ag44e)
                 (x_a55d :: Product f_ag44c g_ag44d a_ag44e)
                 (y_a55e :: Product f_ag44c g_ag44d a_ag44e) ->
                 case Data.Functor.Product.$fOrdProduct_$c<=
                        @ f_ag44c
                        @ g_ag44d
                        @ a_ag44e
                        $dOrd1_ag44f
                        $dOrd2_ag44g
                        $dOrd_ag44h
                        x_a55d
                        y_a55e
                 of {
                   False -> x_a55d;
                   True -> y_a55e
                 }}]
Data.Functor.Product.$fOrdProduct_$cmax
  = \ (@ (f_ag44c :: * -> *))
      (@ (g_ag44d :: * -> *))
      (@ a_ag44e)
      ($dOrd1_ag44f :: Ord1 f_ag44c)
      ($dOrd2_ag44g :: Ord1 g_ag44d)
      ($dOrd_ag44h :: Ord a_ag44e)
      (x_a55d :: Product f_ag44c g_ag44d a_ag44e)
      (y_a55e :: Product f_ag44c g_ag44d a_ag44e) ->
      case x_a55d of ww_sg4R5 { Pair ww1_sg4R6 ww2_sg4R7 ->
      case y_a55e of ww3_sg4Ra { Pair ww4_sg4Rb ww5_sg4Rc ->
      let {
        comp_ag3Fl :: a_ag44e -> a_ag44e -> Ordering
        [LclId]
        comp_ag3Fl = compare @ a_ag44e $dOrd_ag44h } in
      case liftCompare
             @ f_ag44c
             $dOrd1_ag44f
             @ a_ag44e
             @ a_ag44e
             comp_ag3Fl
             ww1_sg4R6
             ww4_sg4Rb
      of {
        LT -> ww3_sg4Ra;
        EQ ->
          case liftCompare
                 @ g_ag44d
                 $dOrd2_ag44g
                 @ a_ag44e
                 @ a_ag44e
                 comp_ag3Fl
                 ww2_sg4R7
                 ww5_sg4Rc
          of {
            __DEFAULT -> ww3_sg4Ra;
            GT -> ww_sg4R5
          };
        GT -> ww_sg4R5
      }
      }
      }

-- RHS size: {terms: 38, types: 60, coercions: 0, joins: 0/1}
Data.Functor.Product.$fOrdProduct_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Product f g a -> Product f g a -> Product f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*U,A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag44c :: * -> *))
                 (@ (g_ag44d :: * -> *))
                 (@ a_ag44e)
                 ($dOrd1_ag44f [Occ=Once] :: Ord1 f_ag44c)
                 ($dOrd2_ag44g [Occ=Once] :: Ord1 g_ag44d)
                 ($dOrd_ag44h [Occ=Once] :: Ord a_ag44e)
                 (x_a55m :: Product f_ag44c g_ag44d a_ag44e)
                 (y_a55n :: Product f_ag44c g_ag44d a_ag44e) ->
                 case Data.Functor.Product.$fOrdProduct_$c<=
                        @ f_ag44c
                        @ g_ag44d
                        @ a_ag44e
                        $dOrd1_ag44f
                        $dOrd2_ag44g
                        $dOrd_ag44h
                        x_a55m
                        y_a55n
                 of {
                   False -> y_a55n;
                   True -> x_a55m
                 }}]
Data.Functor.Product.$fOrdProduct_$cmin
  = \ (@ (f_ag44c :: * -> *))
      (@ (g_ag44d :: * -> *))
      (@ a_ag44e)
      ($dOrd1_ag44f :: Ord1 f_ag44c)
      ($dOrd2_ag44g :: Ord1 g_ag44d)
      ($dOrd_ag44h :: Ord a_ag44e)
      (x_a55m :: Product f_ag44c g_ag44d a_ag44e)
      (y_a55n :: Product f_ag44c g_ag44d a_ag44e) ->
      case x_a55m of ww_sg4R5 { Pair ww1_sg4R6 ww2_sg4R7 ->
      case y_a55n of ww3_sg4Ra { Pair ww4_sg4Rb ww5_sg4Rc ->
      let {
        comp_ag3Fl :: a_ag44e -> a_ag44e -> Ordering
        [LclId]
        comp_ag3Fl = compare @ a_ag44e $dOrd_ag44h } in
      case liftCompare
             @ f_ag44c
             $dOrd1_ag44f
             @ a_ag44e
             @ a_ag44e
             comp_ag3Fl
             ww1_sg4R6
             ww4_sg4Rb
      of {
        LT -> ww_sg4R5;
        EQ ->
          case liftCompare
                 @ g_ag44d
                 $dOrd2_ag44g
                 @ a_ag44e
                 @ a_ag44e
                 comp_ag3Fl
                 ww2_sg4R7
                 ww5_sg4Rc
          of {
            __DEFAULT -> ww_sg4R5;
            GT -> ww3_sg4Ra
          };
        GT -> ww3_sg4Ra
      }
      }
      }

-- RHS size: {terms: 39, types: 46, coercions: 0, joins: 0/0}
Data.Functor.Product.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Ord1 f, Ord1 g, Ord a) =>
     Ord (Product f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ (f_ag3F2 :: * -> *))
             (@ (g_ag3F3 :: * -> *))
             (@ a_ag3F4)
             (v_B1 :: Ord1 f_ag3F2)
             (v1_B2 :: Ord1 g_ag3F3)
             (v2_B3 :: Ord a_ag3F4) ->
       GHC.Classes.C:Ord TYPE: Product f_ag3F2 g_ag3F3 a_ag3F4
                         Data.Functor.Product.$fOrdProduct_$cp1Ord
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$ccompare
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$c<
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$c<=
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$c>
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$c>=
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$cmax
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3
                         Data.Functor.Product.$fOrdProduct_$cmin
                           @ f_ag3F2 @ g_ag3F3 @ a_ag3F4 v_B1 v1_B2 v2_B3]
Data.Functor.Product.$fOrdProduct
  = \ (@ (f_ag44c :: * -> *))
      (@ (g_ag44d :: * -> *))
      (@ a_ag44e)
      ($dOrd1_ag44f :: Ord1 f_ag44c)
      ($dOrd2_ag44g :: Ord1 g_ag44d)
      ($dOrd_ag44h :: Ord a_ag44e) ->
      GHC.Classes.C:Ord
        @ (Product f_ag44c g_ag44d a_ag44e)
        (Data.Functor.Product.$fOrdProduct_$cp1Ord
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$ccompare
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$c<
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$c<=
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$c>
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$c>=
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$cmax
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)
        (Data.Functor.Product.$fOrdProduct_$cmin
           @ f_ag44c
           @ g_ag44d
           @ a_ag44e
           $dOrd1_ag44f
           $dOrd2_ag44g
           $dOrd_ag44h)

-- RHS size: {terms: 13, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Product.$fReadProduct_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Read1 f, Read1 g, Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag43F :: * -> *))
                 (@ (g_ag43G :: * -> *))
                 (@ a_ag43H)
                 ($dRead1_ag43I [Occ=Once] :: Read1 f_ag43F)
                 ($dRead2_ag43J [Occ=Once] :: Read1 g_ag43G)
                 ($dRead_ag43K :: Read a_ag43H) ->
                 Data.Functor.Product.$fRead1Product_$cliftReadPrec
                   @ f_ag43F
                   @ g_ag43G
                   $dRead1_ag43I
                   $dRead2_ag43J
                   @ a_ag43H
                   (readPrec @ a_ag43H $dRead_ag43K)
                   (readListPrec @ a_ag43H $dRead_ag43K)}]
Data.Functor.Product.$fReadProduct_$creadPrec
  = \ (@ (f_ag43F :: * -> *))
      (@ (g_ag43G :: * -> *))
      (@ a_ag43H)
      ($dRead1_ag43I :: Read1 f_ag43F)
      ($dRead2_ag43J :: Read1 g_ag43G)
      ($dRead_ag43K :: Read a_ag43H) ->
      Data.Functor.Product.$fRead1Product_$cliftReadPrec
        @ f_ag43F
        @ g_ag43G
        $dRead1_ag43I
        $dRead2_ag43J
        @ a_ag43H
        (readPrec @ a_ag43H $dRead_ag43K)
        (readListPrec @ a_ag43H $dRead_ag43K)

-- RHS size: {terms: 19, types: 47, coercions: 14, joins: 0/1}
Data.Functor.Product.$fReadProduct_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Read1 f, Read1 g, Read a) =>
     Int -> ReadS (Product f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 60] 160 60}]
Data.Functor.Product.$fReadProduct_$creadsPrec
  = \ (@ (f_ag43F :: * -> *))
      (@ (g_ag43G :: * -> *))
      (@ a_ag43H)
      ($dRead1_ag43I :: Read1 f_ag43F)
      ($dRead2_ag43J :: Read1 g_ag43G)
      ($dRead_ag43K :: Read a_ag43H) ->
      let {
        ds_sg4nS [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.ReadPrec
               (Product f_ag43F g_ag43G a_ag43H)
        [LclId]
        ds_sg4nS
          = Data.Functor.Product.$fRead1Product_$cliftReadPrec
              @ f_ag43F
              @ g_ag43G
              $dRead1_ag43I
              $dRead2_ag43J
              @ a_ag43H
              (readPrec @ a_ag43H $dRead_ag43K)
              (readListPrec @ a_ag43H $dRead_ag43K) } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (Product f_ag43F g_ag43G a_ag43H)
          ((((ds_sg4nS
              `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Product f_ag43F g_ag43G a_ag43H>_R
                      :: (Text.ParserCombinators.ReadPrec.ReadPrec
                            (Product f_ag43F g_ag43G a_ag43H) :: *)
                         ~R# (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP
                                   (Product f_ag43F g_ag43G a_ag43H) :: *)))
               n_i8156)
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                        <Product f_ag43F g_ag43G a_ag43H>_R
                    :: (Text.ParserCombinators.ReadP.ReadP
                          (Product f_ag43F g_ag43G a_ag43H) :: *)
                       ~R# (forall b.
                            (Product f_ag43F g_ag43G a_ag43H
                             -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b :: *)))
             @ (Product f_ag43F g_ag43G a_ag43H)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (Product f_ag43F g_ag43G a_ag43H)))

-- RHS size: {terms: 14, types: 27, coercions: 0, joins: 0/0}
Data.Functor.Product.$fReadProduct_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Read1 f, Read1 g, Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 60] 110 0}]
Data.Functor.Product.$fReadProduct_$creadListPrec
  = \ (@ (f_ag43F :: * -> *))
      (@ (g_ag43G :: * -> *))
      (@ a_ag43H)
      ($dRead1_ag43I :: Read1 f_ag43F)
      ($dRead2_ag43J :: Read1 g_ag43G)
      ($dRead_ag43K :: Read a_ag43H) ->
      GHC.Read.list
        @ (Product f_ag43F g_ag43G a_ag43H)
        (Data.Functor.Product.$fRead1Product_$cliftReadPrec
           @ f_ag43F
           @ g_ag43G
           $dRead1_ag43I
           $dRead2_ag43J
           @ a_ag43H
           (readPrec @ a_ag43H $dRead_ag43K)
           (readListPrec @ a_ag43H $dRead_ag43K))

-- RHS size: {terms: 13, types: 40, coercions: 16, joins: 0/0}
Data.Functor.Product.$fReadProduct_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Read1 f, Read1 g, Read a) =>
     ReadS [Product f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag43F :: * -> *))
                 (@ (g_ag43G :: * -> *))
                 (@ a_ag43H)
                 ($dRead1_ag43I [Occ=Once] :: Read1 f_ag43F)
                 ($dRead2_ag43J [Occ=Once] :: Read1 g_ag43G)
                 ($dRead_ag43K [Occ=Once] :: Read a_ag43H) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Product f_ag43F g_ag43G a_ag43H]
                   (((((Data.Functor.Product.$fReadProduct_$creadListPrec
                          @ f_ag43F
                          @ g_ag43G
                          @ a_ag43H
                          $dRead1_ag43I
                          $dRead2_ag43J
                          $dRead_ag43K)
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Product f_ag43F g_ag43G a_ag43H]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [Product f_ag43F g_ag43G a_ag43H] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [Product f_ag43F g_ag43G a_ag43H] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[Product f_ag43F g_ag43G a_ag43H]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP
                                   [Product f_ag43F g_ag43G a_ag43H] :: *)
                                ~R# (forall b.
                                     ([Product f_ag43F g_ag43G a_ag43H]
                                      -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Product f_ag43F g_ag43G a_ag43H]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Product f_ag43F g_ag43G a_ag43H]))}]
Data.Functor.Product.$fReadProduct_$creadList
  = \ (@ (f_ag43F :: * -> *))
      (@ (g_ag43G :: * -> *))
      (@ a_ag43H)
      ($dRead1_ag43I :: Read1 f_ag43F)
      ($dRead2_ag43J :: Read1 g_ag43G)
      ($dRead_ag43K :: Read a_ag43H) ->
      Text.ParserCombinators.ReadP.run
        @ [Product f_ag43F g_ag43G a_ag43H]
        (((((Data.Functor.Product.$fReadProduct_$creadListPrec
               @ f_ag43F
               @ g_ag43G
               @ a_ag43H
               $dRead1_ag43I
               $dRead2_ag43J
               $dRead_ag43K)
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Product f_ag43F g_ag43G a_ag43H]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [Product f_ag43F g_ag43G a_ag43H] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP
                                 [Product f_ag43F g_ag43G a_ag43H] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Product f_ag43F g_ag43G a_ag43H]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP
                        [Product f_ag43F g_ag43G a_ag43H] :: *)
                     ~R# (forall b.
                          ([Product f_ag43F g_ag43G a_ag43H]
                           -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Product f_ag43F g_ag43G a_ag43H]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Product f_ag43F g_ag43G a_ag43H]))

-- RHS size: {terms: 23, types: 34, coercions: 0, joins: 0/0}
Data.Functor.Product.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Read1 f, Read1 g, Read a) =>
     Read (Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,U,U)>m,
 Unf=DFun: \ (@ (f_ag3EZ :: * -> *))
             (@ (g_ag3F0 :: * -> *))
             (@ a_ag3F1)
             (v_B1 :: Read1 f_ag3EZ)
             (v1_B2 :: Read1 g_ag3F0)
             (v2_B3 :: Read a_ag3F1) ->
       GHC.Read.C:Read TYPE: Product f_ag3EZ g_ag3F0 a_ag3F1
                       Data.Functor.Product.$fReadProduct_$creadsPrec
                         @ f_ag3EZ @ g_ag3F0 @ a_ag3F1 v_B1 v1_B2 v2_B3
                       Data.Functor.Product.$fReadProduct_$creadList
                         @ f_ag3EZ @ g_ag3F0 @ a_ag3F1 v_B1 v1_B2 v2_B3
                       Data.Functor.Product.$fReadProduct_$creadPrec
                         @ f_ag3EZ @ g_ag3F0 @ a_ag3F1 v_B1 v1_B2 v2_B3
                       Data.Functor.Product.$fReadProduct_$creadListPrec
                         @ f_ag3EZ @ g_ag3F0 @ a_ag3F1 v_B1 v1_B2 v2_B3]
Data.Functor.Product.$fReadProduct
  = \ (@ (f_ag43F :: * -> *))
      (@ (g_ag43G :: * -> *))
      (@ a_ag43H)
      ($dRead1_ag43I :: Read1 f_ag43F)
      ($dRead2_ag43J :: Read1 g_ag43G)
      ($dRead_ag43K :: Read a_ag43H) ->
      GHC.Read.C:Read
        @ (Product f_ag43F g_ag43G a_ag43H)
        (Data.Functor.Product.$fReadProduct_$creadsPrec
           @ f_ag43F
           @ g_ag43G
           @ a_ag43H
           $dRead1_ag43I
           $dRead2_ag43J
           $dRead_ag43K)
        (Data.Functor.Product.$fReadProduct_$creadList
           @ f_ag43F
           @ g_ag43G
           @ a_ag43H
           $dRead1_ag43I
           $dRead2_ag43J
           $dRead_ag43K)
        (Data.Functor.Product.$fReadProduct_$creadPrec
           @ f_ag43F
           @ g_ag43G
           @ a_ag43H
           $dRead1_ag43I
           $dRead2_ag43J
           $dRead_ag43K)
        (Data.Functor.Product.$fReadProduct_$creadListPrec
           @ f_ag43F
           @ g_ag43G
           @ a_ag43H
           $dRead1_ag43I
           $dRead2_ag43J
           $dRead_ag43K)

-- RHS size: {terms: 28, types: 37, coercions: 0, joins: 0/2}
Data.Functor.Product.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     GHC.Prim.Int# -> f a -> g a -> ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 210 0}]
Data.Functor.Product.$w$cshowsPrec
  = \ (@ (f_sg4Rr :: * -> *))
      (@ (g_sg4Rs :: * -> *))
      (@ a_sg4Rt)
      (w_sg4Ru :: Show1 f_sg4Rr)
      (w1_sg4Rv :: Show1 g_sg4Rs)
      (w2_sg4Rw :: Show a_sg4Rt)
      (ww_sg4RB :: GHC.Prim.Int#)
      (ww1_sg4RF :: f_sg4Rr a_sg4Rt)
      (ww2_sg4RG :: g_sg4Rs a_sg4Rt) ->
      let {
        sp_ag3Fa :: Int -> a_sg4Rt -> ShowS
        [LclId]
        sp_ag3Fa = showsPrec @ a_sg4Rt w2_sg4Rw } in
      let {
        sl_ag3Fb :: [a_sg4Rt] -> ShowS
        [LclId]
        sl_ag3Fb = showList @ a_sg4Rt w2_sg4Rw } in
      Data.Functor.Classes.$wshowsBinaryWith
        @ (f_sg4Rr a_sg4Rt)
        @ (g_sg4Rs a_sg4Rt)
        (liftShowsPrec @ f_sg4Rr w_sg4Ru @ a_sg4Rt sp_ag3Fa sl_ag3Fb)
        (liftShowsPrec @ g_sg4Rs w1_sg4Rv @ a_sg4Rt sp_ag3Fa sl_ag3Fb)
        Data.Functor.Product.$fRead1Product2
        ww_sg4RB
        ww1_sg4RF
        ww2_sg4RG

-- RHS size: {terms: 21, types: 38, coercions: 0, joins: 0/0}
Data.Functor.Product.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     Int -> Product f g a -> ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Rr :: * -> *))
                 (@ (g_sg4Rs :: * -> *))
                 (@ a_sg4Rt)
                 (w_sg4Ru [Occ=Once] :: Show1 f_sg4Rr)
                 (w1_sg4Rv [Occ=Once] :: Show1 g_sg4Rs)
                 (w2_sg4Rw [Occ=Once] :: Show a_sg4Rt)
                 (w3_sg4Rx [Occ=Once!] :: Int)
                 (w4_sg4Ry [Occ=Once!] :: Product f_sg4Rr g_sg4Rs a_sg4Rt) ->
                 case w3_sg4Rx of { GHC.Types.I# ww1_sg4RB [Occ=Once] ->
                 case w4_sg4Ry of
                 { Pair ww3_sg4RF [Occ=Once] ww4_sg4RG [Occ=Once] ->
                 Data.Functor.Product.$w$cshowsPrec
                   @ f_sg4Rr
                   @ g_sg4Rs
                   @ a_sg4Rt
                   w_sg4Ru
                   w1_sg4Rv
                   w2_sg4Rw
                   ww1_sg4RB
                   ww3_sg4RF
                   ww4_sg4RG
                 }
                 }}]
Data.Functor.Product.$fShowProduct_$cshowsPrec
  = \ (@ (f_sg4Rr :: * -> *))
      (@ (g_sg4Rs :: * -> *))
      (@ a_sg4Rt)
      (w_sg4Ru :: Show1 f_sg4Rr)
      (w1_sg4Rv :: Show1 g_sg4Rs)
      (w2_sg4Rw :: Show a_sg4Rt)
      (w3_sg4Rx :: Int)
      (w4_sg4Ry :: Product f_sg4Rr g_sg4Rs a_sg4Rt) ->
      case w3_sg4Rx of { GHC.Types.I# ww1_sg4RB ->
      case w4_sg4Ry of { Pair ww3_sg4RF ww4_sg4RG ->
      Data.Functor.Product.$w$cshowsPrec
        @ f_sg4Rr
        @ g_sg4Rs
        @ a_sg4Rt
        w_sg4Ru
        w1_sg4Rv
        w2_sg4Rw
        ww1_sg4RB
        ww3_sg4RF
        ww4_sg4RG
      }
      }

-- RHS size: {terms: 33, types: 36, coercions: 0, joins: 0/2}
Data.Functor.Product.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     f a -> g a -> String
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*U,A,1*U)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 250 0}]
Data.Functor.Product.$w$cshow
  = \ (@ (f_sg4RJ :: * -> *))
      (@ (g_sg4RK :: * -> *))
      (@ a_sg4RL)
      (w_sg4RM :: Show1 f_sg4RJ)
      (w1_sg4RN :: Show1 g_sg4RK)
      (w2_sg4RO :: Show a_sg4RL)
      (ww_sg4RS :: f_sg4RJ a_sg4RL)
      (ww1_sg4RT :: g_sg4RK a_sg4RL) ->
      let {
        sp_ag3Fa :: Int -> a_sg4RL -> ShowS
        [LclId]
        sp_ag3Fa = showsPrec @ a_sg4RL w2_sg4RO } in
      let {
        sl_ag3Fb :: [a_sg4RL] -> ShowS
        [LclId]
        sl_ag3Fb = showList @ a_sg4RL w2_sg4RO } in
      ++
        @ Char
        Data.Functor.Product.$fRead1Product2
        (GHC.Types.:
           @ Char
           Data.Functor.Classes.showsUnaryWith1
           (liftShowsPrec
              @ f_sg4RJ
              w_sg4RM
              @ a_sg4RL
              sp_ag3Fa
              sl_ag3Fb
              Data.Functor.Classes.$fRead1Const1
              ww_sg4RS
              (GHC.Types.:
                 @ Char
                 Data.Functor.Classes.showsUnaryWith1
                 (liftShowsPrec
                    @ g_sg4RK
                    w1_sg4RN
                    @ a_sg4RL
                    sp_ag3Fa
                    sl_ag3Fb
                    Data.Functor.Classes.$fRead1Const1
                    ww1_sg4RT
                    (GHC.Types.[] @ Char)))))

-- RHS size: {terms: 16, types: 35, coercions: 0, joins: 0/0}
Data.Functor.Product.$fShowProduct_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     Product f g a -> String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(U,A,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4RJ :: * -> *))
                 (@ (g_sg4RK :: * -> *))
                 (@ a_sg4RL)
                 (w_sg4RM [Occ=Once] :: Show1 f_sg4RJ)
                 (w1_sg4RN [Occ=Once] :: Show1 g_sg4RK)
                 (w2_sg4RO [Occ=Once] :: Show a_sg4RL)
                 (w3_sg4RP [Occ=Once!] :: Product f_sg4RJ g_sg4RK a_sg4RL) ->
                 case w3_sg4RP of
                 { Pair ww1_sg4RS [Occ=Once] ww2_sg4RT [Occ=Once] ->
                 Data.Functor.Product.$w$cshow
                   @ f_sg4RJ
                   @ g_sg4RK
                   @ a_sg4RL
                   w_sg4RM
                   w1_sg4RN
                   w2_sg4RO
                   ww1_sg4RS
                   ww2_sg4RT
                 }}]
Data.Functor.Product.$fShowProduct_$cshow
  = \ (@ (f_sg4RJ :: * -> *))
      (@ (g_sg4RK :: * -> *))
      (@ a_sg4RL)
      (w_sg4RM :: Show1 f_sg4RJ)
      (w1_sg4RN :: Show1 g_sg4RK)
      (w2_sg4RO :: Show a_sg4RL)
      (w3_sg4RP :: Product f_sg4RJ g_sg4RK a_sg4RL) ->
      case w3_sg4RP of { Pair ww1_sg4RS ww2_sg4RT ->
      Data.Functor.Product.$w$cshow
        @ f_sg4RJ
        @ g_sg4RK
        @ a_sg4RL
        w_sg4RM
        w1_sg4RN
        w2_sg4RO
        ww1_sg4RS
        ww2_sg4RT
      }

-- RHS size: {terms: 29, types: 57, coercions: 0, joins: 0/2}
Data.Functor.Product.$fShowProduct_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     [Product f g a] -> ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 60 0 0] 200 0}]
Data.Functor.Product.$fShowProduct_$cshowList
  = \ (@ (f_ag43f :: * -> *))
      (@ (g_ag43g :: * -> *))
      (@ a_ag43h)
      ($dShow1_ag43i :: Show1 f_ag43f)
      ($dShow2_ag43j :: Show1 g_ag43g)
      ($dShow_ag43k :: Show a_ag43h)
      (ls_i7JaB :: [Product f_ag43f g_ag43g a_ag43h])
      (s_i7JaC :: String) ->
      let {
        lvl9_sg4og :: Int -> a_ag43h -> ShowS
        [LclId]
        lvl9_sg4og = showsPrec @ a_ag43h $dShow_ag43k } in
      let {
        lvl10_sg4oh :: [a_ag43h] -> ShowS
        [LclId]
        lvl10_sg4oh = showList @ a_ag43h $dShow_ag43k } in
      GHC.Show.showList__
        @ (Product f_ag43f g_ag43g a_ag43h)
        (\ (eta_B1 :: Product f_ag43f g_ag43g a_ag43h) ->
           case eta_B1 of { Pair ww1_sg4PE ww2_sg4PF ->
           Data.Functor.Product.$w$cliftShowsPrec
             @ f_ag43f
             @ g_ag43g
             $dShow1_ag43i
             $dShow2_ag43j
             @ a_ag43h
             lvl9_sg4og
             lvl10_sg4oh
             0#
             ww1_sg4PE
             ww2_sg4PF
           })
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 19, types: 31, coercions: 0, joins: 0/0}
Data.Functor.Product.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Show1 f, Show1 g, Show a) =>
     Show (Product f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(C1(C1(C(U))))),A)><L,U(U,A,U)>m,
 Unf=DFun: \ (@ (f_ag3EW :: * -> *))
             (@ (g_ag3EX :: * -> *))
             (@ a_ag3EY)
             (v_B1 :: Show1 f_ag3EW)
             (v1_B2 :: Show1 g_ag3EX)
             (v2_B3 :: Show a_ag3EY) ->
       GHC.Show.C:Show TYPE: Product f_ag3EW g_ag3EX a_ag3EY
                       Data.Functor.Product.$fShowProduct_$cshowsPrec
                         @ f_ag3EW @ g_ag3EX @ a_ag3EY v_B1 v1_B2 v2_B3
                       Data.Functor.Product.$fShowProduct_$cshow
                         @ f_ag3EW @ g_ag3EX @ a_ag3EY v_B1 v1_B2 v2_B3
                       Data.Functor.Product.$fShowProduct_$cshowList
                         @ f_ag3EW @ g_ag3EX @ a_ag3EY v_B1 v1_B2 v2_B3]
Data.Functor.Product.$fShowProduct
  = \ (@ (f_ag43f :: * -> *))
      (@ (g_ag43g :: * -> *))
      (@ a_ag43h)
      ($dShow1_ag43i :: Show1 f_ag43f)
      ($dShow2_ag43j :: Show1 g_ag43g)
      ($dShow_ag43k :: Show a_ag43h) ->
      GHC.Show.C:Show
        @ (Product f_ag43f g_ag43g a_ag43h)
        (Data.Functor.Product.$fShowProduct_$cshowsPrec
           @ f_ag43f
           @ g_ag43g
           @ a_ag43h
           $dShow1_ag43i
           $dShow2_ag43j
           $dShow_ag43k)
        (Data.Functor.Product.$fShowProduct_$cshow
           @ f_ag43f
           @ g_ag43g
           @ a_ag43h
           $dShow1_ag43i
           $dShow2_ag43j
           $dShow_ag43k)
        (Data.Functor.Product.$fShowProduct_$cshowList
           @ f_ag43f
           @ g_ag43g
           @ a_ag43h
           $dShow1_ag43i
           $dShow2_ag43j
           $dShow_ag43k)

-- RHS size: {terms: 20, types: 45, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFunctorProduct_$cfmap
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Functor g) =>
     forall a b. (a -> b) -> Product f g a -> Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag42G :: * -> *))
                 (@ (g_ag42H :: * -> *))
                 ($dFunctor_ag42I [Occ=Once] :: Functor f_ag42G)
                 ($dFunctor1_ag42J [Occ=Once] :: Functor g_ag42H)
                 (@ a_ag42N)
                 (@ b_ag42O)
                 (f1_ag3ET :: a_ag42N -> b_ag42O)
                 (ds_dg4dy [Occ=Once!] :: Product f_ag42G g_ag42H a_ag42N) ->
                 case ds_dg4dy of { Pair x_ag3EU [Occ=Once] y_ag3EV [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag42G
                   @ g_ag42H
                   @ b_ag42O
                   (fmap
                      @ f_ag42G $dFunctor_ag42I @ a_ag42N @ b_ag42O f1_ag3ET x_ag3EU)
                   (fmap
                      @ g_ag42H $dFunctor1_ag42J @ a_ag42N @ b_ag42O f1_ag3ET y_ag3EV)
                 }}]
Data.Functor.Product.$fFunctorProduct_$cfmap
  = \ (@ (f_ag42G :: * -> *))
      (@ (g_ag42H :: * -> *))
      ($dFunctor_ag42I :: Functor f_ag42G)
      ($dFunctor1_ag42J :: Functor g_ag42H)
      (@ a_ag42N)
      (@ b_ag42O)
      (f1_ag3ET :: a_ag42N -> b_ag42O)
      (ds_dg4dy :: Product f_ag42G g_ag42H a_ag42N) ->
      case ds_dg4dy of { Pair x_ag3EU y_ag3EV ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag42G
        @ g_ag42H
        @ b_ag42O
        (fmap
           @ f_ag42G $dFunctor_ag42I @ a_ag42N @ b_ag42O f1_ag3ET x_ag3EU)
        (fmap
           @ g_ag42H $dFunctor1_ag42J @ a_ag42N @ b_ag42O f1_ag3ET y_ag3EV)
      }

-- RHS size: {terms: 23, types: 47, coercions: 0, joins: 0/1}
Data.Functor.Product.$fFunctorProduct_$c<$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Functor g) =>
     forall a b. a -> Product f g b -> Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4S4 :: * -> *))
                 (@ (g_sg4S5 :: * -> *))
                 (w_sg4S6 [Occ=Once] :: Functor f_sg4S4)
                 (w1_sg4S7 [Occ=Once] :: Functor g_sg4S5)
                 (@ a_sg4S8)
                 (@ b_sg4S9)
                 (w2_sg4Sa :: a_sg4S8)
                 (w3_sg4Sb [Occ=Once!] :: Product f_sg4S4 g_sg4S5 b_sg4S9) ->
                 case w3_sg4Sb of
                 { Pair ww1_sg4Se [Occ=Once] ww2_sg4Sf [Occ=Once] ->
                 let {
                   f1_sg4nO :: b_sg4S9 -> a_sg4S8
                   [LclId,
                    Arity=1,
                    Str=<L,A>,
                    Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                            WorkFree=True, Expandable=True,
                            Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                            Tmpl= \ _ [Occ=Dead] -> w2_sg4Sa}]
                   f1_sg4nO = \ _ [Occ=Dead] -> w2_sg4Sa } in
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sg4S4
                   @ g_sg4S5
                   @ a_sg4S8
                   (fmap @ f_sg4S4 w_sg4S6 @ b_sg4S9 @ a_sg4S8 f1_sg4nO ww1_sg4Se)
                   (fmap @ g_sg4S5 w1_sg4S7 @ b_sg4S9 @ a_sg4S8 f1_sg4nO ww2_sg4Sf)
                 }}]
Data.Functor.Product.$fFunctorProduct_$c<$
  = \ (@ (f_sg4S4 :: * -> *))
      (@ (g_sg4S5 :: * -> *))
      (w_sg4S6 :: Functor f_sg4S4)
      (w1_sg4S7 :: Functor g_sg4S5)
      (@ a_sg4S8)
      (@ b_sg4S9)
      (w2_sg4Sa :: a_sg4S8)
      (w3_sg4Sb :: Product f_sg4S4 g_sg4S5 b_sg4S9) ->
      case w3_sg4Sb of { Pair ww1_sg4Se ww2_sg4Sf ->
      let {
        f1_sg4nO :: b_sg4S9 -> a_sg4S8
        [LclId,
         Arity=1,
         Str=<L,A>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                 Tmpl= \ _ [Occ=Dead] -> w2_sg4Sa}]
        f1_sg4nO = \ _ [Occ=Dead] -> w2_sg4Sa } in
      Data.Functor.Product.Pair
        @ *
        @ f_sg4S4
        @ g_sg4S5
        @ a_sg4S8
        (fmap @ f_sg4S4 w_sg4S6 @ b_sg4S9 @ a_sg4S8 f1_sg4nO ww1_sg4Se)
        (fmap @ g_sg4S5 w1_sg4S7 @ b_sg4S9 @ a_sg4S8 f1_sg4nO ww2_sg4Sf)
      }

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Functor g) =>
     Functor (Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ (f_ag3ER :: * -> *))
             (@ (g_ag3ES :: * -> *))
             (v_B1 :: Functor f_ag3ER)
             (v1_B2 :: Functor g_ag3ES) ->
       GHC.Base.C:Functor TYPE: Product f_ag3ER g_ag3ES
                          Data.Functor.Product.$fFunctorProduct_$cfmap
                            @ f_ag3ER @ g_ag3ES v_B1 v1_B2
                          Data.Functor.Product.$fFunctorProduct_$c<$
                            @ f_ag3ER @ g_ag3ES v_B1 v1_B2]
Data.Functor.Product.$fFunctorProduct
  = \ (@ (f_ag42G :: * -> *))
      (@ (g_ag42H :: * -> *))
      ($dFunctor_ag42I :: Functor f_ag42G)
      ($dFunctor1_ag42J :: Functor g_ag42H) ->
      GHC.Base.C:Functor
        @ (Product f_ag42G g_ag42H)
        (Data.Functor.Product.$fFunctorProduct_$cfmap
           @ f_ag42G @ g_ag42H $dFunctor_ag42I $dFunctor1_ag42J)
        (Data.Functor.Product.$fFunctorProduct_$c<$
           @ f_ag42G @ g_ag42H $dFunctor_ag42I $dFunctor1_ag42J)

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Data.Functor.Product.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m a. Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0] 140 0}]
Data.Functor.Product.$w$cfoldMap
  = \ (@ (f_sg4Sl :: * -> *))
      (@ (g_sg4Sm :: * -> *))
      (w_sg4Sn :: Foldable f_sg4Sl)
      (w1_sg4So :: Foldable g_sg4Sm)
      (@ m_sg4Sp)
      (@ a_sg4Sq)
      (w2_sg4Sr :: Monoid m_sg4Sp)
      (w3_sg4Ss :: a_sg4Sq -> m_sg4Sp)
      (ww_sg4Sw :: f_sg4Sl a_sg4Sq)
      (ww1_sg4Sx :: g_sg4Sm a_sg4Sq) ->
      mappend
        @ m_sg4Sp
        w2_sg4Sr
        (foldMap
           @ f_sg4Sl w_sg4Sn @ m_sg4Sp @ a_sg4Sq w2_sg4Sr w3_sg4Ss ww_sg4Sw)
        (foldMap
           @ g_sg4Sm w1_sg4So @ m_sg4Sp @ a_sg4Sq w2_sg4Sr w3_sg4Ss ww1_sg4Sx)

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m a. Monoid m => (a -> m) -> Product f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Sl :: * -> *))
                 (@ (g_sg4Sm :: * -> *))
                 (w_sg4Sn [Occ=Once] :: Foldable f_sg4Sl)
                 (w1_sg4So [Occ=Once] :: Foldable g_sg4Sm)
                 (@ m_sg4Sp)
                 (@ a_sg4Sq)
                 (w2_sg4Sr [Occ=Once] :: Monoid m_sg4Sp)
                 (w3_sg4Ss [Occ=Once] :: a_sg4Sq -> m_sg4Sp)
                 (w4_sg4St [Occ=Once!] :: Product f_sg4Sl g_sg4Sm a_sg4Sq) ->
                 case w4_sg4St of
                 { Pair ww1_sg4Sw [Occ=Once] ww2_sg4Sx [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldMap
                   @ f_sg4Sl
                   @ g_sg4Sm
                   w_sg4Sn
                   w1_sg4So
                   @ m_sg4Sp
                   @ a_sg4Sq
                   w2_sg4Sr
                   w3_sg4Ss
                   ww1_sg4Sw
                   ww2_sg4Sx
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldMap
  = \ (@ (f_sg4Sl :: * -> *))
      (@ (g_sg4Sm :: * -> *))
      (w_sg4Sn :: Foldable f_sg4Sl)
      (w1_sg4So :: Foldable g_sg4Sm)
      (@ m_sg4Sp)
      (@ a_sg4Sq)
      (w2_sg4Sr :: Monoid m_sg4Sp)
      (w3_sg4Ss :: a_sg4Sq -> m_sg4Sp)
      (w4_sg4St :: Product f_sg4Sl g_sg4Sm a_sg4Sq) ->
      case w4_sg4St of { Pair ww1_sg4Sw ww2_sg4Sx ->
      Data.Functor.Product.$w$cfoldMap
        @ f_sg4Sl
        @ g_sg4Sm
        w_sg4Sn
        w1_sg4So
        @ m_sg4Sp
        @ a_sg4Sq
        w2_sg4Sr
        w3_sg4Ss
        ww1_sg4Sw
        ww2_sg4Sx
      }

-- RHS size: {terms: 17, types: 37, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m. Monoid m => Product f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag400 :: * -> *))
                 (@ (g_ag401 :: * -> *))
                 ($dFoldable_ag402 [Occ=Once] :: Foldable f_ag400)
                 ($dFoldable1_ag403 [Occ=Once] :: Foldable g_ag401)
                 (@ m_ag407)
                 ($dMonoid_ag409 [Occ=Once] :: Monoid m_ag407) ->
                 Data.Functor.Product.$fFoldableProduct_$cfoldMap
                   @ f_ag400
                   @ g_ag401
                   $dFoldable_ag402
                   $dFoldable1_ag403
                   @ m_ag407
                   @ m_ag407
                   $dMonoid_ag409
                   (id @ m_ag407)}]
Data.Functor.Product.$fFoldableProduct_$cfold
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ m_ag407)
      ($dMonoid_ag409 :: Monoid m_ag407)
      (w_sg4St :: Product f_ag400 g_ag401 m_ag407) ->
      case w_sg4St of { Pair ww1_sg4Sw ww2_sg4Sx ->
      Data.Functor.Product.$w$cfoldMap
        @ f_ag400
        @ g_ag401
        $dFoldable_ag402
        $dFoldable1_ag403
        @ m_ag407
        @ m_ag407
        $dMonoid_ag409
        (id @ m_ag407)
        ww1_sg4Sw
        ww2_sg4Sx
      }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct1 :: forall a. a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_ag42n) (v_ifzGv [Occ=Once] :: a_ag42n) -> v_ifzGv}]
Data.Functor.Product.$fFoldableProduct1
  = \ (@ a_ag42n) (v_ifzGv :: a_ag42n) -> v_ifzGv

-- RHS size: {terms: 25, types: 47, coercions: 26, joins: 0/1}
Data.Functor.Product.$fFoldableProduct_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30] 190 60}]
Data.Functor.Product.$fFoldableProduct_$csum
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag42n)
      ($dNum_ag42p :: Num a_ag42n) ->
      let {
        $dMonoid_sg4nM :: Monoid (Data.Semigroup.Internal.Sum a_ag42n)
        [LclId]
        $dMonoid_sg4nM
          = Data.Semigroup.Internal.$fMonoidSum @ a_ag42n $dNum_ag42p } in
      (\ (ds_dg4ds :: Product f_ag400 g_ag401 a_ag42n) ->
         case ds_dg4ds of { Pair x_ag3EP y_ag3EQ ->
         (+ @ a_ag42n
            $dNum_ag42p
            ((foldMap
                @ f_ag400
                $dFoldable_ag402
                @ (Data.Semigroup.Internal.Sum a_ag42n)
                @ a_ag42n
                $dMonoid_sg4nM
                ((Data.Functor.Product.$fFoldableProduct1 @ a_ag42n)
                 `cast` (<a_ag42n>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_ag42n>_R)
                         :: (a_ag42n -> a_ag42n :: *)
                            ~R# (a_ag42n -> Data.Semigroup.Internal.Sum a_ag42n :: *)))
                x_ag3EP)
             `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ag42n>_R
                     :: (Data.Semigroup.Internal.Sum a_ag42n :: *) ~R# (a_ag42n :: *)))
            ((foldMap
                @ g_ag401
                $dFoldable1_ag403
                @ (Data.Semigroup.Internal.Sum a_ag42n)
                @ a_ag42n
                $dMonoid_sg4nM
                ((Data.Functor.Product.$fFoldableProduct1 @ a_ag42n)
                 `cast` (<a_ag42n>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_ag42n>_R)
                         :: (a_ag42n -> a_ag42n :: *)
                            ~R# (a_ag42n -> Data.Semigroup.Internal.Sum a_ag42n :: *)))
                y_ag3EQ)
             `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ag42n>_R
                     :: (Data.Semigroup.Internal.Sum a_ag42n :: *) ~R# (a_ag42n :: *))))
         `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_ag42n>_R)
                 :: (a_ag42n :: *) ~R# (Data.Semigroup.Internal.Sum a_ag42n :: *))
         })
      `cast` (<Product f_ag400 g_ag401 a_ag42n>_R
              ->_R Data.Semigroup.Internal.N:Sum[0] <a_ag42n>_R
              :: (Product f_ag400 g_ag401 a_ag42n
                  -> Data.Semigroup.Internal.Sum a_ag42n :: *)
                 ~R# (Product f_ag400 g_ag401 a_ag42n -> a_ag42n :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rg5nW :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_rg5nW = "minimum: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct2 :: forall a. a
[GblId, Str=x]
Data.Functor.Product.$fFoldableProduct2
  = \ (@ a_ag42d) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_ag42d
        (GHC.CString.unpackCString# lvl_rg5nW)

-- RHS size: {terms: 49, types: 63, coercions: 21, joins: 0/1}
Data.Functor.Product.$fFoldableProduct_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 30] 320 60}]
Data.Functor.Product.$fFoldableProduct_$cminimum
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag42d)
      ($dOrd_ag42f :: Ord a_ag42d) ->
      let {
        $dMonoid_sg4nH :: Monoid (Data.Functor.Utils.Min a_ag42d)
        [LclId]
        $dMonoid_sg4nH
          = Data.Functor.Utils.$fMonoidMin @ a_ag42d $dOrd_ag42f } in
      \ (x_ifzGk :: Product f_ag400 g_ag401 a_ag42d) ->
        case x_ifzGk of { Pair x1_ag3EP y_ag3EQ ->
        case (foldMap
                @ g_ag401
                $dFoldable1_ag403
                @ (Data.Functor.Utils.Min a_ag42d)
                @ a_ag42d
                $dMonoid_sg4nH
                ((GHC.Base.Just @ a_ag42d)
                 `cast` (<a_ag42d>_R
                         ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_ag42d>_N
                         :: (a_ag42d -> Maybe a_ag42d :: *)
                            ~R# (a_ag42d -> Data.Functor.Utils.Min a_ag42d :: *)))
                y_ag3EQ)
             `cast` (Data.Functor.Utils.N:Min[0] <a_ag42d>_N
                     :: (Data.Functor.Utils.Min a_ag42d :: *) ~R# (Maybe a_ag42d :: *))
        of {
          Nothing ->
            case (foldMap
                    @ f_ag400
                    $dFoldable_ag402
                    @ (Data.Functor.Utils.Min a_ag42d)
                    @ a_ag42d
                    $dMonoid_sg4nH
                    ((GHC.Base.Just @ a_ag42d)
                     `cast` (<a_ag42d>_R
                             ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_ag42d>_N
                             :: (a_ag42d -> Maybe a_ag42d :: *)
                                ~R# (a_ag42d -> Data.Functor.Utils.Min a_ag42d :: *)))
                    x1_ag3EP)
                 `cast` (Data.Functor.Utils.N:Min[0] <a_ag42d>_N
                         :: (Data.Functor.Utils.Min a_ag42d :: *) ~R# (Maybe a_ag42d :: *))
            of {
              Nothing -> Data.Functor.Product.$fFoldableProduct2 @ a_ag42d;
              Just v_ifzGp -> v_ifzGp
            };
          Just ipv_ig4fB ->
            case (foldMap
                    @ f_ag400
                    $dFoldable_ag402
                    @ (Data.Functor.Utils.Min a_ag42d)
                    @ a_ag42d
                    $dMonoid_sg4nH
                    ((GHC.Base.Just @ a_ag42d)
                     `cast` (<a_ag42d>_R
                             ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_ag42d>_N
                             :: (a_ag42d -> Maybe a_ag42d :: *)
                                ~R# (a_ag42d -> Data.Functor.Utils.Min a_ag42d :: *)))
                    x1_ag3EP)
                 `cast` (Data.Functor.Utils.N:Min[0] <a_ag42d>_N
                         :: (Data.Functor.Utils.Min a_ag42d :: *) ~R# (Maybe a_ag42d :: *))
            of {
              Nothing -> ipv_ig4fB;
              Just x2_ig4fH ->
                case <= @ a_ag42d $dOrd_ag42f x2_ig4fH ipv_ig4fB of {
                  False -> ipv_ig4fB;
                  True -> x2_ig4fH
                }
            }
        }
        }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_rg5nX :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_rg5nX = "maximum: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct3 :: forall a. a
[GblId, Str=x]
Data.Functor.Product.$fFoldableProduct3
  = \ (@ a_ag423) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_ag423
        (GHC.CString.unpackCString# lvl1_rg5nX)

-- RHS size: {terms: 49, types: 63, coercions: 21, joins: 0/1}
Data.Functor.Product.$fFoldableProduct_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 30] 320 60}]
Data.Functor.Product.$fFoldableProduct_$cmaximum
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag423)
      ($dOrd_ag425 :: Ord a_ag423) ->
      let {
        $dMonoid_sg4nD :: Monoid (Data.Functor.Utils.Max a_ag423)
        [LclId]
        $dMonoid_sg4nD
          = Data.Functor.Utils.$fMonoidMax @ a_ag423 $dOrd_ag425 } in
      \ (x_ifzG6 :: Product f_ag400 g_ag401 a_ag423) ->
        case x_ifzG6 of { Pair x1_ag3EP y_ag3EQ ->
        case (foldMap
                @ g_ag401
                $dFoldable1_ag403
                @ (Data.Functor.Utils.Max a_ag423)
                @ a_ag423
                $dMonoid_sg4nD
                ((GHC.Base.Just @ a_ag423)
                 `cast` (<a_ag423>_R
                         ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_ag423>_N
                         :: (a_ag423 -> Maybe a_ag423 :: *)
                            ~R# (a_ag423 -> Data.Functor.Utils.Max a_ag423 :: *)))
                y_ag3EQ)
             `cast` (Data.Functor.Utils.N:Max[0] <a_ag423>_N
                     :: (Data.Functor.Utils.Max a_ag423 :: *) ~R# (Maybe a_ag423 :: *))
        of {
          Nothing ->
            case (foldMap
                    @ f_ag400
                    $dFoldable_ag402
                    @ (Data.Functor.Utils.Max a_ag423)
                    @ a_ag423
                    $dMonoid_sg4nD
                    ((GHC.Base.Just @ a_ag423)
                     `cast` (<a_ag423>_R
                             ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_ag423>_N
                             :: (a_ag423 -> Maybe a_ag423 :: *)
                                ~R# (a_ag423 -> Data.Functor.Utils.Max a_ag423 :: *)))
                    x1_ag3EP)
                 `cast` (Data.Functor.Utils.N:Max[0] <a_ag423>_N
                         :: (Data.Functor.Utils.Max a_ag423 :: *) ~R# (Maybe a_ag423 :: *))
            of {
              Nothing -> Data.Functor.Product.$fFoldableProduct3 @ a_ag423;
              Just v_ifzGb -> v_ifzGb
            };
          Just ipv_ig4fb ->
            case (foldMap
                    @ f_ag400
                    $dFoldable_ag402
                    @ (Data.Functor.Utils.Max a_ag423)
                    @ a_ag423
                    $dMonoid_sg4nD
                    ((GHC.Base.Just @ a_ag423)
                     `cast` (<a_ag423>_R
                             ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_ag423>_N
                             :: (a_ag423 -> Maybe a_ag423 :: *)
                                ~R# (a_ag423 -> Data.Functor.Utils.Max a_ag423 :: *)))
                    x1_ag3EP)
                 `cast` (Data.Functor.Utils.N:Max[0] <a_ag423>_N
                         :: (Data.Functor.Utils.Max a_ag423 :: *) ~R# (Maybe a_ag423 :: *))
            of {
              Nothing -> ipv_ig4fb;
              Just x2_ig4fh ->
                case >= @ a_ag423 $dOrd_ag425 x2_ig4fh ipv_ig4fb of {
                  False -> ipv_ig4fb;
                  True -> x2_ig4fh
                }
            }
        }
        }

-- RHS size: {terms: 29, types: 43, coercions: 19, joins: 0/1}
Data.Functor.Product.$fFoldableProduct_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Eq a => a -> Product f g a -> Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0] 180 60}]
Data.Functor.Product.$fFoldableProduct_$celem
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag41T)
      ($dEq_ag41V :: Eq a_ag41T)
      (eta_B1 :: a_ag41T) ->
      let {
        f1_sg4nA :: a_ag41T -> Bool
        [LclId]
        f1_sg4nA = == @ a_ag41T $dEq_ag41V eta_B1 } in
      (\ (ds_dg4ds :: Product f_ag400 g_ag401 a_ag41T) ->
         case ds_dg4ds of { Pair x_ag3EP y_ag3EQ ->
         case (foldMap
                 @ f_ag400
                 $dFoldable_ag402
                 @ Data.Semigroup.Internal.Any
                 @ a_ag41T
                 Data.Semigroup.Internal.$fMonoidAny
                 (f1_sg4nA
                  `cast` (<a_ag41T>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                          :: (a_ag41T -> Bool :: *)
                             ~R# (a_ag41T -> Data.Semigroup.Internal.Any :: *)))
                 x_ag3EP)
              `cast` (Data.Semigroup.Internal.N:Any[0]
                      :: (Data.Semigroup.Internal.Any :: *) ~R# (Bool :: *))
         of {
           False ->
             foldMap
               @ g_ag401
               $dFoldable1_ag403
               @ Data.Semigroup.Internal.Any
               @ a_ag41T
               Data.Semigroup.Internal.$fMonoidAny
               (f1_sg4nA
                `cast` (<a_ag41T>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                        :: (a_ag41T -> Bool :: *)
                           ~R# (a_ag41T -> Data.Semigroup.Internal.Any :: *)))
               y_ag3EQ;
           True ->
             GHC.Types.True
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Semigroup.Internal.Any :: *))
         }
         })
      `cast` (<Product f_ag400 g_ag401 a_ag41T>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Product f_ag400 g_ag401 a_ag41T
                  -> Data.Semigroup.Internal.Any :: *)
                 ~R# (Product f_ag400 g_ag401 a_ag41T -> Bool :: *))

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct8
  :: forall b.
     Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Product.$fFoldableProduct8
  = \ (@ b_ag40V) ->
      Data.Semigroup.Internal.$fMonoidDual
        @ (Data.Semigroup.Internal.Endo b_ag40V)
        (Data.Semigroup.Internal.$fMonoidEndo @ b_ag40V)

-- RHS size: {terms: 27, types: 41, coercions: 18, joins: 0/1}
Data.Functor.Product.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 180 0}]
Data.Functor.Product.$w$cfoldl
  = \ (@ (f_sg4SZ :: * -> *))
      (@ (g_sg4T0 :: * -> *))
      (w_sg4T1 :: Foldable f_sg4SZ)
      (w1_sg4T2 :: Foldable g_sg4T0)
      (@ b_sg4T3)
      (@ a_sg4T4)
      (w2_sg4T5 :: b_sg4T3 -> a_sg4T4 -> b_sg4T3)
      (w3_sg4T6 :: b_sg4T3)
      (ww_sg4Ta :: f_sg4SZ a_sg4T4)
      (ww1_sg4Tb :: g_sg4T0 a_sg4T4) ->
      let {
        f1_sg4ny :: a_sg4T4 -> b_sg4T3 -> b_sg4T3
        [LclId,
         Arity=2,
         Str=<L,U><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
                 Tmpl= \ (x_ifzEJ [Occ=Once] :: a_sg4T4)
                         (y_ifzEK [Occ=Once] :: b_sg4T3) ->
                         w2_sg4T5 y_ifzEK x_ifzEJ}]
        f1_sg4ny
          = \ (x_ifzEJ :: a_sg4T4) (y_ifzEK :: b_sg4T3) ->
              w2_sg4T5 y_ifzEK x_ifzEJ } in
      ((foldMap
          @ g_sg4T0
          w1_sg4T2
          @ (Data.Semigroup.Internal.Dual
               (Data.Semigroup.Internal.Endo b_sg4T3))
          @ a_sg4T4
          (Data.Functor.Product.$fFoldableProduct8 @ b_sg4T3)
          (f1_sg4ny
           `cast` (<a_sg4T4>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_sg4T3>_R))
                   :: (a_sg4T4 -> b_sg4T3 -> b_sg4T3 :: *)
                      ~R# (a_sg4T4
                           -> Data.Semigroup.Internal.Dual
                                (Data.Semigroup.Internal.Endo b_sg4T3) :: *)))
          ww1_sg4Tb)
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_sg4T3>_R)
               :: (Data.Semigroup.Internal.Dual
                     (Data.Semigroup.Internal.Endo b_sg4T3) :: *)
                  ~R# (b_sg4T3 -> b_sg4T3 :: *)))
        (((foldMap
             @ f_sg4SZ
             w_sg4T1
             @ (Data.Semigroup.Internal.Dual
                  (Data.Semigroup.Internal.Endo b_sg4T3))
             @ a_sg4T4
             (Data.Functor.Product.$fFoldableProduct8 @ b_sg4T3)
             (f1_sg4ny
              `cast` (<a_sg4T4>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                    (Data.Semigroup.Internal.N:Endo[0] <b_sg4T3>_R))
                      :: (a_sg4T4 -> b_sg4T3 -> b_sg4T3 :: *)
                         ~R# (a_sg4T4
                              -> Data.Semigroup.Internal.Dual
                                   (Data.Semigroup.Internal.Endo b_sg4T3) :: *)))
             ww_sg4Ta)
          `cast` (Data.Semigroup.Internal.N:Dual[0]
                      (Data.Semigroup.Internal.N:Endo[0] <b_sg4T3>_R)
                  :: (Data.Semigroup.Internal.Dual
                        (Data.Semigroup.Internal.Endo b_sg4T3) :: *)
                     ~R# (b_sg4T3 -> b_sg4T3 :: *)))
           w3_sg4T6)

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4SZ :: * -> *))
                 (@ (g_sg4T0 :: * -> *))
                 (w_sg4T1 [Occ=Once] :: Foldable f_sg4SZ)
                 (w1_sg4T2 [Occ=Once] :: Foldable g_sg4T0)
                 (@ b_sg4T3)
                 (@ a_sg4T4)
                 (w2_sg4T5 [Occ=Once] :: b_sg4T3 -> a_sg4T4 -> b_sg4T3)
                 (w3_sg4T6 [Occ=Once] :: b_sg4T3)
                 (w4_sg4T7 [Occ=Once!] :: Product f_sg4SZ g_sg4T0 a_sg4T4) ->
                 case w4_sg4T7 of
                 { Pair ww1_sg4Ta [Occ=Once] ww2_sg4Tb [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldl
                   @ f_sg4SZ
                   @ g_sg4T0
                   w_sg4T1
                   w1_sg4T2
                   @ b_sg4T3
                   @ a_sg4T4
                   w2_sg4T5
                   w3_sg4T6
                   ww1_sg4Ta
                   ww2_sg4Tb
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldl
  = \ (@ (f_sg4SZ :: * -> *))
      (@ (g_sg4T0 :: * -> *))
      (w_sg4T1 :: Foldable f_sg4SZ)
      (w1_sg4T2 :: Foldable g_sg4T0)
      (@ b_sg4T3)
      (@ a_sg4T4)
      (w2_sg4T5 :: b_sg4T3 -> a_sg4T4 -> b_sg4T3)
      (w3_sg4T6 :: b_sg4T3)
      (w4_sg4T7 :: Product f_sg4SZ g_sg4T0 a_sg4T4) ->
      case w4_sg4T7 of { Pair ww1_sg4Ta ww2_sg4Tb ->
      Data.Functor.Product.$w$cfoldl
        @ f_sg4SZ
        @ g_sg4T0
        w_sg4T1
        w1_sg4T2
        @ b_sg4T3
        @ a_sg4T4
        w2_sg4T5
        w3_sg4T6
        ww1_sg4Ta
        ww2_sg4Tb
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_rg5nY :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_rg5nY = "foldl1: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct7 :: forall a. a
[GblId, Str=x]
Data.Functor.Product.$fFoldableProduct7
  = \ (@ a_ag41n) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_ag41n
        (GHC.CString.unpackCString# lvl2_rg5nY)

-- RHS size: {terms: 36, types: 54, coercions: 22, joins: 0/1}
Data.Functor.Product.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 230 0}]
Data.Functor.Product.$w$cfoldl1
  = \ (@ (f_sg4Te :: * -> *))
      (@ (g_sg4Tf :: * -> *))
      (w_sg4Tg :: Foldable f_sg4Te)
      (w1_sg4Th :: Foldable g_sg4Tf)
      (@ a_sg4Ti)
      (w2_sg4Tj :: a_sg4Ti -> a_sg4Ti -> a_sg4Ti)
      (ww_sg4Tn :: f_sg4Te a_sg4Ti)
      (ww1_sg4To :: g_sg4Tf a_sg4Ti) ->
      let {
        f1_sg4ny :: a_sg4Ti -> Maybe a_sg4Ti -> Maybe a_sg4Ti
        [LclId,
         Arity=2,
         Str=<L,U><L,1*U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_ifzEJ [Occ=Once*] :: a_sg4Ti)
                         (y_ifzEK [Occ=Once!] :: Maybe a_sg4Ti) ->
                         GHC.Base.Just
                           @ a_sg4Ti
                           (case y_ifzEK of {
                              Nothing -> x_ifzEJ;
                              Just x1_ifzFq [Occ=Once] -> w2_sg4Tj x1_ifzFq x_ifzEJ
                            })}]
        f1_sg4ny
          = \ (x_ifzEJ :: a_sg4Ti) (y_ifzEK :: Maybe a_sg4Ti) ->
              GHC.Base.Just
                @ a_sg4Ti
                (case y_ifzEK of {
                   Nothing -> x_ifzEJ;
                   Just x1_ifzFq -> w2_sg4Tj x1_ifzFq x_ifzEJ
                 }) } in
      case ((foldMap
               @ g_sg4Tf
               w1_sg4Th
               @ (Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (Maybe a_sg4Ti)))
               @ a_sg4Ti
               (Data.Functor.Product.$fFoldableProduct8 @ (Maybe a_sg4Ti))
               (f1_sg4ny
                `cast` (<a_sg4Ti>_R
                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                      (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ti>_R))
                        :: (a_sg4Ti -> Maybe a_sg4Ti -> Maybe a_sg4Ti :: *)
                           ~R# (a_sg4Ti
                                -> Data.Semigroup.Internal.Dual
                                     (Data.Semigroup.Internal.Endo (Maybe a_sg4Ti)) :: *)))
               ww1_sg4To)
            `cast` (Data.Semigroup.Internal.N:Dual[0]
                        (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ti>_R)
                    :: (Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (Maybe a_sg4Ti)) :: *)
                       ~R# (Maybe a_sg4Ti -> Maybe a_sg4Ti :: *)))
             (((foldMap
                  @ f_sg4Te
                  w_sg4Tg
                  @ (Data.Semigroup.Internal.Dual
                       (Data.Semigroup.Internal.Endo (Maybe a_sg4Ti)))
                  @ a_sg4Ti
                  (Data.Functor.Product.$fFoldableProduct8 @ (Maybe a_sg4Ti))
                  (f1_sg4ny
                   `cast` (<a_sg4Ti>_R
                           ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                         (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ti>_R))
                           :: (a_sg4Ti -> Maybe a_sg4Ti -> Maybe a_sg4Ti :: *)
                              ~R# (a_sg4Ti
                                   -> Data.Semigroup.Internal.Dual
                                        (Data.Semigroup.Internal.Endo (Maybe a_sg4Ti)) :: *)))
                  ww_sg4Tn)
               `cast` (Data.Semigroup.Internal.N:Dual[0]
                           (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ti>_R)
                       :: (Data.Semigroup.Internal.Dual
                             (Data.Semigroup.Internal.Endo (Maybe a_sg4Ti)) :: *)
                          ~R# (Maybe a_sg4Ti -> Maybe a_sg4Ti :: *)))
                (GHC.Base.Nothing @ a_sg4Ti))
      of {
        Nothing -> Data.Functor.Product.$fFoldableProduct7 @ a_sg4Ti;
        Just v_ifzFw -> v_ifzFw
      }

-- RHS size: {terms: 16, types: 36, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> Product f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Te :: * -> *))
                 (@ (g_sg4Tf :: * -> *))
                 (w_sg4Tg [Occ=Once] :: Foldable f_sg4Te)
                 (w1_sg4Th [Occ=Once] :: Foldable g_sg4Tf)
                 (@ a_sg4Ti)
                 (w2_sg4Tj [Occ=Once] :: a_sg4Ti -> a_sg4Ti -> a_sg4Ti)
                 (w3_sg4Tk [Occ=Once!] :: Product f_sg4Te g_sg4Tf a_sg4Ti) ->
                 case w3_sg4Tk of
                 { Pair ww1_sg4Tn [Occ=Once] ww2_sg4To [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldl1
                   @ f_sg4Te
                   @ g_sg4Tf
                   w_sg4Tg
                   w1_sg4Th
                   @ a_sg4Ti
                   w2_sg4Tj
                   ww1_sg4Tn
                   ww2_sg4To
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldl1
  = \ (@ (f_sg4Te :: * -> *))
      (@ (g_sg4Tf :: * -> *))
      (w_sg4Tg :: Foldable f_sg4Te)
      (w1_sg4Th :: Foldable g_sg4Tf)
      (@ a_sg4Ti)
      (w2_sg4Tj :: a_sg4Ti -> a_sg4Ti -> a_sg4Ti)
      (w3_sg4Tk :: Product f_sg4Te g_sg4Tf a_sg4Ti) ->
      case w3_sg4Tk of { Pair ww1_sg4Tn ww2_sg4To ->
      Data.Functor.Product.$w$cfoldl1
        @ f_sg4Te
        @ g_sg4Tf
        w_sg4Tg
        w1_sg4Th
        @ a_sg4Ti
        w2_sg4Tj
        ww1_sg4Tn
        ww2_sg4To
      }

-- RHS size: {terms: 33, types: 51, coercions: 22, joins: 0/1}
Data.Functor.Product.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 230 0}]
Data.Functor.Product.$w$cfoldr'
  = \ (@ (f_sg4Tr :: * -> *))
      (@ (g_sg4Ts :: * -> *))
      (w_sg4Tt :: Foldable f_sg4Tr)
      (w1_sg4Tu :: Foldable g_sg4Ts)
      (@ a_sg4Tv)
      (@ b_sg4Tw)
      (w2_sg4Tx :: a_sg4Tv -> b_sg4Tw -> b_sg4Tw)
      (w3_sg4Ty :: b_sg4Tw)
      (ww_sg4TC :: f_sg4Tr a_sg4Tv)
      (ww1_sg4TD :: g_sg4Ts a_sg4Tv) ->
      let {
        f1_sg4ny :: a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw
        [LclId,
         Arity=3,
         Str=<L,U><C(S),1*C1(U)><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_ifzEJ [Occ=Once] :: a_sg4Tv)
                         (y_ifzEK [Occ=Once!] :: b_sg4Tw -> b_sg4Tw)
                         (z_ifzEz [Occ=Once] :: b_sg4Tw) ->
                         case w2_sg4Tx x_ifzEJ z_ifzEz of vx_ifzEA { __DEFAULT ->
                         y_ifzEK vx_ifzEA
                         }}]
        f1_sg4ny
          = \ (x_ifzEJ :: a_sg4Tv)
              (y_ifzEK :: b_sg4Tw -> b_sg4Tw)
              (z_ifzEz :: b_sg4Tw) ->
              case w2_sg4Tx x_ifzEJ z_ifzEz of vx_ifzEA { __DEFAULT ->
              y_ifzEK vx_ifzEA
              } } in
      ((foldMap
          @ g_sg4Ts
          w1_sg4Tu
          @ (Data.Semigroup.Internal.Dual
               (Data.Semigroup.Internal.Endo (b_sg4Tw -> b_sg4Tw)))
          @ a_sg4Tv
          (Data.Functor.Product.$fFoldableProduct8 @ (b_sg4Tw -> b_sg4Tw))
          (f1_sg4ny
           `cast` (<a_sg4Tv>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_sg4Tw -> b_sg4Tw>_R))
                   :: (a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw :: *)
                      ~R# (a_sg4Tv
                           -> Data.Semigroup.Internal.Dual
                                (Data.Semigroup.Internal.Endo (b_sg4Tw -> b_sg4Tw)) :: *)))
          ww1_sg4TD)
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_sg4Tw -> b_sg4Tw>_R)
               :: (Data.Semigroup.Internal.Dual
                     (Data.Semigroup.Internal.Endo (b_sg4Tw -> b_sg4Tw)) :: *)
                  ~R# ((b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw :: *)))
        (((foldMap
             @ f_sg4Tr
             w_sg4Tt
             @ (Data.Semigroup.Internal.Dual
                  (Data.Semigroup.Internal.Endo (b_sg4Tw -> b_sg4Tw)))
             @ a_sg4Tv
             (Data.Functor.Product.$fFoldableProduct8 @ (b_sg4Tw -> b_sg4Tw))
             (f1_sg4ny
              `cast` (<a_sg4Tv>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                    (Data.Semigroup.Internal.N:Endo[0] <b_sg4Tw -> b_sg4Tw>_R))
                      :: (a_sg4Tv -> (b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw :: *)
                         ~R# (a_sg4Tv
                              -> Data.Semigroup.Internal.Dual
                                   (Data.Semigroup.Internal.Endo (b_sg4Tw -> b_sg4Tw)) :: *)))
             ww_sg4TC)
          `cast` (Data.Semigroup.Internal.N:Dual[0]
                      (Data.Semigroup.Internal.N:Endo[0] <b_sg4Tw -> b_sg4Tw>_R)
                  :: (Data.Semigroup.Internal.Dual
                        (Data.Semigroup.Internal.Endo (b_sg4Tw -> b_sg4Tw)) :: *)
                     ~R# ((b_sg4Tw -> b_sg4Tw) -> b_sg4Tw -> b_sg4Tw :: *)))
           (id @ b_sg4Tw))
        w3_sg4Ty

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Product f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Tr :: * -> *))
                 (@ (g_sg4Ts :: * -> *))
                 (w_sg4Tt [Occ=Once] :: Foldable f_sg4Tr)
                 (w1_sg4Tu [Occ=Once] :: Foldable g_sg4Ts)
                 (@ a_sg4Tv)
                 (@ b_sg4Tw)
                 (w2_sg4Tx [Occ=Once] :: a_sg4Tv -> b_sg4Tw -> b_sg4Tw)
                 (w3_sg4Ty [Occ=Once] :: b_sg4Tw)
                 (w4_sg4Tz [Occ=Once!] :: Product f_sg4Tr g_sg4Ts a_sg4Tv) ->
                 case w4_sg4Tz of
                 { Pair ww1_sg4TC [Occ=Once] ww2_sg4TD [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldr'
                   @ f_sg4Tr
                   @ g_sg4Ts
                   w_sg4Tt
                   w1_sg4Tu
                   @ a_sg4Tv
                   @ b_sg4Tw
                   w2_sg4Tx
                   w3_sg4Ty
                   ww1_sg4TC
                   ww2_sg4TD
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldr'
  = \ (@ (f_sg4Tr :: * -> *))
      (@ (g_sg4Ts :: * -> *))
      (w_sg4Tt :: Foldable f_sg4Tr)
      (w1_sg4Tu :: Foldable g_sg4Ts)
      (@ a_sg4Tv)
      (@ b_sg4Tw)
      (w2_sg4Tx :: a_sg4Tv -> b_sg4Tw -> b_sg4Tw)
      (w3_sg4Ty :: b_sg4Tw)
      (w4_sg4Tz :: Product f_sg4Tr g_sg4Ts a_sg4Tv) ->
      case w4_sg4Tz of { Pair ww1_sg4TC ww2_sg4TD ->
      Data.Functor.Product.$w$cfoldr'
        @ f_sg4Tr
        @ g_sg4Ts
        w_sg4Tt
        w1_sg4Tu
        @ a_sg4Tv
        @ b_sg4Tw
        w2_sg4Tx
        w3_sg4Ty
        ww1_sg4TC
        ww2_sg4TD
      }

-- RHS size: {terms: 21, types: 34, coercions: 14, joins: 0/0}
Data.Functor.Product.$w$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 0 0] 120 0}]
Data.Functor.Product.$w$cfoldr
  = \ (@ (f_sg4TG :: * -> *))
      (@ (g_sg4TH :: * -> *))
      (w_sg4TI :: Foldable f_sg4TG)
      (w1_sg4TJ :: Foldable g_sg4TH)
      (@ a_sg4TK)
      (@ b_sg4TL)
      (w2_sg4TM :: a_sg4TK -> b_sg4TL -> b_sg4TL)
      (w3_sg4TN :: b_sg4TL)
      (ww_sg4TR :: f_sg4TG a_sg4TK)
      (ww1_sg4TS :: g_sg4TH a_sg4TK) ->
      ((foldMap
          @ f_sg4TG
          w_sg4TI
          @ (Data.Semigroup.Internal.Endo b_sg4TL)
          @ a_sg4TK
          (Data.Semigroup.Internal.$fMonoidEndo @ b_sg4TL)
          (w2_sg4TM
           `cast` (<a_sg4TK>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b_sg4TL>_R)
                   :: (a_sg4TK -> b_sg4TL -> b_sg4TL :: *)
                      ~R# (a_sg4TK -> Data.Semigroup.Internal.Endo b_sg4TL :: *)))
          ww_sg4TR)
       `cast` (Data.Semigroup.Internal.N:Endo[0] <b_sg4TL>_R
               :: (Data.Semigroup.Internal.Endo b_sg4TL :: *)
                  ~R# (b_sg4TL -> b_sg4TL :: *)))
        (((foldMap
             @ g_sg4TH
             w1_sg4TJ
             @ (Data.Semigroup.Internal.Endo b_sg4TL)
             @ a_sg4TK
             (Data.Semigroup.Internal.$fMonoidEndo @ b_sg4TL)
             (w2_sg4TM
              `cast` (<a_sg4TK>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b_sg4TL>_R)
                      :: (a_sg4TK -> b_sg4TL -> b_sg4TL :: *)
                         ~R# (a_sg4TK -> Data.Semigroup.Internal.Endo b_sg4TL :: *)))
             ww1_sg4TS)
          `cast` (Data.Semigroup.Internal.N:Endo[0] <b_sg4TL>_R
                  :: (Data.Semigroup.Internal.Endo b_sg4TL :: *)
                     ~R# (b_sg4TL -> b_sg4TL :: *)))
           w3_sg4TN)

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4TG :: * -> *))
                 (@ (g_sg4TH :: * -> *))
                 (w_sg4TI [Occ=Once] :: Foldable f_sg4TG)
                 (w1_sg4TJ [Occ=Once] :: Foldable g_sg4TH)
                 (@ a_sg4TK)
                 (@ b_sg4TL)
                 (w2_sg4TM [Occ=Once] :: a_sg4TK -> b_sg4TL -> b_sg4TL)
                 (w3_sg4TN [Occ=Once] :: b_sg4TL)
                 (w4_sg4TO [Occ=Once!] :: Product f_sg4TG g_sg4TH a_sg4TK) ->
                 case w4_sg4TO of
                 { Pair ww1_sg4TR [Occ=Once] ww2_sg4TS [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldr
                   @ f_sg4TG
                   @ g_sg4TH
                   w_sg4TI
                   w1_sg4TJ
                   @ a_sg4TK
                   @ b_sg4TL
                   w2_sg4TM
                   w3_sg4TN
                   ww1_sg4TR
                   ww2_sg4TS
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldr
  = \ (@ (f_sg4TG :: * -> *))
      (@ (g_sg4TH :: * -> *))
      (w_sg4TI :: Foldable f_sg4TG)
      (w1_sg4TJ :: Foldable g_sg4TH)
      (@ a_sg4TK)
      (@ b_sg4TL)
      (w2_sg4TM :: a_sg4TK -> b_sg4TL -> b_sg4TL)
      (w3_sg4TN :: b_sg4TL)
      (w4_sg4TO :: Product f_sg4TG g_sg4TH a_sg4TK) ->
      case w4_sg4TO of { Pair ww1_sg4TR ww2_sg4TS ->
      Data.Functor.Product.$w$cfoldr
        @ f_sg4TG
        @ g_sg4TH
        w_sg4TI
        w1_sg4TJ
        @ a_sg4TK
        @ b_sg4TL
        w2_sg4TM
        w3_sg4TN
        ww1_sg4TR
        ww2_sg4TS
      }

-- RHS size: {terms: 33, types: 49, coercions: 18, joins: 0/1}
Data.Functor.Product.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 230 0}]
Data.Functor.Product.$w$cfoldl'
  = \ (@ (f_sg4TV :: * -> *))
      (@ (g_sg4TW :: * -> *))
      (w_sg4TX :: Foldable f_sg4TV)
      (w1_sg4TY :: Foldable g_sg4TW)
      (@ b_sg4TZ)
      (@ a_sg4U0)
      (w2_sg4U1 :: b_sg4TZ -> a_sg4U0 -> b_sg4TZ)
      (w3_sg4U2 :: b_sg4TZ)
      (ww_sg4U6 :: f_sg4TV a_sg4U0)
      (ww1_sg4U7 :: g_sg4TW a_sg4U0) ->
      let {
        f1_sg4nu :: a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ
        [LclId,
         Arity=3,
         Str=<L,U><C(S),1*C1(U)><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_ifzES [Occ=Once] :: a_sg4U0)
                         (k_ifzET [Occ=Once!] :: b_sg4TZ -> b_sg4TZ)
                         (z_ifzEU [Occ=Once] :: b_sg4TZ) ->
                         case w2_sg4U1 z_ifzEU x_ifzES of vx_ifzEV { __DEFAULT ->
                         k_ifzET vx_ifzEV
                         }}]
        f1_sg4nu
          = \ (x_ifzES :: a_sg4U0)
              (k_ifzET :: b_sg4TZ -> b_sg4TZ)
              (z_ifzEU :: b_sg4TZ) ->
              case w2_sg4U1 z_ifzEU x_ifzES of vx_ifzEV { __DEFAULT ->
              k_ifzET vx_ifzEV
              } } in
      ((foldMap
          @ f_sg4TV
          w_sg4TX
          @ (Data.Semigroup.Internal.Endo (b_sg4TZ -> b_sg4TZ))
          @ a_sg4U0
          (Data.Semigroup.Internal.$fMonoidEndo @ (b_sg4TZ -> b_sg4TZ))
          (f1_sg4nu
           `cast` (<a_sg4U0>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b_sg4TZ -> b_sg4TZ>_R)
                   :: (a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ :: *)
                      ~R# (a_sg4U0
                           -> Data.Semigroup.Internal.Endo (b_sg4TZ -> b_sg4TZ) :: *)))
          ww_sg4U6)
       `cast` (Data.Semigroup.Internal.N:Endo[0] <b_sg4TZ -> b_sg4TZ>_R
               :: (Data.Semigroup.Internal.Endo (b_sg4TZ -> b_sg4TZ) :: *)
                  ~R# ((b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ :: *)))
        (((foldMap
             @ g_sg4TW
             w1_sg4TY
             @ (Data.Semigroup.Internal.Endo (b_sg4TZ -> b_sg4TZ))
             @ a_sg4U0
             (Data.Semigroup.Internal.$fMonoidEndo @ (b_sg4TZ -> b_sg4TZ))
             (f1_sg4nu
              `cast` (<a_sg4U0>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b_sg4TZ -> b_sg4TZ>_R)
                      :: (a_sg4U0 -> (b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ :: *)
                         ~R# (a_sg4U0
                              -> Data.Semigroup.Internal.Endo (b_sg4TZ -> b_sg4TZ) :: *)))
             ww1_sg4U7)
          `cast` (Data.Semigroup.Internal.N:Endo[0] <b_sg4TZ -> b_sg4TZ>_R
                  :: (Data.Semigroup.Internal.Endo (b_sg4TZ -> b_sg4TZ) :: *)
                     ~R# ((b_sg4TZ -> b_sg4TZ) -> b_sg4TZ -> b_sg4TZ :: *)))
           (id @ b_sg4TZ))
        w3_sg4U2

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> Product f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4TV :: * -> *))
                 (@ (g_sg4TW :: * -> *))
                 (w_sg4TX [Occ=Once] :: Foldable f_sg4TV)
                 (w1_sg4TY [Occ=Once] :: Foldable g_sg4TW)
                 (@ b_sg4TZ)
                 (@ a_sg4U0)
                 (w2_sg4U1 [Occ=Once] :: b_sg4TZ -> a_sg4U0 -> b_sg4TZ)
                 (w3_sg4U2 [Occ=Once] :: b_sg4TZ)
                 (w4_sg4U3 [Occ=Once!] :: Product f_sg4TV g_sg4TW a_sg4U0) ->
                 case w4_sg4U3 of
                 { Pair ww1_sg4U6 [Occ=Once] ww2_sg4U7 [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldl'
                   @ f_sg4TV
                   @ g_sg4TW
                   w_sg4TX
                   w1_sg4TY
                   @ b_sg4TZ
                   @ a_sg4U0
                   w2_sg4U1
                   w3_sg4U2
                   ww1_sg4U6
                   ww2_sg4U7
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldl'
  = \ (@ (f_sg4TV :: * -> *))
      (@ (g_sg4TW :: * -> *))
      (w_sg4TX :: Foldable f_sg4TV)
      (w1_sg4TY :: Foldable g_sg4TW)
      (@ b_sg4TZ)
      (@ a_sg4U0)
      (w2_sg4U1 :: b_sg4TZ -> a_sg4U0 -> b_sg4TZ)
      (w3_sg4U2 :: b_sg4TZ)
      (w4_sg4U3 :: Product f_sg4TV g_sg4TW a_sg4U0) ->
      case w4_sg4U3 of { Pair ww1_sg4U6 ww2_sg4U7 ->
      Data.Functor.Product.$w$cfoldl'
        @ f_sg4TV
        @ g_sg4TW
        w_sg4TX
        w1_sg4TY
        @ b_sg4TZ
        @ a_sg4U0
        w2_sg4U1
        w3_sg4U2
        ww1_sg4U6
        ww2_sg4U7
      }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct5
  :: forall a. Int -> a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ag41L) (c_ifzFN [Occ=Once!] :: Int) _ [Occ=Dead] ->
                 case c_ifzFN of { GHC.Types.I# x_ifzFR [Occ=Once] ->
                 GHC.Types.I# (GHC.Prim.+# x_ifzFR 1#)
                 }}]
Data.Functor.Product.$fFoldableProduct5
  = \ (@ a_ag41L) (c_ifzFN :: Int) _ [Occ=Dead] ->
      case c_ifzFN of { GHC.Types.I# x_ifzFR ->
      GHC.Types.I# (GHC.Prim.+# x_ifzFR 1#)
      }

-- RHS size: {terms: 16, types: 35, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Product f g a -> Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag400 :: * -> *))
                 (@ (g_ag401 :: * -> *))
                 ($dFoldable_ag402 [Occ=Once] :: Foldable f_ag400)
                 ($dFoldable1_ag403 [Occ=Once] :: Foldable g_ag401)
                 (@ a_ag41L)
                 (eta_B1 [Occ=Once] :: Product f_ag400 g_ag401 a_ag41L) ->
                 Data.Functor.Product.$fFoldableProduct_$cfoldl'
                   @ f_ag400
                   @ g_ag401
                   $dFoldable_ag402
                   $dFoldable1_ag403
                   @ Int
                   @ a_ag41L
                   (Data.Functor.Product.$fFoldableProduct5 @ a_ag41L)
                   Data.Functor.Product.$fFoldableProduct4
                   eta_B1}]
Data.Functor.Product.$fFoldableProduct_$clength
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag41L)
      (eta_B1 :: Product f_ag400 g_ag401 a_ag41L) ->
      case eta_B1 of { Pair ww1_sg4U6 ww2_sg4U7 ->
      Data.Functor.Product.$w$cfoldl'
        @ f_ag400
        @ g_ag401
        $dFoldable_ag402
        $dFoldable1_ag403
        @ Int
        @ a_ag41L
        (Data.Functor.Product.$fFoldableProduct5 @ a_ag41L)
        Data.Functor.Product.$fFoldableProduct4
        ww1_sg4U6
        ww2_sg4U7
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl3_rg5nZ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl3_rg5nZ = "foldr1: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct9 :: forall a. a
[GblId, Str=x]
Data.Functor.Product.$fFoldableProduct9
  = \ (@ a_ag41f) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_ag41f
        (GHC.CString.unpackCString# lvl3_rg5nZ)

-- RHS size: {terms: 36, types: 52, coercions: 18, joins: 0/1}
Data.Functor.Product.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 230 0}]
Data.Functor.Product.$w$cfoldr1
  = \ (@ (f_sg4Ua :: * -> *))
      (@ (g_sg4Ub :: * -> *))
      (w_sg4Uc :: Foldable f_sg4Ua)
      (w1_sg4Ud :: Foldable g_sg4Ub)
      (@ a_sg4Ue)
      (w2_sg4Uf :: a_sg4Ue -> a_sg4Ue -> a_sg4Ue)
      (ww_sg4Uj :: f_sg4Ua a_sg4Ue)
      (ww1_sg4Uk :: g_sg4Ub a_sg4Ue) ->
      let {
        w3_sg4TM :: a_sg4Ue -> Maybe a_sg4Ue -> Maybe a_sg4Ue
        [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []]
        w3_sg4TM
          = \ (x_ifzF1 :: a_sg4Ue) (m_ifzF2 :: Maybe a_sg4Ue) ->
              GHC.Base.Just
                @ a_sg4Ue
                (case m_ifzF2 of {
                   Nothing -> x_ifzF1;
                   Just y_ifzF7 -> w2_sg4Uf x_ifzF1 y_ifzF7
                 }) } in
      case ((foldMap
               @ f_sg4Ua
               w_sg4Uc
               @ (Data.Semigroup.Internal.Endo (Maybe a_sg4Ue))
               @ a_sg4Ue
               (Data.Semigroup.Internal.$fMonoidEndo @ (Maybe a_sg4Ue))
               (w3_sg4TM
                `cast` (<a_sg4Ue>_R
                        ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ue>_R)
                        :: (a_sg4Ue -> Maybe a_sg4Ue -> Maybe a_sg4Ue :: *)
                           ~R# (a_sg4Ue
                                -> Data.Semigroup.Internal.Endo (Maybe a_sg4Ue) :: *)))
               ww_sg4Uj)
            `cast` (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ue>_R
                    :: (Data.Semigroup.Internal.Endo (Maybe a_sg4Ue) :: *)
                       ~R# (Maybe a_sg4Ue -> Maybe a_sg4Ue :: *)))
             (((foldMap
                  @ g_sg4Ub
                  w1_sg4Ud
                  @ (Data.Semigroup.Internal.Endo (Maybe a_sg4Ue))
                  @ a_sg4Ue
                  (Data.Semigroup.Internal.$fMonoidEndo @ (Maybe a_sg4Ue))
                  (w3_sg4TM
                   `cast` (<a_sg4Ue>_R
                           ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ue>_R)
                           :: (a_sg4Ue -> Maybe a_sg4Ue -> Maybe a_sg4Ue :: *)
                              ~R# (a_sg4Ue
                                   -> Data.Semigroup.Internal.Endo (Maybe a_sg4Ue) :: *)))
                  ww1_sg4Uk)
               `cast` (Data.Semigroup.Internal.N:Endo[0] <Maybe a_sg4Ue>_R
                       :: (Data.Semigroup.Internal.Endo (Maybe a_sg4Ue) :: *)
                          ~R# (Maybe a_sg4Ue -> Maybe a_sg4Ue :: *)))
                (GHC.Base.Nothing @ a_sg4Ue))
      of {
        Nothing -> Data.Functor.Product.$fFoldableProduct9 @ a_sg4Ue;
        Just v_ifzFd -> v_ifzFd
      }

-- RHS size: {terms: 16, types: 36, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> Product f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Ua :: * -> *))
                 (@ (g_sg4Ub :: * -> *))
                 (w_sg4Uc [Occ=Once] :: Foldable f_sg4Ua)
                 (w1_sg4Ud [Occ=Once] :: Foldable g_sg4Ub)
                 (@ a_sg4Ue)
                 (w2_sg4Uf [Occ=Once] :: a_sg4Ue -> a_sg4Ue -> a_sg4Ue)
                 (w3_sg4Ug [Occ=Once!] :: Product f_sg4Ua g_sg4Ub a_sg4Ue) ->
                 case w3_sg4Ug of
                 { Pair ww1_sg4Uj [Occ=Once] ww2_sg4Uk [Occ=Once] ->
                 Data.Functor.Product.$w$cfoldr1
                   @ f_sg4Ua
                   @ g_sg4Ub
                   w_sg4Uc
                   w1_sg4Ud
                   @ a_sg4Ue
                   w2_sg4Uf
                   ww1_sg4Uj
                   ww2_sg4Uk
                 }}]
Data.Functor.Product.$fFoldableProduct_$cfoldr1
  = \ (@ (f_sg4Ua :: * -> *))
      (@ (g_sg4Ub :: * -> *))
      (w_sg4Uc :: Foldable f_sg4Ua)
      (w1_sg4Ud :: Foldable g_sg4Ub)
      (@ a_sg4Ue)
      (w2_sg4Uf :: a_sg4Ue -> a_sg4Ue -> a_sg4Ue)
      (w3_sg4Ug :: Product f_sg4Ua g_sg4Ub a_sg4Ue) ->
      case w3_sg4Ug of { Pair ww1_sg4Uj ww2_sg4Uk ->
      Data.Functor.Product.$w$cfoldr1
        @ f_sg4Ua
        @ g_sg4Ub
        w_sg4Uc
        w1_sg4Ud
        @ a_sg4Ue
        w2_sg4Uf
        ww1_sg4Uj
        ww2_sg4Uk
      }

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct6
  :: forall a. a -> Bool -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_ag41D) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False}]
Data.Functor.Product.$fFoldableProduct6
  = \ (@ a_ag41D) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 20, types: 42, coercions: 14, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Product f g a -> Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag400 :: * -> *))
                 (@ (g_ag401 :: * -> *))
                 ($dFoldable_ag402 [Occ=Once] :: Foldable f_ag400)
                 ($dFoldable1_ag403 [Occ=Once] :: Foldable g_ag401)
                 (@ a_ag41D)
                 (eta_B1 [Occ=Once] :: Product f_ag400 g_ag401 a_ag41D) ->
                 Data.Functor.Product.$fFoldableProduct_$cfoldr
                   @ f_ag400
                   @ g_ag401
                   $dFoldable_ag402
                   $dFoldable1_ag403
                   @ a_ag41D
                   @ Bool
                   (Data.Functor.Product.$fFoldableProduct6 @ a_ag41D)
                   GHC.Types.True
                   eta_B1}]
Data.Functor.Product.$fFoldableProduct_$cnull
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag41D)
      (eta_B1 :: Product f_ag400 g_ag401 a_ag41D) ->
      case eta_B1 of { Pair ww1_sg4TR ww2_sg4TS ->
      ((foldMap
          @ f_ag400
          $dFoldable_ag402
          @ (Data.Semigroup.Internal.Endo Bool)
          @ a_ag41D
          (Data.Semigroup.Internal.$fMonoidEndo @ Bool)
          ((Data.Functor.Product.$fFoldableProduct6 @ a_ag41D)
           `cast` (<a_ag41D>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <Bool>_R)
                   :: (a_ag41D -> Bool -> Bool :: *)
                      ~R# (a_ag41D -> Data.Semigroup.Internal.Endo Bool :: *)))
          ww1_sg4TR)
       `cast` (Data.Semigroup.Internal.N:Endo[0] <Bool>_R
               :: (Data.Semigroup.Internal.Endo Bool :: *)
                  ~R# (Bool -> Bool :: *)))
        (((foldMap
             @ g_ag401
             $dFoldable1_ag403
             @ (Data.Semigroup.Internal.Endo Bool)
             @ a_ag41D
             (Data.Semigroup.Internal.$fMonoidEndo @ Bool)
             ((Data.Functor.Product.$fFoldableProduct6 @ a_ag41D)
              `cast` (<a_ag41D>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <Bool>_R)
                      :: (a_ag41D -> Bool -> Bool :: *)
                         ~R# (a_ag41D -> Data.Semigroup.Internal.Endo Bool :: *)))
             ww2_sg4TS)
          `cast` (Data.Semigroup.Internal.N:Endo[0] <Bool>_R
                  :: (Data.Semigroup.Internal.Endo Bool :: *)
                     ~R# (Bool -> Bool :: *)))
           GHC.Types.True)
      }

-- RHS size: {terms: 25, types: 47, coercions: 26, joins: 0/1}
Data.Functor.Product.$fFoldableProduct_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => Product f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30] 190 60}]
Data.Functor.Product.$fFoldableProduct_$cproduct
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag42x)
      ($dNum_ag42z :: Num a_ag42x) ->
      let {
        $dMonoid_sg4ns :: Monoid (Data.Semigroup.Internal.Product a_ag42x)
        [LclId]
        $dMonoid_sg4ns
          = Data.Semigroup.Internal.$fMonoidProduct
              @ a_ag42x $dNum_ag42z } in
      (\ (ds_dg4ds :: Product f_ag400 g_ag401 a_ag42x) ->
         case ds_dg4ds of { Pair x_ag3EP y_ag3EQ ->
         (* @ a_ag42x
            $dNum_ag42z
            ((foldMap
                @ f_ag400
                $dFoldable_ag402
                @ (Data.Semigroup.Internal.Product a_ag42x)
                @ a_ag42x
                $dMonoid_sg4ns
                ((Data.Functor.Product.$fFoldableProduct1 @ a_ag42x)
                 `cast` (<a_ag42x>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_ag42x>_R)
                         :: (a_ag42x -> a_ag42x :: *)
                            ~R# (a_ag42x -> Data.Semigroup.Internal.Product a_ag42x :: *)))
                x_ag3EP)
             `cast` (Data.Semigroup.Internal.N:Product[0] <a_ag42x>_R
                     :: (Data.Semigroup.Internal.Product a_ag42x :: *)
                        ~R# (a_ag42x :: *)))
            ((foldMap
                @ g_ag401
                $dFoldable1_ag403
                @ (Data.Semigroup.Internal.Product a_ag42x)
                @ a_ag42x
                $dMonoid_sg4ns
                ((Data.Functor.Product.$fFoldableProduct1 @ a_ag42x)
                 `cast` (<a_ag42x>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_ag42x>_R)
                         :: (a_ag42x -> a_ag42x :: *)
                            ~R# (a_ag42x -> Data.Semigroup.Internal.Product a_ag42x :: *)))
                y_ag3EQ)
             `cast` (Data.Semigroup.Internal.N:Product[0] <a_ag42x>_R
                     :: (Data.Semigroup.Internal.Product a_ag42x :: *)
                        ~R# (a_ag42x :: *))))
         `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_ag42x>_R)
                 :: (a_ag42x :: *)
                    ~R# (Data.Semigroup.Internal.Product a_ag42x :: *))
         })
      `cast` (<Product f_ag400 g_ag401 a_ag42x>_R
              ->_R Data.Semigroup.Internal.N:Product[0] <a_ag42x>_R
              :: (Product f_ag400 g_ag401 a_ag42x
                  -> Data.Semigroup.Internal.Product a_ag42x :: *)
                 ~R# (Product f_ag400 g_ag401 a_ag42x -> a_ag42x :: *))

-- RHS size: {terms: 20, types: 47, coercions: 18, joins: 0/0}
Data.Functor.Product.$fFoldableProduct_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Product f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_ag400 :: * -> *))
                 (@ (g_ag401 :: * -> *))
                 ($dFoldable_ag402 [Occ=Once] :: Foldable f_ag400)
                 ($dFoldable1_ag403 [Occ=Once] :: Foldable g_ag401)
                 (@ a_ag41v)
                 (t1_ifzFB [Occ=Once] :: Product f_ag400 g_ag401 a_ag41v) ->
                 GHC.Base.build
                   @ a_ag41v
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once, OS=OneShot] :: a_ag41v -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      Data.Functor.Product.$fFoldableProduct_$cfoldr
                        @ f_ag400
                        @ g_ag401
                        $dFoldable_ag402
                        $dFoldable1_ag403
                        @ a_ag41v
                        @ b_ifzFC
                        c_ifzFD
                        n_ifzFE
                        t1_ifzFB)}]
Data.Functor.Product.$fFoldableProduct_$ctoList
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401)
      (@ a_ag41v)
      (eta_B1 :: Product f_ag400 g_ag401 a_ag41v) ->
      case eta_B1 of { Pair ww1_sg4TR ww2_sg4TS ->
      ((foldMap
          @ f_ag400
          $dFoldable_ag402
          @ (Data.Semigroup.Internal.Endo [a_ag41v])
          @ a_ag41v
          (Data.Semigroup.Internal.$fMonoidEndo @ [a_ag41v])
          ((GHC.Types.: @ a_ag41v)
           `cast` (<a_ag41v>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <[a_ag41v]>_R)
                   :: (a_ag41v -> [a_ag41v] -> [a_ag41v] :: *)
                      ~R# (a_ag41v -> Data.Semigroup.Internal.Endo [a_ag41v] :: *)))
          ww1_sg4TR)
       `cast` (Data.Semigroup.Internal.N:Endo[0] <[a_ag41v]>_R
               :: (Data.Semigroup.Internal.Endo [a_ag41v] :: *)
                  ~R# ([a_ag41v] -> [a_ag41v] :: *)))
        (((foldMap
             @ g_ag401
             $dFoldable1_ag403
             @ (Data.Semigroup.Internal.Endo [a_ag41v])
             @ a_ag41v
             (Data.Semigroup.Internal.$fMonoidEndo @ [a_ag41v])
             ((GHC.Types.: @ a_ag41v)
              `cast` (<a_ag41v>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <[a_ag41v]>_R)
                      :: (a_ag41v -> [a_ag41v] -> [a_ag41v] :: *)
                         ~R# (a_ag41v -> Data.Semigroup.Internal.Endo [a_ag41v] :: *)))
             ww2_sg4TS)
          `cast` (Data.Semigroup.Internal.N:Endo[0] <[a_ag41v]>_R
                  :: (Data.Semigroup.Internal.Endo [a_ag41v] :: *)
                     ~R# ([a_ag41v] -> [a_ag41v] :: *)))
           (GHC.Types.[] @ a_ag41v))
      }

-- RHS size: {terms: 53, types: 49, coercions: 0, joins: 0/0}
Data.Functor.Product.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     Foldable (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_ag3EM :: * -> *))
             (@ (g_ag3EN :: * -> *))
             (v_B1 :: Foldable f_ag3EM)
             (v1_B2 :: Foldable g_ag3EN) ->
       Data.Foldable.C:Foldable TYPE: Product f_ag3EM g_ag3EN
                                Data.Functor.Product.$fFoldableProduct_$cfold
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldMap
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldr
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldr'
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldl
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldl'
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldr1
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cfoldl1
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$ctoList
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cnull
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$clength
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$celem
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cmaximum
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cminimum
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$csum
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2
                                Data.Functor.Product.$fFoldableProduct_$cproduct
                                  @ f_ag3EM @ g_ag3EN v_B1 v1_B2]
Data.Functor.Product.$fFoldableProduct
  = \ (@ (f_ag400 :: * -> *))
      (@ (g_ag401 :: * -> *))
      ($dFoldable_ag402 :: Foldable f_ag400)
      ($dFoldable1_ag403 :: Foldable g_ag401) ->
      Data.Foldable.C:Foldable
        @ (Product f_ag400 g_ag401)
        (Data.Functor.Product.$fFoldableProduct_$cfold
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldMap
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldr
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldr'
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldl
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldl'
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldr1
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cfoldl1
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$ctoList
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cnull
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$clength
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$celem
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cmaximum
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cminimum
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$csum
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)
        (Data.Functor.Product.$fFoldableProduct_$cproduct
           @ f_ag400 @ g_ag401 $dFoldable_ag402 $dFoldable1_ag403)

-- RHS size: {terms: 24, types: 53, coercions: 0, joins: 0/0}
Data.Functor.Product.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> f a -> g a -> f1 (Product f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0] 150 0}]
Data.Functor.Product.$w$ctraverse
  = \ (@ (f_sg4Ut :: * -> *))
      (@ (g_sg4Uu :: * -> *))
      (w_sg4Uv :: Traversable f_sg4Ut)
      (w1_sg4Uw :: Traversable g_sg4Uu)
      (@ (f1_sg4Ux :: * -> *))
      (@ a_sg4Uy)
      (@ b_sg4Uz)
      (w2_sg4UA :: Applicative f1_sg4Ux)
      (w3_sg4UB :: a_sg4Uy -> f1_sg4Ux b_sg4Uz)
      (ww_sg4UF :: f_sg4Ut a_sg4Uy)
      (ww1_sg4UG :: g_sg4Uu a_sg4Uy) ->
      liftA2
        @ f1_sg4Ux
        w2_sg4UA
        @ (f_sg4Ut b_sg4Uz)
        @ (g_sg4Uu b_sg4Uz)
        @ (Product f_sg4Ut g_sg4Uu b_sg4Uz)
        (Data.Functor.Product.Pair @ * @ f_sg4Ut @ g_sg4Uu @ b_sg4Uz)
        (traverse
           @ f_sg4Ut
           w_sg4Uv
           @ f1_sg4Ux
           @ a_sg4Uy
           @ b_sg4Uz
           w2_sg4UA
           w3_sg4UB
           ww_sg4UF)
        (traverse
           @ g_sg4Uu
           w1_sg4Uw
           @ f1_sg4Ux
           @ a_sg4Uy
           @ b_sg4Uz
           w2_sg4UA
           w3_sg4UB
           ww1_sg4UG)

-- RHS size: {terms: 20, types: 46, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> Product f g a -> f1 (Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Ut :: * -> *))
                 (@ (g_sg4Uu :: * -> *))
                 (w_sg4Uv [Occ=Once] :: Traversable f_sg4Ut)
                 (w1_sg4Uw [Occ=Once] :: Traversable g_sg4Uu)
                 (@ (f1_sg4Ux :: * -> *))
                 (@ a_sg4Uy)
                 (@ b_sg4Uz)
                 (w2_sg4UA [Occ=Once] :: Applicative f1_sg4Ux)
                 (w3_sg4UB [Occ=Once] :: a_sg4Uy -> f1_sg4Ux b_sg4Uz)
                 (w4_sg4UC [Occ=Once!] :: Product f_sg4Ut g_sg4Uu a_sg4Uy) ->
                 case w4_sg4UC of
                 { Pair ww1_sg4UF [Occ=Once] ww2_sg4UG [Occ=Once] ->
                 Data.Functor.Product.$w$ctraverse
                   @ f_sg4Ut
                   @ g_sg4Uu
                   w_sg4Uv
                   w1_sg4Uw
                   @ f1_sg4Ux
                   @ a_sg4Uy
                   @ b_sg4Uz
                   w2_sg4UA
                   w3_sg4UB
                   ww1_sg4UF
                   ww2_sg4UG
                 }}]
Data.Functor.Product.$fTraversableProduct_$ctraverse
  = \ (@ (f_sg4Ut :: * -> *))
      (@ (g_sg4Uu :: * -> *))
      (w_sg4Uv :: Traversable f_sg4Ut)
      (w1_sg4Uw :: Traversable g_sg4Uu)
      (@ (f1_sg4Ux :: * -> *))
      (@ a_sg4Uy)
      (@ b_sg4Uz)
      (w2_sg4UA :: Applicative f1_sg4Ux)
      (w3_sg4UB :: a_sg4Uy -> f1_sg4Ux b_sg4Uz)
      (w4_sg4UC :: Product f_sg4Ut g_sg4Uu a_sg4Uy) ->
      case w4_sg4UC of { Pair ww1_sg4UF ww2_sg4UG ->
      Data.Functor.Product.$w$ctraverse
        @ f_sg4Ut
        @ g_sg4Uu
        w_sg4Uv
        w1_sg4Uw
        @ f1_sg4Ux
        @ a_sg4Uy
        @ b_sg4Uz
        w2_sg4UA
        w3_sg4UB
        ww1_sg4UF
        ww2_sg4UG
      }

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Foldable (Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3YG :: * -> *))
                 (@ (g_ag3YH :: * -> *))
                 ($dTraversable_ag3YI [Occ=Once] :: Traversable f_ag3YG)
                 ($dTraversable1_ag3YJ [Occ=Once] :: Traversable g_ag3YH) ->
                 Data.Functor.Product.$fFoldableProduct
                   @ f_ag3YG
                   @ g_ag3YH
                   (Data.Traversable.$p2Traversable @ f_ag3YG $dTraversable_ag3YI)
                   (Data.Traversable.$p2Traversable @ g_ag3YH $dTraversable1_ag3YJ)}]
Data.Functor.Product.$fTraversableProduct_$cp2Traversable
  = \ (@ (f_ag3YG :: * -> *))
      (@ (g_ag3YH :: * -> *))
      ($dTraversable_ag3YI :: Traversable f_ag3YG)
      ($dTraversable1_ag3YJ :: Traversable g_ag3YH) ->
      Data.Functor.Product.$fFoldableProduct
        @ f_ag3YG
        @ g_ag3YH
        (Data.Traversable.$p2Traversable @ f_ag3YG $dTraversable_ag3YI)
        (Data.Traversable.$p2Traversable @ g_ag3YH $dTraversable1_ag3YJ)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Functor (Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3YG :: * -> *))
                 (@ (g_ag3YH :: * -> *))
                 ($dTraversable_ag3YI [Occ=Once] :: Traversable f_ag3YG)
                 ($dTraversable1_ag3YJ [Occ=Once] :: Traversable g_ag3YH) ->
                 Data.Functor.Product.$fFunctorProduct
                   @ f_ag3YG
                   @ g_ag3YH
                   (Data.Traversable.$p1Traversable @ f_ag3YG $dTraversable_ag3YI)
                   (Data.Traversable.$p1Traversable @ g_ag3YH $dTraversable1_ag3YJ)}]
Data.Functor.Product.$fTraversableProduct_$cp1Traversable
  = \ (@ (f_ag3YG :: * -> *))
      (@ (g_ag3YH :: * -> *))
      ($dTraversable_ag3YI :: Traversable f_ag3YG)
      ($dTraversable1_ag3YJ :: Traversable g_ag3YH) ->
      Data.Functor.Product.$fFunctorProduct
        @ f_ag3YG
        @ g_ag3YH
        (Data.Traversable.$p1Traversable @ f_ag3YG $dTraversable_ag3YI)
        (Data.Traversable.$p1Traversable @ g_ag3YH $dTraversable1_ag3YJ)

-- RHS size: {terms: 18, types: 48, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a.
     Applicative f1 =>
     Product f g (f1 a) -> f1 (Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_ag3YG :: * -> *))
                 (@ (g_ag3YH :: * -> *))
                 ($dTraversable_ag3YI [Occ=Once] :: Traversable f_ag3YG)
                 ($dTraversable1_ag3YJ [Occ=Once] :: Traversable g_ag3YH)
                 (@ (f1_ag3Zp :: * -> *))
                 (@ a_ag3Zq)
                 ($dApplicative_ag3Zs [Occ=Once] :: Applicative f1_ag3Zp) ->
                 Data.Functor.Product.$fTraversableProduct_$ctraverse
                   @ f_ag3YG
                   @ g_ag3YH
                   $dTraversable_ag3YI
                   $dTraversable1_ag3YJ
                   @ f1_ag3Zp
                   @ (f1_ag3Zp a_ag3Zq)
                   @ a_ag3Zq
                   $dApplicative_ag3Zs
                   (id @ (f1_ag3Zp a_ag3Zq))}]
Data.Functor.Product.$fTraversableProduct_$csequenceA
  = \ (@ (f_ag3YG :: * -> *))
      (@ (g_ag3YH :: * -> *))
      ($dTraversable_ag3YI :: Traversable f_ag3YG)
      ($dTraversable1_ag3YJ :: Traversable g_ag3YH)
      (@ (f1_ag3Zp :: * -> *))
      (@ a_ag3Zq)
      ($dApplicative_ag3Zs :: Applicative f1_ag3Zp)
      (w_sg4UC :: Product f_ag3YG g_ag3YH (f1_ag3Zp a_ag3Zq)) ->
      case w_sg4UC of { Pair ww1_sg4UF ww2_sg4UG ->
      Data.Functor.Product.$w$ctraverse
        @ f_ag3YG
        @ g_ag3YH
        $dTraversable_ag3YI
        $dTraversable1_ag3YJ
        @ f1_ag3Zp
        @ (f1_ag3Zp a_ag3Zq)
        @ a_ag3Zq
        $dApplicative_ag3Zs
        (id @ (f1_ag3Zp a_ag3Zq))
        ww1_sg4UF
        ww2_sg4UG
      }

-- RHS size: {terms: 21, types: 47, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Product f g a -> m (Product f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_ag3YG :: * -> *))
                 (@ (g_ag3YH :: * -> *))
                 ($dTraversable_ag3YI [Occ=Once] :: Traversable f_ag3YG)
                 ($dTraversable1_ag3YJ [Occ=Once] :: Traversable g_ag3YH)
                 (@ (m_ag3ZB :: * -> *))
                 (@ a_ag3ZC)
                 (@ b_ag3ZD)
                 ($dMonad_ag3ZF [Occ=Once] :: Monad m_ag3ZB) ->
                 Data.Functor.Product.$fTraversableProduct_$ctraverse
                   @ f_ag3YG
                   @ g_ag3YH
                   $dTraversable_ag3YI
                   $dTraversable1_ag3YJ
                   @ m_ag3ZB
                   @ a_ag3ZC
                   @ b_ag3ZD
                   (GHC.Base.$p1Monad @ m_ag3ZB $dMonad_ag3ZF)}]
Data.Functor.Product.$fTraversableProduct_$cmapM
  = \ (@ (f_ag3YG :: * -> *))
      (@ (g_ag3YH :: * -> *))
      ($dTraversable_ag3YI :: Traversable f_ag3YG)
      ($dTraversable1_ag3YJ :: Traversable g_ag3YH)
      (@ (m_ag3ZB :: * -> *))
      (@ a_ag3ZC)
      (@ b_ag3ZD)
      ($dMonad_ag3ZF :: Monad m_ag3ZB)
      (eta_B2 :: a_ag3ZC -> m_ag3ZB b_ag3ZD)
      (eta1_B1 :: Product f_ag3YG g_ag3YH a_ag3ZC) ->
      case eta1_B1 of { Pair ww1_sg4UF ww2_sg4UG ->
      Data.Functor.Product.$w$ctraverse
        @ f_ag3YG
        @ g_ag3YH
        $dTraversable_ag3YI
        $dTraversable1_ag3YJ
        @ m_ag3ZB
        @ a_ag3ZC
        @ b_ag3ZD
        (GHC.Base.$p1Monad @ m_ag3ZB $dMonad_ag3ZF)
        eta_B2
        ww1_sg4UF
        ww2_sg4UG
      }

-- RHS size: {terms: 19, types: 49, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a.
     Monad m =>
     Product f g (m a) -> m (Product f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_ag3YG :: * -> *))
                 (@ (g_ag3YH :: * -> *))
                 ($dTraversable_ag3YI [Occ=Once] :: Traversable f_ag3YG)
                 ($dTraversable1_ag3YJ [Occ=Once] :: Traversable g_ag3YH)
                 (@ (m_ag3ZP :: * -> *))
                 (@ a_ag3ZQ)
                 ($dMonad_ag3ZS [Occ=Once] :: Monad m_ag3ZP) ->
                 Data.Functor.Product.$fTraversableProduct_$ctraverse
                   @ f_ag3YG
                   @ g_ag3YH
                   $dTraversable_ag3YI
                   $dTraversable1_ag3YJ
                   @ m_ag3ZP
                   @ (m_ag3ZP a_ag3ZQ)
                   @ a_ag3ZQ
                   (GHC.Base.$p1Monad @ m_ag3ZP $dMonad_ag3ZS)
                   (id @ (m_ag3ZP a_ag3ZQ))}]
Data.Functor.Product.$fTraversableProduct_$csequence
  = \ (@ (f_ag3YG :: * -> *))
      (@ (g_ag3YH :: * -> *))
      ($dTraversable_ag3YI :: Traversable f_ag3YG)
      ($dTraversable1_ag3YJ :: Traversable g_ag3YH)
      (@ (m_ag3ZP :: * -> *))
      (@ a_ag3ZQ)
      ($dMonad_ag3ZS :: Monad m_ag3ZP)
      (eta_B1 :: Product f_ag3YG g_ag3YH (m_ag3ZP a_ag3ZQ)) ->
      case eta_B1 of { Pair ww1_sg4UF ww2_sg4UG ->
      Data.Functor.Product.$w$ctraverse
        @ f_ag3YG
        @ g_ag3YH
        $dTraversable_ag3YI
        $dTraversable1_ag3YJ
        @ m_ag3ZP
        @ (m_ag3ZP a_ag3ZQ)
        @ a_ag3ZQ
        (GHC.Base.$p1Monad @ m_ag3ZP $dMonad_ag3ZS)
        (id @ (m_ag3ZP a_ag3ZQ))
        ww1_sg4UF
        ww2_sg4UG
      }

-- RHS size: {terms: 23, types: 29, coercions: 0, joins: 0/0}
Data.Functor.Product.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Traversable (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m,
 Unf=DFun: \ (@ (f_ag3EH :: * -> *))
             (@ (g_ag3EI :: * -> *))
             (v_B1 :: Traversable f_ag3EH)
             (v1_B2 :: Traversable g_ag3EI) ->
       Data.Traversable.C:Traversable TYPE: Product f_ag3EH g_ag3EI
                                      Data.Functor.Product.$fTraversableProduct_$cp1Traversable
                                        @ f_ag3EH @ g_ag3EI v_B1 v1_B2
                                      Data.Functor.Product.$fTraversableProduct_$cp2Traversable
                                        @ f_ag3EH @ g_ag3EI v_B1 v1_B2
                                      Data.Functor.Product.$fTraversableProduct_$ctraverse
                                        @ f_ag3EH @ g_ag3EI v_B1 v1_B2
                                      Data.Functor.Product.$fTraversableProduct_$csequenceA
                                        @ f_ag3EH @ g_ag3EI v_B1 v1_B2
                                      Data.Functor.Product.$fTraversableProduct_$cmapM
                                        @ f_ag3EH @ g_ag3EI v_B1 v1_B2
                                      Data.Functor.Product.$fTraversableProduct_$csequence
                                        @ f_ag3EH @ g_ag3EI v_B1 v1_B2]
Data.Functor.Product.$fTraversableProduct
  = \ (@ (f_ag3YG :: * -> *))
      (@ (g_ag3YH :: * -> *))
      ($dTraversable_ag3YI :: Traversable f_ag3YG)
      ($dTraversable1_ag3YJ :: Traversable g_ag3YH) ->
      Data.Traversable.C:Traversable
        @ (Product f_ag3YG g_ag3YH)
        (Data.Functor.Product.$fTraversableProduct_$cp1Traversable
           @ f_ag3YG @ g_ag3YH $dTraversable_ag3YI $dTraversable1_ag3YJ)
        (Data.Functor.Product.$fTraversableProduct_$cp2Traversable
           @ f_ag3YG @ g_ag3YH $dTraversable_ag3YI $dTraversable1_ag3YJ)
        (Data.Functor.Product.$fTraversableProduct_$ctraverse
           @ f_ag3YG @ g_ag3YH $dTraversable_ag3YI $dTraversable1_ag3YJ)
        (Data.Functor.Product.$fTraversableProduct_$csequenceA
           @ f_ag3YG @ g_ag3YH $dTraversable_ag3YI $dTraversable1_ag3YJ)
        (Data.Functor.Product.$fTraversableProduct_$cmapM
           @ f_ag3YG @ g_ag3YH $dTraversable_ag3YI $dTraversable1_ag3YJ)
        (Data.Functor.Product.$fTraversableProduct_$csequence
           @ f_ag3YG @ g_ag3YH $dTraversable_ag3YI $dTraversable1_ag3YJ)

-- RHS size: {terms: 27, types: 66, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     forall a b c.
     (a -> b -> c) -> Product f g a -> Product f g b -> Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4UJ :: * -> *))
                 (@ (g_sg4UK :: * -> *))
                 (w_sg4UL [Occ=Once] :: Applicative f_sg4UJ)
                 (w1_sg4UM [Occ=Once] :: Applicative g_sg4UK)
                 (@ a_sg4UN)
                 (@ b_sg4UO)
                 (@ c_sg4UP)
                 (w2_sg4UQ :: a_sg4UN -> b_sg4UO -> c_sg4UP)
                 (w3_sg4UR [Occ=Once!] :: Product f_sg4UJ g_sg4UK a_sg4UN)
                 (w4_sg4US [Occ=Once!] :: Product f_sg4UJ g_sg4UK b_sg4UO) ->
                 case w3_sg4UR of
                 { Pair ww1_sg4UV [Occ=Once] ww2_sg4UW [Occ=Once] ->
                 case w4_sg4US of
                 { Pair ww4_sg4V0 [Occ=Once] ww5_sg4V1 [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sg4UJ
                   @ g_sg4UK
                   @ c_sg4UP
                   (liftA2
                      @ f_sg4UJ
                      w_sg4UL
                      @ a_sg4UN
                      @ b_sg4UO
                      @ c_sg4UP
                      w2_sg4UQ
                      ww1_sg4UV
                      ww4_sg4V0)
                   (liftA2
                      @ g_sg4UK
                      w1_sg4UM
                      @ a_sg4UN
                      @ b_sg4UO
                      @ c_sg4UP
                      w2_sg4UQ
                      ww2_sg4UW
                      ww5_sg4V1)
                 }
                 }}]
Data.Functor.Product.$fApplicativeProduct_$cliftA2
  = \ (@ (f_sg4UJ :: * -> *))
      (@ (g_sg4UK :: * -> *))
      (w_sg4UL :: Applicative f_sg4UJ)
      (w1_sg4UM :: Applicative g_sg4UK)
      (@ a_sg4UN)
      (@ b_sg4UO)
      (@ c_sg4UP)
      (w2_sg4UQ :: a_sg4UN -> b_sg4UO -> c_sg4UP)
      (w3_sg4UR :: Product f_sg4UJ g_sg4UK a_sg4UN)
      (w4_sg4US :: Product f_sg4UJ g_sg4UK b_sg4UO) ->
      case w3_sg4UR of { Pair ww1_sg4UV ww2_sg4UW ->
      case w4_sg4US of { Pair ww4_sg4V0 ww5_sg4V1 ->
      Data.Functor.Product.Pair
        @ *
        @ f_sg4UJ
        @ g_sg4UK
        @ c_sg4UP
        (liftA2
           @ f_sg4UJ
           w_sg4UL
           @ a_sg4UN
           @ b_sg4UO
           @ c_sg4UP
           w2_sg4UQ
           ww1_sg4UV
           ww4_sg4V0)
        (liftA2
           @ g_sg4UK
           w1_sg4UM
           @ a_sg4UN
           @ b_sg4UO
           @ c_sg4UP
           w2_sg4UQ
           ww2_sg4UW
           ww5_sg4V1)
      }
      }

-- RHS size: {terms: 23, types: 63, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct_$c<*>
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     forall a b. Product f g (a -> b) -> Product f g a -> Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Xh :: * -> *))
                 (@ (g_ag3Xi :: * -> *))
                 ($dApplicative_ag3Xj [Occ=Once] :: Applicative f_ag3Xh)
                 ($dApplicative1_ag3Xk [Occ=Once] :: Applicative g_ag3Xi)
                 (@ a_ag3XI)
                 (@ b_ag3XJ)
                 (ds_dg4cW [Occ=Once!]
                    :: Product f_ag3Xh g_ag3Xi (a_ag3XI -> b_ag3XJ))
                 (ds1_dg4cX [Occ=Once!] :: Product f_ag3Xh g_ag3Xi a_ag3XI) ->
                 case ds_dg4cW of { Pair f1_ag3Ey [Occ=Once] g1_ag3Ez [Occ=Once] ->
                 case ds1_dg4cX of { Pair x_ag3EA [Occ=Once] y_ag3EB [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3Xh
                   @ g_ag3Xi
                   @ b_ag3XJ
                   (<*>
                      @ f_ag3Xh $dApplicative_ag3Xj @ a_ag3XI @ b_ag3XJ f1_ag3Ey x_ag3EA)
                   (<*>
                      @ g_ag3Xi
                      $dApplicative1_ag3Xk
                      @ a_ag3XI
                      @ b_ag3XJ
                      g1_ag3Ez
                      y_ag3EB)
                 }
                 }}]
Data.Functor.Product.$fApplicativeProduct_$c<*>
  = \ (@ (f_ag3Xh :: * -> *))
      (@ (g_ag3Xi :: * -> *))
      ($dApplicative_ag3Xj :: Applicative f_ag3Xh)
      ($dApplicative1_ag3Xk :: Applicative g_ag3Xi)
      (@ a_ag3XI)
      (@ b_ag3XJ)
      (ds_dg4cW :: Product f_ag3Xh g_ag3Xi (a_ag3XI -> b_ag3XJ))
      (ds1_dg4cX :: Product f_ag3Xh g_ag3Xi a_ag3XI) ->
      case ds_dg4cW of { Pair f1_ag3Ey g1_ag3Ez ->
      case ds1_dg4cX of { Pair x_ag3EA y_ag3EB ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Xh
        @ g_ag3Xi
        @ b_ag3XJ
        (<*>
           @ f_ag3Xh $dApplicative_ag3Xj @ a_ag3XI @ b_ag3XJ f1_ag3Ey x_ag3EA)
        (<*>
           @ g_ag3Xi
           $dApplicative1_ag3Xk
           @ a_ag3XI
           @ b_ag3XJ
           g1_ag3Ez
           y_ag3EB)
      }
      }

-- RHS size: {terms: 13, types: 24, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct_$cpure
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     forall a. a -> Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Xh :: * -> *))
                 (@ (g_ag3Xi :: * -> *))
                 ($dApplicative_ag3Xj [Occ=Once] :: Applicative f_ag3Xh)
                 ($dApplicative1_ag3Xk [Occ=Once] :: Applicative g_ag3Xi)
                 (@ a_ag3Xs)
                 (x_ag3Ex :: a_ag3Xs) ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3Xh
                   @ g_ag3Xi
                   @ a_ag3Xs
                   (pure @ f_ag3Xh $dApplicative_ag3Xj @ a_ag3Xs x_ag3Ex)
                   (pure @ g_ag3Xi $dApplicative1_ag3Xk @ a_ag3Xs x_ag3Ex)}]
Data.Functor.Product.$fApplicativeProduct_$cpure
  = \ (@ (f_ag3Xh :: * -> *))
      (@ (g_ag3Xi :: * -> *))
      ($dApplicative_ag3Xj :: Applicative f_ag3Xh)
      ($dApplicative1_ag3Xk :: Applicative g_ag3Xi)
      (@ a_ag3Xs)
      (x_ag3Ex :: a_ag3Xs) ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Xh
        @ g_ag3Xi
        @ a_ag3Xs
        (pure @ f_ag3Xh $dApplicative_ag3Xj @ a_ag3Xs x_ag3Ex)
        (pure @ g_ag3Xi $dApplicative1_ag3Xk @ a_ag3Xs x_ag3Ex)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     Functor (Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Xh :: * -> *))
                 (@ (g_ag3Xi :: * -> *))
                 ($dApplicative_ag3Xj [Occ=Once] :: Applicative f_ag3Xh)
                 ($dApplicative1_ag3Xk [Occ=Once] :: Applicative g_ag3Xi) ->
                 Data.Functor.Product.$fFunctorProduct
                   @ f_ag3Xh
                   @ g_ag3Xi
                   (GHC.Base.$p1Applicative @ f_ag3Xh $dApplicative_ag3Xj)
                   (GHC.Base.$p1Applicative @ g_ag3Xi $dApplicative1_ag3Xk)}]
Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
  = \ (@ (f_ag3Xh :: * -> *))
      (@ (g_ag3Xi :: * -> *))
      ($dApplicative_ag3Xj :: Applicative f_ag3Xh)
      ($dApplicative1_ag3Xk :: Applicative g_ag3Xi) ->
      Data.Functor.Product.$fFunctorProduct
        @ f_ag3Xh
        @ g_ag3Xi
        (GHC.Base.$p1Applicative @ f_ag3Xh $dApplicative_ag3Xj)
        (GHC.Base.$p1Applicative @ g_ag3Xi $dApplicative1_ag3Xk)

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct1
  :: forall a b. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_ag3Yn) (@ b_ag3Yo) _ [Occ=Dead] ->
                 GHC.Base.breakpoint @ b_ag3Yo}]
Data.Functor.Product.$fApplicativeProduct1
  = \ (@ a_ag3Yn) (@ b_ag3Yo) _ [Occ=Dead] ->
      GHC.Base.breakpoint @ b_ag3Yo

-- RHS size: {terms: 27, types: 50, coercions: 0, joins: 0/0}
Data.Functor.Product.$w$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     forall a b. f a -> g a -> f b -> g b -> (# f b, g b #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 0 0 0 0] 200 30}]
Data.Functor.Product.$w$c*>
  = \ (@ (f_sg4V7 :: * -> *))
      (@ (g_sg4V8 :: * -> *))
      (w_sg4V9 :: Applicative f_sg4V7)
      (w1_sg4Va :: Applicative g_sg4V8)
      (@ a_sg4Vb)
      (@ b_sg4Vc)
      (ww_sg4Vh :: f_sg4V7 a_sg4Vb)
      (ww1_sg4Vi :: g_sg4V8 a_sg4Vb)
      (ww2_sg4Vm :: f_sg4V7 b_sg4Vc)
      (ww3_sg4Vn :: g_sg4V8 b_sg4Vc) ->
      (# <*>
           @ f_sg4V7
           w_sg4V9
           @ b_sg4Vc
           @ b_sg4Vc
           (fmap
              @ f_sg4V7
              (GHC.Base.$p1Applicative @ f_sg4V7 w_sg4V9)
              @ a_sg4Vb
              @ (b_sg4Vc -> b_sg4Vc)
              (Data.Functor.Product.$fApplicativeProduct1 @ a_sg4Vb @ b_sg4Vc)
              ww_sg4Vh)
           ww2_sg4Vm,
         <*>
           @ g_sg4V8
           w1_sg4Va
           @ b_sg4Vc
           @ b_sg4Vc
           (fmap
              @ g_sg4V8
              (GHC.Base.$p1Applicative @ g_sg4V8 w1_sg4Va)
              @ a_sg4Vb
              @ (b_sg4Vc -> b_sg4Vc)
              (Data.Functor.Product.$fApplicativeProduct1 @ a_sg4Vb @ b_sg4Vc)
              ww1_sg4Vi)
           ww3_sg4Vn #)

-- RHS size: {terms: 26, types: 68, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     forall a b. Product f g a -> Product f g b -> Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4V7 :: * -> *))
                 (@ (g_sg4V8 :: * -> *))
                 (w_sg4V9 [Occ=Once] :: Applicative f_sg4V7)
                 (w1_sg4Va [Occ=Once] :: Applicative g_sg4V8)
                 (@ a_sg4Vb)
                 (@ b_sg4Vc)
                 (w2_sg4Vd [Occ=Once!] :: Product f_sg4V7 g_sg4V8 a_sg4Vb)
                 (w3_sg4Ve [Occ=Once!] :: Product f_sg4V7 g_sg4V8 b_sg4Vc) ->
                 case w2_sg4Vd of
                 { Pair ww1_sg4Vh [Occ=Once] ww2_sg4Vi [Occ=Once] ->
                 case w3_sg4Ve of
                 { Pair ww4_sg4Vm [Occ=Once] ww5_sg4Vn [Occ=Once] ->
                 case Data.Functor.Product.$w$c*>
                        @ f_sg4V7
                        @ g_sg4V8
                        w_sg4V9
                        w1_sg4Va
                        @ a_sg4Vb
                        @ b_sg4Vc
                        ww1_sg4Vh
                        ww2_sg4Vi
                        ww4_sg4Vm
                        ww5_sg4Vn
                 of
                 { (# ww7_sg4Yn [Occ=Once], ww8_sg4Yo [Occ=Once] #) ->
                 Data.Functor.Product.Pair
                   @ * @ f_sg4V7 @ g_sg4V8 @ b_sg4Vc ww7_sg4Yn ww8_sg4Yo
                 }
                 }
                 }}]
Data.Functor.Product.$fApplicativeProduct_$c*>
  = \ (@ (f_sg4V7 :: * -> *))
      (@ (g_sg4V8 :: * -> *))
      (w_sg4V9 :: Applicative f_sg4V7)
      (w1_sg4Va :: Applicative g_sg4V8)
      (@ a_sg4Vb)
      (@ b_sg4Vc)
      (w2_sg4Vd :: Product f_sg4V7 g_sg4V8 a_sg4Vb)
      (w3_sg4Ve :: Product f_sg4V7 g_sg4V8 b_sg4Vc) ->
      case w2_sg4Vd of { Pair ww1_sg4Vh ww2_sg4Vi ->
      case w3_sg4Ve of { Pair ww4_sg4Vm ww5_sg4Vn ->
      case Data.Functor.Product.$w$c*>
             @ f_sg4V7
             @ g_sg4V8
             w_sg4V9
             w1_sg4Va
             @ a_sg4Vb
             @ b_sg4Vc
             ww1_sg4Vh
             ww2_sg4Vi
             ww4_sg4Vm
             ww5_sg4Vn
      of
      { (# ww7_sg4Yn, ww8_sg4Yo #) ->
      Data.Functor.Product.Pair
        @ * @ f_sg4V7 @ g_sg4V8 @ b_sg4Vc ww7_sg4Yn ww8_sg4Yo
      }
      }
      }

-- RHS size: {terms: 25, types: 65, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct_$c<*
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     forall a b. Product f g a -> Product f g b -> Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Xh :: * -> *))
                 (@ (g_ag3Xi :: * -> *))
                 ($dApplicative_ag3Xj [Occ=Once] :: Applicative f_ag3Xh)
                 ($dApplicative1_ag3Xk [Occ=Once] :: Applicative g_ag3Xi)
                 (@ a_ag3Yx)
                 (@ b_ag3Yy) ->
                 Data.Functor.Product.$fApplicativeProduct_$cliftA2
                   @ f_ag3Xh
                   @ g_ag3Xi
                   $dApplicative_ag3Xj
                   $dApplicative1_ag3Xk
                   @ a_ag3Yx
                   @ b_ag3Yy
                   @ a_ag3Yx
                   (const @ a_ag3Yx @ b_ag3Yy)}]
Data.Functor.Product.$fApplicativeProduct_$c<*
  = \ (@ (f_ag3Xh :: * -> *))
      (@ (g_ag3Xi :: * -> *))
      ($dApplicative_ag3Xj :: Applicative f_ag3Xh)
      ($dApplicative1_ag3Xk :: Applicative g_ag3Xi)
      (@ a_ag3Yx)
      (@ b_ag3Yy)
      (w_sg4UR :: Product f_ag3Xh g_ag3Xi a_ag3Yx)
      (w1_sg4US :: Product f_ag3Xh g_ag3Xi b_ag3Yy) ->
      case w_sg4UR of { Pair ww1_sg4UV ww2_sg4UW ->
      case w1_sg4US of { Pair ww4_sg4V0 ww5_sg4V1 ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Xh
        @ g_ag3Xi
        @ a_ag3Yx
        (liftA2
           @ f_ag3Xh
           $dApplicative_ag3Xj
           @ a_ag3Yx
           @ b_ag3Yy
           @ a_ag3Yx
           (const @ a_ag3Yx @ b_ag3Yy)
           ww1_sg4UV
           ww4_sg4V0)
        (liftA2
           @ g_ag3Xi
           $dApplicative1_ag3Xk
           @ a_ag3Yx
           @ b_ag3Yy
           @ a_ag3Yx
           (const @ a_ag3Yx @ b_ag3Yy)
           ww2_sg4UW
           ww5_sg4V1)
      }
      }

-- RHS size: {terms: 23, types: 29, coercions: 0, joins: 0/0}
Data.Functor.Product.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Applicative f, Applicative g) =>
     Applicative (Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)><L,U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A)>m,
 Unf=DFun: \ (@ (f_ag3Ev :: * -> *))
             (@ (g_ag3Ew :: * -> *))
             (v_B1 :: Applicative f_ag3Ev)
             (v1_B2 :: Applicative g_ag3Ew) ->
       GHC.Base.C:Applicative TYPE: Product f_ag3Ev g_ag3Ew
                              Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
                                @ f_ag3Ev @ g_ag3Ew v_B1 v1_B2
                              Data.Functor.Product.$fApplicativeProduct_$cpure
                                @ f_ag3Ev @ g_ag3Ew v_B1 v1_B2
                              Data.Functor.Product.$fApplicativeProduct_$c<*>
                                @ f_ag3Ev @ g_ag3Ew v_B1 v1_B2
                              Data.Functor.Product.$fApplicativeProduct_$cliftA2
                                @ f_ag3Ev @ g_ag3Ew v_B1 v1_B2
                              Data.Functor.Product.$fApplicativeProduct_$c*>
                                @ f_ag3Ev @ g_ag3Ew v_B1 v1_B2
                              Data.Functor.Product.$fApplicativeProduct_$c<*
                                @ f_ag3Ev @ g_ag3Ew v_B1 v1_B2]
Data.Functor.Product.$fApplicativeProduct
  = \ (@ (f_ag3Xh :: * -> *))
      (@ (g_ag3Xi :: * -> *))
      ($dApplicative_ag3Xj :: Applicative f_ag3Xh)
      ($dApplicative1_ag3Xk :: Applicative g_ag3Xi) ->
      GHC.Base.C:Applicative
        @ (Product f_ag3Xh g_ag3Xi)
        (Data.Functor.Product.$fApplicativeProduct_$cp1Applicative
           @ f_ag3Xh @ g_ag3Xi $dApplicative_ag3Xj $dApplicative1_ag3Xk)
        (Data.Functor.Product.$fApplicativeProduct_$cpure
           @ f_ag3Xh @ g_ag3Xi $dApplicative_ag3Xj $dApplicative1_ag3Xk)
        (Data.Functor.Product.$fApplicativeProduct_$c<*>
           @ f_ag3Xh @ g_ag3Xi $dApplicative_ag3Xj $dApplicative1_ag3Xk)
        (Data.Functor.Product.$fApplicativeProduct_$cliftA2
           @ f_ag3Xh @ g_ag3Xi $dApplicative_ag3Xj $dApplicative1_ag3Xk)
        (Data.Functor.Product.$fApplicativeProduct_$c*>
           @ f_ag3Xh @ g_ag3Xi $dApplicative_ag3Xj $dApplicative1_ag3Xk)
        (Data.Functor.Product.$fApplicativeProduct_$c<*
           @ f_ag3Xh @ g_ag3Xi $dApplicative_ag3Xj $dApplicative1_ag3Xk)

-- RHS size: {terms: 22, types: 55, coercions: 0, joins: 0/0}
Data.Functor.Product.$fAlternativeProduct_$c<|>
  :: forall (f :: * -> *) (g :: * -> *).
     (Alternative f, Alternative g) =>
     forall a. Product f g a -> Product f g a -> Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A)><L,1*U(A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Wl :: * -> *))
                 (@ (g_ag3Wm :: * -> *))
                 ($dAlternative_ag3Wn [Occ=Once] :: Alternative f_ag3Wl)
                 ($dAlternative1_ag3Wo [Occ=Once] :: Alternative g_ag3Wm)
                 (@ a_ag3WM)
                 (ds_dg4cG [Occ=Once!] :: Product f_ag3Wl g_ag3Wm a_ag3WM)
                 (ds1_dg4cH [Occ=Once!] :: Product f_ag3Wl g_ag3Wm a_ag3WM) ->
                 case ds_dg4cG of { Pair x1_ag3Er [Occ=Once] y1_ag3Es [Occ=Once] ->
                 case ds1_dg4cH of { Pair x2_ag3Et [Occ=Once] y2_ag3Eu [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3Wl
                   @ g_ag3Wm
                   @ a_ag3WM
                   (<|> @ f_ag3Wl $dAlternative_ag3Wn @ a_ag3WM x1_ag3Er x2_ag3Et)
                   (<|> @ g_ag3Wm $dAlternative1_ag3Wo @ a_ag3WM y1_ag3Es y2_ag3Eu)
                 }
                 }}]
Data.Functor.Product.$fAlternativeProduct_$c<|>
  = \ (@ (f_ag3Wl :: * -> *))
      (@ (g_ag3Wm :: * -> *))
      ($dAlternative_ag3Wn :: Alternative f_ag3Wl)
      ($dAlternative1_ag3Wo :: Alternative g_ag3Wm)
      (@ a_ag3WM)
      (ds_dg4cG :: Product f_ag3Wl g_ag3Wm a_ag3WM)
      (ds1_dg4cH :: Product f_ag3Wl g_ag3Wm a_ag3WM) ->
      case ds_dg4cG of { Pair x1_ag3Er y1_ag3Es ->
      case ds1_dg4cH of { Pair x2_ag3Et y2_ag3Eu ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Wl
        @ g_ag3Wm
        @ a_ag3WM
        (<|> @ f_ag3Wl $dAlternative_ag3Wn @ a_ag3WM x1_ag3Er x2_ag3Et)
        (<|> @ g_ag3Wm $dAlternative1_ag3Wo @ a_ag3WM y1_ag3Es y2_ag3Eu)
      }
      }

-- RHS size: {terms: 10, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Product.$fAlternativeProduct_$cempty
  :: forall (f :: * -> *) (g :: * -> *).
     (Alternative f, Alternative g) =>
     forall a. Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A,A)><L,1*U(A,1*U,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Wl :: * -> *))
                 (@ (g_ag3Wm :: * -> *))
                 ($dAlternative_ag3Wn [Occ=Once] :: Alternative f_ag3Wl)
                 ($dAlternative1_ag3Wo [Occ=Once] :: Alternative g_ag3Wm)
                 (@ a_ag3Ww) ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3Wl
                   @ g_ag3Wm
                   @ a_ag3Ww
                   (empty @ f_ag3Wl $dAlternative_ag3Wn @ a_ag3Ww)
                   (empty @ g_ag3Wm $dAlternative1_ag3Wo @ a_ag3Ww)}]
Data.Functor.Product.$fAlternativeProduct_$cempty
  = \ (@ (f_ag3Wl :: * -> *))
      (@ (g_ag3Wm :: * -> *))
      ($dAlternative_ag3Wn :: Alternative f_ag3Wl)
      ($dAlternative1_ag3Wo :: Alternative g_ag3Wm)
      (@ a_ag3Ww) ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Wl
        @ g_ag3Wm
        @ a_ag3Ww
        (empty @ f_ag3Wl $dAlternative_ag3Wn @ a_ag3Ww)
        (empty @ g_ag3Wm $dAlternative1_ag3Wo @ a_ag3Ww)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (Alternative f, Alternative g) =>
     Applicative (Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Wl :: * -> *))
                 (@ (g_ag3Wm :: * -> *))
                 ($dAlternative_ag3Wn [Occ=Once] :: Alternative f_ag3Wl)
                 ($dAlternative1_ag3Wo [Occ=Once] :: Alternative g_ag3Wm) ->
                 Data.Functor.Product.$fApplicativeProduct
                   @ f_ag3Wl
                   @ g_ag3Wm
                   (GHC.Base.$p1Alternative @ f_ag3Wl $dAlternative_ag3Wn)
                   (GHC.Base.$p1Alternative @ g_ag3Wm $dAlternative1_ag3Wo)}]
Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
  = \ (@ (f_ag3Wl :: * -> *))
      (@ (g_ag3Wm :: * -> *))
      ($dAlternative_ag3Wn :: Alternative f_ag3Wl)
      ($dAlternative1_ag3Wo :: Alternative g_ag3Wm) ->
      Data.Functor.Product.$fApplicativeProduct
        @ f_ag3Wl
        @ g_ag3Wm
        (GHC.Base.$p1Alternative @ f_ag3Wl $dAlternative_ag3Wn)
        (GHC.Base.$p1Alternative @ g_ag3Wm $dAlternative1_ag3Wo)

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
poly_some_v_rg5o0
  :: forall (f :: * -> *) (g :: * -> *) a. Product f g [a]
[GblId, Str=b]
poly_some_v_rg5o0 = poly_some_v_rg5o0
end Rec }

-- RHS size: {terms: 10, types: 33, coercions: 0, joins: 0/0}
Data.Functor.Product.$fAlternativeProduct_$csome [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Alternative f, Alternative g) =>
     forall a. Product f g a -> Product f g [a]
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*H>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Vt :: * -> *))
                 (@ (g_sg4Vu :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ a_sg4Vx)
                 (w2_sg4Vy [Occ=Once!] :: Product f_sg4Vt g_sg4Vu a_sg4Vx) ->
                 case w2_sg4Vy of { Pair _ [Occ=Dead] _ [Occ=Dead] ->
                 joinrec {
                   some_v_sg4nk [Occ=LoopBreakerT[0]]
                     :: Product f_sg4Vt g_sg4Vu [a_sg4Vx]
                   [LclId[JoinId(0)], Str=b]
                   some_v_sg4nk = jump some_v_sg4nk; } in
                 jump some_v_sg4nk
                 }}]
Data.Functor.Product.$fAlternativeProduct_$csome
  = \ (@ (f_sg4Vt :: * -> *))
      (@ (g_sg4Vu :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ a_sg4Vx)
      (w2_sg4Vy :: Product f_sg4Vt g_sg4Vu a_sg4Vx) ->
      case w2_sg4Vy of { Pair ww1_sg4VB ww2_sg4VC ->
      poly_some_v_rg5o0 @ f_sg4Vt @ g_sg4Vu @ a_sg4Vx
      }

-- RHS size: {terms: 20, types: 27, coercions: 0, joins: 0/0}
Data.Functor.Product.$fAlternativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Alternative f, Alternative g) =>
     Alternative (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)><L,U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A)>m,
 Unf=DFun: \ (@ (f_ag3Ep :: * -> *))
             (@ (g_ag3Eq :: * -> *))
             (v_B1 :: Alternative f_ag3Ep)
             (v1_B2 :: Alternative g_ag3Eq) ->
       GHC.Base.C:Alternative TYPE: Product f_ag3Ep g_ag3Eq
                              Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
                                @ f_ag3Ep @ g_ag3Eq v_B1 v1_B2
                              Data.Functor.Product.$fAlternativeProduct_$cempty
                                @ f_ag3Ep @ g_ag3Eq v_B1 v1_B2
                              Data.Functor.Product.$fAlternativeProduct_$c<|>
                                @ f_ag3Ep @ g_ag3Eq v_B1 v1_B2
                              Data.Functor.Product.$fAlternativeProduct_$csome
                                @ f_ag3Ep @ g_ag3Eq v_B1 v1_B2
                              Data.Functor.Product.$fAlternativeProduct_$csome
                                @ f_ag3Ep @ g_ag3Eq v_B1 v1_B2]
Data.Functor.Product.$fAlternativeProduct
  = \ (@ (f_ag3Wl :: * -> *))
      (@ (g_ag3Wm :: * -> *))
      ($dAlternative_ag3Wn :: Alternative f_ag3Wl)
      ($dAlternative1_ag3Wo :: Alternative g_ag3Wm) ->
      GHC.Base.C:Alternative
        @ (Product f_ag3Wl g_ag3Wm)
        (Data.Functor.Product.$fAlternativeProduct_$cp1Alternative
           @ f_ag3Wl @ g_ag3Wm $dAlternative_ag3Wn $dAlternative1_ag3Wo)
        (Data.Functor.Product.$fAlternativeProduct_$cempty
           @ f_ag3Wl @ g_ag3Wm $dAlternative_ag3Wn $dAlternative1_ag3Wo)
        (Data.Functor.Product.$fAlternativeProduct_$c<|>
           @ f_ag3Wl @ g_ag3Wm $dAlternative_ag3Wn $dAlternative1_ag3Wo)
        (Data.Functor.Product.$fAlternativeProduct_$csome
           @ f_ag3Wl @ g_ag3Wm $dAlternative_ag3Wn $dAlternative1_ag3Wo)
        (Data.Functor.Product.$fAlternativeProduct_$csome
           @ f_ag3Wl @ g_ag3Wm $dAlternative_ag3Wn $dAlternative1_ag3Wo)

-- RHS size: {terms: 30, types: 72, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadProduct_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Monad f, Monad g) =>
     forall a b. Product f g a -> (a -> Product f g b) -> Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4VR :: * -> *))
                 (@ (g_sg4VS :: * -> *))
                 (w_sg4VT [Occ=Once] :: Monad f_sg4VR)
                 (w1_sg4VU [Occ=Once] :: Monad g_sg4VS)
                 (@ a_sg4VV)
                 (@ b_sg4VW)
                 (w2_sg4VX [Occ=Once!] :: Product f_sg4VR g_sg4VS a_sg4VV)
                 (w3_sg4VY :: a_sg4VV -> Product f_sg4VR g_sg4VS b_sg4VW) ->
                 case w2_sg4VX of
                 { Pair ww1_sg4W1 [Occ=Once] ww2_sg4W2 [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sg4VR
                   @ g_sg4VS
                   @ b_sg4VW
                   (>>=
                      @ f_sg4VR
                      w_sg4VT
                      @ a_sg4VV
                      @ b_sg4VW
                      ww1_sg4W1
                      (\ (x_i7Rxi [Occ=Once] :: a_sg4VV) ->
                         case w3_sg4VY x_i7Rxi of { Pair a1_ag3En [Occ=Once] _ [Occ=Dead] ->
                         a1_ag3En
                         }))
                   (>>=
                      @ g_sg4VS
                      w1_sg4VU
                      @ a_sg4VV
                      @ b_sg4VW
                      ww2_sg4W2
                      (\ (x_i7Rxi [Occ=Once] :: a_sg4VV) ->
                         case w3_sg4VY x_i7Rxi of { Pair _ [Occ=Dead] b1_ag3Eo [Occ=Once] ->
                         b1_ag3Eo
                         }))
                 }}]
Data.Functor.Product.$fMonadProduct_$c>>=
  = \ (@ (f_sg4VR :: * -> *))
      (@ (g_sg4VS :: * -> *))
      (w_sg4VT :: Monad f_sg4VR)
      (w1_sg4VU :: Monad g_sg4VS)
      (@ a_sg4VV)
      (@ b_sg4VW)
      (w2_sg4VX :: Product f_sg4VR g_sg4VS a_sg4VV)
      (w3_sg4VY :: a_sg4VV -> Product f_sg4VR g_sg4VS b_sg4VW) ->
      case w2_sg4VX of { Pair ww1_sg4W1 ww2_sg4W2 ->
      Data.Functor.Product.Pair
        @ *
        @ f_sg4VR
        @ g_sg4VS
        @ b_sg4VW
        (>>=
           @ f_sg4VR
           w_sg4VT
           @ a_sg4VV
           @ b_sg4VW
           ww1_sg4W1
           (\ (x_i7Rxi :: a_sg4VV) ->
              case w3_sg4VY x_i7Rxi of { Pair a1_ag3En ds_dg4cp -> a1_ag3En }))
        (>>=
           @ g_sg4VS
           w1_sg4VU
           @ a_sg4VV
           @ b_sg4VW
           ww2_sg4W2
           (\ (x_i7Rxi :: a_sg4VV) ->
              case w3_sg4VY x_i7Rxi of { Pair ds_dg4cA b1_ag3Eo -> b1_ag3Eo }))
      }

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadProduct_$cp1Monad
  :: forall (f :: * -> *) (g :: * -> *).
     (Monad f, Monad g) =>
     Applicative (Product f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Uu :: * -> *))
                 (@ (g_ag3Uv :: * -> *))
                 ($dMonad_ag3Uw [Occ=Once] :: Monad f_ag3Uu)
                 ($dMonad1_ag3Ux [Occ=Once] :: Monad g_ag3Uv) ->
                 Data.Functor.Product.$fApplicativeProduct
                   @ f_ag3Uu
                   @ g_ag3Uv
                   (GHC.Base.$p1Monad @ f_ag3Uu $dMonad_ag3Uw)
                   (GHC.Base.$p1Monad @ g_ag3Uv $dMonad1_ag3Ux)}]
Data.Functor.Product.$fMonadProduct_$cp1Monad
  = \ (@ (f_ag3Uu :: * -> *))
      (@ (g_ag3Uv :: * -> *))
      ($dMonad_ag3Uw :: Monad f_ag3Uu)
      ($dMonad1_ag3Ux :: Monad g_ag3Uv) ->
      Data.Functor.Product.$fApplicativeProduct
        @ f_ag3Uu
        @ g_ag3Uv
        (GHC.Base.$p1Monad @ f_ag3Uu $dMonad_ag3Uw)
        (GHC.Base.$p1Monad @ g_ag3Uv $dMonad1_ag3Ux)

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadProduct_$creturn [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Monad f, Monad g) =>
     forall a. a -> Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4W8 :: * -> *))
                 (@ (g_sg4W9 :: * -> *))
                 (w_sg4Wa [Occ=Once] :: Monad f_sg4W8)
                 (w1_sg4Wb [Occ=Once] :: Monad g_sg4W9)
                 (@ a_sg4Wc)
                 (w2_sg4Wd :: a_sg4Wc) ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sg4W8
                   @ g_sg4W9
                   @ a_sg4Wc
                   (pure
                      @ f_sg4W8 (GHC.Base.$p1Monad @ f_sg4W8 w_sg4Wa) @ a_sg4Wc w2_sg4Wd)
                   (pure
                      @ g_sg4W9
                      (GHC.Base.$p1Monad @ g_sg4W9 w1_sg4Wb)
                      @ a_sg4Wc
                      w2_sg4Wd)}]
Data.Functor.Product.$fMonadProduct_$creturn
  = \ (@ (f_sg4W8 :: * -> *))
      (@ (g_sg4W9 :: * -> *))
      (w_sg4Wa :: Monad f_sg4W8)
      (w1_sg4Wb :: Monad g_sg4W9)
      (@ a_sg4Wc)
      (w2_sg4Wd :: a_sg4Wc) ->
      Data.Functor.Product.Pair
        @ *
        @ f_sg4W8
        @ g_sg4W9
        @ a_sg4Wc
        (pure
           @ f_sg4W8 (GHC.Base.$p1Monad @ f_sg4W8 w_sg4Wa) @ a_sg4Wc w2_sg4Wd)
        (pure
           @ g_sg4W9
           (GHC.Base.$p1Monad @ g_sg4W9 w1_sg4Wb)
           @ a_sg4Wc
           w2_sg4Wd)

-- RHS size: {terms: 28, types: 71, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Monad f, Monad g) =>
     forall a b. Product f g a -> Product f g b -> Product f g b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_ag3Uu :: * -> *))
                 (@ (g_ag3Uv :: * -> *))
                 ($dMonad_ag3Uw [Occ=Once] :: Monad f_ag3Uu)
                 ($dMonad1_ag3Ux [Occ=Once] :: Monad g_ag3Uv)
                 (@ a_ag3VW)
                 (@ b_ag3VX)
                 (m1_ibJeL [Occ=Once!] :: Product f_ag3Uu g_ag3Uv a_ag3VW)
                 (k_ibJeM :: Product f_ag3Uu g_ag3Uv b_ag3VX) ->
                 case m1_ibJeL of { Pair m_ag3Ei [Occ=Once] n_ag3Ej [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3Uu
                   @ g_ag3Uv
                   @ b_ag3VX
                   (>>=
                      @ f_ag3Uu
                      $dMonad_ag3Uw
                      @ a_ag3VW
                      @ b_ag3VX
                      m_ag3Ei
                      (\ _ [Occ=Dead] ->
                         case k_ibJeM of { Pair a1_ag3En [Occ=Once] _ [Occ=Dead] ->
                         a1_ag3En
                         }))
                   (>>=
                      @ g_ag3Uv
                      $dMonad1_ag3Ux
                      @ a_ag3VW
                      @ b_ag3VX
                      n_ag3Ej
                      (\ _ [Occ=Dead] ->
                         case k_ibJeM of { Pair _ [Occ=Dead] b1_ag3Eo [Occ=Once] ->
                         b1_ag3Eo
                         }))
                 }}]
Data.Functor.Product.$fMonadProduct_$c>>
  = \ (@ (f_ag3Uu :: * -> *))
      (@ (g_ag3Uv :: * -> *))
      ($dMonad_ag3Uw :: Monad f_ag3Uu)
      ($dMonad1_ag3Ux :: Monad g_ag3Uv)
      (@ a_ag3VW)
      (@ b_ag3VX)
      (eta_B2 :: Product f_ag3Uu g_ag3Uv a_ag3VW)
      (eta1_B1 :: Product f_ag3Uu g_ag3Uv b_ag3VX) ->
      case eta_B2 of { Pair m_ag3Ei n_ag3Ej ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Uu
        @ g_ag3Uv
        @ b_ag3VX
        (>>=
           @ f_ag3Uu
           $dMonad_ag3Uw
           @ a_ag3VW
           @ b_ag3VX
           m_ag3Ei
           (\ _ [Occ=Dead] ->
              case eta1_B1 of { Pair a1_ag3En ds_dg4cp -> a1_ag3En }))
        (>>=
           @ g_ag3Uv
           $dMonad1_ag3Ux
           @ a_ag3VW
           @ b_ag3VX
           n_ag3Ej
           (\ _ [Occ=Dead] ->
              case eta1_B1 of { Pair ds_dg4cA b1_ag3Eo -> b1_ag3Eo }))
      }

-- RHS size: {terms: 6, types: 19, coercions: 0, joins: 0/0}
lvl4_rg5o1
  :: forall (f :: * -> *) (g :: * -> *) a. [Char] -> Product f g a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl4_rg5o1
  = \ (@ (f_ag3Uu :: * -> *))
      (@ (g_ag3Uv :: * -> *))
      (@ a_ag3We)
      (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Product f_ag3Uu g_ag3Uv a_ag3We) eta_B1

-- RHS size: {terms: 18, types: 27, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Monad f, Monad g) =>
     Monad (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)><L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>m,
 Unf=DFun: \ (@ (f_ag3Eg :: * -> *))
             (@ (g_ag3Eh :: * -> *))
             (v_B1 :: Monad f_ag3Eg)
             (v1_B2 :: Monad g_ag3Eh) ->
       GHC.Base.C:Monad TYPE: Product f_ag3Eg g_ag3Eh
                        Data.Functor.Product.$fMonadProduct_$cp1Monad
                          @ f_ag3Eg @ g_ag3Eh v_B1 v1_B2
                        Data.Functor.Product.$fMonadProduct_$c>>=
                          @ f_ag3Eg @ g_ag3Eh v_B1 v1_B2
                        Data.Functor.Product.$fMonadProduct_$c>>
                          @ f_ag3Eg @ g_ag3Eh v_B1 v1_B2
                        Data.Functor.Product.$fMonadProduct_$creturn
                          @ f_ag3Eg @ g_ag3Eh v_B1 v1_B2
                        \ (@ a_ag3We) ->
                          errorWithoutStackTrace
                            @ 'GHC.Types.LiftedRep @ (Product f_ag3Eg g_ag3Eh a_ag3We)]
Data.Functor.Product.$fMonadProduct
  = \ (@ (f_ag3Uu :: * -> *))
      (@ (g_ag3Uv :: * -> *))
      ($dMonad_ag3Uw :: Monad f_ag3Uu)
      ($dMonad1_ag3Ux :: Monad g_ag3Uv) ->
      GHC.Base.C:Monad
        @ (Product f_ag3Uu g_ag3Uv)
        (Data.Functor.Product.$fMonadProduct_$cp1Monad
           @ f_ag3Uu @ g_ag3Uv $dMonad_ag3Uw $dMonad1_ag3Ux)
        (Data.Functor.Product.$fMonadProduct_$c>>=
           @ f_ag3Uu @ g_ag3Uv $dMonad_ag3Uw $dMonad1_ag3Ux)
        (Data.Functor.Product.$fMonadProduct_$c>>
           @ f_ag3Uu @ g_ag3Uv $dMonad_ag3Uw $dMonad1_ag3Ux)
        (Data.Functor.Product.$fMonadProduct_$creturn
           @ f_ag3Uu @ g_ag3Uv $dMonad_ag3Uw $dMonad1_ag3Ux)
        (lvl4_rg5o1 @ f_ag3Uu @ g_ag3Uv)

-- RHS size: {terms: 22, types: 55, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadPlusProduct_$cmplus
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadPlus f, MonadPlus g) =>
     forall a. Product f g a -> Product f g a -> Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)))><L,1*U(A,A,A,1*C1(C1(U)))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3TK :: * -> *))
                 (@ (g_ag3TL :: * -> *))
                 ($dMonadPlus_ag3TM [Occ=Once] :: MonadPlus f_ag3TK)
                 ($dMonadPlus1_ag3TN [Occ=Once] :: MonadPlus g_ag3TL)
                 (@ a_ag3Uf)
                 (ds_dg4bL [Occ=Once!] :: Product f_ag3TK g_ag3TL a_ag3Uf)
                 (ds1_dg4bM [Occ=Once!] :: Product f_ag3TK g_ag3TL a_ag3Uf) ->
                 case ds_dg4bL of { Pair x1_ag3Ec [Occ=Once] y1_ag3Ed [Occ=Once] ->
                 case ds1_dg4bM of { Pair x2_ag3Ee [Occ=Once] y2_ag3Ef [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3TK
                   @ g_ag3TL
                   @ a_ag3Uf
                   (mplus @ f_ag3TK $dMonadPlus_ag3TM @ a_ag3Uf x1_ag3Ec x2_ag3Ee)
                   (mplus @ g_ag3TL $dMonadPlus1_ag3TN @ a_ag3Uf y1_ag3Ed y2_ag3Ef)
                 }
                 }}]
Data.Functor.Product.$fMonadPlusProduct_$cmplus
  = \ (@ (f_ag3TK :: * -> *))
      (@ (g_ag3TL :: * -> *))
      ($dMonadPlus_ag3TM :: MonadPlus f_ag3TK)
      ($dMonadPlus1_ag3TN :: MonadPlus g_ag3TL)
      (@ a_ag3Uf)
      (ds_dg4bL :: Product f_ag3TK g_ag3TL a_ag3Uf)
      (ds1_dg4bM :: Product f_ag3TK g_ag3TL a_ag3Uf) ->
      case ds_dg4bL of { Pair x1_ag3Ec y1_ag3Ed ->
      case ds1_dg4bM of { Pair x2_ag3Ee y2_ag3Ef ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3TK
        @ g_ag3TL
        @ a_ag3Uf
        (mplus @ f_ag3TK $dMonadPlus_ag3TM @ a_ag3Uf x1_ag3Ec x2_ag3Ee)
        (mplus @ g_ag3TL $dMonadPlus1_ag3TN @ a_ag3Uf y1_ag3Ed y2_ag3Ef)
      }
      }

-- RHS size: {terms: 10, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadPlusProduct_$cmzero
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadPlus f, MonadPlus g) =>
     forall a. Product f g a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*U,A)><L,1*U(A,A,1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3TK :: * -> *))
                 (@ (g_ag3TL :: * -> *))
                 ($dMonadPlus_ag3TM [Occ=Once] :: MonadPlus f_ag3TK)
                 ($dMonadPlus1_ag3TN [Occ=Once] :: MonadPlus g_ag3TL)
                 (@ a_ag3TZ) ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_ag3TK
                   @ g_ag3TL
                   @ a_ag3TZ
                   (mzero @ f_ag3TK $dMonadPlus_ag3TM @ a_ag3TZ)
                   (mzero @ g_ag3TL $dMonadPlus1_ag3TN @ a_ag3TZ)}]
Data.Functor.Product.$fMonadPlusProduct_$cmzero
  = \ (@ (f_ag3TK :: * -> *))
      (@ (g_ag3TL :: * -> *))
      ($dMonadPlus_ag3TM :: MonadPlus f_ag3TK)
      ($dMonadPlus1_ag3TN :: MonadPlus g_ag3TL)
      (@ a_ag3TZ) ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3TK
        @ g_ag3TL
        @ a_ag3TZ
        (mzero @ f_ag3TK $dMonadPlus_ag3TM @ a_ag3TZ)
        (mzero @ g_ag3TL $dMonadPlus1_ag3TN @ a_ag3TZ)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadPlus f, MonadPlus g) =>
     Monad (Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)><L,1*U(A,1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3TK :: * -> *))
                 (@ (g_ag3TL :: * -> *))
                 ($dMonadPlus_ag3TM [Occ=Once] :: MonadPlus f_ag3TK)
                 ($dMonadPlus1_ag3TN [Occ=Once] :: MonadPlus g_ag3TL) ->
                 Data.Functor.Product.$fMonadProduct
                   @ f_ag3TK
                   @ g_ag3TL
                   (GHC.Base.$p2MonadPlus @ f_ag3TK $dMonadPlus_ag3TM)
                   (GHC.Base.$p2MonadPlus @ g_ag3TL $dMonadPlus1_ag3TN)}]
Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
  = \ (@ (f_ag3TK :: * -> *))
      (@ (g_ag3TL :: * -> *))
      ($dMonadPlus_ag3TM :: MonadPlus f_ag3TK)
      ($dMonadPlus1_ag3TN :: MonadPlus g_ag3TL) ->
      Data.Functor.Product.$fMonadProduct
        @ f_ag3TK
        @ g_ag3TL
        (GHC.Base.$p2MonadPlus @ f_ag3TK $dMonadPlus_ag3TM)
        (GHC.Base.$p2MonadPlus @ g_ag3TL $dMonadPlus1_ag3TN)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadPlus f, MonadPlus g) =>
     Alternative (Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3TK :: * -> *))
                 (@ (g_ag3TL :: * -> *))
                 ($dMonadPlus_ag3TM [Occ=Once] :: MonadPlus f_ag3TK)
                 ($dMonadPlus1_ag3TN [Occ=Once] :: MonadPlus g_ag3TL) ->
                 Data.Functor.Product.$fAlternativeProduct
                   @ f_ag3TK
                   @ g_ag3TL
                   (GHC.Base.$p1MonadPlus @ f_ag3TK $dMonadPlus_ag3TM)
                   (GHC.Base.$p1MonadPlus @ g_ag3TL $dMonadPlus1_ag3TN)}]
Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
  = \ (@ (f_ag3TK :: * -> *))
      (@ (g_ag3TL :: * -> *))
      ($dMonadPlus_ag3TM :: MonadPlus f_ag3TK)
      ($dMonadPlus1_ag3TN :: MonadPlus g_ag3TL) ->
      Data.Functor.Product.$fAlternativeProduct
        @ f_ag3TK
        @ g_ag3TL
        (GHC.Base.$p1MonadPlus @ f_ag3TK $dMonadPlus_ag3TM)
        (GHC.Base.$p1MonadPlus @ g_ag3TL $dMonadPlus1_ag3TN)

-- RHS size: {terms: 17, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadPlusProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadPlus f, MonadPlus g) =>
     MonadPlus (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))><L,U(1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),1*U,C(C1(U)),A,A),1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),1*U,C(C1(U)))>m,
 Unf=DFun: \ (@ (f_ag3Ea :: * -> *))
             (@ (g_ag3Eb :: * -> *))
             (v_B1 :: MonadPlus f_ag3Ea)
             (v1_B2 :: MonadPlus g_ag3Eb) ->
       GHC.Base.C:MonadPlus TYPE: Product f_ag3Ea g_ag3Eb
                            Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
                              @ f_ag3Ea @ g_ag3Eb v_B1 v1_B2
                            Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
                              @ f_ag3Ea @ g_ag3Eb v_B1 v1_B2
                            Data.Functor.Product.$fMonadPlusProduct_$cmzero
                              @ f_ag3Ea @ g_ag3Eb v_B1 v1_B2
                            Data.Functor.Product.$fMonadPlusProduct_$cmplus
                              @ f_ag3Ea @ g_ag3Eb v_B1 v1_B2]
Data.Functor.Product.$fMonadPlusProduct
  = \ (@ (f_ag3TK :: * -> *))
      (@ (g_ag3TL :: * -> *))
      ($dMonadPlus_ag3TM :: MonadPlus f_ag3TK)
      ($dMonadPlus1_ag3TN :: MonadPlus g_ag3TL) ->
      GHC.Base.C:MonadPlus
        @ (Product f_ag3TK g_ag3TL)
        (Data.Functor.Product.$fMonadPlusProduct_$cp1MonadPlus
           @ f_ag3TK @ g_ag3TL $dMonadPlus_ag3TM $dMonadPlus1_ag3TN)
        (Data.Functor.Product.$fMonadPlusProduct_$cp2MonadPlus
           @ f_ag3TK @ g_ag3TL $dMonadPlus_ag3TM $dMonadPlus1_ag3TN)
        (Data.Functor.Product.$fMonadPlusProduct_$cmzero
           @ f_ag3TK @ g_ag3TL $dMonadPlus_ag3TM $dMonadPlus1_ag3TN)
        (Data.Functor.Product.$fMonadPlusProduct_$cmplus
           @ f_ag3TK @ g_ag3TL $dMonadPlus_ag3TM $dMonadPlus1_ag3TN)

-- RHS size: {terms: 23, types: 52, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadFixProduct_$cmfix [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadFix f, MonadFix g) =>
     forall a. (a -> Product f g a) -> Product f g a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U))><L,1*U(A,1*C1(U))><L,C(U(1*U,1*U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Wi :: * -> *))
                 (@ (g_sg4Wj :: * -> *))
                 (w_sg4Wk [Occ=Once] :: MonadFix f_sg4Wi)
                 (w1_sg4Wl [Occ=Once] :: MonadFix g_sg4Wj)
                 (@ a_sg4Wm)
                 (w2_sg4Wn :: a_sg4Wm -> Product f_sg4Wi g_sg4Wj a_sg4Wm) ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sg4Wi
                   @ g_sg4Wj
                   @ a_sg4Wm
                   (mfix
                      @ f_sg4Wi
                      w_sg4Wk
                      @ a_sg4Wm
                      (\ (x_i7Rxi [Occ=Once] :: a_sg4Wm) ->
                         case w2_sg4Wn x_i7Rxi of { Pair a1_ag3E8 [Occ=Once] _ [Occ=Dead] ->
                         a1_ag3E8
                         }))
                   (mfix
                      @ g_sg4Wj
                      w1_sg4Wl
                      @ a_sg4Wm
                      (\ (x_i7Rxi [Occ=Once] :: a_sg4Wm) ->
                         case w2_sg4Wn x_i7Rxi of { Pair _ [Occ=Dead] b_ag3E9 [Occ=Once] ->
                         b_ag3E9
                         }))}]
Data.Functor.Product.$fMonadFixProduct_$cmfix
  = \ (@ (f_sg4Wi :: * -> *))
      (@ (g_sg4Wj :: * -> *))
      (w_sg4Wk :: MonadFix f_sg4Wi)
      (w1_sg4Wl :: MonadFix g_sg4Wj)
      (@ a_sg4Wm)
      (w2_sg4Wn :: a_sg4Wm -> Product f_sg4Wi g_sg4Wj a_sg4Wm) ->
      Data.Functor.Product.Pair
        @ *
        @ f_sg4Wi
        @ g_sg4Wj
        @ a_sg4Wm
        (mfix
           @ f_sg4Wi
           w_sg4Wk
           @ a_sg4Wm
           (\ (x_i7Rxi :: a_sg4Wm) ->
              case w2_sg4Wn x_i7Rxi of { Pair a1_ag3E8 ds_dg4bk -> a1_ag3E8 }))
        (mfix
           @ g_sg4Wj
           w1_sg4Wl
           @ a_sg4Wm
           (\ (x_i7Rxi :: a_sg4Wm) ->
              case w2_sg4Wn x_i7Rxi of { Pair ds_dg4bx b_ag3E9 -> b_ag3E9 }))

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadFix f, MonadFix g) =>
     Monad (Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Sm :: * -> *))
                 (@ (g_ag3Sn :: * -> *))
                 ($dMonadFix_ag3So [Occ=Once] :: MonadFix f_ag3Sm)
                 ($dMonadFix1_ag3Sp [Occ=Once] :: MonadFix g_ag3Sn) ->
                 Data.Functor.Product.$fMonadProduct
                   @ f_ag3Sm
                   @ g_ag3Sn
                   (Control.Monad.Fix.$p1MonadFix @ f_ag3Sm $dMonadFix_ag3So)
                   (Control.Monad.Fix.$p1MonadFix @ g_ag3Sn $dMonadFix1_ag3Sp)}]
Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
  = \ (@ (f_ag3Sm :: * -> *))
      (@ (g_ag3Sn :: * -> *))
      ($dMonadFix_ag3So :: MonadFix f_ag3Sm)
      ($dMonadFix1_ag3Sp :: MonadFix g_ag3Sn) ->
      Data.Functor.Product.$fMonadProduct
        @ f_ag3Sm
        @ g_ag3Sn
        (Control.Monad.Fix.$p1MonadFix @ f_ag3Sm $dMonadFix_ag3So)
        (Control.Monad.Fix.$p1MonadFix @ g_ag3Sn $dMonadFix1_ag3Sp)

-- RHS size: {terms: 11, types: 21, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadFixProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadFix f, MonadFix g) =>
     MonadFix (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))><L,U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),C(U))>m,
 Unf=DFun: \ (@ (f_ag3E3 :: * -> *))
             (@ (g_ag3E4 :: * -> *))
             (v_B1 :: MonadFix f_ag3E3)
             (v1_B2 :: MonadFix g_ag3E4) ->
       Control.Monad.Fix.C:MonadFix TYPE: Product f_ag3E3 g_ag3E4
                                    Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
                                      @ f_ag3E3 @ g_ag3E4 v_B1 v1_B2
                                    Data.Functor.Product.$fMonadFixProduct_$cmfix
                                      @ f_ag3E3 @ g_ag3E4 v_B1 v1_B2]
Data.Functor.Product.$fMonadFixProduct
  = \ (@ (f_ag3Sm :: * -> *))
      (@ (g_ag3Sn :: * -> *))
      ($dMonadFix_ag3So :: MonadFix f_ag3Sm)
      ($dMonadFix1_ag3Sp :: MonadFix g_ag3Sn) ->
      Control.Monad.Fix.C:MonadFix
        @ (Product f_ag3Sm g_ag3Sn)
        (Data.Functor.Product.$fMonadFixProduct_$cp1MonadFix
           @ f_ag3Sm @ g_ag3Sn $dMonadFix_ag3So $dMonadFix1_ag3Sp)
        (Data.Functor.Product.$fMonadFixProduct_$cmfix
           @ f_ag3Sm @ g_ag3Sn $dMonadFix_ag3So $dMonadFix1_ag3Sp)

-- RHS size: {terms: 27, types: 66, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadZipProduct_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadZip f, MonadZip g) =>
     forall a b c.
     (a -> b -> c) -> Product f g a -> Product f g b -> Product f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4Ws :: * -> *))
                 (@ (g_sg4Wt :: * -> *))
                 (w_sg4Wu [Occ=Once] :: MonadZip f_sg4Ws)
                 (w1_sg4Wv [Occ=Once] :: MonadZip g_sg4Wt)
                 (@ a_sg4Ww)
                 (@ b_sg4Wx)
                 (@ c_sg4Wy)
                 (w2_sg4Wz :: a_sg4Ww -> b_sg4Wx -> c_sg4Wy)
                 (w3_sg4WA [Occ=Once!] :: Product f_sg4Ws g_sg4Wt a_sg4Ww)
                 (w4_sg4WB [Occ=Once!] :: Product f_sg4Ws g_sg4Wt b_sg4Wx) ->
                 case w3_sg4WA of
                 { Pair ww1_sg4WE [Occ=Once] ww2_sg4WF [Occ=Once] ->
                 case w4_sg4WB of
                 { Pair ww4_sg4WJ [Occ=Once] ww5_sg4WK [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ *
                   @ f_sg4Ws
                   @ g_sg4Wt
                   @ c_sg4Wy
                   (mzipWith
                      @ f_sg4Ws
                      w_sg4Wu
                      @ a_sg4Ww
                      @ b_sg4Wx
                      @ c_sg4Wy
                      w2_sg4Wz
                      ww1_sg4WE
                      ww4_sg4WJ)
                   (mzipWith
                      @ g_sg4Wt
                      w1_sg4Wv
                      @ a_sg4Ww
                      @ b_sg4Wx
                      @ c_sg4Wy
                      w2_sg4Wz
                      ww2_sg4WF
                      ww5_sg4WK)
                 }
                 }}]
Data.Functor.Product.$fMonadZipProduct_$cmzipWith
  = \ (@ (f_sg4Ws :: * -> *))
      (@ (g_sg4Wt :: * -> *))
      (w_sg4Wu :: MonadZip f_sg4Ws)
      (w1_sg4Wv :: MonadZip g_sg4Wt)
      (@ a_sg4Ww)
      (@ b_sg4Wx)
      (@ c_sg4Wy)
      (w2_sg4Wz :: a_sg4Ww -> b_sg4Wx -> c_sg4Wy)
      (w3_sg4WA :: Product f_sg4Ws g_sg4Wt a_sg4Ww)
      (w4_sg4WB :: Product f_sg4Ws g_sg4Wt b_sg4Wx) ->
      case w3_sg4WA of { Pair ww1_sg4WE ww2_sg4WF ->
      case w4_sg4WB of { Pair ww4_sg4WJ ww5_sg4WK ->
      Data.Functor.Product.Pair
        @ *
        @ f_sg4Ws
        @ g_sg4Wt
        @ c_sg4Wy
        (mzipWith
           @ f_sg4Ws
           w_sg4Wu
           @ a_sg4Ww
           @ b_sg4Wx
           @ c_sg4Wy
           w2_sg4Wz
           ww1_sg4WE
           ww4_sg4WJ)
        (mzipWith
           @ g_sg4Wt
           w1_sg4Wv
           @ a_sg4Ww
           @ b_sg4Wx
           @ c_sg4Wy
           w2_sg4Wz
           ww2_sg4WF
           ww5_sg4WK)
      }
      }

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadZip f, MonadZip g) =>
     Monad (Product f g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Rw :: * -> *))
                 (@ (g_ag3Rx :: * -> *))
                 ($dMonadZip_ag3Ry [Occ=Once] :: MonadZip f_ag3Rw)
                 ($dMonadZip1_ag3Rz [Occ=Once] :: MonadZip g_ag3Rx) ->
                 Data.Functor.Product.$fMonadProduct
                   @ f_ag3Rw
                   @ g_ag3Rx
                   (Control.Monad.Zip.$p1MonadZip @ f_ag3Rw $dMonadZip_ag3Ry)
                   (Control.Monad.Zip.$p1MonadZip @ g_ag3Rx $dMonadZip1_ag3Rz)}]
Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
  = \ (@ (f_ag3Rw :: * -> *))
      (@ (g_ag3Rx :: * -> *))
      ($dMonadZip_ag3Ry :: MonadZip f_ag3Rw)
      ($dMonadZip1_ag3Rz :: MonadZip g_ag3Rx) ->
      Data.Functor.Product.$fMonadProduct
        @ f_ag3Rw
        @ g_ag3Rx
        (Control.Monad.Zip.$p1MonadZip @ f_ag3Rw $dMonadZip_ag3Ry)
        (Control.Monad.Zip.$p1MonadZip @ g_ag3Rx $dMonadZip1_ag3Rz)

-- RHS size: {terms: 25, types: 71, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadZipProduct_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadZip f, MonadZip g) =>
     forall a b. Product f g a -> Product f g b -> Product f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ag3Rw :: * -> *))
                 (@ (g_ag3Rx :: * -> *))
                 ($dMonadZip_ag3Ry [Occ=Once] :: MonadZip f_ag3Rw)
                 ($dMonadZip1_ag3Rz [Occ=Once] :: MonadZip g_ag3Rx)
                 (@ a_ag3RH)
                 (@ b_ag3RI) ->
                 Data.Functor.Product.$fMonadZipProduct_$cmzipWith
                   @ f_ag3Rw
                   @ g_ag3Rx
                   $dMonadZip_ag3Ry
                   $dMonadZip1_ag3Rz
                   @ a_ag3RH
                   @ b_ag3RI
                   @ (a_ag3RH, b_ag3RI)
                   (GHC.Tuple.(,) @ a_ag3RH @ b_ag3RI)}]
Data.Functor.Product.$fMonadZipProduct_$cmzip
  = \ (@ (f_ag3Rw :: * -> *))
      (@ (g_ag3Rx :: * -> *))
      ($dMonadZip_ag3Ry :: MonadZip f_ag3Rw)
      ($dMonadZip1_ag3Rz :: MonadZip g_ag3Rx)
      (@ a_ag3RH)
      (@ b_ag3RI)
      (w_sg4WA :: Product f_ag3Rw g_ag3Rx a_ag3RH)
      (w1_sg4WB :: Product f_ag3Rw g_ag3Rx b_ag3RI) ->
      case w_sg4WA of { Pair ww1_sg4WE ww2_sg4WF ->
      case w1_sg4WB of { Pair ww4_sg4WJ ww5_sg4WK ->
      Data.Functor.Product.Pair
        @ *
        @ f_ag3Rw
        @ g_ag3Rx
        @ (a_ag3RH, b_ag3RI)
        (mzipWith
           @ f_ag3Rw
           $dMonadZip_ag3Ry
           @ a_ag3RH
           @ b_ag3RI
           @ (a_ag3RH, b_ag3RI)
           (GHC.Tuple.(,) @ a_ag3RH @ b_ag3RI)
           ww1_sg4WE
           ww4_sg4WJ)
        (mzipWith
           @ g_ag3Rx
           $dMonadZip1_ag3Rz
           @ a_ag3RH
           @ b_ag3RI
           @ (a_ag3RH, b_ag3RI)
           (GHC.Tuple.(,) @ a_ag3RH @ b_ag3RI)
           ww2_sg4WF
           ww5_sg4WK)
      }
      }

-- RHS size: {terms: 74, types: 158, coercions: 0, joins: 0/6}
Data.Functor.Product.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadZip f, MonadZip g) =>
     forall a b.
     Product f g (a, b) -> (# Product f g a, Product f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 40] 580 30}]
Data.Functor.Product.$w$cmunzip
  = \ (@ (f_sg4WQ :: * -> *))
      (@ (g_sg4WR :: * -> *))
      (w_sg4WS :: MonadZip f_sg4WQ)
      (w1_sg4WT :: MonadZip g_sg4WR)
      (@ a_sg4WU)
      (@ b_sg4WV)
      (w2_sg4WW :: Product f_sg4WQ g_sg4WR (a_sg4WU, b_sg4WV)) ->
      let {
        $dMonad_sg4na [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
          :: Monad f_sg4WQ
        [LclId]
        $dMonad_sg4na
          = Control.Monad.Zip.$p1MonadZip @ f_sg4WQ w_sg4WS } in
      let {
        $dMonad1_sg4n9 [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
          :: Monad g_sg4WR
        [LclId]
        $dMonad1_sg4n9
          = Control.Monad.Zip.$p1MonadZip @ g_sg4WR w1_sg4WT } in
      (# case w2_sg4WW of { Pair m_ag3Ei n_ag3Ej ->
         Data.Functor.Product.Pair
           @ *
           @ f_sg4WQ
           @ g_sg4WR
           @ a_sg4WU
           (let {
              lvl9_sg4oI [Dmd=<L,U(A,C(U),A,A,A,A)>] :: Applicative f_sg4WQ
              [LclId]
              lvl9_sg4oI = GHC.Base.$p1Monad @ f_sg4WQ $dMonad_sg4na } in
            >>=
              @ f_sg4WQ
              $dMonad_sg4na
              @ (a_sg4WU, b_sg4WV)
              @ a_sg4WU
              m_ag3Ei
              (\ (x_i7Rxi :: (a_sg4WU, b_sg4WV)) ->
                 pure
                   @ f_sg4WQ
                   lvl9_sg4oI
                   @ a_sg4WU
                   (case x_i7Rxi of { (x1_i8S6A, ds1_i8S6B) -> x1_i8S6A })))
           (let {
              lvl9_sg4oJ [Dmd=<L,U(A,C(U),A,A,A,A)>] :: Applicative g_sg4WR
              [LclId]
              lvl9_sg4oJ = GHC.Base.$p1Monad @ g_sg4WR $dMonad1_sg4n9 } in
            >>=
              @ g_sg4WR
              $dMonad1_sg4n9
              @ (a_sg4WU, b_sg4WV)
              @ a_sg4WU
              n_ag3Ej
              (\ (x_i7Rxi :: (a_sg4WU, b_sg4WV)) ->
                 pure
                   @ g_sg4WR
                   lvl9_sg4oJ
                   @ a_sg4WU
                   (case x_i7Rxi of { (x1_i8S6A, ds1_i8S6B) -> x1_i8S6A })))
         },
         case w2_sg4WW of { Pair m_ag3Ei n_ag3Ej ->
         Data.Functor.Product.Pair
           @ *
           @ f_sg4WQ
           @ g_sg4WR
           @ b_sg4WV
           (let {
              lvl9_sg4oK [Dmd=<L,U(A,C(U),A,A,A,A)>] :: Applicative f_sg4WQ
              [LclId]
              lvl9_sg4oK = GHC.Base.$p1Monad @ f_sg4WQ $dMonad_sg4na } in
            >>=
              @ f_sg4WQ
              $dMonad_sg4na
              @ (a_sg4WU, b_sg4WV)
              @ b_sg4WV
              m_ag3Ei
              (\ (x_i7Rxi :: (a_sg4WU, b_sg4WV)) ->
                 pure
                   @ f_sg4WQ
                   lvl9_sg4oK
                   @ b_sg4WV
                   (case x_i7Rxi of { (ds1_iaIin, y_iaIio) -> y_iaIio })))
           (let {
              lvl9_sg4oL [Dmd=<L,U(A,C(U),A,A,A,A)>] :: Applicative g_sg4WR
              [LclId]
              lvl9_sg4oL = GHC.Base.$p1Monad @ g_sg4WR $dMonad1_sg4n9 } in
            >>=
              @ g_sg4WR
              $dMonad1_sg4n9
              @ (a_sg4WU, b_sg4WV)
              @ b_sg4WV
              n_ag3Ej
              (\ (x_i7Rxi :: (a_sg4WU, b_sg4WV)) ->
                 pure
                   @ g_sg4WR
                   lvl9_sg4oL
                   @ b_sg4WV
                   (case x_i7Rxi of { (ds1_iaIin, y_iaIio) -> y_iaIio })))
         } #)

-- RHS size: {terms: 16, types: 67, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadZipProduct_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadZip f, MonadZip g) =>
     forall a b. Product f g (a, b) -> (Product f g a, Product f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sg4WQ :: * -> *))
                 (@ (g_sg4WR :: * -> *))
                 (w_sg4WS [Occ=Once] :: MonadZip f_sg4WQ)
                 (w1_sg4WT [Occ=Once] :: MonadZip g_sg4WR)
                 (@ a_sg4WU)
                 (@ b_sg4WV)
                 (w2_sg4WW [Occ=Once]
                    :: Product f_sg4WQ g_sg4WR (a_sg4WU, b_sg4WV)) ->
                 case Data.Functor.Product.$w$cmunzip
                        @ f_sg4WQ @ g_sg4WR w_sg4WS w1_sg4WT @ a_sg4WU @ b_sg4WV w2_sg4WW
                 of
                 { (# ww1_sg4YC [Occ=Once], ww2_sg4YD [Occ=Once] #) ->
                 (ww1_sg4YC, ww2_sg4YD)
                 }}]
Data.Functor.Product.$fMonadZipProduct_$cmunzip
  = \ (@ (f_sg4WQ :: * -> *))
      (@ (g_sg4WR :: * -> *))
      (w_sg4WS :: MonadZip f_sg4WQ)
      (w1_sg4WT :: MonadZip g_sg4WR)
      (@ a_sg4WU)
      (@ b_sg4WV)
      (w2_sg4WW :: Product f_sg4WQ g_sg4WR (a_sg4WU, b_sg4WV)) ->
      case Data.Functor.Product.$w$cmunzip
             @ f_sg4WQ @ g_sg4WR w_sg4WS w1_sg4WT @ a_sg4WU @ b_sg4WV w2_sg4WW
      of
      { (# ww1_sg4YC, ww2_sg4YD #) ->
      (ww1_sg4YC, ww2_sg4YD)
      }

-- RHS size: {terms: 17, types: 25, coercions: 0, joins: 0/0}
Data.Functor.Product.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (MonadZip f, MonadZip g) =>
     MonadZip (Product f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),A),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m,
 Unf=DFun: \ (@ (f_ag3DW :: * -> *))
             (@ (g_ag3DX :: * -> *))
             (v_B1 :: MonadZip f_ag3DW)
             (v1_B2 :: MonadZip g_ag3DX) ->
       Control.Monad.Zip.C:MonadZip TYPE: Product f_ag3DW g_ag3DX
                                    Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
                                      @ f_ag3DW @ g_ag3DX v_B1 v1_B2
                                    Data.Functor.Product.$fMonadZipProduct_$cmzip
                                      @ f_ag3DW @ g_ag3DX v_B1 v1_B2
                                    Data.Functor.Product.$fMonadZipProduct_$cmzipWith
                                      @ f_ag3DW @ g_ag3DX v_B1 v1_B2
                                    Data.Functor.Product.$fMonadZipProduct_$cmunzip
                                      @ f_ag3DW @ g_ag3DX v_B1 v1_B2]
Data.Functor.Product.$fMonadZipProduct
  = \ (@ (f_ag3Rw :: * -> *))
      (@ (g_ag3Rx :: * -> *))
      ($dMonadZip_ag3Ry :: MonadZip f_ag3Rw)
      ($dMonadZip1_ag3Rz :: MonadZip g_ag3Rx) ->
      Control.Monad.Zip.C:MonadZip
        @ (Product f_ag3Rw g_ag3Rx)
        (Data.Functor.Product.$fMonadZipProduct_$cp1MonadZip
           @ f_ag3Rw @ g_ag3Rx $dMonadZip_ag3Ry $dMonadZip1_ag3Rz)
        (Data.Functor.Product.$fMonadZipProduct_$cmzip
           @ f_ag3Rw @ g_ag3Rx $dMonadZip_ag3Ry $dMonadZip1_ag3Rz)
        (Data.Functor.Product.$fMonadZipProduct_$cmzipWith
           @ f_ag3Rw @ g_ag3Rx $dMonadZip_ag3Ry $dMonadZip1_ag3Rz)
        (Data.Functor.Product.$fMonadZipProduct_$cmunzip
           @ f_ag3Rw @ g_ag3Rx $dMonadZip_ag3Ry $dMonadZip1_ag3Rz)

-- RHS size: {terms: 11, types: 73, coercions: 116, joins: 0/0}
Data.Functor.Product.$fGeneric1Product_$cto1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Product f g) a -> Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_ag3Q7)
                 (@ (f_ag3Q8 :: k_ag3Q7 -> *))
                 (@ (g_ag3Q9 :: k_ag3Q7 -> *))
                 (@ (a_ag3QQ :: k_ag3Q7))
                 (ds_dg4aG [Occ=Once]
                    :: GHC.Generics.Rep1 (Product f_ag3Q8 g_ag3Q9) a_ag3QQ) ->
                 case ds_dg4aG
                      `cast` ((Sub (Data.Functor.Product.Rep1_Product[0]
                                        <k_ag3Q7>_N <f_ag3Q8>_N <g_ag3Q9>_N) ; (GHC.Generics.N:M1[0]
                                                                                    <k_ag3Q7>_N
                                                                                    <GHC.Generics.D>_P
                                                                                    <'GHC.Generics.MetaData
                                                                                       "Product"
                                                                                       "Data.Functor.Product"
                                                                                       "base"
                                                                                       'False>_P
                                                                                    <GHC.Generics.M1
                                                                                       GHC.Generics.C
                                                                                       ('GHC.Generics.MetaCons
                                                                                          "Pair"
                                                                                          'GHC.Generics.PrefixI
                                                                                          'False)
                                                                                       (GHC.Generics.M1
                                                                                          GHC.Generics.S
                                                                                          ('GHC.Generics.MetaSel
                                                                                             'Nothing
                                                                                             'GHC.Generics.NoSourceUnpackedness
                                                                                             'GHC.Generics.NoSourceStrictness
                                                                                             'GHC.Generics.DecidedLazy)
                                                                                          (GHC.Generics.Rec1
                                                                                             f_ag3Q8)
                                                                                        GHC.Generics.:*: GHC.Generics.M1
                                                                                                           GHC.Generics.S
                                                                                                           ('GHC.Generics.MetaSel
                                                                                                              'Nothing
                                                                                                              'GHC.Generics.NoSourceUnpackedness
                                                                                                              'GHC.Generics.NoSourceStrictness
                                                                                                              'GHC.Generics.DecidedLazy)
                                                                                                           (GHC.Generics.Rec1
                                                                                                              g_ag3Q9))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                 <k_ag3Q7>_N
                                                                                                                                 <GHC.Generics.C>_P
                                                                                                                                 <'GHC.Generics.MetaCons
                                                                                                                                    "Pair"
                                                                                                                                    'GHC.Generics.PrefixI
                                                                                                                                    'False>_P
                                                                                                                                 <GHC.Generics.M1
                                                                                                                                    GHC.Generics.S
                                                                                                                                    ('GHC.Generics.MetaSel
                                                                                                                                       'Nothing
                                                                                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                                                                                       'GHC.Generics.NoSourceStrictness
                                                                                                                                       'GHC.Generics.DecidedLazy)
                                                                                                                                    (GHC.Generics.Rec1
                                                                                                                                       f_ag3Q8)
                                                                                                                                  GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                                     GHC.Generics.S
                                                                                                                                                     ('GHC.Generics.MetaSel
                                                                                                                                                        'Nothing
                                                                                                                                                        'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                        'GHC.Generics.NoSourceStrictness
                                                                                                                                                        'GHC.Generics.DecidedLazy)
                                                                                                                                                     (GHC.Generics.Rec1
                                                                                                                                                        g_ag3Q9)>_R)) <a_ag3QQ>_N
                              :: (GHC.Generics.Rep1 (Product f_ag3Q8 g_ag3Q9) a_ag3QQ :: *)
                                 ~R# ((GHC.Generics.:*:)
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.Rec1 f_ag3Q8))
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.Rec1 g_ag3Q9))
                                        a_ag3QQ :: *))
                 of
                 { GHC.Generics.:*: ds1_dg4aJ [Occ=Once] ds2_dg4aK [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ k_ag3Q7
                   @ f_ag3Q8
                   @ g_ag3Q9
                   @ a_ag3QQ
                   (ds1_dg4aJ
                    `cast` ((GHC.Generics.N:M1[0]
                                 <k_ag3Q7>_N
                                 <GHC.Generics.S>_P
                                 <'GHC.Generics.MetaSel
                                    'Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy>_P
                                 <GHC.Generics.Rec1 f_ag3Q8>_R ; GHC.Generics.N:Rec1[0]
                                                                     <k_ag3Q7>_N
                                                                     <f_ag3Q8>_R) <a_ag3QQ>_N
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec1 f_ag3Q8)
                                  a_ag3QQ :: *)
                               ~R# (f_ag3Q8 a_ag3QQ :: *)))
                   (ds2_dg4aK
                    `cast` ((GHC.Generics.N:M1[0]
                                 <k_ag3Q7>_N
                                 <GHC.Generics.S>_P
                                 <'GHC.Generics.MetaSel
                                    'Nothing
                                    'GHC.Generics.NoSourceUnpackedness
                                    'GHC.Generics.NoSourceStrictness
                                    'GHC.Generics.DecidedLazy>_P
                                 <GHC.Generics.Rec1 g_ag3Q9>_R ; GHC.Generics.N:Rec1[0]
                                                                     <k_ag3Q7>_N
                                                                     <g_ag3Q9>_R) <a_ag3QQ>_N
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec1 g_ag3Q9)
                                  a_ag3QQ :: *)
                               ~R# (g_ag3Q9 a_ag3QQ :: *)))
                 }}]
Data.Functor.Product.$fGeneric1Product_$cto1
  = \ (@ k_ag3Q7)
      (@ (f_ag3Q8 :: k_ag3Q7 -> *))
      (@ (g_ag3Q9 :: k_ag3Q7 -> *))
      (@ (a_ag3QQ :: k_ag3Q7))
      (ds_dg4aG
         :: GHC.Generics.Rep1 (Product f_ag3Q8 g_ag3Q9) a_ag3QQ) ->
      case ds_dg4aG
           `cast` ((Sub (Data.Functor.Product.Rep1_Product[0]
                             <k_ag3Q7>_N <f_ag3Q8>_N <g_ag3Q9>_N) ; (GHC.Generics.N:M1[0]
                                                                         <k_ag3Q7>_N
                                                                         <GHC.Generics.D>_P
                                                                         <'GHC.Generics.MetaData
                                                                            "Product"
                                                                            "Data.Functor.Product"
                                                                            "base"
                                                                            'False>_P
                                                                         <GHC.Generics.M1
                                                                            GHC.Generics.C
                                                                            ('GHC.Generics.MetaCons
                                                                               "Pair"
                                                                               'GHC.Generics.PrefixI
                                                                               'False)
                                                                            (GHC.Generics.M1
                                                                               GHC.Generics.S
                                                                               ('GHC.Generics.MetaSel
                                                                                  'Nothing
                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                  'GHC.Generics.NoSourceStrictness
                                                                                  'GHC.Generics.DecidedLazy)
                                                                               (GHC.Generics.Rec1
                                                                                  f_ag3Q8)
                                                                             GHC.Generics.:*: GHC.Generics.M1
                                                                                                GHC.Generics.S
                                                                                                ('GHC.Generics.MetaSel
                                                                                                   'Nothing
                                                                                                   'GHC.Generics.NoSourceUnpackedness
                                                                                                   'GHC.Generics.NoSourceStrictness
                                                                                                   'GHC.Generics.DecidedLazy)
                                                                                                (GHC.Generics.Rec1
                                                                                                   g_ag3Q9))>_R ; GHC.Generics.N:M1[0]
                                                                                                                      <k_ag3Q7>_N
                                                                                                                      <GHC.Generics.C>_P
                                                                                                                      <'GHC.Generics.MetaCons
                                                                                                                         "Pair"
                                                                                                                         'GHC.Generics.PrefixI
                                                                                                                         'False>_P
                                                                                                                      <GHC.Generics.M1
                                                                                                                         GHC.Generics.S
                                                                                                                         ('GHC.Generics.MetaSel
                                                                                                                            'Nothing
                                                                                                                            'GHC.Generics.NoSourceUnpackedness
                                                                                                                            'GHC.Generics.NoSourceStrictness
                                                                                                                            'GHC.Generics.DecidedLazy)
                                                                                                                         (GHC.Generics.Rec1
                                                                                                                            f_ag3Q8)
                                                                                                                       GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                          GHC.Generics.S
                                                                                                                                          ('GHC.Generics.MetaSel
                                                                                                                                             'Nothing
                                                                                                                                             'GHC.Generics.NoSourceUnpackedness
                                                                                                                                             'GHC.Generics.NoSourceStrictness
                                                                                                                                             'GHC.Generics.DecidedLazy)
                                                                                                                                          (GHC.Generics.Rec1
                                                                                                                                             g_ag3Q9)>_R)) <a_ag3QQ>_N
                   :: (GHC.Generics.Rep1 (Product f_ag3Q8 g_ag3Q9) a_ag3QQ :: *)
                      ~R# ((GHC.Generics.:*:)
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.NoSourceStrictness
                                   'GHC.Generics.DecidedLazy)
                                (GHC.Generics.Rec1 f_ag3Q8))
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.NoSourceStrictness
                                   'GHC.Generics.DecidedLazy)
                                (GHC.Generics.Rec1 g_ag3Q9))
                             a_ag3QQ :: *))
      of
      { GHC.Generics.:*: ds1_dg4aJ ds2_dg4aK ->
      Data.Functor.Product.Pair
        @ k_ag3Q7
        @ f_ag3Q8
        @ g_ag3Q9
        @ a_ag3QQ
        (ds1_dg4aJ
         `cast` ((GHC.Generics.N:M1[0]
                      <k_ag3Q7>_N
                      <GHC.Generics.S>_P
                      <'GHC.Generics.MetaSel
                         'Nothing
                         'GHC.Generics.NoSourceUnpackedness
                         'GHC.Generics.NoSourceStrictness
                         'GHC.Generics.DecidedLazy>_P
                      <GHC.Generics.Rec1 f_ag3Q8>_R ; GHC.Generics.N:Rec1[0]
                                                          <k_ag3Q7>_N <f_ag3Q8>_R) <a_ag3QQ>_N
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.Rec1 f_ag3Q8)
                       a_ag3QQ :: *)
                    ~R# (f_ag3Q8 a_ag3QQ :: *)))
        (ds2_dg4aK
         `cast` ((GHC.Generics.N:M1[0]
                      <k_ag3Q7>_N
                      <GHC.Generics.S>_P
                      <'GHC.Generics.MetaSel
                         'Nothing
                         'GHC.Generics.NoSourceUnpackedness
                         'GHC.Generics.NoSourceStrictness
                         'GHC.Generics.DecidedLazy>_P
                      <GHC.Generics.Rec1 g_ag3Q9>_R ; GHC.Generics.N:Rec1[0]
                                                          <k_ag3Q7>_N <g_ag3Q9>_R) <a_ag3QQ>_N
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.Rec1 g_ag3Q9)
                       a_ag3QQ :: *)
                    ~R# (g_ag3Q9 a_ag3QQ :: *)))
      }

-- RHS size: {terms: 11, types: 49, coercions: 73, joins: 0/0}
Data.Functor.Product.$fGeneric1Product1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.Rec1 f)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.Rec1 g))
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_ag3Q7)
                 (@ (f_ag3Q8 :: k_ag3Q7 -> *))
                 (@ (g_ag3Q9 :: k_ag3Q7 -> *))
                 (@ (a_ag3Qd :: k_ag3Q7))
                 (x_ag3KM [Occ=Once!] :: Product f_ag3Q8 g_ag3Q9 a_ag3Qd) ->
                 case x_ag3KM of { Pair g1_ag3KN [Occ=Once] g2_ag3KO [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ k_ag3Q7
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.NoSourceStrictness
                            'GHC.Generics.DecidedLazy)
                         (GHC.Generics.Rec1 f_ag3Q8))
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.NoSourceStrictness
                            'GHC.Generics.DecidedLazy)
                         (GHC.Generics.Rec1 g_ag3Q9))
                    @ a_ag3Qd
                    (g1_ag3KN
                     `cast` ((Sym (GHC.Generics.N:Rec1[0]
                                       <k_ag3Q7>_N <f_ag3Q8>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                           <k_ag3Q7>_N
                                                                           <GHC.Generics.S>_P
                                                                           <'GHC.Generics.MetaSel
                                                                              'Nothing
                                                                              'GHC.Generics.NoSourceUnpackedness
                                                                              'GHC.Generics.NoSourceStrictness
                                                                              'GHC.Generics.DecidedLazy>_P
                                                                           <GHC.Generics.Rec1
                                                                              f_ag3Q8>_R)) <a_ag3Qd>_N
                             :: (f_ag3Q8 a_ag3Qd :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec1 f_ag3Q8)
                                       a_ag3Qd :: *)))
                    (g2_ag3KO
                     `cast` ((Sym (GHC.Generics.N:Rec1[0]
                                       <k_ag3Q7>_N <g_ag3Q9>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                           <k_ag3Q7>_N
                                                                           <GHC.Generics.S>_P
                                                                           <'GHC.Generics.MetaSel
                                                                              'Nothing
                                                                              'GHC.Generics.NoSourceUnpackedness
                                                                              'GHC.Generics.NoSourceStrictness
                                                                              'GHC.Generics.DecidedLazy>_P
                                                                           <GHC.Generics.Rec1
                                                                              g_ag3Q9>_R)) <a_ag3Qd>_N
                             :: (g_ag3Q9 a_ag3Qd :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.Rec1 g_ag3Q9)
                                       a_ag3Qd :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <k_ag3Q7>_N
                                  <GHC.Generics.C>_P
                                  <'GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False>_P
                                  <GHC.Generics.M1
                                     GHC.Generics.S
                                     ('GHC.Generics.MetaSel
                                        'Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.Rec1 f_ag3Q8)
                                   GHC.Generics.:*: GHC.Generics.M1
                                                      GHC.Generics.S
                                                      ('GHC.Generics.MetaSel
                                                         'Nothing
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.NoSourceStrictness
                                                         'GHC.Generics.DecidedLazy)
                                                      (GHC.Generics.Rec1 g_ag3Q9)>_R) <a_ag3Qd>_N
                         :: ((GHC.Generics.:*:)
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec1 f_ag3Q8))
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.Rec1 g_ag3Q9))
                               a_ag3Qd :: *)
                            ~R# (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.Rec1 f_ag3Q8)
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy)
                                                       (GHC.Generics.Rec1 g_ag3Q9))
                                   a_ag3Qd :: *))
                 }}]
Data.Functor.Product.$fGeneric1Product1
  = \ (@ k_ag3Q7)
      (@ (f_ag3Q8 :: k_ag3Q7 -> *))
      (@ (g_ag3Q9 :: k_ag3Q7 -> *))
      (@ (a_ag3Qd :: k_ag3Q7))
      (x_ag3KM :: Product f_ag3Q8 g_ag3Q9 a_ag3Qd) ->
      case x_ag3KM of { Pair g1_ag3KN g2_ag3KO ->
      (GHC.Generics.:*:
         @ k_ag3Q7
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.NoSourceStrictness
                 'GHC.Generics.DecidedLazy)
              (GHC.Generics.Rec1 f_ag3Q8))
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.NoSourceStrictness
                 'GHC.Generics.DecidedLazy)
              (GHC.Generics.Rec1 g_ag3Q9))
         @ a_ag3Qd
         (g1_ag3KN
          `cast` ((Sym (GHC.Generics.N:Rec1[0]
                            <k_ag3Q7>_N <f_ag3Q8>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                <k_ag3Q7>_N
                                                                <GHC.Generics.S>_P
                                                                <'GHC.Generics.MetaSel
                                                                   'Nothing
                                                                   'GHC.Generics.NoSourceUnpackedness
                                                                   'GHC.Generics.NoSourceStrictness
                                                                   'GHC.Generics.DecidedLazy>_P
                                                                <GHC.Generics.Rec1
                                                                   f_ag3Q8>_R)) <a_ag3Qd>_N
                  :: (f_ag3Q8 a_ag3Qd :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.Rec1 f_ag3Q8)
                            a_ag3Qd :: *)))
         (g2_ag3KO
          `cast` ((Sym (GHC.Generics.N:Rec1[0]
                            <k_ag3Q7>_N <g_ag3Q9>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                <k_ag3Q7>_N
                                                                <GHC.Generics.S>_P
                                                                <'GHC.Generics.MetaSel
                                                                   'Nothing
                                                                   'GHC.Generics.NoSourceUnpackedness
                                                                   'GHC.Generics.NoSourceStrictness
                                                                   'GHC.Generics.DecidedLazy>_P
                                                                <GHC.Generics.Rec1
                                                                   g_ag3Q9>_R)) <a_ag3Qd>_N
                  :: (g_ag3Q9 a_ag3Qd :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.Rec1 g_ag3Q9)
                            a_ag3Qd :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <k_ag3Q7>_N
                       <GHC.Generics.C>_P
                       <'GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False>_P
                       <GHC.Generics.M1
                          GHC.Generics.S
                          ('GHC.Generics.MetaSel
                             'Nothing
                             'GHC.Generics.NoSourceUnpackedness
                             'GHC.Generics.NoSourceStrictness
                             'GHC.Generics.DecidedLazy)
                          (GHC.Generics.Rec1 f_ag3Q8)
                        GHC.Generics.:*: GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.Rec1 g_ag3Q9)>_R) <a_ag3Qd>_N
              :: ((GHC.Generics.:*:)
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.Rec1 f_ag3Q8))
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.Rec1 g_ag3Q9))
                    a_ag3Qd :: *)
                 ~R# (GHC.Generics.M1
                        GHC.Generics.C
                        ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                        (GHC.Generics.M1
                           GHC.Generics.S
                           ('GHC.Generics.MetaSel
                              'Nothing
                              'GHC.Generics.NoSourceUnpackedness
                              'GHC.Generics.NoSourceStrictness
                              'GHC.Generics.DecidedLazy)
                           (GHC.Generics.Rec1 f_ag3Q8)
                         GHC.Generics.:*: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.NoSourceStrictness
                                               'GHC.Generics.DecidedLazy)
                                            (GHC.Generics.Rec1 g_ag3Q9))
                        a_ag3Qd :: *))
      }

-- RHS size: {terms: 6, types: 19, coercions: 58, joins: 0/0}
Data.Functor.Product.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *). Generic1 (Product f g)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ k_ag3Iy)
             (@ (f_ag3DT :: k_ag3Iy -> *))
             (@ (g_ag3DU :: k_ag3Iy -> *)) ->
       GHC.Generics.C:Generic1 TYPE: k_ag3Iy
                               TYPE: Product f_ag3DT g_ag3DU
                               (Data.Functor.Product.$fGeneric1Product1
                                  @ k_ag3Iy @ f_ag3DT @ g_ag3DU)
                               `cast` (forall (a :: <k_ag3Iy>_N).
                                       <Product f_ag3DT g_ag3DU a>_R
                                       ->_R (Sym (GHC.Generics.N:M1[0]
                                                      <k_ag3Iy>_N
                                                      <GHC.Generics.D>_P
                                                      <'GHC.Generics.MetaData
                                                         "Product"
                                                         "Data.Functor.Product"
                                                         "base"
                                                         'False>_P
                                                      <GHC.Generics.M1
                                                         GHC.Generics.C
                                                         ('GHC.Generics.MetaCons
                                                            "Pair" 'GHC.Generics.PrefixI 'False)
                                                         (GHC.Generics.M1
                                                            GHC.Generics.S
                                                            ('GHC.Generics.MetaSel
                                                               'Nothing
                                                               'GHC.Generics.NoSourceUnpackedness
                                                               'GHC.Generics.NoSourceStrictness
                                                               'GHC.Generics.DecidedLazy)
                                                            (GHC.Generics.Rec1 f_ag3DT)
                                                          GHC.Generics.:*: GHC.Generics.M1
                                                                             GHC.Generics.S
                                                                             ('GHC.Generics.MetaSel
                                                                                'Nothing
                                                                                'GHC.Generics.NoSourceUnpackedness
                                                                                'GHC.Generics.NoSourceStrictness
                                                                                'GHC.Generics.DecidedLazy)
                                                                             (GHC.Generics.Rec1
                                                                                g_ag3DU))>_R) ; Sub (Sym (Data.Functor.Product.Rep1_Product[0]
                                                                                                              <k_ag3Iy>_N
                                                                                                              <f_ag3DT>_N
                                                                                                              <g_ag3DU>_N))) <a>_N
                                       :: (forall (a :: k).
                                           Product f_ag3DT g_ag3DU a
                                           -> GHC.Generics.M1
                                                GHC.Generics.C
                                                ('GHC.Generics.MetaCons
                                                   "Pair" 'GHC.Generics.PrefixI 'False)
                                                (GHC.Generics.M1
                                                   GHC.Generics.S
                                                   ('GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy)
                                                   (GHC.Generics.Rec1 f_ag3DT)
                                                 GHC.Generics.:*: GHC.Generics.M1
                                                                    GHC.Generics.S
                                                                    ('GHC.Generics.MetaSel
                                                                       'Nothing
                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                       'GHC.Generics.NoSourceStrictness
                                                                       'GHC.Generics.DecidedLazy)
                                                                    (GHC.Generics.Rec1 g_ag3DU))
                                                a :: *)
                                          ~R# (forall (a :: k).
                                               Product f_ag3DT g_ag3DU a
                                               -> GHC.Generics.Rep1
                                                    (Product f_ag3DT g_ag3DU) a :: *))
                               Data.Functor.Product.$fGeneric1Product_$cto1
                                 @ k_ag3Iy @ f_ag3DT @ g_ag3DU]
Data.Functor.Product.$fGeneric1Product
  = \ (@ k_Xg3TT)
      (@ (f_Xg3TV :: k_Xg3TT -> *))
      (@ (g_Xg3TX :: k_Xg3TT -> *)) ->
      GHC.Generics.C:Generic1
        @ k_Xg3TT
        @ (Product f_Xg3TV g_Xg3TX)
        ((Data.Functor.Product.$fGeneric1Product1
            @ k_Xg3TT @ f_Xg3TV @ g_Xg3TX)
         `cast` (forall (a :: <k_Xg3TT>_N).
                 <Product f_Xg3TV g_Xg3TX a>_R
                 ->_R (Sym (GHC.Generics.N:M1[0]
                                <k_Xg3TT>_N
                                <GHC.Generics.D>_P
                                <'GHC.Generics.MetaData
                                   "Product" "Data.Functor.Product" "base" 'False>_P
                                <GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.Rec1 f_Xg3TV)
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy)
                                                       (GHC.Generics.Rec1
                                                          g_Xg3TX))>_R) ; Sub (Sym (Data.Functor.Product.Rep1_Product[0]
                                                                                        <k_Xg3TT>_N
                                                                                        <f_Xg3TV>_N
                                                                                        <g_Xg3TX>_N))) <a>_N
                 :: (forall (a :: k).
                     Product f_Xg3TV g_Xg3TX a
                     -> GHC.Generics.M1
                          GHC.Generics.C
                          ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                          (GHC.Generics.M1
                             GHC.Generics.S
                             ('GHC.Generics.MetaSel
                                'Nothing
                                'GHC.Generics.NoSourceUnpackedness
                                'GHC.Generics.NoSourceStrictness
                                'GHC.Generics.DecidedLazy)
                             (GHC.Generics.Rec1 f_Xg3TV)
                           GHC.Generics.:*: GHC.Generics.M1
                                              GHC.Generics.S
                                              ('GHC.Generics.MetaSel
                                                 'Nothing
                                                 'GHC.Generics.NoSourceUnpackedness
                                                 'GHC.Generics.NoSourceStrictness
                                                 'GHC.Generics.DecidedLazy)
                                              (GHC.Generics.Rec1 g_Xg3TX))
                          a :: *)
                    ~R# (forall (a :: k).
                         Product f_Xg3TV g_Xg3TX a
                         -> GHC.Generics.Rep1 (Product f_Xg3TV g_Xg3TX) a :: *)))
        (Data.Functor.Product.$fGeneric1Product_$cto1
           @ k_Xg3TT @ f_Xg3TV @ g_Xg3TX)

-- RHS size: {terms: 12, types: 91, coercions: 154, joins: 0/0}
Data.Functor.Product.$fGenericProduct_$cto
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Product f g a) x -> Product f g a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_ag3OD)
                 (@ (f_ag3OE :: k_ag3OD -> *))
                 (@ (g_ag3OF :: k_ag3OD -> *))
                 (@ (a_ag3OG :: k_ag3OD))
                 (@ x_ag3Pp)
                 (ds_dg4ax [Occ=Once]
                    :: GHC.Generics.Rep (Product f_ag3OE g_ag3OF a_ag3OG) x_ag3Pp) ->
                 case ds_dg4ax
                      `cast` ((Sub (Data.Functor.Product.Rep_Product[0]
                                        <k_ag3OD>_N
                                        <f_ag3OE>_N
                                        <g_ag3OF>_N
                                        <a_ag3OG>_N) ; (GHC.Generics.N:M1[0]
                                                            <*>_N
                                                            <GHC.Generics.D>_P
                                                            <'GHC.Generics.MetaData
                                                               "Product"
                                                               "Data.Functor.Product"
                                                               "base"
                                                               'False>_P
                                                            <GHC.Generics.M1
                                                               GHC.Generics.C
                                                               ('GHC.Generics.MetaCons
                                                                  "Pair"
                                                                  'GHC.Generics.PrefixI
                                                                  'False)
                                                               (GHC.Generics.M1
                                                                  GHC.Generics.S
                                                                  ('GHC.Generics.MetaSel
                                                                     'Nothing
                                                                     'GHC.Generics.NoSourceUnpackedness
                                                                     'GHC.Generics.NoSourceStrictness
                                                                     'GHC.Generics.DecidedLazy)
                                                                  (GHC.Generics.K1
                                                                     GHC.Generics.R
                                                                     (f_ag3OE a_ag3OG))
                                                                GHC.Generics.:*: GHC.Generics.M1
                                                                                   GHC.Generics.S
                                                                                   ('GHC.Generics.MetaSel
                                                                                      'Nothing
                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                      'GHC.Generics.DecidedLazy)
                                                                                   (GHC.Generics.K1
                                                                                      GHC.Generics.R
                                                                                      (g_ag3OF a_ag3OG)))>_R ; GHC.Generics.N:M1[0]
                                                                                                                   <*>_N
                                                                                                                   <GHC.Generics.C>_P
                                                                                                                   <'GHC.Generics.MetaCons
                                                                                                                      "Pair"
                                                                                                                      'GHC.Generics.PrefixI
                                                                                                                      'False>_P
                                                                                                                   <GHC.Generics.M1
                                                                                                                      GHC.Generics.S
                                                                                                                      ('GHC.Generics.MetaSel
                                                                                                                         'Nothing
                                                                                                                         'GHC.Generics.NoSourceUnpackedness
                                                                                                                         'GHC.Generics.NoSourceStrictness
                                                                                                                         'GHC.Generics.DecidedLazy)
                                                                                                                      (GHC.Generics.K1
                                                                                                                         GHC.Generics.R
                                                                                                                         (f_ag3OE a_ag3OG))
                                                                                                                    GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                       GHC.Generics.S
                                                                                                                                       ('GHC.Generics.MetaSel
                                                                                                                                          'Nothing
                                                                                                                                          'GHC.Generics.NoSourceUnpackedness
                                                                                                                                          'GHC.Generics.NoSourceStrictness
                                                                                                                                          'GHC.Generics.DecidedLazy)
                                                                                                                                       (GHC.Generics.K1
                                                                                                                                          GHC.Generics.R
                                                                                                                                          (g_ag3OF a_ag3OG))>_R)) <x_ag3Pp>_N
                              :: (GHC.Generics.Rep
                                    (Product f_ag3OE g_ag3OF a_ag3OG) x_ag3Pp :: *)
                                 ~R# ((GHC.Generics.:*:)
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG)))
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
                                        x_ag3Pp :: *))
                 of
                 { GHC.Generics.:*: ds1_dg4aA [Occ=Once] ds2_dg4aB [Occ=Once] ->
                 Data.Functor.Product.Pair
                   @ k_ag3OD
                   @ f_ag3OE
                   @ g_ag3OF
                   @ a_ag3OG
                   (ds1_dg4aA
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.S>_P
                                <'GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.NoSourceStrictness
                                   'GHC.Generics.DecidedLazy>_P
                                <GHC.Generics.K1
                                   GHC.Generics.R
                                   (f_ag3OE a_ag3OG)>_R <x_ag3Pp>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <f_ag3OE a_ag3OG>_R
                                                                          <x_ag3Pp>_P
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                                  x_ag3Pp :: *)
                               ~R# (f_ag3OE a_ag3OG :: *)))
                   (ds2_dg4aB
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.S>_P
                                <'GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.NoSourceStrictness
                                   'GHC.Generics.DecidedLazy>_P
                                <GHC.Generics.K1
                                   GHC.Generics.R
                                   (g_ag3OF a_ag3OG)>_R <x_ag3Pp>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <g_ag3OF a_ag3OG>_R
                                                                          <x_ag3Pp>_P
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG))
                                  x_ag3Pp :: *)
                               ~R# (g_ag3OF a_ag3OG :: *)))
                 }}]
Data.Functor.Product.$fGenericProduct_$cto
  = \ (@ k_ag3OD)
      (@ (f_ag3OE :: k_ag3OD -> *))
      (@ (g_ag3OF :: k_ag3OD -> *))
      (@ (a_ag3OG :: k_ag3OD))
      (@ x_ag3Pp)
      (ds_dg4ax
         :: GHC.Generics.Rep (Product f_ag3OE g_ag3OF a_ag3OG) x_ag3Pp) ->
      case ds_dg4ax
           `cast` ((Sub (Data.Functor.Product.Rep_Product[0]
                             <k_ag3OD>_N
                             <f_ag3OE>_N
                             <g_ag3OF>_N
                             <a_ag3OG>_N) ; (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <GHC.Generics.D>_P
                                                 <'GHC.Generics.MetaData
                                                    "Product"
                                                    "Data.Functor.Product"
                                                    "base"
                                                    'False>_P
                                                 <GHC.Generics.M1
                                                    GHC.Generics.C
                                                    ('GHC.Generics.MetaCons
                                                       "Pair" 'GHC.Generics.PrefixI 'False)
                                                    (GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy)
                                                       (GHC.Generics.K1
                                                          GHC.Generics.R (f_ag3OE a_ag3OG))
                                                     GHC.Generics.:*: GHC.Generics.M1
                                                                        GHC.Generics.S
                                                                        ('GHC.Generics.MetaSel
                                                                           'Nothing
                                                                           'GHC.Generics.NoSourceUnpackedness
                                                                           'GHC.Generics.NoSourceStrictness
                                                                           'GHC.Generics.DecidedLazy)
                                                                        (GHC.Generics.K1
                                                                           GHC.Generics.R
                                                                           (g_ag3OF a_ag3OG)))>_R ; GHC.Generics.N:M1[0]
                                                                                                        <*>_N
                                                                                                        <GHC.Generics.C>_P
                                                                                                        <'GHC.Generics.MetaCons
                                                                                                           "Pair"
                                                                                                           'GHC.Generics.PrefixI
                                                                                                           'False>_P
                                                                                                        <GHC.Generics.M1
                                                                                                           GHC.Generics.S
                                                                                                           ('GHC.Generics.MetaSel
                                                                                                              'Nothing
                                                                                                              'GHC.Generics.NoSourceUnpackedness
                                                                                                              'GHC.Generics.NoSourceStrictness
                                                                                                              'GHC.Generics.DecidedLazy)
                                                                                                           (GHC.Generics.K1
                                                                                                              GHC.Generics.R
                                                                                                              (f_ag3OE a_ag3OG))
                                                                                                         GHC.Generics.:*: GHC.Generics.M1
                                                                                                                            GHC.Generics.S
                                                                                                                            ('GHC.Generics.MetaSel
                                                                                                                               'Nothing
                                                                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                                                                               'GHC.Generics.NoSourceStrictness
                                                                                                                               'GHC.Generics.DecidedLazy)
                                                                                                                            (GHC.Generics.K1
                                                                                                                               GHC.Generics.R
                                                                                                                               (g_ag3OF a_ag3OG))>_R)) <x_ag3Pp>_N
                   :: (GHC.Generics.Rep
                         (Product f_ag3OE g_ag3OF a_ag3OG) x_ag3Pp :: *)
                      ~R# ((GHC.Generics.:*:)
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.NoSourceStrictness
                                   'GHC.Generics.DecidedLazy)
                                (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG)))
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.NoSourceStrictness
                                   'GHC.Generics.DecidedLazy)
                                (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
                             x_ag3Pp :: *))
      of
      { GHC.Generics.:*: ds1_dg4aA ds2_dg4aB ->
      Data.Functor.Product.Pair
        @ k_ag3OD
        @ f_ag3OE
        @ g_ag3OF
        @ a_ag3OG
        (ds1_dg4aA
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <GHC.Generics.S>_P
                     <'GHC.Generics.MetaSel
                        'Nothing
                        'GHC.Generics.NoSourceUnpackedness
                        'GHC.Generics.NoSourceStrictness
                        'GHC.Generics.DecidedLazy>_P
                     <GHC.Generics.K1
                        GHC.Generics.R
                        (f_ag3OE a_ag3OG)>_R <x_ag3Pp>_N ; GHC.Generics.N:K1[0]
                                                               <*>_N
                                                               <GHC.Generics.R>_P
                                                               <f_ag3OE a_ag3OG>_R
                                                               <x_ag3Pp>_P
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                       x_ag3Pp :: *)
                    ~R# (f_ag3OE a_ag3OG :: *)))
        (ds2_dg4aB
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <GHC.Generics.S>_P
                     <'GHC.Generics.MetaSel
                        'Nothing
                        'GHC.Generics.NoSourceUnpackedness
                        'GHC.Generics.NoSourceStrictness
                        'GHC.Generics.DecidedLazy>_P
                     <GHC.Generics.K1
                        GHC.Generics.R
                        (g_ag3OF a_ag3OG)>_R <x_ag3Pp>_N ; GHC.Generics.N:K1[0]
                                                               <*>_N
                                                               <GHC.Generics.R>_P
                                                               <g_ag3OF a_ag3OG>_R
                                                               <x_ag3Pp>_P
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG))
                       x_ag3Pp :: *)
                    ~R# (g_ag3OF a_ag3OG :: *)))
      }

-- RHS size: {terms: 12, types: 59, coercions: 99, joins: 0/0}
Data.Functor.Product.$fGenericProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) x.
     Product f g a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R (f a))
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R (g a)))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_ag3OD)
                 (@ (f_ag3OE :: k_ag3OD -> *))
                 (@ (g_ag3OF :: k_ag3OD -> *))
                 (@ (a_ag3OG :: k_ag3OD))
                 (@ x_ag3OK)
                 (x1_ag3KG [Occ=Once!] :: Product f_ag3OE g_ag3OF a_ag3OG) ->
                 case x1_ag3KG of { Pair g1_ag3KH [Occ=Once] g2_ag3KI [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ *
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.NoSourceStrictness
                            'GHC.Generics.DecidedLazy)
                         (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG)))
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.NoSourceStrictness
                            'GHC.Generics.DecidedLazy)
                         (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
                    @ x_ag3OK
                    (g1_ag3KH
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <GHC.Generics.R>_P
                                      <f_ag3OE a_ag3OG>_R
                                      <x_ag3OK>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.S>_P
                                                              <'GHC.Generics.MetaSel
                                                                 'Nothing
                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                 'GHC.Generics.NoSourceStrictness
                                                                 'GHC.Generics.DecidedLazy>_P
                                                              <GHC.Generics.K1
                                                                 GHC.Generics.R
                                                                 (f_ag3OE a_ag3OG)>_R) <x_ag3OK>_N
                             :: (f_ag3OE a_ag3OG :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                                       x_ag3OK :: *)))
                    (g2_ag3KI
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <GHC.Generics.R>_P
                                      <g_ag3OF a_ag3OG>_R
                                      <x_ag3OK>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.S>_P
                                                              <'GHC.Generics.MetaSel
                                                                 'Nothing
                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                 'GHC.Generics.NoSourceStrictness
                                                                 'GHC.Generics.DecidedLazy>_P
                                                              <GHC.Generics.K1
                                                                 GHC.Generics.R
                                                                 (g_ag3OF a_ag3OG)>_R) <x_ag3OK>_N
                             :: (g_ag3OF a_ag3OG :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.NoSourceStrictness
                                          'GHC.Generics.DecidedLazy)
                                       (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG))
                                       x_ag3OK :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <GHC.Generics.C>_P
                                  <'GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False>_P
                                  <GHC.Generics.M1
                                     GHC.Generics.S
                                     ('GHC.Generics.MetaSel
                                        'Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.NoSourceStrictness
                                        'GHC.Generics.DecidedLazy)
                                     (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                                   GHC.Generics.:*: GHC.Generics.M1
                                                      GHC.Generics.S
                                                      ('GHC.Generics.MetaSel
                                                         'Nothing
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.NoSourceStrictness
                                                         'GHC.Generics.DecidedLazy)
                                                      (GHC.Generics.K1
                                                         GHC.Generics.R
                                                         (g_ag3OF a_ag3OG))>_R) <x_ag3OK>_N
                         :: ((GHC.Generics.:*:)
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG)))
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.NoSourceStrictness
                                     'GHC.Generics.DecidedLazy)
                                  (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
                               x_ag3OK :: *)
                            ~R# (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy)
                                                       (GHC.Generics.K1
                                                          GHC.Generics.R (g_ag3OF a_ag3OG)))
                                   x_ag3OK :: *))
                 }}]
Data.Functor.Product.$fGenericProduct1
  = \ (@ k_ag3OD)
      (@ (f_ag3OE :: k_ag3OD -> *))
      (@ (g_ag3OF :: k_ag3OD -> *))
      (@ (a_ag3OG :: k_ag3OD))
      (@ x_ag3OK)
      (x1_ag3KG :: Product f_ag3OE g_ag3OF a_ag3OG) ->
      case x1_ag3KG of { Pair g1_ag3KH g2_ag3KI ->
      (GHC.Generics.:*:
         @ *
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.NoSourceStrictness
                 'GHC.Generics.DecidedLazy)
              (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG)))
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.NoSourceStrictness
                 'GHC.Generics.DecidedLazy)
              (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
         @ x_ag3OK
         (g1_ag3KH
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N
                           <GHC.Generics.R>_P
                           <f_ag3OE a_ag3OG>_R
                           <x_ag3OK>_P) ; Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy>_P
                                                   <GHC.Generics.K1
                                                      GHC.Generics.R
                                                      (f_ag3OE a_ag3OG)>_R) <x_ag3OK>_N
                  :: (f_ag3OE a_ag3OG :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                            x_ag3OK :: *)))
         (g2_ag3KI
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N
                           <GHC.Generics.R>_P
                           <g_ag3OF a_ag3OG>_R
                           <x_ag3OK>_P) ; Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.NoSourceStrictness
                                                      'GHC.Generics.DecidedLazy>_P
                                                   <GHC.Generics.K1
                                                      GHC.Generics.R
                                                      (g_ag3OF a_ag3OG)>_R) <x_ag3OK>_N
                  :: (g_ag3OF a_ag3OG :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG))
                            x_ag3OK :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <*>_N
                       <GHC.Generics.C>_P
                       <'GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False>_P
                       <GHC.Generics.M1
                          GHC.Generics.S
                          ('GHC.Generics.MetaSel
                             'Nothing
                             'GHC.Generics.NoSourceUnpackedness
                             'GHC.Generics.NoSourceStrictness
                             'GHC.Generics.DecidedLazy)
                          (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                        GHC.Generics.:*: GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.K1
                                              GHC.Generics.R (g_ag3OF a_ag3OG))>_R) <x_ag3OK>_N
              :: ((GHC.Generics.:*:)
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG)))
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.NoSourceStrictness
                          'GHC.Generics.DecidedLazy)
                       (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
                    x_ag3OK :: *)
                 ~R# (GHC.Generics.M1
                        GHC.Generics.C
                        ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                        (GHC.Generics.M1
                           GHC.Generics.S
                           ('GHC.Generics.MetaSel
                              'Nothing
                              'GHC.Generics.NoSourceUnpackedness
                              'GHC.Generics.NoSourceStrictness
                              'GHC.Generics.DecidedLazy)
                           (GHC.Generics.K1 GHC.Generics.R (f_ag3OE a_ag3OG))
                         GHC.Generics.:*: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.NoSourceStrictness
                                               'GHC.Generics.DecidedLazy)
                                            (GHC.Generics.K1 GHC.Generics.R (g_ag3OF a_ag3OG)))
                        x_ag3OK :: *))
      }

-- RHS size: {terms: 7, types: 22, coercions: 70, joins: 0/0}
Data.Functor.Product.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Generic (Product f g a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ k_ag3FE)
             (@ (f_ag3DT :: k_ag3FE -> *))
             (@ (g_ag3DU :: k_ag3FE -> *))
             (@ (a_ag3DV :: k_ag3FE)) ->
       GHC.Generics.C:Generic TYPE: Product f_ag3DT g_ag3DU a_ag3DV
                              (Data.Functor.Product.$fGenericProduct1
                                 @ k_ag3FE @ f_ag3DT @ g_ag3DU @ a_ag3DV)
                              `cast` (forall (x :: <*>_N).
                                      <Product f_ag3DT g_ag3DU a_ag3DV>_R
                                      ->_R (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <GHC.Generics.D>_P
                                                     <'GHC.Generics.MetaData
                                                        "Product"
                                                        "Data.Functor.Product"
                                                        "base"
                                                        'False>_P
                                                     <GHC.Generics.M1
                                                        GHC.Generics.C
                                                        ('GHC.Generics.MetaCons
                                                           "Pair" 'GHC.Generics.PrefixI 'False)
                                                        (GHC.Generics.M1
                                                           GHC.Generics.S
                                                           ('GHC.Generics.MetaSel
                                                              'Nothing
                                                              'GHC.Generics.NoSourceUnpackedness
                                                              'GHC.Generics.NoSourceStrictness
                                                              'GHC.Generics.DecidedLazy)
                                                           (GHC.Generics.K1
                                                              GHC.Generics.R (f_ag3DT a_ag3DV))
                                                         GHC.Generics.:*: GHC.Generics.M1
                                                                            GHC.Generics.S
                                                                            ('GHC.Generics.MetaSel
                                                                               'Nothing
                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                               'GHC.Generics.NoSourceStrictness
                                                                               'GHC.Generics.DecidedLazy)
                                                                            (GHC.Generics.K1
                                                                               GHC.Generics.R
                                                                               (g_ag3DU a_ag3DV)))>_R) ; Sub (Sym (Data.Functor.Product.Rep_Product[0]
                                                                                                                       <k_ag3FE>_N
                                                                                                                       <f_ag3DT>_N
                                                                                                                       <g_ag3DU>_N
                                                                                                                       <a_ag3DV>_N))) <x>_N
                                      :: (forall x.
                                          Product f_ag3DT g_ag3DU a_ag3DV
                                          -> GHC.Generics.M1
                                               GHC.Generics.C
                                               ('GHC.Generics.MetaCons
                                                  "Pair" 'GHC.Generics.PrefixI 'False)
                                               (GHC.Generics.M1
                                                  GHC.Generics.S
                                                  ('GHC.Generics.MetaSel
                                                     'Nothing
                                                     'GHC.Generics.NoSourceUnpackedness
                                                     'GHC.Generics.NoSourceStrictness
                                                     'GHC.Generics.DecidedLazy)
                                                  (GHC.Generics.K1 GHC.Generics.R (f_ag3DT a_ag3DV))
                                                GHC.Generics.:*: GHC.Generics.M1
                                                                   GHC.Generics.S
                                                                   ('GHC.Generics.MetaSel
                                                                      'Nothing
                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                      'GHC.Generics.NoSourceStrictness
                                                                      'GHC.Generics.DecidedLazy)
                                                                   (GHC.Generics.K1
                                                                      GHC.Generics.R
                                                                      (g_ag3DU a_ag3DV)))
                                               x :: *)
                                         ~R# (forall x.
                                              Product f_ag3DT g_ag3DU a_ag3DV
                                              -> GHC.Generics.Rep
                                                   (Product f_ag3DT g_ag3DU a_ag3DV) x :: *))
                              Data.Functor.Product.$fGenericProduct_$cto
                                @ k_ag3FE @ f_ag3DT @ g_ag3DU @ a_ag3DV]
Data.Functor.Product.$fGenericProduct
  = \ (@ k_Xg3Sz)
      (@ (f_Xg3SB :: k_Xg3Sz -> *))
      (@ (g_Xg3SD :: k_Xg3Sz -> *))
      (@ (a_Xg3SF :: k_Xg3Sz)) ->
      GHC.Generics.C:Generic
        @ (Product f_Xg3SB g_Xg3SD a_Xg3SF)
        ((Data.Functor.Product.$fGenericProduct1
            @ k_Xg3Sz @ f_Xg3SB @ g_Xg3SD @ a_Xg3SF)
         `cast` (forall (x :: <*>_N).
                 <Product f_Xg3SB g_Xg3SD a_Xg3SF>_R
                 ->_R (Sym (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.D>_P
                                <'GHC.Generics.MetaData
                                   "Product" "Data.Functor.Product" "base" 'False>_P
                                <GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.NoSourceStrictness
                                         'GHC.Generics.DecidedLazy)
                                      (GHC.Generics.K1 GHC.Generics.R (f_Xg3SB a_Xg3SF))
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy)
                                                       (GHC.Generics.K1
                                                          GHC.Generics.R
                                                          (g_Xg3SD a_Xg3SF)))>_R) ; Sub (Sym (Data.Functor.Product.Rep_Product[0]
                                                                                                  <k_Xg3Sz>_N
                                                                                                  <f_Xg3SB>_N
                                                                                                  <g_Xg3SD>_N
                                                                                                  <a_Xg3SF>_N))) <x>_N
                 :: (forall x.
                     Product f_Xg3SB g_Xg3SD a_Xg3SF
                     -> GHC.Generics.M1
                          GHC.Generics.C
                          ('GHC.Generics.MetaCons "Pair" 'GHC.Generics.PrefixI 'False)
                          (GHC.Generics.M1
                             GHC.Generics.S
                             ('GHC.Generics.MetaSel
                                'Nothing
                                'GHC.Generics.NoSourceUnpackedness
                                'GHC.Generics.NoSourceStrictness
                                'GHC.Generics.DecidedLazy)
                             (GHC.Generics.K1 GHC.Generics.R (f_Xg3SB a_Xg3SF))
                           GHC.Generics.:*: GHC.Generics.M1
                                              GHC.Generics.S
                                              ('GHC.Generics.MetaSel
                                                 'Nothing
                                                 'GHC.Generics.NoSourceUnpackedness
                                                 'GHC.Generics.NoSourceStrictness
                                                 'GHC.Generics.DecidedLazy)
                                              (GHC.Generics.K1 GHC.Generics.R (g_Xg3SD a_Xg3SF)))
                          x :: *)
                    ~R# (forall x.
                         Product f_Xg3SB g_Xg3SD a_Xg3SF
                         -> GHC.Generics.Rep (Product f_Xg3SB g_Xg3SD a_Xg3SF) x :: *)))
        (Data.Functor.Product.$fGenericProduct_$cto
           @ k_Xg3Sz @ f_Xg3SB @ g_Xg3SD @ a_Xg3SF)

-- RHS size: {terms: 25, types: 96, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct_$cgfoldl
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1) -> Product f g a -> c (Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_ag3L4)
                 (@ (f_ag3L5 :: k_ag3L4 -> *))
                 (@ (g_ag3L6 :: k_ag3L4 -> *))
                 (@ (a_ag3L7 :: k_ag3L4))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData_ag3Lc [Occ=Once] :: Data (f_ag3L5 a_ag3L7))
                 ($dData1_ag3Ld [Occ=Once] :: Data (g_ag3L6 a_ag3L7))
                 (@ (c_ag3Ll :: * -> *))
                 (k1_ag3KA
                    :: forall d b. Data d => c_ag3Ll (d -> b) -> d -> c_ag3Ll b)
                 (z_ag3KB [Occ=Once!] :: forall g1. g1 -> c_ag3Ll g1)
                 (ds_dg4ab [Occ=Once!] :: Product f_ag3L5 g_ag3L6 a_ag3L7) ->
                 case ds_dg4ab of { Pair a1_ag3KC [Occ=Once] a2_ag3KD [Occ=Once] ->
                 k1_ag3KA
                   @ (g_ag3L6 a_ag3L7)
                   @ (Product f_ag3L5 g_ag3L6 a_ag3L7)
                   $dData1_ag3Ld
                   (k1_ag3KA
                      @ (f_ag3L5 a_ag3L7)
                      @ (g_ag3L6 a_ag3L7 -> Product f_ag3L5 g_ag3L6 a_ag3L7)
                      $dData_ag3Lc
                      (z_ag3KB
                         @ (f_ag3L5 a_ag3L7
                            -> g_ag3L6 a_ag3L7 -> Product f_ag3L5 g_ag3L6 a_ag3L7)
                         (Data.Functor.Product.Pair
                            @ k_ag3L4 @ f_ag3L5 @ g_ag3L6 @ a_ag3L7))
                      a1_ag3KC)
                   a2_ag3KD
                 }}]
Data.Functor.Product.$fDataProduct_$cgfoldl
  = \ (@ k_ag3L4)
      (@ (f_ag3L5 :: k_ag3L4 -> *))
      (@ (g_ag3L6 :: k_ag3L4 -> *))
      (@ (a_ag3L7 :: k_ag3L4))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData_ag3Lc :: Data (f_ag3L5 a_ag3L7))
      ($dData1_ag3Ld :: Data (g_ag3L6 a_ag3L7))
      (@ (c_ag3Ll :: * -> *))
      (k1_ag3KA
         :: forall d b. Data d => c_ag3Ll (d -> b) -> d -> c_ag3Ll b)
      (z_ag3KB :: forall g1. g1 -> c_ag3Ll g1)
      (ds_dg4ab :: Product f_ag3L5 g_ag3L6 a_ag3L7) ->
      case ds_dg4ab of { Pair a1_ag3KC a2_ag3KD ->
      k1_ag3KA
        @ (g_ag3L6 a_ag3L7)
        @ (Product f_ag3L5 g_ag3L6 a_ag3L7)
        $dData1_ag3Ld
        (k1_ag3KA
           @ (f_ag3L5 a_ag3L7)
           @ (g_ag3L6 a_ag3L7 -> Product f_ag3L5 g_ag3L6 a_ag3L7)
           $dData_ag3Lc
           (z_ag3KB
              @ (f_ag3L5 a_ag3L7
                 -> g_ag3L6 a_ag3L7 -> Product f_ag3L5 g_ag3L6 a_ag3L7)
              (Data.Functor.Product.Pair
                 @ k_ag3L4 @ f_ag3L5 @ g_ag3L6 @ a_ag3L7))
           a1_ag3KC)
        a2_ag3KD
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Product.$fDataProduct6 = "Product"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Product.$fDataProduct5
  = GHC.CString.unpackCString# Data.Functor.Product.$fDataProduct6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go61_rg5o2 :: [Data.Data.Constr] -> [Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go61_rg5o2
  = \ (ds2_iaIB3 :: [Data.Data.Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString
                     ds4_de7m4 Data.Functor.Product.$fRead1Product2
              of {
                False -> go61_rg5o2 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cPair1_rg5o3 :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cPair1_rg5o3 = Data.Data.AlgConstr $cPair2_rg5o4

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct4 :: [Data.Data.Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Product.$fDataProduct4
  = GHC.Types.:
      @ Data.Data.Constr
      Data.Functor.Product.$cPair
      (GHC.Types.[] @ Data.Data.Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct3 :: Data.Data.DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$fDataProduct3
  = Data.Data.AlgRep Data.Functor.Product.$fDataProduct4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$tProduct :: Data.Data.DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Product.$tProduct
  = Data.Data.DataType
      Data.Functor.Product.$fDataProduct5
      Data.Functor.Product.$fDataProduct3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Functor.Product.$cPair [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Functor.Product.$cPair
  = Data.Data.Constr
      $cPair1_rg5o3
      Data.Functor.Product.$fRead1Product2
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Functor.Product.$tProduct

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cPair2_rg5o4 :: Data.Data.ConIndex
[GblId]
$cPair2_rg5o4
  = go61_rg5o2
      Data.Functor.Product.$fDataProduct4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Functor.Product.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$trModule3
  = GHC.Types.TrNameS Data.Functor.Product.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Data.Functor.Product.$trModule2 = "Data.Functor.Product"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$trModule1
  = GHC.Types.TrNameS Data.Functor.Product.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Product.$trModule
  = GHC.Types.Module
      Data.Functor.Product.$trModule3 Data.Functor.Product.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_rg5o5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_rg5o5 = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep1_rg5o6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep1_rg5o6 = GHC.Types.KindRepFun $krep_rg5o5 GHC.Types.krep$*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_rg5o7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep2_rg5o7 = GHC.Types.KindRepFun $krep1_rg5o6 $krep1_rg5o6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct8 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Product.$fDataProduct8
  = GHC.Types.KindRepFun $krep1_rg5o6 $krep2_rg5o7

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3_rg5o8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_rg5o8 = GHC.Types.KindRepVar 2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep4_rg5o9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_rg5o9 = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep5_rg5oa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep5_rg5oa = GHC.Types.KindRepVar 3#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6_rg5ob :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep6_rg5ob = GHC.Types.KindRepApp $krep4_rg5o9 $krep5_rg5oa

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_rg5oc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep7_rg5oc = GHC.Types.KindRepApp $krep3_rg5o8 $krep5_rg5oa

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct9 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$fDataProduct9
  = GHC.Types.TrNameS Data.Functor.Product.$fDataProduct6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$tcProduct :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Product.$tcProduct
  = GHC.Types.TyCon
      9904636435990105341##
      16069493191308336164##
      Data.Functor.Product.$trModule
      Data.Functor.Product.$fDataProduct9
      1#
      Data.Functor.Product.$fDataProduct8

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep8_rg5od :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep8_rg5od
  = GHC.Types.:
      @ GHC.Types.KindRep $krep5_rg5oa (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep9_rg5oe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep9_rg5oe
  = GHC.Types.: @ GHC.Types.KindRep $krep3_rg5o8 $krep8_rg5od

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep10_rg5of :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep10_rg5of
  = GHC.Types.: @ GHC.Types.KindRep $krep4_rg5o9 $krep9_rg5oe

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep11_rg5og :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep11_rg5og
  = GHC.Types.: @ GHC.Types.KindRep $krep_rg5o5 $krep10_rg5of

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_rg5oh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep12_rg5oh
  = GHC.Types.KindRepTyConApp
      Data.Functor.Product.$tcProduct $krep11_rg5og

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_rg5oi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep13_rg5oi = GHC.Types.KindRepFun $krep7_rg5oc $krep12_rg5oh

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$tc'Pair1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Functor.Product.$tc'Pair1
  = GHC.Types.KindRepFun $krep6_rg5ob $krep13_rg5oi

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$tc'Pair3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Functor.Product.$tc'Pair3 = "'Pair"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$tc'Pair2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Functor.Product.$tc'Pair2
  = GHC.Types.TrNameS Data.Functor.Product.$tc'Pair3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Functor.Product.$tc'Pair :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Functor.Product.$tc'Pair
  = GHC.Types.TyCon
      11374113252541295849##
      18011678063065699923##
      Data.Functor.Product.$trModule
      Data.Functor.Product.$tc'Pair2
      4#
      Data.Functor.Product.$tc'Pair1

-- RHS size: {terms: 33, types: 123, coercions: 17, joins: 0/0}
Data.Functor.Product.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k) =>
     Data.Typeable.Internal.TypeRep (Product f g a)
[GblId,
 Arity=4,
 Str=<S,U><S,U><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 210 0}]
Data.Functor.Product.$w$cp1Data
  = \ (@ k_sg4X3)
      (@ (f_sg4X4 :: k_sg4X3 -> *))
      (@ (g_sg4X5 :: k_sg4X3 -> *))
      (@ (a_sg4X6 :: k_sg4X3))
      (w_sg4X7 :: Data.Typeable.Internal.Typeable a_sg4X6)
      (w1_sg4X8 :: Data.Typeable.Internal.Typeable f_sg4X4)
      (w2_sg4X9 :: Data.Typeable.Internal.Typeable g_sg4X5)
      (w3_sg4Xa :: Data.Typeable.Internal.Typeable k_sg4X3) ->
      case Data.Typeable.Internal.$wmkTrCon
             @ ((k_sg4X3 -> *) -> (k_sg4X3 -> *) -> k_sg4X3 -> *)
             @ Product
             9904636435990105341##
             16069493191308336164##
             Data.Functor.Product.$trModule
             Data.Functor.Product.$fDataProduct9
             1#
             Data.Functor.Product.$fDataProduct8
             (GHC.Types.:
                @ Data.Typeable.Internal.SomeTypeRep
                (Data.Typeable.Internal.SomeTypeRep
                   @ *
                   @ k_sg4X3
                   (w3_sg4Xa
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <k_sg4X3>_N
                            :: (Data.Typeable.Internal.Typeable k_sg4X3 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep k_sg4X3 :: *))))
                (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep))
      of
      { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
      Data.Typeable.Internal.mkTrApp
        @ k_sg4X3
        @ *
        @ (Product f_sg4X4 g_sg4X5)
        @ a_sg4X6
        (Data.Typeable.Internal.mkTrApp
           @ (k_sg4X3 -> *)
           @ (k_sg4X3 -> *)
           @ (Product f_sg4X4)
           @ g_sg4X5
           (Data.Typeable.Internal.mkTrApp
              @ (k_sg4X3 -> *)
              @ ((k_sg4X3 -> *) -> k_sg4X3 -> *)
              @ Product
              @ f_sg4X4
              (Data.Typeable.Internal.TrTyCon
                 @ ((k_sg4X3 -> *) -> (k_sg4X3 -> *) -> k_sg4X3 -> *)
                 @ Product
                 ww8_idPJm
                 ww9_idPJn
                 ww10_idPJo
                 ww11_idPJp
                 ww12_idPJq)
              (w1_sg4X8
               `cast` (Data.Typeable.Internal.N:Typeable[0] <k_sg4X3
                                                             -> *>_N <f_sg4X4>_N
                       :: (Data.Typeable.Internal.Typeable f_sg4X4 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep f_sg4X4 :: *))))
           (w2_sg4X9
            `cast` (Data.Typeable.Internal.N:Typeable[0] <k_sg4X3
                                                          -> *>_N <g_sg4X5>_N
                    :: (Data.Typeable.Internal.Typeable g_sg4X5 :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep g_sg4X5 :: *))))
        (w_sg4X7
         `cast` (Data.Typeable.Internal.N:Typeable[0] <k_sg4X3>_N <a_sg4X6>_N
                 :: (Data.Typeable.Internal.Typeable a_sg4X6 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_sg4X6 :: *)))
      }

-- RHS size: {terms: 15, types: 36, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct7 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     Data.Typeable.Internal.TypeRep (Product f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ k_sg4X3)
                 (@ (f_sg4X4 :: k_sg4X3 -> *))
                 (@ (g_sg4X5 :: k_sg4X3 -> *))
                 (@ (a_sg4X6 :: k_sg4X3))
                 (w_sg4X7 [Occ=Once] :: Data.Typeable.Internal.Typeable a_sg4X6)
                 (w1_sg4X8 [Occ=Once] :: Data.Typeable.Internal.Typeable f_sg4X4)
                 (w2_sg4X9 [Occ=Once] :: Data.Typeable.Internal.Typeable g_sg4X5)
                 (w3_sg4Xa [Occ=Once] :: Data.Typeable.Internal.Typeable k_sg4X3)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 Data.Functor.Product.$w$cp1Data
                   @ k_sg4X3
                   @ f_sg4X4
                   @ g_sg4X5
                   @ a_sg4X6
                   w_sg4X7
                   w1_sg4X8
                   w2_sg4X9
                   w3_sg4Xa}]
Data.Functor.Product.$fDataProduct7
  = \ (@ k_sg4X3)
      (@ (f_sg4X4 :: k_sg4X3 -> *))
      (@ (g_sg4X5 :: k_sg4X3 -> *))
      (@ (a_sg4X6 :: k_sg4X3))
      (w_sg4X7 :: Data.Typeable.Internal.Typeable a_sg4X6)
      (w1_sg4X8 :: Data.Typeable.Internal.Typeable f_sg4X4)
      (w2_sg4X9 :: Data.Typeable.Internal.Typeable g_sg4X5)
      (w3_sg4Xa :: Data.Typeable.Internal.Typeable k_sg4X3)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Functor.Product.$w$cp1Data
        @ k_sg4X3
        @ f_sg4X4
        @ g_sg4X5
        @ a_sg4X6
        w_sg4X7
        w1_sg4X8
        w2_sg4X9
        w3_sg4Xa

-- RHS size: {terms: 7, types: 23, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct1
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (f a -> g a -> Product f g a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Functor.Product.$fDataProduct1
  = \ (@ k_Xg3PW)
      (@ (f_Xg3PY :: k_Xg3PW -> *))
      (@ (g_Xg3Q0 :: k_Xg3PW -> *))
      (@ (a_Xg3Q2 :: k_Xg3PW)) ->
      (Data.Functor.Product.Pair @ k_Xg3PW @ f_Xg3PY @ g_Xg3Q0 @ a_Xg3Q2,
       GHC.Types.False)

-- RHS size: {terms: 77, types: 199, coercions: 26, joins: 0/4}
Data.Functor.Product.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data (f a), Data (g a)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> Product f g a -> m (Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 640 0}]
Data.Functor.Product.$w$cgmapMp
  = \ (@ k_sg4Xj)
      (@ (f_sg4Xk :: k_sg4Xj -> *))
      (@ (g_sg4Xl :: k_sg4Xj -> *))
      (@ (a_sg4Xm :: k_sg4Xj))
      (w_sg4Xr :: Data (f_sg4Xk a_sg4Xm))
      (w1_sg4Xs :: Data (g_sg4Xl a_sg4Xm))
      (@ (m_sg4Xt :: * -> *))
      (w2_sg4Xu :: MonadPlus m_sg4Xt)
      (w3_sg4Xv :: forall d. Data d => d -> m_sg4Xt d)
      (w4_sg4Xw :: Product f_sg4Xk g_sg4Xl a_sg4Xm) ->
      let {
        lvl9_sg4oY :: m_sg4Xt (Product f_sg4Xk g_sg4Xl a_sg4Xm)
        [LclId]
        lvl9_sg4oY
          = mzero @ m_sg4Xt w2_sg4Xu @ (Product f_sg4Xk g_sg4Xl a_sg4Xm) } in
      let {
        $dMonad_sg4n6 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_sg4Xt
        [LclId]
        $dMonad_sg4n6 = GHC.Base.$p2MonadPlus @ m_sg4Xt w2_sg4Xu } in
      >>=
        @ m_sg4Xt
        $dMonad_sg4n6
        @ (Product f_sg4Xk g_sg4Xl a_sg4Xm, Bool)
        @ (Product f_sg4Xk g_sg4Xl a_sg4Xm)
        (case w4_sg4Xw of { Pair a1_ag3KC a2_ag3KD ->
         let {
           k1_sg4n5 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Data.Data.Mp m_sg4Xt (d -> b) -> d -> m_sg4Xt (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k1_sg4n5
             = \ (@ d_ae2Ws)
                 (@ b_ae2Wt)
                 ($dData1_ae2Wv :: Data d_ae2Ws)
                 (ds_de7oC [OS=OneShot]
                    :: Data.Data.Mp m_sg4Xt (d_ae2Ws -> b_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl10_sg4oW :: m_sg4Xt d_ae2Ws
                   [LclId]
                   lvl10_sg4oW = w3_sg4Xv @ d_ae2Ws $dData1_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_sg4Xt
                   $dMonad_sg4n6
                   @ (d_ae2Ws -> b_ae2Wt, Bool)
                   @ (b_ae2Wt, Bool)
                   (ds_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_sg4Xt>_R <d_ae2Ws -> b_ae2Wt>_N
                            :: (Data.Data.Mp m_sg4Xt (d_ae2Ws -> b_ae2Wt) :: *)
                               ~R# (m_sg4Xt (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                   (\ (ds1_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                      case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
                      mplus
                        @ m_sg4Xt
                        w2_sg4Xu
                        @ (b_ae2Wt, Bool)
                        (>>=
                           @ m_sg4Xt
                           $dMonad_sg4n6
                           @ d_ae2Ws
                           @ (b_ae2Wt, Bool)
                           lvl10_sg4oW
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_sg4Xt
                                $dMonad_sg4n6
                                @ (b_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_sg4Xt
                           $dMonad_sg4n6
                           @ (b_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b1_ae1TB))
                      }) } in
         k1_sg4n5
           @ (g_sg4Xl a_sg4Xm)
           @ (Product f_sg4Xk g_sg4Xl a_sg4Xm)
           w1_sg4Xs
           ((k1_sg4n5
               @ (f_sg4Xk a_sg4Xm)
               @ (g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm)
               w_sg4Xr
               ((return
                   @ m_sg4Xt
                   $dMonad_sg4n6
                   @ (f_sg4Xk a_sg4Xm
                      -> g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm,
                      Bool)
                   (Data.Functor.Product.$fDataProduct1
                      @ k_sg4Xj @ f_sg4Xk @ g_sg4Xl @ a_sg4Xm))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_sg4Xt>_R
                                 <f_sg4Xk a_sg4Xm
                                  -> g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm>_N)
                        :: (m_sg4Xt (f_sg4Xk a_sg4Xm
                                     -> g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm,
                                     Bool) :: *)
                           ~R# (Data.Data.Mp
                                  m_sg4Xt
                                  (f_sg4Xk a_sg4Xm
                                   -> g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm) :: *)))
               a1_ag3KC)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_sg4Xt>_R <g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm>_N)
                    :: (m_sg4Xt (g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm,
                                 Bool) :: *)
                       ~R# (Data.Data.Mp
                              m_sg4Xt
                              (g_sg4Xl a_sg4Xm -> Product f_sg4Xk g_sg4Xl a_sg4Xm) :: *)))
           a2_ag3KD
         })
        (\ (ds_de7oa :: (Product f_sg4Xk g_sg4Xl a_sg4Xm, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl9_sg4oY;
             True ->
               return
                 @ m_sg4Xt
                 $dMonad_sg4n6
                 @ (Product f_sg4Xk g_sg4Xl a_sg4Xm)
                 x'_ae1TD
           }
           })

-- RHS size: {terms: 20, types: 55, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> Product f g a -> m (Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ k_sg4Xj)
                 (@ (f_sg4Xk :: k_sg4Xj -> *))
                 (@ (g_sg4Xl :: k_sg4Xj -> *))
                 (@ (a_sg4Xm :: k_sg4Xj))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_sg4Xr [Occ=Once] :: Data (f_sg4Xk a_sg4Xm))
                 (w5_sg4Xs [Occ=Once] :: Data (g_sg4Xl a_sg4Xm))
                 (@ (m_sg4Xt :: * -> *))
                 (w6_sg4Xu [Occ=Once] :: MonadPlus m_sg4Xt)
                 (w7_sg4Xv [Occ=Once] :: forall d. Data d => d -> m_sg4Xt d)
                 (w8_sg4Xw [Occ=Once] :: Product f_sg4Xk g_sg4Xl a_sg4Xm) ->
                 Data.Functor.Product.$w$cgmapMp
                   @ k_sg4Xj
                   @ f_sg4Xk
                   @ g_sg4Xl
                   @ a_sg4Xm
                   w4_sg4Xr
                   w5_sg4Xs
                   @ m_sg4Xt
                   w6_sg4Xu
                   w7_sg4Xv
                   w8_sg4Xw}]
Data.Functor.Product.$fDataProduct_$cgmapMp
  = \ (@ k_sg4Xj)
      (@ (f_sg4Xk :: k_sg4Xj -> *))
      (@ (g_sg4Xl :: k_sg4Xj -> *))
      (@ (a_sg4Xm :: k_sg4Xj))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_sg4Xr :: Data (f_sg4Xk a_sg4Xm))
      (w5_sg4Xs :: Data (g_sg4Xl a_sg4Xm))
      (@ (m_sg4Xt :: * -> *))
      (w6_sg4Xu :: MonadPlus m_sg4Xt)
      (w7_sg4Xv :: forall d. Data d => d -> m_sg4Xt d)
      (w8_sg4Xw :: Product f_sg4Xk g_sg4Xl a_sg4Xm) ->
      Data.Functor.Product.$w$cgmapMp
        @ k_sg4Xj
        @ f_sg4Xk
        @ g_sg4Xl
        @ a_sg4Xm
        w4_sg4Xr
        w5_sg4Xs
        @ m_sg4Xt
        w6_sg4Xu
        w7_sg4Xv
        w8_sg4Xw

-- RHS size: {terms: 42, types: 99, coercions: 0, joins: 0/2}
Data.Functor.Product.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data (f a), Data (g a)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> f a -> g a -> m (Product f g a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60 0 0] 340 0}]
Data.Functor.Product.$w$cgmapM
  = \ (@ k_sg4XD)
      (@ (f_sg4XE :: k_sg4XD -> *))
      (@ (g_sg4XF :: k_sg4XD -> *))
      (@ (a_sg4XG :: k_sg4XD))
      (w_sg4XL :: Data (f_sg4XE a_sg4XG))
      (w1_sg4XM :: Data (g_sg4XF a_sg4XG))
      (@ (m_sg4XN :: * -> *))
      (w2_sg4XO :: Monad m_sg4XN)
      (w3_sg4XP :: forall d. Data d => d -> m_sg4XN d)
      (ww_sg4XT :: f_sg4XE a_sg4XG)
      (ww1_sg4XU :: g_sg4XF a_sg4XG) ->
      let {
        k1_sg4n2 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b. Data d => m_sg4XN (d -> b) -> d -> m_sg4XN b
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k1_sg4n2
          = \ (@ d_ae2Vh)
              (@ b_ae2Vi)
              ($dData1_ae2Vk :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_sg4XN (d_ae2Vh -> b_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl9_sg4oZ :: m_sg4XN d_ae2Vh
                [LclId]
                lvl9_sg4oZ = w3_sg4XP @ d_ae2Vh $dData1_ae2Vk x_ae1Tn } in
              >>=
                @ m_sg4XN
                w2_sg4XO
                @ (d_ae2Vh -> b_ae2Vi)
                @ b_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b_ae2Vi) ->
                   >>=
                     @ m_sg4XN
                     w2_sg4XO
                     @ d_ae2Vh
                     @ b_ae2Vi
                     lvl9_sg4oZ
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_sg4XN w2_sg4XO @ b_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k1_sg4n2
        @ (g_sg4XF a_sg4XG)
        @ (Product f_sg4XE g_sg4XF a_sg4XG)
        w1_sg4XM
        (k1_sg4n2
           @ (f_sg4XE a_sg4XG)
           @ (g_sg4XF a_sg4XG -> Product f_sg4XE g_sg4XF a_sg4XG)
           w_sg4XL
           (return
              @ m_sg4XN
              w2_sg4XO
              @ (f_sg4XE a_sg4XG
                 -> g_sg4XF a_sg4XG -> Product f_sg4XE g_sg4XF a_sg4XG)
              (Data.Functor.Product.Pair
                 @ k_sg4XD @ f_sg4XE @ g_sg4XF @ a_sg4XG))
           ww_sg4XT)
        ww1_sg4XU

-- RHS size: {terms: 24, types: 64, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d)
     -> Product f g a -> m (Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_sg4XD)
                 (@ (f_sg4XE :: k_sg4XD -> *))
                 (@ (g_sg4XF :: k_sg4XD -> *))
                 (@ (a_sg4XG :: k_sg4XD))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_sg4XL [Occ=Once] :: Data (f_sg4XE a_sg4XG))
                 (w5_sg4XM [Occ=Once] :: Data (g_sg4XF a_sg4XG))
                 (@ (m_sg4XN :: * -> *))
                 (w6_sg4XO [Occ=Once] :: Monad m_sg4XN)
                 (w7_sg4XP [Occ=Once] :: forall d. Data d => d -> m_sg4XN d)
                 (w8_sg4XQ [Occ=Once!] :: Product f_sg4XE g_sg4XF a_sg4XG) ->
                 case w8_sg4XQ of
                 { Pair ww1_sg4XT [Occ=Once] ww2_sg4XU [Occ=Once] ->
                 Data.Functor.Product.$w$cgmapM
                   @ k_sg4XD
                   @ f_sg4XE
                   @ g_sg4XF
                   @ a_sg4XG
                   w4_sg4XL
                   w5_sg4XM
                   @ m_sg4XN
                   w6_sg4XO
                   w7_sg4XP
                   ww1_sg4XT
                   ww2_sg4XU
                 }}]
Data.Functor.Product.$fDataProduct_$cgmapM
  = \ (@ k_sg4XD)
      (@ (f_sg4XE :: k_sg4XD -> *))
      (@ (g_sg4XF :: k_sg4XD -> *))
      (@ (a_sg4XG :: k_sg4XD))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_sg4XL :: Data (f_sg4XE a_sg4XG))
      (w5_sg4XM :: Data (g_sg4XF a_sg4XG))
      (@ (m_sg4XN :: * -> *))
      (w6_sg4XO :: Monad m_sg4XN)
      (w7_sg4XP :: forall d. Data d => d -> m_sg4XN d)
      (w8_sg4XQ :: Product f_sg4XE g_sg4XF a_sg4XG) ->
      case w8_sg4XQ of { Pair ww1_sg4XT ww2_sg4XU ->
      Data.Functor.Product.$w$cgmapM
        @ k_sg4XD
        @ f_sg4XE
        @ g_sg4XF
        @ a_sg4XG
        w4_sg4XL
        w5_sg4XM
        @ m_sg4XN
        w6_sg4XO
        w7_sg4XP
        ww1_sg4XT
        ww2_sg4XU
      }

-- RHS size: {terms: 32, types: 63, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct_$cgmapQi
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall u. Int -> (forall d. Data d => d -> u) -> Product f g a -> u
[GblId,
 Arity=9,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_Xg3PU)
                 (@ (f_Xg3PW :: k_Xg3PU -> *))
                 (@ (g_Xg3PY :: k_Xg3PU -> *))
                 (@ (a_Xg3Q0 :: k_Xg3PU))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData_Xg3Qa [Occ=Once] :: Data (f_Xg3PW a_Xg3Q0))
                 ($dData1_Xg3Qc [Occ=Once] :: Data (g_Xg3PY a_Xg3Q0))
                 (@ u_ag3NE)
                 (ds_dg4ar [Occ=Once!] :: Int)
                 (ds1_dg4as [Occ=Once*!] :: forall d. Data d => d -> u_ag3NE)
                 (x_ae1T7 [Occ=Once!] :: Product f_Xg3PW g_Xg3PY a_Xg3Q0) ->
                 case x_ae1T7 of { Pair a1_ag3KC [Occ=Once] a2_ag3KD [Occ=Once] ->
                 case ds_dg4ar of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ag3NE;
                   0# -> ds1_dg4as @ (f_Xg3PW a_Xg3Q0) $dData_Xg3Qa a1_ag3KC;
                   1# -> ds1_dg4as @ (g_Xg3PY a_Xg3Q0) $dData1_Xg3Qc a2_ag3KD
                 }
                 }
                 }}]
Data.Functor.Product.$fDataProduct_$cgmapQi
  = \ (@ k_Xg3PU)
      (@ (f_Xg3PW :: k_Xg3PU -> *))
      (@ (g_Xg3PY :: k_Xg3PU -> *))
      (@ (a_Xg3Q0 :: k_Xg3PU))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData_Xg3Qa :: Data (f_Xg3PW a_Xg3Q0))
      ($dData1_Xg3Qc :: Data (g_Xg3PY a_Xg3Q0))
      (@ u_ag3NE)
      (ds_dg4ar :: Int)
      (ds1_dg4as :: forall d. Data d => d -> u_ag3NE)
      (x_ae1T7 :: Product f_Xg3PW g_Xg3PY a_Xg3Q0) ->
      case x_ae1T7 of { Pair a1_ag3KC a2_ag3KD ->
      case ds_dg4ar of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ag3NE;
        0# -> ds1_dg4as @ (f_Xg3PW a_Xg3Q0) $dData_Xg3Qa a1_ag3KC;
        1# -> ds1_dg4as @ (g_Xg3PY a_Xg3Q0) $dData1_Xg3Qc a2_ag3KD
      }
      }
      }

-- RHS size: {terms: 28, types: 64, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct_$cgmapQr
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Product f g a -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=10,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_Xg3PS)
                 (@ (f_Xg3PU :: k_Xg3PS -> *))
                 (@ (g_Xg3PW :: k_Xg3PS -> *))
                 (@ (a_Xg3PY :: k_Xg3PS))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData_Xg3Q8 [Occ=Once] :: Data (f_Xg3PU a_Xg3PY))
                 ($dData1_Xg3Qa [Occ=Once] :: Data (g_Xg3PW a_Xg3PY))
                 (@ r_ag3N9)
                 (@ r'_ag3Na)
                 (ds_dg4an :: r'_ag3Na -> r_ag3N9 -> r_ag3N9)
                 (ds1_dg4ao [Occ=Once] :: r_ag3N9)
                 (ds2_dg4ap :: forall d. Data d => d -> r'_ag3Na)
                 (x0_ae1SX [Occ=Once!] :: Product f_Xg3PU g_Xg3PW a_Xg3PY) ->
                 case x0_ae1SX of { Pair a1_ag3KC [Occ=Once] a2_ag3KD [Occ=Once] ->
                 ds_dg4an
                   (ds2_dg4ap @ (f_Xg3PU a_Xg3PY) $dData_Xg3Q8 a1_ag3KC)
                   (ds_dg4an
                      (ds2_dg4ap @ (g_Xg3PW a_Xg3PY) $dData1_Xg3Qa a2_ag3KD) ds1_dg4ao)
                 }}]
Data.Functor.Product.$fDataProduct_$cgmapQr
  = \ (@ k_Xg3PS)
      (@ (f_Xg3PU :: k_Xg3PS -> *))
      (@ (g_Xg3PW :: k_Xg3PS -> *))
      (@ (a_Xg3PY :: k_Xg3PS))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData_Xg3Q8 :: Data (f_Xg3PU a_Xg3PY))
      ($dData1_Xg3Qa :: Data (g_Xg3PW a_Xg3PY))
      (@ r_ag3N9)
      (@ r'_ag3Na)
      (ds_dg4an :: r'_ag3Na -> r_ag3N9 -> r_ag3N9)
      (ds1_dg4ao :: r_ag3N9)
      (ds2_dg4ap :: forall d. Data d => d -> r'_ag3Na)
      (x0_ae1SX :: Product f_Xg3PU g_Xg3PW a_Xg3PY) ->
      case x0_ae1SX of { Pair a1_ag3KC a2_ag3KD ->
      ds_dg4an
        (ds2_dg4ap @ (f_Xg3PU a_Xg3PY) $dData_Xg3Q8 a1_ag3KC)
        (ds_dg4an
           (ds2_dg4ap @ (g_Xg3PW a_Xg3PY) $dData1_Xg3Qa a2_ag3KD) ds1_dg4ao)
      }

-- RHS size: {terms: 28, types: 64, coercions: 10, joins: 0/0}
Data.Functor.Product.$fDataProduct2
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Product f g a
     -> Const r (Product f g a)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=10,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ k_Xg3PR)
                 (@ (f_Xg3PT :: k_Xg3PR -> *))
                 (@ (g_Xg3PV :: k_Xg3PR -> *))
                 (@ (a_Xg3PX :: k_Xg3PR))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData_Xg3Q7 [Occ=Once] :: Data (f_Xg3PT a_Xg3PX))
                 ($dData1_Xg3Q9 [Occ=Once] :: Data (g_Xg3PV a_Xg3PX))
                 (@ r_ag3MS)
                 (@ r'_ag3MT)
                 (ds_dg4ak :: r_ag3MS -> r'_ag3MT -> r_ag3MS)
                 (ds1_dg4al [Occ=Once] :: r_ag3MS)
                 (ds2_dg4am :: forall d. Data d => d -> r'_ag3MT)
                 (eta_B1 [Occ=Once!] :: Product f_Xg3PT g_Xg3PV a_Xg3PX) ->
                 case eta_B1 of { Pair a1_ag3KC [Occ=Once] a2_ag3KD [Occ=Once] ->
                 (ds_dg4ak
                    (ds_dg4ak
                       ds1_dg4al (ds2_dg4am @ (f_Xg3PT a_Xg3PX) $dData_Xg3Q7 a1_ag3KC))
                    (ds2_dg4am @ (g_Xg3PV a_Xg3PX) $dData1_Xg3Q9 a2_ag3KD))
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ag3MS>_R <Product f_Xg3PT g_Xg3PV a_Xg3PX>_P)
                         :: (r_ag3MS :: *)
                            ~R# (Const r_ag3MS (Product f_Xg3PT g_Xg3PV a_Xg3PX) :: *))
                 }}]
Data.Functor.Product.$fDataProduct2
  = \ (@ k_Xg3PR)
      (@ (f_Xg3PT :: k_Xg3PR -> *))
      (@ (g_Xg3PV :: k_Xg3PR -> *))
      (@ (a_Xg3PX :: k_Xg3PR))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData_Xg3Q7 :: Data (f_Xg3PT a_Xg3PX))
      ($dData1_Xg3Q9 :: Data (g_Xg3PV a_Xg3PX))
      (@ r_ag3MS)
      (@ r'_ag3MT)
      (ds_dg4ak :: r_ag3MS -> r'_ag3MT -> r_ag3MS)
      (ds1_dg4al :: r_ag3MS)
      (ds2_dg4am :: forall d. Data d => d -> r'_ag3MT)
      (eta_B1 :: Product f_Xg3PT g_Xg3PV a_Xg3PX) ->
      case eta_B1 of { Pair a1_ag3KC a2_ag3KD ->
      (ds_dg4ak
         (ds_dg4ak
            ds1_dg4al (ds2_dg4am @ (f_Xg3PT a_Xg3PX) $dData_Xg3Q7 a1_ag3KC))
         (ds2_dg4am @ (g_Xg3PV a_Xg3PX) $dData1_Xg3Q9 a2_ag3KD))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ag3MS>_R <Product f_Xg3PT g_Xg3PV a_Xg3PX>_P)
              :: (r_ag3MS :: *)
                 ~R# (Const r_ag3MS (Product f_Xg3PT g_Xg3PV a_Xg3PX) :: *))
      }

-- RHS size: {terms: 87, types: 206, coercions: 26, joins: 0/4}
Data.Functor.Product.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data (f a), Data (g a)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> Product f g a -> m (Product f g a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 720 0}]
Data.Functor.Product.$w$cgmapMo
  = \ (@ k_sg4Y2)
      (@ (f_sg4Y3 :: k_sg4Y2 -> *))
      (@ (g_sg4Y4 :: k_sg4Y2 -> *))
      (@ (a_sg4Y5 :: k_sg4Y2))
      (w_sg4Ya :: Data (f_sg4Y3 a_sg4Y5))
      (w1_sg4Yb :: Data (g_sg4Y4 a_sg4Y5))
      (@ (m_sg4Yc :: * -> *))
      (w2_sg4Yd :: MonadPlus m_sg4Yc)
      (w3_sg4Ye :: forall d. Data d => d -> m_sg4Yc d)
      (w4_sg4Yf :: Product f_sg4Y3 g_sg4Y4 a_sg4Y5) ->
      let {
        lvl9_sg4p5 :: m_sg4Yc (Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
        [LclId]
        lvl9_sg4p5
          = mzero @ m_sg4Yc w2_sg4Yd @ (Product f_sg4Y3 g_sg4Y4 a_sg4Y5) } in
      let {
        $dMonad_sg4n0 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_sg4Yc
        [LclId]
        $dMonad_sg4n0 = GHC.Base.$p2MonadPlus @ m_sg4Yc w2_sg4Yd } in
      >>=
        @ m_sg4Yc
        $dMonad_sg4n0
        @ (Product f_sg4Y3 g_sg4Y4 a_sg4Y5, Bool)
        @ (Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
        (case w4_sg4Yf of { Pair a1_ag3KC a2_ag3KD ->
         let {
           k1_sg4mZ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Data.Data.Mp m_sg4Yc (d -> b) -> d -> m_sg4Yc (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k1_sg4mZ
             = \ (@ d_ae2Ya)
                 (@ b_ae2Yb)
                 ($dData1_ae2Yd :: Data d_ae2Ya)
                 (ds_de7pC [OS=OneShot]
                    :: Data.Data.Mp m_sg4Yc (d_ae2Ya -> b_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl10_sg4p3 :: m_sg4Yc d_ae2Ya
                   [LclId]
                   lvl10_sg4p3 = w3_sg4Ye @ d_ae2Ya $dData1_ae2Yd y_ae1TO } in
                 >>=
                   @ m_sg4Yc
                   $dMonad_sg4n0
                   @ (d_ae2Ya -> b_ae2Yb, Bool)
                   @ (b_ae2Yb, Bool)
                   (ds_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_sg4Yc>_R <d_ae2Ya -> b_ae2Yb>_N
                            :: (Data.Data.Mp m_sg4Yc (d_ae2Ya -> b_ae2Yb) :: *)
                               ~R# (m_sg4Yc (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                   (\ (ds1_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                      case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                      case b1_ae1TQ of {
                        False ->
                          mplus
                            @ m_sg4Yc
                            w2_sg4Yd
                            @ (b_ae2Yb, Bool)
                            (>>=
                               @ m_sg4Yc
                               $dMonad_sg4n0
                               @ d_ae2Ya
                               @ (b_ae2Yb, Bool)
                               lvl10_sg4p3
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_sg4Yc
                                    $dMonad_sg4n0
                                    @ (b_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_sg4Yc
                               $dMonad_sg4n0
                               @ (b_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_sg4Yc
                            $dMonad_sg4n0
                            @ (b_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k1_sg4mZ
           @ (g_sg4Y4 a_sg4Y5)
           @ (Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
           w1_sg4Yb
           ((k1_sg4mZ
               @ (f_sg4Y3 a_sg4Y5)
               @ (g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
               w_sg4Ya
               ((return
                   @ m_sg4Yc
                   $dMonad_sg4n0
                   @ (f_sg4Y3 a_sg4Y5
                      -> g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                      Bool)
                   (Data.Functor.Product.$fDataProduct1
                      @ k_sg4Y2 @ f_sg4Y3 @ g_sg4Y4 @ a_sg4Y5))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_sg4Yc>_R
                                 <f_sg4Y3 a_sg4Y5
                                  -> g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5>_N)
                        :: (m_sg4Yc (f_sg4Y3 a_sg4Y5
                                     -> g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                                     Bool) :: *)
                           ~R# (Data.Data.Mp
                                  m_sg4Yc
                                  (f_sg4Y3 a_sg4Y5
                                   -> g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5) :: *)))
               a1_ag3KC)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_sg4Yc>_R <g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5>_N)
                    :: (m_sg4Yc (g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5,
                                 Bool) :: *)
                       ~R# (Data.Data.Mp
                              m_sg4Yc
                              (g_sg4Y4 a_sg4Y5 -> Product f_sg4Y3 g_sg4Y4 a_sg4Y5) :: *)))
           a2_ag3KD
         })
        (\ (ds_de7pa :: (Product f_sg4Y3 g_sg4Y4 a_sg4Y5, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl9_sg4p5;
             True ->
               return
                 @ m_sg4Yc
                 $dMonad_sg4n0
                 @ (Product f_sg4Y3 g_sg4Y4 a_sg4Y5)
                 x'_ae1TS
           }
           })

-- RHS size: {terms: 20, types: 55, coercions: 0, joins: 0/0}
Data.Functor.Product.$fDataProduct_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> Product f g a -> m (Product f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ k_sg4Y2)
                 (@ (f_sg4Y3 :: k_sg4Y2 -> *))
                 (@ (g_sg4Y4 :: k_sg4Y2 -> *))
                 (@ (a_sg4Y5 :: k_sg4Y2))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_sg4Ya [Occ=Once] :: Data (f_sg4Y3 a_sg4Y5))
                 (w5_sg4Yb [Occ=Once] :: Data (g_sg4Y4 a_sg4Y5))
                 (@ (m_sg4Yc :: * -> *))
                 (w6_sg4Yd [Occ=Once] :: MonadPlus m_sg4Yc)
                 (w7_sg4Ye [Occ=Once] :: forall d. Data d => d -> m_sg4Yc d)
                 (w8_sg4Yf [Occ=Once] :: Product f_sg4Y3 g_sg4Y4 a_sg4Y5) ->
                 Data.Functor.Product.$w$cgmapMo
                   @ k_sg4Y2
                   @ f_sg4Y3
                   @ g_sg4Y4
                   @ a_sg4Y5
                   w4_sg4Ya
                   w5_sg4Yb
                   @ m_sg4Yc
                   w6_sg4Yd
                   w7_sg4Ye
                   w8_sg4Yf}]
Data.Functor.Product.$fDataProduct_$cgmapMo
  = \ (@ k_sg4Y2)
      (@ (f_sg4Y3 :: k_sg4Y2 -> *))
      (@ (g_sg4Y4 :: k_sg4Y2 -> *))
      (@ (a_sg4Y5 :: k_sg4Y2))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_sg4Ya :: Data (f_sg4Y3 a_sg4Y5))
      (w5_sg4Yb :: Data (g_sg4Y4 a_sg4Y5))
      (@ (m_sg4Yc :: * -> *))
      (w6_sg4Yd :: MonadPlus m_sg4Yc)
      (w7_sg4Ye :: forall d. Data d => d -> m_sg4Yc d)
      (w8_sg4Yf :: Product f_sg4Y3 g_sg4Y4 a_sg4Y5) ->
      Data.Functor.Product.$w$cgmapMo
        @ k_sg4Y2
        @ f_sg4Y3
        @ g_sg4Y4
        @ a_sg4Y5
        w4_sg4Ya
        w5_sg4Yb
        @ m_sg4Yc
        w6_sg4Yd
        w7_sg4Ye
        w8_sg4Yf

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
lvl5_rg5oj
  :: forall k (g :: k -> *) (a :: k) (f :: k -> *).
     Product f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl5_rg5oj
  = \ (@ k_Xg3PN)
      (@ (g_Xg3V4 :: k_Xg3PN -> *))
      (@ (a_Xg3V7 :: k_Xg3PN))
      (@ (f_Xg3PP :: k_Xg3PN -> *))
      (ds_dg4ad :: Product f_Xg3PP g_Xg3V4 a_Xg3V7) ->
      case ds_dg4ad of { Pair ds1_dg4ae ds2_dg4af ->
      Data.Functor.Product.$cPair
      }

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
lvl6_rg5ok
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     Product f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl6_rg5ok
  = \ (@ k_Xg3PN)
      (@ (f_Xg3PP :: k_Xg3PN -> *))
      (@ (g_Xg3V4 :: k_Xg3PN -> *))
      (@ (a_Xg3V7 :: k_Xg3PN))
      _ [Occ=Dead] ->
      Data.Functor.Product.$tProduct

-- RHS size: {terms: 9, types: 36, coercions: 0, joins: 0/0}
lvl7_rg5ol
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl7_rg5ol
  = \ (@ k_Xg3PN)
      (@ (f_Xg3PP :: k_Xg3PN -> *))
      (@ (g_Xg3V4 :: k_Xg3PN -> *))
      (@ (a_Xg3V7 :: k_Xg3PN))
      (@ (t_ag3M1 :: * -> *))
      (@ (c_ag3M2 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ag3M2 (Product f_Xg3PP g_Xg3V4 a_Xg3V7))

-- RHS size: {terms: 9, types: 45, coercions: 0, joins: 0/0}
lvl8_rg5om
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k) (t :: *
                                                         -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Product f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl8_rg5om
  = \ (@ k_Xg3PN)
      (@ (f_Xg3PP :: k_Xg3PN -> *))
      (@ (g_Xg3V4 :: k_Xg3PN -> *))
      (@ (a_Xg3V7 :: k_Xg3PN))
      (@ (t_ag3Mk :: * -> * -> *))
      (@ (c_ag3Ml :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ag3Ml (Product f_Xg3PP g_Xg3V4 a_Xg3V7))

-- RHS size: {terms: 112, types: 230, coercions: 69, joins: 0/0}
Data.Functor.Product.$fDataProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (g :: k -> *) (a :: k).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k, Data (f a), Data (g a)) =>
     Data (Product f g a)
[GblId[DFunId],
 Arity=6,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=DFun: \ (@ k_ag3FE)
             (@ (f_ag3DT :: k_ag3FE -> *))
             (@ (g_ag3DU :: k_ag3FE -> *))
             (@ (a_ag3DV :: k_ag3FE))
             (v_X5g :: Data.Typeable.Internal.Typeable a_ag3DV)
             (v1_B2 :: Data.Typeable.Internal.Typeable f_ag3DT)
             (v2_B3 :: Data.Typeable.Internal.Typeable g_ag3DU)
             (v3_B4 :: Data.Typeable.Internal.Typeable k_ag3FE)
             (v4_B5 :: Data (f_ag3DT a_ag3DV))
             (v5_B6 :: Data (g_ag3DU a_ag3DV)) ->
       Data.Data.C:Data TYPE: Product f_ag3DT g_ag3DU a_ag3DV
                        (Data.Functor.Product.$fDataProduct7
                           @ k_ag3FE
                           @ f_ag3DT
                           @ g_ag3DU
                           @ a_ag3DV
                           v_X5g
                           v1_B2
                           v2_B3
                           v3_B4
                           v4_B5
                           v5_B6)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Product
                                                                                    f_ag3DT
                                                                                    g_ag3DU
                                                                                    a_ag3DV>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (Product f_ag3DT g_ag3DU a_ag3DV) :: *)
                                   ~R# (Data.Typeable.Internal.Typeable
                                          (Product f_ag3DT g_ag3DU a_ag3DV) :: Constraint))
                        Data.Functor.Product.$fDataProduct_$cgfoldl
                          @ k_ag3FE
                          @ f_ag3DT
                          @ g_ag3DU
                          @ a_ag3DV
                          v_X5g
                          v1_B2
                          v2_B3
                          v3_B4
                          v4_B5
                          v5_B6
                        \ (@ (c_ag3LC :: * -> *))
                          (k1_ag3KE :: forall b r. Data b => c_ag3LC (b -> r) -> c_ag3LC r)
                          (z_ag3KF [Occ=Once!] :: forall r. r -> c_ag3LC r)
                          _ [Occ=Dead] ->
                          k1_ag3KE
                            @ (g_ag3DU a_ag3DV)
                            @ (Product f_ag3DT g_ag3DU a_ag3DV)
                            v5_B6
                            (k1_ag3KE
                               @ (f_ag3DT a_ag3DV)
                               @ (g_ag3DU a_ag3DV -> Product f_ag3DT g_ag3DU a_ag3DV)
                               v4_B5
                               (z_ag3KF
                                  @ (f_ag3DT a_ag3DV
                                     -> g_ag3DU a_ag3DV -> Product f_ag3DT g_ag3DU a_ag3DV)
                                  (Data.Functor.Product.Pair
                                     @ k_ag3FE @ f_ag3DT @ g_ag3DU @ a_ag3DV)))
                        \ (ds_dg4ad [Occ=Once!] :: Product f_ag3DT g_ag3DU a_ag3DV) ->
                          case ds_dg4ad of { Pair _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Functor.Product.$cPair
                          }
                        \ _ [Occ=Dead] -> Data.Functor.Product.$tProduct
                        \ (@ (t_ag3M1 :: * -> *))
                          (@ (c_ag3M2 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ag3M2 (Product f_ag3DT g_ag3DU a_ag3DV))
                        \ (@ (t_ag3Mk :: * -> * -> *))
                          (@ (c_ag3Ml :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ag3Ml (Product f_ag3DT g_ag3DU a_ag3DV))
                        (\ (ds_dg4aj :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once!] :: Product f_ag3DT g_ag3DU a_ag3DV) ->
                           case x0_Xe2jm of { Pair a1_ag3KC [Occ=Once] a2_ag3KD [Occ=Once] ->
                           (Data.Functor.Product.Pair
                              @ k_ag3FE
                              @ f_ag3DT
                              @ g_ag3DU
                              @ a_ag3DV
                              (ds_dg4aj @ (f_ag3DT a_ag3DV) v4_B5 a1_ag3KC)
                              (ds_dg4aj @ (g_ag3DU a_ag3DV) v5_B6 a2_ag3KD))
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                            <Product f_ag3DT g_ag3DU a_ag3DV>_R)
                                   :: (Product f_ag3DT g_ag3DU a_ag3DV :: *)
                                      ~R# (Data.Functor.Identity.Identity
                                             (Product f_ag3DT g_ag3DU a_ag3DV) :: *))
                           })
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Product f_ag3DT g_ag3DU a_ag3DV>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <Product f_ag3DT g_ag3DU a_ag3DV>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Product f_ag3DT g_ag3DU a_ag3DV
                                    -> Data.Functor.Identity.Identity
                                         (Product f_ag3DT g_ag3DU a_ag3DV) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Product f_ag3DT g_ag3DU a_ag3DV
                                        -> Product f_ag3DT g_ag3DU a_ag3DV :: *))
                        (Data.Functor.Product.$fDataProduct2
                           @ k_ag3FE
                           @ f_ag3DT
                           @ g_ag3DU
                           @ a_ag3DV
                           v_X5g
                           v1_B2
                           v2_B3
                           v3_B4
                           v4_B5
                           v5_B6)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Product f_ag3DT g_ag3DU a_ag3DV>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <Product f_ag3DT g_ag3DU a_ag3DV>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Product f_ag3DT g_ag3DU a_ag3DV
                                    -> Const r (Product f_ag3DT g_ag3DU a_ag3DV) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Product f_ag3DT g_ag3DU a_ag3DV
                                        -> r :: *))
                        Data.Functor.Product.$fDataProduct_$cgmapQr
                          @ k_ag3FE
                          @ f_ag3DT
                          @ g_ag3DU
                          @ a_ag3DV
                          v_X5g
                          v1_B2
                          v2_B3
                          v3_B4
                          v4_B5
                          v5_B6
                        \ (@ u_ag3Nq)
                          (ds_dg4aq :: forall d. Data d => d -> u_ag3Nq)
                          (x0_ae1SX [Occ=Once!] :: Product f_ag3DT g_ag3DU a_ag3DV) ->
                          case x0_ae1SX of { Pair a1_ag3KC [Occ=Once] a2_ag3KD [Occ=Once] ->
                          GHC.Types.:
                            @ u_ag3Nq
                            (ds_dg4aq @ (f_ag3DT a_ag3DV) v4_B5 a1_ag3KC)
                            (GHC.Types.:
                               @ u_ag3Nq
                               (ds_dg4aq @ (g_ag3DU a_ag3DV) v5_B6 a2_ag3KD)
                               (GHC.Types.[] @ u_ag3Nq))
                          }
                        Data.Functor.Product.$fDataProduct_$cgmapQi
                          @ k_ag3FE
                          @ f_ag3DT
                          @ g_ag3DU
                          @ a_ag3DV
                          v_X5g
                          v1_B2
                          v2_B3
                          v3_B4
                          v4_B5
                          v5_B6
                        Data.Functor.Product.$fDataProduct_$cgmapM
                          @ k_ag3FE
                          @ f_ag3DT
                          @ g_ag3DU
                          @ a_ag3DV
                          v_X5g
                          v1_B2
                          v2_B3
                          v3_B4
                          v4_B5
                          v5_B6
                        Data.Functor.Product.$fDataProduct_$cgmapMp
                          @ k_ag3FE
                          @ f_ag3DT
                          @ g_ag3DU
                          @ a_ag3DV
                          v_X5g
                          v1_B2
                          v2_B3
                          v3_B4
                          v4_B5
                          v5_B6
                        Data.Functor.Product.$fDataProduct_$cgmapMo
                          @ k_ag3FE
                          @ f_ag3DT
                          @ g_ag3DU
                          @ a_ag3DV
                          v_X5g
                          v1_B2
                          v2_B3
                          v3_B4
                          v4_B5
                          v5_B6]
Data.Functor.Product.$fDataProduct
  = \ (@ k_Xg3PN)
      (@ (f_Xg3PP :: k_Xg3PN -> *))
      (@ (g_Xg3V4 :: k_Xg3PN -> *))
      (@ (a_Xg3V7 :: k_Xg3PN))
      ($dTypeable_Xg3Va :: Data.Typeable.Internal.Typeable a_Xg3V7)
      ($dTypeable1_Xg3Vd :: Data.Typeable.Internal.Typeable f_Xg3PP)
      ($dTypeable2_Xg3Vg :: Data.Typeable.Internal.Typeable g_Xg3V4)
      ($dTypeable3_Xg3Vj :: Data.Typeable.Internal.Typeable k_Xg3PN)
      ($dData_Xg3Vm :: Data (f_Xg3PP a_Xg3V7))
      ($dData1_Xg3Vp :: Data (g_Xg3V4 a_Xg3V7)) ->
      Data.Data.C:Data
        @ (Product f_Xg3PP g_Xg3V4 a_Xg3V7)
        ((Data.Functor.Product.$w$cp1Data
            @ k_Xg3PN
            @ f_Xg3PP
            @ g_Xg3V4
            @ a_Xg3V7
            $dTypeable_Xg3Va
            $dTypeable1_Xg3Vd
            $dTypeable2_Xg3Vg
            $dTypeable3_Xg3Vj)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Product
                                                                     f_Xg3PP g_Xg3V4 a_Xg3V7>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (Product f_Xg3PP g_Xg3V4 a_Xg3V7) :: *)
                    ~R# (Data.Typeable.Internal.Typeable
                           (Product f_Xg3PP g_Xg3V4 a_Xg3V7) :: Constraint)))
        (Data.Functor.Product.$fDataProduct_$cgfoldl
           @ k_Xg3PN
           @ f_Xg3PP
           @ g_Xg3V4
           @ a_Xg3V7
           $dTypeable_Xg3Va
           $dTypeable1_Xg3Vd
           $dTypeable2_Xg3Vg
           $dTypeable3_Xg3Vj
           $dData_Xg3Vm
           $dData1_Xg3Vp)
        (\ (@ (c_ag3LC :: * -> *))
           (k1_ag3KE :: forall b r. Data b => c_ag3LC (b -> r) -> c_ag3LC r)
           (z_ag3KF :: forall r. r -> c_ag3LC r)
           _ [Occ=Dead] ->
           k1_ag3KE
             @ (g_Xg3V4 a_Xg3V7)
             @ (Product f_Xg3PP g_Xg3V4 a_Xg3V7)
             $dData1_Xg3Vp
             (k1_ag3KE
                @ (f_Xg3PP a_Xg3V7)
                @ (g_Xg3V4 a_Xg3V7 -> Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                $dData_Xg3Vm
                (z_ag3KF
                   @ (f_Xg3PP a_Xg3V7
                      -> g_Xg3V4 a_Xg3V7 -> Product f_Xg3PP g_Xg3V4 a_Xg3V7)
                   (Data.Functor.Product.Pair
                      @ k_Xg3PN @ f_Xg3PP @ g_Xg3V4 @ a_Xg3V7))))
        (lvl5_rg5oj @ k_Xg3PN @ g_Xg3V4 @ a_Xg3V7 @ f_Xg3PP)
        (lvl6_rg5ok @ k_Xg3PN @ f_Xg3PP @ g_Xg3V4 @ a_Xg3V7)
        (lvl7_rg5ol @ k_Xg3PN @ f_Xg3PP @ g_Xg3V4 @ a_Xg3V7)
        (lvl8_rg5om @ k_Xg3PN @ f_Xg3PP @ g_Xg3V4 @ a_Xg3V7)
        ((\ (ds_dg4aj :: forall b. Data b => b -> b)
            (x0_Xe2jm :: Product f_Xg3PP g_Xg3V4 a_Xg3V7) ->
            case x0_Xe2jm of { Pair a1_ag3KC a2_ag3KD ->
            (Data.Functor.Product.Pair
               @ k_Xg3PN
               @ f_Xg3PP
               @ g_Xg3V4
               @ a_Xg3V7
               (ds_dg4aj @ (f_Xg3PP a_Xg3V7) $dData_Xg3Vm a1_ag3KC)
               (ds_dg4aj @ (g_Xg3V4 a_Xg3V7) $dData1_Xg3Vp a2_ag3KD))
            `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                             <Product f_Xg3PP g_Xg3V4 a_Xg3V7>_R)
                    :: (Product f_Xg3PP g_Xg3V4 a_Xg3V7 :: *)
                       ~R# (Data.Functor.Identity.Identity
                              (Product f_Xg3PP g_Xg3V4 a_Xg3V7) :: *))
            })
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Product f_Xg3PP g_Xg3V4 a_Xg3V7>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <Product f_Xg3PP g_Xg3V4 a_Xg3V7>_R
                 :: ((forall b. Data b => b -> b)
                     -> Product f_Xg3PP g_Xg3V4 a_Xg3V7
                     -> Data.Functor.Identity.Identity
                          (Product f_Xg3PP g_Xg3V4 a_Xg3V7) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Product f_Xg3PP g_Xg3V4 a_Xg3V7
                         -> Product f_Xg3PP g_Xg3V4 a_Xg3V7 :: *)))
        ((Data.Functor.Product.$fDataProduct2
            @ k_Xg3PN
            @ f_Xg3PP
            @ g_Xg3V4
            @ a_Xg3V7
            $dTypeable_Xg3Va
            $dTypeable1_Xg3Vd
            $dTypeable2_Xg3Vg
            $dTypeable3_Xg3Vj
            $dData_Xg3Vm
            $dData1_Xg3Vp)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Product f_Xg3PP g_Xg3V4 a_Xg3V7>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <Product f_Xg3PP g_Xg3V4 a_Xg3V7>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Product f_Xg3PP g_Xg3V4 a_Xg3V7
                     -> Const r (Product f_Xg3PP g_Xg3V4 a_Xg3V7) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> Product f_Xg3PP g_Xg3V4 a_Xg3V7
                         -> r :: *)))
        (Data.Functor.Product.$fDataProduct_$cgmapQr
           @ k_Xg3PN
           @ f_Xg3PP
           @ g_Xg3V4
           @ a_Xg3V7
           $dTypeable_Xg3Va
           $dTypeable1_Xg3Vd
           $dTypeable2_Xg3Vg
           $dTypeable3_Xg3Vj
           $dData_Xg3Vm
           $dData1_Xg3Vp)
        (\ (@ u_ag3Nq)
           (ds_dg4aq :: forall d. Data d => d -> u_ag3Nq)
           (x0_ae1SX :: Product f_Xg3PP g_Xg3V4 a_Xg3V7) ->
           case x0_ae1SX of { Pair a1_ag3KC a2_ag3KD ->
           GHC.Types.:
             @ u_ag3Nq
             (ds_dg4aq @ (f_Xg3PP a_Xg3V7) $dData_Xg3Vm a1_ag3KC)
             (GHC.Types.:
                @ u_ag3Nq
                (ds_dg4aq @ (g_Xg3V4 a_Xg3V7) $dData1_Xg3Vp a2_ag3KD)
                (GHC.Types.[] @ u_ag3Nq))
           })
        (Data.Functor.Product.$fDataProduct_$cgmapQi
           @ k_Xg3PN
           @ f_Xg3PP
           @ g_Xg3V4
           @ a_Xg3V7
           $dTypeable_Xg3Va
           $dTypeable1_Xg3Vd
           $dTypeable2_Xg3Vg
           $dTypeable3_Xg3Vj
           $dData_Xg3Vm
           $dData1_Xg3Vp)
        (Data.Functor.Product.$fDataProduct_$cgmapM
           @ k_Xg3PN
           @ f_Xg3PP
           @ g_Xg3V4
           @ a_Xg3V7
           $dTypeable_Xg3Va
           $dTypeable1_Xg3Vd
           $dTypeable2_Xg3Vg
           $dTypeable3_Xg3Vj
           $dData_Xg3Vm
           $dData1_Xg3Vp)
        (\ (@ (m_sg4Xt :: * -> *))
           (w_sg4Xu :: MonadPlus m_sg4Xt)
           (w1_sg4Xv :: forall d. Data d => d -> m_sg4Xt d)
           (w2_sg4Xw :: Product f_Xg3PP g_Xg3V4 a_Xg3V7) ->
           Data.Functor.Product.$w$cgmapMp
             @ k_Xg3PN
             @ f_Xg3PP
             @ g_Xg3V4
             @ a_Xg3V7
             $dData_Xg3Vm
             $dData1_Xg3Vp
             @ m_sg4Xt
             w_sg4Xu
             w1_sg4Xv
             w2_sg4Xw)
        (\ (@ (m_sg4Yc :: * -> *))
           (w_sg4Yd :: MonadPlus m_sg4Yc)
           (w1_sg4Ye :: forall d. Data d => d -> m_sg4Yc d)
           (w2_sg4Yf :: Product f_Xg3PP g_Xg3V4 a_Xg3V7) ->
           Data.Functor.Product.$w$cgmapMo
             @ k_Xg3PN
             @ f_Xg3PP
             @ g_Xg3V4
             @ a_Xg3V7
             $dData_Xg3Vm
             $dData1_Xg3Vp
             @ m_sg4Yc
             w_sg4Yd
             w1_sg4Ye
             w2_sg4Yf)


