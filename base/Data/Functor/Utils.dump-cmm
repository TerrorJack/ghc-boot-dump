
==================== Output Cmm ====================
2018-03-16 15:56:20.028190496 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:20.029627426 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMax_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMax_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMax_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ytc,
                       label: Data.Functor.Utils.$fMonoidMax_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ytc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1ytd; else goto c1yte;
       c1ytd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yte: // global
           I64[Sp - 24] = block_c1yt5_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ytN; else goto c1yt6;
       u1ytN: // global
           call _c1yt5(R1) args: 0, res: 0, upd: 0;
       c1yt6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yt5() //  [R1]
         { info_tbl: [(c1yt5,
                       label: block_c1yt5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yt5: // global
           _s1yob::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yt9; else goto c1yta;
       c1yt9: // global
           R1 = _s1yob::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yta: // global
           I64[Sp - 8] = block_c1ytk_info;
           _s1yod::P64 = R1;
           _s1yoe::P64 = P64[R1 + 6];
           R1 = _s1yob::P64;
           P64[Sp] = _s1yoe::P64;
           P64[Sp + 16] = _s1yod::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ytM; else goto c1ytm;
       u1ytM: // global
           call _c1ytk(R1) args: 0, res: 0, upd: 0;
       c1ytm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ytk() //  [R1]
         { info_tbl: [(c1ytk,
                       label: block_c1ytk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ytk: // global
           if (R1 & 7 == 1) goto u1ytK; else goto c1ytx;
       u1ytK: // global
           Sp = Sp + 24;
           call _c1ytD() args: 0, res: 0, upd: 0;
       c1ytx: // global
           _s1yoe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ytv_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yoe::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ytv() //  [R1]
         { info_tbl: [(c1ytv,
                       label: block_c1ytv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ytv: // global
           if (R1 & 7 == 1) goto u1ytL; else goto c1ytH;
       u1ytL: // global
           Sp = Sp + 16;
           call _c1ytD() args: 0, res: 0, upd: 0;
       c1ytH: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1ytD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ytD: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.032259221 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat_closure" {
     Data.Functor.Utils.$w$csconcat_closure:
         const Data.Functor.Utils.$w$csconcat_info;
 },
 go_s1yol_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yu6,
                       label: go_s1yol_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yu6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yu7; else goto c1yu8;
       c1yu7: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yu8: // global
           I64[Sp - 32] = block_c1ytZ_info;
           _s1yol::P64 = R1;
           _s1yoi::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1yoi::P64;
           P64[Sp - 16] = _s1yol::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yuV; else goto c1yu0;
       u1yuV: // global
           call _c1ytZ(R1) args: 0, res: 0, upd: 0;
       c1yu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ytZ() //  [R1]
         { info_tbl: [(c1ytZ,
                       label: block_c1ytZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ytZ: // global
           if (R1 & 7 == 1) goto u1yuQ; else goto c1yu4;
       u1yuQ: // global
           Sp = Sp + 24;
           call _c1yul() args: 0, res: 0, upd: 0;
       c1yu4: // global
           I64[Sp] = block_c1yue_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1yol_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yue() //  [R1]
         { info_tbl: [(c1yue,
                       label: block_c1yue_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yue: // global
           if (R1 & 7 == 1) goto u1yuR; else goto c1yuq;
       u1yuR: // global
           Sp = Sp + 24;
           call _c1yul() args: 0, res: 0, upd: 0;
       c1yuq: // global
           I64[Sp] = block_c1yuo_info;
           _s1yor::P64 = R1;
           _s1yos::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1yos::P64;
           P64[Sp + 24] = _s1yor::P64;
           if (R1 & 7 != 0) goto u1yuW; else goto c1yur;
       u1yuW: // global
           call _c1yuo(R1) args: 0, res: 0, upd: 0;
       c1yur: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yul() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yul: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yuo() //  [R1]
         { info_tbl: [(c1yuo,
                       label: block_c1yuo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yuo: // global
           if (R1 & 7 == 1) goto u1yuS; else goto c1yuC;
       u1yuS: // global
           Sp = Sp + 24;
           call _c1yuI() args: 0, res: 0, upd: 0;
       c1yuC: // global
           _s1yoi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yuA_info;
           R2 = _s1yoi::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yuA() //  [R1]
         { info_tbl: [(c1yuA,
                       label: block_c1yuA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yuA: // global
           if (R1 & 7 == 1) goto u1yuT; else goto c1yuM;
       u1yuT: // global
           Sp = Sp + 16;
           call _c1yuI() args: 0, res: 0, upd: 0;
       c1yuM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yuI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yuI: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yv0,
                       label: Data.Functor.Utils.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yv0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yv4; else goto c1yv3;
       c1yv4: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yv3: // global
           I64[Hp - 8] = go_s1yol_info;
           P64[Hp] = R2;
           _s1yoj::P64 = R3;
           R3 = R4;
           R2 = _s1yoj::P64;
           R1 = Hp - 6;
           call go_s1yol_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.034769657 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMax_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMax_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMax_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yvc,
                       label: Data.Functor.Utils.$fSemigroupMax_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yvc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yvd; else goto c1yve;
       c1yvd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yve: // global
           I64[Sp - 16] = block_c1yv9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1yvi; else goto c1yva;
       u1yvi: // global
           call _c1yv9(R1) args: 0, res: 0, upd: 0;
       c1yva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yv9() //  [R1]
         { info_tbl: [(c1yv9,
                       label: block_c1yv9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yv9: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.036559306 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_closure" {
     Data.Functor.Utils.$fSemigroupMax_closure:
         const Data.Functor.Utils.$fSemigroupMax_info;
         const 0;
 },
 sat_s1yoE_entry() //  [R1, R2]
         { info_tbl: [(c1yvs,
                       label: sat_s1yoE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yvs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoD_entry() //  [R1, R2]
         { info_tbl: [(c1yvA,
                       label: sat_s1yoD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yvA: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoC_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yvI,
                       label: sat_s1yoC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yvI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_entry() //  [R2]
         { info_tbl: [(c1yvM,
                       label: Data.Functor.Utils.$fSemigroupMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yvM: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1yvQ; else goto c1yvP;
       c1yvQ: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yvP: // global
           I64[Hp - 72] = sat_s1yoE_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1yoD_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1yoC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMax_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMax_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_info;
         const 0;
 },
 sat_s1yoH_entry() //  [R1]
         { info_tbl: [(c1yvZ,
                       label: sat_s1yoH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yvZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yw0; else goto c1yw1;
       c1yw0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yw1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1yw2,
                       label: Data.Functor.Utils.$fSemigroupMax_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yw2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yw6; else goto c1yw5;
       c1yw6: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yw5: // global
           I64[Hp - 16] = sat_s1yoH_info;
           P64[Hp] = R2;
           _s1yoG::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1yoG::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.039363379 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMax_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMax_$cmconcat_info;
 },
 go_s1yoK_entry() //  [R1, R2]
         { info_tbl: [(c1ywo,
                       label: go_s1yoK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ywo: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1ywp; else goto c1ywq;
       c1ywp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1ywq: // global
           I64[Sp - 24] = block_c1ywh_info;
           _s1yoK::P64 = R1;
           _s1yoI::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1yoI::P64;
           P64[Sp - 8] = _s1yoK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1yxa; else goto c1ywi;
       u1yxa: // global
           call _c1ywh(R1) args: 0, res: 0, upd: 0;
       c1ywi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ywh() //  [R1]
         { info_tbl: [(c1ywh,
                       label: block_c1ywh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ywh: // global
           if (R1 & 7 == 1) goto c1ywl; else goto c1ywm;
       c1ywl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ywm: // global
           I64[Sp] = block_c1yww_info;
           R2 = P64[R1 + 14];
           _s1yoN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1yoN::P64;
           call go_s1yoK_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yww() //  [R1]
         { info_tbl: [(c1yww,
                       label: block_c1yww_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yww: // global
           _s1yoN::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1ywD; else goto c1ywI;
       c1ywD: // global
           R1 = _s1yoN::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1ywI: // global
           I64[Sp - 8] = block_c1ywG_info;
           _s1yoP::P64 = R1;
           _s1yoQ::P64 = P64[R1 + 6];
           R1 = _s1yoN::P64;
           P64[Sp] = _s1yoQ::P64;
           P64[Sp + 16] = _s1yoP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1yxb; else goto c1ywJ;
       u1yxb: // global
           call _c1ywG(R1) args: 0, res: 0, upd: 0;
       c1ywJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ywG() //  [R1]
         { info_tbl: [(c1ywG,
                       label: block_c1ywG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ywG: // global
           if (R1 & 7 == 1) goto u1yx8; else goto c1ywU;
       u1yx8: // global
           Sp = Sp + 24;
           call _c1yx0() args: 0, res: 0, upd: 0;
       c1ywU: // global
           _s1yoQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ywS_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yoQ::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ywS() //  [R1]
         { info_tbl: [(c1ywS,
                       label: block_c1ywS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ywS: // global
           if (R1 & 7 == 1) goto u1yx9; else goto c1yx4;
       u1yx9: // global
           Sp = Sp + 16;
           call _c1yx0() args: 0, res: 0, upd: 0;
       c1yx4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yx0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yx0: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMax_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yxe,
                       label: Data.Functor.Utils.$fMonoidMax_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yxe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yxi; else goto c1yxh;
       c1yxi: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yxh: // global
           I64[Hp - 8] = go_s1yoK_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1yoK_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.042123557 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_closure" {
     Data.Functor.Utils.$fMonoidMax_closure:
         const Data.Functor.Utils.$fMonoidMax_info;
         const 0;
 },
 sat_s1yoX_entry() //  [R1, R2]
         { info_tbl: [(c1yxs,
                       label: sat_s1yoX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yxs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMax_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoW_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yxA,
                       label: sat_s1yoW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yxA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoV_entry() //  [R1]
         { info_tbl: [(c1yxH,
                       label: sat_s1yoV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yxI; else goto c1yxJ;
       c1yxI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yxJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMax_entry() //  [R2]
         { info_tbl: [(c1yxL,
                       label: Data.Functor.Utils.$fMonoidMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yxL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1yxP; else goto c1yxO;
       c1yxP: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yxO: // global
           I64[Hp - 88] = sat_s1yoX_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1yoW_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1yoV_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.044159208 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMin_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMin_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMin_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yy1,
                       label: Data.Functor.Utils.$fMonoidMin_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yy1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yy2; else goto c1yy3;
       c1yy2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yy3: // global
           I64[Sp - 24] = block_c1yxU_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1yyC; else goto c1yxV;
       u1yyC: // global
           call _c1yxU(R1) args: 0, res: 0, upd: 0;
       c1yxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yxU() //  [R1]
         { info_tbl: [(c1yxU,
                       label: block_c1yxU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yxU: // global
           _s1yoZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yxY; else goto c1yxZ;
       c1yxY: // global
           R1 = _s1yoZ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yxZ: // global
           I64[Sp - 8] = block_c1yy9_info;
           _s1yp1::P64 = R1;
           _s1yp2::P64 = P64[R1 + 6];
           R1 = _s1yoZ::P64;
           P64[Sp] = _s1yp2::P64;
           P64[Sp + 16] = _s1yp1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1yyB; else goto c1yyb;
       u1yyB: // global
           call _c1yy9(R1) args: 0, res: 0, upd: 0;
       c1yyb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yy9() //  [R1]
         { info_tbl: [(c1yy9,
                       label: block_c1yy9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yy9: // global
           if (R1 & 7 == 1) goto u1yyz; else goto c1yym;
       u1yyz: // global
           Sp = Sp + 24;
           call _c1yys() args: 0, res: 0, upd: 0;
       c1yym: // global
           _s1yp2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yyk_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yp2::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yyk() //  [R1]
         { info_tbl: [(c1yyk,
                       label: block_c1yyk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yyk: // global
           if (R1 & 7 == 1) goto u1yyA; else goto c1yyw;
       u1yyA: // global
           Sp = Sp + 16;
           call _c1yys() args: 0, res: 0, upd: 0;
       c1yyw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yys() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yys: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.046815934 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat1_closure" {
     Data.Functor.Utils.$w$csconcat1_closure:
         const Data.Functor.Utils.$w$csconcat1_info;
 },
 go_s1yp9_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yyV,
                       label: go_s1yp9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yyV: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yyW; else goto c1yyX;
       c1yyW: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yyX: // global
           I64[Sp - 32] = block_c1yyO_info;
           _s1yp9::P64 = R1;
           _s1yp6::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1yp6::P64;
           P64[Sp - 16] = _s1yp9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yzK; else goto c1yyP;
       u1yzK: // global
           call _c1yyO(R1) args: 0, res: 0, upd: 0;
       c1yyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yyO() //  [R1]
         { info_tbl: [(c1yyO,
                       label: block_c1yyO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yyO: // global
           if (R1 & 7 == 1) goto u1yzF; else goto c1yyT;
       u1yzF: // global
           Sp = Sp + 24;
           call _c1yza() args: 0, res: 0, upd: 0;
       c1yyT: // global
           I64[Sp] = block_c1yz3_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1yp9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yz3() //  [R1]
         { info_tbl: [(c1yz3,
                       label: block_c1yz3_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yz3: // global
           if (R1 & 7 == 1) goto u1yzG; else goto c1yzf;
       u1yzG: // global
           Sp = Sp + 24;
           call _c1yza() args: 0, res: 0, upd: 0;
       c1yzf: // global
           I64[Sp] = block_c1yzd_info;
           _s1ypf::P64 = R1;
           _s1ypg::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1ypg::P64;
           P64[Sp + 24] = _s1ypf::P64;
           if (R1 & 7 != 0) goto u1yzL; else goto c1yzg;
       u1yzL: // global
           call _c1yzd(R1) args: 0, res: 0, upd: 0;
       c1yzg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yza() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yza: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yzd() //  [R1]
         { info_tbl: [(c1yzd,
                       label: block_c1yzd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yzd: // global
           if (R1 & 7 == 1) goto u1yzH; else goto c1yzr;
       u1yzH: // global
           Sp = Sp + 24;
           call _c1yzx() args: 0, res: 0, upd: 0;
       c1yzr: // global
           _s1yp6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yzp_info;
           R2 = _s1yp6::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yzp() //  [R1]
         { info_tbl: [(c1yzp,
                       label: block_c1yzp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yzp: // global
           if (R1 & 7 == 1) goto u1yzI; else goto c1yzB;
       u1yzI: // global
           Sp = Sp + 16;
           call _c1yzx() args: 0, res: 0, upd: 0;
       c1yzB: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yzx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yzx: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yzP,
                       label: Data.Functor.Utils.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yzP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yzT; else goto c1yzS;
       c1yzT: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yzS: // global
           I64[Hp - 8] = go_s1yp9_info;
           P64[Hp] = R2;
           _s1yp7::P64 = R3;
           R3 = R4;
           R2 = _s1yp7::P64;
           R1 = Hp - 6;
           call go_s1yp9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.049355364 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMin_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMin_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMin_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yA1,
                       label: Data.Functor.Utils.$fSemigroupMin_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yA1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yA2; else goto c1yA3;
       c1yA2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yA3: // global
           I64[Sp - 16] = block_c1yzY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1yA7; else goto c1yzZ;
       u1yA7: // global
           call _c1yzY(R1) args: 0, res: 0, upd: 0;
       c1yzZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yzY() //  [R1]
         { info_tbl: [(c1yzY,
                       label: block_c1yzY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yzY: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.05116168 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_closure" {
     Data.Functor.Utils.$fSemigroupMin_closure:
         const Data.Functor.Utils.$fSemigroupMin_info;
         const 0;
 },
 sat_s1yps_entry() //  [R1, R2]
         { info_tbl: [(c1yAh,
                       label: sat_s1yps_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yAh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypr_entry() //  [R1, R2]
         { info_tbl: [(c1yAp,
                       label: sat_s1ypr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yAp: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypq_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yAx,
                       label: sat_s1ypq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yAx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_entry() //  [R2]
         { info_tbl: [(c1yAB,
                       label: Data.Functor.Utils.$fSemigroupMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yAB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1yAF; else goto c1yAE;
       c1yAF: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yAE: // global
           I64[Hp - 72] = sat_s1yps_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ypr_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1ypq_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMin_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMin_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_info;
         const 0;
 },
 sat_s1ypv_entry() //  [R1]
         { info_tbl: [(c1yAO,
                       label: sat_s1ypv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yAO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yAP; else goto c1yAQ;
       c1yAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yAQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1yAR,
                       label: Data.Functor.Utils.$fSemigroupMin_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yAR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yAV; else goto c1yAU;
       c1yAV: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yAU: // global
           I64[Hp - 16] = sat_s1ypv_info;
           P64[Hp] = R2;
           _s1ypu::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1ypu::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.05424198 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMin_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMin_$cmconcat_info;
 },
 go_s1ypy_entry() //  [R1, R2]
         { info_tbl: [(c1yBc,
                       label: go_s1ypy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yBc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yBd; else goto c1yBe;
       c1yBd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yBe: // global
           I64[Sp - 24] = block_c1yB5_info;
           _s1ypy::P64 = R1;
           _s1ypw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1ypw::P64;
           P64[Sp - 8] = _s1ypy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1yBY; else goto c1yB6;
       u1yBY: // global
           call _c1yB5(R1) args: 0, res: 0, upd: 0;
       c1yB6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yB5() //  [R1]
         { info_tbl: [(c1yB5,
                       label: block_c1yB5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yB5: // global
           if (R1 & 7 == 1) goto c1yB9; else goto c1yBa;
       c1yB9: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1yBa: // global
           I64[Sp] = block_c1yBk_info;
           R2 = P64[R1 + 14];
           _s1ypB::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1ypB::P64;
           call go_s1ypy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yBk() //  [R1]
         { info_tbl: [(c1yBk,
                       label: block_c1yBk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yBk: // global
           _s1ypB::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yBr; else goto c1yBw;
       c1yBr: // global
           R1 = _s1ypB::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yBw: // global
           I64[Sp - 8] = block_c1yBu_info;
           _s1ypD::P64 = R1;
           _s1ypE::P64 = P64[R1 + 6];
           R1 = _s1ypB::P64;
           P64[Sp] = _s1ypE::P64;
           P64[Sp + 16] = _s1ypD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1yBZ; else goto c1yBx;
       u1yBZ: // global
           call _c1yBu(R1) args: 0, res: 0, upd: 0;
       c1yBx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yBu() //  [R1]
         { info_tbl: [(c1yBu,
                       label: block_c1yBu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yBu: // global
           if (R1 & 7 == 1) goto u1yBW; else goto c1yBI;
       u1yBW: // global
           Sp = Sp + 24;
           call _c1yBO() args: 0, res: 0, upd: 0;
       c1yBI: // global
           _s1ypE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yBG_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1ypE::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yBG() //  [R1]
         { info_tbl: [(c1yBG,
                       label: block_c1yBG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yBG: // global
           if (R1 & 7 == 1) goto u1yBX; else goto c1yBS;
       u1yBX: // global
           Sp = Sp + 16;
           call _c1yBO() args: 0, res: 0, upd: 0;
       c1yBS: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yBO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yBO: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMin_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yC2,
                       label: Data.Functor.Utils.$fMonoidMin_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yC2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yC6; else goto c1yC5;
       c1yC6: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yC5: // global
           I64[Hp - 8] = go_s1ypy_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1ypy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.057025887 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_closure" {
     Data.Functor.Utils.$fMonoidMin_closure:
         const Data.Functor.Utils.$fMonoidMin_info;
         const 0;
 },
 sat_s1ypL_entry() //  [R1, R2]
         { info_tbl: [(c1yCg,
                       label: sat_s1ypL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yCg: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMin_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yCo,
                       label: sat_s1ypK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yCo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypJ_entry() //  [R1]
         { info_tbl: [(c1yCv,
                       label: sat_s1ypJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yCv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yCw; else goto c1yCx;
       c1yCw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yCx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMin_entry() //  [R2]
         { info_tbl: [(c1yCz,
                       label: Data.Functor.Utils.$fMonoidMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yCz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1yCD; else goto c1yCC;
       c1yCD: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yCC: // global
           I64[Hp - 88] = sat_s1ypL_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1ypK_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ypJ_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.059071606 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL2_closure" {
     Data.Functor.Utils.$fFunctorStateL2_closure:
         const Data.Functor.Utils.$fFunctorStateL2_info;
 },
 sat_s1ypY_entry() //  [R1]
         { info_tbl: [(c1yCO,
                       label: sat_s1ypY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yCO: // global
           _s1ypY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yCP; else goto c1yCQ;
       c1yCQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yCS; else goto c1yCR;
       c1yCS: // global
           HpAlloc = 24;
           goto c1yCP;
       c1yCP: // global
           R1 = _s1ypY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yCR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ypY::P64;
           _s1ypM::P64 = P64[_s1ypY::P64 + 16];
           _s1ypP::P64 = P64[_s1ypY::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1ypP::P64;
           R2 = Hp - 16;
           R1 = _s1ypM::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yCV,
                       label: Data.Functor.Utils.$fFunctorStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yCV: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yCZ; else goto c1yCY;
       c1yCZ: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yCY: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1ypY_info;
           P64[Hp - 56] = R2;
           _c1yCI::P64 = Hp - 104;
           P64[Hp - 48] = _c1yCI::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yCI::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.062272881 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL1_closure" {
     Data.Functor.Utils.$fFunctorStateL1_closure:
         const Data.Functor.Utils.$fFunctorStateL1_info;
 },
 sat_s1yq5_entry() //  [R1]
         { info_tbl: [(c1yDa,
                       label: sat_s1yq5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yDa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yDb; else goto c1yDc;
       c1yDb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yD8_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yD8() //  [R1]
         { info_tbl: [(c1yD8,
                       label: block_c1yD8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yD8: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yDh,
                       label: Data.Functor.Utils.$fFunctorStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yDh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1yDl; else goto c1yDk;
       c1yDl: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yDk: // global
           I64[Hp - 48] = sat_s1yq5_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.063471639 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL_closure" {
     Data.Functor.Utils.$fFunctorStateL_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateL2_closure+3;
         const Data.Functor.Utils.$fFunctorStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.06465041 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL3_closure" {
     Data.Functor.Utils.$fApplicativeStateL3_closure:
         const Data.Functor.Utils.$fApplicativeStateL3_info;
 },
 ds1_s1yqb_entry() //  [R1]
         { info_tbl: [(c1yDw,
                       label: ds1_s1yqb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yDw: // global
           _s1yqb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yDx; else goto c1yDy;
       c1yDy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yDA; else goto c1yDz;
       c1yDA: // global
           HpAlloc = 24;
           goto c1yDx;
       c1yDx: // global
           R1 = _s1yqb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yDz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqb::P64;
           _s1yq8::P64 = P64[_s1yqb::P64 + 16];
           _s1yqa::P64 = P64[_s1yqb::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yqa::P64;
           R2 = Hp - 16;
           R1 = _s1yq8::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1yqs_entry() //  [R1]
         { info_tbl: [(c1yDH,
                       label: sat_s1yqs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yDH: // global
           _s1yqs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yDI; else goto c1yDJ;
       c1yDJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1yDL; else goto c1yDK;
       c1yDL: // global
           HpAlloc = 48;
           goto c1yDI;
       c1yDI: // global
           R1 = _s1yqs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yDK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqs::P64;
           _s1yq6::P64 = P64[_s1yqs::P64 + 16];
           _s1yqa::P64 = P64[_s1yqs::P64 + 24];
           _s1yqb::P64 = P64[_s1yqs::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1yqb::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yqa::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1yq6::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1yDO,
                       label: Data.Functor.Utils.$fApplicativeStateL3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yDO: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1yDS; else goto c1yDR;
       c1yDS: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yDR: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1yqb_info;
           P64[Hp - 96] = R4;
           _c1yDq::P64 = Hp - 144;
           P64[Hp - 88] = _c1yDq::P64;
           I64[Hp - 80] = sat_s1yqs_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1yDq::P64;
           _c1yDr::P64 = Hp - 112;
           P64[Hp - 48] = _c1yDr::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yDr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.067034219 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL4_closure" {
     Data.Functor.Utils.$fApplicativeStateL4_closure:
         const Data.Functor.Utils.$fApplicativeStateL4_info;
 },
 ds1_s1yqx_entry() //  [R1]
         { info_tbl: [(c1yE3,
                       label: ds1_s1yqx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yE3: // global
           _s1yqx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yE4; else goto c1yE5;
       c1yE5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yE7; else goto c1yE6;
       c1yE7: // global
           HpAlloc = 24;
           goto c1yE4;
       c1yE4: // global
           R1 = _s1yqx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yE6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqx::P64;
           _s1yqu::P64 = P64[_s1yqx::P64 + 16];
           _s1yqw::P64 = P64[_s1yqx::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yqw::P64;
           R2 = Hp - 16;
           R1 = _s1yqu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1yqN_entry() //  [R1]
         { info_tbl: [(c1yEf,
                       label: sat_s1yqN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yEf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1yEj; else goto c1yEk;
       c1yEj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yEk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1yEc_info;
           _s1yqx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s1yqx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yEo; else goto c1yEd;
       u1yEo: // global
           call _c1yEc(R1) args: 0, res: 0, upd: 0;
       c1yEd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yEc() //  [R1]
         { info_tbl: [(c1yEc,
                       label: block_c1yEc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yEc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yEn; else goto c1yEm;
       c1yEn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1yEm: // global
           _s1yqI::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1yqI::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yEr,
                       label: Data.Functor.Utils.$fApplicativeStateL4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yEr: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1yEv; else goto c1yEu;
       c1yEv: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yEu: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1yqx_info;
           P64[Hp - 88] = R3;
           _c1yDX::P64 = Hp - 136;
           P64[Hp - 80] = _c1yDX::P64;
           I64[Hp - 72] = sat_s1yqN_info;
           P64[Hp - 56] = _c1yDX::P64;
           _c1yDY::P64 = Hp - 104;
           P64[Hp - 48] = _c1yDY::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yDY::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.069056942 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL5_closure" {
     Data.Functor.Utils.$fApplicativeStateL5_closure:
         const Data.Functor.Utils.$fApplicativeStateL5_info;
 },
 Data.Functor.Utils.$fApplicativeStateL5_entry() //  [R2, R3]
         { info_tbl: [(c1yEB,
                       label: Data.Functor.Utils.$fApplicativeStateL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yEB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yEF; else goto c1yEE;
       c1yEF: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yEE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.070583228 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL2_closure" {
     Data.Functor.Utils.$fApplicativeStateL2_closure:
         const Data.Functor.Utils.$fApplicativeStateL2_info;
 },
 sat_s1yqX_entry() //  [R1]
         { info_tbl: [(c1yEU,
                       label: sat_s1yqX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yEU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yEV; else goto c1yEW;
       c1yEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yEW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yES_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yES() //  [R1]
         { info_tbl: [(c1yES,
                       label: block_c1yES_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yES: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1yqT_entry() //  [R1]
         { info_tbl: [(c1yF0,
                       label: ds_s1yqT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yF0: // global
           _s1yqT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yF1; else goto c1yF2;
       c1yF2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1yF4; else goto c1yF3;
       c1yF4: // global
           HpAlloc = 32;
           goto c1yF1;
       c1yF1: // global
           R1 = _s1yqT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yF3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqT::P64;
           _s1yqQ::P64 = P64[_s1yqT::P64 + 16];
           _s1yqR::P64 = P64[_s1yqT::P64 + 24];
           _s1yqS::P64 = P64[_s1yqT::P64 + 32];
           I64[Hp - 24] = sat_s1yqX_info;
           P64[Hp - 8] = _s1yqQ::P64;
           P64[Hp] = _s1yqS::P64;
           R2 = Hp - 24;
           R1 = _s1yqR::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yF8,
                       label: Data.Functor.Utils.$fApplicativeStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yF8: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yFc; else goto c1yFb;
       c1yFc: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yFb: // global
           I64[Hp - 104] = ds_s1yqT_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1yEK::P64 = Hp - 104;
           P64[Hp - 48] = _c1yEK::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yEK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.072670387 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL1_closure" {
     Data.Functor.Utils.$fApplicativeStateL1_closure:
         const Data.Functor.Utils.$fApplicativeStateL1_info;
 },
 sat_s1yrh_entry() //  [R1]
         { info_tbl: [(c1yFq,
                       label: sat_s1yrh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yFq: // global
           _s1yrh::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1yFr; else goto c1yFs;
       c1yFs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yFu; else goto c1yFt;
       c1yFu: // global
           HpAlloc = 24;
           goto c1yFr;
       c1yFr: // global
           R1 = _s1yrh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yFt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yrh::P64;
           _s1yr7::P64 = P64[_s1yrh::P64 + 16];
           _s1yr9::P64 = P64[_s1yrh::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yr9::P64;
           I64[Sp - 24] = block_c1yFo_info;
           R2 = Hp - 16;
           R1 = _s1yr7::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yFo() //  [R1]
         { info_tbl: [(c1yFo,
                       label: block_c1yFo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yFo: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yFz,
                       label: Data.Functor.Utils.$fApplicativeStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yFz: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yFD; else goto c1yFC;
       c1yFD: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yFC: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1yFh::P64 = Hp - 104;
           P64[Hp - 56] = _c1yFh::P64;
           I64[Hp - 48] = sat_s1yrh_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _c1yFh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.074132588 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL_closure" {
     Data.Functor.Utils.$fApplicativeStateL_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateL_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateL4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateL2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.075076083 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR2_closure" {
     Data.Functor.Utils.$fFunctorStateR2_closure:
         const Data.Functor.Utils.$fFunctorStateR2_info;
 },
 sat_s1yry_entry() //  [R1]
         { info_tbl: [(c1yFO,
                       label: sat_s1yry_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yFO: // global
           _s1yry::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yFP; else goto c1yFQ;
       c1yFQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yFS; else goto c1yFR;
       c1yFS: // global
           HpAlloc = 24;
           goto c1yFP;
       c1yFP: // global
           R1 = _s1yry::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yFR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yry::P64;
           _s1yrm::P64 = P64[_s1yry::P64 + 16];
           _s1yrp::P64 = P64[_s1yry::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yrp::P64;
           R2 = Hp - 16;
           R1 = _s1yrm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yFV,
                       label: Data.Functor.Utils.$fFunctorStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yFV: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yFZ; else goto c1yFY;
       c1yFZ: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yFY: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1yry_info;
           P64[Hp - 56] = R2;
           _c1yFI::P64 = Hp - 104;
           P64[Hp - 48] = _c1yFI::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yFI::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.076724783 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR1_closure" {
     Data.Functor.Utils.$fFunctorStateR1_closure:
         const Data.Functor.Utils.$fFunctorStateR1_info;
 },
 sat_s1yrF_entry() //  [R1]
         { info_tbl: [(c1yGa,
                       label: sat_s1yrF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yGa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yGb; else goto c1yGc;
       c1yGb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yGc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yG8_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yG8() //  [R1]
         { info_tbl: [(c1yG8,
                       label: block_c1yG8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yG8: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yGh,
                       label: Data.Functor.Utils.$fFunctorStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yGh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1yGl; else goto c1yGk;
       c1yGl: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yGk: // global
           I64[Hp - 48] = sat_s1yrF_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.077998195 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR_closure" {
     Data.Functor.Utils.$fFunctorStateR_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateR2_closure+3;
         const Data.Functor.Utils.$fFunctorStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.079149089 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR3_closure" {
     Data.Functor.Utils.$fApplicativeStateR3_closure:
         const Data.Functor.Utils.$fApplicativeStateR3_info;
 },
 ds1_s1yrL_entry() //  [R1]
         { info_tbl: [(c1yGw,
                       label: ds1_s1yrL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yGw: // global
           _s1yrL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yGx; else goto c1yGy;
       c1yGy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yGA; else goto c1yGz;
       c1yGA: // global
           HpAlloc = 24;
           goto c1yGx;
       c1yGx: // global
           R1 = _s1yrL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yGz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yrL::P64;
           _s1yrH::P64 = P64[_s1yrL::P64 + 16];
           _s1yrK::P64 = P64[_s1yrL::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yrK::P64;
           R2 = Hp - 16;
           R1 = _s1yrH::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ys2_entry() //  [R1]
         { info_tbl: [(c1yGH,
                       label: sat_s1ys2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yGH: // global
           _s1ys2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yGI; else goto c1yGJ;
       c1yGJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1yGL; else goto c1yGK;
       c1yGL: // global
           HpAlloc = 48;
           goto c1yGI;
       c1yGI: // global
           R1 = _s1ys2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yGK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ys2::P64;
           _s1yrG::P64 = P64[_s1ys2::P64 + 16];
           _s1yrK::P64 = P64[_s1ys2::P64 + 24];
           _s1yrL::P64 = P64[_s1ys2::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1yrK::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yrL::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1yrG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1yGO,
                       label: Data.Functor.Utils.$fApplicativeStateR3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yGO: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1yGS; else goto c1yGR;
       c1yGS: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yGR: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R4;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1yrL_info;
           P64[Hp - 96] = R3;
           _c1yGq::P64 = Hp - 144;
           P64[Hp - 88] = _c1yGq::P64;
           I64[Hp - 80] = sat_s1ys2_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1yGq::P64;
           _c1yGr::P64 = Hp - 112;
           P64[Hp - 48] = _c1yGr::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yGr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.081730488 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR4_closure" {
     Data.Functor.Utils.$fApplicativeStateR4_closure:
         const Data.Functor.Utils.$fApplicativeStateR4_info;
 },
 ds1_s1ys7_entry() //  [R1]
         { info_tbl: [(c1yH3,
                       label: ds1_s1ys7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yH3: // global
           _s1ys7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yH4; else goto c1yH5;
       c1yH5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yH7; else goto c1yH6;
       c1yH7: // global
           HpAlloc = 24;
           goto c1yH4;
       c1yH4: // global
           R1 = _s1ys7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yH6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ys7::P64;
           _s1ys3::P64 = P64[_s1ys7::P64 + 16];
           _s1ys6::P64 = P64[_s1ys7::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ys6::P64;
           R2 = Hp - 16;
           R1 = _s1ys3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ysn_entry() //  [R1]
         { info_tbl: [(c1yHf,
                       label: sat_s1ysn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yHf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1yHj; else goto c1yHk;
       c1yHj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yHk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1yHc_info;
           _s1ys6::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1ys6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yHo; else goto c1yHd;
       u1yHo: // global
           call _c1yHc(R1) args: 0, res: 0, upd: 0;
       c1yHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yHc() //  [R1]
         { info_tbl: [(c1yHc,
                       label: block_c1yHc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yHc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yHn; else goto c1yHm;
       c1yHn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1yHm: // global
           _s1ysi::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1ysi::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yHr,
                       label: Data.Functor.Utils.$fApplicativeStateR4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yHr: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1yHv; else goto c1yHu;
       c1yHv: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yHu: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1ys7_info;
           P64[Hp - 88] = R2;
           _c1yGX::P64 = Hp - 136;
           P64[Hp - 80] = _c1yGX::P64;
           I64[Hp - 72] = sat_s1ysn_info;
           P64[Hp - 56] = _c1yGX::P64;
           _c1yGY::P64 = Hp - 104;
           P64[Hp - 48] = _c1yGY::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yGY::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.084089431 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR2_closure" {
     Data.Functor.Utils.$fApplicativeStateR2_closure:
         const Data.Functor.Utils.$fApplicativeStateR2_info;
 },
 sat_s1ysz_entry() //  [R1]
         { info_tbl: [(c1yHJ,
                       label: sat_s1ysz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yHJ: // global
           _s1ysz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1yHK; else goto c1yHL;
       c1yHL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yHN; else goto c1yHM;
       c1yHN: // global
           HpAlloc = 24;
           goto c1yHK;
       c1yHK: // global
           R1 = _s1ysz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yHM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ysz::P64;
           _s1yso::P64 = P64[_s1ysz::P64 + 16];
           _s1ysr::P64 = P64[_s1ysz::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ysr::P64;
           I64[Sp - 24] = block_c1yHH_info;
           R2 = Hp - 16;
           R1 = _s1yso::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yHH() //  [R1]
         { info_tbl: [(c1yHH,
                       label: block_c1yHH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yHH: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yHS,
                       label: Data.Functor.Utils.$fApplicativeStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yHS: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yHW; else goto c1yHV;
       c1yHW: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yHV: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1yHA::P64 = Hp - 104;
           P64[Hp - 56] = _c1yHA::P64;
           I64[Hp - 48] = sat_s1ysz_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _c1yHA::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.086124415 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR1_closure" {
     Data.Functor.Utils.$fApplicativeStateR1_closure:
         const Data.Functor.Utils.$fApplicativeStateR1_info;
 },
 sat_s1ysL_entry() //  [R1]
         { info_tbl: [(c1yIb,
                       label: sat_s1ysL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yIc; else goto c1yId;
       c1yIc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yId: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yI9_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yI9() //  [R1]
         { info_tbl: [(c1yI9,
                       label: block_c1yI9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yI9: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds2_s1ysH_entry() //  [R1]
         { info_tbl: [(c1yIh,
                       label: ds2_s1ysH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIh: // global
           _s1ysH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yIi; else goto c1yIj;
       c1yIj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1yIl; else goto c1yIk;
       c1yIl: // global
           HpAlloc = 32;
           goto c1yIi;
       c1yIi: // global
           R1 = _s1ysH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yIk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ysH::P64;
           _s1ysE::P64 = P64[_s1ysH::P64 + 16];
           _s1ysF::P64 = P64[_s1ysH::P64 + 24];
           _s1ysG::P64 = P64[_s1ysH::P64 + 32];
           I64[Hp - 24] = sat_s1ysL_info;
           P64[Hp - 8] = _s1ysF::P64;
           P64[Hp] = _s1ysG::P64;
           R2 = Hp - 24;
           R1 = _s1ysE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yIp,
                       label: Data.Functor.Utils.$fApplicativeStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIp: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yIt; else goto c1yIs;
       c1yIt: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yIs: // global
           I64[Hp - 104] = ds2_s1ysH_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1yI1::P64 = Hp - 104;
           P64[Hp - 48] = _c1yI1::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yI1::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.087757139 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR_closure" {
     Data.Functor.Utils.$fApplicativeStateR_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateR_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateR4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateR2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.088498286 UTC

[section ""data" . Data.Functor.Utils.getMax1_closure" {
     Data.Functor.Utils.getMax1_closure:
         const Data.Functor.Utils.getMax1_info;
 },
 Data.Functor.Utils.getMax1_entry() //  [R2]
         { info_tbl: [(c1yIy,
                       label: Data.Functor.Utils.getMax1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIy: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.089356921 UTC

[section ""data" . Data.Functor.Utils.getMax_closure" {
     Data.Functor.Utils.getMax_closure:
         const Data.Functor.Utils.getMax_info;
 },
 Data.Functor.Utils.getMax_entry() //  [R2]
         { info_tbl: [(c1yIF,
                       label: Data.Functor.Utils.getMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIF: // global
           R2 = R2;
           call Data.Functor.Utils.getMax1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.090185911 UTC

[section ""data" . Data.Functor.Utils.getMin1_closure" {
     Data.Functor.Utils.getMin1_closure:
         const Data.Functor.Utils.getMin1_info;
 },
 Data.Functor.Utils.getMin1_entry() //  [R2]
         { info_tbl: [(c1yIM,
                       label: Data.Functor.Utils.getMin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIM: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.091001743 UTC

[section ""data" . Data.Functor.Utils.getMin_closure" {
     Data.Functor.Utils.getMin_closure:
         const Data.Functor.Utils.getMin_info;
 },
 Data.Functor.Utils.getMin_entry() //  [R2]
         { info_tbl: [(c1yIT,
                       label: Data.Functor.Utils.getMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yIT: // global
           R2 = R2;
           call Data.Functor.Utils.getMin1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.09183538 UTC

[section ""data" . Data.Functor.Utils.runStateL1_closure" {
     Data.Functor.Utils.runStateL1_closure:
         const Data.Functor.Utils.runStateL1_info;
 },
 Data.Functor.Utils.runStateL1_entry() //  [R2]
         { info_tbl: [(c1yJ0,
                       label: Data.Functor.Utils.runStateL1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJ0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.096821691 UTC

[section ""data" . Data.Functor.Utils.runStateL_closure" {
     Data.Functor.Utils.runStateL_closure:
         const Data.Functor.Utils.runStateL_info;
 },
 Data.Functor.Utils.runStateL_entry() //  [R2]
         { info_tbl: [(c1yJ7,
                       label: Data.Functor.Utils.runStateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJ7: // global
           R2 = R2;
           call Data.Functor.Utils.runStateL1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.098198957 UTC

[section ""data" . Data.Functor.Utils.runStateR1_closure" {
     Data.Functor.Utils.runStateR1_closure:
         const Data.Functor.Utils.runStateR1_info;
 },
 Data.Functor.Utils.runStateR1_entry() //  [R2]
         { info_tbl: [(c1yJe,
                       label: Data.Functor.Utils.runStateR1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJe: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.099317878 UTC

[section ""data" . Data.Functor.Utils.runStateR_closure" {
     Data.Functor.Utils.runStateR_closure:
         const Data.Functor.Utils.runStateR_info;
 },
 Data.Functor.Utils.runStateR_entry() //  [R2]
         { info_tbl: [(c1yJl,
                       label: Data.Functor.Utils.runStateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJl: // global
           R2 = R2;
           call Data.Functor.Utils.runStateR1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.100475484 UTC

[section ""data" . Data.Functor.Utils.#._closure" {
     Data.Functor.Utils.#._closure:
         const Data.Functor.Utils.#._info;
 },
 Data.Functor.Utils.#._entry() //  [R2, R3, R4]
         { info_tbl: [(c1yJu,
                       label: Data.Functor.Utils.#._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yJv; else goto c1yJw;
       c1yJv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.#._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yJw: // global
           I64[Sp - 16] = block_c1yJs_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1yJs() //  []
         { info_tbl: [(c1yJs,
                       label: block_c1yJs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.102005201 UTC

[section ""cstring" . Data.Functor.Utils.$trModule4_bytes" {
     Data.Functor.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.102918572 UTC

[section ""data" . Data.Functor.Utils.$trModule3_closure" {
     Data.Functor.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.103724625 UTC

[section ""cstring" . Data.Functor.Utils.$trModule2_bytes" {
     Data.Functor.Utils.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.104428368 UTC

[section ""data" . Data.Functor.Utils.$trModule1_closure" {
     Data.Functor.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.10519113 UTC

[section ""data" . Data.Functor.Utils.$trModule_closure" {
     Data.Functor.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Utils.$trModule3_closure+1;
         const Data.Functor.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.106061219 UTC

[section ""data" . $krep_r1ynX_closure" {
     $krep_r1ynX_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.10676175 UTC

[section ""data" . $krep1_r1ynY_closure" {
     $krep1_r1ynY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.107471437 UTC

[section ""data" . $krep2_r1ynZ_closure" {
     $krep2_r1ynZ_closure:
         const :_con_info;
         const $krep_r1ynX_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.108325791 UTC

[section ""data" . $krep3_r1yo0_closure" {
     $krep3_r1yo0_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep2_r1ynZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.109166872 UTC

[section ""data" . $krep4_r1yo1_closure" {
     $krep4_r1yo1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.109959782 UTC

[section ""data" . $krep5_r1yo2_closure" {
     $krep5_r1yo2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep4_r1yo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.110827536 UTC

[section ""data" . $krep6_r1yo3_closure" {
     $krep6_r1yo3_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.111653697 UTC

[section ""data" . $krep7_r1yo4_closure" {
     $krep7_r1yo4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.112489213 UTC

[section ""cstring" . Data.Functor.Utils.$tcMax2_bytes" {
     Data.Functor.Utils.$tcMax2_bytes:
         I8[] [77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.113371186 UTC

[section ""data" . Data.Functor.Utils.$tcMax1_closure" {
     Data.Functor.Utils.$tcMax1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMax2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.114159523 UTC

[section ""data" . Data.Functor.Utils.$tcMax_closure" {
     Data.Functor.Utils.$tcMax_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMax1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17055998897267803697;
         const 13070619747111935994;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.115022994 UTC

[section ""data" . $krep8_r1yo5_closure" {
     $krep8_r1yo5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMax_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.115885286 UTC

[section ""data" . Data.Functor.Utils.$tc'Max1_closure" {
     Data.Functor.Utils.$tc'Max1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep8_r1yo5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.116694179 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Max3_bytes" {
     Data.Functor.Utils.$tc'Max3_bytes:
         I8[] [39,77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.117568322 UTC

[section ""data" . Data.Functor.Utils.$tc'Max2_closure" {
     Data.Functor.Utils.$tc'Max2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Max3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.118354106 UTC

[section ""data" . Data.Functor.Utils.$tc'Max_closure" {
     Data.Functor.Utils.$tc'Max_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Max2_closure+1;
         const Data.Functor.Utils.$tc'Max1_closure+4;
         const 16178335003924091205;
         const 10384293407056089504;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.119247423 UTC

[section ""cstring" . Data.Functor.Utils.$tcMin2_bytes" {
     Data.Functor.Utils.$tcMin2_bytes:
         I8[] [77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.120182832 UTC

[section ""data" . Data.Functor.Utils.$tcMin1_closure" {
     Data.Functor.Utils.$tcMin1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMin2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.121061762 UTC

[section ""data" . Data.Functor.Utils.$tcMin_closure" {
     Data.Functor.Utils.$tcMin_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMin1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13719831963261617173;
         const 12509304105097421826;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.121989458 UTC

[section ""data" . $krep9_r1yo6_closure" {
     $krep9_r1yo6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMin_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.122775544 UTC

[section ""data" . Data.Functor.Utils.$tc'Min1_closure" {
     Data.Functor.Utils.$tc'Min1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep9_r1yo6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.123580935 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Min3_bytes" {
     Data.Functor.Utils.$tc'Min3_bytes:
         I8[] [39,77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.124336411 UTC

[section ""data" . Data.Functor.Utils.$tc'Min2_closure" {
     Data.Functor.Utils.$tc'Min2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Min3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.12516051 UTC

[section ""data" . Data.Functor.Utils.$tc'Min_closure" {
     Data.Functor.Utils.$tc'Min_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Min2_closure+1;
         const Data.Functor.Utils.$tc'Min1_closure+4;
         const 3497961960072019520;
         const 14191657227527039212;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.126095126 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateL2_bytes" {
     Data.Functor.Utils.$tcStateL2_bytes:
         I8[] [83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.126895544 UTC

[section ""data" . Data.Functor.Utils.$tcStateL1_closure" {
     Data.Functor.Utils.$tcStateL1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateL2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.127753372 UTC

[section ""data" . Data.Functor.Utils.$tcStateL_closure" {
     Data.Functor.Utils.$tcStateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateL1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 8498227433031831307;
         const 6442648285908986693;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.128622578 UTC

[section ""data" . $krep10_r1yo7_closure" {
     $krep10_r1yo7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateL_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.129516287 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL1_closure" {
     Data.Functor.Utils.$tc'StateL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep10_r1yo7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.130412881 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateL3_bytes" {
     Data.Functor.Utils.$tc'StateL3_bytes:
         I8[] [39,83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.131274291 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL2_closure" {
     Data.Functor.Utils.$tc'StateL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.132200616 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL_closure" {
     Data.Functor.Utils.$tc'StateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateL2_closure+1;
         const Data.Functor.Utils.$tc'StateL1_closure+4;
         const 8965240648136302046;
         const 8498113279827793106;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.133148558 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateR2_bytes" {
     Data.Functor.Utils.$tcStateR2_bytes:
         I8[] [83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.134931356 UTC

[section ""data" . Data.Functor.Utils.$tcStateR1_closure" {
     Data.Functor.Utils.$tcStateR1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateR2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.135588006 UTC

[section ""data" . Data.Functor.Utils.$tcStateR_closure" {
     Data.Functor.Utils.$tcStateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateR1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 10049146831422350196;
         const 16883721947448934294;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.136262052 UTC

[section ""data" . $krep11_r1yo8_closure" {
     $krep11_r1yo8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateR_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.136843128 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR1_closure" {
     Data.Functor.Utils.$tc'StateR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep11_r1yo8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.137995019 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateR3_bytes" {
     Data.Functor.Utils.$tc'StateR3_bytes:
         I8[] [39,83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.138523281 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR2_closure" {
     Data.Functor.Utils.$tc'StateR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.139075395 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR_closure" {
     Data.Functor.Utils.$tc'StateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateR2_closure+1;
         const Data.Functor.Utils.$tc'StateR1_closure+4;
         const 13798701525568783897;
         const 17913645303573466967;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.139662438 UTC

[section ""relreadonly" . S1yw7_srt" {
     S1yw7_srt:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMax_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMin_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.140247229 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:20.141582872 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMax_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMax_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMax_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yJJ,
                       label: Data.Functor.Utils.$fMonoidMax_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yJK; else goto c1yJL;
       c1yJK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yJL: // global
           I64[Sp - 24] = block_c1yJC_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1yKk; else goto c1yJD;
       u1yKk: // global
           call _c1yJC(R1) args: 0, res: 0, upd: 0;
       c1yJD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yJC() //  [R1]
         { info_tbl: [(c1yJC,
                       label: block_c1yJC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJC: // global
           _s1yob::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yJG; else goto c1yJH;
       c1yJG: // global
           R1 = _s1yob::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yJH: // global
           I64[Sp - 8] = block_c1yJR_info;
           _s1yod::P64 = R1;
           _s1yoe::P64 = P64[R1 + 6];
           R1 = _s1yob::P64;
           P64[Sp] = _s1yoe::P64;
           P64[Sp + 16] = _s1yod::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1yKj; else goto c1yJT;
       u1yKj: // global
           call _c1yJR(R1) args: 0, res: 0, upd: 0;
       c1yJT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yJR() //  [R1]
         { info_tbl: [(c1yJR,
                       label: block_c1yJR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yJR: // global
           if (R1 & 7 == 1) goto u1yKh; else goto c1yK4;
       u1yKh: // global
           Sp = Sp + 24;
           call _c1yKa() args: 0, res: 0, upd: 0;
       c1yK4: // global
           _s1yoe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yK2_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yoe::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yK2() //  [R1]
         { info_tbl: [(c1yK2,
                       label: block_c1yK2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yK2: // global
           if (R1 & 7 == 1) goto u1yKi; else goto c1yKe;
       u1yKi: // global
           Sp = Sp + 16;
           call _c1yKa() args: 0, res: 0, upd: 0;
       c1yKe: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yKa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yKa: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.14421141 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat_closure" {
     Data.Functor.Utils.$w$csconcat_closure:
         const Data.Functor.Utils.$w$csconcat_info;
 },
 go_s1yol_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yKD,
                       label: go_s1yol_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yKD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yKE; else goto c1yKF;
       c1yKE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yKF: // global
           I64[Sp - 32] = block_c1yKw_info;
           _s1yol::P64 = R1;
           _s1yoi::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1yoi::P64;
           P64[Sp - 16] = _s1yol::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yLs; else goto c1yKx;
       u1yLs: // global
           call _c1yKw(R1) args: 0, res: 0, upd: 0;
       c1yKx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yKw() //  [R1]
         { info_tbl: [(c1yKw,
                       label: block_c1yKw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yKw: // global
           if (R1 & 7 == 1) goto u1yLn; else goto c1yKB;
       u1yLn: // global
           Sp = Sp + 24;
           call _c1yKS() args: 0, res: 0, upd: 0;
       c1yKB: // global
           I64[Sp] = block_c1yKL_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1yol_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yKL() //  [R1]
         { info_tbl: [(c1yKL,
                       label: block_c1yKL_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yKL: // global
           if (R1 & 7 == 1) goto u1yLo; else goto c1yKX;
       u1yLo: // global
           Sp = Sp + 24;
           call _c1yKS() args: 0, res: 0, upd: 0;
       c1yKX: // global
           I64[Sp] = block_c1yKV_info;
           _s1yor::P64 = R1;
           _s1yos::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1yos::P64;
           P64[Sp + 24] = _s1yor::P64;
           if (R1 & 7 != 0) goto u1yLt; else goto c1yKY;
       u1yLt: // global
           call _c1yKV(R1) args: 0, res: 0, upd: 0;
       c1yKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yKS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yKS: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yKV() //  [R1]
         { info_tbl: [(c1yKV,
                       label: block_c1yKV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yKV: // global
           if (R1 & 7 == 1) goto u1yLp; else goto c1yL9;
       u1yLp: // global
           Sp = Sp + 24;
           call _c1yLf() args: 0, res: 0, upd: 0;
       c1yL9: // global
           _s1yoi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yL7_info;
           R2 = _s1yoi::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yL7() //  [R1]
         { info_tbl: [(c1yL7,
                       label: block_c1yL7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yL7: // global
           if (R1 & 7 == 1) goto u1yLq; else goto c1yLj;
       u1yLq: // global
           Sp = Sp + 16;
           call _c1yLf() args: 0, res: 0, upd: 0;
       c1yLj: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yLf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yLf: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yLx,
                       label: Data.Functor.Utils.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yLx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yLB; else goto c1yLA;
       c1yLB: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yLA: // global
           I64[Hp - 8] = go_s1yol_info;
           P64[Hp] = R2;
           _s1yoj::P64 = R3;
           R3 = R4;
           R2 = _s1yoj::P64;
           R1 = Hp - 6;
           call go_s1yol_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.146766468 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMax_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMax_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMax_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yLJ,
                       label: Data.Functor.Utils.$fSemigroupMax_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yLJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yLK; else goto c1yLL;
       c1yLK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yLL: // global
           I64[Sp - 16] = block_c1yLG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1yLP; else goto c1yLH;
       u1yLP: // global
           call _c1yLG(R1) args: 0, res: 0, upd: 0;
       c1yLH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yLG() //  [R1]
         { info_tbl: [(c1yLG,
                       label: block_c1yLG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yLG: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.148560545 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_closure" {
     Data.Functor.Utils.$fSemigroupMax_closure:
         const Data.Functor.Utils.$fSemigroupMax_info;
         const 0;
 },
 sat_s1yoE_entry() //  [R1, R2]
         { info_tbl: [(c1yLZ,
                       label: sat_s1yoE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yLZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoD_entry() //  [R1, R2]
         { info_tbl: [(c1yM7,
                       label: sat_s1yoD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yM7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoC_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yMf,
                       label: sat_s1yoC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yMf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_entry() //  [R2]
         { info_tbl: [(c1yMj,
                       label: Data.Functor.Utils.$fSemigroupMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yMj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1yMn; else goto c1yMm;
       c1yMn: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yMm: // global
           I64[Hp - 72] = sat_s1yoE_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1yoD_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1yoC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMax_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMax_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_info;
         const 0;
 },
 sat_s1yoH_entry() //  [R1]
         { info_tbl: [(c1yMw,
                       label: sat_s1yoH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yMw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yMx; else goto c1yMy;
       c1yMx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yMy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1yMz,
                       label: Data.Functor.Utils.$fSemigroupMax_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yMz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yMD; else goto c1yMC;
       c1yMD: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yMC: // global
           I64[Hp - 16] = sat_s1yoH_info;
           P64[Hp] = R2;
           _s1yoG::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1yoG::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.151773824 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMax_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMax_$cmconcat_info;
 },
 go_s1yoK_entry() //  [R1, R2]
         { info_tbl: [(c1yMU,
                       label: go_s1yoK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yMU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yMV; else goto c1yMW;
       c1yMV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yMW: // global
           I64[Sp - 24] = block_c1yMN_info;
           _s1yoK::P64 = R1;
           _s1yoI::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1yoI::P64;
           P64[Sp - 8] = _s1yoK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1yNG; else goto c1yMO;
       u1yNG: // global
           call _c1yMN(R1) args: 0, res: 0, upd: 0;
       c1yMO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yMN() //  [R1]
         { info_tbl: [(c1yMN,
                       label: block_c1yMN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yMN: // global
           if (R1 & 7 == 1) goto c1yMR; else goto c1yMS;
       c1yMR: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1yMS: // global
           I64[Sp] = block_c1yN2_info;
           R2 = P64[R1 + 14];
           _s1yoN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1yoN::P64;
           call go_s1yoK_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yN2() //  [R1]
         { info_tbl: [(c1yN2,
                       label: block_c1yN2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yN2: // global
           _s1yoN::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yN9; else goto c1yNe;
       c1yN9: // global
           R1 = _s1yoN::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yNe: // global
           I64[Sp - 8] = block_c1yNc_info;
           _s1yoP::P64 = R1;
           _s1yoQ::P64 = P64[R1 + 6];
           R1 = _s1yoN::P64;
           P64[Sp] = _s1yoQ::P64;
           P64[Sp + 16] = _s1yoP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1yNH; else goto c1yNf;
       u1yNH: // global
           call _c1yNc(R1) args: 0, res: 0, upd: 0;
       c1yNf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yNc() //  [R1]
         { info_tbl: [(c1yNc,
                       label: block_c1yNc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yNc: // global
           if (R1 & 7 == 1) goto u1yNE; else goto c1yNq;
       u1yNE: // global
           Sp = Sp + 24;
           call _c1yNw() args: 0, res: 0, upd: 0;
       c1yNq: // global
           _s1yoQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yNo_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yoQ::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yNo() //  [R1]
         { info_tbl: [(c1yNo,
                       label: block_c1yNo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yNo: // global
           if (R1 & 7 == 1) goto u1yNF; else goto c1yNA;
       u1yNF: // global
           Sp = Sp + 16;
           call _c1yNw() args: 0, res: 0, upd: 0;
       c1yNA: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yNw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yNw: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMax_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yNK,
                       label: Data.Functor.Utils.$fMonoidMax_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yNK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yNO; else goto c1yNN;
       c1yNO: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yNN: // global
           I64[Hp - 8] = go_s1yoK_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1yoK_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.154548928 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_closure" {
     Data.Functor.Utils.$fMonoidMax_closure:
         const Data.Functor.Utils.$fMonoidMax_info;
         const 0;
 },
 sat_s1yoX_entry() //  [R1, R2]
         { info_tbl: [(c1yNY,
                       label: sat_s1yoX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yNY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMax_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoW_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yO6,
                       label: sat_s1yoW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yO6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoV_entry() //  [R1]
         { info_tbl: [(c1yOd,
                       label: sat_s1yoV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yOe; else goto c1yOf;
       c1yOe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yOf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMax_entry() //  [R2]
         { info_tbl: [(c1yOh,
                       label: Data.Functor.Utils.$fMonoidMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOh: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1yOl; else goto c1yOk;
       c1yOl: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yOk: // global
           I64[Hp - 88] = sat_s1yoX_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1yoW_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1yoV_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.156627044 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMin_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMin_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMin_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yOx,
                       label: Data.Functor.Utils.$fMonoidMin_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yOy; else goto c1yOz;
       c1yOy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yOz: // global
           I64[Sp - 24] = block_c1yOq_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1yP8; else goto c1yOr;
       u1yP8: // global
           call _c1yOq(R1) args: 0, res: 0, upd: 0;
       c1yOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yOq() //  [R1]
         { info_tbl: [(c1yOq,
                       label: block_c1yOq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOq: // global
           _s1yoZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yOu; else goto c1yOv;
       c1yOu: // global
           R1 = _s1yoZ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yOv: // global
           I64[Sp - 8] = block_c1yOF_info;
           _s1yp1::P64 = R1;
           _s1yp2::P64 = P64[R1 + 6];
           R1 = _s1yoZ::P64;
           P64[Sp] = _s1yp2::P64;
           P64[Sp + 16] = _s1yp1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1yP7; else goto c1yOH;
       u1yP7: // global
           call _c1yOF(R1) args: 0, res: 0, upd: 0;
       c1yOH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yOF() //  [R1]
         { info_tbl: [(c1yOF,
                       label: block_c1yOF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOF: // global
           if (R1 & 7 == 1) goto u1yP5; else goto c1yOS;
       u1yP5: // global
           Sp = Sp + 24;
           call _c1yOY() args: 0, res: 0, upd: 0;
       c1yOS: // global
           _s1yp2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yOQ_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yp2::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yOQ() //  [R1]
         { info_tbl: [(c1yOQ,
                       label: block_c1yOQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOQ: // global
           if (R1 & 7 == 1) goto u1yP6; else goto c1yP2;
       u1yP6: // global
           Sp = Sp + 16;
           call _c1yOY() args: 0, res: 0, upd: 0;
       c1yP2: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yOY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yOY: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.159374747 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat1_closure" {
     Data.Functor.Utils.$w$csconcat1_closure:
         const Data.Functor.Utils.$w$csconcat1_info;
 },
 go_s1yp9_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yPr,
                       label: go_s1yp9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yPr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yPs; else goto c1yPt;
       c1yPs: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yPt: // global
           I64[Sp - 32] = block_c1yPk_info;
           _s1yp9::P64 = R1;
           _s1yp6::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1yp6::P64;
           P64[Sp - 16] = _s1yp9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yQg; else goto c1yPl;
       u1yQg: // global
           call _c1yPk(R1) args: 0, res: 0, upd: 0;
       c1yPl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yPk() //  [R1]
         { info_tbl: [(c1yPk,
                       label: block_c1yPk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yPk: // global
           if (R1 & 7 == 1) goto u1yQb; else goto c1yPp;
       u1yQb: // global
           Sp = Sp + 24;
           call _c1yPG() args: 0, res: 0, upd: 0;
       c1yPp: // global
           I64[Sp] = block_c1yPz_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1yp9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yPz() //  [R1]
         { info_tbl: [(c1yPz,
                       label: block_c1yPz_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yPz: // global
           if (R1 & 7 == 1) goto u1yQc; else goto c1yPL;
       u1yQc: // global
           Sp = Sp + 24;
           call _c1yPG() args: 0, res: 0, upd: 0;
       c1yPL: // global
           I64[Sp] = block_c1yPJ_info;
           _s1ypf::P64 = R1;
           _s1ypg::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1ypg::P64;
           P64[Sp + 24] = _s1ypf::P64;
           if (R1 & 7 != 0) goto u1yQh; else goto c1yPM;
       u1yQh: // global
           call _c1yPJ(R1) args: 0, res: 0, upd: 0;
       c1yPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yPG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yPG: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yPJ() //  [R1]
         { info_tbl: [(c1yPJ,
                       label: block_c1yPJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yPJ: // global
           if (R1 & 7 == 1) goto u1yQd; else goto c1yPX;
       u1yQd: // global
           Sp = Sp + 24;
           call _c1yQ3() args: 0, res: 0, upd: 0;
       c1yPX: // global
           _s1yp6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1yPV_info;
           R2 = _s1yp6::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1yPV() //  [R1]
         { info_tbl: [(c1yPV,
                       label: block_c1yPV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yPV: // global
           if (R1 & 7 == 1) goto u1yQe; else goto c1yQ7;
       u1yQe: // global
           Sp = Sp + 16;
           call _c1yQ3() args: 0, res: 0, upd: 0;
       c1yQ7: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1yQ3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yQ3: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yQl,
                       label: Data.Functor.Utils.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yQl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1yQp; else goto c1yQo;
       c1yQp: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yQo: // global
           I64[Hp - 8] = go_s1yp9_info;
           P64[Hp] = R2;
           _s1yp7::P64 = R3;
           R3 = R4;
           R2 = _s1yp7::P64;
           R1 = Hp - 6;
           call go_s1yp9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.161979133 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMin_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMin_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMin_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1yQx,
                       label: Data.Functor.Utils.$fSemigroupMin_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yQy; else goto c1yQz;
       c1yQy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yQz: // global
           I64[Sp - 16] = block_c1yQu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1yQD; else goto c1yQv;
       u1yQD: // global
           call _c1yQu(R1) args: 0, res: 0, upd: 0;
       c1yQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yQu() //  [R1]
         { info_tbl: [(c1yQu,
                       label: block_c1yQu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yQu: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.163771202 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_closure" {
     Data.Functor.Utils.$fSemigroupMin_closure:
         const Data.Functor.Utils.$fSemigroupMin_info;
         const 0;
 },
 sat_s1yps_entry() //  [R1, R2]
         { info_tbl: [(c1yQN,
                       label: sat_s1yps_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yQN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypr_entry() //  [R1, R2]
         { info_tbl: [(c1yQV,
                       label: sat_s1ypr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yQV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypq_entry() //  [R1, R2, R3]
         { info_tbl: [(c1yR3,
                       label: sat_s1ypq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yR3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_entry() //  [R2]
         { info_tbl: [(c1yR7,
                       label: Data.Functor.Utils.$fSemigroupMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yR7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1yRb; else goto c1yRa;
       c1yRb: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yRa: // global
           I64[Hp - 72] = sat_s1yps_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ypr_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1ypq_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMin_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMin_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_info;
         const 0;
 },
 sat_s1ypv_entry() //  [R1]
         { info_tbl: [(c1yRk,
                       label: sat_s1ypv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yRk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yRl; else goto c1yRm;
       c1yRl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yRm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1yRn,
                       label: Data.Functor.Utils.$fSemigroupMin_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yRn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yRr; else goto c1yRq;
       c1yRr: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yRq: // global
           I64[Hp - 16] = sat_s1ypv_info;
           P64[Hp] = R2;
           _s1ypu::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1ypu::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.166611344 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMin_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMin_$cmconcat_info;
 },
 go_s1ypy_entry() //  [R1, R2]
         { info_tbl: [(c1yRI,
                       label: go_s1ypy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yRI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1yRJ; else goto c1yRK;
       c1yRJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yRK: // global
           I64[Sp - 24] = block_c1yRB_info;
           _s1ypy::P64 = R1;
           _s1ypw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1ypw::P64;
           P64[Sp - 8] = _s1ypy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ySu; else goto c1yRC;
       u1ySu: // global
           call _c1yRB(R1) args: 0, res: 0, upd: 0;
       c1yRC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yRB() //  [R1]
         { info_tbl: [(c1yRB,
                       label: block_c1yRB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yRB: // global
           if (R1 & 7 == 1) goto c1yRF; else goto c1yRG;
       c1yRF: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1yRG: // global
           I64[Sp] = block_c1yRQ_info;
           R2 = P64[R1 + 14];
           _s1ypB::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1ypB::P64;
           call go_s1ypy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yRQ() //  [R1]
         { info_tbl: [(c1yRQ,
                       label: block_c1yRQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yRQ: // global
           _s1ypB::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1yRX; else goto c1yS2;
       c1yRX: // global
           R1 = _s1ypB::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1yS2: // global
           I64[Sp - 8] = block_c1yS0_info;
           _s1ypD::P64 = R1;
           _s1ypE::P64 = P64[R1 + 6];
           R1 = _s1ypB::P64;
           P64[Sp] = _s1ypE::P64;
           P64[Sp + 16] = _s1ypD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ySv; else goto c1yS3;
       u1ySv: // global
           call _c1yS0(R1) args: 0, res: 0, upd: 0;
       c1yS3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1yS0() //  [R1]
         { info_tbl: [(c1yS0,
                       label: block_c1yS0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yS0: // global
           if (R1 & 7 == 1) goto u1ySs; else goto c1ySe;
       u1ySs: // global
           Sp = Sp + 24;
           call _c1ySk() args: 0, res: 0, upd: 0;
       c1ySe: // global
           _s1ypE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1ySc_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1ypE::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ySc() //  [R1]
         { info_tbl: [(c1ySc,
                       label: block_c1ySc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ySc: // global
           if (R1 & 7 == 1) goto u1ySt; else goto c1ySo;
       u1ySt: // global
           Sp = Sp + 16;
           call _c1ySk() args: 0, res: 0, upd: 0;
       c1ySo: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1ySk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ySk: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMin_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1ySy,
                       label: Data.Functor.Utils.$fMonoidMin_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ySy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ySC; else goto c1ySB;
       c1ySC: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ySB: // global
           I64[Hp - 8] = go_s1ypy_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1ypy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.170887253 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_closure" {
     Data.Functor.Utils.$fMonoidMin_closure:
         const Data.Functor.Utils.$fMonoidMin_info;
         const 0;
 },
 sat_s1ypL_entry() //  [R1, R2]
         { info_tbl: [(c1ySM,
                       label: sat_s1ypL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ySM: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMin_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1ySU,
                       label: sat_s1ypK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ySU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypJ_entry() //  [R1]
         { info_tbl: [(c1yT1,
                       label: sat_s1ypJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yT1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1yT2; else goto c1yT3;
       c1yT2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yT3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMin_entry() //  [R2]
         { info_tbl: [(c1yT5,
                       label: Data.Functor.Utils.$fMonoidMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yT5: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1yT9; else goto c1yT8;
       c1yT9: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1yT8: // global
           I64[Hp - 88] = sat_s1ypL_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1ypK_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ypJ_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.172701221 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL2_closure" {
     Data.Functor.Utils.$fFunctorStateL2_closure:
         const Data.Functor.Utils.$fFunctorStateL2_info;
 },
 sat_s1ypY_entry() //  [R1]
         { info_tbl: [(c1yTk,
                       label: sat_s1ypY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yTk: // global
           _s1ypY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yTl; else goto c1yTm;
       c1yTm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yTo; else goto c1yTn;
       c1yTo: // global
           HpAlloc = 24;
           goto c1yTl;
       c1yTl: // global
           R1 = _s1ypY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yTn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ypY::P64;
           _s1ypM::P64 = P64[_s1ypY::P64 + 16];
           _s1ypP::P64 = P64[_s1ypY::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1ypP::P64;
           R2 = Hp - 16;
           R1 = _s1ypM::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yTr,
                       label: Data.Functor.Utils.$fFunctorStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yTr: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yTv; else goto c1yTu;
       c1yTv: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yTu: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1ypY_info;
           P64[Hp - 56] = R2;
           _c1yTe::P64 = Hp - 104;
           P64[Hp - 48] = _c1yTe::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yTe::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.174449674 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL1_closure" {
     Data.Functor.Utils.$fFunctorStateL1_closure:
         const Data.Functor.Utils.$fFunctorStateL1_info;
 },
 sat_s1yq5_entry() //  [R1]
         { info_tbl: [(c1yTG,
                       label: sat_s1yq5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yTG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yTH; else goto c1yTI;
       c1yTH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yTI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yTE_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yTE() //  [R1]
         { info_tbl: [(c1yTE,
                       label: block_c1yTE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yTE: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yTN,
                       label: Data.Functor.Utils.$fFunctorStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yTN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1yTR; else goto c1yTQ;
       c1yTR: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yTQ: // global
           I64[Hp - 48] = sat_s1yq5_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.17568732 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL_closure" {
     Data.Functor.Utils.$fFunctorStateL_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateL2_closure+3;
         const Data.Functor.Utils.$fFunctorStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.176878972 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL3_closure" {
     Data.Functor.Utils.$fApplicativeStateL3_closure:
         const Data.Functor.Utils.$fApplicativeStateL3_info;
 },
 ds1_s1yqb_entry() //  [R1]
         { info_tbl: [(c1yU2,
                       label: ds1_s1yqb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yU2: // global
           _s1yqb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yU3; else goto c1yU4;
       c1yU4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yU6; else goto c1yU5;
       c1yU6: // global
           HpAlloc = 24;
           goto c1yU3;
       c1yU3: // global
           R1 = _s1yqb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yU5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqb::P64;
           _s1yq8::P64 = P64[_s1yqb::P64 + 16];
           _s1yqa::P64 = P64[_s1yqb::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yqa::P64;
           R2 = Hp - 16;
           R1 = _s1yq8::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1yqs_entry() //  [R1]
         { info_tbl: [(c1yUd,
                       label: sat_s1yqs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yUd: // global
           _s1yqs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yUe; else goto c1yUf;
       c1yUf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1yUh; else goto c1yUg;
       c1yUh: // global
           HpAlloc = 48;
           goto c1yUe;
       c1yUe: // global
           R1 = _s1yqs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yUg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqs::P64;
           _s1yq6::P64 = P64[_s1yqs::P64 + 16];
           _s1yqa::P64 = P64[_s1yqs::P64 + 24];
           _s1yqb::P64 = P64[_s1yqs::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1yqb::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yqa::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1yq6::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1yUk,
                       label: Data.Functor.Utils.$fApplicativeStateL3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yUk: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1yUo; else goto c1yUn;
       c1yUo: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yUn: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1yqb_info;
           P64[Hp - 96] = R4;
           _c1yTW::P64 = Hp - 144;
           P64[Hp - 88] = _c1yTW::P64;
           I64[Hp - 80] = sat_s1yqs_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1yTW::P64;
           _c1yTX::P64 = Hp - 112;
           P64[Hp - 48] = _c1yTX::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yTX::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.179488631 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL4_closure" {
     Data.Functor.Utils.$fApplicativeStateL4_closure:
         const Data.Functor.Utils.$fApplicativeStateL4_info;
 },
 ds1_s1yqx_entry() //  [R1]
         { info_tbl: [(c1yUz,
                       label: ds1_s1yqx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yUz: // global
           _s1yqx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yUA; else goto c1yUB;
       c1yUB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yUD; else goto c1yUC;
       c1yUD: // global
           HpAlloc = 24;
           goto c1yUA;
       c1yUA: // global
           R1 = _s1yqx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yUC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqx::P64;
           _s1yqu::P64 = P64[_s1yqx::P64 + 16];
           _s1yqw::P64 = P64[_s1yqx::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yqw::P64;
           R2 = Hp - 16;
           R1 = _s1yqu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1yqN_entry() //  [R1]
         { info_tbl: [(c1yUL,
                       label: sat_s1yqN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yUL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1yUP; else goto c1yUQ;
       c1yUP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yUQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1yUI_info;
           _s1yqx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s1yqx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yUU; else goto c1yUJ;
       u1yUU: // global
           call _c1yUI(R1) args: 0, res: 0, upd: 0;
       c1yUJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yUI() //  [R1]
         { info_tbl: [(c1yUI,
                       label: block_c1yUI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yUI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yUT; else goto c1yUS;
       c1yUT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1yUS: // global
           _s1yqI::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1yqI::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yUX,
                       label: Data.Functor.Utils.$fApplicativeStateL4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yUX: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1yV1; else goto c1yV0;
       c1yV1: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yV0: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1yqx_info;
           P64[Hp - 88] = R3;
           _c1yUt::P64 = Hp - 136;
           P64[Hp - 80] = _c1yUt::P64;
           I64[Hp - 72] = sat_s1yqN_info;
           P64[Hp - 56] = _c1yUt::P64;
           _c1yUu::P64 = Hp - 104;
           P64[Hp - 48] = _c1yUu::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yUu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.181516208 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL5_closure" {
     Data.Functor.Utils.$fApplicativeStateL5_closure:
         const Data.Functor.Utils.$fApplicativeStateL5_info;
 },
 Data.Functor.Utils.$fApplicativeStateL5_entry() //  [R2, R3]
         { info_tbl: [(c1yV7,
                       label: Data.Functor.Utils.$fApplicativeStateL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yV7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yVb; else goto c1yVa;
       c1yVb: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yVa: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.182888143 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL2_closure" {
     Data.Functor.Utils.$fApplicativeStateL2_closure:
         const Data.Functor.Utils.$fApplicativeStateL2_info;
 },
 sat_s1yqX_entry() //  [R1]
         { info_tbl: [(c1yVq,
                       label: sat_s1yqX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yVq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yVr; else goto c1yVs;
       c1yVr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yVs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yVo_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yVo() //  [R1]
         { info_tbl: [(c1yVo,
                       label: block_c1yVo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yVo: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1yqT_entry() //  [R1]
         { info_tbl: [(c1yVw,
                       label: ds_s1yqT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yVw: // global
           _s1yqT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yVx; else goto c1yVy;
       c1yVy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1yVA; else goto c1yVz;
       c1yVA: // global
           HpAlloc = 32;
           goto c1yVx;
       c1yVx: // global
           R1 = _s1yqT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yVz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqT::P64;
           _s1yqQ::P64 = P64[_s1yqT::P64 + 16];
           _s1yqR::P64 = P64[_s1yqT::P64 + 24];
           _s1yqS::P64 = P64[_s1yqT::P64 + 32];
           I64[Hp - 24] = sat_s1yqX_info;
           P64[Hp - 8] = _s1yqQ::P64;
           P64[Hp] = _s1yqS::P64;
           R2 = Hp - 24;
           R1 = _s1yqR::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yVE,
                       label: Data.Functor.Utils.$fApplicativeStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yVE: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yVI; else goto c1yVH;
       c1yVI: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yVH: // global
           I64[Hp - 104] = ds_s1yqT_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1yVg::P64 = Hp - 104;
           P64[Hp - 48] = _c1yVg::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yVg::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.185117942 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL1_closure" {
     Data.Functor.Utils.$fApplicativeStateL1_closure:
         const Data.Functor.Utils.$fApplicativeStateL1_info;
 },
 sat_s1yrh_entry() //  [R1]
         { info_tbl: [(c1yVW,
                       label: sat_s1yrh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yVW: // global
           _s1yrh::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1yVX; else goto c1yVY;
       c1yVY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yW0; else goto c1yVZ;
       c1yW0: // global
           HpAlloc = 24;
           goto c1yVX;
       c1yVX: // global
           R1 = _s1yrh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yVZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yrh::P64;
           _s1yr7::P64 = P64[_s1yrh::P64 + 16];
           _s1yr9::P64 = P64[_s1yrh::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yr9::P64;
           I64[Sp - 24] = block_c1yVU_info;
           R2 = Hp - 16;
           R1 = _s1yr7::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yVU() //  [R1]
         { info_tbl: [(c1yVU,
                       label: block_c1yVU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yVU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yW5,
                       label: Data.Functor.Utils.$fApplicativeStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yW5: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yW9; else goto c1yW8;
       c1yW9: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yW8: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1yVN::P64 = Hp - 104;
           P64[Hp - 56] = _c1yVN::P64;
           I64[Hp - 48] = sat_s1yrh_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _c1yVN::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.18657272 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL_closure" {
     Data.Functor.Utils.$fApplicativeStateL_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateL_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateL4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateL2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.187551 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR2_closure" {
     Data.Functor.Utils.$fFunctorStateR2_closure:
         const Data.Functor.Utils.$fFunctorStateR2_info;
 },
 sat_s1yry_entry() //  [R1]
         { info_tbl: [(c1yWk,
                       label: sat_s1yry_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yWk: // global
           _s1yry::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yWl; else goto c1yWm;
       c1yWm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yWo; else goto c1yWn;
       c1yWo: // global
           HpAlloc = 24;
           goto c1yWl;
       c1yWl: // global
           R1 = _s1yry::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yWn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yry::P64;
           _s1yrm::P64 = P64[_s1yry::P64 + 16];
           _s1yrp::P64 = P64[_s1yry::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yrp::P64;
           R2 = Hp - 16;
           R1 = _s1yrm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yWr,
                       label: Data.Functor.Utils.$fFunctorStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yWr: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yWv; else goto c1yWu;
       c1yWv: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yWu: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1yry_info;
           P64[Hp - 56] = R2;
           _c1yWe::P64 = Hp - 104;
           P64[Hp - 48] = _c1yWe::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yWe::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.189168072 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR1_closure" {
     Data.Functor.Utils.$fFunctorStateR1_closure:
         const Data.Functor.Utils.$fFunctorStateR1_info;
 },
 sat_s1yrF_entry() //  [R1]
         { info_tbl: [(c1yWG,
                       label: sat_s1yrF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yWG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yWH; else goto c1yWI;
       c1yWH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yWI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yWE_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yWE() //  [R1]
         { info_tbl: [(c1yWE,
                       label: block_c1yWE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yWE: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yWN,
                       label: Data.Functor.Utils.$fFunctorStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yWN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1yWR; else goto c1yWQ;
       c1yWR: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yWQ: // global
           I64[Hp - 48] = sat_s1yrF_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.190756145 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR_closure" {
     Data.Functor.Utils.$fFunctorStateR_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateR2_closure+3;
         const Data.Functor.Utils.$fFunctorStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.192423069 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR3_closure" {
     Data.Functor.Utils.$fApplicativeStateR3_closure:
         const Data.Functor.Utils.$fApplicativeStateR3_info;
 },
 ds1_s1yrL_entry() //  [R1]
         { info_tbl: [(c1yX2,
                       label: ds1_s1yrL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yX2: // global
           _s1yrL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yX3; else goto c1yX4;
       c1yX4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yX6; else goto c1yX5;
       c1yX6: // global
           HpAlloc = 24;
           goto c1yX3;
       c1yX3: // global
           R1 = _s1yrL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yX5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yrL::P64;
           _s1yrH::P64 = P64[_s1yrL::P64 + 16];
           _s1yrK::P64 = P64[_s1yrL::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yrK::P64;
           R2 = Hp - 16;
           R1 = _s1yrH::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ys2_entry() //  [R1]
         { info_tbl: [(c1yXd,
                       label: sat_s1ys2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yXd: // global
           _s1ys2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yXe; else goto c1yXf;
       c1yXf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1yXh; else goto c1yXg;
       c1yXh: // global
           HpAlloc = 48;
           goto c1yXe;
       c1yXe: // global
           R1 = _s1ys2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yXg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ys2::P64;
           _s1yrG::P64 = P64[_s1ys2::P64 + 16];
           _s1yrK::P64 = P64[_s1ys2::P64 + 24];
           _s1yrL::P64 = P64[_s1ys2::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1yrK::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yrL::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1yrG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1yXk,
                       label: Data.Functor.Utils.$fApplicativeStateR3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yXk: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1yXo; else goto c1yXn;
       c1yXo: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yXn: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R4;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1yrL_info;
           P64[Hp - 96] = R3;
           _c1yWW::P64 = Hp - 144;
           P64[Hp - 88] = _c1yWW::P64;
           I64[Hp - 80] = sat_s1ys2_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1yWW::P64;
           _c1yWX::P64 = Hp - 112;
           P64[Hp - 48] = _c1yWX::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yWX::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.195606055 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR4_closure" {
     Data.Functor.Utils.$fApplicativeStateR4_closure:
         const Data.Functor.Utils.$fApplicativeStateR4_info;
 },
 ds1_s1ys7_entry() //  [R1]
         { info_tbl: [(c1yXz,
                       label: ds1_s1ys7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yXz: // global
           _s1ys7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yXA; else goto c1yXB;
       c1yXB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yXD; else goto c1yXC;
       c1yXD: // global
           HpAlloc = 24;
           goto c1yXA;
       c1yXA: // global
           R1 = _s1ys7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yXC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ys7::P64;
           _s1ys3::P64 = P64[_s1ys7::P64 + 16];
           _s1ys6::P64 = P64[_s1ys7::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ys6::P64;
           R2 = Hp - 16;
           R1 = _s1ys3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ysn_entry() //  [R1]
         { info_tbl: [(c1yXL,
                       label: sat_s1ysn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yXL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1yXP; else goto c1yXQ;
       c1yXP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yXQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1yXI_info;
           _s1ys6::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1ys6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1yXU; else goto c1yXJ;
       u1yXU: // global
           call _c1yXI(R1) args: 0, res: 0, upd: 0;
       c1yXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yXI() //  [R1]
         { info_tbl: [(c1yXI,
                       label: block_c1yXI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yXI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yXT; else goto c1yXS;
       c1yXT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1yXS: // global
           _s1ysi::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1ysi::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yXX,
                       label: Data.Functor.Utils.$fApplicativeStateR4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yXX: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1yY1; else goto c1yY0;
       c1yY1: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yY0: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1ys7_info;
           P64[Hp - 88] = R2;
           _c1yXt::P64 = Hp - 136;
           P64[Hp - 80] = _c1yXt::P64;
           I64[Hp - 72] = sat_s1ysn_info;
           P64[Hp - 56] = _c1yXt::P64;
           _c1yXu::P64 = Hp - 104;
           P64[Hp - 48] = _c1yXu::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yXu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.198532967 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR2_closure" {
     Data.Functor.Utils.$fApplicativeStateR2_closure:
         const Data.Functor.Utils.$fApplicativeStateR2_info;
 },
 sat_s1ysz_entry() //  [R1]
         { info_tbl: [(c1yYf,
                       label: sat_s1ysz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYf: // global
           _s1ysz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1yYg; else goto c1yYh;
       c1yYh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1yYj; else goto c1yYi;
       c1yYj: // global
           HpAlloc = 24;
           goto c1yYg;
       c1yYg: // global
           R1 = _s1ysz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ysz::P64;
           _s1yso::P64 = P64[_s1ysz::P64 + 16];
           _s1ysr::P64 = P64[_s1ysz::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ysr::P64;
           I64[Sp - 24] = block_c1yYd_info;
           R2 = Hp - 16;
           R1 = _s1yso::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yYd() //  [R1]
         { info_tbl: [(c1yYd,
                       label: block_c1yYd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYd: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yYo,
                       label: Data.Functor.Utils.$fApplicativeStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYo: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yYs; else goto c1yYr;
       c1yYs: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yYr: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1yY6::P64 = Hp - 104;
           P64[Hp - 56] = _c1yY6::P64;
           I64[Hp - 48] = sat_s1ysz_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _c1yY6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.201449395 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR1_closure" {
     Data.Functor.Utils.$fApplicativeStateR1_closure:
         const Data.Functor.Utils.$fApplicativeStateR1_info;
 },
 sat_s1ysL_entry() //  [R1]
         { info_tbl: [(c1yYH,
                       label: sat_s1ysL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1yYI; else goto c1yYJ;
       c1yYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1yYF_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1yYF() //  [R1]
         { info_tbl: [(c1yYF,
                       label: block_c1yYF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds2_s1ysH_entry() //  [R1]
         { info_tbl: [(c1yYN,
                       label: ds2_s1ysH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYN: // global
           _s1ysH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1yYO; else goto c1yYP;
       c1yYP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1yYR; else goto c1yYQ;
       c1yYR: // global
           HpAlloc = 32;
           goto c1yYO;
       c1yYO: // global
           R1 = _s1ysH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1yYQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ysH::P64;
           _s1ysE::P64 = P64[_s1ysH::P64 + 16];
           _s1ysF::P64 = P64[_s1ysH::P64 + 24];
           _s1ysG::P64 = P64[_s1ysH::P64 + 32];
           I64[Hp - 24] = sat_s1ysL_info;
           P64[Hp - 8] = _s1ysF::P64;
           P64[Hp] = _s1ysG::P64;
           R2 = Hp - 24;
           R1 = _s1ysE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1yYV,
                       label: Data.Functor.Utils.$fApplicativeStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yYV: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1yYZ; else goto c1yYY;
       c1yYZ: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1yYY: // global
           I64[Hp - 104] = ds2_s1ysH_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1yYx::P64 = Hp - 104;
           P64[Hp - 48] = _c1yYx::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1yYx::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.204127719 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR_closure" {
     Data.Functor.Utils.$fApplicativeStateR_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateR_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateR4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateR2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.2068114 UTC

[section ""data" . Data.Functor.Utils.getMax1_closure" {
     Data.Functor.Utils.getMax1_closure:
         const Data.Functor.Utils.getMax1_info;
 },
 Data.Functor.Utils.getMax1_entry() //  [R2]
         { info_tbl: [(c1yZ4,
                       label: Data.Functor.Utils.getMax1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZ4: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.207742175 UTC

[section ""data" . Data.Functor.Utils.getMax_closure" {
     Data.Functor.Utils.getMax_closure:
         const Data.Functor.Utils.getMax_info;
 },
 Data.Functor.Utils.getMax_entry() //  [R2]
         { info_tbl: [(c1yZb,
                       label: Data.Functor.Utils.getMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZb: // global
           R2 = R2;
           call Data.Functor.Utils.getMax1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.208752687 UTC

[section ""data" . Data.Functor.Utils.getMin1_closure" {
     Data.Functor.Utils.getMin1_closure:
         const Data.Functor.Utils.getMin1_info;
 },
 Data.Functor.Utils.getMin1_entry() //  [R2]
         { info_tbl: [(c1yZi,
                       label: Data.Functor.Utils.getMin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZi: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.209959772 UTC

[section ""data" . Data.Functor.Utils.getMin_closure" {
     Data.Functor.Utils.getMin_closure:
         const Data.Functor.Utils.getMin_info;
 },
 Data.Functor.Utils.getMin_entry() //  [R2]
         { info_tbl: [(c1yZp,
                       label: Data.Functor.Utils.getMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZp: // global
           R2 = R2;
           call Data.Functor.Utils.getMin1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.210892622 UTC

[section ""data" . Data.Functor.Utils.runStateL1_closure" {
     Data.Functor.Utils.runStateL1_closure:
         const Data.Functor.Utils.runStateL1_info;
 },
 Data.Functor.Utils.runStateL1_entry() //  [R2]
         { info_tbl: [(c1yZw,
                       label: Data.Functor.Utils.runStateL1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZw: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.211899058 UTC

[section ""data" . Data.Functor.Utils.runStateL_closure" {
     Data.Functor.Utils.runStateL_closure:
         const Data.Functor.Utils.runStateL_info;
 },
 Data.Functor.Utils.runStateL_entry() //  [R2]
         { info_tbl: [(c1yZD,
                       label: Data.Functor.Utils.runStateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZD: // global
           R2 = R2;
           call Data.Functor.Utils.runStateL1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.212939645 UTC

[section ""data" . Data.Functor.Utils.runStateR1_closure" {
     Data.Functor.Utils.runStateR1_closure:
         const Data.Functor.Utils.runStateR1_info;
 },
 Data.Functor.Utils.runStateR1_entry() //  [R2]
         { info_tbl: [(c1yZK,
                       label: Data.Functor.Utils.runStateR1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.214024709 UTC

[section ""data" . Data.Functor.Utils.runStateR_closure" {
     Data.Functor.Utils.runStateR_closure:
         const Data.Functor.Utils.runStateR_info;
 },
 Data.Functor.Utils.runStateR_entry() //  [R2]
         { info_tbl: [(c1yZR,
                       label: Data.Functor.Utils.runStateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZR: // global
           R2 = R2;
           call Data.Functor.Utils.runStateR1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.21508474 UTC

[section ""data" . Data.Functor.Utils.#._closure" {
     Data.Functor.Utils.#._closure:
         const Data.Functor.Utils.#._info;
 },
 Data.Functor.Utils.#._entry() //  [R2, R3, R4]
         { info_tbl: [(c1z00,
                       label: Data.Functor.Utils.#._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z00: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1z01; else goto c1z02;
       c1z01: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.#._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z02: // global
           I64[Sp - 16] = block_c1yZY_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1yZY() //  []
         { info_tbl: [(c1yZY,
                       label: block_c1yZY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1yZY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.216305808 UTC

[section ""cstring" . Data.Functor.Utils.$trModule4_bytes" {
     Data.Functor.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.217083559 UTC

[section ""data" . Data.Functor.Utils.$trModule3_closure" {
     Data.Functor.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.217728675 UTC

[section ""cstring" . Data.Functor.Utils.$trModule2_bytes" {
     Data.Functor.Utils.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.218517032 UTC

[section ""data" . Data.Functor.Utils.$trModule1_closure" {
     Data.Functor.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.219282904 UTC

[section ""data" . Data.Functor.Utils.$trModule_closure" {
     Data.Functor.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Utils.$trModule3_closure+1;
         const Data.Functor.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.219975219 UTC

[section ""data" . $krep_r1ynX_closure" {
     $krep_r1ynX_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.220606022 UTC

[section ""data" . $krep1_r1ynY_closure" {
     $krep1_r1ynY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.221399906 UTC

[section ""data" . $krep2_r1ynZ_closure" {
     $krep2_r1ynZ_closure:
         const :_con_info;
         const $krep_r1ynX_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.222032578 UTC

[section ""data" . $krep3_r1yo0_closure" {
     $krep3_r1yo0_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep2_r1ynZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.222707168 UTC

[section ""data" . $krep4_r1yo1_closure" {
     $krep4_r1yo1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.223354319 UTC

[section ""data" . $krep5_r1yo2_closure" {
     $krep5_r1yo2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep4_r1yo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.224037074 UTC

[section ""data" . $krep6_r1yo3_closure" {
     $krep6_r1yo3_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.224750351 UTC

[section ""data" . $krep7_r1yo4_closure" {
     $krep7_r1yo4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.225582487 UTC

[section ""cstring" . Data.Functor.Utils.$tcMax2_bytes" {
     Data.Functor.Utils.$tcMax2_bytes:
         I8[] [77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.226309203 UTC

[section ""data" . Data.Functor.Utils.$tcMax1_closure" {
     Data.Functor.Utils.$tcMax1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMax2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.227042307 UTC

[section ""data" . Data.Functor.Utils.$tcMax_closure" {
     Data.Functor.Utils.$tcMax_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMax1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17055998897267803697;
         const 13070619747111935994;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.227900089 UTC

[section ""data" . $krep8_r1yo5_closure" {
     $krep8_r1yo5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMax_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.228700909 UTC

[section ""data" . Data.Functor.Utils.$tc'Max1_closure" {
     Data.Functor.Utils.$tc'Max1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep8_r1yo5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.229484679 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Max3_bytes" {
     Data.Functor.Utils.$tc'Max3_bytes:
         I8[] [39,77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.23025218 UTC

[section ""data" . Data.Functor.Utils.$tc'Max2_closure" {
     Data.Functor.Utils.$tc'Max2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Max3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.231087699 UTC

[section ""data" . Data.Functor.Utils.$tc'Max_closure" {
     Data.Functor.Utils.$tc'Max_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Max2_closure+1;
         const Data.Functor.Utils.$tc'Max1_closure+4;
         const 16178335003924091205;
         const 10384293407056089504;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.231865854 UTC

[section ""cstring" . Data.Functor.Utils.$tcMin2_bytes" {
     Data.Functor.Utils.$tcMin2_bytes:
         I8[] [77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.232594918 UTC

[section ""data" . Data.Functor.Utils.$tcMin1_closure" {
     Data.Functor.Utils.$tcMin1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMin2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.233479852 UTC

[section ""data" . Data.Functor.Utils.$tcMin_closure" {
     Data.Functor.Utils.$tcMin_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMin1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13719831963261617173;
         const 12509304105097421826;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.234323517 UTC

[section ""data" . $krep9_r1yo6_closure" {
     $krep9_r1yo6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMin_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.235074441 UTC

[section ""data" . Data.Functor.Utils.$tc'Min1_closure" {
     Data.Functor.Utils.$tc'Min1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep9_r1yo6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.235780845 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Min3_bytes" {
     Data.Functor.Utils.$tc'Min3_bytes:
         I8[] [39,77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.236364953 UTC

[section ""data" . Data.Functor.Utils.$tc'Min2_closure" {
     Data.Functor.Utils.$tc'Min2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Min3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.237092678 UTC

[section ""data" . Data.Functor.Utils.$tc'Min_closure" {
     Data.Functor.Utils.$tc'Min_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Min2_closure+1;
         const Data.Functor.Utils.$tc'Min1_closure+4;
         const 3497961960072019520;
         const 14191657227527039212;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.237924615 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateL2_bytes" {
     Data.Functor.Utils.$tcStateL2_bytes:
         I8[] [83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.238626712 UTC

[section ""data" . Data.Functor.Utils.$tcStateL1_closure" {
     Data.Functor.Utils.$tcStateL1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateL2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.239275171 UTC

[section ""data" . Data.Functor.Utils.$tcStateL_closure" {
     Data.Functor.Utils.$tcStateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateL1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 8498227433031831307;
         const 6442648285908986693;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.240033294 UTC

[section ""data" . $krep10_r1yo7_closure" {
     $krep10_r1yo7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateL_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.241975405 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL1_closure" {
     Data.Functor.Utils.$tc'StateL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep10_r1yo7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.242865653 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateL3_bytes" {
     Data.Functor.Utils.$tc'StateL3_bytes:
         I8[] [39,83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.243597693 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL2_closure" {
     Data.Functor.Utils.$tc'StateL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.244317427 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL_closure" {
     Data.Functor.Utils.$tc'StateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateL2_closure+1;
         const Data.Functor.Utils.$tc'StateL1_closure+4;
         const 8965240648136302046;
         const 8498113279827793106;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.245105049 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateR2_bytes" {
     Data.Functor.Utils.$tcStateR2_bytes:
         I8[] [83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.245878175 UTC

[section ""data" . Data.Functor.Utils.$tcStateR1_closure" {
     Data.Functor.Utils.$tcStateR1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateR2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.246657216 UTC

[section ""data" . Data.Functor.Utils.$tcStateR_closure" {
     Data.Functor.Utils.$tcStateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateR1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 10049146831422350196;
         const 16883721947448934294;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.247406745 UTC

[section ""data" . $krep11_r1yo8_closure" {
     $krep11_r1yo8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateR_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.248149965 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR1_closure" {
     Data.Functor.Utils.$tc'StateR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep11_r1yo8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.248861157 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateR3_bytes" {
     Data.Functor.Utils.$tc'StateR3_bytes:
         I8[] [39,83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.250242519 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR2_closure" {
     Data.Functor.Utils.$tc'StateR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.251018009 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR_closure" {
     Data.Functor.Utils.$tc'StateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateR2_closure+1;
         const Data.Functor.Utils.$tc'StateR1_closure+4;
         const 13798701525568783897;
         const 17913645303573466967;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.251730658 UTC

[section ""relreadonly" . S1yw7_srt" {
     S1yw7_srt:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMax_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMin_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.252746264 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:20.255083884 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMax_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMax_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMax_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1z0f,
                       label: Data.Functor.Utils.$fMonoidMax_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z0f: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1z0g; else goto c1z0h;
       c1z0g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z0h: // global
           I64[Sp - 24] = block_c1z08_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1z0Q; else goto c1z09;
       u1z0Q: // global
           call _c1z08(R1) args: 0, res: 0, upd: 0;
       c1z09: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z08() //  [R1]
         { info_tbl: [(c1z08,
                       label: block_c1z08_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z08: // global
           _s1yob::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1z0c; else goto c1z0d;
       c1z0c: // global
           R1 = _s1yob::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1z0d: // global
           I64[Sp - 8] = block_c1z0n_info;
           _s1yod::P64 = R1;
           _s1yoe::P64 = P64[R1 + 6];
           R1 = _s1yob::P64;
           P64[Sp] = _s1yoe::P64;
           P64[Sp + 16] = _s1yod::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1z0P; else goto c1z0p;
       u1z0P: // global
           call _c1z0n(R1) args: 0, res: 0, upd: 0;
       c1z0p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z0n() //  [R1]
         { info_tbl: [(c1z0n,
                       label: block_c1z0n_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z0n: // global
           if (R1 & 7 == 1) goto u1z0N; else goto c1z0A;
       u1z0N: // global
           Sp = Sp + 24;
           call _c1z0G() args: 0, res: 0, upd: 0;
       c1z0A: // global
           _s1yoe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1z0y_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yoe::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1z0y() //  [R1]
         { info_tbl: [(c1z0y,
                       label: block_c1z0y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z0y: // global
           if (R1 & 7 == 1) goto u1z0O; else goto c1z0K;
       u1z0O: // global
           Sp = Sp + 16;
           call _c1z0G() args: 0, res: 0, upd: 0;
       c1z0K: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z0G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z0G: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.268126144 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat_closure" {
     Data.Functor.Utils.$w$csconcat_closure:
         const Data.Functor.Utils.$w$csconcat_info;
 },
 go_s1yol_entry() //  [R1, R2, R3]
         { info_tbl: [(c1z1E,
                       label: go_s1yol_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z1E: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1z1F; else goto c1z1G;
       c1z1F: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z1G: // global
           I64[Sp - 32] = block_c1z1x_info;
           _s1yol::P64 = R1;
           _s1yoi::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1yoi::P64;
           P64[Sp - 16] = _s1yol::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1z2t; else goto c1z1y;
       u1z2t: // global
           call _c1z1x(R1) args: 0, res: 0, upd: 0;
       c1z1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z1x() //  [R1]
         { info_tbl: [(c1z1x,
                       label: block_c1z1x_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z1x: // global
           if (R1 & 7 == 1) goto u1z2o; else goto c1z1C;
       u1z2o: // global
           Sp = Sp + 24;
           call _c1z1T() args: 0, res: 0, upd: 0;
       c1z1C: // global
           I64[Sp] = block_c1z1M_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1yol_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z1M() //  [R1]
         { info_tbl: [(c1z1M,
                       label: block_c1z1M_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z1M: // global
           if (R1 & 7 == 1) goto u1z2p; else goto c1z1Y;
       u1z2p: // global
           Sp = Sp + 24;
           call _c1z1T() args: 0, res: 0, upd: 0;
       c1z1Y: // global
           I64[Sp] = block_c1z1W_info;
           _s1yor::P64 = R1;
           _s1yos::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1yos::P64;
           P64[Sp + 24] = _s1yor::P64;
           if (R1 & 7 != 0) goto u1z2u; else goto c1z1Z;
       u1z2u: // global
           call _c1z1W(R1) args: 0, res: 0, upd: 0;
       c1z1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z1T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z1T: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z1W() //  [R1]
         { info_tbl: [(c1z1W,
                       label: block_c1z1W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z1W: // global
           if (R1 & 7 == 1) goto u1z2q; else goto c1z2a;
       u1z2q: // global
           Sp = Sp + 24;
           call _c1z2g() args: 0, res: 0, upd: 0;
       c1z2a: // global
           _s1yoi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1z28_info;
           R2 = _s1yoi::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1z28() //  [R1]
         { info_tbl: [(c1z28,
                       label: block_c1z28_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z28: // global
           if (R1 & 7 == 1) goto u1z2r; else goto c1z2k;
       u1z2r: // global
           Sp = Sp + 16;
           call _c1z2g() args: 0, res: 0, upd: 0;
       c1z2k: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z2g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z2g: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c1z2y,
                       label: Data.Functor.Utils.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z2y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1z2C; else goto c1z2B;
       c1z2C: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z2B: // global
           I64[Hp - 8] = go_s1yol_info;
           P64[Hp] = R2;
           _s1yoj::P64 = R3;
           R3 = R4;
           R2 = _s1yoj::P64;
           R1 = Hp - 6;
           call go_s1yol_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.284429089 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMax_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMax_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMax_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1z3q,
                       label: Data.Functor.Utils.$fSemigroupMax_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z3q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1z3r; else goto c1z3s;
       c1z3r: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z3s: // global
           I64[Sp - 16] = block_c1z3n_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1z3w; else goto c1z3o;
       u1z3w: // global
           call _c1z3n(R1) args: 0, res: 0, upd: 0;
       c1z3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z3n() //  [R1]
         { info_tbl: [(c1z3n,
                       label: block_c1z3n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z3n: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.290658709 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_closure" {
     Data.Functor.Utils.$fSemigroupMax_closure:
         const Data.Functor.Utils.$fSemigroupMax_info;
         const 0;
 },
 sat_s1yoE_entry() //  [R1, R2]
         { info_tbl: [(c1z3P,
                       label: sat_s1yoE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z3P: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoD_entry() //  [R1, R2]
         { info_tbl: [(c1z3X,
                       label: sat_s1yoD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z3X: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoC_entry() //  [R1, R2, R3]
         { info_tbl: [(c1z45,
                       label: sat_s1yoC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z45: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_entry() //  [R2]
         { info_tbl: [(c1z49,
                       label: Data.Functor.Utils.$fSemigroupMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z49: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1z4d; else goto c1z4c;
       c1z4d: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1z4c: // global
           I64[Hp - 72] = sat_s1yoE_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1yoD_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1yoC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMax_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMax_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_info;
         const 0;
 },
 sat_s1yoH_entry() //  [R1]
         { info_tbl: [(c1z4m,
                       label: sat_s1yoH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z4m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1z4n; else goto c1z4o;
       c1z4n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1z4o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1z4p,
                       label: Data.Functor.Utils.$fSemigroupMax_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z4p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1z4t; else goto c1z4s;
       c1z4t: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z4s: // global
           I64[Hp - 16] = sat_s1yoH_info;
           P64[Hp] = R2;
           _s1yoG::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1yoG::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.306006157 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMax_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMax_$cmconcat_info;
 },
 go_s1yoK_entry() //  [R1, R2]
         { info_tbl: [(c1z59,
                       label: go_s1yoK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z59: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1z5a; else goto c1z5b;
       c1z5a: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1z5b: // global
           I64[Sp - 24] = block_c1z52_info;
           _s1yoK::P64 = R1;
           _s1yoI::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1yoI::P64;
           P64[Sp - 8] = _s1yoK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1z5V; else goto c1z53;
       u1z5V: // global
           call _c1z52(R1) args: 0, res: 0, upd: 0;
       c1z53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z52() //  [R1]
         { info_tbl: [(c1z52,
                       label: block_c1z52_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z52: // global
           if (R1 & 7 == 1) goto c1z56; else goto c1z57;
       c1z56: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1z57: // global
           I64[Sp] = block_c1z5h_info;
           R2 = P64[R1 + 14];
           _s1yoN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1yoN::P64;
           call go_s1yoK_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z5h() //  [R1]
         { info_tbl: [(c1z5h,
                       label: block_c1z5h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z5h: // global
           _s1yoN::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1z5o; else goto c1z5t;
       c1z5o: // global
           R1 = _s1yoN::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1z5t: // global
           I64[Sp - 8] = block_c1z5r_info;
           _s1yoP::P64 = R1;
           _s1yoQ::P64 = P64[R1 + 6];
           R1 = _s1yoN::P64;
           P64[Sp] = _s1yoQ::P64;
           P64[Sp + 16] = _s1yoP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1z5W; else goto c1z5u;
       u1z5W: // global
           call _c1z5r(R1) args: 0, res: 0, upd: 0;
       c1z5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z5r() //  [R1]
         { info_tbl: [(c1z5r,
                       label: block_c1z5r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z5r: // global
           if (R1 & 7 == 1) goto u1z5T; else goto c1z5F;
       u1z5T: // global
           Sp = Sp + 24;
           call _c1z5L() args: 0, res: 0, upd: 0;
       c1z5F: // global
           _s1yoQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1z5D_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yoQ::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1z5D() //  [R1]
         { info_tbl: [(c1z5D,
                       label: block_c1z5D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z5D: // global
           if (R1 & 7 == 1) goto u1z5U; else goto c1z5P;
       u1z5U: // global
           Sp = Sp + 16;
           call _c1z5L() args: 0, res: 0, upd: 0;
       c1z5P: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z5L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z5L: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMax_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1z5Z,
                       label: Data.Functor.Utils.$fMonoidMax_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z5Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1z63; else goto c1z62;
       c1z63: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z62: // global
           I64[Hp - 8] = go_s1yoK_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1yoK_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.32098916 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_closure" {
     Data.Functor.Utils.$fMonoidMax_closure:
         const Data.Functor.Utils.$fMonoidMax_info;
         const 0;
 },
 sat_s1yoX_entry() //  [R1, R2]
         { info_tbl: [(c1z6R,
                       label: sat_s1yoX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z6R: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMax_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoW_entry() //  [R1, R2, R3]
         { info_tbl: [(c1z6Z,
                       label: sat_s1yoW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z6Z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1yoV_entry() //  [R1]
         { info_tbl: [(c1z76,
                       label: sat_s1yoV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z76: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1z77; else goto c1z78;
       c1z77: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1z78: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMax_entry() //  [R2]
         { info_tbl: [(c1z7a,
                       label: Data.Functor.Utils.$fMonoidMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z7a: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1z7e; else goto c1z7d;
       c1z7e: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1z7d: // global
           I64[Hp - 88] = sat_s1yoX_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1yoW_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1yoV_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.331165853 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMin_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMin_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMin_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1z7I,
                       label: Data.Functor.Utils.$fMonoidMin_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z7I: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1z7J; else goto c1z7K;
       c1z7J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z7K: // global
           I64[Sp - 24] = block_c1z7B_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1z8j; else goto c1z7C;
       u1z8j: // global
           call _c1z7B(R1) args: 0, res: 0, upd: 0;
       c1z7C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z7B() //  [R1]
         { info_tbl: [(c1z7B,
                       label: block_c1z7B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z7B: // global
           _s1yoZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1z7F; else goto c1z7G;
       c1z7F: // global
           R1 = _s1yoZ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1z7G: // global
           I64[Sp - 8] = block_c1z7Q_info;
           _s1yp1::P64 = R1;
           _s1yp2::P64 = P64[R1 + 6];
           R1 = _s1yoZ::P64;
           P64[Sp] = _s1yp2::P64;
           P64[Sp + 16] = _s1yp1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1z8i; else goto c1z7S;
       u1z8i: // global
           call _c1z7Q(R1) args: 0, res: 0, upd: 0;
       c1z7S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z7Q() //  [R1]
         { info_tbl: [(c1z7Q,
                       label: block_c1z7Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z7Q: // global
           if (R1 & 7 == 1) goto u1z8g; else goto c1z83;
       u1z8g: // global
           Sp = Sp + 24;
           call _c1z89() args: 0, res: 0, upd: 0;
       c1z83: // global
           _s1yp2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1z81_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1yp2::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1z81() //  [R1]
         { info_tbl: [(c1z81,
                       label: block_c1z81_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z81: // global
           if (R1 & 7 == 1) goto u1z8h; else goto c1z8d;
       u1z8h: // global
           Sp = Sp + 16;
           call _c1z89() args: 0, res: 0, upd: 0;
       c1z8d: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z89() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z89: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.343362097 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat1_closure" {
     Data.Functor.Utils.$w$csconcat1_closure:
         const Data.Functor.Utils.$w$csconcat1_info;
 },
 go_s1yp9_entry() //  [R1, R2, R3]
         { info_tbl: [(c1z97,
                       label: go_s1yp9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z97: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1z98; else goto c1z99;
       c1z98: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1z99: // global
           I64[Sp - 32] = block_c1z90_info;
           _s1yp9::P64 = R1;
           _s1yp6::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1yp6::P64;
           P64[Sp - 16] = _s1yp9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1z9W; else goto c1z91;
       u1z9W: // global
           call _c1z90(R1) args: 0, res: 0, upd: 0;
       c1z91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z90() //  [R1]
         { info_tbl: [(c1z90,
                       label: block_c1z90_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z90: // global
           if (R1 & 7 == 1) goto u1z9R; else goto c1z95;
       u1z9R: // global
           Sp = Sp + 24;
           call _c1z9m() args: 0, res: 0, upd: 0;
       c1z95: // global
           I64[Sp] = block_c1z9f_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1yp9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z9f() //  [R1]
         { info_tbl: [(c1z9f,
                       label: block_c1z9f_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z9f: // global
           if (R1 & 7 == 1) goto u1z9S; else goto c1z9r;
       u1z9S: // global
           Sp = Sp + 24;
           call _c1z9m() args: 0, res: 0, upd: 0;
       c1z9r: // global
           I64[Sp] = block_c1z9p_info;
           _s1ypf::P64 = R1;
           _s1ypg::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1ypg::P64;
           P64[Sp + 24] = _s1ypf::P64;
           if (R1 & 7 != 0) goto u1z9X; else goto c1z9s;
       u1z9X: // global
           call _c1z9p(R1) args: 0, res: 0, upd: 0;
       c1z9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1z9m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z9m: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z9p() //  [R1]
         { info_tbl: [(c1z9p,
                       label: block_c1z9p_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z9p: // global
           if (R1 & 7 == 1) goto u1z9T; else goto c1z9D;
       u1z9T: // global
           Sp = Sp + 24;
           call _c1z9J() args: 0, res: 0, upd: 0;
       c1z9D: // global
           _s1yp6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1z9B_info;
           R2 = _s1yp6::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1z9B() //  [R1]
         { info_tbl: [(c1z9B,
                       label: block_c1z9B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z9B: // global
           if (R1 & 7 == 1) goto u1z9U; else goto c1z9N;
       u1z9U: // global
           Sp = Sp + 16;
           call _c1z9J() args: 0, res: 0, upd: 0;
       c1z9N: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1z9J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1z9J: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1za1,
                       label: Data.Functor.Utils.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1za1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1za5; else goto c1za4;
       c1za5: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1za4: // global
           I64[Hp - 8] = go_s1yp9_info;
           P64[Hp] = R2;
           _s1yp7::P64 = R3;
           R3 = R4;
           R2 = _s1yp7::P64;
           R1 = Hp - 6;
           call go_s1yp9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.35891127 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMin_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMin_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMin_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1zaT,
                       label: Data.Functor.Utils.$fSemigroupMin_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zaT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zaU; else goto c1zaV;
       c1zaU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zaV: // global
           I64[Sp - 16] = block_c1zaQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1zaZ; else goto c1zaR;
       u1zaZ: // global
           call _c1zaQ(R1) args: 0, res: 0, upd: 0;
       c1zaR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zaQ() //  [R1]
         { info_tbl: [(c1zaQ,
                       label: block_c1zaQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zaQ: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.366318943 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_closure" {
     Data.Functor.Utils.$fSemigroupMin_closure:
         const Data.Functor.Utils.$fSemigroupMin_info;
         const 0;
 },
 sat_s1yps_entry() //  [R1, R2]
         { info_tbl: [(c1zbi,
                       label: sat_s1yps_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zbi: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypr_entry() //  [R1, R2]
         { info_tbl: [(c1zbq,
                       label: sat_s1ypr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zbq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypq_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zby,
                       label: sat_s1ypq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zby: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_entry() //  [R2]
         { info_tbl: [(c1zbC,
                       label: Data.Functor.Utils.$fSemigroupMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zbC: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1zbG; else goto c1zbF;
       c1zbG: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zbF: // global
           I64[Hp - 72] = sat_s1yps_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ypr_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1ypq_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMin_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMin_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_info;
         const 0;
 },
 sat_s1ypv_entry() //  [R1]
         { info_tbl: [(c1zbP,
                       label: sat_s1ypv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zbP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zbQ; else goto c1zbR;
       c1zbQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zbR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1zbS,
                       label: Data.Functor.Utils.$fSemigroupMin_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zbS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zbW; else goto c1zbV;
       c1zbW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zbV: // global
           I64[Hp - 16] = sat_s1ypv_info;
           P64[Hp] = R2;
           _s1ypu::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1ypu::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.381527068 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMin_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMin_$cmconcat_info;
 },
 go_s1ypy_entry() //  [R1, R2]
         { info_tbl: [(c1zcC,
                       label: go_s1ypy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zcC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zcD; else goto c1zcE;
       c1zcD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zcE: // global
           I64[Sp - 24] = block_c1zcv_info;
           _s1ypy::P64 = R1;
           _s1ypw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1ypw::P64;
           P64[Sp - 8] = _s1ypy::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1zdo; else goto c1zcw;
       u1zdo: // global
           call _c1zcv(R1) args: 0, res: 0, upd: 0;
       c1zcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zcv() //  [R1]
         { info_tbl: [(c1zcv,
                       label: block_c1zcv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zcv: // global
           if (R1 & 7 == 1) goto c1zcz; else goto c1zcA;
       c1zcz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1zcA: // global
           I64[Sp] = block_c1zcK_info;
           R2 = P64[R1 + 14];
           _s1ypB::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1ypB::P64;
           call go_s1ypy_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zcK() //  [R1]
         { info_tbl: [(c1zcK,
                       label: block_c1zcK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zcK: // global
           _s1ypB::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1zcR; else goto c1zcW;
       c1zcR: // global
           R1 = _s1ypB::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1zcW: // global
           I64[Sp - 8] = block_c1zcU_info;
           _s1ypD::P64 = R1;
           _s1ypE::P64 = P64[R1 + 6];
           R1 = _s1ypB::P64;
           P64[Sp] = _s1ypE::P64;
           P64[Sp + 16] = _s1ypD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1zdp; else goto c1zcX;
       u1zdp: // global
           call _c1zcU(R1) args: 0, res: 0, upd: 0;
       c1zcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zcU() //  [R1]
         { info_tbl: [(c1zcU,
                       label: block_c1zcU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zcU: // global
           if (R1 & 7 == 1) goto u1zdm; else goto c1zd8;
       u1zdm: // global
           Sp = Sp + 24;
           call _c1zde() args: 0, res: 0, upd: 0;
       c1zd8: // global
           _s1ypE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zd6_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1ypE::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zd6() //  [R1]
         { info_tbl: [(c1zd6,
                       label: block_c1zd6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zd6: // global
           if (R1 & 7 == 1) goto u1zdn; else goto c1zdi;
       u1zdn: // global
           Sp = Sp + 16;
           call _c1zde() args: 0, res: 0, upd: 0;
       c1zdi: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zde() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zde: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMin_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1zds,
                       label: Data.Functor.Utils.$fMonoidMin_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zds: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1zdw; else goto c1zdv;
       c1zdw: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zdv: // global
           I64[Hp - 8] = go_s1ypy_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1ypy_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.397136463 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_closure" {
     Data.Functor.Utils.$fMonoidMin_closure:
         const Data.Functor.Utils.$fMonoidMin_info;
         const 0;
 },
 sat_s1ypL_entry() //  [R1, R2]
         { info_tbl: [(c1zek,
                       label: sat_s1ypL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zek: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMin_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypK_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zes,
                       label: sat_s1ypK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zes: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1ypJ_entry() //  [R1]
         { info_tbl: [(c1zez,
                       label: sat_s1ypJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zez: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zeA; else goto c1zeB;
       c1zeA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zeB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMin_entry() //  [R2]
         { info_tbl: [(c1zeD,
                       label: Data.Functor.Utils.$fMonoidMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zeD: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1zeH; else goto c1zeG;
       c1zeH: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zeG: // global
           I64[Hp - 88] = sat_s1ypL_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1ypK_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1ypJ_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.406635339 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL2_closure" {
     Data.Functor.Utils.$fFunctorStateL2_closure:
         const Data.Functor.Utils.$fFunctorStateL2_info;
 },
 sat_s1ypY_entry() //  [R1]
         { info_tbl: [(c1zfa,
                       label: sat_s1ypY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zfa: // global
           _s1ypY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zfb; else goto c1zfc;
       c1zfc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zfe; else goto c1zfd;
       c1zfe: // global
           HpAlloc = 24;
           goto c1zfb;
       c1zfb: // global
           R1 = _s1ypY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zfd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ypY::P64;
           _s1ypM::P64 = P64[_s1ypY::P64 + 16];
           _s1ypP::P64 = P64[_s1ypY::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1ypP::P64;
           R2 = Hp - 16;
           R1 = _s1ypM::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zfh,
                       label: Data.Functor.Utils.$fFunctorStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zfh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zfl; else goto c1zfk;
       c1zfl: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zfk: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1ypY_info;
           P64[Hp - 56] = R2;
           _c1zf4::P64 = Hp - 104;
           P64[Hp - 48] = _c1zf4::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zf4::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.413701842 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL1_closure" {
     Data.Functor.Utils.$fFunctorStateL1_closure:
         const Data.Functor.Utils.$fFunctorStateL1_info;
 },
 sat_s1yq5_entry() //  [R1]
         { info_tbl: [(c1zfH,
                       label: sat_s1yq5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zfH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zfI; else goto c1zfJ;
       c1zfI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zfJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zfF_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zfF() //  [R1]
         { info_tbl: [(c1zfF,
                       label: block_c1zfF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zfF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zfO,
                       label: Data.Functor.Utils.$fFunctorStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zfO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1zfS; else goto c1zfR;
       c1zfS: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zfR: // global
           I64[Hp - 48] = sat_s1yq5_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.420978513 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL_closure" {
     Data.Functor.Utils.$fFunctorStateL_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateL2_closure+3;
         const Data.Functor.Utils.$fFunctorStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.423569208 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL3_closure" {
     Data.Functor.Utils.$fApplicativeStateL3_closure:
         const Data.Functor.Utils.$fApplicativeStateL3_info;
 },
 ds1_s1yqb_entry() //  [R1]
         { info_tbl: [(c1zgh,
                       label: ds1_s1yqb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zgh: // global
           _s1yqb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zgi; else goto c1zgj;
       c1zgj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zgl; else goto c1zgk;
       c1zgl: // global
           HpAlloc = 24;
           goto c1zgi;
       c1zgi: // global
           R1 = _s1yqb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zgk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqb::P64;
           _s1yq8::P64 = P64[_s1yqb::P64 + 16];
           _s1yqa::P64 = P64[_s1yqb::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yqa::P64;
           R2 = Hp - 16;
           R1 = _s1yq8::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1yqs_entry() //  [R1]
         { info_tbl: [(c1zgs,
                       label: sat_s1yqs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zgs: // global
           _s1yqs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zgt; else goto c1zgu;
       c1zgu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1zgw; else goto c1zgv;
       c1zgw: // global
           HpAlloc = 48;
           goto c1zgt;
       c1zgt: // global
           R1 = _s1yqs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zgv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqs::P64;
           _s1yq6::P64 = P64[_s1yqs::P64 + 16];
           _s1yqa::P64 = P64[_s1yqs::P64 + 24];
           _s1yqb::P64 = P64[_s1yqs::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1yqb::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yqa::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1yq6::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1zgz,
                       label: Data.Functor.Utils.$fApplicativeStateL3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zgz: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1zgD; else goto c1zgC;
       c1zgD: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zgC: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1yqb_info;
           P64[Hp - 96] = R4;
           _c1zgb::P64 = Hp - 144;
           P64[Hp - 88] = _c1zgb::P64;
           I64[Hp - 80] = sat_s1yqs_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1zgb::P64;
           _c1zgc::P64 = Hp - 112;
           P64[Hp - 48] = _c1zgc::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zgc::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.433830342 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL4_closure" {
     Data.Functor.Utils.$fApplicativeStateL4_closure:
         const Data.Functor.Utils.$fApplicativeStateL4_info;
 },
 ds1_s1yqx_entry() //  [R1]
         { info_tbl: [(c1zh3,
                       label: ds1_s1yqx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zh3: // global
           _s1yqx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zh4; else goto c1zh5;
       c1zh5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zh7; else goto c1zh6;
       c1zh7: // global
           HpAlloc = 24;
           goto c1zh4;
       c1zh4: // global
           R1 = _s1yqx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zh6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqx::P64;
           _s1yqu::P64 = P64[_s1yqx::P64 + 16];
           _s1yqw::P64 = P64[_s1yqx::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yqw::P64;
           R2 = Hp - 16;
           R1 = _s1yqu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1yqN_entry() //  [R1]
         { info_tbl: [(c1zhf,
                       label: sat_s1yqN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zhf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1zhj; else goto c1zhk;
       c1zhj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zhk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1zhc_info;
           _s1yqx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s1yqx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1zho; else goto c1zhd;
       u1zho: // global
           call _c1zhc(R1) args: 0, res: 0, upd: 0;
       c1zhd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zhc() //  [R1]
         { info_tbl: [(c1zhc,
                       label: block_c1zhc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zhc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zhn; else goto c1zhm;
       c1zhn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1zhm: // global
           _s1yqI::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1yqI::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zhr,
                       label: Data.Functor.Utils.$fApplicativeStateL4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zhr: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1zhv; else goto c1zhu;
       c1zhv: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zhu: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1yqx_info;
           P64[Hp - 88] = R3;
           _c1zgX::P64 = Hp - 136;
           P64[Hp - 80] = _c1zgX::P64;
           I64[Hp - 72] = sat_s1yqN_info;
           P64[Hp - 56] = _c1zgX::P64;
           _c1zgY::P64 = Hp - 104;
           P64[Hp - 48] = _c1zgY::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zgY::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.446140988 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL5_closure" {
     Data.Functor.Utils.$fApplicativeStateL5_closure:
         const Data.Functor.Utils.$fApplicativeStateL5_info;
 },
 Data.Functor.Utils.$fApplicativeStateL5_entry() //  [R2, R3]
         { info_tbl: [(c1zhV,
                       label: Data.Functor.Utils.$fApplicativeStateL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zhV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zhZ; else goto c1zhY;
       c1zhZ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zhY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.450519076 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL2_closure" {
     Data.Functor.Utils.$fApplicativeStateL2_closure:
         const Data.Functor.Utils.$fApplicativeStateL2_info;
 },
 sat_s1yqX_entry() //  [R1]
         { info_tbl: [(c1zij,
                       label: sat_s1yqX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zij: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zik; else goto c1zil;
       c1zik: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zil: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zih_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zih() //  [R1]
         { info_tbl: [(c1zih,
                       label: block_c1zih_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zih: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1yqT_entry() //  [R1]
         { info_tbl: [(c1zip,
                       label: ds_s1yqT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zip: // global
           _s1yqT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1ziq; else goto c1zir;
       c1zir: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1zit; else goto c1zis;
       c1zit: // global
           HpAlloc = 32;
           goto c1ziq;
       c1ziq: // global
           R1 = _s1yqT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zis: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yqT::P64;
           _s1yqQ::P64 = P64[_s1yqT::P64 + 16];
           _s1yqR::P64 = P64[_s1yqT::P64 + 24];
           _s1yqS::P64 = P64[_s1yqT::P64 + 32];
           I64[Hp - 24] = sat_s1yqX_info;
           P64[Hp - 8] = _s1yqQ::P64;
           P64[Hp] = _s1yqS::P64;
           R2 = Hp - 24;
           R1 = _s1yqR::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zix,
                       label: Data.Functor.Utils.$fApplicativeStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zix: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1ziB; else goto c1ziA;
       c1ziB: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ziA: // global
           I64[Hp - 104] = ds_s1yqT_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1zi9::P64 = Hp - 104;
           P64[Hp - 48] = _c1zi9::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zi9::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.461782826 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL1_closure" {
     Data.Functor.Utils.$fApplicativeStateL1_closure:
         const Data.Functor.Utils.$fApplicativeStateL1_info;
 },
 sat_s1yrh_entry() //  [R1]
         { info_tbl: [(c1zj7,
                       label: sat_s1yrh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zj7: // global
           _s1yrh::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1zj8; else goto c1zj9;
       c1zj9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zjb; else goto c1zja;
       c1zjb: // global
           HpAlloc = 24;
           goto c1zj8;
       c1zj8: // global
           R1 = _s1yrh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zja: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yrh::P64;
           _s1yr7::P64 = P64[_s1yrh::P64 + 16];
           _s1yr9::P64 = P64[_s1yrh::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yr9::P64;
           I64[Sp - 24] = block_c1zj5_info;
           R2 = Hp - 16;
           R1 = _s1yr7::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zj5() //  [R1]
         { info_tbl: [(c1zj5,
                       label: block_c1zj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zj5: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zjg,
                       label: Data.Functor.Utils.$fApplicativeStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zjg: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zjk; else goto c1zjj;
       c1zjk: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zjj: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1ziY::P64 = Hp - 104;
           P64[Hp - 56] = _c1ziY::P64;
           I64[Hp - 48] = sat_s1yrh_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _c1ziY::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.469902273 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL_closure" {
     Data.Functor.Utils.$fApplicativeStateL_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateL_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateL4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateL2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.47222474 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR2_closure" {
     Data.Functor.Utils.$fFunctorStateR2_closure:
         const Data.Functor.Utils.$fFunctorStateR2_info;
 },
 sat_s1yry_entry() //  [R1]
         { info_tbl: [(c1zjK,
                       label: sat_s1yry_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zjK: // global
           _s1yry::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zjL; else goto c1zjM;
       c1zjM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zjO; else goto c1zjN;
       c1zjO: // global
           HpAlloc = 24;
           goto c1zjL;
       c1zjL: // global
           R1 = _s1yry::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zjN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yry::P64;
           _s1yrm::P64 = P64[_s1yry::P64 + 16];
           _s1yrp::P64 = P64[_s1yry::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yrp::P64;
           R2 = Hp - 16;
           R1 = _s1yrm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zjR,
                       label: Data.Functor.Utils.$fFunctorStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zjR: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zjV; else goto c1zjU;
       c1zjV: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zjU: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1yry_info;
           P64[Hp - 56] = R2;
           _c1zjE::P64 = Hp - 104;
           P64[Hp - 48] = _c1zjE::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zjE::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.479308568 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR1_closure" {
     Data.Functor.Utils.$fFunctorStateR1_closure:
         const Data.Functor.Utils.$fFunctorStateR1_info;
 },
 sat_s1yrF_entry() //  [R1]
         { info_tbl: [(c1zkh,
                       label: sat_s1yrF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zkh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zki; else goto c1zkj;
       c1zki: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zkj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zkf_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zkf() //  [R1]
         { info_tbl: [(c1zkf,
                       label: block_c1zkf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zkf: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zko,
                       label: Data.Functor.Utils.$fFunctorStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zko: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1zks; else goto c1zkr;
       c1zks: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zkr: // global
           I64[Hp - 48] = sat_s1yrF_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.48655217 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR_closure" {
     Data.Functor.Utils.$fFunctorStateR_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateR2_closure+3;
         const Data.Functor.Utils.$fFunctorStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.489894526 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR3_closure" {
     Data.Functor.Utils.$fApplicativeStateR3_closure:
         const Data.Functor.Utils.$fApplicativeStateR3_info;
 },
 ds1_s1yrL_entry() //  [R1]
         { info_tbl: [(c1zkR,
                       label: ds1_s1yrL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zkR: // global
           _s1yrL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zkS; else goto c1zkT;
       c1zkT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zkV; else goto c1zkU;
       c1zkV: // global
           HpAlloc = 24;
           goto c1zkS;
       c1zkS: // global
           R1 = _s1yrL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zkU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1yrL::P64;
           _s1yrH::P64 = P64[_s1yrL::P64 + 16];
           _s1yrK::P64 = P64[_s1yrL::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1yrK::P64;
           R2 = Hp - 16;
           R1 = _s1yrH::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ys2_entry() //  [R1]
         { info_tbl: [(c1zl2,
                       label: sat_s1ys2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zl2: // global
           _s1ys2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zl3; else goto c1zl4;
       c1zl4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1zl6; else goto c1zl5;
       c1zl6: // global
           HpAlloc = 48;
           goto c1zl3;
       c1zl3: // global
           R1 = _s1ys2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zl5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ys2::P64;
           _s1yrG::P64 = P64[_s1ys2::P64 + 16];
           _s1yrK::P64 = P64[_s1ys2::P64 + 24];
           _s1yrL::P64 = P64[_s1ys2::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1yrK::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1yrL::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1yrG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1zl9,
                       label: Data.Functor.Utils.$fApplicativeStateR3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zl9: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1zld; else goto c1zlc;
       c1zld: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zlc: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R4;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1yrL_info;
           P64[Hp - 96] = R3;
           _c1zkL::P64 = Hp - 144;
           P64[Hp - 88] = _c1zkL::P64;
           I64[Hp - 80] = sat_s1ys2_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1zkL::P64;
           _c1zkM::P64 = Hp - 112;
           P64[Hp - 48] = _c1zkM::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zkM::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.499564384 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR4_closure" {
     Data.Functor.Utils.$fApplicativeStateR4_closure:
         const Data.Functor.Utils.$fApplicativeStateR4_info;
 },
 ds1_s1ys7_entry() //  [R1]
         { info_tbl: [(c1zlD,
                       label: ds1_s1ys7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zlD: // global
           _s1ys7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zlE; else goto c1zlF;
       c1zlF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zlH; else goto c1zlG;
       c1zlH: // global
           HpAlloc = 24;
           goto c1zlE;
       c1zlE: // global
           R1 = _s1ys7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zlG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ys7::P64;
           _s1ys3::P64 = P64[_s1ys7::P64 + 16];
           _s1ys6::P64 = P64[_s1ys7::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ys6::P64;
           R2 = Hp - 16;
           R1 = _s1ys3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1ysn_entry() //  [R1]
         { info_tbl: [(c1zlP,
                       label: sat_s1ysn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zlP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1zlT; else goto c1zlU;
       c1zlT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zlU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1zlM_info;
           _s1ys6::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1ys6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1zlY; else goto c1zlN;
       u1zlY: // global
           call _c1zlM(R1) args: 0, res: 0, upd: 0;
       c1zlN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zlM() //  [R1]
         { info_tbl: [(c1zlM,
                       label: block_c1zlM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zlM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zlX; else goto c1zlW;
       c1zlX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1zlW: // global
           _s1ysi::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1ysi::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zm1,
                       label: Data.Functor.Utils.$fApplicativeStateR4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zm1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1zm5; else goto c1zm4;
       c1zm5: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zm4: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1ys7_info;
           P64[Hp - 88] = R2;
           _c1zlx::P64 = Hp - 136;
           P64[Hp - 80] = _c1zlx::P64;
           I64[Hp - 72] = sat_s1ysn_info;
           P64[Hp - 56] = _c1zlx::P64;
           _c1zly::P64 = Hp - 104;
           P64[Hp - 48] = _c1zly::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zly::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.510589847 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR2_closure" {
     Data.Functor.Utils.$fApplicativeStateR2_closure:
         const Data.Functor.Utils.$fApplicativeStateR2_info;
 },
 sat_s1ysz_entry() //  [R1]
         { info_tbl: [(c1zmD,
                       label: sat_s1ysz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zmD: // global
           _s1ysz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1zmE; else goto c1zmF;
       c1zmF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zmH; else goto c1zmG;
       c1zmH: // global
           HpAlloc = 24;
           goto c1zmE;
       c1zmE: // global
           R1 = _s1ysz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zmG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ysz::P64;
           _s1yso::P64 = P64[_s1ysz::P64 + 16];
           _s1ysr::P64 = P64[_s1ysz::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ysr::P64;
           I64[Sp - 24] = block_c1zmB_info;
           R2 = Hp - 16;
           R1 = _s1yso::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zmB() //  [R1]
         { info_tbl: [(c1zmB,
                       label: block_c1zmB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zmB: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zmM,
                       label: Data.Functor.Utils.$fApplicativeStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zmM: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zmQ; else goto c1zmP;
       c1zmQ: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zmP: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1zmu::P64 = Hp - 104;
           P64[Hp - 56] = _c1zmu::P64;
           I64[Hp - 48] = sat_s1ysz_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _c1zmu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.519944041 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR1_closure" {
     Data.Functor.Utils.$fApplicativeStateR1_closure:
         const Data.Functor.Utils.$fApplicativeStateR1_info;
 },
 sat_s1ysL_entry() //  [R1]
         { info_tbl: [(c1znj,
                       label: sat_s1ysL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1znj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1znk; else goto c1znl;
       c1znk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1znl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1znh_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1znh() //  [R1]
         { info_tbl: [(c1znh,
                       label: block_c1znh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1znh: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds2_s1ysH_entry() //  [R1]
         { info_tbl: [(c1znp,
                       label: ds2_s1ysH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1znp: // global
           _s1ysH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1znq; else goto c1znr;
       c1znr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1znt; else goto c1zns;
       c1znt: // global
           HpAlloc = 32;
           goto c1znq;
       c1znq: // global
           R1 = _s1ysH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zns: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ysH::P64;
           _s1ysE::P64 = P64[_s1ysH::P64 + 16];
           _s1ysF::P64 = P64[_s1ysH::P64 + 24];
           _s1ysG::P64 = P64[_s1ysH::P64 + 32];
           I64[Hp - 24] = sat_s1ysL_info;
           P64[Hp - 8] = _s1ysF::P64;
           P64[Hp] = _s1ysG::P64;
           R2 = Hp - 24;
           R1 = _s1ysE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1znx,
                       label: Data.Functor.Utils.$fApplicativeStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1znx: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1znB; else goto c1znA;
       c1znB: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1znA: // global
           I64[Hp - 104] = ds2_s1ysH_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1zn9::P64 = Hp - 104;
           P64[Hp - 48] = _c1zn9::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zn9::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.529661739 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR_closure" {
     Data.Functor.Utils.$fApplicativeStateR_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateR_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateR4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateR2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.531719427 UTC

[section ""data" . Data.Functor.Utils.getMax1_closure" {
     Data.Functor.Utils.getMax1_closure:
         const Data.Functor.Utils.getMax1_info;
 },
 Data.Functor.Utils.getMax1_entry() //  [R2]
         { info_tbl: [(c1znZ,
                       label: Data.Functor.Utils.getMax1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1znZ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.535169573 UTC

[section ""data" . Data.Functor.Utils.getMax_closure" {
     Data.Functor.Utils.getMax_closure:
         const Data.Functor.Utils.getMax_info;
 },
 Data.Functor.Utils.getMax_entry() //  [R2]
         { info_tbl: [(c1zoc,
                       label: Data.Functor.Utils.getMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zoc: // global
           R2 = R2;
           call Data.Functor.Utils.getMax1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.538905765 UTC

[section ""data" . Data.Functor.Utils.getMin1_closure" {
     Data.Functor.Utils.getMin1_closure:
         const Data.Functor.Utils.getMin1_info;
 },
 Data.Functor.Utils.getMin1_entry() //  [R2]
         { info_tbl: [(c1zon,
                       label: Data.Functor.Utils.getMin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zon: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.542380081 UTC

[section ""data" . Data.Functor.Utils.getMin_closure" {
     Data.Functor.Utils.getMin_closure:
         const Data.Functor.Utils.getMin_info;
 },
 Data.Functor.Utils.getMin_entry() //  [R2]
         { info_tbl: [(c1zoA,
                       label: Data.Functor.Utils.getMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zoA: // global
           R2 = R2;
           call Data.Functor.Utils.getMin1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.545866789 UTC

[section ""data" . Data.Functor.Utils.runStateL1_closure" {
     Data.Functor.Utils.runStateL1_closure:
         const Data.Functor.Utils.runStateL1_info;
 },
 Data.Functor.Utils.runStateL1_entry() //  [R2]
         { info_tbl: [(c1zoL,
                       label: Data.Functor.Utils.runStateL1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zoL: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.550159478 UTC

[section ""data" . Data.Functor.Utils.runStateL_closure" {
     Data.Functor.Utils.runStateL_closure:
         const Data.Functor.Utils.runStateL_info;
 },
 Data.Functor.Utils.runStateL_entry() //  [R2]
         { info_tbl: [(c1zoW,
                       label: Data.Functor.Utils.runStateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zoW: // global
           R2 = R2;
           call Data.Functor.Utils.runStateL1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.553696517 UTC

[section ""data" . Data.Functor.Utils.runStateR1_closure" {
     Data.Functor.Utils.runStateR1_closure:
         const Data.Functor.Utils.runStateR1_info;
 },
 Data.Functor.Utils.runStateR1_entry() //  [R2]
         { info_tbl: [(c1zp7,
                       label: Data.Functor.Utils.runStateR1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zp7: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.55697253 UTC

[section ""data" . Data.Functor.Utils.runStateR_closure" {
     Data.Functor.Utils.runStateR_closure:
         const Data.Functor.Utils.runStateR_info;
 },
 Data.Functor.Utils.runStateR_entry() //  [R2]
         { info_tbl: [(c1zpi,
                       label: Data.Functor.Utils.runStateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zpi: // global
           R2 = R2;
           call Data.Functor.Utils.runStateR1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.56039135 UTC

[section ""data" . Data.Functor.Utils.#._closure" {
     Data.Functor.Utils.#._closure:
         const Data.Functor.Utils.#._info;
 },
 Data.Functor.Utils.#._entry() //  [R2, R3, R4]
         { info_tbl: [(c1zpv,
                       label: Data.Functor.Utils.#._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zpv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zpw; else goto c1zpx;
       c1zpw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.#._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zpx: // global
           I64[Sp - 16] = block_c1zpt_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1zpt() //  []
         { info_tbl: [(c1zpt,
                       label: block_c1zpt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zpt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.565654231 UTC

[section ""cstring" . Data.Functor.Utils.$trModule4_bytes" {
     Data.Functor.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.567298782 UTC

[section ""data" . Data.Functor.Utils.$trModule3_closure" {
     Data.Functor.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.56902705 UTC

[section ""cstring" . Data.Functor.Utils.$trModule2_bytes" {
     Data.Functor.Utils.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.570702192 UTC

[section ""data" . Data.Functor.Utils.$trModule1_closure" {
     Data.Functor.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.572359032 UTC

[section ""data" . Data.Functor.Utils.$trModule_closure" {
     Data.Functor.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Utils.$trModule3_closure+1;
         const Data.Functor.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.574269378 UTC

[section ""data" . $krep_r1ynX_closure" {
     $krep_r1ynX_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.576600043 UTC

[section ""data" . $krep1_r1ynY_closure" {
     $krep1_r1ynY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.578718066 UTC

[section ""data" . $krep2_r1ynZ_closure" {
     $krep2_r1ynZ_closure:
         const :_con_info;
         const $krep_r1ynX_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.58045836 UTC

[section ""data" . $krep3_r1yo0_closure" {
     $krep3_r1yo0_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep2_r1ynZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.582261866 UTC

[section ""data" . $krep4_r1yo1_closure" {
     $krep4_r1yo1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.584034854 UTC

[section ""data" . $krep5_r1yo2_closure" {
     $krep5_r1yo2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep4_r1yo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.585831251 UTC

[section ""data" . $krep6_r1yo3_closure" {
     $krep6_r1yo3_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.58759861 UTC

[section ""data" . $krep7_r1yo4_closure" {
     $krep7_r1yo4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.589684891 UTC

[section ""cstring" . Data.Functor.Utils.$tcMax2_bytes" {
     Data.Functor.Utils.$tcMax2_bytes:
         I8[] [77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.591417024 UTC

[section ""data" . Data.Functor.Utils.$tcMax1_closure" {
     Data.Functor.Utils.$tcMax1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMax2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.593168532 UTC

[section ""data" . Data.Functor.Utils.$tcMax_closure" {
     Data.Functor.Utils.$tcMax_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMax1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17055998897267803697;
         const 13070619747111935994;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.595120371 UTC

[section ""data" . $krep8_r1yo5_closure" {
     $krep8_r1yo5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMax_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.596870318 UTC

[section ""data" . Data.Functor.Utils.$tc'Max1_closure" {
     Data.Functor.Utils.$tc'Max1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep8_r1yo5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.598690517 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Max3_bytes" {
     Data.Functor.Utils.$tc'Max3_bytes:
         I8[] [39,77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.600400313 UTC

[section ""data" . Data.Functor.Utils.$tc'Max2_closure" {
     Data.Functor.Utils.$tc'Max2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Max3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.602731432 UTC

[section ""data" . Data.Functor.Utils.$tc'Max_closure" {
     Data.Functor.Utils.$tc'Max_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Max2_closure+1;
         const Data.Functor.Utils.$tc'Max1_closure+4;
         const 16178335003924091205;
         const 10384293407056089504;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.604577686 UTC

[section ""cstring" . Data.Functor.Utils.$tcMin2_bytes" {
     Data.Functor.Utils.$tcMin2_bytes:
         I8[] [77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.607175144 UTC

[section ""data" . Data.Functor.Utils.$tcMin1_closure" {
     Data.Functor.Utils.$tcMin1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMin2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.608894394 UTC

[section ""data" . Data.Functor.Utils.$tcMin_closure" {
     Data.Functor.Utils.$tcMin_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMin1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13719831963261617173;
         const 12509304105097421826;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.610871169 UTC

[section ""data" . $krep9_r1yo6_closure" {
     $krep9_r1yo6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMin_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.6126569 UTC

[section ""data" . Data.Functor.Utils.$tc'Min1_closure" {
     Data.Functor.Utils.$tc'Min1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep9_r1yo6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.614444781 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Min3_bytes" {
     Data.Functor.Utils.$tc'Min3_bytes:
         I8[] [39,77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.616149922 UTC

[section ""data" . Data.Functor.Utils.$tc'Min2_closure" {
     Data.Functor.Utils.$tc'Min2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Min3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.61798706 UTC

[section ""data" . Data.Functor.Utils.$tc'Min_closure" {
     Data.Functor.Utils.$tc'Min_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Min2_closure+1;
         const Data.Functor.Utils.$tc'Min1_closure+4;
         const 3497961960072019520;
         const 14191657227527039212;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.619815176 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateL2_bytes" {
     Data.Functor.Utils.$tcStateL2_bytes:
         I8[] [83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.622303808 UTC

[section ""data" . Data.Functor.Utils.$tcStateL1_closure" {
     Data.Functor.Utils.$tcStateL1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateL2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.623993138 UTC

[section ""data" . Data.Functor.Utils.$tcStateL_closure" {
     Data.Functor.Utils.$tcStateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateL1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 8498227433031831307;
         const 6442648285908986693;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.625894179 UTC

[section ""data" . $krep10_r1yo7_closure" {
     $krep10_r1yo7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateL_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.628213738 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL1_closure" {
     Data.Functor.Utils.$tc'StateL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep10_r1yo7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.630088639 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateL3_bytes" {
     Data.Functor.Utils.$tc'StateL3_bytes:
         I8[] [39,83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.631780891 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL2_closure" {
     Data.Functor.Utils.$tc'StateL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.63353054 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL_closure" {
     Data.Functor.Utils.$tc'StateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateL2_closure+1;
         const Data.Functor.Utils.$tc'StateL1_closure+4;
         const 8965240648136302046;
         const 8498113279827793106;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.635324507 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateR2_bytes" {
     Data.Functor.Utils.$tcStateR2_bytes:
         I8[] [83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.636979437 UTC

[section ""data" . Data.Functor.Utils.$tcStateR1_closure" {
     Data.Functor.Utils.$tcStateR1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateR2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.6388318 UTC

[section ""data" . Data.Functor.Utils.$tcStateR_closure" {
     Data.Functor.Utils.$tcStateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateR1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 10049146831422350196;
         const 16883721947448934294;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.64058277 UTC

[section ""data" . $krep11_r1yo8_closure" {
     $krep11_r1yo8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateR_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.642415501 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR1_closure" {
     Data.Functor.Utils.$tc'StateR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep11_r1yo8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.644198392 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateR3_bytes" {
     Data.Functor.Utils.$tc'StateR3_bytes:
         I8[] [39,83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.645959086 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR2_closure" {
     Data.Functor.Utils.$tc'StateR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.647681649 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR_closure" {
     Data.Functor.Utils.$tc'StateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateR2_closure+1;
         const Data.Functor.Utils.$tc'StateR1_closure+4;
         const 13798701525568783897;
         const 17913645303573466967;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:20.649708415 UTC

[section ""relreadonly" . S1yw7_srt" {
     S1yw7_srt:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMax_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMin_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.596581372 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:21.601592091 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMax_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMax_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMax_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zvt,
                       label: Data.Functor.Utils.$fMonoidMax_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zvt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zvu; else goto c1zvv;
       c1zvu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zvv: // global
           I64[Sp - 24] = block_c1zvm_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1zw4; else goto c1zvn;
       u1zw4: // global
           call _c1zvm(R1) args: 0, res: 0, upd: 0;
       c1zvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zvm() //  [R1]
         { info_tbl: [(c1zvm,
                       label: block_c1zvm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zvm: // global
           _s1zqs::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1zvq; else goto c1zvr;
       c1zvq: // global
           R1 = _s1zqs::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1zvr: // global
           I64[Sp - 8] = block_c1zvB_info;
           _s1zqu::P64 = R1;
           _s1zqv::P64 = P64[R1 + 6];
           R1 = _s1zqs::P64;
           P64[Sp] = _s1zqv::P64;
           P64[Sp + 16] = _s1zqu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1zw3; else goto c1zvD;
       u1zw3: // global
           call _c1zvB(R1) args: 0, res: 0, upd: 0;
       c1zvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zvB() //  [R1]
         { info_tbl: [(c1zvB,
                       label: block_c1zvB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zvB: // global
           if (R1 & 7 == 1) goto u1zw1; else goto c1zvO;
       u1zw1: // global
           Sp = Sp + 24;
           call _c1zvU() args: 0, res: 0, upd: 0;
       c1zvO: // global
           _s1zqv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zvM_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1zqv::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zvM() //  [R1]
         { info_tbl: [(c1zvM,
                       label: block_c1zvM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zvM: // global
           if (R1 & 7 == 1) goto u1zw2; else goto c1zvY;
       u1zw2: // global
           Sp = Sp + 16;
           call _c1zvU() args: 0, res: 0, upd: 0;
       c1zvY: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zvU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zvU: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.614261951 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat_closure" {
     Data.Functor.Utils.$w$csconcat_closure:
         const Data.Functor.Utils.$w$csconcat_info;
 },
 go_s1zqC_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zwW,
                       label: go_s1zqC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zwW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zwX; else goto c1zwY;
       c1zwX: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zwY: // global
           I64[Sp - 32] = block_c1zwP_info;
           _s1zqC::P64 = R1;
           _s1zqz::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1zqz::P64;
           P64[Sp - 16] = _s1zqC::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1zxL; else goto c1zwQ;
       u1zxL: // global
           call _c1zwP(R1) args: 0, res: 0, upd: 0;
       c1zwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zwP() //  [R1]
         { info_tbl: [(c1zwP,
                       label: block_c1zwP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zwP: // global
           if (R1 & 7 == 1) goto u1zxG; else goto c1zwU;
       u1zxG: // global
           Sp = Sp + 24;
           call _c1zxb() args: 0, res: 0, upd: 0;
       c1zwU: // global
           I64[Sp] = block_c1zx4_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1zqC_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zx4() //  [R1]
         { info_tbl: [(c1zx4,
                       label: block_c1zx4_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zx4: // global
           if (R1 & 7 == 1) goto u1zxH; else goto c1zxg;
       u1zxH: // global
           Sp = Sp + 24;
           call _c1zxb() args: 0, res: 0, upd: 0;
       c1zxg: // global
           I64[Sp] = block_c1zxe_info;
           _s1zqI::P64 = R1;
           _s1zqJ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1zqJ::P64;
           P64[Sp + 24] = _s1zqI::P64;
           if (R1 & 7 != 0) goto u1zxM; else goto c1zxh;
       u1zxM: // global
           call _c1zxe(R1) args: 0, res: 0, upd: 0;
       c1zxh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zxb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zxb: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zxe() //  [R1]
         { info_tbl: [(c1zxe,
                       label: block_c1zxe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zxe: // global
           if (R1 & 7 == 1) goto u1zxI; else goto c1zxs;
       u1zxI: // global
           Sp = Sp + 24;
           call _c1zxy() args: 0, res: 0, upd: 0;
       c1zxs: // global
           _s1zqz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zxq_info;
           R2 = _s1zqz::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zxq() //  [R1]
         { info_tbl: [(c1zxq,
                       label: block_c1zxq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zxq: // global
           if (R1 & 7 == 1) goto u1zxJ; else goto c1zxC;
       u1zxJ: // global
           Sp = Sp + 16;
           call _c1zxy() args: 0, res: 0, upd: 0;
       c1zxC: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zxy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zxy: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zxQ,
                       label: Data.Functor.Utils.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zxQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1zxU; else goto c1zxT;
       c1zxU: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zxT: // global
           I64[Hp - 8] = go_s1zqC_info;
           P64[Hp] = R2;
           _s1zqA::P64 = R3;
           R3 = R4;
           R2 = _s1zqA::P64;
           R1 = Hp - 6;
           call go_s1zqC_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.630519625 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMax_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMax_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMax_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1zyO,
                       label: Data.Functor.Utils.$fSemigroupMax_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zyO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zyP; else goto c1zyQ;
       c1zyP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zyQ: // global
           I64[Sp - 16] = block_c1zyL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1zyU; else goto c1zyM;
       u1zyU: // global
           call _c1zyL(R1) args: 0, res: 0, upd: 0;
       c1zyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zyL() //  [R1]
         { info_tbl: [(c1zyL,
                       label: block_c1zyL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zyL: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.63706756 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMax_closure" {
     Data.Functor.Utils.$fSemigroupMax_closure:
         const Data.Functor.Utils.$fSemigroupMax_info;
         const 0;
 },
 sat_s1zqV_entry() //  [R1, R2]
         { info_tbl: [(c1zze,
                       label: sat_s1zqV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zze: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zqU_entry() //  [R1, R2]
         { info_tbl: [(c1zzm,
                       label: sat_s1zqU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zzm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMax_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zqT_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zzu,
                       label: sat_s1zqT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zzu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_entry() //  [R2]
         { info_tbl: [(c1zzy,
                       label: Data.Functor.Utils.$fSemigroupMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zzy: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1zzC; else goto c1zzB;
       c1zzC: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zzB: // global
           I64[Hp - 72] = sat_s1zqV_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1zqU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1zqT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMax_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMax_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_info;
         const 0;
 },
 sat_s1zqY_entry() //  [R1]
         { info_tbl: [(c1zzL,
                       label: sat_s1zqY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zzL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zzM; else goto c1zzN;
       c1zzM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zzN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMax_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1zzO,
                       label: Data.Functor.Utils.$fSemigroupMax_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zzO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zzS; else goto c1zzR;
       c1zzS: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zzR: // global
           I64[Hp - 16] = sat_s1zqY_info;
           P64[Hp] = R2;
           _s1zqX::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1zqX::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.653188788 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMax_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMax_$cmconcat_info;
 },
 go_s1zr1_entry() //  [R1, R2]
         { info_tbl: [(c1zAF,
                       label: go_s1zr1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zAF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zAG; else goto c1zAH;
       c1zAG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zAH: // global
           I64[Sp - 24] = block_c1zAy_info;
           _s1zr1::P64 = R1;
           _s1zqZ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1zqZ::P64;
           P64[Sp - 8] = _s1zr1::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1zBr; else goto c1zAz;
       u1zBr: // global
           call _c1zAy(R1) args: 0, res: 0, upd: 0;
       c1zAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zAy() //  [R1]
         { info_tbl: [(c1zAy,
                       label: block_c1zAy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zAy: // global
           if (R1 & 7 == 1) goto c1zAC; else goto c1zAD;
       c1zAC: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1zAD: // global
           I64[Sp] = block_c1zAN_info;
           R2 = P64[R1 + 14];
           _s1zr4::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1zr4::P64;
           call go_s1zr1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zAN() //  [R1]
         { info_tbl: [(c1zAN,
                       label: block_c1zAN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zAN: // global
           _s1zr4::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1zAU; else goto c1zAZ;
       c1zAU: // global
           R1 = _s1zr4::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1zAZ: // global
           I64[Sp - 8] = block_c1zAX_info;
           _s1zr6::P64 = R1;
           _s1zr7::P64 = P64[R1 + 6];
           R1 = _s1zr4::P64;
           P64[Sp] = _s1zr7::P64;
           P64[Sp + 16] = _s1zr6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1zBs; else goto c1zB0;
       u1zBs: // global
           call _c1zAX(R1) args: 0, res: 0, upd: 0;
       c1zB0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zAX() //  [R1]
         { info_tbl: [(c1zAX,
                       label: block_c1zAX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zAX: // global
           if (R1 & 7 == 1) goto u1zBp; else goto c1zBb;
       u1zBp: // global
           Sp = Sp + 24;
           call _c1zBh() args: 0, res: 0, upd: 0;
       c1zBb: // global
           _s1zr7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zB9_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1zr7::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zB9() //  [R1]
         { info_tbl: [(c1zB9,
                       label: block_c1zB9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zB9: // global
           if (R1 & 7 == 1) goto u1zBq; else goto c1zBl;
       u1zBq: // global
           Sp = Sp + 16;
           call _c1zBh() args: 0, res: 0, upd: 0;
       c1zBl: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zBh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zBh: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMax_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1zBv,
                       label: Data.Functor.Utils.$fMonoidMax_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zBv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1zBz; else goto c1zBy;
       c1zBz: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zBy: // global
           I64[Hp - 8] = go_s1zr1_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1zr1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.669688272 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMax_closure" {
     Data.Functor.Utils.$fMonoidMax_closure:
         const Data.Functor.Utils.$fMonoidMax_info;
         const 0;
 },
 sat_s1zre_entry() //  [R1, R2]
         { info_tbl: [(c1zCu,
                       label: sat_s1zre_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zCu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMax_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zrd_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zCC,
                       label: sat_s1zrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zCC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMax_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zrc_entry() //  [R1]
         { info_tbl: [(c1zCJ,
                       label: sat_s1zrc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zCJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zCK; else goto c1zCL;
       c1zCK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zCL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMax_entry() //  [R2]
         { info_tbl: [(c1zCN,
                       label: Data.Functor.Utils.$fMonoidMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zCN: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1zCR; else goto c1zCQ;
       c1zCR: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMax_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zCQ: // global
           I64[Hp - 88] = sat_s1zre_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1zrd_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1zrc_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.679775121 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$c<>_closure" {
     Data.Functor.Utils.$fMonoidMin_$c<>_closure:
         const Data.Functor.Utils.$fMonoidMin_$c<>_info;
 },
 Data.Functor.Utils.$fMonoidMin_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zDs,
                       label: Data.Functor.Utils.$fMonoidMin_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zDs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zDt; else goto c1zDu;
       c1zDt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zDu: // global
           I64[Sp - 24] = block_c1zDl_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1zE3; else goto c1zDm;
       u1zE3: // global
           call _c1zDl(R1) args: 0, res: 0, upd: 0;
       c1zDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zDl() //  [R1]
         { info_tbl: [(c1zDl,
                       label: block_c1zDl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zDl: // global
           _s1zrg::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1zDp; else goto c1zDq;
       c1zDp: // global
           R1 = _s1zrg::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1zDq: // global
           I64[Sp - 8] = block_c1zDA_info;
           _s1zri::P64 = R1;
           _s1zrj::P64 = P64[R1 + 6];
           R1 = _s1zrg::P64;
           P64[Sp] = _s1zrj::P64;
           P64[Sp + 16] = _s1zri::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1zE2; else goto c1zDC;
       u1zE2: // global
           call _c1zDA(R1) args: 0, res: 0, upd: 0;
       c1zDC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zDA() //  [R1]
         { info_tbl: [(c1zDA,
                       label: block_c1zDA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zDA: // global
           if (R1 & 7 == 1) goto u1zE0; else goto c1zDN;
       u1zE0: // global
           Sp = Sp + 24;
           call _c1zDT() args: 0, res: 0, upd: 0;
       c1zDN: // global
           _s1zrj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zDL_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1zrj::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zDL() //  [R1]
         { info_tbl: [(c1zDL,
                       label: block_c1zDL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zDL: // global
           if (R1 & 7 == 1) goto u1zE1; else goto c1zDX;
       u1zE1: // global
           Sp = Sp + 16;
           call _c1zDT() args: 0, res: 0, upd: 0;
       c1zDX: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zDT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zDT: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.692668045 UTC

[section ""data" . Data.Functor.Utils.$w$csconcat1_closure" {
     Data.Functor.Utils.$w$csconcat1_closure:
         const Data.Functor.Utils.$w$csconcat1_info;
 },
 go_s1zrq_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zEV,
                       label: go_s1zrq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zEV: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zEW; else goto c1zEX;
       c1zEW: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zEX: // global
           I64[Sp - 32] = block_c1zEO_info;
           _s1zrq::P64 = R1;
           _s1zrn::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s1zrn::P64;
           P64[Sp - 16] = _s1zrq::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1zFK; else goto c1zEP;
       u1zFK: // global
           call _c1zEO(R1) args: 0, res: 0, upd: 0;
       c1zEP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zEO() //  [R1]
         { info_tbl: [(c1zEO,
                       label: block_c1zEO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zEO: // global
           if (R1 & 7 == 1) goto u1zFF; else goto c1zET;
       u1zFF: // global
           Sp = Sp + 24;
           call _c1zFa() args: 0, res: 0, upd: 0;
       c1zET: // global
           I64[Sp] = block_c1zF3_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           call go_s1zrq_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zF3() //  [R1]
         { info_tbl: [(c1zF3,
                       label: block_c1zF3_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zF3: // global
           if (R1 & 7 == 1) goto u1zFG; else goto c1zFf;
       u1zFG: // global
           Sp = Sp + 24;
           call _c1zFa() args: 0, res: 0, upd: 0;
       c1zFf: // global
           I64[Sp] = block_c1zFd_info;
           _s1zrw::P64 = R1;
           _s1zrx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 16] = _s1zrx::P64;
           P64[Sp + 24] = _s1zrw::P64;
           if (R1 & 7 != 0) goto u1zFL; else goto c1zFg;
       u1zFL: // global
           call _c1zFd(R1) args: 0, res: 0, upd: 0;
       c1zFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zFa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zFa: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zFd() //  [R1]
         { info_tbl: [(c1zFd,
                       label: block_c1zFd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zFd: // global
           if (R1 & 7 == 1) goto u1zFH; else goto c1zFr;
       u1zFH: // global
           Sp = Sp + 24;
           call _c1zFx() args: 0, res: 0, upd: 0;
       c1zFr: // global
           _s1zrn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zFp_info;
           R2 = _s1zrn::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zFp() //  [R1]
         { info_tbl: [(c1zFp,
                       label: block_c1zFp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zFp: // global
           if (R1 & 7 == 1) goto u1zFI; else goto c1zFB;
       u1zFI: // global
           Sp = Sp + 16;
           call _c1zFx() args: 0, res: 0, upd: 0;
       c1zFB: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zFx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zFx: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zFP,
                       label: Data.Functor.Utils.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zFP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1zFT; else goto c1zFS;
       c1zFT: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zFS: // global
           I64[Hp - 8] = go_s1zrq_info;
           P64[Hp] = R2;
           _s1zro::P64 = R3;
           R3 = R4;
           R2 = _s1zro::P64;
           R1 = Hp - 6;
           call go_s1zrq_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.709634149 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_$csconcat_closure" {
     Data.Functor.Utils.$fSemigroupMin_$csconcat_closure:
         const Data.Functor.Utils.$fSemigroupMin_$csconcat_info;
 },
 Data.Functor.Utils.$fSemigroupMin_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c1zGN,
                       label: Data.Functor.Utils.$fSemigroupMin_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zGN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zGO; else goto c1zGP;
       c1zGO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zGP: // global
           I64[Sp - 16] = block_c1zGK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1zGT; else goto c1zGL;
       u1zGT: // global
           call _c1zGK(R1) args: 0, res: 0, upd: 0;
       c1zGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zGK() //  [R1]
         { info_tbl: [(c1zGK,
                       label: block_c1zGK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zGK: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Functor.Utils.$w$csconcat1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.716209558 UTC

[section ""data" . Data.Functor.Utils.$fSemigroupMin_closure" {
     Data.Functor.Utils.$fSemigroupMin_closure:
         const Data.Functor.Utils.$fSemigroupMin_info;
         const 0;
 },
 sat_s1zrJ_entry() //  [R1, R2]
         { info_tbl: [(c1zHd,
                       label: sat_s1zrJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zHd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$cstimes_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zrI_entry() //  [R1, R2]
         { info_tbl: [(c1zHl,
                       label: sat_s1zrI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zHl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fSemigroupMin_$csconcat_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zrH_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zHt,
                       label: sat_s1zrH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zHt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_entry() //  [R2]
         { info_tbl: [(c1zHx,
                       label: Data.Functor.Utils.$fSemigroupMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zHx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c1zHB; else goto c1zHA;
       c1zHB: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zHA: // global
           I64[Hp - 72] = sat_s1zrJ_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1zrI_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s1zrH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Functor.Utils.$fSemigroupMin_$cstimes_closure" {
     Data.Functor.Utils.$fSemigroupMin_$cstimes_closure:
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_info;
         const 0;
 },
 sat_s1zrM_entry() //  [R1]
         { info_tbl: [(c1zHK,
                       label: sat_s1zrM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zHK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zHL; else goto c1zHM;
       c1zHL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zHM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fSemigroupMin_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c1zHN,
                       label: Data.Functor.Utils.$fSemigroupMin_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zHN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zHR; else goto c1zHQ;
       c1zHR: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zHQ: // global
           I64[Hp - 16] = sat_s1zrM_info;
           P64[Hp] = R2;
           _s1zrL::P64 = R3;
           R3 = Hp - 16;
           R2 = _s1zrL::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.730635823 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_$cmconcat_closure" {
     Data.Functor.Utils.$fMonoidMin_$cmconcat_closure:
         const Data.Functor.Utils.$fMonoidMin_$cmconcat_info;
 },
 go_s1zrP_entry() //  [R1, R2]
         { info_tbl: [(c1zID,
                       label: go_s1zrP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zID: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c1zIE; else goto c1zIF;
       c1zIE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zIF: // global
           I64[Sp - 24] = block_c1zIw_info;
           _s1zrP::P64 = R1;
           _s1zrN::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s1zrN::P64;
           P64[Sp - 8] = _s1zrP::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1zJp; else goto c1zIx;
       u1zJp: // global
           call _c1zIw(R1) args: 0, res: 0, upd: 0;
       c1zIx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zIw() //  [R1]
         { info_tbl: [(c1zIw,
                       label: block_c1zIw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zIw: // global
           if (R1 & 7 == 1) goto c1zIA; else goto c1zIB;
       c1zIA: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1zIB: // global
           I64[Sp] = block_c1zIL_info;
           R2 = P64[R1 + 14];
           _s1zrS::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s1zrS::P64;
           call go_s1zrP_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zIL() //  [R1]
         { info_tbl: [(c1zIL,
                       label: block_c1zIL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zIL: // global
           _s1zrS::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1zIS; else goto c1zIX;
       c1zIS: // global
           R1 = _s1zrS::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1zIX: // global
           I64[Sp - 8] = block_c1zIV_info;
           _s1zrU::P64 = R1;
           _s1zrV::P64 = P64[R1 + 6];
           R1 = _s1zrS::P64;
           P64[Sp] = _s1zrV::P64;
           P64[Sp + 16] = _s1zrU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1zJq; else goto c1zIY;
       u1zJq: // global
           call _c1zIV(R1) args: 0, res: 0, upd: 0;
       c1zIY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1zIV() //  [R1]
         { info_tbl: [(c1zIV,
                       label: block_c1zIV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zIV: // global
           if (R1 & 7 == 1) goto u1zJn; else goto c1zJ9;
       u1zJn: // global
           Sp = Sp + 24;
           call _c1zJf() args: 0, res: 0, upd: 0;
       c1zJ9: // global
           _s1zrV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1zJ7_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = _s1zrV::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1zJ7() //  [R1]
         { info_tbl: [(c1zJ7,
                       label: block_c1zJ7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zJ7: // global
           if (R1 & 7 == 1) goto u1zJo; else goto c1zJj;
       u1zJo: // global
           Sp = Sp + 16;
           call _c1zJf() args: 0, res: 0, upd: 0;
       c1zJj: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1zJf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zJf: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Utils.$fMonoidMin_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c1zJt,
                       label: Data.Functor.Utils.$fMonoidMin_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zJt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1zJx; else goto c1zJw;
       c1zJx: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zJw: // global
           I64[Hp - 8] = go_s1zrP_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s1zrP_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.747023862 UTC

[section ""data" . Data.Functor.Utils.$fMonoidMin_closure" {
     Data.Functor.Utils.$fMonoidMin_closure:
         const Data.Functor.Utils.$fMonoidMin_info;
         const 0;
 },
 sat_s1zs2_entry() //  [R1, R2]
         { info_tbl: [(c1zKs,
                       label: sat_s1zs2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zKs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Utils.$fMonoidMin_$cmconcat_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zs1_entry() //  [R1, R2, R3]
         { info_tbl: [(c1zKA,
                       label: sat_s1zs1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zKA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Utils.$fMonoidMin_$c<>_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s1zs0_entry() //  [R1]
         { info_tbl: [(c1zKH,
                       label: sat_s1zs0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zKH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zKI; else goto c1zKJ;
       c1zKI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zKJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fSemigroupMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fMonoidMin_entry() //  [R2]
         { info_tbl: [(c1zKL,
                       label: Data.Functor.Utils.$fMonoidMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zKL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c1zKP; else goto c1zKO;
       c1zKP: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = Data.Functor.Utils.$fMonoidMin_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1zKO: // global
           I64[Hp - 88] = sat_s1zs2_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s1zs1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s1zs0_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.757312131 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL2_closure" {
     Data.Functor.Utils.$fFunctorStateL2_closure:
         const Data.Functor.Utils.$fFunctorStateL2_info;
 },
 sat_s1zsf_entry() //  [R1]
         { info_tbl: [(c1zLp,
                       label: sat_s1zsf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zLp: // global
           _s1zsf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zLq; else goto c1zLr;
       c1zLr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zLt; else goto c1zLs;
       c1zLt: // global
           HpAlloc = 24;
           goto c1zLq;
       c1zLq: // global
           R1 = _s1zsf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zLs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zsf::P64;
           _s1zs3::P64 = P64[_s1zsf::P64 + 16];
           _s1zs6::P64 = P64[_s1zsf::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1zs6::P64;
           R2 = Hp - 16;
           R1 = _s1zs3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zLw,
                       label: Data.Functor.Utils.$fFunctorStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zLw: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zLA; else goto c1zLz;
       c1zLA: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zLz: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1zsf_info;
           P64[Hp - 56] = R2;
           _c1zLj::P64 = Hp - 104;
           P64[Hp - 48] = _c1zLj::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zLj::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.764355006 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL1_closure" {
     Data.Functor.Utils.$fFunctorStateL1_closure:
         const Data.Functor.Utils.$fFunctorStateL1_info;
 },
 sat_s1zsm_entry() //  [R1]
         { info_tbl: [(c1zM2,
                       label: sat_s1zsm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zM2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zM3; else goto c1zM4;
       c1zM3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zM4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zM0_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zM0() //  [R1]
         { info_tbl: [(c1zM0,
                       label: block_c1zM0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zM0: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zM9,
                       label: Data.Functor.Utils.$fFunctorStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zM9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1zMd; else goto c1zMc;
       c1zMd: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zMc: // global
           I64[Hp - 48] = sat_s1zsm_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.771743028 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateL_closure" {
     Data.Functor.Utils.$fFunctorStateL_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateL2_closure+3;
         const Data.Functor.Utils.$fFunctorStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.774680914 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL3_closure" {
     Data.Functor.Utils.$fApplicativeStateL3_closure:
         const Data.Functor.Utils.$fApplicativeStateL3_info;
 },
 ds1_s1zss_entry() //  [R1]
         { info_tbl: [(c1zMG,
                       label: ds1_s1zss_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zMG: // global
           _s1zss::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zMH; else goto c1zMI;
       c1zMI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zMK; else goto c1zMJ;
       c1zMK: // global
           HpAlloc = 24;
           goto c1zMH;
       c1zMH: // global
           R1 = _s1zss::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zMJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zss::P64;
           _s1zsp::P64 = P64[_s1zss::P64 + 16];
           _s1zsr::P64 = P64[_s1zss::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1zsr::P64;
           R2 = Hp - 16;
           R1 = _s1zsp::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1zsJ_entry() //  [R1]
         { info_tbl: [(c1zMR,
                       label: sat_s1zsJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zMR: // global
           _s1zsJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zMS; else goto c1zMT;
       c1zMT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1zMV; else goto c1zMU;
       c1zMV: // global
           HpAlloc = 48;
           goto c1zMS;
       c1zMS: // global
           R1 = _s1zsJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zMU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zsJ::P64;
           _s1zsn::P64 = P64[_s1zsJ::P64 + 16];
           _s1zsr::P64 = P64[_s1zsJ::P64 + 24];
           _s1zss::P64 = P64[_s1zsJ::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1zss::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1zsr::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1zsn::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1zMY,
                       label: Data.Functor.Utils.$fApplicativeStateL3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zMY: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1zN2; else goto c1zN1;
       c1zN2: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zN1: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1zss_info;
           P64[Hp - 96] = R4;
           _c1zMA::P64 = Hp - 144;
           P64[Hp - 88] = _c1zMA::P64;
           I64[Hp - 80] = sat_s1zsJ_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1zMA::P64;
           _c1zMB::P64 = Hp - 112;
           P64[Hp - 48] = _c1zMB::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zMB::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.784947806 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL4_closure" {
     Data.Functor.Utils.$fApplicativeStateL4_closure:
         const Data.Functor.Utils.$fApplicativeStateL4_info;
 },
 ds1_s1zsO_entry() //  [R1]
         { info_tbl: [(c1zNC,
                       label: ds1_s1zsO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zNC: // global
           _s1zsO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zND; else goto c1zNE;
       c1zNE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zNG; else goto c1zNF;
       c1zNG: // global
           HpAlloc = 24;
           goto c1zND;
       c1zND: // global
           R1 = _s1zsO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zNF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zsO::P64;
           _s1zsL::P64 = P64[_s1zsO::P64 + 16];
           _s1zsN::P64 = P64[_s1zsO::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1zsN::P64;
           R2 = Hp - 16;
           R1 = _s1zsL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1zt4_entry() //  [R1]
         { info_tbl: [(c1zNO,
                       label: sat_s1zt4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zNO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1zNS; else goto c1zNT;
       c1zNS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zNT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1zNL_info;
           _s1zsO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s1zsO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1zNX; else goto c1zNM;
       u1zNX: // global
           call _c1zNL(R1) args: 0, res: 0, upd: 0;
       c1zNM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zNL() //  [R1]
         { info_tbl: [(c1zNL,
                       label: block_c1zNL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zNL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zNW; else goto c1zNV;
       c1zNW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1zNV: // global
           _s1zsZ::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1zsZ::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zO0,
                       label: Data.Functor.Utils.$fApplicativeStateL4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zO0: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1zO4; else goto c1zO3;
       c1zO4: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zO3: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1zsO_info;
           P64[Hp - 88] = R3;
           _c1zNw::P64 = Hp - 136;
           P64[Hp - 80] = _c1zNw::P64;
           I64[Hp - 72] = sat_s1zt4_info;
           P64[Hp - 56] = _c1zNw::P64;
           _c1zNx::P64 = Hp - 104;
           P64[Hp - 48] = _c1zNx::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zNx::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.796280609 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL5_closure" {
     Data.Functor.Utils.$fApplicativeStateL5_closure:
         const Data.Functor.Utils.$fApplicativeStateL5_info;
 },
 Data.Functor.Utils.$fApplicativeStateL5_entry() //  [R2, R3]
         { info_tbl: [(c1zOE,
                       label: Data.Functor.Utils.$fApplicativeStateL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zOE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zOI; else goto c1zOH;
       c1zOI: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zOH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.800992117 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL2_closure" {
     Data.Functor.Utils.$fApplicativeStateL2_closure:
         const Data.Functor.Utils.$fApplicativeStateL2_info;
 },
 sat_s1zte_entry() //  [R1]
         { info_tbl: [(c1zP3,
                       label: sat_s1zte_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zP3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zP4; else goto c1zP5;
       c1zP4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zP5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zP1_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zP1() //  [R1]
         { info_tbl: [(c1zP1,
                       label: block_c1zP1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zP1: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_s1zta_entry() //  [R1]
         { info_tbl: [(c1zP9,
                       label: ds_s1zta_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zP9: // global
           _s1zta::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zPa; else goto c1zPb;
       c1zPb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1zPd; else goto c1zPc;
       c1zPd: // global
           HpAlloc = 32;
           goto c1zPa;
       c1zPa: // global
           R1 = _s1zta::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zPc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zta::P64;
           _s1zt7::P64 = P64[_s1zta::P64 + 16];
           _s1zt8::P64 = P64[_s1zta::P64 + 24];
           _s1zt9::P64 = P64[_s1zta::P64 + 32];
           I64[Hp - 24] = sat_s1zte_info;
           P64[Hp - 8] = _s1zt7::P64;
           P64[Hp] = _s1zt9::P64;
           R2 = Hp - 24;
           R1 = _s1zt8::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zPh,
                       label: Data.Functor.Utils.$fApplicativeStateL2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zPh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zPl; else goto c1zPk;
       c1zPl: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zPk: // global
           I64[Hp - 104] = ds_s1zta_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1zOT::P64 = Hp - 104;
           P64[Hp - 48] = _c1zOT::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zOT::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.812190126 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL1_closure" {
     Data.Functor.Utils.$fApplicativeStateL1_closure:
         const Data.Functor.Utils.$fApplicativeStateL1_info;
 },
 sat_s1zty_entry() //  [R1]
         { info_tbl: [(c1zPZ,
                       label: sat_s1zty_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zPZ: // global
           _s1zty::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1zQ0; else goto c1zQ1;
       c1zQ1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zQ3; else goto c1zQ2;
       c1zQ3: // global
           HpAlloc = 24;
           goto c1zQ0;
       c1zQ0: // global
           R1 = _s1zty::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zQ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zty::P64;
           _s1zto::P64 = P64[_s1zty::P64 + 16];
           _s1ztq::P64 = P64[_s1zty::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1ztq::P64;
           I64[Sp - 24] = block_c1zPX_info;
           R2 = Hp - 16;
           R1 = _s1zto::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zPX() //  [R1]
         { info_tbl: [(c1zPX,
                       label: block_c1zPX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zPX: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateL1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zQ8,
                       label: Data.Functor.Utils.$fApplicativeStateL1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zQ8: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zQc; else goto c1zQb;
       c1zQc: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateL1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zQb: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1zPQ::P64 = Hp - 104;
           P64[Hp - 56] = _c1zPQ::P64;
           I64[Hp - 48] = sat_s1zty_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _c1zPQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.820815026 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateL_closure" {
     Data.Functor.Utils.$fApplicativeStateL_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateL_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateL4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateL2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateL1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.823184103 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR2_closure" {
     Data.Functor.Utils.$fFunctorStateR2_closure:
         const Data.Functor.Utils.$fFunctorStateR2_info;
 },
 sat_s1ztP_entry() //  [R1]
         { info_tbl: [(c1zQJ,
                       label: sat_s1ztP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zQJ: // global
           _s1ztP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zQK; else goto c1zQL;
       c1zQL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zQN; else goto c1zQM;
       c1zQN: // global
           HpAlloc = 24;
           goto c1zQK;
       c1zQK: // global
           R1 = _s1ztP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zQM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1ztP::P64;
           _s1ztD::P64 = P64[_s1ztP::P64 + 16];
           _s1ztG::P64 = P64[_s1ztP::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1ztG::P64;
           R2 = Hp - 16;
           R1 = _s1ztD::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zQQ,
                       label: Data.Functor.Utils.$fFunctorStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zQQ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zQU; else goto c1zQT;
       c1zQU: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zQT: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s1ztP_info;
           P64[Hp - 56] = R2;
           _c1zQD::P64 = Hp - 104;
           P64[Hp - 48] = _c1zQD::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zQD::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.830818595 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR1_closure" {
     Data.Functor.Utils.$fFunctorStateR1_closure:
         const Data.Functor.Utils.$fFunctorStateR1_info;
 },
 sat_s1ztW_entry() //  [R1]
         { info_tbl: [(c1zRm,
                       label: sat_s1ztW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zRn; else goto c1zRo;
       c1zRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zRk_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zRk() //  [R1]
         { info_tbl: [(c1zRk,
                       label: block_c1zRk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zRk: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fFunctorStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zRt,
                       label: Data.Functor.Utils.$fFunctorStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zRt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1zRx; else goto c1zRw;
       c1zRx: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fFunctorStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zRw: // global
           I64[Hp - 48] = sat_s1ztW_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.838389182 UTC

[section ""data" . Data.Functor.Utils.$fFunctorStateR_closure" {
     Data.Functor.Utils.$fFunctorStateR_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Utils.$fFunctorStateR2_closure+3;
         const Data.Functor.Utils.$fFunctorStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.841105413 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR3_closure" {
     Data.Functor.Utils.$fApplicativeStateR3_closure:
         const Data.Functor.Utils.$fApplicativeStateR3_info;
 },
 ds1_s1zu2_entry() //  [R1]
         { info_tbl: [(c1zS0,
                       label: ds1_s1zu2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zS0: // global
           _s1zu2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zS1; else goto c1zS2;
       c1zS2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zS4; else goto c1zS3;
       c1zS4: // global
           HpAlloc = 24;
           goto c1zS1;
       c1zS1: // global
           R1 = _s1zu2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zS3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zu2::P64;
           _s1ztY::P64 = P64[_s1zu2::P64 + 16];
           _s1zu1::P64 = P64[_s1zu2::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1zu1::P64;
           R2 = Hp - 16;
           R1 = _s1ztY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1zuj_entry() //  [R1]
         { info_tbl: [(c1zSb,
                       label: sat_s1zuj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zSb: // global
           _s1zuj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zSc; else goto c1zSd;
       c1zSd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1zSf; else goto c1zSe;
       c1zSf: // global
           HpAlloc = 48;
           goto c1zSc;
       c1zSc: // global
           R1 = _s1zuj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zSe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zuj::P64;
           _s1ztX::P64 = P64[_s1zuj::P64 + 16];
           _s1zu1::P64 = P64[_s1zuj::P64 + 24];
           _s1zu2::P64 = P64[_s1zuj::P64 + 32];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _s1zu1::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _s1zu2::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _s1ztX::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR3_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c1zSi,
                       label: Data.Functor.Utils.$fApplicativeStateR3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zSi: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c1zSm; else goto c1zSl;
       c1zSm: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zSl: // global
           I64[Hp - 144] = stg_ap_2_upd_info;
           P64[Hp - 128] = R4;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = ds1_s1zu2_info;
           P64[Hp - 96] = R3;
           _c1zRU::P64 = Hp - 144;
           P64[Hp - 88] = _c1zRU::P64;
           I64[Hp - 80] = sat_s1zuj_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = _c1zRU::P64;
           _c1zRV::P64 = Hp - 112;
           P64[Hp - 48] = _c1zRV::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zRV::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.851098942 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR4_closure" {
     Data.Functor.Utils.$fApplicativeStateR4_closure:
         const Data.Functor.Utils.$fApplicativeStateR4_info;
 },
 ds1_s1zuo_entry() //  [R1]
         { info_tbl: [(c1zSW,
                       label: ds1_s1zuo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zSW: // global
           _s1zuo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zSX; else goto c1zSY;
       c1zSY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zT0; else goto c1zSZ;
       c1zT0: // global
           HpAlloc = 24;
           goto c1zSX;
       c1zSX: // global
           R1 = _s1zuo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zSZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zuo::P64;
           _s1zuk::P64 = P64[_s1zuo::P64 + 16];
           _s1zun::P64 = P64[_s1zuo::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1zun::P64;
           R2 = Hp - 16;
           R1 = _s1zuk::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1zuE_entry() //  [R1]
         { info_tbl: [(c1zT8,
                       label: sat_s1zuE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zT8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1zTc; else goto c1zTd;
       c1zTc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zTd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c1zT5_info;
           _s1zun::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s1zun::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u1zTh; else goto c1zT6;
       u1zTh: // global
           call _c1zT5(R1) args: 0, res: 0, upd: 0;
       c1zT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zT5() //  [R1]
         { info_tbl: [(c1zT5,
                       label: block_c1zT5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zT5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zTg; else goto c1zTf;
       c1zTg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1zTf: // global
           _s1zuz::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = _s1zuz::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR4_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zTk,
                       label: Data.Functor.Utils.$fApplicativeStateR4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zTk: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto c1zTo; else goto c1zTn;
       c1zTo: // global
           HpAlloc = 144;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zTn: // global
           I64[Hp - 136] = stg_ap_2_upd_info;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           I64[Hp - 104] = ds1_s1zuo_info;
           P64[Hp - 88] = R2;
           _c1zSQ::P64 = Hp - 136;
           P64[Hp - 80] = _c1zSQ::P64;
           I64[Hp - 72] = sat_s1zuE_info;
           P64[Hp - 56] = _c1zSQ::P64;
           _c1zSR::P64 = Hp - 104;
           P64[Hp - 48] = _c1zSR::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zSR::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.86311636 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR2_closure" {
     Data.Functor.Utils.$fApplicativeStateR2_closure:
         const Data.Functor.Utils.$fApplicativeStateR2_info;
 },
 sat_s1zuQ_entry() //  [R1]
         { info_tbl: [(c1zU6,
                       label: sat_s1zuQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zU6: // global
           _s1zuQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c1zU7; else goto c1zU8;
       c1zU8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1zUa; else goto c1zU9;
       c1zUa: // global
           HpAlloc = 24;
           goto c1zU7;
       c1zU7: // global
           R1 = _s1zuQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zU9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zuQ::P64;
           _s1zuF::P64 = P64[_s1zuQ::P64 + 16];
           _s1zuI::P64 = P64[_s1zuQ::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s1zuI::P64;
           I64[Sp - 24] = block_c1zU4_info;
           R2 = Hp - 16;
           R1 = _s1zuF::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zU4() //  [R1]
         { info_tbl: [(c1zU4,
                       label: block_c1zU4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zU4: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR2_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zUf,
                       label: Data.Functor.Utils.$fApplicativeStateR2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zUf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zUj; else goto c1zUi;
       c1zUj: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zUi: // global
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _c1zTX::P64 = Hp - 104;
           P64[Hp - 56] = _c1zTX::P64;
           I64[Hp - 48] = sat_s1zuQ_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _c1zTX::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.87217821 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR1_closure" {
     Data.Functor.Utils.$fApplicativeStateR1_closure:
         const Data.Functor.Utils.$fApplicativeStateR1_info;
 },
 sat_s1zv2_entry() //  [R1]
         { info_tbl: [(c1zUT,
                       label: sat_s1zv2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zUT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1zUU; else goto c1zUV;
       c1zUU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1zUR_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1zUR() //  [R1]
         { info_tbl: [(c1zUR,
                       label: block_c1zUR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zUR: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds2_s1zuY_entry() //  [R1]
         { info_tbl: [(c1zUZ,
                       label: ds2_s1zuY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zUZ: // global
           _s1zuY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c1zV0; else goto c1zV1;
       c1zV1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1zV3; else goto c1zV2;
       c1zV3: // global
           HpAlloc = 32;
           goto c1zV0;
       c1zV0: // global
           R1 = _s1zuY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1zV2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1zuY::P64;
           _s1zuV::P64 = P64[_s1zuY::P64 + 16];
           _s1zuW::P64 = P64[_s1zuY::P64 + 24];
           _s1zuX::P64 = P64[_s1zuY::P64 + 32];
           I64[Hp - 24] = sat_s1zv2_info;
           P64[Hp - 8] = _s1zuW::P64;
           P64[Hp] = _s1zuX::P64;
           R2 = Hp - 24;
           R1 = _s1zuV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Utils.$fApplicativeStateR1_entry() //  [R2, R3, R4]
         { info_tbl: [(c1zV7,
                       label: Data.Functor.Utils.$fApplicativeStateR1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zV7: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c1zVb; else goto c1zVa;
       c1zVb: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.$fApplicativeStateR1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zVa: // global
           I64[Hp - 104] = ds2_s1zuY_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c1zUJ::P64 = Hp - 104;
           P64[Hp - 48] = _c1zUJ::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c1zUJ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.882248473 UTC

[section ""data" . Data.Functor.Utils.$fApplicativeStateR_closure" {
     Data.Functor.Utils.$fApplicativeStateR_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Utils.$fFunctorStateR_closure+1;
         const Data.Functor.Utils.$fApplicativeStateL5_closure+2;
         const Data.Functor.Utils.$fApplicativeStateR4_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR3_closure+4;
         const Data.Functor.Utils.$fApplicativeStateR2_closure+3;
         const Data.Functor.Utils.$fApplicativeStateR1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.884505942 UTC

[section ""data" . Data.Functor.Utils.getMax1_closure" {
     Data.Functor.Utils.getMax1_closure:
         const Data.Functor.Utils.getMax1_info;
 },
 Data.Functor.Utils.getMax1_entry() //  [R2]
         { info_tbl: [(c1zVH,
                       label: Data.Functor.Utils.getMax1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zVH: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.888047606 UTC

[section ""data" . Data.Functor.Utils.getMax_closure" {
     Data.Functor.Utils.getMax_closure:
         const Data.Functor.Utils.getMax_info;
 },
 Data.Functor.Utils.getMax_entry() //  [R2]
         { info_tbl: [(c1zVU,
                       label: Data.Functor.Utils.getMax_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zVU: // global
           R2 = R2;
           call Data.Functor.Utils.getMax1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.891661368 UTC

[section ""data" . Data.Functor.Utils.getMin1_closure" {
     Data.Functor.Utils.getMin1_closure:
         const Data.Functor.Utils.getMin1_info;
 },
 Data.Functor.Utils.getMin1_entry() //  [R2]
         { info_tbl: [(c1zW5,
                       label: Data.Functor.Utils.getMin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zW5: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.895064154 UTC

[section ""data" . Data.Functor.Utils.getMin_closure" {
     Data.Functor.Utils.getMin_closure:
         const Data.Functor.Utils.getMin_info;
 },
 Data.Functor.Utils.getMin_entry() //  [R2]
         { info_tbl: [(c1zWi,
                       label: Data.Functor.Utils.getMin_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zWi: // global
           R2 = R2;
           call Data.Functor.Utils.getMin1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.898681973 UTC

[section ""data" . Data.Functor.Utils.runStateL1_closure" {
     Data.Functor.Utils.runStateL1_closure:
         const Data.Functor.Utils.runStateL1_info;
 },
 Data.Functor.Utils.runStateL1_entry() //  [R2]
         { info_tbl: [(c1zWt,
                       label: Data.Functor.Utils.runStateL1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zWt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.902665613 UTC

[section ""data" . Data.Functor.Utils.runStateL_closure" {
     Data.Functor.Utils.runStateL_closure:
         const Data.Functor.Utils.runStateL_info;
 },
 Data.Functor.Utils.runStateL_entry() //  [R2]
         { info_tbl: [(c1zWE,
                       label: Data.Functor.Utils.runStateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zWE: // global
           R2 = R2;
           call Data.Functor.Utils.runStateL1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.905876389 UTC

[section ""data" . Data.Functor.Utils.runStateR1_closure" {
     Data.Functor.Utils.runStateR1_closure:
         const Data.Functor.Utils.runStateR1_info;
 },
 Data.Functor.Utils.runStateR1_entry() //  [R2]
         { info_tbl: [(c1zWP,
                       label: Data.Functor.Utils.runStateR1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zWP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.909579565 UTC

[section ""data" . Data.Functor.Utils.runStateR_closure" {
     Data.Functor.Utils.runStateR_closure:
         const Data.Functor.Utils.runStateR_info;
 },
 Data.Functor.Utils.runStateR_entry() //  [R2]
         { info_tbl: [(c1zX0,
                       label: Data.Functor.Utils.runStateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zX0: // global
           R2 = R2;
           call Data.Functor.Utils.runStateR1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.913012985 UTC

[section ""data" . Data.Functor.Utils.#._closure" {
     Data.Functor.Utils.#._closure:
         const Data.Functor.Utils.#._info;
 },
 Data.Functor.Utils.#._entry() //  [R2, R3, R4]
         { info_tbl: [(c1zXd,
                       label: Data.Functor.Utils.#._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zXd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1zXe; else goto c1zXf;
       c1zXe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Utils.#._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1zXf: // global
           I64[Sp - 16] = block_c1zXb_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1zXb() //  []
         { info_tbl: [(c1zXb,
                       label: block_c1zXb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1zXb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.918947733 UTC

[section ""cstring" . Data.Functor.Utils.$trModule4_bytes" {
     Data.Functor.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.920919474 UTC

[section ""data" . Data.Functor.Utils.$trModule3_closure" {
     Data.Functor.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.922631116 UTC

[section ""cstring" . Data.Functor.Utils.$trModule2_bytes" {
     Data.Functor.Utils.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.924318881 UTC

[section ""data" . Data.Functor.Utils.$trModule1_closure" {
     Data.Functor.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.92636747 UTC

[section ""data" . Data.Functor.Utils.$trModule_closure" {
     Data.Functor.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Utils.$trModule3_closure+1;
         const Data.Functor.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.928639769 UTC

[section ""data" . $krep_r1ynX_closure" {
     $krep_r1ynX_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.930334541 UTC

[section ""data" . $krep1_r1ynY_closure" {
     $krep1_r1ynY_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.932079128 UTC

[section ""data" . $krep2_r1ynZ_closure" {
     $krep2_r1ynZ_closure:
         const :_con_info;
         const $krep_r1ynX_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.934216519 UTC

[section ""data" . $krep3_r1yo0_closure" {
     $krep3_r1yo0_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep2_r1ynZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.935970178 UTC

[section ""data" . $krep4_r1yo1_closure" {
     $krep4_r1yo1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.937986489 UTC

[section ""data" . $krep5_r1yo2_closure" {
     $krep5_r1yo2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1ynY_closure+2;
         const $krep4_r1yo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.93965792 UTC

[section ""data" . $krep6_r1yo3_closure" {
     $krep6_r1yo3_closure:
         const :_con_info;
         const $krep1_r1ynY_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.941361515 UTC

[section ""data" . $krep7_r1yo4_closure" {
     $krep7_r1yo4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.943074751 UTC

[section ""cstring" . Data.Functor.Utils.$tcMax2_bytes" {
     Data.Functor.Utils.$tcMax2_bytes:
         I8[] [77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.944957368 UTC

[section ""data" . Data.Functor.Utils.$tcMax1_closure" {
     Data.Functor.Utils.$tcMax1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMax2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.946673286 UTC

[section ""data" . Data.Functor.Utils.$tcMax_closure" {
     Data.Functor.Utils.$tcMax_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMax1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 17055998897267803697;
         const 13070619747111935994;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.948517628 UTC

[section ""data" . $krep8_r1yo5_closure" {
     $krep8_r1yo5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMax_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.951105596 UTC

[section ""data" . Data.Functor.Utils.$tc'Max1_closure" {
     Data.Functor.Utils.$tc'Max1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep8_r1yo5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.95279059 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Max3_bytes" {
     Data.Functor.Utils.$tc'Max3_bytes:
         I8[] [39,77,97,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.954522141 UTC

[section ""data" . Data.Functor.Utils.$tc'Max2_closure" {
     Data.Functor.Utils.$tc'Max2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Max3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.956438649 UTC

[section ""data" . Data.Functor.Utils.$tc'Max_closure" {
     Data.Functor.Utils.$tc'Max_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Max2_closure+1;
         const Data.Functor.Utils.$tc'Max1_closure+4;
         const 16178335003924091205;
         const 10384293407056089504;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.958296421 UTC

[section ""cstring" . Data.Functor.Utils.$tcMin2_bytes" {
     Data.Functor.Utils.$tcMin2_bytes:
         I8[] [77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.959886507 UTC

[section ""data" . Data.Functor.Utils.$tcMin1_closure" {
     Data.Functor.Utils.$tcMin1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcMin2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.961914483 UTC

[section ""data" . Data.Functor.Utils.$tcMin_closure" {
     Data.Functor.Utils.$tcMin_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcMin1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13719831963261617173;
         const 12509304105097421826;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.963739213 UTC

[section ""data" . $krep9_r1yo6_closure" {
     $krep9_r1yo6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcMin_closure+1;
         const $krep6_r1yo3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.965668083 UTC

[section ""data" . Data.Functor.Utils.$tc'Min1_closure" {
     Data.Functor.Utils.$tc'Min1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1yo4_closure+1;
         const $krep9_r1yo6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.967613211 UTC

[section ""cstring" . Data.Functor.Utils.$tc'Min3_bytes" {
     Data.Functor.Utils.$tc'Min3_bytes:
         I8[] [39,77,105,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.970182052 UTC

[section ""data" . Data.Functor.Utils.$tc'Min2_closure" {
     Data.Functor.Utils.$tc'Min2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'Min3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.971945569 UTC

[section ""data" . Data.Functor.Utils.$tc'Min_closure" {
     Data.Functor.Utils.$tc'Min_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'Min2_closure+1;
         const Data.Functor.Utils.$tc'Min1_closure+4;
         const 3497961960072019520;
         const 14191657227527039212;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.974152565 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateL2_bytes" {
     Data.Functor.Utils.$tcStateL2_bytes:
         I8[] [83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.975865771 UTC

[section ""data" . Data.Functor.Utils.$tcStateL1_closure" {
     Data.Functor.Utils.$tcStateL1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateL2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.977887428 UTC

[section ""data" . Data.Functor.Utils.$tcStateL_closure" {
     Data.Functor.Utils.$tcStateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateL1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 8498227433031831307;
         const 6442648285908986693;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.979712045 UTC

[section ""data" . $krep10_r1yo7_closure" {
     $krep10_r1yo7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateL_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.981771866 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL1_closure" {
     Data.Functor.Utils.$tc'StateL1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep10_r1yo7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.983743661 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateL3_bytes" {
     Data.Functor.Utils.$tc'StateL3_bytes:
         I8[] [39,83,116,97,116,101,76]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.985441826 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL2_closure" {
     Data.Functor.Utils.$tc'StateL2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateL3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.987168482 UTC

[section ""data" . Data.Functor.Utils.$tc'StateL_closure" {
     Data.Functor.Utils.$tc'StateL_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateL2_closure+1;
         const Data.Functor.Utils.$tc'StateL1_closure+4;
         const 8965240648136302046;
         const 8498113279827793106;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.989292911 UTC

[section ""cstring" . Data.Functor.Utils.$tcStateR2_bytes" {
     Data.Functor.Utils.$tcStateR2_bytes:
         I8[] [83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.990969723 UTC

[section ""data" . Data.Functor.Utils.$tcStateR1_closure" {
     Data.Functor.Utils.$tcStateR1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tcStateR2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.992630222 UTC

[section ""data" . Data.Functor.Utils.$tcStateR_closure" {
     Data.Functor.Utils.$tcStateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tcStateR1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 10049146831422350196;
         const 16883721947448934294;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.994750623 UTC

[section ""data" . $krep11_r1yo8_closure" {
     $krep11_r1yo8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Utils.$tcStateR_closure+1;
         const $krep3_r1yo0_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.996392718 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR1_closure" {
     Data.Functor.Utils.$tc'StateR1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r1yo2_closure+4;
         const $krep11_r1yo8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:21.998376698 UTC

[section ""cstring" . Data.Functor.Utils.$tc'StateR3_bytes" {
     Data.Functor.Utils.$tc'StateR3_bytes:
         I8[] [39,83,116,97,116,101,82]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:22.000295424 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR2_closure" {
     Data.Functor.Utils.$tc'StateR2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Utils.$tc'StateR3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:22.001909584 UTC

[section ""data" . Data.Functor.Utils.$tc'StateR_closure" {
     Data.Functor.Utils.$tc'StateR_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Utils.$trModule_closure+1;
         const Data.Functor.Utils.$tc'StateR2_closure+1;
         const Data.Functor.Utils.$tc'StateR1_closure+4;
         const 13798701525568783897;
         const 17913645303573466967;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:22.0036983 UTC

[section ""relreadonly" . S1zzT_srt" {
     S1zzT_srt:
         const Data.Functor.Utils.$fSemigroupMax_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMax_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Functor.Utils.$fSemigroupMin_$cstimes_closure;
         const Data.Functor.Utils.$fSemigroupMin_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
 }]

