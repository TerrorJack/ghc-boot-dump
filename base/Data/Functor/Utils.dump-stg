
==================== Pre unarise: ====================
2018-03-16 15:56:19.992354185 UTC

Data.Functor.Utils.$fMonoidMax_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoa eta_s1yob eta1_s1yoc]
        case eta1_s1yoc of wild_s1yod {
          GHC.Base.Nothing -> eta_s1yob;
          GHC.Base.Just ipv_s1yoe [Occ=Once] ->
              case eta_s1yob of wild1_s1yof {
                GHC.Base.Nothing -> wild_s1yod;
                GHC.Base.Just x_s1yog [Occ=Once] ->
                    case GHC.Classes.>= $dOrd_s1yoa x_s1yog ipv_s1yoe of {
                      GHC.Types.False -> wild_s1yod;
                      GHC.Types.True -> wild1_s1yof;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1yoi ww_s1yoj ww1_s1yok]
        let {
          go_s1yol [Occ=LoopBreaker]
            :: Data.Functor.Utils.Max a_s1ydG
               -> [Data.Functor.Utils.Max a_s1ydG]
               -> Data.Functor.Utils.Max a_s1ydG
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1yoi go_s1yol] \r [b_s1yom ds1_s1yon]
                  case ds1_s1yon of {
                    [] -> b_s1yom;
                    : c_s1yop [Occ=Once] cs_s1yoq [Occ=Once] ->
                        case go_s1yol c_s1yop cs_s1yoq of wild_s1yor {
                          GHC.Base.Nothing -> b_s1yom;
                          GHC.Base.Just ipv_s1yos [Occ=Once] ->
                              case b_s1yom of wild2_s1yot {
                                GHC.Base.Nothing -> wild_s1yor;
                                GHC.Base.Just x_s1you [Occ=Once] ->
                                    case GHC.Classes.>= w_s1yoi x_s1you ipv_s1yos of {
                                      GHC.Types.False -> wild_s1yor;
                                      GHC.Types.True -> wild2_s1yot;
                                    };
                              };
                        };
                  };
        } in  go_s1yol ww_s1yoj ww1_s1yok;

Data.Functor.Utils.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Max a)
     -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1yow w1_s1yox]
        case w1_s1yox of {
          GHC.Base.:| ww1_s1yoz [Occ=Once] ww2_s1yoA [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat w_s1yow ww1_s1yoz ww2_s1yoA;
        };

Data.Functor.Utils.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1yoB]
        let {
          sat_s1yoE [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1yoB] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$cstimes $dOrd_s1yoB eta_B1; } in
        let {
          sat_s1yoD [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Max a_a1xV2)
               -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1yoB] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$csconcat
                      $dOrd_s1yoB eta_B1; } in
        let {
          sat_s1yoC [Occ=Once]
            :: Data.Functor.Utils.Max a_a1xV2
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1yoB] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1yoB eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1yoC sat_s1yoD sat_s1yoE];
Data.Functor.Utils.$fSemigroupMax_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoF $dIntegral_s1yoG]
        let {
          sat_s1yoH [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_a1xV2)
          [LclId] =
              [$dOrd_s1yoF] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1yoF;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1yoG sat_s1yoH;

Data.Functor.Utils.$fMonoidMax_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoI eta_s1yoJ]
        let {
          go_s1yoK [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Max a_X1xVO]
               -> Data.Functor.Utils.Max a_X1xVO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1yoI go_s1yoK] \r [ds_s1yoL]
                  case ds_s1yoL of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1yoN [Occ=Once*] ys_s1yoO [Occ=Once] ->
                        case go_s1yoK ys_s1yoO of wild1_s1yoP {
                          GHC.Base.Nothing -> y_s1yoN;
                          GHC.Base.Just ipv_s1yoQ [Occ=Once] ->
                              case y_s1yoN of wild2_s1yoR {
                                GHC.Base.Nothing -> wild1_s1yoP;
                                GHC.Base.Just x_s1yoS [Occ=Once] ->
                                    case GHC.Classes.>= $dOrd_s1yoI x_s1yoS ipv_s1yoQ of {
                                      GHC.Types.False -> wild1_s1yoP;
                                      GHC.Types.True -> wild2_s1yoR;
                                    };
                              };
                        };
                  };
        } in  go_s1yoK eta_s1yoJ;

Data.Functor.Utils.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1yoU]
        let {
          sat_s1yoX [Occ=Once]
            :: [Data.Functor.Utils.Max a_X1xVM]
               -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1yoU] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$cmconcat $dOrd_s1yoU eta_B1; } in
        let {
          sat_s1yoW [Occ=Once]
            :: Data.Functor.Utils.Max a_X1xVM
               -> Data.Functor.Utils.Max a_X1xVM -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1yoU] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1yoU eta_B2 eta_B1; } in
        let {
          sat_s1yoV [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_X1xVM)
          [LclId] =
              [$dOrd_s1yoU] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1yoU;
        } in 
          GHC.Base.C:Monoid [sat_s1yoV GHC.Base.Nothing sat_s1yoW sat_s1yoX];

Data.Functor.Utils.$fMonoidMin_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoY eta_s1yoZ eta1_s1yp0]
        case eta1_s1yp0 of wild_s1yp1 {
          GHC.Base.Nothing -> eta_s1yoZ;
          GHC.Base.Just ipv_s1yp2 [Occ=Once] ->
              case eta_s1yoZ of wild1_s1yp3 {
                GHC.Base.Nothing -> wild_s1yp1;
                GHC.Base.Just x_s1yp4 [Occ=Once] ->
                    case GHC.Classes.<= $dOrd_s1yoY x_s1yp4 ipv_s1yp2 of {
                      GHC.Types.False -> wild_s1yp1;
                      GHC.Types.True -> wild1_s1yp3;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1yp6 ww_s1yp7 ww1_s1yp8]
        let {
          go_s1yp9 [Occ=LoopBreaker]
            :: Data.Functor.Utils.Min a_s1ydZ
               -> [Data.Functor.Utils.Min a_s1ydZ]
               -> Data.Functor.Utils.Min a_s1ydZ
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1yp6 go_s1yp9] \r [b_s1ypa ds1_s1ypb]
                  case ds1_s1ypb of {
                    [] -> b_s1ypa;
                    : c_s1ypd [Occ=Once] cs_s1ype [Occ=Once] ->
                        case go_s1yp9 c_s1ypd cs_s1ype of wild_s1ypf {
                          GHC.Base.Nothing -> b_s1ypa;
                          GHC.Base.Just ipv_s1ypg [Occ=Once] ->
                              case b_s1ypa of wild2_s1yph {
                                GHC.Base.Nothing -> wild_s1ypf;
                                GHC.Base.Just x_s1ypi [Occ=Once] ->
                                    case GHC.Classes.<= w_s1yp6 x_s1ypi ipv_s1ypg of {
                                      GHC.Types.False -> wild_s1ypf;
                                      GHC.Types.True -> wild2_s1yph;
                                    };
                              };
                        };
                  };
        } in  go_s1yp9 ww_s1yp7 ww1_s1yp8;

Data.Functor.Utils.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Min a)
     -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1ypk w1_s1ypl]
        case w1_s1ypl of {
          GHC.Base.:| ww1_s1ypn [Occ=Once] ww2_s1ypo [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat1 w_s1ypk ww1_s1ypn ww2_s1ypo;
        };

Data.Functor.Utils.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1ypp]
        let {
          sat_s1yps [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1ypp] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$cstimes $dOrd_s1ypp eta_B1; } in
        let {
          sat_s1ypr [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Min a_a1xTV)
               -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1ypp] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$csconcat
                      $dOrd_s1ypp eta_B1; } in
        let {
          sat_s1ypq [Occ=Once]
            :: Data.Functor.Utils.Min a_a1xTV
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1ypp] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1ypp eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1ypq sat_s1ypr sat_s1yps];
Data.Functor.Utils.$fSemigroupMin_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1ypt $dIntegral_s1ypu]
        let {
          sat_s1ypv [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_a1xTV)
          [LclId] =
              [$dOrd_s1ypt] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1ypt;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1ypu sat_s1ypv;

Data.Functor.Utils.$fMonoidMin_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1ypw eta_s1ypx]
        let {
          go_s1ypy [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Min a_X1xUO]
               -> Data.Functor.Utils.Min a_X1xUO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1ypw go_s1ypy] \r [ds_s1ypz]
                  case ds_s1ypz of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1ypB [Occ=Once*] ys_s1ypC [Occ=Once] ->
                        case go_s1ypy ys_s1ypC of wild1_s1ypD {
                          GHC.Base.Nothing -> y_s1ypB;
                          GHC.Base.Just ipv_s1ypE [Occ=Once] ->
                              case y_s1ypB of wild2_s1ypF {
                                GHC.Base.Nothing -> wild1_s1ypD;
                                GHC.Base.Just x_s1ypG [Occ=Once] ->
                                    case GHC.Classes.<= $dOrd_s1ypw x_s1ypG ipv_s1ypE of {
                                      GHC.Types.False -> wild1_s1ypD;
                                      GHC.Types.True -> wild2_s1ypF;
                                    };
                              };
                        };
                  };
        } in  go_s1ypy eta_s1ypx;

Data.Functor.Utils.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1ypI]
        let {
          sat_s1ypL [Occ=Once]
            :: [Data.Functor.Utils.Min a_X1xUM]
               -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1ypI] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$cmconcat $dOrd_s1ypI eta_B1; } in
        let {
          sat_s1ypK [Occ=Once]
            :: Data.Functor.Utils.Min a_X1xUM
               -> Data.Functor.Utils.Min a_X1xUM -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1ypI] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1ypI eta_B2 eta_B1; } in
        let {
          sat_s1ypJ [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_X1xUM)
          [LclId] =
              [$dOrd_s1ypI] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1ypI;
        } in 
          GHC.Base.C:Monoid [sat_s1ypJ GHC.Base.Nothing sat_s1ypK sat_s1ypL];

Data.Functor.Utils.$fFunctorStateL2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1ypM ds_s1ypN s1_s1ypO]
        let {
          ds1_s1ypP [Dmd=<L,U(1*U,1*U)>] :: (s_a1xSQ, a_a1xSU)
          [LclId] =
              [ds_s1ypN s1_s1ypO] \u [] ds_s1ypN s1_s1ypO; } in
        let {
          sat_s1ypY [Occ=Once] :: b_a1xSV
          [LclId] =
              [f_s1ypM ds1_s1ypP] \u []
                  let {
                    sat_s1ypX [Occ=Once] :: a_a1xSU
                    [LclId] =
                        [ds1_s1ypP] \u []
                            case ds1_s1ypP of {
                              (,) _ [Occ=Dead] v_s1ypW [Occ=Once] -> v_s1ypW;
                            };
                  } in  f_s1ypM sat_s1ypX; } in
        let {
          sat_s1ypT [Occ=Once] :: s_a1xSQ
          [LclId] =
              [ds1_s1ypP] \u []
                  case ds1_s1ypP of {
                    (,) s'_s1ypR [Occ=Once] _ [Occ=Dead] -> s'_s1ypR;
                  };
        } in  (,) [sat_s1ypT sat_s1ypY];

Data.Functor.Utils.$fFunctorStateL1
  :: forall b s a. a -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1ypZ ds_s1yq0 s1_s1yq1]
        let {
          sat_s1yq5 [Occ=Once] :: s_X1xUk
          [LclId] =
              [ds_s1yq0 s1_s1yq1] \u []
                  case ds_s1yq0 s1_s1yq1 of {
                    (,) s'_s1yq3 [Occ=Once] _ [Occ=Dead] -> s'_s1yq3;
                  };
        } in  (,) [sat_s1yq5 x_s1ypZ];

Data.Functor.Utils.$fFunctorStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateL2
                                       Data.Functor.Utils.$fFunctorStateL1];

Data.Functor.Utils.$fApplicativeStateL3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1yq6 w1_s1yq7 w2_s1yq8 w3_s1yq9]
        let {
          ds_s1yqa [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, a_s1yeh)
          [LclId] =
              [w1_s1yq7 w3_s1yq9] \u [] w1_s1yq7 w3_s1yq9; } in
        let {
          ds1_s1yqb [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, b_s1yei)
          [LclId] =
              [w2_s1yq8 ds_s1yqa] \u []
                  let {
                    sat_s1yqf [Occ=Once] :: s_s1yeg
                    [LclId] =
                        [ds_s1yqa] \u []
                            case ds_s1yqa of {
                              (,) s'_s1yqd [Occ=Once] _ [Occ=Dead] -> s'_s1yqd;
                            };
                  } in  w2_s1yq8 sat_s1yqf; } in
        let {
          sat_s1yqs [Occ=Once] :: c_s1yej
          [LclId] =
              [w_s1yq6 ds_s1yqa ds1_s1yqb] \u []
                  let {
                    sat_s1yqr [Occ=Once] :: b_s1yei
                    [LclId] =
                        [ds1_s1yqb] \u []
                            case ds1_s1yqb of {
                              (,) _ [Occ=Dead] y_s1yqq [Occ=Once] -> y_s1yqq;
                            }; } in
                  let {
                    sat_s1yqn [Occ=Once] :: a_s1yeh
                    [LclId] =
                        [ds_s1yqa] \u []
                            case ds_s1yqa of {
                              (,) _ [Occ=Dead] x_s1yqm [Occ=Once] -> x_s1yqm;
                            };
                  } in  w_s1yq6 sat_s1yqn sat_s1yqr; } in
        let {
          sat_s1yqj [Occ=Once] :: s_s1yeg
          [LclId] =
              [ds1_s1yqb] \u []
                  case ds1_s1yqb of {
                    (,) s''_s1yqh [Occ=Once] _ [Occ=Dead] -> s''_s1yqh;
                  };
        } in  (,) [sat_s1yqj sat_s1yqs];

Data.Functor.Utils.$fApplicativeStateL4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateL s (a -> b)
     -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1yqt w1_s1yqu w2_s1yqv]
        let {
          ds_s1yqw [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yes, a_s1yet -> b_s1yeu)
          [LclId] =
              [w_s1yqt w2_s1yqv] \u [] w_s1yqt w2_s1yqv; } in
        let {
          ds1_s1yqx [Dmd=<L,U(1*U,1*U)>] :: (s_s1yes, a_s1yet)
          [LclId] =
              [w1_s1yqu ds_s1yqw] \u []
                  let {
                    sat_s1yqB [Occ=Once] :: s_s1yes
                    [LclId] =
                        [ds_s1yqw] \u []
                            case ds_s1yqw of {
                              (,) s'_s1yqz [Occ=Once] _ [Occ=Dead] -> s'_s1yqz;
                            };
                  } in  w1_s1yqu sat_s1yqB; } in
        let {
          sat_s1yqN [Occ=Once] :: b_s1yeu
          [LclId] =
              [ds_s1yqw ds1_s1yqx] \u []
                  case ds_s1yqw of {
                    (,) _ [Occ=Dead] f_s1yqI [Occ=Once!] ->
                        let {
                          sat_s1yqM [Occ=Once] :: a_s1yet
                          [LclId] =
                              [ds1_s1yqx] \u []
                                  case ds1_s1yqx of {
                                    (,) _ [Occ=Dead] v_s1yqL [Occ=Once] -> v_s1yqL;
                                  };
                        } in  f_s1yqI sat_s1yqM;
                  }; } in
        let {
          sat_s1yqF [Occ=Once] :: s_s1yes
          [LclId] =
              [ds1_s1yqx] \u []
                  case ds1_s1yqx of {
                    (,) s''_s1yqD [Occ=Once] _ [Occ=Dead] -> s''_s1yqD;
                  };
        } in  (,) [sat_s1yqF sat_s1yqN];

Data.Functor.Utils.$fApplicativeStateL5
  :: forall s a. a -> s -> (s, a)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><L,U>m, Unf=OtherCon []] =
    [] \r [x_s1yqO s1_s1yqP] (,) [s1_s1yqP x_s1yqO];

Data.Functor.Utils.$fApplicativeStateL2
  :: forall b a s.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1yqQ a2_s1yqR eta_s1yqS]
        let {
          ds_s1yqT [Dmd=<L,U(1*U,1*U)>] :: (s_X1xSV, b_a1xSy)
          [LclId] =
              [a1_s1yqQ a2_s1yqR eta_s1yqS] \u []
                  let {
                    sat_s1yqX [Occ=Once] :: s_X1xSV
                    [LclId] =
                        [a1_s1yqQ eta_s1yqS] \u []
                            case a1_s1yqQ eta_s1yqS of {
                              (,) s'_s1yqV [Occ=Once] _ [Occ=Dead] -> s'_s1yqV;
                            };
                  } in  a2_s1yqR sat_s1yqX; } in
        let {
          sat_s1yr5 [Occ=Once] :: b_a1xSy
          [LclId] =
              [ds_s1yqT] \u []
                  case ds_s1yqT of {
                    (,) _ [Occ=Dead] v_s1yr4 [Occ=Once] -> v_s1yr4;
                  }; } in
        let {
          sat_s1yr1 [Occ=Once] :: s_X1xSV
          [LclId] =
              [ds_s1yqT] \u []
                  case ds_s1yqT of {
                    (,) s''_s1yqZ [Occ=Once] _ [Occ=Dead] -> s''_s1yqZ;
                  };
        } in  (,) [sat_s1yr1 sat_s1yr5];

Data.Functor.Utils.$fApplicativeStateL1
  :: forall a s b.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1yr6 ds1_s1yr7 s1_s1yr8]
        let {
          ds2_s1yr9 [Dmd=<L,U(1*U,1*U)>] :: (s_X1xST, a_a1xSH)
          [LclId] =
              [ds_s1yr6 s1_s1yr8] \u [] ds_s1yr6 s1_s1yr8; } in
        let {
          sat_s1yrl [Occ=Once] :: a_a1xSH
          [LclId] =
              [ds2_s1yr9] \u []
                  case ds2_s1yr9 of {
                    (,) _ [Occ=Dead] x_s1yrk [Occ=Once] -> x_s1yrk;
                  }; } in
        let {
          sat_s1yrh [Occ=Once] :: s_X1xST
          [LclId] =
              [ds1_s1yr7 ds2_s1yr9] \u []
                  let {
                    sat_s1yrd [Occ=Once] :: s_X1xST
                    [LclId] =
                        [ds2_s1yr9] \u []
                            case ds2_s1yr9 of {
                              (,) s'_s1yrb [Occ=Once] _ [Occ=Dead] -> s'_s1yrb;
                            };
                  } in 
                    case ds1_s1yr7 sat_s1yrd of {
                      (,) s''_s1yrf [Occ=Once] _ [Occ=Dead] -> s''_s1yrf;
                    };
        } in  (,) [sat_s1yrh sat_s1yrl];

Data.Functor.Utils.$fApplicativeStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateL
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateL4
                                           Data.Functor.Utils.$fApplicativeStateL3
                                           Data.Functor.Utils.$fApplicativeStateL2
                                           Data.Functor.Utils.$fApplicativeStateL1];

Data.Functor.Utils.$fFunctorStateR2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1yrm ds_s1yrn s1_s1yro]
        let {
          ds1_s1yrp [Dmd=<L,U(1*U,1*U)>] :: (s_a1xQk, a_a1xQo)
          [LclId] =
              [ds_s1yrn s1_s1yro] \u [] ds_s1yrn s1_s1yro; } in
        let {
          sat_s1yry [Occ=Once] :: b_a1xQp
          [LclId] =
              [f_s1yrm ds1_s1yrp] \u []
                  let {
                    sat_s1yrx [Occ=Once] :: a_a1xQo
                    [LclId] =
                        [ds1_s1yrp] \u []
                            case ds1_s1yrp of {
                              (,) _ [Occ=Dead] v_s1yrw [Occ=Once] -> v_s1yrw;
                            };
                  } in  f_s1yrm sat_s1yrx; } in
        let {
          sat_s1yrt [Occ=Once] :: s_a1xQk
          [LclId] =
              [ds1_s1yrp] \u []
                  case ds1_s1yrp of {
                    (,) s'_s1yrr [Occ=Once] _ [Occ=Dead] -> s'_s1yrr;
                  };
        } in  (,) [sat_s1yrt sat_s1yry];

Data.Functor.Utils.$fFunctorStateR1
  :: forall b s a. a -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1yrz ds_s1yrA s1_s1yrB]
        let {
          sat_s1yrF [Occ=Once] :: s_X1xSo
          [LclId] =
              [ds_s1yrA s1_s1yrB] \u []
                  case ds_s1yrA s1_s1yrB of {
                    (,) s'_s1yrD [Occ=Once] _ [Occ=Dead] -> s'_s1yrD;
                  };
        } in  (,) [sat_s1yrF x_s1yrz];

Data.Functor.Utils.$fFunctorStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateR2
                                       Data.Functor.Utils.$fFunctorStateR1];

Data.Functor.Utils.$fApplicativeStateR3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1yrG w1_s1yrH w2_s1yrI w3_s1yrJ]
        let {
          ds_s1yrK [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, b_s1yeE)
          [LclId] =
              [w2_s1yrI w3_s1yrJ] \u [] w2_s1yrI w3_s1yrJ; } in
        let {
          ds1_s1yrL [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, a_s1yeD)
          [LclId] =
              [w1_s1yrH ds_s1yrK] \u []
                  let {
                    sat_s1yrP [Occ=Once] :: s_s1yeC
                    [LclId] =
                        [ds_s1yrK] \u []
                            case ds_s1yrK of {
                              (,) s'_s1yrN [Occ=Once] _ [Occ=Dead] -> s'_s1yrN;
                            };
                  } in  w1_s1yrH sat_s1yrP; } in
        let {
          sat_s1ys2 [Occ=Once] :: c_s1yeF
          [LclId] =
              [w_s1yrG ds_s1yrK ds1_s1yrL] \u []
                  let {
                    sat_s1ys1 [Occ=Once] :: b_s1yeE
                    [LclId] =
                        [ds_s1yrK] \u []
                            case ds_s1yrK of {
                              (,) _ [Occ=Dead] y_s1ys0 [Occ=Once] -> y_s1ys0;
                            }; } in
                  let {
                    sat_s1yrX [Occ=Once] :: a_s1yeD
                    [LclId] =
                        [ds1_s1yrL] \u []
                            case ds1_s1yrL of {
                              (,) _ [Occ=Dead] x_s1yrW [Occ=Once] -> x_s1yrW;
                            };
                  } in  w_s1yrG sat_s1yrX sat_s1ys1; } in
        let {
          sat_s1yrT [Occ=Once] :: s_s1yeC
          [LclId] =
              [ds1_s1yrL] \u []
                  case ds1_s1yrL of {
                    (,) s''_s1yrR [Occ=Once] _ [Occ=Dead] -> s''_s1yrR;
                  };
        } in  (,) [sat_s1yrT sat_s1ys2];

Data.Functor.Utils.$fApplicativeStateR4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateR s (a -> b)
     -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1ys3 w1_s1ys4 w2_s1ys5]
        let {
          ds_s1ys6 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeO, a_s1yeP)
          [LclId] =
              [w1_s1ys4 w2_s1ys5] \u [] w1_s1ys4 w2_s1ys5; } in
        let {
          ds1_s1ys7 [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yeO, a_s1yeP -> b_s1yeQ)
          [LclId] =
              [w_s1ys3 ds_s1ys6] \u []
                  let {
                    sat_s1ysb [Occ=Once] :: s_s1yeO
                    [LclId] =
                        [ds_s1ys6] \u []
                            case ds_s1ys6 of {
                              (,) s'_s1ys9 [Occ=Once] _ [Occ=Dead] -> s'_s1ys9;
                            };
                  } in  w_s1ys3 sat_s1ysb; } in
        let {
          sat_s1ysn [Occ=Once] :: b_s1yeQ
          [LclId] =
              [ds_s1ys6 ds1_s1ys7] \u []
                  case ds1_s1ys7 of {
                    (,) _ [Occ=Dead] f_s1ysi [Occ=Once!] ->
                        let {
                          sat_s1ysm [Occ=Once] :: a_s1yeP
                          [LclId] =
                              [ds_s1ys6] \u []
                                  case ds_s1ys6 of {
                                    (,) _ [Occ=Dead] v_s1ysl [Occ=Once] -> v_s1ysl;
                                  };
                        } in  f_s1ysi sat_s1ysm;
                  }; } in
        let {
          sat_s1ysf [Occ=Once] :: s_s1yeO
          [LclId] =
              [ds1_s1ys7] \u []
                  case ds1_s1ys7 of {
                    (,) s''_s1ysd [Occ=Once] _ [Occ=Dead] -> s''_s1ysd;
                  };
        } in  (,) [sat_s1ysf sat_s1ysn];

Data.Functor.Utils.$fApplicativeStateR2
  :: forall b a s.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1yso a2_s1ysp eta_s1ysq]
        let {
          ds_s1ysr [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQD, b_a1xPW)
          [LclId] =
              [a2_s1ysp eta_s1ysq] \u [] a2_s1ysp eta_s1ysq; } in
        let {
          sat_s1ysD [Occ=Once] :: b_a1xPW
          [LclId] =
              [ds_s1ysr] \u []
                  case ds_s1ysr of {
                    (,) _ [Occ=Dead] v_s1ysC [Occ=Once] -> v_s1ysC;
                  }; } in
        let {
          sat_s1ysz [Occ=Once] :: s_X1xQD
          [LclId] =
              [a1_s1yso ds_s1ysr] \u []
                  let {
                    sat_s1ysv [Occ=Once] :: s_X1xQD
                    [LclId] =
                        [ds_s1ysr] \u []
                            case ds_s1ysr of {
                              (,) s'_s1yst [Occ=Once] _ [Occ=Dead] -> s'_s1yst;
                            };
                  } in 
                    case a1_s1yso sat_s1ysv of {
                      (,) s'_s1ysx [Occ=Once] _ [Occ=Dead] -> s'_s1ysx;
                    };
        } in  (,) [sat_s1ysz sat_s1ysD];

Data.Functor.Utils.$fApplicativeStateR1
  :: forall a s b.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1ysE ds1_s1ysF s1_s1ysG]
        let {
          ds2_s1ysH [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQB, a_a1xQb)
          [LclId] =
              [ds_s1ysE ds1_s1ysF s1_s1ysG] \u []
                  let {
                    sat_s1ysL [Occ=Once] :: s_X1xQB
                    [LclId] =
                        [ds1_s1ysF s1_s1ysG] \u []
                            case ds1_s1ysF s1_s1ysG of {
                              (,) s'_s1ysJ [Occ=Once] _ [Occ=Dead] -> s'_s1ysJ;
                            };
                  } in  ds_s1ysE sat_s1ysL; } in
        let {
          sat_s1ysT [Occ=Once] :: a_a1xQb
          [LclId] =
              [ds2_s1ysH] \u []
                  case ds2_s1ysH of {
                    (,) _ [Occ=Dead] x_s1ysS [Occ=Once] -> x_s1ysS;
                  }; } in
        let {
          sat_s1ysP [Occ=Once] :: s_X1xQB
          [LclId] =
              [ds2_s1ysH] \u []
                  case ds2_s1ysH of {
                    (,) s''_s1ysN [Occ=Once] _ [Occ=Dead] -> s''_s1ysN;
                  };
        } in  (,) [sat_s1ysP sat_s1ysT];

Data.Functor.Utils.$fApplicativeStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateR
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateR4
                                           Data.Functor.Utils.$fApplicativeStateR3
                                           Data.Functor.Utils.$fApplicativeStateR2
                                           Data.Functor.Utils.$fApplicativeStateR1];

Data.Functor.Utils.getMax1
  :: forall a. Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysU] ds_s1ysU;

Data.Functor.Utils.getMax
  :: forall a. Data.Functor.Utils.Max a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMax1 eta_B1;

Data.Functor.Utils.getMin1
  :: forall a. Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysV] ds_s1ysV;

Data.Functor.Utils.getMin
  :: forall a. Data.Functor.Utils.Min a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMin1 eta_B1;

Data.Functor.Utils.runStateL1
  :: forall s a.
     Data.Functor.Utils.StateL s a -> Data.Functor.Utils.StateL s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysW] ds_s1ysW;

Data.Functor.Utils.runStateL
  :: forall s a. Data.Functor.Utils.StateL s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateL1 eta_B1;

Data.Functor.Utils.runStateR1
  :: forall s a.
     Data.Functor.Utils.StateR s a -> Data.Functor.Utils.StateR s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysX] ds_s1ysX;

Data.Functor.Utils.runStateR
  :: forall s a. Data.Functor.Utils.StateR s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateR1 eta_B1;

Data.Functor.Utils.#. [InlPrag=INLINE (sat-args=1)]
  :: forall b c a.
     GHC.Types.Coercible b c =>
     (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dCoercible_s1ysY eta_s1ysZ eta1_s1yt0]
        case GHC.Types.coercible_sel $dCoercible_s1ysY of {
          __DEFAULT -> eta1_s1yt0;
        };

Data.Functor.Utils.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Utils.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule4];

Data.Functor.Utils.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Utils"#;

Data.Functor.Utils.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule2];

Data.Functor.Utils.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Utils.$trModule3
                                     Data.Functor.Utils.$trModule1];

$krep_r1ynX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r1ynY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r1ynZ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1ynX GHC.Types.[]];

$krep3_r1yo0 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY $krep2_r1ynZ];

$krep4_r1yo1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep3_r1yo0];

$krep5_r1yo2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1ynY $krep4_r1yo1];

$krep6_r1yo3 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY GHC.Types.[]];

$krep7_r1yo4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep6_r1yo3];

Data.Functor.Utils.$tcMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Functor.Utils.$tcMax1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMax2];

Data.Functor.Utils.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17055998897267803697##
                                    13070619747111935994##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMax1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep8_r1yo5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMax
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep8_r1yo5];

Data.Functor.Utils.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Functor.Utils.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Max3];

Data.Functor.Utils.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16178335003924091205##
                                    10384293407056089504##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Max2
                                    1#
                                    Data.Functor.Utils.$tc'Max1];

Data.Functor.Utils.$tcMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Functor.Utils.$tcMin1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMin2];

Data.Functor.Utils.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13719831963261617173##
                                    12509304105097421826##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMin1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r1yo6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMin
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep9_r1yo6];

Data.Functor.Utils.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Functor.Utils.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Min3];

Data.Functor.Utils.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3497961960072019520##
                                    14191657227527039212##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Min2
                                    1#
                                    Data.Functor.Utils.$tc'Min1];

Data.Functor.Utils.$tcStateL2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateL"#;

Data.Functor.Utils.$tcStateL1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateL2];

Data.Functor.Utils.$tcStateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8498227433031831307##
                                    6442648285908986693##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateL1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep10_r1yo7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateL
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep10_r1yo7];

Data.Functor.Utils.$tc'StateL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateL"#;

Data.Functor.Utils.$tc'StateL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateL3];

Data.Functor.Utils.$tc'StateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8965240648136302046##
                                    8498113279827793106##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateL2
                                    2#
                                    Data.Functor.Utils.$tc'StateL1];

Data.Functor.Utils.$tcStateR2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateR"#;

Data.Functor.Utils.$tcStateR1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateR2];

Data.Functor.Utils.$tcStateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10049146831422350196##
                                    16883721947448934294##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateR1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep11_r1yo8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateR
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep11_r1yo8];

Data.Functor.Utils.$tc'StateR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateR"#;

Data.Functor.Utils.$tc'StateR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateR3];

Data.Functor.Utils.$tc'StateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13798701525568783897##
                                    17913645303573466967##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateR2
                                    2#
                                    Data.Functor.Utils.$tc'StateR1];


==================== STG syntax: ====================
2018-03-16 15:56:20.01079185 UTC

Data.Functor.Utils.$fMonoidMax_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoa eta_s1yob eta1_s1yoc]
        case eta1_s1yoc of wild_s1yod {
          GHC.Base.Nothing -> eta_s1yob;
          GHC.Base.Just ipv_s1yoe [Occ=Once] ->
              case eta_s1yob of wild1_s1yof {
                GHC.Base.Nothing -> wild_s1yod;
                GHC.Base.Just x_s1yog [Occ=Once] ->
                    case GHC.Classes.>= $dOrd_s1yoa x_s1yog ipv_s1yoe of {
                      GHC.Types.False -> wild_s1yod;
                      GHC.Types.True -> wild1_s1yof;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1yoi ww_s1yoj ww1_s1yok]
        let {
          go_s1yol [Occ=LoopBreaker]
            :: Data.Functor.Utils.Max a_s1ydG
               -> [Data.Functor.Utils.Max a_s1ydG]
               -> Data.Functor.Utils.Max a_s1ydG
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1yoi go_s1yol] \r [b_s1yom ds1_s1yon]
                  case ds1_s1yon of {
                    [] -> b_s1yom;
                    : c_s1yop [Occ=Once] cs_s1yoq [Occ=Once] ->
                        case go_s1yol c_s1yop cs_s1yoq of wild_s1yor {
                          GHC.Base.Nothing -> b_s1yom;
                          GHC.Base.Just ipv_s1yos [Occ=Once] ->
                              case b_s1yom of wild2_s1yot {
                                GHC.Base.Nothing -> wild_s1yor;
                                GHC.Base.Just x_s1you [Occ=Once] ->
                                    case GHC.Classes.>= w_s1yoi x_s1you ipv_s1yos of {
                                      GHC.Types.False -> wild_s1yor;
                                      GHC.Types.True -> wild2_s1yot;
                                    };
                              };
                        };
                  };
        } in  go_s1yol ww_s1yoj ww1_s1yok;

Data.Functor.Utils.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Max a)
     -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1yow w1_s1yox]
        case w1_s1yox of {
          GHC.Base.:| ww1_s1yoz [Occ=Once] ww2_s1yoA [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat w_s1yow ww1_s1yoz ww2_s1yoA;
        };

Data.Functor.Utils.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1yoB]
        let {
          sat_s1yoE [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1yoB] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$cstimes $dOrd_s1yoB eta_B1; } in
        let {
          sat_s1yoD [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Max a_a1xV2)
               -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1yoB] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$csconcat
                      $dOrd_s1yoB eta_B1; } in
        let {
          sat_s1yoC [Occ=Once]
            :: Data.Functor.Utils.Max a_a1xV2
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1yoB] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1yoB eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1yoC sat_s1yoD sat_s1yoE];
Data.Functor.Utils.$fSemigroupMax_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoF $dIntegral_s1yoG]
        let {
          sat_s1yoH [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_a1xV2)
          [LclId] =
              [$dOrd_s1yoF] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1yoF;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1yoG sat_s1yoH;

Data.Functor.Utils.$fMonoidMax_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoI eta_s1yoJ]
        let {
          go_s1yoK [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Max a_X1xVO]
               -> Data.Functor.Utils.Max a_X1xVO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1yoI go_s1yoK] \r [ds_s1yoL]
                  case ds_s1yoL of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1yoN [Occ=Once*] ys_s1yoO [Occ=Once] ->
                        case go_s1yoK ys_s1yoO of wild1_s1yoP {
                          GHC.Base.Nothing -> y_s1yoN;
                          GHC.Base.Just ipv_s1yoQ [Occ=Once] ->
                              case y_s1yoN of wild2_s1yoR {
                                GHC.Base.Nothing -> wild1_s1yoP;
                                GHC.Base.Just x_s1yoS [Occ=Once] ->
                                    case GHC.Classes.>= $dOrd_s1yoI x_s1yoS ipv_s1yoQ of {
                                      GHC.Types.False -> wild1_s1yoP;
                                      GHC.Types.True -> wild2_s1yoR;
                                    };
                              };
                        };
                  };
        } in  go_s1yoK eta_s1yoJ;

Data.Functor.Utils.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1yoU]
        let {
          sat_s1yoX [Occ=Once]
            :: [Data.Functor.Utils.Max a_X1xVM]
               -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1yoU] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$cmconcat $dOrd_s1yoU eta_B1; } in
        let {
          sat_s1yoW [Occ=Once]
            :: Data.Functor.Utils.Max a_X1xVM
               -> Data.Functor.Utils.Max a_X1xVM -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1yoU] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1yoU eta_B2 eta_B1; } in
        let {
          sat_s1yoV [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_X1xVM)
          [LclId] =
              [$dOrd_s1yoU] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1yoU;
        } in 
          GHC.Base.C:Monoid [sat_s1yoV GHC.Base.Nothing sat_s1yoW sat_s1yoX];

Data.Functor.Utils.$fMonoidMin_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1yoY eta_s1yoZ eta1_s1yp0]
        case eta1_s1yp0 of wild_s1yp1 {
          GHC.Base.Nothing -> eta_s1yoZ;
          GHC.Base.Just ipv_s1yp2 [Occ=Once] ->
              case eta_s1yoZ of wild1_s1yp3 {
                GHC.Base.Nothing -> wild_s1yp1;
                GHC.Base.Just x_s1yp4 [Occ=Once] ->
                    case GHC.Classes.<= $dOrd_s1yoY x_s1yp4 ipv_s1yp2 of {
                      GHC.Types.False -> wild_s1yp1;
                      GHC.Types.True -> wild1_s1yp3;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1yp6 ww_s1yp7 ww1_s1yp8]
        let {
          go_s1yp9 [Occ=LoopBreaker]
            :: Data.Functor.Utils.Min a_s1ydZ
               -> [Data.Functor.Utils.Min a_s1ydZ]
               -> Data.Functor.Utils.Min a_s1ydZ
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1yp6 go_s1yp9] \r [b_s1ypa ds1_s1ypb]
                  case ds1_s1ypb of {
                    [] -> b_s1ypa;
                    : c_s1ypd [Occ=Once] cs_s1ype [Occ=Once] ->
                        case go_s1yp9 c_s1ypd cs_s1ype of wild_s1ypf {
                          GHC.Base.Nothing -> b_s1ypa;
                          GHC.Base.Just ipv_s1ypg [Occ=Once] ->
                              case b_s1ypa of wild2_s1yph {
                                GHC.Base.Nothing -> wild_s1ypf;
                                GHC.Base.Just x_s1ypi [Occ=Once] ->
                                    case GHC.Classes.<= w_s1yp6 x_s1ypi ipv_s1ypg of {
                                      GHC.Types.False -> wild_s1ypf;
                                      GHC.Types.True -> wild2_s1yph;
                                    };
                              };
                        };
                  };
        } in  go_s1yp9 ww_s1yp7 ww1_s1yp8;

Data.Functor.Utils.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Min a)
     -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1ypk w1_s1ypl]
        case w1_s1ypl of {
          GHC.Base.:| ww1_s1ypn [Occ=Once] ww2_s1ypo [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat1 w_s1ypk ww1_s1ypn ww2_s1ypo;
        };

Data.Functor.Utils.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1ypp]
        let {
          sat_s1yps [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1ypp] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$cstimes $dOrd_s1ypp eta_B1; } in
        let {
          sat_s1ypr [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Min a_a1xTV)
               -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1ypp] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$csconcat
                      $dOrd_s1ypp eta_B1; } in
        let {
          sat_s1ypq [Occ=Once]
            :: Data.Functor.Utils.Min a_a1xTV
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1ypp] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1ypp eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1ypq sat_s1ypr sat_s1yps];
Data.Functor.Utils.$fSemigroupMin_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1ypt $dIntegral_s1ypu]
        let {
          sat_s1ypv [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_a1xTV)
          [LclId] =
              [$dOrd_s1ypt] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1ypt;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1ypu sat_s1ypv;

Data.Functor.Utils.$fMonoidMin_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1ypw eta_s1ypx]
        let {
          go_s1ypy [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Min a_X1xUO]
               -> Data.Functor.Utils.Min a_X1xUO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1ypw go_s1ypy] \r [ds_s1ypz]
                  case ds_s1ypz of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1ypB [Occ=Once*] ys_s1ypC [Occ=Once] ->
                        case go_s1ypy ys_s1ypC of wild1_s1ypD {
                          GHC.Base.Nothing -> y_s1ypB;
                          GHC.Base.Just ipv_s1ypE [Occ=Once] ->
                              case y_s1ypB of wild2_s1ypF {
                                GHC.Base.Nothing -> wild1_s1ypD;
                                GHC.Base.Just x_s1ypG [Occ=Once] ->
                                    case GHC.Classes.<= $dOrd_s1ypw x_s1ypG ipv_s1ypE of {
                                      GHC.Types.False -> wild1_s1ypD;
                                      GHC.Types.True -> wild2_s1ypF;
                                    };
                              };
                        };
                  };
        } in  go_s1ypy eta_s1ypx;

Data.Functor.Utils.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1ypI]
        let {
          sat_s1ypL [Occ=Once]
            :: [Data.Functor.Utils.Min a_X1xUM]
               -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1ypI] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$cmconcat $dOrd_s1ypI eta_B1; } in
        let {
          sat_s1ypK [Occ=Once]
            :: Data.Functor.Utils.Min a_X1xUM
               -> Data.Functor.Utils.Min a_X1xUM -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1ypI] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1ypI eta_B2 eta_B1; } in
        let {
          sat_s1ypJ [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_X1xUM)
          [LclId] =
              [$dOrd_s1ypI] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1ypI;
        } in 
          GHC.Base.C:Monoid [sat_s1ypJ GHC.Base.Nothing sat_s1ypK sat_s1ypL];

Data.Functor.Utils.$fFunctorStateL2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1ypM ds_s1ypN s1_s1ypO]
        let {
          ds1_s1ypP [Dmd=<L,U(1*U,1*U)>] :: (s_a1xSQ, a_a1xSU)
          [LclId] =
              [ds_s1ypN s1_s1ypO] \u [] ds_s1ypN s1_s1ypO; } in
        let {
          sat_s1ypY [Occ=Once] :: b_a1xSV
          [LclId] =
              [f_s1ypM ds1_s1ypP] \u []
                  let {
                    sat_s1ypX [Occ=Once] :: a_a1xSU
                    [LclId] =
                        [ds1_s1ypP] \u []
                            case ds1_s1ypP of {
                              (,) _ [Occ=Dead] v_s1ypW [Occ=Once] -> v_s1ypW;
                            };
                  } in  f_s1ypM sat_s1ypX; } in
        let {
          sat_s1ypT [Occ=Once] :: s_a1xSQ
          [LclId] =
              [ds1_s1ypP] \u []
                  case ds1_s1ypP of {
                    (,) s'_s1ypR [Occ=Once] _ [Occ=Dead] -> s'_s1ypR;
                  };
        } in  (,) [sat_s1ypT sat_s1ypY];

Data.Functor.Utils.$fFunctorStateL1
  :: forall b s a. a -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1ypZ ds_s1yq0 s1_s1yq1]
        let {
          sat_s1yq5 [Occ=Once] :: s_X1xUk
          [LclId] =
              [ds_s1yq0 s1_s1yq1] \u []
                  case ds_s1yq0 s1_s1yq1 of {
                    (,) s'_s1yq3 [Occ=Once] _ [Occ=Dead] -> s'_s1yq3;
                  };
        } in  (,) [sat_s1yq5 x_s1ypZ];

Data.Functor.Utils.$fFunctorStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateL2
                                       Data.Functor.Utils.$fFunctorStateL1];

Data.Functor.Utils.$fApplicativeStateL3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1yq6 w1_s1yq7 w2_s1yq8 w3_s1yq9]
        let {
          ds_s1yqa [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, a_s1yeh)
          [LclId] =
              [w1_s1yq7 w3_s1yq9] \u [] w1_s1yq7 w3_s1yq9; } in
        let {
          ds1_s1yqb [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, b_s1yei)
          [LclId] =
              [w2_s1yq8 ds_s1yqa] \u []
                  let {
                    sat_s1yqf [Occ=Once] :: s_s1yeg
                    [LclId] =
                        [ds_s1yqa] \u []
                            case ds_s1yqa of {
                              (,) s'_s1yqd [Occ=Once] _ [Occ=Dead] -> s'_s1yqd;
                            };
                  } in  w2_s1yq8 sat_s1yqf; } in
        let {
          sat_s1yqs [Occ=Once] :: c_s1yej
          [LclId] =
              [w_s1yq6 ds_s1yqa ds1_s1yqb] \u []
                  let {
                    sat_s1yqr [Occ=Once] :: b_s1yei
                    [LclId] =
                        [ds1_s1yqb] \u []
                            case ds1_s1yqb of {
                              (,) _ [Occ=Dead] y_s1yqq [Occ=Once] -> y_s1yqq;
                            }; } in
                  let {
                    sat_s1yqn [Occ=Once] :: a_s1yeh
                    [LclId] =
                        [ds_s1yqa] \u []
                            case ds_s1yqa of {
                              (,) _ [Occ=Dead] x_s1yqm [Occ=Once] -> x_s1yqm;
                            };
                  } in  w_s1yq6 sat_s1yqn sat_s1yqr; } in
        let {
          sat_s1yqj [Occ=Once] :: s_s1yeg
          [LclId] =
              [ds1_s1yqb] \u []
                  case ds1_s1yqb of {
                    (,) s''_s1yqh [Occ=Once] _ [Occ=Dead] -> s''_s1yqh;
                  };
        } in  (,) [sat_s1yqj sat_s1yqs];

Data.Functor.Utils.$fApplicativeStateL4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateL s (a -> b)
     -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1yqt w1_s1yqu w2_s1yqv]
        let {
          ds_s1yqw [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yes, a_s1yet -> b_s1yeu)
          [LclId] =
              [w_s1yqt w2_s1yqv] \u [] w_s1yqt w2_s1yqv; } in
        let {
          ds1_s1yqx [Dmd=<L,U(1*U,1*U)>] :: (s_s1yes, a_s1yet)
          [LclId] =
              [w1_s1yqu ds_s1yqw] \u []
                  let {
                    sat_s1yqB [Occ=Once] :: s_s1yes
                    [LclId] =
                        [ds_s1yqw] \u []
                            case ds_s1yqw of {
                              (,) s'_s1yqz [Occ=Once] _ [Occ=Dead] -> s'_s1yqz;
                            };
                  } in  w1_s1yqu sat_s1yqB; } in
        let {
          sat_s1yqN [Occ=Once] :: b_s1yeu
          [LclId] =
              [ds_s1yqw ds1_s1yqx] \u []
                  case ds_s1yqw of {
                    (,) _ [Occ=Dead] f_s1yqI [Occ=Once!] ->
                        let {
                          sat_s1yqM [Occ=Once] :: a_s1yet
                          [LclId] =
                              [ds1_s1yqx] \u []
                                  case ds1_s1yqx of {
                                    (,) _ [Occ=Dead] v_s1yqL [Occ=Once] -> v_s1yqL;
                                  };
                        } in  f_s1yqI sat_s1yqM;
                  }; } in
        let {
          sat_s1yqF [Occ=Once] :: s_s1yes
          [LclId] =
              [ds1_s1yqx] \u []
                  case ds1_s1yqx of {
                    (,) s''_s1yqD [Occ=Once] _ [Occ=Dead] -> s''_s1yqD;
                  };
        } in  (,) [sat_s1yqF sat_s1yqN];

Data.Functor.Utils.$fApplicativeStateL5
  :: forall s a. a -> s -> (s, a)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><L,U>m, Unf=OtherCon []] =
    [] \r [x_s1yqO s1_s1yqP] (,) [s1_s1yqP x_s1yqO];

Data.Functor.Utils.$fApplicativeStateL2
  :: forall b a s.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1yqQ a2_s1yqR eta_s1yqS]
        let {
          ds_s1yqT [Dmd=<L,U(1*U,1*U)>] :: (s_X1xSV, b_a1xSy)
          [LclId] =
              [a1_s1yqQ a2_s1yqR eta_s1yqS] \u []
                  let {
                    sat_s1yqX [Occ=Once] :: s_X1xSV
                    [LclId] =
                        [a1_s1yqQ eta_s1yqS] \u []
                            case a1_s1yqQ eta_s1yqS of {
                              (,) s'_s1yqV [Occ=Once] _ [Occ=Dead] -> s'_s1yqV;
                            };
                  } in  a2_s1yqR sat_s1yqX; } in
        let {
          sat_s1yr5 [Occ=Once] :: b_a1xSy
          [LclId] =
              [ds_s1yqT] \u []
                  case ds_s1yqT of {
                    (,) _ [Occ=Dead] v_s1yr4 [Occ=Once] -> v_s1yr4;
                  }; } in
        let {
          sat_s1yr1 [Occ=Once] :: s_X1xSV
          [LclId] =
              [ds_s1yqT] \u []
                  case ds_s1yqT of {
                    (,) s''_s1yqZ [Occ=Once] _ [Occ=Dead] -> s''_s1yqZ;
                  };
        } in  (,) [sat_s1yr1 sat_s1yr5];

Data.Functor.Utils.$fApplicativeStateL1
  :: forall a s b.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1yr6 ds1_s1yr7 s1_s1yr8]
        let {
          ds2_s1yr9 [Dmd=<L,U(1*U,1*U)>] :: (s_X1xST, a_a1xSH)
          [LclId] =
              [ds_s1yr6 s1_s1yr8] \u [] ds_s1yr6 s1_s1yr8; } in
        let {
          sat_s1yrl [Occ=Once] :: a_a1xSH
          [LclId] =
              [ds2_s1yr9] \u []
                  case ds2_s1yr9 of {
                    (,) _ [Occ=Dead] x_s1yrk [Occ=Once] -> x_s1yrk;
                  }; } in
        let {
          sat_s1yrh [Occ=Once] :: s_X1xST
          [LclId] =
              [ds1_s1yr7 ds2_s1yr9] \u []
                  let {
                    sat_s1yrd [Occ=Once] :: s_X1xST
                    [LclId] =
                        [ds2_s1yr9] \u []
                            case ds2_s1yr9 of {
                              (,) s'_s1yrb [Occ=Once] _ [Occ=Dead] -> s'_s1yrb;
                            };
                  } in 
                    case ds1_s1yr7 sat_s1yrd of {
                      (,) s''_s1yrf [Occ=Once] _ [Occ=Dead] -> s''_s1yrf;
                    };
        } in  (,) [sat_s1yrh sat_s1yrl];

Data.Functor.Utils.$fApplicativeStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateL
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateL4
                                           Data.Functor.Utils.$fApplicativeStateL3
                                           Data.Functor.Utils.$fApplicativeStateL2
                                           Data.Functor.Utils.$fApplicativeStateL1];

Data.Functor.Utils.$fFunctorStateR2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1yrm ds_s1yrn s1_s1yro]
        let {
          ds1_s1yrp [Dmd=<L,U(1*U,1*U)>] :: (s_a1xQk, a_a1xQo)
          [LclId] =
              [ds_s1yrn s1_s1yro] \u [] ds_s1yrn s1_s1yro; } in
        let {
          sat_s1yry [Occ=Once] :: b_a1xQp
          [LclId] =
              [f_s1yrm ds1_s1yrp] \u []
                  let {
                    sat_s1yrx [Occ=Once] :: a_a1xQo
                    [LclId] =
                        [ds1_s1yrp] \u []
                            case ds1_s1yrp of {
                              (,) _ [Occ=Dead] v_s1yrw [Occ=Once] -> v_s1yrw;
                            };
                  } in  f_s1yrm sat_s1yrx; } in
        let {
          sat_s1yrt [Occ=Once] :: s_a1xQk
          [LclId] =
              [ds1_s1yrp] \u []
                  case ds1_s1yrp of {
                    (,) s'_s1yrr [Occ=Once] _ [Occ=Dead] -> s'_s1yrr;
                  };
        } in  (,) [sat_s1yrt sat_s1yry];

Data.Functor.Utils.$fFunctorStateR1
  :: forall b s a. a -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1yrz ds_s1yrA s1_s1yrB]
        let {
          sat_s1yrF [Occ=Once] :: s_X1xSo
          [LclId] =
              [ds_s1yrA s1_s1yrB] \u []
                  case ds_s1yrA s1_s1yrB of {
                    (,) s'_s1yrD [Occ=Once] _ [Occ=Dead] -> s'_s1yrD;
                  };
        } in  (,) [sat_s1yrF x_s1yrz];

Data.Functor.Utils.$fFunctorStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateR2
                                       Data.Functor.Utils.$fFunctorStateR1];

Data.Functor.Utils.$fApplicativeStateR3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1yrG w1_s1yrH w2_s1yrI w3_s1yrJ]
        let {
          ds_s1yrK [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, b_s1yeE)
          [LclId] =
              [w2_s1yrI w3_s1yrJ] \u [] w2_s1yrI w3_s1yrJ; } in
        let {
          ds1_s1yrL [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, a_s1yeD)
          [LclId] =
              [w1_s1yrH ds_s1yrK] \u []
                  let {
                    sat_s1yrP [Occ=Once] :: s_s1yeC
                    [LclId] =
                        [ds_s1yrK] \u []
                            case ds_s1yrK of {
                              (,) s'_s1yrN [Occ=Once] _ [Occ=Dead] -> s'_s1yrN;
                            };
                  } in  w1_s1yrH sat_s1yrP; } in
        let {
          sat_s1ys2 [Occ=Once] :: c_s1yeF
          [LclId] =
              [w_s1yrG ds_s1yrK ds1_s1yrL] \u []
                  let {
                    sat_s1ys1 [Occ=Once] :: b_s1yeE
                    [LclId] =
                        [ds_s1yrK] \u []
                            case ds_s1yrK of {
                              (,) _ [Occ=Dead] y_s1ys0 [Occ=Once] -> y_s1ys0;
                            }; } in
                  let {
                    sat_s1yrX [Occ=Once] :: a_s1yeD
                    [LclId] =
                        [ds1_s1yrL] \u []
                            case ds1_s1yrL of {
                              (,) _ [Occ=Dead] x_s1yrW [Occ=Once] -> x_s1yrW;
                            };
                  } in  w_s1yrG sat_s1yrX sat_s1ys1; } in
        let {
          sat_s1yrT [Occ=Once] :: s_s1yeC
          [LclId] =
              [ds1_s1yrL] \u []
                  case ds1_s1yrL of {
                    (,) s''_s1yrR [Occ=Once] _ [Occ=Dead] -> s''_s1yrR;
                  };
        } in  (,) [sat_s1yrT sat_s1ys2];

Data.Functor.Utils.$fApplicativeStateR4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateR s (a -> b)
     -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1ys3 w1_s1ys4 w2_s1ys5]
        let {
          ds_s1ys6 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeO, a_s1yeP)
          [LclId] =
              [w1_s1ys4 w2_s1ys5] \u [] w1_s1ys4 w2_s1ys5; } in
        let {
          ds1_s1ys7 [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yeO, a_s1yeP -> b_s1yeQ)
          [LclId] =
              [w_s1ys3 ds_s1ys6] \u []
                  let {
                    sat_s1ysb [Occ=Once] :: s_s1yeO
                    [LclId] =
                        [ds_s1ys6] \u []
                            case ds_s1ys6 of {
                              (,) s'_s1ys9 [Occ=Once] _ [Occ=Dead] -> s'_s1ys9;
                            };
                  } in  w_s1ys3 sat_s1ysb; } in
        let {
          sat_s1ysn [Occ=Once] :: b_s1yeQ
          [LclId] =
              [ds_s1ys6 ds1_s1ys7] \u []
                  case ds1_s1ys7 of {
                    (,) _ [Occ=Dead] f_s1ysi [Occ=Once!] ->
                        let {
                          sat_s1ysm [Occ=Once] :: a_s1yeP
                          [LclId] =
                              [ds_s1ys6] \u []
                                  case ds_s1ys6 of {
                                    (,) _ [Occ=Dead] v_s1ysl [Occ=Once] -> v_s1ysl;
                                  };
                        } in  f_s1ysi sat_s1ysm;
                  }; } in
        let {
          sat_s1ysf [Occ=Once] :: s_s1yeO
          [LclId] =
              [ds1_s1ys7] \u []
                  case ds1_s1ys7 of {
                    (,) s''_s1ysd [Occ=Once] _ [Occ=Dead] -> s''_s1ysd;
                  };
        } in  (,) [sat_s1ysf sat_s1ysn];

Data.Functor.Utils.$fApplicativeStateR2
  :: forall b a s.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1yso a2_s1ysp eta_s1ysq]
        let {
          ds_s1ysr [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQD, b_a1xPW)
          [LclId] =
              [a2_s1ysp eta_s1ysq] \u [] a2_s1ysp eta_s1ysq; } in
        let {
          sat_s1ysD [Occ=Once] :: b_a1xPW
          [LclId] =
              [ds_s1ysr] \u []
                  case ds_s1ysr of {
                    (,) _ [Occ=Dead] v_s1ysC [Occ=Once] -> v_s1ysC;
                  }; } in
        let {
          sat_s1ysz [Occ=Once] :: s_X1xQD
          [LclId] =
              [a1_s1yso ds_s1ysr] \u []
                  let {
                    sat_s1ysv [Occ=Once] :: s_X1xQD
                    [LclId] =
                        [ds_s1ysr] \u []
                            case ds_s1ysr of {
                              (,) s'_s1yst [Occ=Once] _ [Occ=Dead] -> s'_s1yst;
                            };
                  } in 
                    case a1_s1yso sat_s1ysv of {
                      (,) s'_s1ysx [Occ=Once] _ [Occ=Dead] -> s'_s1ysx;
                    };
        } in  (,) [sat_s1ysz sat_s1ysD];

Data.Functor.Utils.$fApplicativeStateR1
  :: forall a s b.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1ysE ds1_s1ysF s1_s1ysG]
        let {
          ds2_s1ysH [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQB, a_a1xQb)
          [LclId] =
              [ds_s1ysE ds1_s1ysF s1_s1ysG] \u []
                  let {
                    sat_s1ysL [Occ=Once] :: s_X1xQB
                    [LclId] =
                        [ds1_s1ysF s1_s1ysG] \u []
                            case ds1_s1ysF s1_s1ysG of {
                              (,) s'_s1ysJ [Occ=Once] _ [Occ=Dead] -> s'_s1ysJ;
                            };
                  } in  ds_s1ysE sat_s1ysL; } in
        let {
          sat_s1ysT [Occ=Once] :: a_a1xQb
          [LclId] =
              [ds2_s1ysH] \u []
                  case ds2_s1ysH of {
                    (,) _ [Occ=Dead] x_s1ysS [Occ=Once] -> x_s1ysS;
                  }; } in
        let {
          sat_s1ysP [Occ=Once] :: s_X1xQB
          [LclId] =
              [ds2_s1ysH] \u []
                  case ds2_s1ysH of {
                    (,) s''_s1ysN [Occ=Once] _ [Occ=Dead] -> s''_s1ysN;
                  };
        } in  (,) [sat_s1ysP sat_s1ysT];

Data.Functor.Utils.$fApplicativeStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateR
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateR4
                                           Data.Functor.Utils.$fApplicativeStateR3
                                           Data.Functor.Utils.$fApplicativeStateR2
                                           Data.Functor.Utils.$fApplicativeStateR1];

Data.Functor.Utils.getMax1
  :: forall a. Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysU] ds_s1ysU;

Data.Functor.Utils.getMax
  :: forall a. Data.Functor.Utils.Max a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMax1 eta_B1;

Data.Functor.Utils.getMin1
  :: forall a. Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysV] ds_s1ysV;

Data.Functor.Utils.getMin
  :: forall a. Data.Functor.Utils.Min a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMin1 eta_B1;

Data.Functor.Utils.runStateL1
  :: forall s a.
     Data.Functor.Utils.StateL s a -> Data.Functor.Utils.StateL s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysW] ds_s1ysW;

Data.Functor.Utils.runStateL
  :: forall s a. Data.Functor.Utils.StateL s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateL1 eta_B1;

Data.Functor.Utils.runStateR1
  :: forall s a.
     Data.Functor.Utils.StateR s a -> Data.Functor.Utils.StateR s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1ysX] ds_s1ysX;

Data.Functor.Utils.runStateR
  :: forall s a. Data.Functor.Utils.StateR s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateR1 eta_B1;

Data.Functor.Utils.#. [InlPrag=INLINE (sat-args=1)]
  :: forall b c a.
     GHC.Types.Coercible b c =>
     (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dCoercible_s1ysY eta_s1ysZ eta1_s1yt0]
        case GHC.Types.coercible_sel $dCoercible_s1ysY of {
          (##) -> eta1_s1yt0;
        };

Data.Functor.Utils.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Utils.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule4];

Data.Functor.Utils.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Utils"#;

Data.Functor.Utils.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule2];

Data.Functor.Utils.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Utils.$trModule3
                                     Data.Functor.Utils.$trModule1];

$krep_r1ynX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r1ynY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r1ynZ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1ynX GHC.Types.[]];

$krep3_r1yo0 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY $krep2_r1ynZ];

$krep4_r1yo1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep3_r1yo0];

$krep5_r1yo2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1ynY $krep4_r1yo1];

$krep6_r1yo3 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY GHC.Types.[]];

$krep7_r1yo4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep6_r1yo3];

Data.Functor.Utils.$tcMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Functor.Utils.$tcMax1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMax2];

Data.Functor.Utils.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17055998897267803697##
                                    13070619747111935994##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMax1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep8_r1yo5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMax
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep8_r1yo5];

Data.Functor.Utils.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Functor.Utils.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Max3];

Data.Functor.Utils.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16178335003924091205##
                                    10384293407056089504##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Max2
                                    1#
                                    Data.Functor.Utils.$tc'Max1];

Data.Functor.Utils.$tcMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Functor.Utils.$tcMin1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMin2];

Data.Functor.Utils.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13719831963261617173##
                                    12509304105097421826##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMin1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r1yo6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMin
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep9_r1yo6];

Data.Functor.Utils.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Functor.Utils.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Min3];

Data.Functor.Utils.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3497961960072019520##
                                    14191657227527039212##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Min2
                                    1#
                                    Data.Functor.Utils.$tc'Min1];

Data.Functor.Utils.$tcStateL2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateL"#;

Data.Functor.Utils.$tcStateL1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateL2];

Data.Functor.Utils.$tcStateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8498227433031831307##
                                    6442648285908986693##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateL1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep10_r1yo7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateL
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep10_r1yo7];

Data.Functor.Utils.$tc'StateL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateL"#;

Data.Functor.Utils.$tc'StateL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateL3];

Data.Functor.Utils.$tc'StateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8965240648136302046##
                                    8498113279827793106##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateL2
                                    2#
                                    Data.Functor.Utils.$tc'StateL1];

Data.Functor.Utils.$tcStateR2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateR"#;

Data.Functor.Utils.$tcStateR1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateR2];

Data.Functor.Utils.$tcStateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10049146831422350196##
                                    16883721947448934294##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateR1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep11_r1yo8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateR
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep11_r1yo8];

Data.Functor.Utils.$tc'StateR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateR"#;

Data.Functor.Utils.$tc'StateR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateR3];

Data.Functor.Utils.$tc'StateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13798701525568783897##
                                    17913645303573466967##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateR2
                                    2#
                                    Data.Functor.Utils.$tc'StateR1];


==================== Pre unarise: ====================
2018-03-16 15:56:21.557708669 UTC

Data.Functor.Utils.$fMonoidMax_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zqr eta_s1zqs eta1_s1zqt]
        case eta1_s1zqt of wild_s1zqu {
          GHC.Base.Nothing -> eta_s1zqs;
          GHC.Base.Just ipv_s1zqv [Occ=Once] ->
              case eta_s1zqs of wild1_s1zqw {
                GHC.Base.Nothing -> wild_s1zqu;
                GHC.Base.Just x_s1zqx [Occ=Once] ->
                    case GHC.Classes.>= $dOrd_s1zqr x_s1zqx ipv_s1zqv of {
                      GHC.Types.False -> wild_s1zqu;
                      GHC.Types.True -> wild1_s1zqw;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1zqz ww_s1zqA ww1_s1zqB]
        let {
          go_s1zqC [Occ=LoopBreaker]
            :: Data.Functor.Utils.Max a_s1ydG
               -> [Data.Functor.Utils.Max a_s1ydG]
               -> Data.Functor.Utils.Max a_s1ydG
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1zqz go_s1zqC] \r [b_s1zqD ds1_s1zqE]
                  case ds1_s1zqE of {
                    [] -> b_s1zqD;
                    : c_s1zqG [Occ=Once] cs_s1zqH [Occ=Once] ->
                        case go_s1zqC c_s1zqG cs_s1zqH of wild_s1zqI {
                          GHC.Base.Nothing -> b_s1zqD;
                          GHC.Base.Just ipv_s1zqJ [Occ=Once] ->
                              case b_s1zqD of wild2_s1zqK {
                                GHC.Base.Nothing -> wild_s1zqI;
                                GHC.Base.Just x_s1zqL [Occ=Once] ->
                                    case GHC.Classes.>= w_s1zqz x_s1zqL ipv_s1zqJ of {
                                      GHC.Types.False -> wild_s1zqI;
                                      GHC.Types.True -> wild2_s1zqK;
                                    };
                              };
                        };
                  };
        } in  go_s1zqC ww_s1zqA ww1_s1zqB;

Data.Functor.Utils.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Max a)
     -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1zqN w1_s1zqO]
        case w1_s1zqO of {
          GHC.Base.:| ww1_s1zqQ [Occ=Once] ww2_s1zqR [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat w_s1zqN ww1_s1zqQ ww2_s1zqR;
        };

Data.Functor.Utils.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1zqS]
        let {
          sat_s1zqV [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1zqS] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$cstimes $dOrd_s1zqS eta_B1; } in
        let {
          sat_s1zqU [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Max a_a1xV2)
               -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1zqS] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$csconcat
                      $dOrd_s1zqS eta_B1; } in
        let {
          sat_s1zqT [Occ=Once]
            :: Data.Functor.Utils.Max a_a1xV2
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1zqS] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1zqS eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1zqT sat_s1zqU sat_s1zqV];
Data.Functor.Utils.$fSemigroupMax_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zqW $dIntegral_s1zqX]
        let {
          sat_s1zqY [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_a1xV2)
          [LclId] =
              [$dOrd_s1zqW] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1zqW;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1zqX sat_s1zqY;

Data.Functor.Utils.$fMonoidMax_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zqZ eta_s1zr0]
        let {
          go_s1zr1 [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Max a_X1xVO]
               -> Data.Functor.Utils.Max a_X1xVO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1zqZ go_s1zr1] \r [ds_s1zr2]
                  case ds_s1zr2 of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1zr4 [Occ=Once*] ys_s1zr5 [Occ=Once] ->
                        case go_s1zr1 ys_s1zr5 of wild1_s1zr6 {
                          GHC.Base.Nothing -> y_s1zr4;
                          GHC.Base.Just ipv_s1zr7 [Occ=Once] ->
                              case y_s1zr4 of wild2_s1zr8 {
                                GHC.Base.Nothing -> wild1_s1zr6;
                                GHC.Base.Just x_s1zr9 [Occ=Once] ->
                                    case GHC.Classes.>= $dOrd_s1zqZ x_s1zr9 ipv_s1zr7 of {
                                      GHC.Types.False -> wild1_s1zr6;
                                      GHC.Types.True -> wild2_s1zr8;
                                    };
                              };
                        };
                  };
        } in  go_s1zr1 eta_s1zr0;

Data.Functor.Utils.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1zrb]
        let {
          sat_s1zre [Occ=Once]
            :: [Data.Functor.Utils.Max a_X1xVM]
               -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1zrb] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$cmconcat $dOrd_s1zrb eta_B1; } in
        let {
          sat_s1zrd [Occ=Once]
            :: Data.Functor.Utils.Max a_X1xVM
               -> Data.Functor.Utils.Max a_X1xVM -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1zrb] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1zrb eta_B2 eta_B1; } in
        let {
          sat_s1zrc [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_X1xVM)
          [LclId] =
              [$dOrd_s1zrb] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1zrb;
        } in 
          GHC.Base.C:Monoid [sat_s1zrc GHC.Base.Nothing sat_s1zrd sat_s1zre];

Data.Functor.Utils.$fMonoidMin_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zrf eta_s1zrg eta1_s1zrh]
        case eta1_s1zrh of wild_s1zri {
          GHC.Base.Nothing -> eta_s1zrg;
          GHC.Base.Just ipv_s1zrj [Occ=Once] ->
              case eta_s1zrg of wild1_s1zrk {
                GHC.Base.Nothing -> wild_s1zri;
                GHC.Base.Just x_s1zrl [Occ=Once] ->
                    case GHC.Classes.<= $dOrd_s1zrf x_s1zrl ipv_s1zrj of {
                      GHC.Types.False -> wild_s1zri;
                      GHC.Types.True -> wild1_s1zrk;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1zrn ww_s1zro ww1_s1zrp]
        let {
          go_s1zrq [Occ=LoopBreaker]
            :: Data.Functor.Utils.Min a_s1ydZ
               -> [Data.Functor.Utils.Min a_s1ydZ]
               -> Data.Functor.Utils.Min a_s1ydZ
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1zrn go_s1zrq] \r [b_s1zrr ds1_s1zrs]
                  case ds1_s1zrs of {
                    [] -> b_s1zrr;
                    : c_s1zru [Occ=Once] cs_s1zrv [Occ=Once] ->
                        case go_s1zrq c_s1zru cs_s1zrv of wild_s1zrw {
                          GHC.Base.Nothing -> b_s1zrr;
                          GHC.Base.Just ipv_s1zrx [Occ=Once] ->
                              case b_s1zrr of wild2_s1zry {
                                GHC.Base.Nothing -> wild_s1zrw;
                                GHC.Base.Just x_s1zrz [Occ=Once] ->
                                    case GHC.Classes.<= w_s1zrn x_s1zrz ipv_s1zrx of {
                                      GHC.Types.False -> wild_s1zrw;
                                      GHC.Types.True -> wild2_s1zry;
                                    };
                              };
                        };
                  };
        } in  go_s1zrq ww_s1zro ww1_s1zrp;

Data.Functor.Utils.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Min a)
     -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1zrB w1_s1zrC]
        case w1_s1zrC of {
          GHC.Base.:| ww1_s1zrE [Occ=Once] ww2_s1zrF [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat1 w_s1zrB ww1_s1zrE ww2_s1zrF;
        };

Data.Functor.Utils.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1zrG]
        let {
          sat_s1zrJ [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1zrG] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$cstimes $dOrd_s1zrG eta_B1; } in
        let {
          sat_s1zrI [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Min a_a1xTV)
               -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1zrG] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$csconcat
                      $dOrd_s1zrG eta_B1; } in
        let {
          sat_s1zrH [Occ=Once]
            :: Data.Functor.Utils.Min a_a1xTV
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1zrG] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1zrG eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1zrH sat_s1zrI sat_s1zrJ];
Data.Functor.Utils.$fSemigroupMin_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zrK $dIntegral_s1zrL]
        let {
          sat_s1zrM [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_a1xTV)
          [LclId] =
              [$dOrd_s1zrK] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1zrK;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1zrL sat_s1zrM;

Data.Functor.Utils.$fMonoidMin_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zrN eta_s1zrO]
        let {
          go_s1zrP [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Min a_X1xUO]
               -> Data.Functor.Utils.Min a_X1xUO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1zrN go_s1zrP] \r [ds_s1zrQ]
                  case ds_s1zrQ of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1zrS [Occ=Once*] ys_s1zrT [Occ=Once] ->
                        case go_s1zrP ys_s1zrT of wild1_s1zrU {
                          GHC.Base.Nothing -> y_s1zrS;
                          GHC.Base.Just ipv_s1zrV [Occ=Once] ->
                              case y_s1zrS of wild2_s1zrW {
                                GHC.Base.Nothing -> wild1_s1zrU;
                                GHC.Base.Just x_s1zrX [Occ=Once] ->
                                    case GHC.Classes.<= $dOrd_s1zrN x_s1zrX ipv_s1zrV of {
                                      GHC.Types.False -> wild1_s1zrU;
                                      GHC.Types.True -> wild2_s1zrW;
                                    };
                              };
                        };
                  };
        } in  go_s1zrP eta_s1zrO;

Data.Functor.Utils.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1zrZ]
        let {
          sat_s1zs2 [Occ=Once]
            :: [Data.Functor.Utils.Min a_X1xUM]
               -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1zrZ] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$cmconcat $dOrd_s1zrZ eta_B1; } in
        let {
          sat_s1zs1 [Occ=Once]
            :: Data.Functor.Utils.Min a_X1xUM
               -> Data.Functor.Utils.Min a_X1xUM -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1zrZ] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1zrZ eta_B2 eta_B1; } in
        let {
          sat_s1zs0 [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_X1xUM)
          [LclId] =
              [$dOrd_s1zrZ] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1zrZ;
        } in 
          GHC.Base.C:Monoid [sat_s1zs0 GHC.Base.Nothing sat_s1zs1 sat_s1zs2];

Data.Functor.Utils.$fFunctorStateL2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1zs3 ds_s1zs4 s1_s1zs5]
        let {
          ds1_s1zs6 [Dmd=<L,U(1*U,1*U)>] :: (s_a1xSQ, a_a1xSU)
          [LclId] =
              [ds_s1zs4 s1_s1zs5] \u [] ds_s1zs4 s1_s1zs5; } in
        let {
          sat_s1zsf [Occ=Once] :: b_a1xSV
          [LclId] =
              [f_s1zs3 ds1_s1zs6] \u []
                  let {
                    sat_s1zse [Occ=Once] :: a_a1xSU
                    [LclId] =
                        [ds1_s1zs6] \u []
                            case ds1_s1zs6 of {
                              (,) _ [Occ=Dead] v_s1zsd [Occ=Once] -> v_s1zsd;
                            };
                  } in  f_s1zs3 sat_s1zse; } in
        let {
          sat_s1zsa [Occ=Once] :: s_a1xSQ
          [LclId] =
              [ds1_s1zs6] \u []
                  case ds1_s1zs6 of {
                    (,) s'_s1zs8 [Occ=Once] _ [Occ=Dead] -> s'_s1zs8;
                  };
        } in  (,) [sat_s1zsa sat_s1zsf];

Data.Functor.Utils.$fFunctorStateL1
  :: forall b s a. a -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1zsg ds_s1zsh s1_s1zsi]
        let {
          sat_s1zsm [Occ=Once] :: s_X1xUk
          [LclId] =
              [ds_s1zsh s1_s1zsi] \u []
                  case ds_s1zsh s1_s1zsi of {
                    (,) s'_s1zsk [Occ=Once] _ [Occ=Dead] -> s'_s1zsk;
                  };
        } in  (,) [sat_s1zsm x_s1zsg];

Data.Functor.Utils.$fFunctorStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateL2
                                       Data.Functor.Utils.$fFunctorStateL1];

Data.Functor.Utils.$fApplicativeStateL3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1zsn w1_s1zso w2_s1zsp w3_s1zsq]
        let {
          ds_s1zsr [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, a_s1yeh)
          [LclId] =
              [w1_s1zso w3_s1zsq] \u [] w1_s1zso w3_s1zsq; } in
        let {
          ds1_s1zss [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, b_s1yei)
          [LclId] =
              [w2_s1zsp ds_s1zsr] \u []
                  let {
                    sat_s1zsw [Occ=Once] :: s_s1yeg
                    [LclId] =
                        [ds_s1zsr] \u []
                            case ds_s1zsr of {
                              (,) s'_s1zsu [Occ=Once] _ [Occ=Dead] -> s'_s1zsu;
                            };
                  } in  w2_s1zsp sat_s1zsw; } in
        let {
          sat_s1zsJ [Occ=Once] :: c_s1yej
          [LclId] =
              [w_s1zsn ds_s1zsr ds1_s1zss] \u []
                  let {
                    sat_s1zsI [Occ=Once] :: b_s1yei
                    [LclId] =
                        [ds1_s1zss] \u []
                            case ds1_s1zss of {
                              (,) _ [Occ=Dead] y_s1zsH [Occ=Once] -> y_s1zsH;
                            }; } in
                  let {
                    sat_s1zsE [Occ=Once] :: a_s1yeh
                    [LclId] =
                        [ds_s1zsr] \u []
                            case ds_s1zsr of {
                              (,) _ [Occ=Dead] x_s1zsD [Occ=Once] -> x_s1zsD;
                            };
                  } in  w_s1zsn sat_s1zsE sat_s1zsI; } in
        let {
          sat_s1zsA [Occ=Once] :: s_s1yeg
          [LclId] =
              [ds1_s1zss] \u []
                  case ds1_s1zss of {
                    (,) s''_s1zsy [Occ=Once] _ [Occ=Dead] -> s''_s1zsy;
                  };
        } in  (,) [sat_s1zsA sat_s1zsJ];

Data.Functor.Utils.$fApplicativeStateL4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateL s (a -> b)
     -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1zsK w1_s1zsL w2_s1zsM]
        let {
          ds_s1zsN [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yes, a_s1yet -> b_s1yeu)
          [LclId] =
              [w_s1zsK w2_s1zsM] \u [] w_s1zsK w2_s1zsM; } in
        let {
          ds1_s1zsO [Dmd=<L,U(1*U,1*U)>] :: (s_s1yes, a_s1yet)
          [LclId] =
              [w1_s1zsL ds_s1zsN] \u []
                  let {
                    sat_s1zsS [Occ=Once] :: s_s1yes
                    [LclId] =
                        [ds_s1zsN] \u []
                            case ds_s1zsN of {
                              (,) s'_s1zsQ [Occ=Once] _ [Occ=Dead] -> s'_s1zsQ;
                            };
                  } in  w1_s1zsL sat_s1zsS; } in
        let {
          sat_s1zt4 [Occ=Once] :: b_s1yeu
          [LclId] =
              [ds_s1zsN ds1_s1zsO] \u []
                  case ds_s1zsN of {
                    (,) _ [Occ=Dead] f_s1zsZ [Occ=Once!] ->
                        let {
                          sat_s1zt3 [Occ=Once] :: a_s1yet
                          [LclId] =
                              [ds1_s1zsO] \u []
                                  case ds1_s1zsO of {
                                    (,) _ [Occ=Dead] v_s1zt2 [Occ=Once] -> v_s1zt2;
                                  };
                        } in  f_s1zsZ sat_s1zt3;
                  }; } in
        let {
          sat_s1zsW [Occ=Once] :: s_s1yes
          [LclId] =
              [ds1_s1zsO] \u []
                  case ds1_s1zsO of {
                    (,) s''_s1zsU [Occ=Once] _ [Occ=Dead] -> s''_s1zsU;
                  };
        } in  (,) [sat_s1zsW sat_s1zt4];

Data.Functor.Utils.$fApplicativeStateL5
  :: forall s a. a -> s -> (s, a)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><L,U>m, Unf=OtherCon []] =
    [] \r [x_s1zt5 s1_s1zt6] (,) [s1_s1zt6 x_s1zt5];

Data.Functor.Utils.$fApplicativeStateL2
  :: forall b a s.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1zt7 a2_s1zt8 eta_s1zt9]
        let {
          ds_s1zta [Dmd=<L,U(1*U,1*U)>] :: (s_X1xSV, b_a1xSy)
          [LclId] =
              [a1_s1zt7 a2_s1zt8 eta_s1zt9] \u []
                  let {
                    sat_s1zte [Occ=Once] :: s_X1xSV
                    [LclId] =
                        [a1_s1zt7 eta_s1zt9] \u []
                            case a1_s1zt7 eta_s1zt9 of {
                              (,) s'_s1ztc [Occ=Once] _ [Occ=Dead] -> s'_s1ztc;
                            };
                  } in  a2_s1zt8 sat_s1zte; } in
        let {
          sat_s1ztm [Occ=Once] :: b_a1xSy
          [LclId] =
              [ds_s1zta] \u []
                  case ds_s1zta of {
                    (,) _ [Occ=Dead] v_s1ztl [Occ=Once] -> v_s1ztl;
                  }; } in
        let {
          sat_s1zti [Occ=Once] :: s_X1xSV
          [LclId] =
              [ds_s1zta] \u []
                  case ds_s1zta of {
                    (,) s''_s1ztg [Occ=Once] _ [Occ=Dead] -> s''_s1ztg;
                  };
        } in  (,) [sat_s1zti sat_s1ztm];

Data.Functor.Utils.$fApplicativeStateL1
  :: forall a s b.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1ztn ds1_s1zto s1_s1ztp]
        let {
          ds2_s1ztq [Dmd=<L,U(1*U,1*U)>] :: (s_X1xST, a_a1xSH)
          [LclId] =
              [ds_s1ztn s1_s1ztp] \u [] ds_s1ztn s1_s1ztp; } in
        let {
          sat_s1ztC [Occ=Once] :: a_a1xSH
          [LclId] =
              [ds2_s1ztq] \u []
                  case ds2_s1ztq of {
                    (,) _ [Occ=Dead] x_s1ztB [Occ=Once] -> x_s1ztB;
                  }; } in
        let {
          sat_s1zty [Occ=Once] :: s_X1xST
          [LclId] =
              [ds1_s1zto ds2_s1ztq] \u []
                  let {
                    sat_s1ztu [Occ=Once] :: s_X1xST
                    [LclId] =
                        [ds2_s1ztq] \u []
                            case ds2_s1ztq of {
                              (,) s'_s1zts [Occ=Once] _ [Occ=Dead] -> s'_s1zts;
                            };
                  } in 
                    case ds1_s1zto sat_s1ztu of {
                      (,) s''_s1ztw [Occ=Once] _ [Occ=Dead] -> s''_s1ztw;
                    };
        } in  (,) [sat_s1zty sat_s1ztC];

Data.Functor.Utils.$fApplicativeStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateL
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateL4
                                           Data.Functor.Utils.$fApplicativeStateL3
                                           Data.Functor.Utils.$fApplicativeStateL2
                                           Data.Functor.Utils.$fApplicativeStateL1];

Data.Functor.Utils.$fFunctorStateR2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1ztD ds_s1ztE s1_s1ztF]
        let {
          ds1_s1ztG [Dmd=<L,U(1*U,1*U)>] :: (s_a1xQk, a_a1xQo)
          [LclId] =
              [ds_s1ztE s1_s1ztF] \u [] ds_s1ztE s1_s1ztF; } in
        let {
          sat_s1ztP [Occ=Once] :: b_a1xQp
          [LclId] =
              [f_s1ztD ds1_s1ztG] \u []
                  let {
                    sat_s1ztO [Occ=Once] :: a_a1xQo
                    [LclId] =
                        [ds1_s1ztG] \u []
                            case ds1_s1ztG of {
                              (,) _ [Occ=Dead] v_s1ztN [Occ=Once] -> v_s1ztN;
                            };
                  } in  f_s1ztD sat_s1ztO; } in
        let {
          sat_s1ztK [Occ=Once] :: s_a1xQk
          [LclId] =
              [ds1_s1ztG] \u []
                  case ds1_s1ztG of {
                    (,) s'_s1ztI [Occ=Once] _ [Occ=Dead] -> s'_s1ztI;
                  };
        } in  (,) [sat_s1ztK sat_s1ztP];

Data.Functor.Utils.$fFunctorStateR1
  :: forall b s a. a -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1ztQ ds_s1ztR s1_s1ztS]
        let {
          sat_s1ztW [Occ=Once] :: s_X1xSo
          [LclId] =
              [ds_s1ztR s1_s1ztS] \u []
                  case ds_s1ztR s1_s1ztS of {
                    (,) s'_s1ztU [Occ=Once] _ [Occ=Dead] -> s'_s1ztU;
                  };
        } in  (,) [sat_s1ztW x_s1ztQ];

Data.Functor.Utils.$fFunctorStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateR2
                                       Data.Functor.Utils.$fFunctorStateR1];

Data.Functor.Utils.$fApplicativeStateR3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1ztX w1_s1ztY w2_s1ztZ w3_s1zu0]
        let {
          ds_s1zu1 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, b_s1yeE)
          [LclId] =
              [w2_s1ztZ w3_s1zu0] \u [] w2_s1ztZ w3_s1zu0; } in
        let {
          ds1_s1zu2 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, a_s1yeD)
          [LclId] =
              [w1_s1ztY ds_s1zu1] \u []
                  let {
                    sat_s1zu6 [Occ=Once] :: s_s1yeC
                    [LclId] =
                        [ds_s1zu1] \u []
                            case ds_s1zu1 of {
                              (,) s'_s1zu4 [Occ=Once] _ [Occ=Dead] -> s'_s1zu4;
                            };
                  } in  w1_s1ztY sat_s1zu6; } in
        let {
          sat_s1zuj [Occ=Once] :: c_s1yeF
          [LclId] =
              [w_s1ztX ds_s1zu1 ds1_s1zu2] \u []
                  let {
                    sat_s1zui [Occ=Once] :: b_s1yeE
                    [LclId] =
                        [ds_s1zu1] \u []
                            case ds_s1zu1 of {
                              (,) _ [Occ=Dead] y_s1zuh [Occ=Once] -> y_s1zuh;
                            }; } in
                  let {
                    sat_s1zue [Occ=Once] :: a_s1yeD
                    [LclId] =
                        [ds1_s1zu2] \u []
                            case ds1_s1zu2 of {
                              (,) _ [Occ=Dead] x_s1zud [Occ=Once] -> x_s1zud;
                            };
                  } in  w_s1ztX sat_s1zue sat_s1zui; } in
        let {
          sat_s1zua [Occ=Once] :: s_s1yeC
          [LclId] =
              [ds1_s1zu2] \u []
                  case ds1_s1zu2 of {
                    (,) s''_s1zu8 [Occ=Once] _ [Occ=Dead] -> s''_s1zu8;
                  };
        } in  (,) [sat_s1zua sat_s1zuj];

Data.Functor.Utils.$fApplicativeStateR4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateR s (a -> b)
     -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1zuk w1_s1zul w2_s1zum]
        let {
          ds_s1zun [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeO, a_s1yeP)
          [LclId] =
              [w1_s1zul w2_s1zum] \u [] w1_s1zul w2_s1zum; } in
        let {
          ds1_s1zuo [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yeO, a_s1yeP -> b_s1yeQ)
          [LclId] =
              [w_s1zuk ds_s1zun] \u []
                  let {
                    sat_s1zus [Occ=Once] :: s_s1yeO
                    [LclId] =
                        [ds_s1zun] \u []
                            case ds_s1zun of {
                              (,) s'_s1zuq [Occ=Once] _ [Occ=Dead] -> s'_s1zuq;
                            };
                  } in  w_s1zuk sat_s1zus; } in
        let {
          sat_s1zuE [Occ=Once] :: b_s1yeQ
          [LclId] =
              [ds_s1zun ds1_s1zuo] \u []
                  case ds1_s1zuo of {
                    (,) _ [Occ=Dead] f_s1zuz [Occ=Once!] ->
                        let {
                          sat_s1zuD [Occ=Once] :: a_s1yeP
                          [LclId] =
                              [ds_s1zun] \u []
                                  case ds_s1zun of {
                                    (,) _ [Occ=Dead] v_s1zuC [Occ=Once] -> v_s1zuC;
                                  };
                        } in  f_s1zuz sat_s1zuD;
                  }; } in
        let {
          sat_s1zuw [Occ=Once] :: s_s1yeO
          [LclId] =
              [ds1_s1zuo] \u []
                  case ds1_s1zuo of {
                    (,) s''_s1zuu [Occ=Once] _ [Occ=Dead] -> s''_s1zuu;
                  };
        } in  (,) [sat_s1zuw sat_s1zuE];

Data.Functor.Utils.$fApplicativeStateR2
  :: forall b a s.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1zuF a2_s1zuG eta_s1zuH]
        let {
          ds_s1zuI [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQD, b_a1xPW)
          [LclId] =
              [a2_s1zuG eta_s1zuH] \u [] a2_s1zuG eta_s1zuH; } in
        let {
          sat_s1zuU [Occ=Once] :: b_a1xPW
          [LclId] =
              [ds_s1zuI] \u []
                  case ds_s1zuI of {
                    (,) _ [Occ=Dead] v_s1zuT [Occ=Once] -> v_s1zuT;
                  }; } in
        let {
          sat_s1zuQ [Occ=Once] :: s_X1xQD
          [LclId] =
              [a1_s1zuF ds_s1zuI] \u []
                  let {
                    sat_s1zuM [Occ=Once] :: s_X1xQD
                    [LclId] =
                        [ds_s1zuI] \u []
                            case ds_s1zuI of {
                              (,) s'_s1zuK [Occ=Once] _ [Occ=Dead] -> s'_s1zuK;
                            };
                  } in 
                    case a1_s1zuF sat_s1zuM of {
                      (,) s'_s1zuO [Occ=Once] _ [Occ=Dead] -> s'_s1zuO;
                    };
        } in  (,) [sat_s1zuQ sat_s1zuU];

Data.Functor.Utils.$fApplicativeStateR1
  :: forall a s b.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1zuV ds1_s1zuW s1_s1zuX]
        let {
          ds2_s1zuY [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQB, a_a1xQb)
          [LclId] =
              [ds_s1zuV ds1_s1zuW s1_s1zuX] \u []
                  let {
                    sat_s1zv2 [Occ=Once] :: s_X1xQB
                    [LclId] =
                        [ds1_s1zuW s1_s1zuX] \u []
                            case ds1_s1zuW s1_s1zuX of {
                              (,) s'_s1zv0 [Occ=Once] _ [Occ=Dead] -> s'_s1zv0;
                            };
                  } in  ds_s1zuV sat_s1zv2; } in
        let {
          sat_s1zva [Occ=Once] :: a_a1xQb
          [LclId] =
              [ds2_s1zuY] \u []
                  case ds2_s1zuY of {
                    (,) _ [Occ=Dead] x_s1zv9 [Occ=Once] -> x_s1zv9;
                  }; } in
        let {
          sat_s1zv6 [Occ=Once] :: s_X1xQB
          [LclId] =
              [ds2_s1zuY] \u []
                  case ds2_s1zuY of {
                    (,) s''_s1zv4 [Occ=Once] _ [Occ=Dead] -> s''_s1zv4;
                  };
        } in  (,) [sat_s1zv6 sat_s1zva];

Data.Functor.Utils.$fApplicativeStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateR
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateR4
                                           Data.Functor.Utils.$fApplicativeStateR3
                                           Data.Functor.Utils.$fApplicativeStateR2
                                           Data.Functor.Utils.$fApplicativeStateR1];

Data.Functor.Utils.getMax1
  :: forall a. Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zvb] ds_s1zvb;

Data.Functor.Utils.getMax
  :: forall a. Data.Functor.Utils.Max a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMax1 eta_B1;

Data.Functor.Utils.getMin1
  :: forall a. Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zvc] ds_s1zvc;

Data.Functor.Utils.getMin
  :: forall a. Data.Functor.Utils.Min a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMin1 eta_B1;

Data.Functor.Utils.runStateL1
  :: forall s a.
     Data.Functor.Utils.StateL s a -> Data.Functor.Utils.StateL s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zvd] ds_s1zvd;

Data.Functor.Utils.runStateL
  :: forall s a. Data.Functor.Utils.StateL s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateL1 eta_B1;

Data.Functor.Utils.runStateR1
  :: forall s a.
     Data.Functor.Utils.StateR s a -> Data.Functor.Utils.StateR s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zve] ds_s1zve;

Data.Functor.Utils.runStateR
  :: forall s a. Data.Functor.Utils.StateR s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateR1 eta_B1;

Data.Functor.Utils.#. [InlPrag=INLINE (sat-args=1)]
  :: forall b c a.
     GHC.Types.Coercible b c =>
     (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dCoercible_s1zvf eta_s1zvg eta1_s1zvh]
        case GHC.Types.coercible_sel $dCoercible_s1zvf of {
          __DEFAULT -> eta1_s1zvh;
        };

Data.Functor.Utils.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Utils.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule4];

Data.Functor.Utils.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Utils"#;

Data.Functor.Utils.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule2];

Data.Functor.Utils.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Utils.$trModule3
                                     Data.Functor.Utils.$trModule1];

$krep_r1ynX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r1ynY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r1ynZ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1ynX GHC.Types.[]];

$krep3_r1yo0 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY $krep2_r1ynZ];

$krep4_r1yo1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep3_r1yo0];

$krep5_r1yo2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1ynY $krep4_r1yo1];

$krep6_r1yo3 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY GHC.Types.[]];

$krep7_r1yo4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep6_r1yo3];

Data.Functor.Utils.$tcMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Functor.Utils.$tcMax1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMax2];

Data.Functor.Utils.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17055998897267803697##
                                    13070619747111935994##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMax1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep8_r1yo5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMax
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep8_r1yo5];

Data.Functor.Utils.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Functor.Utils.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Max3];

Data.Functor.Utils.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16178335003924091205##
                                    10384293407056089504##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Max2
                                    1#
                                    Data.Functor.Utils.$tc'Max1];

Data.Functor.Utils.$tcMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Functor.Utils.$tcMin1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMin2];

Data.Functor.Utils.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13719831963261617173##
                                    12509304105097421826##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMin1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r1yo6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMin
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep9_r1yo6];

Data.Functor.Utils.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Functor.Utils.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Min3];

Data.Functor.Utils.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3497961960072019520##
                                    14191657227527039212##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Min2
                                    1#
                                    Data.Functor.Utils.$tc'Min1];

Data.Functor.Utils.$tcStateL2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateL"#;

Data.Functor.Utils.$tcStateL1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateL2];

Data.Functor.Utils.$tcStateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8498227433031831307##
                                    6442648285908986693##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateL1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep10_r1yo7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateL
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep10_r1yo7];

Data.Functor.Utils.$tc'StateL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateL"#;

Data.Functor.Utils.$tc'StateL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateL3];

Data.Functor.Utils.$tc'StateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8965240648136302046##
                                    8498113279827793106##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateL2
                                    2#
                                    Data.Functor.Utils.$tc'StateL1];

Data.Functor.Utils.$tcStateR2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateR"#;

Data.Functor.Utils.$tcStateR1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateR2];

Data.Functor.Utils.$tcStateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10049146831422350196##
                                    16883721947448934294##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateR1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep11_r1yo8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateR
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep11_r1yo8];

Data.Functor.Utils.$tc'StateR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateR"#;

Data.Functor.Utils.$tc'StateR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateR3];

Data.Functor.Utils.$tc'StateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13798701525568783897##
                                    17913645303573466967##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateR2
                                    2#
                                    Data.Functor.Utils.$tc'StateR1];


==================== STG syntax: ====================
2018-03-16 15:56:21.578426664 UTC

Data.Functor.Utils.$fMonoidMax_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zqr eta_s1zqs eta1_s1zqt]
        case eta1_s1zqt of wild_s1zqu {
          GHC.Base.Nothing -> eta_s1zqs;
          GHC.Base.Just ipv_s1zqv [Occ=Once] ->
              case eta_s1zqs of wild1_s1zqw {
                GHC.Base.Nothing -> wild_s1zqu;
                GHC.Base.Just x_s1zqx [Occ=Once] ->
                    case GHC.Classes.>= $dOrd_s1zqr x_s1zqx ipv_s1zqv of {
                      GHC.Types.False -> wild_s1zqu;
                      GHC.Types.True -> wild1_s1zqw;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Max a
     -> [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1zqz ww_s1zqA ww1_s1zqB]
        let {
          go_s1zqC [Occ=LoopBreaker]
            :: Data.Functor.Utils.Max a_s1ydG
               -> [Data.Functor.Utils.Max a_s1ydG]
               -> Data.Functor.Utils.Max a_s1ydG
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1zqz go_s1zqC] \r [b_s1zqD ds1_s1zqE]
                  case ds1_s1zqE of {
                    [] -> b_s1zqD;
                    : c_s1zqG [Occ=Once] cs_s1zqH [Occ=Once] ->
                        case go_s1zqC c_s1zqG cs_s1zqH of wild_s1zqI {
                          GHC.Base.Nothing -> b_s1zqD;
                          GHC.Base.Just ipv_s1zqJ [Occ=Once] ->
                              case b_s1zqD of wild2_s1zqK {
                                GHC.Base.Nothing -> wild_s1zqI;
                                GHC.Base.Just x_s1zqL [Occ=Once] ->
                                    case GHC.Classes.>= w_s1zqz x_s1zqL ipv_s1zqJ of {
                                      GHC.Types.False -> wild_s1zqI;
                                      GHC.Types.True -> wild2_s1zqK;
                                    };
                              };
                        };
                  };
        } in  go_s1zqC ww_s1zqA ww1_s1zqB;

Data.Functor.Utils.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Max a)
     -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1zqN w1_s1zqO]
        case w1_s1zqO of {
          GHC.Base.:| ww1_s1zqQ [Occ=Once] ww2_s1zqR [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat w_s1zqN ww1_s1zqQ ww2_s1zqR;
        };

Data.Functor.Utils.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1zqS]
        let {
          sat_s1zqV [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1zqS] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$cstimes $dOrd_s1zqS eta_B1; } in
        let {
          sat_s1zqU [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Max a_a1xV2)
               -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1zqS] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMax_$csconcat
                      $dOrd_s1zqS eta_B1; } in
        let {
          sat_s1zqT [Occ=Once]
            :: Data.Functor.Utils.Max a_a1xV2
               -> Data.Functor.Utils.Max a_a1xV2 -> Data.Functor.Utils.Max a_a1xV2
          [LclId] =
              [$dOrd_s1zqS] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1zqS eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1zqT sat_s1zqU sat_s1zqV];
Data.Functor.Utils.$fSemigroupMax_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zqW $dIntegral_s1zqX]
        let {
          sat_s1zqY [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_a1xV2)
          [LclId] =
              [$dOrd_s1zqW] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1zqW;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1zqX sat_s1zqY;

Data.Functor.Utils.$fMonoidMax_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Max a] -> Data.Functor.Utils.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zqZ eta_s1zr0]
        let {
          go_s1zr1 [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Max a_X1xVO]
               -> Data.Functor.Utils.Max a_X1xVO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1zqZ go_s1zr1] \r [ds_s1zr2]
                  case ds_s1zr2 of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1zr4 [Occ=Once*] ys_s1zr5 [Occ=Once] ->
                        case go_s1zr1 ys_s1zr5 of wild1_s1zr6 {
                          GHC.Base.Nothing -> y_s1zr4;
                          GHC.Base.Just ipv_s1zr7 [Occ=Once] ->
                              case y_s1zr4 of wild2_s1zr8 {
                                GHC.Base.Nothing -> wild1_s1zr6;
                                GHC.Base.Just x_s1zr9 [Occ=Once] ->
                                    case GHC.Classes.>= $dOrd_s1zqZ x_s1zr9 ipv_s1zr7 of {
                                      GHC.Types.False -> wild1_s1zr6;
                                      GHC.Types.True -> wild2_s1zr8;
                                    };
                              };
                        };
                  };
        } in  go_s1zr1 eta_s1zr0;

Data.Functor.Utils.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_s1zrb]
        let {
          sat_s1zre [Occ=Once]
            :: [Data.Functor.Utils.Max a_X1xVM]
               -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1zrb] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$cmconcat $dOrd_s1zrb eta_B1; } in
        let {
          sat_s1zrd [Occ=Once]
            :: Data.Functor.Utils.Max a_X1xVM
               -> Data.Functor.Utils.Max a_X1xVM -> Data.Functor.Utils.Max a_X1xVM
          [LclId] =
              [$dOrd_s1zrb] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMax_$c<> $dOrd_s1zrb eta_B2 eta_B1; } in
        let {
          sat_s1zrc [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Max a_X1xVM)
          [LclId] =
              [$dOrd_s1zrb] \u [] Data.Functor.Utils.$fSemigroupMax $dOrd_s1zrb;
        } in 
          GHC.Base.C:Monoid [sat_s1zrc GHC.Base.Nothing sat_s1zrd sat_s1zre];

Data.Functor.Utils.$fMonoidMin_$c<> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zrf eta_s1zrg eta1_s1zrh]
        case eta1_s1zrh of wild_s1zri {
          GHC.Base.Nothing -> eta_s1zrg;
          GHC.Base.Just ipv_s1zrj [Occ=Once] ->
              case eta_s1zrg of wild1_s1zrk {
                GHC.Base.Nothing -> wild_s1zri;
                GHC.Base.Just x_s1zrl [Occ=Once] ->
                    case GHC.Classes.<= $dOrd_s1zrf x_s1zrl ipv_s1zrj of {
                      GHC.Types.False -> wild_s1zri;
                      GHC.Types.True -> wild1_s1zrk;
                    };
              };
        };

Data.Functor.Utils.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Utils.Min a
     -> [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s1zrn ww_s1zro ww1_s1zrp]
        let {
          go_s1zrq [Occ=LoopBreaker]
            :: Data.Functor.Utils.Min a_s1ydZ
               -> [Data.Functor.Utils.Min a_s1ydZ]
               -> Data.Functor.Utils.Min a_s1ydZ
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s1zrn go_s1zrq] \r [b_s1zrr ds1_s1zrs]
                  case ds1_s1zrs of {
                    [] -> b_s1zrr;
                    : c_s1zru [Occ=Once] cs_s1zrv [Occ=Once] ->
                        case go_s1zrq c_s1zru cs_s1zrv of wild_s1zrw {
                          GHC.Base.Nothing -> b_s1zrr;
                          GHC.Base.Just ipv_s1zrx [Occ=Once] ->
                              case b_s1zrr of wild2_s1zry {
                                GHC.Base.Nothing -> wild_s1zrw;
                                GHC.Base.Just x_s1zrz [Occ=Once] ->
                                    case GHC.Classes.<= w_s1zrn x_s1zrz ipv_s1zrx of {
                                      GHC.Types.False -> wild_s1zrw;
                                      GHC.Types.True -> wild2_s1zry;
                                    };
                              };
                        };
                  };
        } in  go_s1zrq ww_s1zro ww1_s1zrp;

Data.Functor.Utils.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Functor.Utils.Min a)
     -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s1zrB w1_s1zrC]
        case w1_s1zrC of {
          GHC.Base.:| ww1_s1zrE [Occ=Once] ww2_s1zrF [Occ=Once] ->
              Data.Functor.Utils.$w$csconcat1 w_s1zrB ww1_s1zrE ww2_s1zrF;
        };

Data.Functor.Utils.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1zrG]
        let {
          sat_s1zrJ [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1zrG] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$cstimes $dOrd_s1zrG eta_B1; } in
        let {
          sat_s1zrI [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Utils.Min a_a1xTV)
               -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1zrG] \r [eta_B1]
                  Data.Functor.Utils.$fSemigroupMin_$csconcat
                      $dOrd_s1zrG eta_B1; } in
        let {
          sat_s1zrH [Occ=Once]
            :: Data.Functor.Utils.Min a_a1xTV
               -> Data.Functor.Utils.Min a_a1xTV -> Data.Functor.Utils.Min a_a1xTV
          [LclId] =
              [$dOrd_s1zrG] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1zrG eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s1zrH sat_s1zrI sat_s1zrJ];
Data.Functor.Utils.$fSemigroupMin_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Classes.Ord a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zrK $dIntegral_s1zrL]
        let {
          sat_s1zrM [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_a1xTV)
          [LclId] =
              [$dOrd_s1zrK] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1zrK;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s1zrL sat_s1zrM;

Data.Functor.Utils.$fMonoidMin_$cmconcat
  :: forall a.
     GHC.Classes.Ord a =>
     [Data.Functor.Utils.Min a] -> Data.Functor.Utils.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s1zrN eta_s1zrO]
        let {
          go_s1zrP [Occ=LoopBreaker]
            :: [Data.Functor.Utils.Min a_X1xUO]
               -> Data.Functor.Utils.Min a_X1xUO
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_s1zrN go_s1zrP] \r [ds_s1zrQ]
                  case ds_s1zrQ of {
                    [] -> GHC.Base.Nothing [];
                    : y_s1zrS [Occ=Once*] ys_s1zrT [Occ=Once] ->
                        case go_s1zrP ys_s1zrT of wild1_s1zrU {
                          GHC.Base.Nothing -> y_s1zrS;
                          GHC.Base.Just ipv_s1zrV [Occ=Once] ->
                              case y_s1zrS of wild2_s1zrW {
                                GHC.Base.Nothing -> wild1_s1zrU;
                                GHC.Base.Just x_s1zrX [Occ=Once] ->
                                    case GHC.Classes.<= $dOrd_s1zrN x_s1zrX ipv_s1zrV of {
                                      GHC.Types.False -> wild1_s1zrU;
                                      GHC.Types.True -> wild2_s1zrW;
                                    };
                              };
                        };
                  };
        } in  go_s1zrP eta_s1zrO;

Data.Functor.Utils.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Monoid (Data.Functor.Utils.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)>m] =
    [] \r [$dOrd_s1zrZ]
        let {
          sat_s1zs2 [Occ=Once]
            :: [Data.Functor.Utils.Min a_X1xUM]
               -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1zrZ] \r [eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$cmconcat $dOrd_s1zrZ eta_B1; } in
        let {
          sat_s1zs1 [Occ=Once]
            :: Data.Functor.Utils.Min a_X1xUM
               -> Data.Functor.Utils.Min a_X1xUM -> Data.Functor.Utils.Min a_X1xUM
          [LclId] =
              [$dOrd_s1zrZ] \r [eta_B2 eta_B1]
                  Data.Functor.Utils.$fMonoidMin_$c<> $dOrd_s1zrZ eta_B2 eta_B1; } in
        let {
          sat_s1zs0 [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Utils.Min a_X1xUM)
          [LclId] =
              [$dOrd_s1zrZ] \u [] Data.Functor.Utils.$fSemigroupMin $dOrd_s1zrZ;
        } in 
          GHC.Base.C:Monoid [sat_s1zs0 GHC.Base.Nothing sat_s1zs1 sat_s1zs2];

Data.Functor.Utils.$fFunctorStateL2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1zs3 ds_s1zs4 s1_s1zs5]
        let {
          ds1_s1zs6 [Dmd=<L,U(1*U,1*U)>] :: (s_a1xSQ, a_a1xSU)
          [LclId] =
              [ds_s1zs4 s1_s1zs5] \u [] ds_s1zs4 s1_s1zs5; } in
        let {
          sat_s1zsf [Occ=Once] :: b_a1xSV
          [LclId] =
              [f_s1zs3 ds1_s1zs6] \u []
                  let {
                    sat_s1zse [Occ=Once] :: a_a1xSU
                    [LclId] =
                        [ds1_s1zs6] \u []
                            case ds1_s1zs6 of {
                              (,) _ [Occ=Dead] v_s1zsd [Occ=Once] -> v_s1zsd;
                            };
                  } in  f_s1zs3 sat_s1zse; } in
        let {
          sat_s1zsa [Occ=Once] :: s_a1xSQ
          [LclId] =
              [ds1_s1zs6] \u []
                  case ds1_s1zs6 of {
                    (,) s'_s1zs8 [Occ=Once] _ [Occ=Dead] -> s'_s1zs8;
                  };
        } in  (,) [sat_s1zsa sat_s1zsf];

Data.Functor.Utils.$fFunctorStateL1
  :: forall b s a. a -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1zsg ds_s1zsh s1_s1zsi]
        let {
          sat_s1zsm [Occ=Once] :: s_X1xUk
          [LclId] =
              [ds_s1zsh s1_s1zsi] \u []
                  case ds_s1zsh s1_s1zsi of {
                    (,) s'_s1zsk [Occ=Once] _ [Occ=Dead] -> s'_s1zsk;
                  };
        } in  (,) [sat_s1zsm x_s1zsg];

Data.Functor.Utils.$fFunctorStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateL2
                                       Data.Functor.Utils.$fFunctorStateL1];

Data.Functor.Utils.$fApplicativeStateL3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1zsn w1_s1zso w2_s1zsp w3_s1zsq]
        let {
          ds_s1zsr [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, a_s1yeh)
          [LclId] =
              [w1_s1zso w3_s1zsq] \u [] w1_s1zso w3_s1zsq; } in
        let {
          ds1_s1zss [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeg, b_s1yei)
          [LclId] =
              [w2_s1zsp ds_s1zsr] \u []
                  let {
                    sat_s1zsw [Occ=Once] :: s_s1yeg
                    [LclId] =
                        [ds_s1zsr] \u []
                            case ds_s1zsr of {
                              (,) s'_s1zsu [Occ=Once] _ [Occ=Dead] -> s'_s1zsu;
                            };
                  } in  w2_s1zsp sat_s1zsw; } in
        let {
          sat_s1zsJ [Occ=Once] :: c_s1yej
          [LclId] =
              [w_s1zsn ds_s1zsr ds1_s1zss] \u []
                  let {
                    sat_s1zsI [Occ=Once] :: b_s1yei
                    [LclId] =
                        [ds1_s1zss] \u []
                            case ds1_s1zss of {
                              (,) _ [Occ=Dead] y_s1zsH [Occ=Once] -> y_s1zsH;
                            }; } in
                  let {
                    sat_s1zsE [Occ=Once] :: a_s1yeh
                    [LclId] =
                        [ds_s1zsr] \u []
                            case ds_s1zsr of {
                              (,) _ [Occ=Dead] x_s1zsD [Occ=Once] -> x_s1zsD;
                            };
                  } in  w_s1zsn sat_s1zsE sat_s1zsI; } in
        let {
          sat_s1zsA [Occ=Once] :: s_s1yeg
          [LclId] =
              [ds1_s1zss] \u []
                  case ds1_s1zss of {
                    (,) s''_s1zsy [Occ=Once] _ [Occ=Dead] -> s''_s1zsy;
                  };
        } in  (,) [sat_s1zsA sat_s1zsJ];

Data.Functor.Utils.$fApplicativeStateL4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateL s (a -> b)
     -> Data.Functor.Utils.StateL s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1zsK w1_s1zsL w2_s1zsM]
        let {
          ds_s1zsN [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yes, a_s1yet -> b_s1yeu)
          [LclId] =
              [w_s1zsK w2_s1zsM] \u [] w_s1zsK w2_s1zsM; } in
        let {
          ds1_s1zsO [Dmd=<L,U(1*U,1*U)>] :: (s_s1yes, a_s1yet)
          [LclId] =
              [w1_s1zsL ds_s1zsN] \u []
                  let {
                    sat_s1zsS [Occ=Once] :: s_s1yes
                    [LclId] =
                        [ds_s1zsN] \u []
                            case ds_s1zsN of {
                              (,) s'_s1zsQ [Occ=Once] _ [Occ=Dead] -> s'_s1zsQ;
                            };
                  } in  w1_s1zsL sat_s1zsS; } in
        let {
          sat_s1zt4 [Occ=Once] :: b_s1yeu
          [LclId] =
              [ds_s1zsN ds1_s1zsO] \u []
                  case ds_s1zsN of {
                    (,) _ [Occ=Dead] f_s1zsZ [Occ=Once!] ->
                        let {
                          sat_s1zt3 [Occ=Once] :: a_s1yet
                          [LclId] =
                              [ds1_s1zsO] \u []
                                  case ds1_s1zsO of {
                                    (,) _ [Occ=Dead] v_s1zt2 [Occ=Once] -> v_s1zt2;
                                  };
                        } in  f_s1zsZ sat_s1zt3;
                  }; } in
        let {
          sat_s1zsW [Occ=Once] :: s_s1yes
          [LclId] =
              [ds1_s1zsO] \u []
                  case ds1_s1zsO of {
                    (,) s''_s1zsU [Occ=Once] _ [Occ=Dead] -> s''_s1zsU;
                  };
        } in  (,) [sat_s1zsW sat_s1zt4];

Data.Functor.Utils.$fApplicativeStateL5
  :: forall s a. a -> s -> (s, a)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><L,U>m, Unf=OtherCon []] =
    [] \r [x_s1zt5 s1_s1zt6] (,) [s1_s1zt6 x_s1zt5];

Data.Functor.Utils.$fApplicativeStateL2
  :: forall b a s.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1zt7 a2_s1zt8 eta_s1zt9]
        let {
          ds_s1zta [Dmd=<L,U(1*U,1*U)>] :: (s_X1xSV, b_a1xSy)
          [LclId] =
              [a1_s1zt7 a2_s1zt8 eta_s1zt9] \u []
                  let {
                    sat_s1zte [Occ=Once] :: s_X1xSV
                    [LclId] =
                        [a1_s1zt7 eta_s1zt9] \u []
                            case a1_s1zt7 eta_s1zt9 of {
                              (,) s'_s1ztc [Occ=Once] _ [Occ=Dead] -> s'_s1ztc;
                            };
                  } in  a2_s1zt8 sat_s1zte; } in
        let {
          sat_s1ztm [Occ=Once] :: b_a1xSy
          [LclId] =
              [ds_s1zta] \u []
                  case ds_s1zta of {
                    (,) _ [Occ=Dead] v_s1ztl [Occ=Once] -> v_s1ztl;
                  }; } in
        let {
          sat_s1zti [Occ=Once] :: s_X1xSV
          [LclId] =
              [ds_s1zta] \u []
                  case ds_s1zta of {
                    (,) s''_s1ztg [Occ=Once] _ [Occ=Dead] -> s''_s1ztg;
                  };
        } in  (,) [sat_s1zti sat_s1ztm];

Data.Functor.Utils.$fApplicativeStateL1
  :: forall a s b.
     Data.Functor.Utils.StateL s a
     -> Data.Functor.Utils.StateL s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1ztn ds1_s1zto s1_s1ztp]
        let {
          ds2_s1ztq [Dmd=<L,U(1*U,1*U)>] :: (s_X1xST, a_a1xSH)
          [LclId] =
              [ds_s1ztn s1_s1ztp] \u [] ds_s1ztn s1_s1ztp; } in
        let {
          sat_s1ztC [Occ=Once] :: a_a1xSH
          [LclId] =
              [ds2_s1ztq] \u []
                  case ds2_s1ztq of {
                    (,) _ [Occ=Dead] x_s1ztB [Occ=Once] -> x_s1ztB;
                  }; } in
        let {
          sat_s1zty [Occ=Once] :: s_X1xST
          [LclId] =
              [ds1_s1zto ds2_s1ztq] \u []
                  let {
                    sat_s1ztu [Occ=Once] :: s_X1xST
                    [LclId] =
                        [ds2_s1ztq] \u []
                            case ds2_s1ztq of {
                              (,) s'_s1zts [Occ=Once] _ [Occ=Dead] -> s'_s1zts;
                            };
                  } in 
                    case ds1_s1zto sat_s1ztu of {
                      (,) s''_s1ztw [Occ=Once] _ [Occ=Dead] -> s''_s1ztw;
                    };
        } in  (,) [sat_s1zty sat_s1ztC];

Data.Functor.Utils.$fApplicativeStateL [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateL s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateL
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateL4
                                           Data.Functor.Utils.$fApplicativeStateL3
                                           Data.Functor.Utils.$fApplicativeStateL2
                                           Data.Functor.Utils.$fApplicativeStateL1];

Data.Functor.Utils.$fFunctorStateR2
  :: forall s a b.
     (a -> b) -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_s1ztD ds_s1ztE s1_s1ztF]
        let {
          ds1_s1ztG [Dmd=<L,U(1*U,1*U)>] :: (s_a1xQk, a_a1xQo)
          [LclId] =
              [ds_s1ztE s1_s1ztF] \u [] ds_s1ztE s1_s1ztF; } in
        let {
          sat_s1ztP [Occ=Once] :: b_a1xQp
          [LclId] =
              [f_s1ztD ds1_s1ztG] \u []
                  let {
                    sat_s1ztO [Occ=Once] :: a_a1xQo
                    [LclId] =
                        [ds1_s1ztG] \u []
                            case ds1_s1ztG of {
                              (,) _ [Occ=Dead] v_s1ztN [Occ=Once] -> v_s1ztN;
                            };
                  } in  f_s1ztD sat_s1ztO; } in
        let {
          sat_s1ztK [Occ=Once] :: s_a1xQk
          [LclId] =
              [ds1_s1ztG] \u []
                  case ds1_s1ztG of {
                    (,) s'_s1ztI [Occ=Once] _ [Occ=Dead] -> s'_s1ztI;
                  };
        } in  (,) [sat_s1ztK sat_s1ztP];

Data.Functor.Utils.$fFunctorStateR1
  :: forall b s a. a -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [x_s1ztQ ds_s1ztR s1_s1ztS]
        let {
          sat_s1ztW [Occ=Once] :: s_X1xSo
          [LclId] =
              [ds_s1ztR s1_s1ztS] \u []
                  case ds_s1ztR s1_s1ztS of {
                    (,) s'_s1ztU [Occ=Once] _ [Occ=Dead] -> s'_s1ztU;
                  };
        } in  (,) [sat_s1ztW x_s1ztQ];

Data.Functor.Utils.$fFunctorStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Functor (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Utils.$fFunctorStateR2
                                       Data.Functor.Utils.$fFunctorStateR1];

Data.Functor.Utils.$fApplicativeStateR3 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b c.
     (a -> b -> c)
     -> Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b
     -> s
     -> (s, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1ztX w1_s1ztY w2_s1ztZ w3_s1zu0]
        let {
          ds_s1zu1 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, b_s1yeE)
          [LclId] =
              [w2_s1ztZ w3_s1zu0] \u [] w2_s1ztZ w3_s1zu0; } in
        let {
          ds1_s1zu2 [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeC, a_s1yeD)
          [LclId] =
              [w1_s1ztY ds_s1zu1] \u []
                  let {
                    sat_s1zu6 [Occ=Once] :: s_s1yeC
                    [LclId] =
                        [ds_s1zu1] \u []
                            case ds_s1zu1 of {
                              (,) s'_s1zu4 [Occ=Once] _ [Occ=Dead] -> s'_s1zu4;
                            };
                  } in  w1_s1ztY sat_s1zu6; } in
        let {
          sat_s1zuj [Occ=Once] :: c_s1yeF
          [LclId] =
              [w_s1ztX ds_s1zu1 ds1_s1zu2] \u []
                  let {
                    sat_s1zui [Occ=Once] :: b_s1yeE
                    [LclId] =
                        [ds_s1zu1] \u []
                            case ds_s1zu1 of {
                              (,) _ [Occ=Dead] y_s1zuh [Occ=Once] -> y_s1zuh;
                            }; } in
                  let {
                    sat_s1zue [Occ=Once] :: a_s1yeD
                    [LclId] =
                        [ds1_s1zu2] \u []
                            case ds1_s1zu2 of {
                              (,) _ [Occ=Dead] x_s1zud [Occ=Once] -> x_s1zud;
                            };
                  } in  w_s1ztX sat_s1zue sat_s1zui; } in
        let {
          sat_s1zua [Occ=Once] :: s_s1yeC
          [LclId] =
              [ds1_s1zu2] \u []
                  case ds1_s1zu2 of {
                    (,) s''_s1zu8 [Occ=Once] _ [Occ=Dead] -> s''_s1zu8;
                  };
        } in  (,) [sat_s1zua sat_s1zuj];

Data.Functor.Utils.$fApplicativeStateR4 [InlPrag=NOUSERINLINE[0]]
  :: forall s a b.
     Data.Functor.Utils.StateR s (a -> b)
     -> Data.Functor.Utils.StateR s a -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*C1(U)))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1zuk w1_s1zul w2_s1zum]
        let {
          ds_s1zun [Dmd=<L,U(1*U,1*U)>] :: (s_s1yeO, a_s1yeP)
          [LclId] =
              [w1_s1zul w2_s1zum] \u [] w1_s1zul w2_s1zum; } in
        let {
          ds1_s1zuo [Dmd=<L,U(1*U,1*C1(U))>] :: (s_s1yeO, a_s1yeP -> b_s1yeQ)
          [LclId] =
              [w_s1zuk ds_s1zun] \u []
                  let {
                    sat_s1zus [Occ=Once] :: s_s1yeO
                    [LclId] =
                        [ds_s1zun] \u []
                            case ds_s1zun of {
                              (,) s'_s1zuq [Occ=Once] _ [Occ=Dead] -> s'_s1zuq;
                            };
                  } in  w_s1zuk sat_s1zus; } in
        let {
          sat_s1zuE [Occ=Once] :: b_s1yeQ
          [LclId] =
              [ds_s1zun ds1_s1zuo] \u []
                  case ds1_s1zuo of {
                    (,) _ [Occ=Dead] f_s1zuz [Occ=Once!] ->
                        let {
                          sat_s1zuD [Occ=Once] :: a_s1yeP
                          [LclId] =
                              [ds_s1zun] \u []
                                  case ds_s1zun of {
                                    (,) _ [Occ=Dead] v_s1zuC [Occ=Once] -> v_s1zuC;
                                  };
                        } in  f_s1zuz sat_s1zuD;
                  }; } in
        let {
          sat_s1zuw [Occ=Once] :: s_s1yeO
          [LclId] =
              [ds1_s1zuo] \u []
                  case ds1_s1zuo of {
                    (,) s''_s1zuu [Occ=Once] _ [Occ=Dead] -> s''_s1zuu;
                  };
        } in  (,) [sat_s1zuw sat_s1zuE];

Data.Functor.Utils.$fApplicativeStateR2
  :: forall b a s.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,A))><L,1*C1(U(1*U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [a1_s1zuF a2_s1zuG eta_s1zuH]
        let {
          ds_s1zuI [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQD, b_a1xPW)
          [LclId] =
              [a2_s1zuG eta_s1zuH] \u [] a2_s1zuG eta_s1zuH; } in
        let {
          sat_s1zuU [Occ=Once] :: b_a1xPW
          [LclId] =
              [ds_s1zuI] \u []
                  case ds_s1zuI of {
                    (,) _ [Occ=Dead] v_s1zuT [Occ=Once] -> v_s1zuT;
                  }; } in
        let {
          sat_s1zuQ [Occ=Once] :: s_X1xQD
          [LclId] =
              [a1_s1zuF ds_s1zuI] \u []
                  let {
                    sat_s1zuM [Occ=Once] :: s_X1xQD
                    [LclId] =
                        [ds_s1zuI] \u []
                            case ds_s1zuI of {
                              (,) s'_s1zuK [Occ=Once] _ [Occ=Dead] -> s'_s1zuK;
                            };
                  } in 
                    case a1_s1zuF sat_s1zuM of {
                      (,) s'_s1zuO [Occ=Once] _ [Occ=Dead] -> s'_s1zuO;
                    };
        } in  (,) [sat_s1zuQ sat_s1zuU];

Data.Functor.Utils.$fApplicativeStateR1
  :: forall a s b.
     Data.Functor.Utils.StateR s a
     -> Data.Functor.Utils.StateR s b -> s -> (s, a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,A))><L,U>m,
 Unf=OtherCon []] =
    [] \r [ds_s1zuV ds1_s1zuW s1_s1zuX]
        let {
          ds2_s1zuY [Dmd=<L,U(1*U,1*U)>] :: (s_X1xQB, a_a1xQb)
          [LclId] =
              [ds_s1zuV ds1_s1zuW s1_s1zuX] \u []
                  let {
                    sat_s1zv2 [Occ=Once] :: s_X1xQB
                    [LclId] =
                        [ds1_s1zuW s1_s1zuX] \u []
                            case ds1_s1zuW s1_s1zuX of {
                              (,) s'_s1zv0 [Occ=Once] _ [Occ=Dead] -> s'_s1zv0;
                            };
                  } in  ds_s1zuV sat_s1zv2; } in
        let {
          sat_s1zva [Occ=Once] :: a_a1xQb
          [LclId] =
              [ds2_s1zuY] \u []
                  case ds2_s1zuY of {
                    (,) _ [Occ=Dead] x_s1zv9 [Occ=Once] -> x_s1zv9;
                  }; } in
        let {
          sat_s1zv6 [Occ=Once] :: s_X1xQB
          [LclId] =
              [ds2_s1zuY] \u []
                  case ds2_s1zuY of {
                    (,) s''_s1zv4 [Occ=Once] _ [Occ=Dead] -> s''_s1zv4;
                  };
        } in  (,) [sat_s1zv6 sat_s1zva];

Data.Functor.Utils.$fApplicativeStateR [InlPrag=NOUSERINLINE CONLIKE]
  :: forall s. GHC.Base.Applicative (Data.Functor.Utils.StateR s)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Utils.$fFunctorStateR
                                           Data.Functor.Utils.$fApplicativeStateL5
                                           Data.Functor.Utils.$fApplicativeStateR4
                                           Data.Functor.Utils.$fApplicativeStateR3
                                           Data.Functor.Utils.$fApplicativeStateR2
                                           Data.Functor.Utils.$fApplicativeStateR1];

Data.Functor.Utils.getMax1
  :: forall a. Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zvb] ds_s1zvb;

Data.Functor.Utils.getMax
  :: forall a. Data.Functor.Utils.Max a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMax1 eta_B1;

Data.Functor.Utils.getMin1
  :: forall a. Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zvc] ds_s1zvc;

Data.Functor.Utils.getMin
  :: forall a. Data.Functor.Utils.Min a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.getMin1 eta_B1;

Data.Functor.Utils.runStateL1
  :: forall s a.
     Data.Functor.Utils.StateL s a -> Data.Functor.Utils.StateL s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zvd] ds_s1zvd;

Data.Functor.Utils.runStateL
  :: forall s a. Data.Functor.Utils.StateL s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateL1 eta_B1;

Data.Functor.Utils.runStateR1
  :: forall s a.
     Data.Functor.Utils.StateR s a -> Data.Functor.Utils.StateR s a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s1zve] ds_s1zve;

Data.Functor.Utils.runStateR
  :: forall s a. Data.Functor.Utils.StateR s a -> s -> (s, a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Utils.runStateR1 eta_B1;

Data.Functor.Utils.#. [InlPrag=INLINE (sat-args=1)]
  :: forall b c a.
     GHC.Types.Coercible b c =>
     (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dCoercible_s1zvf eta_s1zvg eta1_s1zvh]
        case GHC.Types.coercible_sel $dCoercible_s1zvf of {
          (##) -> eta1_s1zvh;
        };

Data.Functor.Utils.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Utils.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule4];

Data.Functor.Utils.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Utils"#;

Data.Functor.Utils.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$trModule2];

Data.Functor.Utils.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Utils.$trModule3
                                     Data.Functor.Utils.$trModule1];

$krep_r1ynX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r1ynY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r1ynZ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r1ynX GHC.Types.[]];

$krep3_r1yo0 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY $krep2_r1ynZ];

$krep4_r1yo1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep3_r1yo0];

$krep5_r1yo2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1ynY $krep4_r1yo1];

$krep6_r1yo3 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1ynY GHC.Types.[]];

$krep7_r1yo4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep6_r1yo3];

Data.Functor.Utils.$tcMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Functor.Utils.$tcMax1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMax2];

Data.Functor.Utils.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17055998897267803697##
                                    13070619747111935994##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMax1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep8_r1yo5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMax
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep8_r1yo5];

Data.Functor.Utils.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Functor.Utils.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Max3];

Data.Functor.Utils.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16178335003924091205##
                                    10384293407056089504##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Max2
                                    1#
                                    Data.Functor.Utils.$tc'Max1];

Data.Functor.Utils.$tcMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Functor.Utils.$tcMin1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcMin2];

Data.Functor.Utils.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13719831963261617173##
                                    12509304105097421826##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcMin1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r1yo6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcMin
                                              $krep6_r1yo3];

Data.Functor.Utils.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1yo4 $krep9_r1yo6];

Data.Functor.Utils.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Functor.Utils.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'Min3];

Data.Functor.Utils.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3497961960072019520##
                                    14191657227527039212##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'Min2
                                    1#
                                    Data.Functor.Utils.$tc'Min1];

Data.Functor.Utils.$tcStateL2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateL"#;

Data.Functor.Utils.$tcStateL1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateL2];

Data.Functor.Utils.$tcStateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8498227433031831307##
                                    6442648285908986693##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateL1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep10_r1yo7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateL
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateL1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep10_r1yo7];

Data.Functor.Utils.$tc'StateL3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateL"#;

Data.Functor.Utils.$tc'StateL2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateL3];

Data.Functor.Utils.$tc'StateL :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8965240648136302046##
                                    8498113279827793106##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateL2
                                    2#
                                    Data.Functor.Utils.$tc'StateL1];

Data.Functor.Utils.$tcStateR2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "StateR"#;

Data.Functor.Utils.$tcStateR1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tcStateR2];

Data.Functor.Utils.$tcStateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10049146831422350196##
                                    16883721947448934294##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tcStateR1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep11_r1yo8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Utils.$tcStateR
                                              $krep3_r1yo0];

Data.Functor.Utils.$tc'StateR1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r1yo2 $krep11_r1yo8];

Data.Functor.Utils.$tc'StateR3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'StateR"#;

Data.Functor.Utils.$tc'StateR2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Utils.$tc'StateR3];

Data.Functor.Utils.$tc'StateR :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13798701525568783897##
                                    17913645303573466967##
                                    Data.Functor.Utils.$trModule
                                    Data.Functor.Utils.$tc'StateR2
                                    2#
                                    Data.Functor.Utils.$tc'StateR1];

