
==================== Output Cmm ====================
2018-03-16 16:06:35.723875507 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:35.724493138 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity4_closure" {
     Data.Functor.Identity.$fReadIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.725108167 UTC

[section ""cstring" . Data.Functor.Identity.$fReadIdentity6_bytes" {
     Data.Functor.Identity.$fReadIdentity6_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.726002042 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity5_closure" {
     Data.Functor.Identity.$fReadIdentity5_closure:
         const Data.Functor.Identity.$fReadIdentity5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity5_entry() //  [R1]
         { info_tbl: [(cbJyc,
                       label: Data.Functor.Identity.$fReadIdentity5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJyd; else goto cbJye;
       cbJyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJye: // global
           (_cbJy9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbJy9::I64 == 0) goto cbJyb; else goto cbJya;
       cbJyb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbJya: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbJy9::I64;
           R2 = Data.Functor.Identity.$fReadIdentity6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.728643705 UTC

[section ""data" . Data.Functor.Identity.$w$creadsPrec_closure" {
     Data.Functor.Identity.$w$creadsPrec_closure:
         const Data.Functor.Identity.$w$creadsPrec_info;
         const 0;
 },
 go1_sbJto_entry() //  [R1, R2]
         { info_tbl: [(cbJyR,
                       label: go1_sbJto_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbJyS; else goto cbJyT;
       cbJyS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJyT: // global
           I64[Sp - 24] = block_cbJyK_info;
           _sbJto::P64 = R1;
           _sbJtn::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sbJtn::P64;
           P64[Sp - 8] = _sbJto::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubJzb; else goto cbJyL;
       ubJzb: // global
           call _cbJyK(R1) args: 0, res: 0, upd: 0;
       cbJyL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbJyK() //  [R1]
         { info_tbl: [(cbJyK,
                       label: block_cbJyK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyK: // global
           if (R1 & 7 == 1) goto cbJyO; else goto cbJyP;
       cbJyO: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbJyP: // global
           I64[Sp] = block_cbJyZ_info;
           _sbJts::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbJts::P64;
           if (R1 & 7 != 0) goto ubJza; else goto cbJz0;
       ubJza: // global
           call _cbJyZ(R1) args: 0, res: 0, upd: 0;
       cbJz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbJyZ() //  [R1]
         { info_tbl: [(cbJyZ,
                       label: block_cbJyZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbJz9; else goto cbJz8;
       cbJz9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbJz8: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sbJte_entry() //  [R1, R2]
         { info_tbl: [(cbJzg,
                       label: go_sbJte_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJzg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbJzh; else goto ubJzB;
       cbJzh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubJzB: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbJyl() args: 0, res: 0, upd: 0;
     }
 },
 _cbJyl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyl: // global
           _sbJtb::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cbJyo_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbJtb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubJzD; else goto cbJyp;
       ubJzD: // global
           call _cbJyo(R1) args: 0, res: 0, upd: 0;
       cbJyp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbJyo() //  [R1]
         { info_tbl: [(cbJyo,
                       label: block_cbJyo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyo: // global
           if (R1 & 7 == 1) goto cbJzd; else goto cbJze;
       cbJzd: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbJze: // global
           I64[Sp - 8] = block_cbJyu_info;
           _sbJti::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbJti::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubJzE; else goto cbJyv;
       ubJzE: // global
           call _cbJyu(R1) args: 0, res: 0, upd: 0;
       cbJyv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbJyu() //  [R1]
         { info_tbl: [(cbJyu,
                       label: block_cbJyu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyu: // global
           I64[Sp - 8] = block_cbJyz_info;
           R3 = Data.Functor.Identity.$fReadIdentity5_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbJyz() //  [R1]
         { info_tbl: [(cbJyz,
                       label: block_cbJyz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJyz: // global
           _sbJti::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbJzq; else goto cbJzs;
       cbJzq: // global
           P64[Sp + 32] = _sbJti::P64;
           Sp = Sp + 24;
           call _cbJyl() args: 0, res: 0, upd: 0;
       cbJzs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbJzv; else goto cbJzu;
       cbJzv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbJzu: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbJti::P64;
           I64[Hp - 8] = go1_sbJto_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_cbJzr_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _sbJtl::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp + 16] = _sbJtl::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbJzr() //  [R1]
         { info_tbl: [(cbJzr,
                       label: block_cbJzr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJzr: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbJto_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtD_entry() //  [R1, R2]
         { info_tbl: [(cbJzO,
                       label: sat_sbJtD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJzO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJzP; else goto cbJzQ;
       cbJzP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJzQ: // global
           I64[Sp - 16] = block_cbJzM_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbJzM() //  [R1]
         { info_tbl: [(cbJzM,
                       label: block_cbJzM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJzM: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sbJte_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbJzW,
                       label: Data.Functor.Identity.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJzW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbJA0; else goto cbJzZ;
       cbJA0: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJzZ: // global
           I64[Hp - 24] = go_sbJte_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbJtD_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sbJtA::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sbJtA::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.732491832 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbJA9,
                       label: Data.Functor.Identity.$fReadIdentity_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJA9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbJAa; else goto cbJAb;
       cbJAa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJAb: // global
           I64[Sp - 24] = block_cbJA6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubJAf; else goto cbJA7;
       ubJAf: // global
           call _cbJA6(R1) args: 0, res: 0, upd: 0;
       cbJA7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbJA6() //  [R1]
         { info_tbl: [(cbJA6,
                       label: block_cbJA6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJA6: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$creadsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.734030131 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity3_closure" {
     Data.Functor.Identity.$fReadIdentity3_closure:
         const Data.Functor.Identity.$fReadIdentity3_info;
         const 0;
 },
 sat_sbJtM_entry() //  [R1, R2]
         { info_tbl: [(cbJAp,
                       label: sat_sbJtM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJAp: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbJAv,
                       label: Data.Functor.Identity.$fReadIdentity3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJAv: // global
           _sbJtL::P64 = R4;
           _sbJtK::P64 = R3;
           _sbJtJ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbJAw; else goto cbJAx;
       cbJAx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJAz; else goto cbJAy;
       cbJAz: // global
           HpAlloc = 24;
           goto cbJAw;
       cbJAw: // global
           R4 = _sbJtL::P64;
           R3 = _sbJtK::P64;
           R2 = _sbJtJ::P64;
           R1 = Data.Functor.Identity.$fReadIdentity3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJAy: // global
           I64[Hp - 16] = sat_sbJtM_info;
           P64[Hp - 8] = _sbJtJ::P64;
           P64[Hp] = _sbJtK::P64;
           I64[Sp - 8] = block_cbJAs_info;
           R3 = _sbJtL::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbJAs() //  [R1]
         { info_tbl: [(cbJAs,
                       label: block_cbJAs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJAs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJAC; else goto cbJAB;
       cbJAC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbJAB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.735472679 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity2_closure" {
     Data.Functor.Identity.$fReadIdentity2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.736516709 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadList_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadList_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadList_info;
         const 0;
 },
 sat_sbJtQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbJAQ,
                       label: sat_sbJtQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJAQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtR_entry() //  [R1]
         { info_tbl: [(cbJAT,
                       label: sat_sbJtR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJAT: // global
           _sbJtR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbJAU; else goto cbJAV;
       cbJAV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJAX; else goto cbJAW;
       cbJAX: // global
           HpAlloc = 16;
           goto cbJAU;
       cbJAU: // global
           R1 = _sbJtR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJAW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJtR::P64;
           _sbJtP::P64 = P64[_sbJtR::P64 + 16];
           I64[Hp - 8] = sat_sbJtQ_info;
           P64[Hp] = _sbJtP::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fReadIdentity_$creadList_entry() //  [R2]
         { info_tbl: [(cbJAY,
                       label: Data.Functor.Identity.$fReadIdentity_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJAY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJB2; else goto cbJB1;
       cbJB2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJB1: // global
           I64[Hp - 16] = sat_sbJtR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.738797489 UTC

[section ""data" . Data.Functor.Identity.$w$creadListPrec_closure" {
     Data.Functor.Identity.$w$creadListPrec_closure:
         const Data.Functor.Identity.$w$creadListPrec_info;
         const 0;
 },
 sat_sbJtU_entry() //  [R1, R2, R3]
         { info_tbl: [(cbJBg,
                       label: sat_sbJtU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_sbJtT_entry() //  [R1]
         { info_tbl: [(cbJBj,
                       label: w1_sbJtT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBj: // global
           _sbJtT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbJBk; else goto cbJBl;
       cbJBl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJBn; else goto cbJBm;
       cbJBn: // global
           HpAlloc = 16;
           goto cbJBk;
       cbJBk: // global
           R1 = _sbJtT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJBm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJtT::P64;
           _sbJtS::P64 = P64[_sbJtT::P64 + 16];
           I64[Hp - 8] = sat_sbJtU_info;
           P64[Hp] = _sbJtS::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_sbJtV_entry() //  [R1, R2]
         { info_tbl: [(cbJBt,
                       label: w2_sbJtV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtZ_entry() //  [R1, R2]
         { info_tbl: [(cbJBE,
                       label: sat_sbJtZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbJBF; else goto cbJBG;
       cbJBF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJBG: // global
           I64[Sp - 8] = block_cbJBB_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbJBB() //  [R1]
         { info_tbl: [(cbJBB,
                       label: block_cbJBB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJBJ; else goto cbJBI;
       cbJBJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbJBI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbJBK,
                       label: Data.Functor.Identity.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbJBO; else goto cbJBN;
       cbJBO: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJBN: // global
           I64[Hp - 48] = w1_sbJtT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_sbJtV_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbJtZ_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.740994867 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity1_closure" {
     Data.Functor.Identity.$fReadIdentity1_closure:
         const Data.Functor.Identity.$fReadIdentity1_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity1_entry() //  [R2]
         { info_tbl: [(cbJBT,
                       label: Data.Functor.Identity.$fReadIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJBT: // global
           R2 = R2;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.742526052 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_closure" {
     Data.Functor.Identity.$fReadIdentity_closure:
         const Data.Functor.Identity.$fReadIdentity_info;
         const 0;
 },
 lvl1_sbJu3_entry() //  [R1]
         { info_tbl: [(cbJC4,
                       label: lvl1_sbJu3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJC4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJC5; else goto cbJC6;
       cbJC5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJC6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJu8_entry() //  [R1]
         { info_tbl: [(cbJCc,
                       label: sat_sbJu8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCc: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJu6_entry() //  [R1, R2, R3]
         { info_tbl: [(cbJCk,
                       label: sat_sbJu6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJu5_entry() //  [R1]
         { info_tbl: [(cbJCr,
                       label: sat_sbJu5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJCs; else goto cbJCt;
       cbJCs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJCt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fReadIdentity_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJu4_entry() //  [R1, R2, R3]
         { info_tbl: [(cbJCz,
                       label: sat_sbJu4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity_entry() //  [R2]
         { info_tbl: [(cbJCD,
                       label: Data.Functor.Identity.$fReadIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCD: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbJCH; else goto cbJCG;
       cbJCH: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJCG: // global
           I64[Hp - 128] = lvl1_sbJu3_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJu8_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sbJu6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJu5_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJu4_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.744487176 UTC

[section ""cstring" . Data.Functor.Identity.$fShowIdentity2_bytes" {
     Data.Functor.Identity.$fShowIdentity2_bytes:
         I8[] [73,100,101,110,116,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.745286517 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity1_closure" {
     Data.Functor.Identity.$fShowIdentity1_closure:
         const Data.Functor.Identity.$fShowIdentity1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity1_entry() //  [R1]
         { info_tbl: [(cbJCO,
                       label: Data.Functor.Identity.$fShowIdentity1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJCP; else goto cbJCQ;
       cbJCP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJCQ: // global
           (_cbJCL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbJCL::I64 == 0) goto cbJCN; else goto cbJCM;
       cbJCN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbJCM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbJCL::I64;
           R2 = Data.Functor.Identity.$fShowIdentity2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.749084805 UTC

[section ""data" . Data.Functor.Identity.$w$cshowsPrec_closure" {
     Data.Functor.Identity.$w$cshowsPrec_closure:
         const Data.Functor.Identity.$w$cshowsPrec_info;
         const 0;
 },
 g_sbJuc_entry() //  [R1]
         { info_tbl: [(cbJCZ,
                       label: g_sbJuc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJCZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbJD0; else goto cbJD1;
       cbJD0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJD1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbJuf_entry() //  [R1]
         { info_tbl: [(cbJDe,
                       label: sat_sbJuf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJDe: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJug_entry() //  [R1, R2]
         { info_tbl: [(cbJDh,
                       label: sat_sbJug_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJDh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbJDl; else goto cbJDk;
       cbJDl: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJDk: // global
           _sbJuc::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbJuf_info;
           P64[Hp - 8] = _sbJuc::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuj_entry() //  [R1]
         { info_tbl: [(cbJDB,
                       label: sat_sbJuj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJDB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJDF; else goto cbJDE;
       cbJDF: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJDE: // global
           _sbJuc::P64 = P64[R1 + 16];
           _sbJuh::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbJuh::P64;
           R2 = Hp - 14;
           R1 = _sbJuc::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuk_entry() //  [R1]
         { info_tbl: [(cbJDG,
                       label: sat_sbJuk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJDG: // global
           _sbJuk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbJDH; else goto cbJDI;
       cbJDI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbJDK; else goto cbJDJ;
       cbJDK: // global
           HpAlloc = 32;
           goto cbJDH;
       cbJDH: // global
           R1 = _sbJuk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJDJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJuk::P64;
           _sbJuc::P64 = P64[_sbJuk::P64 + 16];
           _sbJuh::P64 = P64[_sbJuk::P64 + 24];
           I64[Hp - 24] = sat_sbJuj_info;
           P64[Hp - 8] = _sbJuc::P64;
           P64[Hp] = _sbJuh::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJul_entry() //  [R1, R2]
         { info_tbl: [(cbJDM,
                       label: sat_sbJul_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJDM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbJDQ; else goto cbJDP;
       cbJDQ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJDP: // global
           _sbJuc::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbJuk_info;
           P64[Hp - 32] = _sbJuc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbJDU,
                       label: Data.Functor.Identity.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJDU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbJDY; else goto cbJDX;
       cbJDY: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJDX: // global
           I64[Hp - 40] = g_sbJuc_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbJCV::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto cbJDS; else goto cbJDT;
       cbJDS: // global
           I64[Hp - 8] = sat_sbJug_info;
           P64[Hp] = _cbJCV::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbJDT: // global
           I64[Hp - 8] = sat_sbJul_info;
           P64[Hp] = _cbJCV::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.752027034 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbJE6,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJE6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbJE7; else goto cbJE8;
       cbJE7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJE8: // global
           I64[Sp - 24] = block_cbJE3_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubJEc; else goto cbJE4;
       ubJEc: // global
           call _cbJE3(R1) args: 0, res: 0, upd: 0;
       cbJE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbJE3() //  [R1]
         { info_tbl: [(cbJE3,
                       label: block_cbJE3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJE3: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.75340454 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshow_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshow_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshow_info;
         const 0;
 },
 sat_sbJut_entry() //  [R1]
         { info_tbl: [(cbJEl,
                       label: sat_sbJut_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJEl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbJEm; else goto cbJEn;
       cbJEm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJEn: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbJEo,
                       label: Data.Functor.Identity.$fShowIdentity_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJEo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbJEs; else goto cbJEr;
       cbJEs: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJEr: // global
           I64[Hp - 24] = sat_sbJut_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.754754844 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowList_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowList_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowList_info;
         const 0;
 },
 sat_sbJuy_entry() //  [R1, R2]
         { info_tbl: [(cbJEC,
                       label: sat_sbJuy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJEC: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshowList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbJEF,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJEF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJEJ; else goto cbJEI;
       cbJEJ: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJEI: // global
           I64[Hp - 8] = sat_sbJuy_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.756284521 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_closure" {
     Data.Functor.Identity.$fShowIdentity_closure:
         const Data.Functor.Identity.$fShowIdentity_info;
         const 0;
 },
 sat_sbJuC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbJET,
                       label: sat_sbJuC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJET: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuB_entry() //  [R1, R2]
         { info_tbl: [(cbJF1,
                       label: sat_sbJuB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJF1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fShowIdentity_$cshow_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbJF9,
                       label: sat_sbJuA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJF9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_entry() //  [R2]
         { info_tbl: [(cbJFd,
                       label: Data.Functor.Identity.$fShowIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFd: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbJFh; else goto cbJFg;
       cbJFh: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJFg: // global
           I64[Hp - 72] = sat_sbJuC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJuB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJuA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.757759666 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity4_closure" {
     Data.Functor.Identity.$fFoldableIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.758419031 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$clength_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$clength_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$clength_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$clength_entry() //  []
         { info_tbl: [(cbJFm,
                       label: Data.Functor.Identity.$fFoldableIdentity_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFm: // global
           R1 = Data.Functor.Identity.$fFoldableIdentity4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.759205482 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cnull_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cnull_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cnull_entry() //  []
         { info_tbl: [(cbJFt,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.760069709 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$ctoList_entry() //  [R2]
         { info_tbl: [(cbJFB,
                       label: Data.Functor.Identity.$fFoldableIdentity_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJFF; else goto cbJFE;
       cbJFF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJFE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.760993735 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity6_closure" {
     Data.Functor.Identity.$fFoldableIdentity6_closure:
         const Data.Functor.Identity.$fFoldableIdentity6_info;
 },
 Data.Functor.Identity.$fFoldableIdentity6_entry() //  [R2]
         { info_tbl: [(cbJFK,
                       label: Data.Functor.Identity.$fFoldableIdentity6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.76199023 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cfoldr_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbJFR,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFR: // global
           R3 = R3;
           _sbJuH::P64 = R2;
           R2 = R4;
           R1 = _sbJuH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.762818432 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity7_closure" {
     Data.Functor.Identity.$fFoldableIdentity7_closure:
         const Data.Functor.Identity.$fFoldableIdentity7_info;
 },
 Data.Functor.Identity.$fFoldableIdentity7_entry() //  [R3]
         { info_tbl: [(cbJFY,
                       label: Data.Functor.Identity.$fFoldableIdentity7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJFY: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.763586184 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity2_closure" {
     Data.Functor.Identity.$fFunctorIdentity2_closure:
         const Data.Functor.Identity.$fFunctorIdentity2_info;
 },
 Data.Functor.Identity.$fFunctorIdentity2_entry() //  [R2]
         { info_tbl: [(cbJG5,
                       label: Data.Functor.Identity.$fFunctorIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJG5: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.76437328 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity1_closure" {
     Data.Functor.Identity.$fFunctorIdentity1_closure:
         const Data.Functor.Identity.$fFunctorIdentity1_info;
 },
 Data.Functor.Identity.$fFunctorIdentity1_entry() //  [R2]
         { info_tbl: [(cbJGc,
                       label: Data.Functor.Identity.$fFunctorIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.765041107 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity_closure" {
     Data.Functor.Identity.$fFunctorIdentity_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Identity.$fFunctorIdentity2_closure+1;
         const Data.Functor.Identity.$fFunctorIdentity1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.76578002 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity1_closure" {
     Data.Functor.Identity.$fApplicativeIdentity1_closure:
         const Data.Functor.Identity.$fApplicativeIdentity1_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity1_entry() //  [R2]
         { info_tbl: [(cbJGj,
                       label: Data.Functor.Identity.$fApplicativeIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGj: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.766581827 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity2_closure" {
     Data.Functor.Identity.$fApplicativeIdentity2_closure:
         const Data.Functor.Identity.$fApplicativeIdentity2_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity2_entry() //  [R2]
         { info_tbl: [(cbJGq,
                       label: Data.Functor.Identity.$fApplicativeIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.767410857 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity3_closure" {
     Data.Functor.Identity.$fApplicativeIdentity3_closure:
         const Data.Functor.Identity.$fApplicativeIdentity3_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity3_entry() //  [R2]
         { info_tbl: [(cbJGx,
                       label: Data.Functor.Identity.$fApplicativeIdentity3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGx: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.768248228 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure:
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry() //  [R3]
         { info_tbl: [(cbJGE,
                       label: Data.Functor.Identity.$fApplicativeIdentity_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGE: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.768925957 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity2_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity1_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure+2;
         const GHC.Base.const_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.7705869 UTC

[section ""data" . Data.Functor.Identity.$fStorableIdentity_closure" {
     Data.Functor.Identity.$fStorableIdentity_closure:
         const Data.Functor.Identity.$fStorableIdentity_info;
 },
 sat_sbJv2_entry() //  [R1]
         { info_tbl: [(cbJGP,
                       label: sat_sbJv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJGQ; else goto cbJGR;
       cbJGQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJGR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv1_entry() //  [R1]
         { info_tbl: [(cbJGW,
                       label: sat_sbJv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJGW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJGX; else goto cbJGY;
       cbJGX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJGY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv0_entry() //  [R1]
         { info_tbl: [(cbJH3,
                       label: sat_sbJv0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJH3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJH4; else goto cbJH5;
       cbJH4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJH5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuZ_entry() //  [R1]
         { info_tbl: [(cbJHa,
                       label: sat_sbJuZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJHb; else goto cbJHc;
       cbJHb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJHc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuY_entry() //  [R1]
         { info_tbl: [(cbJHh,
                       label: sat_sbJuY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJHi; else goto cbJHj;
       cbJHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuX_entry() //  [R1]
         { info_tbl: [(cbJHo,
                       label: sat_sbJuX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJHp; else goto cbJHq;
       cbJHp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJHq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuW_entry() //  [R1]
         { info_tbl: [(cbJHv,
                       label: sat_sbJuW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJHw; else goto cbJHx;
       cbJHw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJHx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuV_entry() //  [R1]
         { info_tbl: [(cbJHC,
                       label: sat_sbJuV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJHD; else goto cbJHE;
       cbJHD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJHE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fStorableIdentity_entry() //  [R2]
         { info_tbl: [(cbJHG,
                       label: Data.Functor.Identity.$fStorableIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHG: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbJHK; else goto cbJHJ;
       cbJHK: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fStorableIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJHJ: // global
           I64[Hp - 256] = sat_sbJv2_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJv1_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJv0_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJuZ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJuY_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJuX_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJuW_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJuV_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.774348199 UTC

[section ""data" . Data.Functor.Identity.$fNumIdentity_closure" {
     Data.Functor.Identity.$fNumIdentity_closure:
         const Data.Functor.Identity.$fNumIdentity_info;
 },
 sat_sbJva_entry() //  [R1]
         { info_tbl: [(cbJHT,
                       label: sat_sbJva_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJHT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJHU; else goto cbJHV;
       cbJHU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJHV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv9_entry() //  [R1]
         { info_tbl: [(cbJI0,
                       label: sat_sbJv9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJI0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJI1; else goto cbJI2;
       cbJI1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJI2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv8_entry() //  [R1]
         { info_tbl: [(cbJI7,
                       label: sat_sbJv8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJI7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJI8; else goto cbJI9;
       cbJI8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJI9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv7_entry() //  [R1]
         { info_tbl: [(cbJIe,
                       label: sat_sbJv7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJIe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJIf; else goto cbJIg;
       cbJIf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJIg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv6_entry() //  [R1]
         { info_tbl: [(cbJIl,
                       label: sat_sbJv6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJIl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJIm; else goto cbJIn;
       cbJIm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJIn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv5_entry() //  [R1]
         { info_tbl: [(cbJIs,
                       label: sat_sbJv5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJIs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJIt; else goto cbJIu;
       cbJIt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJIu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv4_entry() //  [R1]
         { info_tbl: [(cbJIz,
                       label: sat_sbJv4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJIz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJIA; else goto cbJIB;
       cbJIA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJIB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fNumIdentity_entry() //  [R2]
         { info_tbl: [(cbJID,
                       label: Data.Functor.Identity.$fNumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJID: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbJIH; else goto cbJIG;
       cbJIH: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fNumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJIG: // global
           I64[Hp - 224] = sat_sbJva_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJv9_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJv8_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJv7_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJv6_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJv5_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJv4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.776994783 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp1Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp1Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp1Real_info;
 },
 sat_sbJvc_entry() //  [R1]
         { info_tbl: [(cbJIQ,
                       label: sat_sbJvc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJIQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJIR; else goto cbJIS;
       cbJIR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJIS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp1Real_entry() //  [R2]
         { info_tbl: [(cbJIT,
                       label: Data.Functor.Identity.$fRealIdentity_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJIT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJIX; else goto cbJIW;
       cbJIX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJIW: // global
           I64[Hp - 16] = sat_sbJvc_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.778527853 UTC

[section ""data" . Data.Functor.Identity.$fSemigroupIdentity_closure" {
     Data.Functor.Identity.$fSemigroupIdentity_closure:
         const Data.Functor.Identity.$fSemigroupIdentity_info;
 },
 sat_sbJvg_entry() //  [R1]
         { info_tbl: [(cbJJ6,
                       label: sat_sbJvg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJJ7; else goto cbJJ8;
       cbJJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJJ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvf_entry() //  [R1]
         { info_tbl: [(cbJJd,
                       label: sat_sbJvf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJJe; else goto cbJJf;
       cbJJe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJJf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJve_entry() //  [R1]
         { info_tbl: [(cbJJk,
                       label: sat_sbJve_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJJl; else goto cbJJm;
       cbJJl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJJm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fSemigroupIdentity_entry() //  [R2]
         { info_tbl: [(cbJJo,
                       label: Data.Functor.Identity.$fSemigroupIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJo: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbJJs; else goto cbJJr;
       cbJJs: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fSemigroupIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJJr: // global
           I64[Hp - 96] = sat_sbJvg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJvf_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJve_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.780306656 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure" {
     Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure:
         const Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info;
 },
 sat_sbJvi_entry() //  [R1]
         { info_tbl: [(cbJJB,
                       label: sat_sbJvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJJC; else goto cbJJD;
       cbJJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cbJJE,
                       label: Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJJI; else goto cbJJH;
       cbJJI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJJH: // global
           I64[Hp - 16] = sat_sbJvi_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fSemigroupIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.78193406 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_closure" {
     Data.Functor.Identity.$fMonoidIdentity_closure:
         const Data.Functor.Identity.$fMonoidIdentity_info;
 },
 sat_sbJvn_entry() //  [R1]
         { info_tbl: [(cbJJR,
                       label: sat_sbJvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJJS; else goto cbJJT;
       cbJJS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJJT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvm_entry() //  [R1]
         { info_tbl: [(cbJJY,
                       label: sat_sbJvm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJJZ; else goto cbJK0;
       cbJJZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJK0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvl_entry() //  [R1]
         { info_tbl: [(cbJK5,
                       label: sat_sbJvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJK5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJK6; else goto cbJK7;
       cbJK6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJK7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvk_entry() //  [R1]
         { info_tbl: [(cbJKc,
                       label: sat_sbJvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJKd; else goto cbJKe;
       cbJKd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJKe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_entry() //  [R2]
         { info_tbl: [(cbJKg,
                       label: Data.Functor.Identity.$fMonoidIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKg: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbJKk; else goto cbJKj;
       cbJKk: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJKj: // global
           I64[Hp - 128] = sat_sbJvn_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJvm_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJvl_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJvk_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.783785356 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity1_closure" {
     Data.Functor.Identity.$fGeneric1Identity1_closure:
         const Data.Functor.Identity.$fGeneric1Identity1_info;
 },
 Data.Functor.Identity.$fGeneric1Identity1_entry() //  [R2]
         { info_tbl: [(cbJKp,
                       label: Data.Functor.Identity.$fGeneric1Identity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.784559609 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity2_closure" {
     Data.Functor.Identity.$fFoldableIdentity2_closure:
         const Data.Functor.Identity.$fFoldableIdentity2_info;
 },
 Data.Functor.Identity.$fFoldableIdentity2_entry() //  [R2]
         { info_tbl: [(cbJKw,
                       label: Data.Functor.Identity.$fFoldableIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKw: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.785595378 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity_closure" {
     Data.Functor.Identity.$fGeneric1Identity_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Identity.$fFoldableIdentity2_closure+1;
         const Data.Functor.Identity.$fGeneric1Identity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.786303855 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity1_closure" {
     Data.Functor.Identity.$fGenericIdentity1_closure:
         const Data.Functor.Identity.$fGenericIdentity1_info;
 },
 Data.Functor.Identity.$fGenericIdentity1_entry() //  [R2]
         { info_tbl: [(cbJKD,
                       label: Data.Functor.Identity.$fGenericIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.787100904 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity2_closure" {
     Data.Functor.Identity.$fGenericIdentity2_closure:
         const Data.Functor.Identity.$fGenericIdentity2_info;
 },
 Data.Functor.Identity.$fGenericIdentity2_entry() //  [R2]
         { info_tbl: [(cbJKK,
                       label: Data.Functor.Identity.$fGenericIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.787811991 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity_closure" {
     Data.Functor.Identity.$fGenericIdentity_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Identity.$fGenericIdentity2_closure+1;
         const Data.Functor.Identity.$fGenericIdentity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.788691647 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure" {
     Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure:
         const Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info;
 },
 sat_sbJvt_entry() //  [R1]
         { info_tbl: [(cbJKV,
                       label: sat_sbJvt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJKW; else goto cbJKX;
       cbJKW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJKX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cbJKY,
                       label: Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJKY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJL2; else goto cbJL1;
       cbJL2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJL1: // global
           I64[Hp - 16] = sat_sbJvt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.790390484 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_closure" {
     Data.Functor.Identity.$fFractionalIdentity_closure:
         const Data.Functor.Identity.$fFractionalIdentity_info;
 },
 sat_sbJvy_entry() //  [R1]
         { info_tbl: [(cbJLb,
                       label: sat_sbJvy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJLc; else goto cbJLd;
       cbJLc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJLd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvx_entry() //  [R1]
         { info_tbl: [(cbJLi,
                       label: sat_sbJvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJLj; else goto cbJLk;
       cbJLj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJLk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvw_entry() //  [R1]
         { info_tbl: [(cbJLp,
                       label: sat_sbJvw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJLq; else goto cbJLr;
       cbJLq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJLr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvv_entry() //  [R1]
         { info_tbl: [(cbJLw,
                       label: sat_sbJvv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJLx; else goto cbJLy;
       cbJLx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJLy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_entry() //  [R2]
         { info_tbl: [(cbJLA,
                       label: Data.Functor.Identity.$fFractionalIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLA: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbJLE; else goto cbJLD;
       cbJLE: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJLD: // global
           I64[Hp - 128] = sat_sbJvy_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJvx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJvw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJvv_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.792383858 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info;
 },
 sat_sbJvA_entry() //  [R1]
         { info_tbl: [(cbJLN,
                       label: sat_sbJvA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJLO; else goto cbJLP;
       cbJLO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJLP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(cbJLQ,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJLQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJLU; else goto cbJLT;
       cbJLU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJLT: // global
           I64[Hp - 16] = sat_sbJvA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.793731996 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure" {
     Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure:
         const Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info;
 },
 sat_sbJvC_entry() //  [R1]
         { info_tbl: [(cbJM3,
                       label: sat_sbJvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJM3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJM4; else goto cbJM5;
       cbJM4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJM5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cbJM6,
                       label: Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJM6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJMa; else goto cbJM9;
       cbJMa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJM9: // global
           I64[Hp - 16] = sat_sbJvC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.797456492 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_closure" {
     Data.Functor.Identity.$fFloatingIdentity_closure:
         const Data.Functor.Identity.$fFloatingIdentity_info;
 },
 sat_sbJw0_entry() //  [R1]
         { info_tbl: [(cbJMj,
                       label: sat_sbJw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJMj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJMk; else goto cbJMl;
       cbJMk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJMl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvZ_entry() //  [R1]
         { info_tbl: [(cbJMq,
                       label: sat_sbJvZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJMq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJMr; else goto cbJMs;
       cbJMr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJMs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvY_entry() //  [R1]
         { info_tbl: [(cbJMx,
                       label: sat_sbJvY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJMx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJMy; else goto cbJMz;
       cbJMy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJMz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvX_entry() //  [R1]
         { info_tbl: [(cbJME,
                       label: sat_sbJvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJMF; else goto cbJMG;
       cbJMF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJMG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvW_entry() //  [R1]
         { info_tbl: [(cbJML,
                       label: sat_sbJvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJML: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJMM; else goto cbJMN;
       cbJMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvV_entry() //  [R1]
         { info_tbl: [(cbJMS,
                       label: sat_sbJvV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJMS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJMT; else goto cbJMU;
       cbJMT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJMU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvU_entry() //  [R1]
         { info_tbl: [(cbJMZ,
                       label: sat_sbJvU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJMZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJN0; else goto cbJN1;
       cbJN0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJN1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvT_entry() //  [R1]
         { info_tbl: [(cbJN6,
                       label: sat_sbJvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJN6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJN7; else goto cbJN8;
       cbJN7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJN8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvS_entry() //  [R1]
         { info_tbl: [(cbJNd,
                       label: sat_sbJvS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNe; else goto cbJNf;
       cbJNe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvR_entry() //  [R1]
         { info_tbl: [(cbJNk,
                       label: sat_sbJvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNl; else goto cbJNm;
       cbJNl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvQ_entry() //  [R1]
         { info_tbl: [(cbJNr,
                       label: sat_sbJvQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNs; else goto cbJNt;
       cbJNs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvP_entry() //  [R1]
         { info_tbl: [(cbJNy,
                       label: sat_sbJvP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNz; else goto cbJNA;
       cbJNz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvO_entry() //  [R1]
         { info_tbl: [(cbJNF,
                       label: sat_sbJvO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNG; else goto cbJNH;
       cbJNG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvN_entry() //  [R1]
         { info_tbl: [(cbJNM,
                       label: sat_sbJvN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNN; else goto cbJNO;
       cbJNN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvM_entry() //  [R1]
         { info_tbl: [(cbJNT,
                       label: sat_sbJvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJNT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJNU; else goto cbJNV;
       cbJNU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJNV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvL_entry() //  [R1]
         { info_tbl: [(cbJO0,
                       label: sat_sbJvL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJO0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJO1; else goto cbJO2;
       cbJO1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJO2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvK_entry() //  [R1]
         { info_tbl: [(cbJO7,
                       label: sat_sbJvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJO7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJO8; else goto cbJO9;
       cbJO8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJO9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvJ_entry() //  [R1]
         { info_tbl: [(cbJOe,
                       label: sat_sbJvJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJOe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJOf; else goto cbJOg;
       cbJOf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJOg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvI_entry() //  [R1]
         { info_tbl: [(cbJOl,
                       label: sat_sbJvI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJOm; else goto cbJOn;
       cbJOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvH_entry() //  [R1]
         { info_tbl: [(cbJOs,
                       label: sat_sbJvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJOt; else goto cbJOu;
       cbJOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJOu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvG_entry() //  [R1]
         { info_tbl: [(cbJOz,
                       label: sat_sbJvG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJOz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJOA; else goto cbJOB;
       cbJOA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvF_entry() //  [R1]
         { info_tbl: [(cbJOG,
                       label: sat_sbJvF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJOG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJOH; else goto cbJOI;
       cbJOH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJOI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvE_entry() //  [R1]
         { info_tbl: [(cbJON,
                       label: sat_sbJvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJON: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJOO; else goto cbJOP;
       cbJOO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJOP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_entry() //  [R2]
         { info_tbl: [(cbJOR,
                       label: Data.Functor.Identity.$fFloatingIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJOR: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbJOV; else goto cbJOU;
       cbJOV: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJOU: // global
           I64[Hp - 736] = sat_sbJw0_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbJvZ_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbJvY_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbJvX_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbJvW_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbJvV_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbJvU_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbJvT_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbJvS_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbJvR_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbJvQ_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbJvP_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbJvO_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbJvN_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbJvM_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbJvL_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbJvK_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbJvJ_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbJvI_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbJvH_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbJvG_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJvF_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJvE_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.803984446 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info;
 },
 sat_sbJw2_entry() //  [R1]
         { info_tbl: [(cbJP4,
                       label: sat_sbJw2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJP4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJP5; else goto cbJP6;
       cbJP5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(cbJP7,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJP7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJPb; else goto cbJPa;
       cbJPb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJPa: // global
           I64[Hp - 16] = sat_sbJw2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.805445833 UTC

[section ""data" . Data.Functor.Identity.$fEqIdentity_closure" {
     Data.Functor.Identity.$fEqIdentity_closure:
         const Data.Functor.Identity.$fEqIdentity_info;
 },
 sat_sbJw5_entry() //  [R1]
         { info_tbl: [(cbJPk,
                       label: sat_sbJw5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJPk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJPl; else goto cbJPm;
       cbJPl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJPm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJw4_entry() //  [R1]
         { info_tbl: [(cbJPr,
                       label: sat_sbJw4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJPr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJPs; else goto cbJPt;
       cbJPs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJPt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEqIdentity_entry() //  [R2]
         { info_tbl: [(cbJPv,
                       label: Data.Functor.Identity.$fEqIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJPv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbJPz; else goto cbJPy;
       cbJPz: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEqIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJPy: // global
           I64[Hp - 64] = sat_sbJw5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJw4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.806993578 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure" {
     Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure:
         const Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info;
 },
 sat_sbJw7_entry() //  [R1]
         { info_tbl: [(cbJPI,
                       label: sat_sbJw7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJPI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJPJ; else goto cbJPK;
       cbJPJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJPK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbJPL,
                       label: Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJPL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJPP; else goto cbJPO;
       cbJPP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJPO: // global
           I64[Hp - 16] = sat_sbJw7_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.809038797 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_closure" {
     Data.Functor.Identity.$fOrdIdentity_closure:
         const Data.Functor.Identity.$fOrdIdentity_info;
 },
 sat_sbJwg_entry() //  [R1]
         { info_tbl: [(cbJPY,
                       label: sat_sbJwg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJPY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJPZ; else goto cbJQ0;
       cbJPZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwf_entry() //  [R1]
         { info_tbl: [(cbJQ5,
                       label: sat_sbJwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQ6; else goto cbJQ7;
       cbJQ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwe_entry() //  [R1]
         { info_tbl: [(cbJQc,
                       label: sat_sbJwe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQd; else goto cbJQe;
       cbJQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwd_entry() //  [R1]
         { info_tbl: [(cbJQj,
                       label: sat_sbJwd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQk; else goto cbJQl;
       cbJQk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwc_entry() //  [R1]
         { info_tbl: [(cbJQq,
                       label: sat_sbJwc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQr; else goto cbJQs;
       cbJQr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwb_entry() //  [R1]
         { info_tbl: [(cbJQx,
                       label: sat_sbJwb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQy; else goto cbJQz;
       cbJQy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwa_entry() //  [R1]
         { info_tbl: [(cbJQE,
                       label: sat_sbJwa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQF; else goto cbJQG;
       cbJQF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJw9_entry() //  [R1]
         { info_tbl: [(cbJQL,
                       label: sat_sbJw9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJQM; else goto cbJQN;
       cbJQM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJQN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_entry() //  [R2]
         { info_tbl: [(cbJQP,
                       label: Data.Functor.Identity.$fOrdIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJQP: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbJQT; else goto cbJQS;
       cbJQT: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJQS: // global
           I64[Hp - 256] = sat_sbJwg_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJwf_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJwe_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJwd_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJwc_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJwb_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJwa_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJw9_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.812015788 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure" {
     Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure:
         const Data.Functor.Identity.$fIxIdentity_$cp1Ix_info;
 },
 sat_sbJwi_entry() //  [R1]
         { info_tbl: [(cbJR2,
                       label: sat_sbJwi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJR2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJR3; else goto cbJR4;
       cbJR3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJR4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry() //  [R2]
         { info_tbl: [(cbJR5,
                       label: Data.Functor.Identity.$fIxIdentity_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJR5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJR9; else goto cbJR8;
       cbJR9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJR8: // global
           I64[Hp - 16] = sat_sbJwi_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.816050483 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_closure" {
     Data.Functor.Identity.$fIxIdentity_closure:
         const Data.Functor.Identity.$fIxIdentity_info;
 },
 sat_sbJwq_entry() //  [R1]
         { info_tbl: [(cbJRi,
                       label: sat_sbJwq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRj; else goto cbJRk;
       cbJRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwp_entry() //  [R1]
         { info_tbl: [(cbJRp,
                       label: sat_sbJwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRq; else goto cbJRr;
       cbJRq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJRr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwo_entry() //  [R1]
         { info_tbl: [(cbJRw,
                       label: sat_sbJwo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRx; else goto cbJRy;
       cbJRx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJRy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwn_entry() //  [R1]
         { info_tbl: [(cbJRD,
                       label: sat_sbJwn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRE; else goto cbJRF;
       cbJRE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJRF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwm_entry() //  [R1]
         { info_tbl: [(cbJRK,
                       label: sat_sbJwm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRL; else goto cbJRM;
       cbJRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwl_entry() //  [R1]
         { info_tbl: [(cbJRR,
                       label: sat_sbJwl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRS; else goto cbJRT;
       cbJRS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJRT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwk_entry() //  [R1]
         { info_tbl: [(cbJRY,
                       label: sat_sbJwk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJRY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJRZ; else goto cbJS0;
       cbJRZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJS0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_entry() //  [R2]
         { info_tbl: [(cbJS2,
                       label: Data.Functor.Identity.$fIxIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJS2: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbJS6; else goto cbJS5;
       cbJS6: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJS5: // global
           I64[Hp - 224] = sat_sbJwq_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwp_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwo_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwn_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJwm_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJwl_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJwk_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.818968908 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp2Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp2Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp2Real_info;
 },
 sat_sbJws_entry() //  [R1]
         { info_tbl: [(cbJSf,
                       label: sat_sbJws_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJSf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJSg; else goto cbJSh;
       cbJSg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJSh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp2Real_entry() //  [R2]
         { info_tbl: [(cbJSi,
                       label: Data.Functor.Identity.$fRealIdentity_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJSi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJSm; else goto cbJSl;
       cbJSm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJSl: // global
           I64[Hp - 16] = sat_sbJws_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.820449802 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_closure" {
     Data.Functor.Identity.$fRealIdentity_closure:
         const Data.Functor.Identity.$fRealIdentity_info;
 },
 sat_sbJww_entry() //  [R1]
         { info_tbl: [(cbJSv,
                       label: sat_sbJww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJSv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJSw; else goto cbJSx;
       cbJSw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJSx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwv_entry() //  [R1]
         { info_tbl: [(cbJSC,
                       label: sat_sbJwv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJSC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJSD; else goto cbJSE;
       cbJSD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJSE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwu_entry() //  [R1]
         { info_tbl: [(cbJSJ,
                       label: sat_sbJwu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJSK; else goto cbJSL;
       cbJSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_entry() //  [R2]
         { info_tbl: [(cbJSN,
                       label: Data.Functor.Identity.$fRealIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJSN: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbJSR; else goto cbJSQ;
       cbJSR: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJSQ: // global
           I64[Hp - 96] = sat_sbJww_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJwv_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJwu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.822231419 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info;
 },
 sat_sbJwy_entry() //  [R1]
         { info_tbl: [(cbJT0,
                       label: sat_sbJwy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJT0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJT1; else goto cbJT2;
       cbJT1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJT2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry() //  [R2]
         { info_tbl: [(cbJT3,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJT3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJT7; else goto cbJT6;
       cbJT7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJT6: // global
           I64[Hp - 16] = sat_sbJwy_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.823516019 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info;
 },
 sat_sbJwA_entry() //  [R1]
         { info_tbl: [(cbJTg,
                       label: sat_sbJwA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJTh; else goto cbJTi;
       cbJTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJTi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(cbJTj,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJTn; else goto cbJTm;
       cbJTn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJTm: // global
           I64[Hp - 16] = sat_sbJwA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.825523495 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_closure" {
     Data.Functor.Identity.$fRealFracIdentity_closure:
         const Data.Functor.Identity.$fRealFracIdentity_info;
 },
 sat_sbJwI_entry() //  [R1]
         { info_tbl: [(cbJTw,
                       label: sat_sbJwI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJTx; else goto cbJTy;
       cbJTx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJTy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwH_entry() //  [R1]
         { info_tbl: [(cbJTD,
                       label: sat_sbJwH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJTE; else goto cbJTF;
       cbJTE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJTF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwG_entry() //  [R1]
         { info_tbl: [(cbJTK,
                       label: sat_sbJwG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJTL; else goto cbJTM;
       cbJTL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJTM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwF_entry() //  [R1]
         { info_tbl: [(cbJTR,
                       label: sat_sbJwF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJTS; else goto cbJTT;
       cbJTS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJTT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwE_entry() //  [R1]
         { info_tbl: [(cbJTY,
                       label: sat_sbJwE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJTY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJTZ; else goto cbJU0;
       cbJTZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJU0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwD_entry() //  [R1]
         { info_tbl: [(cbJU5,
                       label: sat_sbJwD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJU5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJU6; else goto cbJU7;
       cbJU6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJU7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwC_entry() //  [R1]
         { info_tbl: [(cbJUc,
                       label: sat_sbJwC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJUd; else goto cbJUe;
       cbJUd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJUe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_entry() //  [R2]
         { info_tbl: [(cbJUg,
                       label: Data.Functor.Identity.$fRealFracIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUg: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbJUk; else goto cbJUj;
       cbJUk: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJUj: // global
           I64[Hp - 224] = sat_sbJwI_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwH_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwG_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwF_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJwE_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJwD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJwC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.828204315 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info;
 },
 sat_sbJwK_entry() //  [R1]
         { info_tbl: [(cbJUt,
                       label: sat_sbJwK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJUu; else goto cbJUv;
       cbJUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(cbJUw,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJUA; else goto cbJUz;
       cbJUA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJUz: // global
           I64[Hp - 16] = sat_sbJwK_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.831255335 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_info;
 },
 sat_sbJx1_entry() //  [R1]
         { info_tbl: [(cbJUJ,
                       label: sat_sbJx1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJUK; else goto cbJUL;
       cbJUK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJUL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx0_entry() //  [R1]
         { info_tbl: [(cbJUQ,
                       label: sat_sbJx0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJUR; else goto cbJUS;
       cbJUR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJUS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwZ_entry() //  [R1]
         { info_tbl: [(cbJUX,
                       label: sat_sbJwZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJUX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJUY; else goto cbJUZ;
       cbJUY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJUZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwY_entry() //  [R1]
         { info_tbl: [(cbJV4,
                       label: sat_sbJwY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJV4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJV5; else goto cbJV6;
       cbJV5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJV6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwX_entry() //  [R1]
         { info_tbl: [(cbJVb,
                       label: sat_sbJwX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVc; else goto cbJVd;
       cbJVc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwW_entry() //  [R1]
         { info_tbl: [(cbJVi,
                       label: sat_sbJwW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVj; else goto cbJVk;
       cbJVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwV_entry() //  [R1]
         { info_tbl: [(cbJVp,
                       label: sat_sbJwV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVq; else goto cbJVr;
       cbJVq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwU_entry() //  [R1]
         { info_tbl: [(cbJVw,
                       label: sat_sbJwU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVx; else goto cbJVy;
       cbJVx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwT_entry() //  [R1]
         { info_tbl: [(cbJVD,
                       label: sat_sbJwT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVE; else goto cbJVF;
       cbJVE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwS_entry() //  [R1]
         { info_tbl: [(cbJVK,
                       label: sat_sbJwS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVL; else goto cbJVM;
       cbJVL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwR_entry() //  [R1]
         { info_tbl: [(cbJVR,
                       label: sat_sbJwR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVS; else goto cbJVT;
       cbJVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwQ_entry() //  [R1]
         { info_tbl: [(cbJVY,
                       label: sat_sbJwQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJVY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJVZ; else goto cbJW0;
       cbJVZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJW0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwP_entry() //  [R1]
         { info_tbl: [(cbJW5,
                       label: sat_sbJwP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJW5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJW6; else goto cbJW7;
       cbJW6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJW7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwO_entry() //  [R1]
         { info_tbl: [(cbJWc,
                       label: sat_sbJwO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJWd; else goto cbJWe;
       cbJWd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJWe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwN_entry() //  [R1]
         { info_tbl: [(cbJWj,
                       label: sat_sbJwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJWk; else goto cbJWl;
       cbJWk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJWl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwM_entry() //  [R1]
         { info_tbl: [(cbJWq,
                       label: sat_sbJwM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJWr; else goto cbJWs;
       cbJWr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJWs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_entry() //  [R2]
         { info_tbl: [(cbJWu,
                       label: Data.Functor.Identity.$fRealFloatIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWu: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cbJWy; else goto cbJWx;
       cbJWy: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJWx: // global
           I64[Hp - 512] = sat_sbJx1_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_sbJx0_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sbJwZ_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_sbJwY_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sbJwX_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_sbJwW_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sbJwV_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_sbJwU_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sbJwT_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_sbJwS_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sbJwR_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_sbJwQ_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sbJwP_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwO_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwN_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwM_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.836738483 UTC

[section ""data" . Data.Functor.Identity.$fEnumIdentity_closure" {
     Data.Functor.Identity.$fEnumIdentity_closure:
         const Data.Functor.Identity.$fEnumIdentity_info;
 },
 sat_sbJxa_entry() //  [R1]
         { info_tbl: [(cbJWH,
                       label: sat_sbJxa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJWI; else goto cbJWJ;
       cbJWI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJWJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx9_entry() //  [R1]
         { info_tbl: [(cbJWO,
                       label: sat_sbJx9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJWP; else goto cbJWQ;
       cbJWP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJWQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx8_entry() //  [R1]
         { info_tbl: [(cbJWV,
                       label: sat_sbJx8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJWV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJWW; else goto cbJWX;
       cbJWW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJWX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx7_entry() //  [R1]
         { info_tbl: [(cbJX2,
                       label: sat_sbJx7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJX2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJX3; else goto cbJX4;
       cbJX3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJX4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx6_entry() //  [R1]
         { info_tbl: [(cbJX9,
                       label: sat_sbJx6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJX9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJXa; else goto cbJXb;
       cbJXa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJXb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx5_entry() //  [R1]
         { info_tbl: [(cbJXg,
                       label: sat_sbJx5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJXg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJXh; else goto cbJXi;
       cbJXh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJXi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx4_entry() //  [R1]
         { info_tbl: [(cbJXn,
                       label: sat_sbJx4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJXn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJXo; else goto cbJXp;
       cbJXo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJXp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx3_entry() //  [R1]
         { info_tbl: [(cbJXu,
                       label: sat_sbJx3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJXu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJXv; else goto cbJXw;
       cbJXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEnumIdentity_entry() //  [R2]
         { info_tbl: [(cbJXy,
                       label: Data.Functor.Identity.$fEnumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJXy: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbJXC; else goto cbJXB;
       cbJXC: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEnumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJXB: // global
           I64[Hp - 256] = sat_sbJxa_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJx9_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJx8_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJx7_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJx6_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJx5_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJx4_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJx3_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.839617904 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info;
 },
 sat_sbJxc_entry() //  [R1]
         { info_tbl: [(cbJXL,
                       label: sat_sbJxc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJXL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJXM; else goto cbJXN;
       cbJXM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJXN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry() //  [R2]
         { info_tbl: [(cbJXO,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJXO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJXS; else goto cbJXR;
       cbJXS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJXR: // global
           I64[Hp - 16] = sat_sbJxc_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEnumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.84191497 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_closure" {
     Data.Functor.Identity.$fIntegralIdentity_closure:
         const Data.Functor.Identity.$fIntegralIdentity_info;
 },
 sat_sbJxm_entry() //  [R1]
         { info_tbl: [(cbJY1,
                       label: sat_sbJxm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJY1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJY2; else goto cbJY3;
       cbJY2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJY3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxl_entry() //  [R1]
         { info_tbl: [(cbJY8,
                       label: sat_sbJxl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJY8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJY9; else goto cbJYa;
       cbJY9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxk_entry() //  [R1]
         { info_tbl: [(cbJYf,
                       label: sat_sbJxk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYg; else goto cbJYh;
       cbJYg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxj_entry() //  [R1]
         { info_tbl: [(cbJYm,
                       label: sat_sbJxj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYn; else goto cbJYo;
       cbJYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxi_entry() //  [R1]
         { info_tbl: [(cbJYt,
                       label: sat_sbJxi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYu; else goto cbJYv;
       cbJYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxh_entry() //  [R1]
         { info_tbl: [(cbJYA,
                       label: sat_sbJxh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYB; else goto cbJYC;
       cbJYB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxg_entry() //  [R1]
         { info_tbl: [(cbJYH,
                       label: sat_sbJxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYI; else goto cbJYJ;
       cbJYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxf_entry() //  [R1]
         { info_tbl: [(cbJYO,
                       label: sat_sbJxf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYP; else goto cbJYQ;
       cbJYP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxe_entry() //  [R1]
         { info_tbl: [(cbJYV,
                       label: sat_sbJxe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJYW; else goto cbJYX;
       cbJYW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJYX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_entry() //  [R2]
         { info_tbl: [(cbJYZ,
                       label: Data.Functor.Identity.$fIntegralIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJYZ: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto cbJZ3; else goto cbJZ2;
       cbJZ3: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJZ2: // global
           I64[Hp - 288] = sat_sbJxm_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_sbJxl_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sbJxk_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_sbJxj_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_sbJxi_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbJxh_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbJxg_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbJxf_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbJxe_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.845129614 UTC

[section ""data" . Data.Functor.Identity.$fBoundedIdentity_closure" {
     Data.Functor.Identity.$fBoundedIdentity_closure:
         const Data.Functor.Identity.$fBoundedIdentity_info;
 },
 sat_sbJxp_entry() //  [R1]
         { info_tbl: [(cbJZc,
                       label: sat_sbJxp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJZd; else goto cbJZe;
       cbJZd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJZe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxo_entry() //  [R1]
         { info_tbl: [(cbJZj,
                       label: sat_sbJxo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJZk; else goto cbJZl;
       cbJZk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJZl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBoundedIdentity_entry() //  [R2]
         { info_tbl: [(cbJZn,
                       label: Data.Functor.Identity.$fBoundedIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbJZr; else goto cbJZq;
       cbJZr: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBoundedIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJZq: // global
           I64[Hp - 64] = sat_sbJxp_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJxo_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.846689683 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure" {
     Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure:
         const Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info;
 },
 sat_sbJxr_entry() //  [R1]
         { info_tbl: [(cbJZA,
                       label: sat_sbJxr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJZB; else goto cbJZC;
       cbJZB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJZC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry() //  [R2]
         { info_tbl: [(cbJZD,
                       label: Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJZH; else goto cbJZG;
       cbJZH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbJZG: // global
           I64[Hp - 16] = sat_sbJxr_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.850407259 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_closure" {
     Data.Functor.Identity.$fBitsIdentity_closure:
         const Data.Functor.Identity.$fBitsIdentity_info;
 },
 sat_sbJxP_entry() //  [R1]
         { info_tbl: [(cbJZQ,
                       label: sat_sbJxP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJZR; else goto cbJZS;
       cbJZR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJZS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxO_entry() //  [R1]
         { info_tbl: [(cbJZX,
                       label: sat_sbJxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJZX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbJZY; else goto cbJZZ;
       cbJZY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJZZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxN_entry() //  [R1]
         { info_tbl: [(cbK04,
                       label: sat_sbJxN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK04: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK05; else goto cbK06;
       cbK05: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK06: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxM_entry() //  [R1]
         { info_tbl: [(cbK0b,
                       label: sat_sbJxM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0c; else goto cbK0d;
       cbK0c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxL_entry() //  [R1]
         { info_tbl: [(cbK0i,
                       label: sat_sbJxL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0j; else goto cbK0k;
       cbK0j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxK_entry() //  [R1]
         { info_tbl: [(cbK0p,
                       label: sat_sbJxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0q; else goto cbK0r;
       cbK0q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxJ_entry() //  [R1]
         { info_tbl: [(cbK0w,
                       label: sat_sbJxJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0x; else goto cbK0y;
       cbK0x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxI_entry() //  [R1]
         { info_tbl: [(cbK0D,
                       label: sat_sbJxI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0E; else goto cbK0F;
       cbK0E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxH_entry() //  [R1]
         { info_tbl: [(cbK0K,
                       label: sat_sbJxH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0L; else goto cbK0M;
       cbK0L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxG_entry() //  [R1]
         { info_tbl: [(cbK0R,
                       label: sat_sbJxG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0S; else goto cbK0T;
       cbK0S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK0T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxF_entry() //  [R1]
         { info_tbl: [(cbK0Y,
                       label: sat_sbJxF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK0Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK0Z; else goto cbK10;
       cbK0Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK10: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxE_entry() //  [R1]
         { info_tbl: [(cbK15,
                       label: sat_sbJxE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK15: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK16; else goto cbK17;
       cbK16: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK17: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxD_entry() //  [R1]
         { info_tbl: [(cbK1c,
                       label: sat_sbJxD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1d; else goto cbK1e;
       cbK1d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxC_entry() //  [R1]
         { info_tbl: [(cbK1j,
                       label: sat_sbJxC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1k; else goto cbK1l;
       cbK1k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxB_entry() //  [R1]
         { info_tbl: [(cbK1q,
                       label: sat_sbJxB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1r; else goto cbK1s;
       cbK1r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxA_entry() //  [R1]
         { info_tbl: [(cbK1x,
                       label: sat_sbJxA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1y; else goto cbK1z;
       cbK1y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxz_entry() //  [R1]
         { info_tbl: [(cbK1E,
                       label: sat_sbJxz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1F; else goto cbK1G;
       cbK1F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxy_entry() //  [R1]
         { info_tbl: [(cbK1L,
                       label: sat_sbJxy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1M; else goto cbK1N;
       cbK1M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxx_entry() //  [R1]
         { info_tbl: [(cbK1S,
                       label: sat_sbJxx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK1T; else goto cbK1U;
       cbK1T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK1U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxw_entry() //  [R1]
         { info_tbl: [(cbK1Z,
                       label: sat_sbJxw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK1Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK20; else goto cbK21;
       cbK20: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK21: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxv_entry() //  [R1]
         { info_tbl: [(cbK26,
                       label: sat_sbJxv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK26: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK27; else goto cbK28;
       cbK27: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK28: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxu_entry() //  [R1]
         { info_tbl: [(cbK2d,
                       label: sat_sbJxu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK2e; else goto cbK2f;
       cbK2e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK2f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxt_entry() //  [R1]
         { info_tbl: [(cbK2k,
                       label: sat_sbJxt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK2l; else goto cbK2m;
       cbK2l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK2m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbK2o,
                       label: Data.Functor.Identity.$fBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2o: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbK2s; else goto cbK2r;
       cbK2s: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK2r: // global
           I64[Hp - 736] = sat_sbJxP_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbJxO_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbJxN_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbJxM_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbJxL_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbJxK_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbJxJ_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbJxI_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbJxH_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbJxG_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbJxF_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbJxE_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbJxD_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbJxC_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbJxB_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbJxA_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbJxz_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbJxy_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbJxx_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbJxw_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbJxv_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJxu_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJxt_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.856855916 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info;
 },
 sat_sbJxR_entry() //  [R1]
         { info_tbl: [(cbK2B,
                       label: sat_sbJxR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK2C; else goto cbK2D;
       cbK2C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK2D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(cbK2E,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbK2I; else goto cbK2H;
       cbK2I: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK2H: // global
           I64[Hp - 16] = sat_sbJxR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fBitsIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.858533714 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_info;
 },
 sat_sbJxW_entry() //  [R1]
         { info_tbl: [(cbK2R,
                       label: sat_sbJxW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK2S; else goto cbK2T;
       cbK2S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK2T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxV_entry() //  [R1]
         { info_tbl: [(cbK2Y,
                       label: sat_sbJxV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK2Z; else goto cbK30;
       cbK2Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK30: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxU_entry() //  [R1]
         { info_tbl: [(cbK35,
                       label: sat_sbJxU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK35: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK36; else goto cbK37;
       cbK36: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK37: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxT_entry() //  [R1]
         { info_tbl: [(cbK3c,
                       label: sat_sbJxT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK3d; else goto cbK3e;
       cbK3d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK3e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbK3g,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3g: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbK3k; else goto cbK3j;
       cbK3k: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK3j: // global
           I64[Hp - 128] = sat_sbJxW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJxV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJxU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJxT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.860364721 UTC

[section ""data" . Data.Functor.Identity.runIdentity_closure" {
     Data.Functor.Identity.runIdentity_closure:
         const Data.Functor.Identity.runIdentity_info;
 },
 Data.Functor.Identity.runIdentity_entry() //  [R2]
         { info_tbl: [(cbK3p,
                       label: Data.Functor.Identity.runIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3p: // global
           R2 = R2;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.861265412 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure:
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info;
 },
 Data.Functor.Identity.$fMonadFixIdentity_$cmfix_entry() //  [R2]
         { info_tbl: [(cbK3x,
                       label: Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbK3B; else goto cbK3A;
       cbK3B: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK3A: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbK3w::P64 = Hp - 24;
           P64[Hp] = _cbK3w::P64;
           R1 = _cbK3w::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.862235934 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>=_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>=_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbK3G,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3G: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.863054654 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>_entry() //  [R2, R3]
         { info_tbl: [(cbK3N,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3N: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.863859644 UTC

[section ""data" . lvl_rbJt6_closure" {
     lvl_rbJt6_closure:
         const lvl_rbJt6_info;
         const 0;
 },
 lvl_rbJt6_entry() //  [R2]
         { info_tbl: [(cbK3U,
                       label: lvl_rbJt6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK3U: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.86460511 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_closure" {
     Data.Functor.Identity.$fMonadIdentity_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Functor.Identity.$fApplicativeIdentity_closure+1;
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_closure+2;
         const Data.Functor.Identity.$fMonadIdentity_$c>>_closure+2;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const lvl_rbJt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.865204424 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure+1;
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.866010903 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity5_closure" {
     Data.Functor.Identity.$fFoldableIdentity5_closure:
         const Data.Functor.Identity.$fFoldableIdentity5_info;
 },
 Data.Functor.Identity.$fFoldableIdentity5_entry() //  [R3]
         { info_tbl: [(cbK41,
                       label: Data.Functor.Identity.$fFoldableIdentity5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK41: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.866807938 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity3_closure" {
     Data.Functor.Identity.$fFoldableIdentity3_closure:
         const Data.Functor.Identity.$fFoldableIdentity3_info;
 },
 Data.Functor.Identity.$fFoldableIdentity3_entry() //  [R3]
         { info_tbl: [(cbK48,
                       label: Data.Functor.Identity.$fFoldableIdentity3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK48: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.867581811 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity1_closure" {
     Data.Functor.Identity.$fFoldableIdentity1_closure:
         const Data.Functor.Identity.$fFoldableIdentity1_info;
 },
 Data.Functor.Identity.$fFoldableIdentity1_entry() //  [R3]
         { info_tbl: [(cbK4f,
                       label: Data.Functor.Identity.$fFoldableIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4f: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.868405648 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity8_closure" {
     Data.Functor.Identity.$fFoldableIdentity8_closure:
         const Data.Functor.Identity.$fFoldableIdentity8_info;
 },
 Data.Functor.Identity.$fFoldableIdentity8_entry() //  [R3]
         { info_tbl: [(cbK4m,
                       label: Data.Functor.Identity.$fFoldableIdentity8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4m: // global
           R2 = R3;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.869098162 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_closure" {
     Data.Functor.Identity.$fFoldableIdentity_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Identity.$fFoldableIdentity8_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity7_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$clength_closure+1;
         const GHC.Classes.==_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.869825559 UTC

[section ""cstring" . Data.Functor.Identity.$trModule4_bytes" {
     Data.Functor.Identity.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.870366927 UTC

[section ""data" . Data.Functor.Identity.$trModule3_closure" {
     Data.Functor.Identity.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.870908953 UTC

[section ""cstring" . Data.Functor.Identity.$trModule2_bytes" {
     Data.Functor.Identity.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.871436485 UTC

[section ""data" . Data.Functor.Identity.$trModule1_closure" {
     Data.Functor.Identity.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.871986743 UTC

[section ""data" . Data.Functor.Identity.$trModule_closure" {
     Data.Functor.Identity.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Identity.$trModule3_closure+1;
         const Data.Functor.Identity.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.872560713 UTC

[section ""data" . $krep_rbJt7_closure" {
     $krep_rbJt7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.873148987 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity1_closure" {
     Data.Functor.Identity.$tcIdentity1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$fReadIdentity6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.873763343 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity_closure" {
     Data.Functor.Identity.$tcIdentity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tcIdentity1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 3410104521590905987;
         const 16392070908630191652;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.874381992 UTC

[section ""data" . $krep1_rbJt8_closure" {
     $krep1_rbJt8_closure:
         const :_con_info;
         const $krep_rbJt7_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.874989079 UTC

[section ""data" . $krep2_rbJt9_closure" {
     $krep2_rbJt9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Identity.$tcIdentity_closure+1;
         const $krep1_rbJt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.875545168 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity1_closure" {
     Data.Functor.Identity.$tc'Identity1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbJt7_closure+2;
         const $krep2_rbJt9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.876095916 UTC

[section ""cstring" . Data.Functor.Identity.$tc'Identity3_bytes" {
     Data.Functor.Identity.$tc'Identity3_bytes:
         I8[] [39,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.876639032 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity2_closure" {
     Data.Functor.Identity.$tc'Identity2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$tc'Identity3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.877232899 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity_closure" {
     Data.Functor.Identity.$tc'Identity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tc'Identity2_closure+1;
         const Data.Functor.Identity.$tc'Identity1_closure+4;
         const 11920310844698764515;
         const 3935129235072617509;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.878097413 UTC

[section ""relreadonly" . SbJA1_srt" {
     SbJA1_srt:
         const Data.Functor.Identity.$fReadIdentity5_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Identity.$w$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity3_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadList_closure;
         const Data.Functor.Identity.$w$creadListPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_closure;
         const Data.Functor.Identity.$fShowIdentity1_closure;
         const Data.Functor.Identity.$w$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshow_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
         const Data.Functor.Identity.$fShowIdentity_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.880509747 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:35.8810574 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity4_closure" {
     Data.Functor.Identity.$fReadIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.881578309 UTC

[section ""cstring" . Data.Functor.Identity.$fReadIdentity6_bytes" {
     Data.Functor.Identity.$fReadIdentity6_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.882387603 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity5_closure" {
     Data.Functor.Identity.$fReadIdentity5_closure:
         const Data.Functor.Identity.$fReadIdentity5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity5_entry() //  [R1]
         { info_tbl: [(cbK4v,
                       label: Data.Functor.Identity.$fReadIdentity5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK4w; else goto cbK4x;
       cbK4w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK4x: // global
           (_cbK4s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbK4s::I64 == 0) goto cbK4u; else goto cbK4t;
       cbK4u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbK4t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbK4s::I64;
           R2 = Data.Functor.Identity.$fReadIdentity6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.884853084 UTC

[section ""data" . Data.Functor.Identity.$w$creadsPrec_closure" {
     Data.Functor.Identity.$w$creadsPrec_closure:
         const Data.Functor.Identity.$w$creadsPrec_info;
         const 0;
 },
 go1_sbJto_entry() //  [R1, R2]
         { info_tbl: [(cbK5a,
                       label: go1_sbJto_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK5a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbK5b; else goto cbK5c;
       cbK5b: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK5c: // global
           I64[Sp - 24] = block_cbK53_info;
           _sbJto::P64 = R1;
           _sbJtn::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sbJtn::P64;
           P64[Sp - 8] = _sbJto::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubK5u; else goto cbK54;
       ubK5u: // global
           call _cbK53(R1) args: 0, res: 0, upd: 0;
       cbK54: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbK53() //  [R1]
         { info_tbl: [(cbK53,
                       label: block_cbK53_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK53: // global
           if (R1 & 7 == 1) goto cbK57; else goto cbK58;
       cbK57: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbK58: // global
           I64[Sp] = block_cbK5i_info;
           _sbJts::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbJts::P64;
           if (R1 & 7 != 0) goto ubK5t; else goto cbK5j;
       ubK5t: // global
           call _cbK5i(R1) args: 0, res: 0, upd: 0;
       cbK5j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbK5i() //  [R1]
         { info_tbl: [(cbK5i,
                       label: block_cbK5i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK5i: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbK5s; else goto cbK5r;
       cbK5s: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbK5r: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sbJte_entry() //  [R1, R2]
         { info_tbl: [(cbK5z,
                       label: go_sbJte_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK5z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbK5A; else goto ubK5U;
       cbK5A: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubK5U: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbK4E() args: 0, res: 0, upd: 0;
     }
 },
 _cbK4E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4E: // global
           _sbJtb::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cbK4H_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbJtb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubK5W; else goto cbK4I;
       ubK5W: // global
           call _cbK4H(R1) args: 0, res: 0, upd: 0;
       cbK4I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbK4H() //  [R1]
         { info_tbl: [(cbK4H,
                       label: block_cbK4H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4H: // global
           if (R1 & 7 == 1) goto cbK5w; else goto cbK5x;
       cbK5w: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbK5x: // global
           I64[Sp - 8] = block_cbK4N_info;
           _sbJti::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbJti::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubK5X; else goto cbK4O;
       ubK5X: // global
           call _cbK4N(R1) args: 0, res: 0, upd: 0;
       cbK4O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbK4N() //  [R1]
         { info_tbl: [(cbK4N,
                       label: block_cbK4N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4N: // global
           I64[Sp - 8] = block_cbK4S_info;
           R3 = Data.Functor.Identity.$fReadIdentity5_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbK4S() //  [R1]
         { info_tbl: [(cbK4S,
                       label: block_cbK4S_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK4S: // global
           _sbJti::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbK5J; else goto cbK5L;
       cbK5J: // global
           P64[Sp + 32] = _sbJti::P64;
           Sp = Sp + 24;
           call _cbK4E() args: 0, res: 0, upd: 0;
       cbK5L: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbK5O; else goto cbK5N;
       cbK5O: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbK5N: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbJti::P64;
           I64[Hp - 8] = go1_sbJto_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_cbK5K_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _sbJtl::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp + 16] = _sbJtl::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbK5K() //  [R1]
         { info_tbl: [(cbK5K,
                       label: block_cbK5K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK5K: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbJto_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtD_entry() //  [R1, R2]
         { info_tbl: [(cbK67,
                       label: sat_sbJtD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK67: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK68; else goto cbK69;
       cbK68: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK69: // global
           I64[Sp - 16] = block_cbK65_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbK65() //  [R1]
         { info_tbl: [(cbK65,
                       label: block_cbK65_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK65: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sbJte_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbK6f,
                       label: Data.Functor.Identity.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK6f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbK6j; else goto cbK6i;
       cbK6j: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbK6i: // global
           I64[Hp - 24] = go_sbJte_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbJtD_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sbJtA::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sbJtA::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.888607045 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbK6r,
                       label: Data.Functor.Identity.$fReadIdentity_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK6r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbK6s; else goto cbK6t;
       cbK6s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbK6t: // global
           I64[Sp - 24] = block_cbK6o_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubK6x; else goto cbK6p;
       ubK6x: // global
           call _cbK6o(R1) args: 0, res: 0, upd: 0;
       cbK6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbK6o() //  [R1]
         { info_tbl: [(cbK6o,
                       label: block_cbK6o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK6o: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$creadsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.890110452 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity3_closure" {
     Data.Functor.Identity.$fReadIdentity3_closure:
         const Data.Functor.Identity.$fReadIdentity3_info;
         const 0;
 },
 sat_sbJtM_entry() //  [R1, R2]
         { info_tbl: [(cbK6H,
                       label: sat_sbJtM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK6H: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbK6N,
                       label: Data.Functor.Identity.$fReadIdentity3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK6N: // global
           _sbJtL::P64 = R4;
           _sbJtK::P64 = R3;
           _sbJtJ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbK6O; else goto cbK6P;
       cbK6P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbK6R; else goto cbK6Q;
       cbK6R: // global
           HpAlloc = 24;
           goto cbK6O;
       cbK6O: // global
           R4 = _sbJtL::P64;
           R3 = _sbJtK::P64;
           R2 = _sbJtJ::P64;
           R1 = Data.Functor.Identity.$fReadIdentity3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbK6Q: // global
           I64[Hp - 16] = sat_sbJtM_info;
           P64[Hp - 8] = _sbJtJ::P64;
           P64[Hp] = _sbJtK::P64;
           I64[Sp - 8] = block_cbK6K_info;
           R3 = _sbJtL::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbK6K() //  [R1]
         { info_tbl: [(cbK6K,
                       label: block_cbK6K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK6K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbK6U; else goto cbK6T;
       cbK6U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbK6T: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.891421967 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity2_closure" {
     Data.Functor.Identity.$fReadIdentity2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.892466656 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadList_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadList_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadList_info;
         const 0;
 },
 sat_sbJtQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbK78,
                       label: sat_sbJtQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK78: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtR_entry() //  [R1]
         { info_tbl: [(cbK7b,
                       label: sat_sbJtR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7b: // global
           _sbJtR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbK7c; else goto cbK7d;
       cbK7d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbK7f; else goto cbK7e;
       cbK7f: // global
           HpAlloc = 16;
           goto cbK7c;
       cbK7c: // global
           R1 = _sbJtR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK7e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJtR::P64;
           _sbJtP::P64 = P64[_sbJtR::P64 + 16];
           I64[Hp - 8] = sat_sbJtQ_info;
           P64[Hp] = _sbJtP::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fReadIdentity_$creadList_entry() //  [R2]
         { info_tbl: [(cbK7g,
                       label: Data.Functor.Identity.$fReadIdentity_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbK7k; else goto cbK7j;
       cbK7k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK7j: // global
           I64[Hp - 16] = sat_sbJtR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.895005786 UTC

[section ""data" . Data.Functor.Identity.$w$creadListPrec_closure" {
     Data.Functor.Identity.$w$creadListPrec_closure:
         const Data.Functor.Identity.$w$creadListPrec_info;
         const 0;
 },
 sat_sbJtU_entry() //  [R1, R2, R3]
         { info_tbl: [(cbK7y,
                       label: sat_sbJtU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_sbJtT_entry() //  [R1]
         { info_tbl: [(cbK7B,
                       label: w1_sbJtT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7B: // global
           _sbJtT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbK7C; else goto cbK7D;
       cbK7D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbK7F; else goto cbK7E;
       cbK7F: // global
           HpAlloc = 16;
           goto cbK7C;
       cbK7C: // global
           R1 = _sbJtT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK7E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJtT::P64;
           _sbJtS::P64 = P64[_sbJtT::P64 + 16];
           I64[Hp - 8] = sat_sbJtU_info;
           P64[Hp] = _sbJtS::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_sbJtV_entry() //  [R1, R2]
         { info_tbl: [(cbK7L,
                       label: w2_sbJtV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7L: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtZ_entry() //  [R1, R2]
         { info_tbl: [(cbK7W,
                       label: sat_sbJtZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbK7X; else goto cbK7Y;
       cbK7X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK7Y: // global
           I64[Sp - 8] = block_cbK7T_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbK7T() //  [R1]
         { info_tbl: [(cbK7T,
                       label: block_cbK7T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK7T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbK81; else goto cbK80;
       cbK81: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbK80: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbK82,
                       label: Data.Functor.Identity.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK82: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbK86; else goto cbK85;
       cbK86: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK85: // global
           I64[Hp - 48] = w1_sbJtT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_sbJtV_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbJtZ_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.897069862 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity1_closure" {
     Data.Functor.Identity.$fReadIdentity1_closure:
         const Data.Functor.Identity.$fReadIdentity1_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity1_entry() //  [R2]
         { info_tbl: [(cbK8b,
                       label: Data.Functor.Identity.$fReadIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8b: // global
           R2 = R2;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.898464678 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_closure" {
     Data.Functor.Identity.$fReadIdentity_closure:
         const Data.Functor.Identity.$fReadIdentity_info;
         const 0;
 },
 lvl1_sbJu3_entry() //  [R1]
         { info_tbl: [(cbK8m,
                       label: lvl1_sbJu3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK8n; else goto cbK8o;
       cbK8n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK8o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJu8_entry() //  [R1]
         { info_tbl: [(cbK8u,
                       label: sat_sbJu8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8u: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJu6_entry() //  [R1, R2, R3]
         { info_tbl: [(cbK8C,
                       label: sat_sbJu6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8C: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJu5_entry() //  [R1]
         { info_tbl: [(cbK8J,
                       label: sat_sbJu5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK8K; else goto cbK8L;
       cbK8K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK8L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fReadIdentity_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJu4_entry() //  [R1, R2, R3]
         { info_tbl: [(cbK8R,
                       label: sat_sbJu4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8R: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity_entry() //  [R2]
         { info_tbl: [(cbK8V,
                       label: Data.Functor.Identity.$fReadIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK8V: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbK8Z; else goto cbK8Y;
       cbK8Z: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK8Y: // global
           I64[Hp - 128] = lvl1_sbJu3_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJu8_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sbJu6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJu5_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJu4_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.900300178 UTC

[section ""cstring" . Data.Functor.Identity.$fShowIdentity2_bytes" {
     Data.Functor.Identity.$fShowIdentity2_bytes:
         I8[] [73,100,101,110,116,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.90103411 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity1_closure" {
     Data.Functor.Identity.$fShowIdentity1_closure:
         const Data.Functor.Identity.$fShowIdentity1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity1_entry() //  [R1]
         { info_tbl: [(cbK96,
                       label: Data.Functor.Identity.$fShowIdentity1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK96: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK97; else goto cbK98;
       cbK97: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK98: // global
           (_cbK93::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbK93::I64 == 0) goto cbK95; else goto cbK94;
       cbK95: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbK94: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbK93::I64;
           R2 = Data.Functor.Identity.$fShowIdentity2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.903066292 UTC

[section ""data" . Data.Functor.Identity.$w$cshowsPrec_closure" {
     Data.Functor.Identity.$w$cshowsPrec_closure:
         const Data.Functor.Identity.$w$cshowsPrec_info;
         const 0;
 },
 g_sbJuc_entry() //  [R1]
         { info_tbl: [(cbK9h,
                       label: g_sbJuc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK9h: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbK9i; else goto cbK9j;
       cbK9i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK9j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbJuf_entry() //  [R1]
         { info_tbl: [(cbK9w,
                       label: sat_sbJuf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK9w: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJug_entry() //  [R1, R2]
         { info_tbl: [(cbK9z,
                       label: sat_sbJug_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK9z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbK9D; else goto cbK9C;
       cbK9D: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK9C: // global
           _sbJuc::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbJuf_info;
           P64[Hp - 8] = _sbJuc::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuj_entry() //  [R1]
         { info_tbl: [(cbK9T,
                       label: sat_sbJuj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK9T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbK9X; else goto cbK9W;
       cbK9X: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbK9W: // global
           _sbJuc::P64 = P64[R1 + 16];
           _sbJuh::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbJuh::P64;
           R2 = Hp - 14;
           R1 = _sbJuc::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuk_entry() //  [R1]
         { info_tbl: [(cbK9Y,
                       label: sat_sbJuk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK9Y: // global
           _sbJuk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbK9Z; else goto cbKa0;
       cbKa0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKa2; else goto cbKa1;
       cbKa2: // global
           HpAlloc = 32;
           goto cbK9Z;
       cbK9Z: // global
           R1 = _sbJuk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKa1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJuk::P64;
           _sbJuc::P64 = P64[_sbJuk::P64 + 16];
           _sbJuh::P64 = P64[_sbJuk::P64 + 24];
           I64[Hp - 24] = sat_sbJuj_info;
           P64[Hp - 8] = _sbJuc::P64;
           P64[Hp] = _sbJuh::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJul_entry() //  [R1, R2]
         { info_tbl: [(cbKa4,
                       label: sat_sbJul_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKa4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbKa8; else goto cbKa7;
       cbKa8: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKa7: // global
           _sbJuc::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbJuk_info;
           P64[Hp - 32] = _sbJuc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbKac,
                       label: Data.Functor.Identity.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKac: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbKag; else goto cbKaf;
       cbKag: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKaf: // global
           I64[Hp - 40] = g_sbJuc_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbK9d::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto cbKaa; else goto cbKab;
       cbKaa: // global
           I64[Hp - 8] = sat_sbJug_info;
           P64[Hp] = _cbK9d::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbKab: // global
           I64[Hp - 8] = sat_sbJul_info;
           P64[Hp] = _cbK9d::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.906073841 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbKao,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKao: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbKap; else goto cbKaq;
       cbKap: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKaq: // global
           I64[Sp - 24] = block_cbKal_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubKau; else goto cbKam;
       ubKau: // global
           call _cbKal(R1) args: 0, res: 0, upd: 0;
       cbKam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKal() //  [R1]
         { info_tbl: [(cbKal,
                       label: block_cbKal_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKal: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.907420032 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshow_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshow_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshow_info;
         const 0;
 },
 sat_sbJut_entry() //  [R1]
         { info_tbl: [(cbKaD,
                       label: sat_sbJut_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKaD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbKaE; else goto cbKaF;
       cbKaE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKaF: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbKaG,
                       label: Data.Functor.Identity.$fShowIdentity_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKaG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKaK; else goto cbKaJ;
       cbKaK: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKaJ: // global
           I64[Hp - 24] = sat_sbJut_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.908758553 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowList_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowList_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowList_info;
         const 0;
 },
 sat_sbJuy_entry() //  [R1, R2]
         { info_tbl: [(cbKaU,
                       label: sat_sbJuy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKaU: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshowList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbKaX,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKaX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbKb1; else goto cbKb0;
       cbKb1: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKb0: // global
           I64[Hp - 8] = sat_sbJuy_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.910307842 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_closure" {
     Data.Functor.Identity.$fShowIdentity_closure:
         const Data.Functor.Identity.$fShowIdentity_info;
         const 0;
 },
 sat_sbJuC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKbb,
                       label: sat_sbJuC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuB_entry() //  [R1, R2]
         { info_tbl: [(cbKbj,
                       label: sat_sbJuB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbj: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fShowIdentity_$cshow_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKbr,
                       label: sat_sbJuA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_entry() //  [R2]
         { info_tbl: [(cbKbv,
                       label: Data.Functor.Identity.$fShowIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbKbz; else goto cbKby;
       cbKbz: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKby: // global
           I64[Hp - 72] = sat_sbJuC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJuB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJuA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.911667533 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity4_closure" {
     Data.Functor.Identity.$fFoldableIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.912347891 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$clength_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$clength_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$clength_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$clength_entry() //  []
         { info_tbl: [(cbKbE,
                       label: Data.Functor.Identity.$fFoldableIdentity_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbE: // global
           R1 = Data.Functor.Identity.$fFoldableIdentity4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.9131504 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cnull_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cnull_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cnull_entry() //  []
         { info_tbl: [(cbKbL,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.914002128 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$ctoList_entry() //  [R2]
         { info_tbl: [(cbKbT,
                       label: Data.Functor.Identity.$fFoldableIdentity_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKbT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKbX; else goto cbKbW;
       cbKbX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKbW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.914923047 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity6_closure" {
     Data.Functor.Identity.$fFoldableIdentity6_closure:
         const Data.Functor.Identity.$fFoldableIdentity6_info;
 },
 Data.Functor.Identity.$fFoldableIdentity6_entry() //  [R2]
         { info_tbl: [(cbKc2,
                       label: Data.Functor.Identity.$fFoldableIdentity6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKc2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.915746109 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cfoldr_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbKc9,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKc9: // global
           R3 = R3;
           _sbJuH::P64 = R2;
           R2 = R4;
           R1 = _sbJuH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.916611018 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity7_closure" {
     Data.Functor.Identity.$fFoldableIdentity7_closure:
         const Data.Functor.Identity.$fFoldableIdentity7_info;
 },
 Data.Functor.Identity.$fFoldableIdentity7_entry() //  [R3]
         { info_tbl: [(cbKcg,
                       label: Data.Functor.Identity.$fFoldableIdentity7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcg: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.917448774 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity2_closure" {
     Data.Functor.Identity.$fFunctorIdentity2_closure:
         const Data.Functor.Identity.$fFunctorIdentity2_info;
 },
 Data.Functor.Identity.$fFunctorIdentity2_entry() //  [R2]
         { info_tbl: [(cbKcn,
                       label: Data.Functor.Identity.$fFunctorIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.91823277 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity1_closure" {
     Data.Functor.Identity.$fFunctorIdentity1_closure:
         const Data.Functor.Identity.$fFunctorIdentity1_info;
 },
 Data.Functor.Identity.$fFunctorIdentity1_entry() //  [R2]
         { info_tbl: [(cbKcu,
                       label: Data.Functor.Identity.$fFunctorIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcu: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.918915069 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity_closure" {
     Data.Functor.Identity.$fFunctorIdentity_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Identity.$fFunctorIdentity2_closure+1;
         const Data.Functor.Identity.$fFunctorIdentity1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.91959225 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity1_closure" {
     Data.Functor.Identity.$fApplicativeIdentity1_closure:
         const Data.Functor.Identity.$fApplicativeIdentity1_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity1_entry() //  [R2]
         { info_tbl: [(cbKcB,
                       label: Data.Functor.Identity.$fApplicativeIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcB: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.920363996 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity2_closure" {
     Data.Functor.Identity.$fApplicativeIdentity2_closure:
         const Data.Functor.Identity.$fApplicativeIdentity2_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity2_entry() //  [R2]
         { info_tbl: [(cbKcI,
                       label: Data.Functor.Identity.$fApplicativeIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcI: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.921152462 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity3_closure" {
     Data.Functor.Identity.$fApplicativeIdentity3_closure:
         const Data.Functor.Identity.$fApplicativeIdentity3_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity3_entry() //  [R2]
         { info_tbl: [(cbKcP,
                       label: Data.Functor.Identity.$fApplicativeIdentity3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.921975635 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure:
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry() //  [R3]
         { info_tbl: [(cbKcW,
                       label: Data.Functor.Identity.$fApplicativeIdentity_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKcW: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.922692878 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity2_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity1_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure+2;
         const GHC.Base.const_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.924359236 UTC

[section ""data" . Data.Functor.Identity.$fStorableIdentity_closure" {
     Data.Functor.Identity.$fStorableIdentity_closure:
         const Data.Functor.Identity.$fStorableIdentity_info;
 },
 sat_sbJv2_entry() //  [R1]
         { info_tbl: [(cbKd7,
                       label: sat_sbJv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKd7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKd8; else goto cbKd9;
       cbKd8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKd9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv1_entry() //  [R1]
         { info_tbl: [(cbKde,
                       label: sat_sbJv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKde: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdf; else goto cbKdg;
       cbKdf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv0_entry() //  [R1]
         { info_tbl: [(cbKdl,
                       label: sat_sbJv0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKdl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdm; else goto cbKdn;
       cbKdm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuZ_entry() //  [R1]
         { info_tbl: [(cbKds,
                       label: sat_sbJuZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKds: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdt; else goto cbKdu;
       cbKdt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuY_entry() //  [R1]
         { info_tbl: [(cbKdz,
                       label: sat_sbJuY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKdz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdA; else goto cbKdB;
       cbKdA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuX_entry() //  [R1]
         { info_tbl: [(cbKdG,
                       label: sat_sbJuX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKdG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdH; else goto cbKdI;
       cbKdH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuW_entry() //  [R1]
         { info_tbl: [(cbKdN,
                       label: sat_sbJuW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKdN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdO; else goto cbKdP;
       cbKdO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuV_entry() //  [R1]
         { info_tbl: [(cbKdU,
                       label: sat_sbJuV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKdU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKdV; else goto cbKdW;
       cbKdV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKdW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fStorableIdentity_entry() //  [R2]
         { info_tbl: [(cbKdY,
                       label: Data.Functor.Identity.$fStorableIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKdY: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbKe2; else goto cbKe1;
       cbKe2: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fStorableIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKe1: // global
           I64[Hp - 256] = sat_sbJv2_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJv1_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJv0_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJuZ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJuY_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJuX_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJuW_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJuV_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.928275318 UTC

[section ""data" . Data.Functor.Identity.$fNumIdentity_closure" {
     Data.Functor.Identity.$fNumIdentity_closure:
         const Data.Functor.Identity.$fNumIdentity_info;
 },
 sat_sbJva_entry() //  [R1]
         { info_tbl: [(cbKeb,
                       label: sat_sbJva_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKeb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKec; else goto cbKed;
       cbKec: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKed: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv9_entry() //  [R1]
         { info_tbl: [(cbKei,
                       label: sat_sbJv9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKei: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKej; else goto cbKek;
       cbKej: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKek: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv8_entry() //  [R1]
         { info_tbl: [(cbKep,
                       label: sat_sbJv8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKeq; else goto cbKer;
       cbKeq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKer: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv7_entry() //  [R1]
         { info_tbl: [(cbKew,
                       label: sat_sbJv7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKew: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKex; else goto cbKey;
       cbKex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKey: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv6_entry() //  [R1]
         { info_tbl: [(cbKeD,
                       label: sat_sbJv6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKeD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKeE; else goto cbKeF;
       cbKeE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKeF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv5_entry() //  [R1]
         { info_tbl: [(cbKeK,
                       label: sat_sbJv5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKeL; else goto cbKeM;
       cbKeL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKeM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv4_entry() //  [R1]
         { info_tbl: [(cbKeR,
                       label: sat_sbJv4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKeR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKeS; else goto cbKeT;
       cbKeS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKeT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fNumIdentity_entry() //  [R2]
         { info_tbl: [(cbKeV,
                       label: Data.Functor.Identity.$fNumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKeV: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbKeZ; else goto cbKeY;
       cbKeZ: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fNumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKeY: // global
           I64[Hp - 224] = sat_sbJva_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJv9_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJv8_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJv7_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJv6_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJv5_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJv4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.930976956 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp1Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp1Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp1Real_info;
 },
 sat_sbJvc_entry() //  [R1]
         { info_tbl: [(cbKf8,
                       label: sat_sbJvc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKf8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKf9; else goto cbKfa;
       cbKf9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKfa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp1Real_entry() //  [R2]
         { info_tbl: [(cbKfb,
                       label: Data.Functor.Identity.$fRealIdentity_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKff; else goto cbKfe;
       cbKff: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKfe: // global
           I64[Hp - 16] = sat_sbJvc_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.932523464 UTC

[section ""data" . Data.Functor.Identity.$fSemigroupIdentity_closure" {
     Data.Functor.Identity.$fSemigroupIdentity_closure:
         const Data.Functor.Identity.$fSemigroupIdentity_info;
 },
 sat_sbJvg_entry() //  [R1]
         { info_tbl: [(cbKfo,
                       label: sat_sbJvg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKfp; else goto cbKfq;
       cbKfp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKfq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvf_entry() //  [R1]
         { info_tbl: [(cbKfv,
                       label: sat_sbJvf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKfw; else goto cbKfx;
       cbKfw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKfx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJve_entry() //  [R1]
         { info_tbl: [(cbKfC,
                       label: sat_sbJve_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKfD; else goto cbKfE;
       cbKfD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKfE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fSemigroupIdentity_entry() //  [R2]
         { info_tbl: [(cbKfG,
                       label: Data.Functor.Identity.$fSemigroupIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfG: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbKfK; else goto cbKfJ;
       cbKfK: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fSemigroupIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKfJ: // global
           I64[Hp - 96] = sat_sbJvg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJvf_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJve_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.934359514 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure" {
     Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure:
         const Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info;
 },
 sat_sbJvi_entry() //  [R1]
         { info_tbl: [(cbKfT,
                       label: sat_sbJvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKfU; else goto cbKfV;
       cbKfU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKfV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cbKfW,
                       label: Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKfW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKg0; else goto cbKfZ;
       cbKg0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKfZ: // global
           I64[Hp - 16] = sat_sbJvi_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fSemigroupIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.935980328 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_closure" {
     Data.Functor.Identity.$fMonoidIdentity_closure:
         const Data.Functor.Identity.$fMonoidIdentity_info;
 },
 sat_sbJvn_entry() //  [R1]
         { info_tbl: [(cbKg9,
                       label: sat_sbJvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKg9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKga; else goto cbKgb;
       cbKga: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKgb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvm_entry() //  [R1]
         { info_tbl: [(cbKgg,
                       label: sat_sbJvm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKgh; else goto cbKgi;
       cbKgh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKgi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvl_entry() //  [R1]
         { info_tbl: [(cbKgn,
                       label: sat_sbJvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKgo; else goto cbKgp;
       cbKgo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKgp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvk_entry() //  [R1]
         { info_tbl: [(cbKgu,
                       label: sat_sbJvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKgv; else goto cbKgw;
       cbKgv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKgw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_entry() //  [R2]
         { info_tbl: [(cbKgy,
                       label: Data.Functor.Identity.$fMonoidIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgy: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbKgC; else goto cbKgB;
       cbKgC: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKgB: // global
           I64[Hp - 128] = sat_sbJvn_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJvm_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJvl_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJvk_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.938185514 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity1_closure" {
     Data.Functor.Identity.$fGeneric1Identity1_closure:
         const Data.Functor.Identity.$fGeneric1Identity1_info;
 },
 Data.Functor.Identity.$fGeneric1Identity1_entry() //  [R2]
         { info_tbl: [(cbKgH,
                       label: Data.Functor.Identity.$fGeneric1Identity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.938987004 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity2_closure" {
     Data.Functor.Identity.$fFoldableIdentity2_closure:
         const Data.Functor.Identity.$fFoldableIdentity2_info;
 },
 Data.Functor.Identity.$fFoldableIdentity2_entry() //  [R2]
         { info_tbl: [(cbKgO,
                       label: Data.Functor.Identity.$fFoldableIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.939700543 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity_closure" {
     Data.Functor.Identity.$fGeneric1Identity_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Identity.$fFoldableIdentity2_closure+1;
         const Data.Functor.Identity.$fGeneric1Identity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.942236104 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity1_closure" {
     Data.Functor.Identity.$fGenericIdentity1_closure:
         const Data.Functor.Identity.$fGenericIdentity1_info;
 },
 Data.Functor.Identity.$fGenericIdentity1_entry() //  [R2]
         { info_tbl: [(cbKgV,
                       label: Data.Functor.Identity.$fGenericIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKgV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.943013936 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity2_closure" {
     Data.Functor.Identity.$fGenericIdentity2_closure:
         const Data.Functor.Identity.$fGenericIdentity2_info;
 },
 Data.Functor.Identity.$fGenericIdentity2_entry() //  [R2]
         { info_tbl: [(cbKh2,
                       label: Data.Functor.Identity.$fGenericIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKh2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.943694387 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity_closure" {
     Data.Functor.Identity.$fGenericIdentity_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Identity.$fGenericIdentity2_closure+1;
         const Data.Functor.Identity.$fGenericIdentity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.944530678 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure" {
     Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure:
         const Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info;
 },
 sat_sbJvt_entry() //  [R1]
         { info_tbl: [(cbKhd,
                       label: sat_sbJvt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKhe; else goto cbKhf;
       cbKhe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKhf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cbKhg,
                       label: Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKhg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKhk; else goto cbKhj;
       cbKhk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKhj: // global
           I64[Hp - 16] = sat_sbJvt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.94614468 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_closure" {
     Data.Functor.Identity.$fFractionalIdentity_closure:
         const Data.Functor.Identity.$fFractionalIdentity_info;
 },
 sat_sbJvy_entry() //  [R1]
         { info_tbl: [(cbKht,
                       label: sat_sbJvy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKhu; else goto cbKhv;
       cbKhu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKhv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvx_entry() //  [R1]
         { info_tbl: [(cbKhA,
                       label: sat_sbJvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKhA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKhB; else goto cbKhC;
       cbKhB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKhC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvw_entry() //  [R1]
         { info_tbl: [(cbKhH,
                       label: sat_sbJvw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKhH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKhI; else goto cbKhJ;
       cbKhI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKhJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvv_entry() //  [R1]
         { info_tbl: [(cbKhO,
                       label: sat_sbJvv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKhO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKhP; else goto cbKhQ;
       cbKhP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKhQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_entry() //  [R2]
         { info_tbl: [(cbKhS,
                       label: Data.Functor.Identity.$fFractionalIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKhS: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbKhW; else goto cbKhV;
       cbKhW: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKhV: // global
           I64[Hp - 128] = sat_sbJvy_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJvx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJvw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJvv_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.948099079 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info;
 },
 sat_sbJvA_entry() //  [R1]
         { info_tbl: [(cbKi5,
                       label: sat_sbJvA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKi5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKi6; else goto cbKi7;
       cbKi6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKi7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(cbKi8,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKi8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKic; else goto cbKib;
       cbKic: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKib: // global
           I64[Hp - 16] = sat_sbJvA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.949518794 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure" {
     Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure:
         const Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info;
 },
 sat_sbJvC_entry() //  [R1]
         { info_tbl: [(cbKil,
                       label: sat_sbJvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKil: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKim; else goto cbKin;
       cbKim: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKin: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cbKio,
                       label: Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKio: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKis; else goto cbKir;
       cbKis: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKir: // global
           I64[Hp - 16] = sat_sbJvC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.953205768 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_closure" {
     Data.Functor.Identity.$fFloatingIdentity_closure:
         const Data.Functor.Identity.$fFloatingIdentity_info;
 },
 sat_sbJw0_entry() //  [R1]
         { info_tbl: [(cbKiB,
                       label: sat_sbJw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKiB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKiC; else goto cbKiD;
       cbKiC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKiD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvZ_entry() //  [R1]
         { info_tbl: [(cbKiI,
                       label: sat_sbJvZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKiI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKiJ; else goto cbKiK;
       cbKiJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKiK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvY_entry() //  [R1]
         { info_tbl: [(cbKiP,
                       label: sat_sbJvY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKiP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKiQ; else goto cbKiR;
       cbKiQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKiR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvX_entry() //  [R1]
         { info_tbl: [(cbKiW,
                       label: sat_sbJvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKiW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKiX; else goto cbKiY;
       cbKiX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKiY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvW_entry() //  [R1]
         { info_tbl: [(cbKj3,
                       label: sat_sbJvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKj3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKj4; else goto cbKj5;
       cbKj4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKj5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvV_entry() //  [R1]
         { info_tbl: [(cbKja,
                       label: sat_sbJvV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKja: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjb; else goto cbKjc;
       cbKjb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvU_entry() //  [R1]
         { info_tbl: [(cbKjh,
                       label: sat_sbJvU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKji; else goto cbKjj;
       cbKji: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvT_entry() //  [R1]
         { info_tbl: [(cbKjo,
                       label: sat_sbJvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjp; else goto cbKjq;
       cbKjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvS_entry() //  [R1]
         { info_tbl: [(cbKjv,
                       label: sat_sbJvS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjw; else goto cbKjx;
       cbKjw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvR_entry() //  [R1]
         { info_tbl: [(cbKjC,
                       label: sat_sbJvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjD; else goto cbKjE;
       cbKjD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvQ_entry() //  [R1]
         { info_tbl: [(cbKjJ,
                       label: sat_sbJvQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjK; else goto cbKjL;
       cbKjK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvP_entry() //  [R1]
         { info_tbl: [(cbKjQ,
                       label: sat_sbJvP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjR; else goto cbKjS;
       cbKjR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvO_entry() //  [R1]
         { info_tbl: [(cbKjX,
                       label: sat_sbJvO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKjX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKjY; else goto cbKjZ;
       cbKjY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKjZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvN_entry() //  [R1]
         { info_tbl: [(cbKk4,
                       label: sat_sbJvN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKk4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKk5; else goto cbKk6;
       cbKk5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKk6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvM_entry() //  [R1]
         { info_tbl: [(cbKkb,
                       label: sat_sbJvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkc; else goto cbKkd;
       cbKkc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKkd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvL_entry() //  [R1]
         { info_tbl: [(cbKki,
                       label: sat_sbJvL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKki: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkj; else goto cbKkk;
       cbKkj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKkk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvK_entry() //  [R1]
         { info_tbl: [(cbKkp,
                       label: sat_sbJvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkq; else goto cbKkr;
       cbKkq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKkr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvJ_entry() //  [R1]
         { info_tbl: [(cbKkw,
                       label: sat_sbJvJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkx; else goto cbKky;
       cbKkx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvI_entry() //  [R1]
         { info_tbl: [(cbKkD,
                       label: sat_sbJvI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkE; else goto cbKkF;
       cbKkE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKkF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvH_entry() //  [R1]
         { info_tbl: [(cbKkK,
                       label: sat_sbJvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkL; else goto cbKkM;
       cbKkL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKkM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvG_entry() //  [R1]
         { info_tbl: [(cbKkR,
                       label: sat_sbJvG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkS; else goto cbKkT;
       cbKkS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKkT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvF_entry() //  [R1]
         { info_tbl: [(cbKkY,
                       label: sat_sbJvF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKkY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKkZ; else goto cbKl0;
       cbKkZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKl0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvE_entry() //  [R1]
         { info_tbl: [(cbKl5,
                       label: sat_sbJvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKl5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKl6; else goto cbKl7;
       cbKl6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_entry() //  [R2]
         { info_tbl: [(cbKl9,
                       label: Data.Functor.Identity.$fFloatingIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKl9: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbKld; else goto cbKlc;
       cbKld: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKlc: // global
           I64[Hp - 736] = sat_sbJw0_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbJvZ_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbJvY_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbJvX_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbJvW_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbJvV_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbJvU_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbJvT_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbJvS_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbJvR_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbJvQ_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbJvP_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbJvO_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbJvN_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbJvM_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbJvL_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbJvK_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbJvJ_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbJvI_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbJvH_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbJvG_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJvF_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJvE_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.959521866 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info;
 },
 sat_sbJw2_entry() //  [R1]
         { info_tbl: [(cbKlm,
                       label: sat_sbJw2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKlm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKln; else goto cbKlo;
       cbKln: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKlo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(cbKlp,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKlp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKlt; else goto cbKls;
       cbKlt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKls: // global
           I64[Hp - 16] = sat_sbJw2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.960948861 UTC

[section ""data" . Data.Functor.Identity.$fEqIdentity_closure" {
     Data.Functor.Identity.$fEqIdentity_closure:
         const Data.Functor.Identity.$fEqIdentity_info;
 },
 sat_sbJw5_entry() //  [R1]
         { info_tbl: [(cbKlC,
                       label: sat_sbJw5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKlC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKlD; else goto cbKlE;
       cbKlD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKlE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJw4_entry() //  [R1]
         { info_tbl: [(cbKlJ,
                       label: sat_sbJw4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKlJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKlK; else goto cbKlL;
       cbKlK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKlL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEqIdentity_entry() //  [R2]
         { info_tbl: [(cbKlN,
                       label: Data.Functor.Identity.$fEqIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKlN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbKlR; else goto cbKlQ;
       cbKlR: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEqIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKlQ: // global
           I64[Hp - 64] = sat_sbJw5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJw4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.962759514 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure" {
     Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure:
         const Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info;
 },
 sat_sbJw7_entry() //  [R1]
         { info_tbl: [(cbKm0,
                       label: sat_sbJw7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKm1; else goto cbKm2;
       cbKm1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKm2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbKm3,
                       label: Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKm3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKm7; else goto cbKm6;
       cbKm7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKm6: // global
           I64[Hp - 16] = sat_sbJw7_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.964770673 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_closure" {
     Data.Functor.Identity.$fOrdIdentity_closure:
         const Data.Functor.Identity.$fOrdIdentity_info;
 },
 sat_sbJwg_entry() //  [R1]
         { info_tbl: [(cbKmg,
                       label: sat_sbJwg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmh; else goto cbKmi;
       cbKmh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwf_entry() //  [R1]
         { info_tbl: [(cbKmn,
                       label: sat_sbJwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmo; else goto cbKmp;
       cbKmo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwe_entry() //  [R1]
         { info_tbl: [(cbKmu,
                       label: sat_sbJwe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmv; else goto cbKmw;
       cbKmv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwd_entry() //  [R1]
         { info_tbl: [(cbKmB,
                       label: sat_sbJwd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmC; else goto cbKmD;
       cbKmC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwc_entry() //  [R1]
         { info_tbl: [(cbKmI,
                       label: sat_sbJwc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmJ; else goto cbKmK;
       cbKmJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwb_entry() //  [R1]
         { info_tbl: [(cbKmP,
                       label: sat_sbJwb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmQ; else goto cbKmR;
       cbKmQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwa_entry() //  [R1]
         { info_tbl: [(cbKmW,
                       label: sat_sbJwa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKmW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKmX; else goto cbKmY;
       cbKmX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKmY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJw9_entry() //  [R1]
         { info_tbl: [(cbKn3,
                       label: sat_sbJw9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKn3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKn4; else goto cbKn5;
       cbKn4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKn5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_entry() //  [R2]
         { info_tbl: [(cbKn7,
                       label: Data.Functor.Identity.$fOrdIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKn7: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbKnb; else goto cbKna;
       cbKnb: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKna: // global
           I64[Hp - 256] = sat_sbJwg_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJwf_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJwe_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJwd_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJwc_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJwb_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJwa_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJw9_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.967685179 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure" {
     Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure:
         const Data.Functor.Identity.$fIxIdentity_$cp1Ix_info;
 },
 sat_sbJwi_entry() //  [R1]
         { info_tbl: [(cbKnk,
                       label: sat_sbJwi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKnk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKnl; else goto cbKnm;
       cbKnl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKnm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry() //  [R2]
         { info_tbl: [(cbKnn,
                       label: Data.Functor.Identity.$fIxIdentity_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKnn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKnr; else goto cbKnq;
       cbKnr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKnq: // global
           I64[Hp - 16] = sat_sbJwi_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.969668458 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_closure" {
     Data.Functor.Identity.$fIxIdentity_closure:
         const Data.Functor.Identity.$fIxIdentity_info;
 },
 sat_sbJwq_entry() //  [R1]
         { info_tbl: [(cbKnA,
                       label: sat_sbJwq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKnA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKnB; else goto cbKnC;
       cbKnB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKnC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwp_entry() //  [R1]
         { info_tbl: [(cbKnH,
                       label: sat_sbJwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKnH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKnI; else goto cbKnJ;
       cbKnI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKnJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwo_entry() //  [R1]
         { info_tbl: [(cbKnO,
                       label: sat_sbJwo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKnO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKnP; else goto cbKnQ;
       cbKnP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKnQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwn_entry() //  [R1]
         { info_tbl: [(cbKnV,
                       label: sat_sbJwn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKnV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKnW; else goto cbKnX;
       cbKnW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKnX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwm_entry() //  [R1]
         { info_tbl: [(cbKo2,
                       label: sat_sbJwm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKo2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKo3; else goto cbKo4;
       cbKo3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKo4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwl_entry() //  [R1]
         { info_tbl: [(cbKo9,
                       label: sat_sbJwl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKo9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKoa; else goto cbKob;
       cbKoa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwk_entry() //  [R1]
         { info_tbl: [(cbKog,
                       label: sat_sbJwk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKog: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKoh; else goto cbKoi;
       cbKoh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKoi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_entry() //  [R2]
         { info_tbl: [(cbKok,
                       label: Data.Functor.Identity.$fIxIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKok: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbKoo; else goto cbKon;
       cbKoo: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKon: // global
           I64[Hp - 224] = sat_sbJwq_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwp_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwo_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwn_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJwm_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJwl_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJwk_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.972304161 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp2Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp2Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp2Real_info;
 },
 sat_sbJws_entry() //  [R1]
         { info_tbl: [(cbKox,
                       label: sat_sbJws_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKoy; else goto cbKoz;
       cbKoy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKoz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp2Real_entry() //  [R2]
         { info_tbl: [(cbKoA,
                       label: Data.Functor.Identity.$fRealIdentity_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKoA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKoE; else goto cbKoD;
       cbKoE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKoD: // global
           I64[Hp - 16] = sat_sbJws_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.973857331 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_closure" {
     Data.Functor.Identity.$fRealIdentity_closure:
         const Data.Functor.Identity.$fRealIdentity_info;
 },
 sat_sbJww_entry() //  [R1]
         { info_tbl: [(cbKoN,
                       label: sat_sbJww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKoO; else goto cbKoP;
       cbKoO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKoP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwv_entry() //  [R1]
         { info_tbl: [(cbKoU,
                       label: sat_sbJwv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKoU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKoV; else goto cbKoW;
       cbKoV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKoW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwu_entry() //  [R1]
         { info_tbl: [(cbKp1,
                       label: sat_sbJwu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKp1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKp2; else goto cbKp3;
       cbKp2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKp3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_entry() //  [R2]
         { info_tbl: [(cbKp5,
                       label: Data.Functor.Identity.$fRealIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKp5: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbKp9; else goto cbKp8;
       cbKp9: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKp8: // global
           I64[Hp - 96] = sat_sbJww_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJwv_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJwu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.975598139 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info;
 },
 sat_sbJwy_entry() //  [R1]
         { info_tbl: [(cbKpi,
                       label: sat_sbJwy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKpj; else goto cbKpk;
       cbKpj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKpk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry() //  [R2]
         { info_tbl: [(cbKpl,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKpl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKpp; else goto cbKpo;
       cbKpp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKpo: // global
           I64[Hp - 16] = sat_sbJwy_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.976866954 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info;
 },
 sat_sbJwA_entry() //  [R1]
         { info_tbl: [(cbKpy,
                       label: sat_sbJwA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKpz; else goto cbKpA;
       cbKpz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKpA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(cbKpB,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKpB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKpF; else goto cbKpE;
       cbKpF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKpE: // global
           I64[Hp - 16] = sat_sbJwA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.978847754 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_closure" {
     Data.Functor.Identity.$fRealFracIdentity_closure:
         const Data.Functor.Identity.$fRealFracIdentity_info;
 },
 sat_sbJwI_entry() //  [R1]
         { info_tbl: [(cbKpO,
                       label: sat_sbJwI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKpO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKpP; else goto cbKpQ;
       cbKpP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKpQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwH_entry() //  [R1]
         { info_tbl: [(cbKpV,
                       label: sat_sbJwH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKpV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKpW; else goto cbKpX;
       cbKpW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKpX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwG_entry() //  [R1]
         { info_tbl: [(cbKq2,
                       label: sat_sbJwG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKq2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKq3; else goto cbKq4;
       cbKq3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKq4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwF_entry() //  [R1]
         { info_tbl: [(cbKq9,
                       label: sat_sbJwF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKq9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKqa; else goto cbKqb;
       cbKqa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKqb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwE_entry() //  [R1]
         { info_tbl: [(cbKqg,
                       label: sat_sbJwE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKqg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKqh; else goto cbKqi;
       cbKqh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKqi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwD_entry() //  [R1]
         { info_tbl: [(cbKqn,
                       label: sat_sbJwD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKqn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKqo; else goto cbKqp;
       cbKqo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKqp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwC_entry() //  [R1]
         { info_tbl: [(cbKqu,
                       label: sat_sbJwC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKqu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKqv; else goto cbKqw;
       cbKqv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKqw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_entry() //  [R2]
         { info_tbl: [(cbKqy,
                       label: Data.Functor.Identity.$fRealFracIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKqy: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbKqC; else goto cbKqB;
       cbKqC: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKqB: // global
           I64[Hp - 224] = sat_sbJwI_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwH_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwG_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwF_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJwE_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJwD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJwC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.981682124 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info;
 },
 sat_sbJwK_entry() //  [R1]
         { info_tbl: [(cbKqL,
                       label: sat_sbJwK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKqL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKqM; else goto cbKqN;
       cbKqM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKqN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(cbKqO,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKqO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKqS; else goto cbKqR;
       cbKqS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKqR: // global
           I64[Hp - 16] = sat_sbJwK_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.984577699 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_info;
 },
 sat_sbJx1_entry() //  [R1]
         { info_tbl: [(cbKr1,
                       label: sat_sbJx1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKr1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKr2; else goto cbKr3;
       cbKr2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKr3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx0_entry() //  [R1]
         { info_tbl: [(cbKr8,
                       label: sat_sbJx0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKr8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKr9; else goto cbKra;
       cbKr9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKra: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwZ_entry() //  [R1]
         { info_tbl: [(cbKrf,
                       label: sat_sbJwZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKrg; else goto cbKrh;
       cbKrg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKrh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwY_entry() //  [R1]
         { info_tbl: [(cbKrm,
                       label: sat_sbJwY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKrn; else goto cbKro;
       cbKrn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwX_entry() //  [R1]
         { info_tbl: [(cbKrt,
                       label: sat_sbJwX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKru; else goto cbKrv;
       cbKru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKrv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwW_entry() //  [R1]
         { info_tbl: [(cbKrA,
                       label: sat_sbJwW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKrB; else goto cbKrC;
       cbKrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwV_entry() //  [R1]
         { info_tbl: [(cbKrH,
                       label: sat_sbJwV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKrI; else goto cbKrJ;
       cbKrI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKrJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwU_entry() //  [R1]
         { info_tbl: [(cbKrO,
                       label: sat_sbJwU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKrP; else goto cbKrQ;
       cbKrP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKrQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwT_entry() //  [R1]
         { info_tbl: [(cbKrV,
                       label: sat_sbJwT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKrW; else goto cbKrX;
       cbKrW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKrX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwS_entry() //  [R1]
         { info_tbl: [(cbKs2,
                       label: sat_sbJwS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKs2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKs3; else goto cbKs4;
       cbKs3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKs4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwR_entry() //  [R1]
         { info_tbl: [(cbKs9,
                       label: sat_sbJwR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKs9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKsa; else goto cbKsb;
       cbKsa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKsb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwQ_entry() //  [R1]
         { info_tbl: [(cbKsg,
                       label: sat_sbJwQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKsh; else goto cbKsi;
       cbKsh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKsi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwP_entry() //  [R1]
         { info_tbl: [(cbKsn,
                       label: sat_sbJwP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKso; else goto cbKsp;
       cbKso: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKsp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwO_entry() //  [R1]
         { info_tbl: [(cbKsu,
                       label: sat_sbJwO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKsv; else goto cbKsw;
       cbKsv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKsw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwN_entry() //  [R1]
         { info_tbl: [(cbKsB,
                       label: sat_sbJwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKsC; else goto cbKsD;
       cbKsC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKsD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwM_entry() //  [R1]
         { info_tbl: [(cbKsI,
                       label: sat_sbJwM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKsJ; else goto cbKsK;
       cbKsJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKsK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_entry() //  [R2]
         { info_tbl: [(cbKsM,
                       label: Data.Functor.Identity.$fRealFloatIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsM: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cbKsQ; else goto cbKsP;
       cbKsQ: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKsP: // global
           I64[Hp - 512] = sat_sbJx1_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_sbJx0_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sbJwZ_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_sbJwY_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sbJwX_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_sbJwW_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sbJwV_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_sbJwU_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sbJwT_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_sbJwS_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sbJwR_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_sbJwQ_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sbJwP_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwO_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwN_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwM_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.99009551 UTC

[section ""data" . Data.Functor.Identity.$fEnumIdentity_closure" {
     Data.Functor.Identity.$fEnumIdentity_closure:
         const Data.Functor.Identity.$fEnumIdentity_info;
 },
 sat_sbJxa_entry() //  [R1]
         { info_tbl: [(cbKsZ,
                       label: sat_sbJxa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKsZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKt0; else goto cbKt1;
       cbKt0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKt1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx9_entry() //  [R1]
         { info_tbl: [(cbKt6,
                       label: sat_sbJx9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKt6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKt7; else goto cbKt8;
       cbKt7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKt8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx8_entry() //  [R1]
         { info_tbl: [(cbKtd,
                       label: sat_sbJx8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKtd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKte; else goto cbKtf;
       cbKte: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKtf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx7_entry() //  [R1]
         { info_tbl: [(cbKtk,
                       label: sat_sbJx7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKtk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKtl; else goto cbKtm;
       cbKtl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKtm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx6_entry() //  [R1]
         { info_tbl: [(cbKtr,
                       label: sat_sbJx6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKtr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKts; else goto cbKtt;
       cbKts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKtt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx5_entry() //  [R1]
         { info_tbl: [(cbKty,
                       label: sat_sbJx5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKty: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKtz; else goto cbKtA;
       cbKtz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKtA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx4_entry() //  [R1]
         { info_tbl: [(cbKtF,
                       label: sat_sbJx4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKtF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKtG; else goto cbKtH;
       cbKtG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKtH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx3_entry() //  [R1]
         { info_tbl: [(cbKtM,
                       label: sat_sbJx3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKtM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKtN; else goto cbKtO;
       cbKtN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKtO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEnumIdentity_entry() //  [R2]
         { info_tbl: [(cbKtQ,
                       label: Data.Functor.Identity.$fEnumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKtQ: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbKtU; else goto cbKtT;
       cbKtU: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEnumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKtT: // global
           I64[Hp - 256] = sat_sbJxa_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJx9_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJx8_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJx7_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJx6_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJx5_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJx4_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJx3_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.992957429 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info;
 },
 sat_sbJxc_entry() //  [R1]
         { info_tbl: [(cbKu3,
                       label: sat_sbJxc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKu3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKu4; else goto cbKu5;
       cbKu4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKu5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry() //  [R2]
         { info_tbl: [(cbKu6,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKu6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKua; else goto cbKu9;
       cbKua: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKu9: // global
           I64[Hp - 16] = sat_sbJxc_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEnumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.995349001 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_closure" {
     Data.Functor.Identity.$fIntegralIdentity_closure:
         const Data.Functor.Identity.$fIntegralIdentity_info;
 },
 sat_sbJxm_entry() //  [R1]
         { info_tbl: [(cbKuj,
                       label: sat_sbJxm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKuj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKuk; else goto cbKul;
       cbKuk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKul: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxl_entry() //  [R1]
         { info_tbl: [(cbKuq,
                       label: sat_sbJxl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKuq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKur; else goto cbKus;
       cbKur: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKus: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxk_entry() //  [R1]
         { info_tbl: [(cbKux,
                       label: sat_sbJxk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKux: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKuy; else goto cbKuz;
       cbKuy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKuz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxj_entry() //  [R1]
         { info_tbl: [(cbKuE,
                       label: sat_sbJxj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKuE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKuF; else goto cbKuG;
       cbKuF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKuG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxi_entry() //  [R1]
         { info_tbl: [(cbKuL,
                       label: sat_sbJxi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKuL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKuM; else goto cbKuN;
       cbKuM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKuN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxh_entry() //  [R1]
         { info_tbl: [(cbKuS,
                       label: sat_sbJxh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKuS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKuT; else goto cbKuU;
       cbKuT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKuU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxg_entry() //  [R1]
         { info_tbl: [(cbKuZ,
                       label: sat_sbJxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKuZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKv0; else goto cbKv1;
       cbKv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKv1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxf_entry() //  [R1]
         { info_tbl: [(cbKv6,
                       label: sat_sbJxf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKv6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKv7; else goto cbKv8;
       cbKv7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKv8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxe_entry() //  [R1]
         { info_tbl: [(cbKvd,
                       label: sat_sbJxe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKve; else goto cbKvf;
       cbKve: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKvf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_entry() //  [R2]
         { info_tbl: [(cbKvh,
                       label: Data.Functor.Identity.$fIntegralIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvh: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto cbKvl; else goto cbKvk;
       cbKvl: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKvk: // global
           I64[Hp - 288] = sat_sbJxm_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_sbJxl_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sbJxk_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_sbJxj_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_sbJxi_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbJxh_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbJxg_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbJxf_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbJxe_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.998582858 UTC

[section ""data" . Data.Functor.Identity.$fBoundedIdentity_closure" {
     Data.Functor.Identity.$fBoundedIdentity_closure:
         const Data.Functor.Identity.$fBoundedIdentity_info;
 },
 sat_sbJxp_entry() //  [R1]
         { info_tbl: [(cbKvu,
                       label: sat_sbJxp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKvv; else goto cbKvw;
       cbKvv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKvw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxo_entry() //  [R1]
         { info_tbl: [(cbKvB,
                       label: sat_sbJxo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKvC; else goto cbKvD;
       cbKvC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKvD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBoundedIdentity_entry() //  [R2]
         { info_tbl: [(cbKvF,
                       label: Data.Functor.Identity.$fBoundedIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbKvJ; else goto cbKvI;
       cbKvJ: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBoundedIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKvI: // global
           I64[Hp - 64] = sat_sbJxp_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJxo_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.000124636 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure" {
     Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure:
         const Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info;
 },
 sat_sbJxr_entry() //  [R1]
         { info_tbl: [(cbKvS,
                       label: sat_sbJxr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKvT; else goto cbKvU;
       cbKvT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKvU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry() //  [R2]
         { info_tbl: [(cbKvV,
                       label: Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKvV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKvZ; else goto cbKvY;
       cbKvZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKvY: // global
           I64[Hp - 16] = sat_sbJxr_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.003789855 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_closure" {
     Data.Functor.Identity.$fBitsIdentity_closure:
         const Data.Functor.Identity.$fBitsIdentity_info;
 },
 sat_sbJxP_entry() //  [R1]
         { info_tbl: [(cbKw8,
                       label: sat_sbJxP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKw8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKw9; else goto cbKwa;
       cbKw9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxO_entry() //  [R1]
         { info_tbl: [(cbKwf,
                       label: sat_sbJxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwg; else goto cbKwh;
       cbKwg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxN_entry() //  [R1]
         { info_tbl: [(cbKwm,
                       label: sat_sbJxN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwn; else goto cbKwo;
       cbKwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxM_entry() //  [R1]
         { info_tbl: [(cbKwt,
                       label: sat_sbJxM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwu; else goto cbKwv;
       cbKwu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxL_entry() //  [R1]
         { info_tbl: [(cbKwA,
                       label: sat_sbJxL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwB; else goto cbKwC;
       cbKwB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxK_entry() //  [R1]
         { info_tbl: [(cbKwH,
                       label: sat_sbJxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwI; else goto cbKwJ;
       cbKwI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxJ_entry() //  [R1]
         { info_tbl: [(cbKwO,
                       label: sat_sbJxJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwP; else goto cbKwQ;
       cbKwP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxI_entry() //  [R1]
         { info_tbl: [(cbKwV,
                       label: sat_sbJxI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKwV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKwW; else goto cbKwX;
       cbKwW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKwX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxH_entry() //  [R1]
         { info_tbl: [(cbKx2,
                       label: sat_sbJxH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKx2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKx3; else goto cbKx4;
       cbKx3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKx4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxG_entry() //  [R1]
         { info_tbl: [(cbKx9,
                       label: sat_sbJxG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKx9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxa; else goto cbKxb;
       cbKxa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxF_entry() //  [R1]
         { info_tbl: [(cbKxg,
                       label: sat_sbJxF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxh; else goto cbKxi;
       cbKxh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxE_entry() //  [R1]
         { info_tbl: [(cbKxn,
                       label: sat_sbJxE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxo; else goto cbKxp;
       cbKxo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxD_entry() //  [R1]
         { info_tbl: [(cbKxu,
                       label: sat_sbJxD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxv; else goto cbKxw;
       cbKxv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxC_entry() //  [R1]
         { info_tbl: [(cbKxB,
                       label: sat_sbJxC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxC; else goto cbKxD;
       cbKxC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxB_entry() //  [R1]
         { info_tbl: [(cbKxI,
                       label: sat_sbJxB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxJ; else goto cbKxK;
       cbKxJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxA_entry() //  [R1]
         { info_tbl: [(cbKxP,
                       label: sat_sbJxA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxQ; else goto cbKxR;
       cbKxQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxz_entry() //  [R1]
         { info_tbl: [(cbKxW,
                       label: sat_sbJxz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKxW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKxX; else goto cbKxY;
       cbKxX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKxY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxy_entry() //  [R1]
         { info_tbl: [(cbKy3,
                       label: sat_sbJxy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKy3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKy4; else goto cbKy5;
       cbKy4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKy5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxx_entry() //  [R1]
         { info_tbl: [(cbKya,
                       label: sat_sbJxx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKya: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKyb; else goto cbKyc;
       cbKyb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKyc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxw_entry() //  [R1]
         { info_tbl: [(cbKyh,
                       label: sat_sbJxw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKyi; else goto cbKyj;
       cbKyi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKyj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxv_entry() //  [R1]
         { info_tbl: [(cbKyo,
                       label: sat_sbJxv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKyp; else goto cbKyq;
       cbKyp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKyq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxu_entry() //  [R1]
         { info_tbl: [(cbKyv,
                       label: sat_sbJxu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKyw; else goto cbKyx;
       cbKyw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKyx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxt_entry() //  [R1]
         { info_tbl: [(cbKyC,
                       label: sat_sbJxt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKyD; else goto cbKyE;
       cbKyD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKyE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbKyG,
                       label: Data.Functor.Identity.$fBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyG: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbKyK; else goto cbKyJ;
       cbKyK: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKyJ: // global
           I64[Hp - 736] = sat_sbJxP_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbJxO_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbJxN_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbJxM_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbJxL_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbJxK_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbJxJ_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbJxI_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbJxH_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbJxG_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbJxF_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbJxE_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbJxD_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbJxC_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbJxB_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbJxA_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbJxz_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbJxy_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbJxx_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbJxw_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbJxv_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJxu_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJxt_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.01036491 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info;
 },
 sat_sbJxR_entry() //  [R1]
         { info_tbl: [(cbKyT,
                       label: sat_sbJxR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKyU; else goto cbKyV;
       cbKyU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKyV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(cbKyW,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKyW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKz0; else goto cbKyZ;
       cbKz0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKyZ: // global
           I64[Hp - 16] = sat_sbJxR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fBitsIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.011981824 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_info;
 },
 sat_sbJxW_entry() //  [R1]
         { info_tbl: [(cbKz9,
                       label: sat_sbJxW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKza; else goto cbKzb;
       cbKza: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKzb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxV_entry() //  [R1]
         { info_tbl: [(cbKzg,
                       label: sat_sbJxV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKzh; else goto cbKzi;
       cbKzh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKzi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxU_entry() //  [R1]
         { info_tbl: [(cbKzn,
                       label: sat_sbJxU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKzo; else goto cbKzp;
       cbKzo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKzp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxT_entry() //  [R1]
         { info_tbl: [(cbKzu,
                       label: sat_sbJxT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKzv; else goto cbKzw;
       cbKzv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKzw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbKzy,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzy: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbKzC; else goto cbKzB;
       cbKzC: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKzB: // global
           I64[Hp - 128] = sat_sbJxW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJxV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJxU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJxT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.013866816 UTC

[section ""data" . Data.Functor.Identity.runIdentity_closure" {
     Data.Functor.Identity.runIdentity_closure:
         const Data.Functor.Identity.runIdentity_info;
 },
 Data.Functor.Identity.runIdentity_entry() //  [R2]
         { info_tbl: [(cbKzH,
                       label: Data.Functor.Identity.runIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzH: // global
           R2 = R2;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.014703501 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure:
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info;
 },
 Data.Functor.Identity.$fMonadFixIdentity_$cmfix_entry() //  [R2]
         { info_tbl: [(cbKzP,
                       label: Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKzT; else goto cbKzS;
       cbKzT: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKzS: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbKzO::P64 = Hp - 24;
           P64[Hp] = _cbKzO::P64;
           R1 = _cbKzO::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.015662053 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>=_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>=_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbKzY,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKzY: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.016500077 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>_entry() //  [R2, R3]
         { info_tbl: [(cbKA5,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKA5: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.01734361 UTC

[section ""data" . lvl_rbJt6_closure" {
     lvl_rbJt6_closure:
         const lvl_rbJt6_info;
         const 0;
 },
 lvl_rbJt6_entry() //  [R2]
         { info_tbl: [(cbKAc,
                       label: lvl_rbJt6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKAc: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.018112149 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_closure" {
     Data.Functor.Identity.$fMonadIdentity_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Functor.Identity.$fApplicativeIdentity_closure+1;
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_closure+2;
         const Data.Functor.Identity.$fMonadIdentity_$c>>_closure+2;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const lvl_rbJt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.018737728 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure+1;
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.019385012 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity5_closure" {
     Data.Functor.Identity.$fFoldableIdentity5_closure:
         const Data.Functor.Identity.$fFoldableIdentity5_info;
 },
 Data.Functor.Identity.$fFoldableIdentity5_entry() //  [R3]
         { info_tbl: [(cbKAj,
                       label: Data.Functor.Identity.$fFoldableIdentity5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKAj: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.020210864 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity3_closure" {
     Data.Functor.Identity.$fFoldableIdentity3_closure:
         const Data.Functor.Identity.$fFoldableIdentity3_info;
 },
 Data.Functor.Identity.$fFoldableIdentity3_entry() //  [R3]
         { info_tbl: [(cbKAq,
                       label: Data.Functor.Identity.$fFoldableIdentity3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKAq: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.021014781 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity1_closure" {
     Data.Functor.Identity.$fFoldableIdentity1_closure:
         const Data.Functor.Identity.$fFoldableIdentity1_info;
 },
 Data.Functor.Identity.$fFoldableIdentity1_entry() //  [R3]
         { info_tbl: [(cbKAx,
                       label: Data.Functor.Identity.$fFoldableIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKAx: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.021920132 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity8_closure" {
     Data.Functor.Identity.$fFoldableIdentity8_closure:
         const Data.Functor.Identity.$fFoldableIdentity8_info;
 },
 Data.Functor.Identity.$fFoldableIdentity8_entry() //  [R3]
         { info_tbl: [(cbKAE,
                       label: Data.Functor.Identity.$fFoldableIdentity8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKAE: // global
           R2 = R3;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.022709497 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_closure" {
     Data.Functor.Identity.$fFoldableIdentity_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Identity.$fFoldableIdentity8_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity7_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$clength_closure+1;
         const GHC.Classes.==_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.023397471 UTC

[section ""cstring" . Data.Functor.Identity.$trModule4_bytes" {
     Data.Functor.Identity.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.026472626 UTC

[section ""data" . Data.Functor.Identity.$trModule3_closure" {
     Data.Functor.Identity.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.027037138 UTC

[section ""cstring" . Data.Functor.Identity.$trModule2_bytes" {
     Data.Functor.Identity.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.027531437 UTC

[section ""data" . Data.Functor.Identity.$trModule1_closure" {
     Data.Functor.Identity.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.028079356 UTC

[section ""data" . Data.Functor.Identity.$trModule_closure" {
     Data.Functor.Identity.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Identity.$trModule3_closure+1;
         const Data.Functor.Identity.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.028649095 UTC

[section ""data" . $krep_rbJt7_closure" {
     $krep_rbJt7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.029204829 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity1_closure" {
     Data.Functor.Identity.$tcIdentity1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$fReadIdentity6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.029837477 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity_closure" {
     Data.Functor.Identity.$tcIdentity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tcIdentity1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 3410104521590905987;
         const 16392070908630191652;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.030451543 UTC

[section ""data" . $krep1_rbJt8_closure" {
     $krep1_rbJt8_closure:
         const :_con_info;
         const $krep_rbJt7_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.031020785 UTC

[section ""data" . $krep2_rbJt9_closure" {
     $krep2_rbJt9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Identity.$tcIdentity_closure+1;
         const $krep1_rbJt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.031593857 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity1_closure" {
     Data.Functor.Identity.$tc'Identity1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbJt7_closure+2;
         const $krep2_rbJt9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.032172463 UTC

[section ""cstring" . Data.Functor.Identity.$tc'Identity3_bytes" {
     Data.Functor.Identity.$tc'Identity3_bytes:
         I8[] [39,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.032699481 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity2_closure" {
     Data.Functor.Identity.$tc'Identity2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$tc'Identity3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.033315134 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity_closure" {
     Data.Functor.Identity.$tc'Identity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tc'Identity2_closure+1;
         const Data.Functor.Identity.$tc'Identity1_closure+4;
         const 11920310844698764515;
         const 3935129235072617509;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.033897369 UTC

[section ""relreadonly" . SbJA1_srt" {
     SbJA1_srt:
         const Data.Functor.Identity.$fReadIdentity5_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Identity.$w$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity3_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadList_closure;
         const Data.Functor.Identity.$w$creadListPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_closure;
         const Data.Functor.Identity.$fShowIdentity1_closure;
         const Data.Functor.Identity.$w$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshow_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
         const Data.Functor.Identity.$fShowIdentity_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.03475637 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:36.035878412 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity4_closure" {
     Data.Functor.Identity.$fReadIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.037979478 UTC

[section ""cstring" . Data.Functor.Identity.$fReadIdentity6_bytes" {
     Data.Functor.Identity.$fReadIdentity6_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.039871478 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity5_closure" {
     Data.Functor.Identity.$fReadIdentity5_closure:
         const Data.Functor.Identity.$fReadIdentity5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity5_entry() //  [R1]
         { info_tbl: [(cbKAP,
                       label: Data.Functor.Identity.$fReadIdentity5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKAP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKAQ; else goto cbKAR;
       cbKAQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKAR: // global
           (_cbKAM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbKAM::I64 == 0) goto cbKAO; else goto cbKAN;
       cbKAO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbKAN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbKAM::I64;
           R2 = Data.Functor.Identity.$fReadIdentity6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.045419395 UTC

[section ""data" . Data.Functor.Identity.$w$creadsPrec_closure" {
     Data.Functor.Identity.$w$creadsPrec_closure:
         const Data.Functor.Identity.$w$creadsPrec_info;
         const 0;
 },
 go1_sbJto_entry() //  [R1, R2]
         { info_tbl: [(cbKBB,
                       label: go1_sbJto_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKBB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbKBC; else goto cbKBD;
       cbKBC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKBD: // global
           I64[Sp - 24] = block_cbKBu_info;
           _sbJto::P64 = R1;
           _sbJtn::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sbJtn::P64;
           P64[Sp - 8] = _sbJto::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubKBV; else goto cbKBv;
       ubKBV: // global
           call _cbKBu(R1) args: 0, res: 0, upd: 0;
       cbKBv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKBu() //  [R1]
         { info_tbl: [(cbKBu,
                       label: block_cbKBu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKBu: // global
           if (R1 & 7 == 1) goto cbKBy; else goto cbKBz;
       cbKBy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbKBz: // global
           I64[Sp] = block_cbKBJ_info;
           _sbJts::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbJts::P64;
           if (R1 & 7 != 0) goto ubKBU; else goto cbKBK;
       ubKBU: // global
           call _cbKBJ(R1) args: 0, res: 0, upd: 0;
       cbKBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKBJ() //  [R1]
         { info_tbl: [(cbKBJ,
                       label: block_cbKBJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKBJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbKBT; else goto cbKBS;
       cbKBT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbKBS: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sbJte_entry() //  [R1, R2]
         { info_tbl: [(cbKC0,
                       label: go_sbJte_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKC0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbKC1; else goto ubKCl;
       cbKC1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubKCl: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbKB5() args: 0, res: 0, upd: 0;
     }
 },
 _cbKB5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKB5: // global
           _sbJtb::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cbKB8_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbJtb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubKCn; else goto cbKB9;
       ubKCn: // global
           call _cbKB8(R1) args: 0, res: 0, upd: 0;
       cbKB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKB8() //  [R1]
         { info_tbl: [(cbKB8,
                       label: block_cbKB8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKB8: // global
           if (R1 & 7 == 1) goto cbKBX; else goto cbKBY;
       cbKBX: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbKBY: // global
           I64[Sp - 8] = block_cbKBe_info;
           _sbJti::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbJti::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubKCo; else goto cbKBf;
       ubKCo: // global
           call _cbKBe(R1) args: 0, res: 0, upd: 0;
       cbKBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKBe() //  [R1]
         { info_tbl: [(cbKBe,
                       label: block_cbKBe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKBe: // global
           I64[Sp - 8] = block_cbKBj_info;
           R3 = Data.Functor.Identity.$fReadIdentity5_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbKBj() //  [R1]
         { info_tbl: [(cbKBj,
                       label: block_cbKBj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKBj: // global
           _sbJti::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbKCa; else goto cbKCc;
       cbKCa: // global
           P64[Sp + 32] = _sbJti::P64;
           Sp = Sp + 24;
           call _cbKB5() args: 0, res: 0, upd: 0;
       cbKCc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbKCf; else goto cbKCe;
       cbKCf: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbKCe: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbJti::P64;
           I64[Hp - 8] = go1_sbJto_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_cbKCb_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _sbJtl::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp + 16] = _sbJtl::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbKCb() //  [R1]
         { info_tbl: [(cbKCb,
                       label: block_cbKCb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKCb: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbJto_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtD_entry() //  [R1, R2]
         { info_tbl: [(cbKCy,
                       label: sat_sbJtD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKCy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKCz; else goto cbKCA;
       cbKCz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKCA: // global
           I64[Sp - 16] = block_cbKCw_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbKCw() //  [R1]
         { info_tbl: [(cbKCw,
                       label: block_cbKCw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKCw: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sbJte_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbKCG,
                       label: Data.Functor.Identity.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKCG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKCK; else goto cbKCJ;
       cbKCK: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKCJ: // global
           I64[Hp - 24] = go_sbJte_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbJtD_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sbJtA::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sbJtA::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.070709304 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbKDV,
                       label: Data.Functor.Identity.$fReadIdentity_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKDV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbKDW; else goto cbKDX;
       cbKDW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKDX: // global
           I64[Sp - 24] = block_cbKDS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubKE1; else goto cbKDT;
       ubKE1: // global
           call _cbKDS(R1) args: 0, res: 0, upd: 0;
       cbKDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKDS() //  [R1]
         { info_tbl: [(cbKDS,
                       label: block_cbKDS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKDS: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$creadsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.076521087 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity3_closure" {
     Data.Functor.Identity.$fReadIdentity3_closure:
         const Data.Functor.Identity.$fReadIdentity3_info;
         const 0;
 },
 sat_sbJtM_entry() //  [R1, R2]
         { info_tbl: [(cbKEk,
                       label: sat_sbJtM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKEk: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbKEq,
                       label: Data.Functor.Identity.$fReadIdentity3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKEq: // global
           _sbJtL::P64 = R4;
           _sbJtK::P64 = R3;
           _sbJtJ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbKEr; else goto cbKEs;
       cbKEs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKEu; else goto cbKEt;
       cbKEu: // global
           HpAlloc = 24;
           goto cbKEr;
       cbKEr: // global
           R4 = _sbJtL::P64;
           R3 = _sbJtK::P64;
           R2 = _sbJtJ::P64;
           R1 = Data.Functor.Identity.$fReadIdentity3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKEt: // global
           I64[Hp - 16] = sat_sbJtM_info;
           P64[Hp - 8] = _sbJtJ::P64;
           P64[Hp] = _sbJtK::P64;
           I64[Sp - 8] = block_cbKEn_info;
           R3 = _sbJtL::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbKEn() //  [R1]
         { info_tbl: [(cbKEn,
                       label: block_cbKEn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKEn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbKEx; else goto cbKEw;
       cbKEx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbKEw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.084105843 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity2_closure" {
     Data.Functor.Identity.$fReadIdentity2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.086264728 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadList_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadList_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadList_info;
         const 0;
 },
 sat_sbJtQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKEY,
                       label: sat_sbJtQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKEY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtR_entry() //  [R1]
         { info_tbl: [(cbKF1,
                       label: sat_sbJtR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKF1: // global
           _sbJtR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbKF2; else goto cbKF3;
       cbKF3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbKF5; else goto cbKF4;
       cbKF5: // global
           HpAlloc = 16;
           goto cbKF2;
       cbKF2: // global
           R1 = _sbJtR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJtR::P64;
           _sbJtP::P64 = P64[_sbJtR::P64 + 16];
           I64[Hp - 8] = sat_sbJtQ_info;
           P64[Hp] = _sbJtP::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fReadIdentity_$creadList_entry() //  [R2]
         { info_tbl: [(cbKF6,
                       label: Data.Functor.Identity.$fReadIdentity_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKF6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKFa; else goto cbKF9;
       cbKFa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKF9: // global
           I64[Hp - 16] = sat_sbJtR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.094742833 UTC

[section ""data" . Data.Functor.Identity.$w$creadListPrec_closure" {
     Data.Functor.Identity.$w$creadListPrec_closure:
         const Data.Functor.Identity.$w$creadListPrec_info;
         const 0;
 },
 sat_sbJtU_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKFz,
                       label: sat_sbJtU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKFz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_sbJtT_entry() //  [R1]
         { info_tbl: [(cbKFC,
                       label: w1_sbJtT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKFC: // global
           _sbJtT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbKFD; else goto cbKFE;
       cbKFE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbKFG; else goto cbKFF;
       cbKFG: // global
           HpAlloc = 16;
           goto cbKFD;
       cbKFD: // global
           R1 = _sbJtT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKFF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJtT::P64;
           _sbJtS::P64 = P64[_sbJtT::P64 + 16];
           I64[Hp - 8] = sat_sbJtU_info;
           P64[Hp] = _sbJtS::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_sbJtV_entry() //  [R1, R2]
         { info_tbl: [(cbKFM,
                       label: w2_sbJtV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKFM: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJtZ_entry() //  [R1, R2]
         { info_tbl: [(cbKFX,
                       label: sat_sbJtZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKFX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbKFY; else goto cbKFZ;
       cbKFY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKFZ: // global
           I64[Sp - 8] = block_cbKFU_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbKFU() //  [R1]
         { info_tbl: [(cbKFU,
                       label: block_cbKFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKFU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbKG2; else goto cbKG1;
       cbKG2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbKG1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbKG3,
                       label: Data.Functor.Identity.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKG3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbKG7; else goto cbKG6;
       cbKG7: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKG6: // global
           I64[Hp - 48] = w1_sbJtT_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_sbJtV_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbJtZ_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.108441123 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity1_closure" {
     Data.Functor.Identity.$fReadIdentity1_closure:
         const Data.Functor.Identity.$fReadIdentity1_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity1_entry() //  [R2]
         { info_tbl: [(cbKGB,
                       label: Data.Functor.Identity.$fReadIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKGB: // global
           R2 = R2;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.112492475 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_closure" {
     Data.Functor.Identity.$fReadIdentity_closure:
         const Data.Functor.Identity.$fReadIdentity_info;
         const 0;
 },
 lvl1_sbJu3_entry() //  [R1]
         { info_tbl: [(cbKGQ,
                       label: lvl1_sbJu3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKGQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKGR; else goto cbKGS;
       cbKGR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKGS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJu8_entry() //  [R1]
         { info_tbl: [(cbKGY,
                       label: sat_sbJu8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKGY: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJu6_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKH6,
                       label: sat_sbJu6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKH6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJu5_entry() //  [R1]
         { info_tbl: [(cbKHd,
                       label: sat_sbJu5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKHd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKHe; else goto cbKHf;
       cbKHe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKHf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fReadIdentity_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJu4_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKHl,
                       label: sat_sbJu4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKHl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity_entry() //  [R2]
         { info_tbl: [(cbKHp,
                       label: Data.Functor.Identity.$fReadIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKHp: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbKHt; else goto cbKHs;
       cbKHt: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKHs: // global
           I64[Hp - 128] = lvl1_sbJu3_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJu8_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sbJu6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJu5_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJu4_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.124601257 UTC

[section ""cstring" . Data.Functor.Identity.$fShowIdentity2_bytes" {
     Data.Functor.Identity.$fShowIdentity2_bytes:
         I8[] [73,100,101,110,116,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.126537859 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity1_closure" {
     Data.Functor.Identity.$fShowIdentity1_closure:
         const Data.Functor.Identity.$fShowIdentity1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity1_entry() //  [R1]
         { info_tbl: [(cbKI2,
                       label: Data.Functor.Identity.$fShowIdentity1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKI2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKI3; else goto cbKI4;
       cbKI3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKI4: // global
           (_cbKHZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbKHZ::I64 == 0) goto cbKI1; else goto cbKI0;
       cbKI1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbKI0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbKHZ::I64;
           R2 = Data.Functor.Identity.$fShowIdentity2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.131605294 UTC

[section ""data" . Data.Functor.Identity.$w$cshowsPrec_closure" {
     Data.Functor.Identity.$w$cshowsPrec_closure:
         const Data.Functor.Identity.$w$cshowsPrec_info;
         const 0;
 },
 g_sbJuc_entry() //  [R1]
         { info_tbl: [(cbKIk,
                       label: g_sbJuc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKIk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbKIl; else goto cbKIm;
       cbKIl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKIm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbJuf_entry() //  [R1]
         { info_tbl: [(cbKIz,
                       label: sat_sbJuf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKIz: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJug_entry() //  [R1, R2]
         { info_tbl: [(cbKIC,
                       label: sat_sbJug_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKIC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKIG; else goto cbKIF;
       cbKIG: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKIF: // global
           _sbJuc::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbJuf_info;
           P64[Hp - 8] = _sbJuc::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuj_entry() //  [R1]
         { info_tbl: [(cbKIW,
                       label: sat_sbJuj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKIW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKJ0; else goto cbKIZ;
       cbKJ0: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKIZ: // global
           _sbJuc::P64 = P64[R1 + 16];
           _sbJuh::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbJuh::P64;
           R2 = Hp - 14;
           R1 = _sbJuc::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuk_entry() //  [R1]
         { info_tbl: [(cbKJ1,
                       label: sat_sbJuk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKJ1: // global
           _sbJuk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbKJ2; else goto cbKJ3;
       cbKJ3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKJ5; else goto cbKJ4;
       cbKJ5: // global
           HpAlloc = 32;
           goto cbKJ2;
       cbKJ2: // global
           R1 = _sbJuk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKJ4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbJuk::P64;
           _sbJuc::P64 = P64[_sbJuk::P64 + 16];
           _sbJuh::P64 = P64[_sbJuk::P64 + 24];
           I64[Hp - 24] = sat_sbJuj_info;
           P64[Hp - 8] = _sbJuc::P64;
           P64[Hp] = _sbJuh::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJul_entry() //  [R1, R2]
         { info_tbl: [(cbKJ7,
                       label: sat_sbJul_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKJ7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbKJb; else goto cbKJa;
       cbKJb: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKJa: // global
           _sbJuc::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbJuk_info;
           P64[Hp - 32] = _sbJuc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbKJf,
                       label: Data.Functor.Identity.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKJf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbKJj; else goto cbKJi;
       cbKJj: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKJi: // global
           I64[Hp - 40] = g_sbJuc_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbKIg::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto cbKJd; else goto cbKJe;
       cbKJd: // global
           I64[Hp - 8] = sat_sbJug_info;
           P64[Hp] = _cbKIg::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbKJe: // global
           I64[Hp - 8] = sat_sbJul_info;
           P64[Hp] = _cbKIg::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.151212815 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbKJU,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKJU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbKJV; else goto cbKJW;
       cbKJV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKJW: // global
           I64[Sp - 24] = block_cbKJR_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubKK0; else goto cbKJS;
       ubKK0: // global
           call _cbKJR(R1) args: 0, res: 0, upd: 0;
       cbKJS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbKJR() //  [R1]
         { info_tbl: [(cbKJR,
                       label: block_cbKJR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKJR: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.157761325 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshow_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshow_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshow_info;
         const 0;
 },
 sat_sbJut_entry() //  [R1]
         { info_tbl: [(cbKKi,
                       label: sat_sbJut_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKKi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbKKj; else goto cbKKk;
       cbKKj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKKk: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbKKl,
                       label: Data.Functor.Identity.$fShowIdentity_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKKl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbKKp; else goto cbKKo;
       cbKKp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKKo: // global
           I64[Hp - 24] = sat_sbJut_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.164449461 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowList_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowList_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowList_info;
         const 0;
 },
 sat_sbJuy_entry() //  [R1, R2]
         { info_tbl: [(cbKKI,
                       label: sat_sbJuy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKKI: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshowList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbKKL,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKKL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbKKP; else goto cbKKO;
       cbKKP: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKKO: // global
           I64[Hp - 8] = sat_sbJuy_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.170924261 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_closure" {
     Data.Functor.Identity.$fShowIdentity_closure:
         const Data.Functor.Identity.$fShowIdentity_info;
         const 0;
 },
 sat_sbJuC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKL6,
                       label: sat_sbJuC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKL6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuB_entry() //  [R1, R2]
         { info_tbl: [(cbKLe,
                       label: sat_sbJuB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKLe: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fShowIdentity_$cshow_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbJuA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbKLm,
                       label: sat_sbJuA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKLm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_entry() //  [R2]
         { info_tbl: [(cbKLq,
                       label: Data.Functor.Identity.$fShowIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKLq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbKLu; else goto cbKLt;
       cbKLu: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKLt: // global
           I64[Hp - 72] = sat_sbJuC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJuB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJuA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.181107611 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity4_closure" {
     Data.Functor.Identity.$fFoldableIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.183002978 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$clength_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$clength_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$clength_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$clength_entry() //  []
         { info_tbl: [(cbKLR,
                       label: Data.Functor.Identity.$fFoldableIdentity_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKLR: // global
           R1 = Data.Functor.Identity.$fFoldableIdentity4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.186438906 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cnull_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cnull_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cnull_entry() //  []
         { info_tbl: [(cbKM3,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKM3: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.190136096 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$ctoList_entry() //  [R2]
         { info_tbl: [(cbKMg,
                       label: Data.Functor.Identity.$fFoldableIdentity_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKMg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKMk; else goto cbKMj;
       cbKMk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKMj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.19391103 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity6_closure" {
     Data.Functor.Identity.$fFoldableIdentity6_closure:
         const Data.Functor.Identity.$fFoldableIdentity6_info;
 },
 Data.Functor.Identity.$fFoldableIdentity6_entry() //  [R2]
         { info_tbl: [(cbKMu,
                       label: Data.Functor.Identity.$fFoldableIdentity6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKMu: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.197215211 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cfoldr_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbKMF,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKMF: // global
           R3 = R3;
           _sbJuH::P64 = R2;
           R2 = R4;
           R1 = _sbJuH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.200630748 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity7_closure" {
     Data.Functor.Identity.$fFoldableIdentity7_closure:
         const Data.Functor.Identity.$fFoldableIdentity7_info;
 },
 Data.Functor.Identity.$fFoldableIdentity7_entry() //  [R3]
         { info_tbl: [(cbKMQ,
                       label: Data.Functor.Identity.$fFoldableIdentity7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKMQ: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.203872474 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity2_closure" {
     Data.Functor.Identity.$fFunctorIdentity2_closure:
         const Data.Functor.Identity.$fFunctorIdentity2_info;
 },
 Data.Functor.Identity.$fFunctorIdentity2_entry() //  [R2]
         { info_tbl: [(cbKN1,
                       label: Data.Functor.Identity.$fFunctorIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKN1: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.207095488 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity1_closure" {
     Data.Functor.Identity.$fFunctorIdentity1_closure:
         const Data.Functor.Identity.$fFunctorIdentity1_info;
 },
 Data.Functor.Identity.$fFunctorIdentity1_entry() //  [R2]
         { info_tbl: [(cbKNc,
                       label: Data.Functor.Identity.$fFunctorIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKNc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.210819545 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity_closure" {
     Data.Functor.Identity.$fFunctorIdentity_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Identity.$fFunctorIdentity2_closure+1;
         const Data.Functor.Identity.$fFunctorIdentity1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.212686058 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity1_closure" {
     Data.Functor.Identity.$fApplicativeIdentity1_closure:
         const Data.Functor.Identity.$fApplicativeIdentity1_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity1_entry() //  [R2]
         { info_tbl: [(cbKNo,
                       label: Data.Functor.Identity.$fApplicativeIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKNo: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.216488393 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity2_closure" {
     Data.Functor.Identity.$fApplicativeIdentity2_closure:
         const Data.Functor.Identity.$fApplicativeIdentity2_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity2_entry() //  [R2]
         { info_tbl: [(cbKNz,
                       label: Data.Functor.Identity.$fApplicativeIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKNz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.219868941 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity3_closure" {
     Data.Functor.Identity.$fApplicativeIdentity3_closure:
         const Data.Functor.Identity.$fApplicativeIdentity3_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity3_entry() //  [R2]
         { info_tbl: [(cbKNK,
                       label: Data.Functor.Identity.$fApplicativeIdentity3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKNK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.223169559 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure:
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry() //  [R3]
         { info_tbl: [(cbKNV,
                       label: Data.Functor.Identity.$fApplicativeIdentity_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKNV: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.226346336 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity2_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity1_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure+2;
         const GHC.Base.const_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.229333404 UTC

[section ""data" . Data.Functor.Identity.$fStorableIdentity_closure" {
     Data.Functor.Identity.$fStorableIdentity_closure:
         const Data.Functor.Identity.$fStorableIdentity_info;
 },
 sat_sbJv2_entry() //  [R1]
         { info_tbl: [(cbKOb,
                       label: sat_sbJv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOc; else goto cbKOd;
       cbKOc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv1_entry() //  [R1]
         { info_tbl: [(cbKOi,
                       label: sat_sbJv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOj; else goto cbKOk;
       cbKOj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv0_entry() //  [R1]
         { info_tbl: [(cbKOp,
                       label: sat_sbJv0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOq; else goto cbKOr;
       cbKOq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuZ_entry() //  [R1]
         { info_tbl: [(cbKOw,
                       label: sat_sbJuZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOx; else goto cbKOy;
       cbKOx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuY_entry() //  [R1]
         { info_tbl: [(cbKOD,
                       label: sat_sbJuY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOE; else goto cbKOF;
       cbKOE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuX_entry() //  [R1]
         { info_tbl: [(cbKOK,
                       label: sat_sbJuX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOL; else goto cbKOM;
       cbKOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuW_entry() //  [R1]
         { info_tbl: [(cbKOR,
                       label: sat_sbJuW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOS; else goto cbKOT;
       cbKOS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKOT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJuV_entry() //  [R1]
         { info_tbl: [(cbKOY,
                       label: sat_sbJuV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKOY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKOZ; else goto cbKP0;
       cbKOZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKP0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fStorableIdentity_entry() //  [R2]
         { info_tbl: [(cbKP2,
                       label: Data.Functor.Identity.$fStorableIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKP2: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbKP6; else goto cbKP5;
       cbKP6: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fStorableIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKP5: // global
           I64[Hp - 256] = sat_sbJv2_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJv1_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJv0_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJuZ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJuY_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJuX_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJuW_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJuV_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.250567586 UTC

[section ""data" . Data.Functor.Identity.$fNumIdentity_closure" {
     Data.Functor.Identity.$fNumIdentity_closure:
         const Data.Functor.Identity.$fNumIdentity_info;
 },
 sat_sbJva_entry() //  [R1]
         { info_tbl: [(cbKPY,
                       label: sat_sbJva_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKPY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKPZ; else goto cbKQ0;
       cbKPZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv9_entry() //  [R1]
         { info_tbl: [(cbKQ5,
                       label: sat_sbJv9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKQ6; else goto cbKQ7;
       cbKQ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv8_entry() //  [R1]
         { info_tbl: [(cbKQc,
                       label: sat_sbJv8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKQd; else goto cbKQe;
       cbKQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv7_entry() //  [R1]
         { info_tbl: [(cbKQj,
                       label: sat_sbJv7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKQk; else goto cbKQl;
       cbKQk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv6_entry() //  [R1]
         { info_tbl: [(cbKQq,
                       label: sat_sbJv6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKQr; else goto cbKQs;
       cbKQr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv5_entry() //  [R1]
         { info_tbl: [(cbKQx,
                       label: sat_sbJv5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKQy; else goto cbKQz;
       cbKQy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJv4_entry() //  [R1]
         { info_tbl: [(cbKQE,
                       label: sat_sbJv4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKQF; else goto cbKQG;
       cbKQF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fNumIdentity_entry() //  [R2]
         { info_tbl: [(cbKQI,
                       label: Data.Functor.Identity.$fNumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKQI: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbKQM; else goto cbKQL;
       cbKQM: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fNumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKQL: // global
           I64[Hp - 224] = sat_sbJva_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJv9_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJv8_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJv7_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJv6_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJv5_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJv4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.267540945 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp1Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp1Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp1Real_info;
 },
 sat_sbJvc_entry() //  [R1]
         { info_tbl: [(cbKRz,
                       label: sat_sbJvc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKRz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKRA; else goto cbKRB;
       cbKRA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKRB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp1Real_entry() //  [R2]
         { info_tbl: [(cbKRC,
                       label: Data.Functor.Identity.$fRealIdentity_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKRC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKRG; else goto cbKRF;
       cbKRG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKRF: // global
           I64[Hp - 16] = sat_sbJvc_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.273799153 UTC

[section ""data" . Data.Functor.Identity.$fSemigroupIdentity_closure" {
     Data.Functor.Identity.$fSemigroupIdentity_closure:
         const Data.Functor.Identity.$fSemigroupIdentity_info;
 },
 sat_sbJvg_entry() //  [R1]
         { info_tbl: [(cbKRX,
                       label: sat_sbJvg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKRX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKRY; else goto cbKRZ;
       cbKRY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKRZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvf_entry() //  [R1]
         { info_tbl: [(cbKS4,
                       label: sat_sbJvf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKS4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKS5; else goto cbKS6;
       cbKS5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKS6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJve_entry() //  [R1]
         { info_tbl: [(cbKSb,
                       label: sat_sbJve_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKSb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKSc; else goto cbKSd;
       cbKSc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKSd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fSemigroupIdentity_entry() //  [R2]
         { info_tbl: [(cbKSf,
                       label: Data.Functor.Identity.$fSemigroupIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKSf: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbKSj; else goto cbKSi;
       cbKSj: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fSemigroupIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKSi: // global
           I64[Hp - 96] = sat_sbJvg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJvf_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJve_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.283872234 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure" {
     Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure:
         const Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info;
 },
 sat_sbJvi_entry() //  [R1]
         { info_tbl: [(cbKSM,
                       label: sat_sbJvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKSM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKSN; else goto cbKSO;
       cbKSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKSO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cbKSP,
                       label: Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKSP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKST; else goto cbKSS;
       cbKST: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKSS: // global
           I64[Hp - 16] = sat_sbJvi_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fSemigroupIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.289847007 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_closure" {
     Data.Functor.Identity.$fMonoidIdentity_closure:
         const Data.Functor.Identity.$fMonoidIdentity_info;
 },
 sat_sbJvn_entry() //  [R1]
         { info_tbl: [(cbKTa,
                       label: sat_sbJvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKTa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKTb; else goto cbKTc;
       cbKTb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKTc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvm_entry() //  [R1]
         { info_tbl: [(cbKTh,
                       label: sat_sbJvm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKTh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKTi; else goto cbKTj;
       cbKTi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvl_entry() //  [R1]
         { info_tbl: [(cbKTo,
                       label: sat_sbJvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKTo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKTp; else goto cbKTq;
       cbKTp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKTq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvk_entry() //  [R1]
         { info_tbl: [(cbKTv,
                       label: sat_sbJvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKTv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKTw; else goto cbKTx;
       cbKTw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKTx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_entry() //  [R2]
         { info_tbl: [(cbKTz,
                       label: Data.Functor.Identity.$fMonoidIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKTz: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbKTD; else goto cbKTC;
       cbKTD: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKTC: // global
           I64[Hp - 128] = sat_sbJvn_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJvm_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJvl_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJvk_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.301305619 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity1_closure" {
     Data.Functor.Identity.$fGeneric1Identity1_closure:
         const Data.Functor.Identity.$fGeneric1Identity1_info;
 },
 Data.Functor.Identity.$fGeneric1Identity1_entry() //  [R2]
         { info_tbl: [(cbKU7,
                       label: Data.Functor.Identity.$fGeneric1Identity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKU7: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.304682319 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity2_closure" {
     Data.Functor.Identity.$fFoldableIdentity2_closure:
         const Data.Functor.Identity.$fFoldableIdentity2_info;
 },
 Data.Functor.Identity.$fFoldableIdentity2_entry() //  [R2]
         { info_tbl: [(cbKUi,
                       label: Data.Functor.Identity.$fFoldableIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKUi: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.307836381 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity_closure" {
     Data.Functor.Identity.$fGeneric1Identity_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Identity.$fFoldableIdentity2_closure+1;
         const Data.Functor.Identity.$fGeneric1Identity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.310139532 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity1_closure" {
     Data.Functor.Identity.$fGenericIdentity1_closure:
         const Data.Functor.Identity.$fGenericIdentity1_info;
 },
 Data.Functor.Identity.$fGenericIdentity1_entry() //  [R2]
         { info_tbl: [(cbKUu,
                       label: Data.Functor.Identity.$fGenericIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKUu: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.313348749 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity2_closure" {
     Data.Functor.Identity.$fGenericIdentity2_closure:
         const Data.Functor.Identity.$fGenericIdentity2_info;
 },
 Data.Functor.Identity.$fGenericIdentity2_entry() //  [R2]
         { info_tbl: [(cbKUF,
                       label: Data.Functor.Identity.$fGenericIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKUF: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.3170783 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity_closure" {
     Data.Functor.Identity.$fGenericIdentity_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Identity.$fGenericIdentity2_closure+1;
         const Data.Functor.Identity.$fGenericIdentity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.319183904 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure" {
     Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure:
         const Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info;
 },
 sat_sbJvt_entry() //  [R1]
         { info_tbl: [(cbKUV,
                       label: sat_sbJvt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKUV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKUW; else goto cbKUX;
       cbKUW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKUX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cbKUY,
                       label: Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKUY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKV2; else goto cbKV1;
       cbKV2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKV1: // global
           I64[Hp - 16] = sat_sbJvt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.326019663 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_closure" {
     Data.Functor.Identity.$fFractionalIdentity_closure:
         const Data.Functor.Identity.$fFractionalIdentity_info;
 },
 sat_sbJvy_entry() //  [R1]
         { info_tbl: [(cbKVj,
                       label: sat_sbJvy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKVj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKVk; else goto cbKVl;
       cbKVk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKVl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvx_entry() //  [R1]
         { info_tbl: [(cbKVq,
                       label: sat_sbJvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKVr; else goto cbKVs;
       cbKVr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKVs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvw_entry() //  [R1]
         { info_tbl: [(cbKVx,
                       label: sat_sbJvw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKVx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKVy; else goto cbKVz;
       cbKVy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKVz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvv_entry() //  [R1]
         { info_tbl: [(cbKVE,
                       label: sat_sbJvv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKVE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKVF; else goto cbKVG;
       cbKVF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKVG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_entry() //  [R2]
         { info_tbl: [(cbKVI,
                       label: Data.Functor.Identity.$fFractionalIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKVI: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbKVM; else goto cbKVL;
       cbKVM: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKVL: // global
           I64[Hp - 128] = sat_sbJvy_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJvx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJvw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJvv_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.33737585 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info;
 },
 sat_sbJvA_entry() //  [R1]
         { info_tbl: [(cbKWk,
                       label: sat_sbJvA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKWk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKWl; else goto cbKWm;
       cbKWl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKWm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(cbKWn,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKWn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKWr; else goto cbKWq;
       cbKWr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKWq: // global
           I64[Hp - 16] = sat_sbJvA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.343194451 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure" {
     Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure:
         const Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info;
 },
 sat_sbJvC_entry() //  [R1]
         { info_tbl: [(cbKWI,
                       label: sat_sbJvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKWI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKWJ; else goto cbKWK;
       cbKWJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKWK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cbKWL,
                       label: Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKWL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKWP; else goto cbKWO;
       cbKWP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKWO: // global
           I64[Hp - 16] = sat_sbJvC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.351444545 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_closure" {
     Data.Functor.Identity.$fFloatingIdentity_closure:
         const Data.Functor.Identity.$fFloatingIdentity_info;
 },
 sat_sbJw0_entry() //  [R1]
         { info_tbl: [(cbKX6,
                       label: sat_sbJw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKX6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKX7; else goto cbKX8;
       cbKX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvZ_entry() //  [R1]
         { info_tbl: [(cbKXd,
                       label: sat_sbJvZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXe; else goto cbKXf;
       cbKXe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvY_entry() //  [R1]
         { info_tbl: [(cbKXk,
                       label: sat_sbJvY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXl; else goto cbKXm;
       cbKXl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvX_entry() //  [R1]
         { info_tbl: [(cbKXr,
                       label: sat_sbJvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXs; else goto cbKXt;
       cbKXs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvW_entry() //  [R1]
         { info_tbl: [(cbKXy,
                       label: sat_sbJvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXz; else goto cbKXA;
       cbKXz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvV_entry() //  [R1]
         { info_tbl: [(cbKXF,
                       label: sat_sbJvV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXG; else goto cbKXH;
       cbKXG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvU_entry() //  [R1]
         { info_tbl: [(cbKXM,
                       label: sat_sbJvU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXN; else goto cbKXO;
       cbKXN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvT_entry() //  [R1]
         { info_tbl: [(cbKXT,
                       label: sat_sbJvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKXT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKXU; else goto cbKXV;
       cbKXU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKXV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvS_entry() //  [R1]
         { info_tbl: [(cbKY0,
                       label: sat_sbJvS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKY0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKY1; else goto cbKY2;
       cbKY1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKY2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvR_entry() //  [R1]
         { info_tbl: [(cbKY7,
                       label: sat_sbJvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKY7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKY8; else goto cbKY9;
       cbKY8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKY9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvQ_entry() //  [R1]
         { info_tbl: [(cbKYe,
                       label: sat_sbJvQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYf; else goto cbKYg;
       cbKYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvP_entry() //  [R1]
         { info_tbl: [(cbKYl,
                       label: sat_sbJvP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYm; else goto cbKYn;
       cbKYm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvO_entry() //  [R1]
         { info_tbl: [(cbKYs,
                       label: sat_sbJvO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYt; else goto cbKYu;
       cbKYt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvN_entry() //  [R1]
         { info_tbl: [(cbKYz,
                       label: sat_sbJvN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYA; else goto cbKYB;
       cbKYA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvM_entry() //  [R1]
         { info_tbl: [(cbKYG,
                       label: sat_sbJvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYH; else goto cbKYI;
       cbKYH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvL_entry() //  [R1]
         { info_tbl: [(cbKYN,
                       label: sat_sbJvL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYO; else goto cbKYP;
       cbKYO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvK_entry() //  [R1]
         { info_tbl: [(cbKYU,
                       label: sat_sbJvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKYU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKYV; else goto cbKYW;
       cbKYV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKYW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvJ_entry() //  [R1]
         { info_tbl: [(cbKZ1,
                       label: sat_sbJvJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKZ2; else goto cbKZ3;
       cbKZ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKZ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvI_entry() //  [R1]
         { info_tbl: [(cbKZ8,
                       label: sat_sbJvI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKZ9; else goto cbKZa;
       cbKZ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKZa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvH_entry() //  [R1]
         { info_tbl: [(cbKZf,
                       label: sat_sbJvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKZg; else goto cbKZh;
       cbKZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvG_entry() //  [R1]
         { info_tbl: [(cbKZm,
                       label: sat_sbJvG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKZn; else goto cbKZo;
       cbKZn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKZo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvF_entry() //  [R1]
         { info_tbl: [(cbKZt,
                       label: sat_sbJvF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKZu; else goto cbKZv;
       cbKZu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKZv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJvE_entry() //  [R1]
         { info_tbl: [(cbKZA,
                       label: sat_sbJvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbKZB; else goto cbKZC;
       cbKZB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKZC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_entry() //  [R2]
         { info_tbl: [(cbKZE,
                       label: Data.Functor.Identity.$fFloatingIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKZE: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbKZI; else goto cbKZH;
       cbKZI: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbKZH: // global
           I64[Hp - 736] = sat_sbJw0_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbJvZ_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbJvY_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbJvX_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbJvW_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbJvV_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbJvU_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbJvT_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbJvS_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbJvR_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbJvQ_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbJvP_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbJvO_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbJvN_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbJvM_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbJvL_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbJvK_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbJvJ_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbJvI_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbJvH_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbJvG_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJvF_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJvE_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.401175851 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info;
 },
 sat_sbJw2_entry() //  [R1]
         { info_tbl: [(cbL1N,
                       label: sat_sbJw2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL1N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL1O; else goto cbL1P;
       cbL1O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL1P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(cbL1Q,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL1Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbL1U; else goto cbL1T;
       cbL1U: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL1T: // global
           I64[Hp - 16] = sat_sbJw2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.4069912 UTC

[section ""data" . Data.Functor.Identity.$fEqIdentity_closure" {
     Data.Functor.Identity.$fEqIdentity_closure:
         const Data.Functor.Identity.$fEqIdentity_info;
 },
 sat_sbJw5_entry() //  [R1]
         { info_tbl: [(cbL2b,
                       label: sat_sbJw5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL2b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL2c; else goto cbL2d;
       cbL2c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL2d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJw4_entry() //  [R1]
         { info_tbl: [(cbL2i,
                       label: sat_sbJw4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL2j; else goto cbL2k;
       cbL2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEqIdentity_entry() //  [R2]
         { info_tbl: [(cbL2m,
                       label: Data.Functor.Identity.$fEqIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL2m: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbL2q; else goto cbL2p;
       cbL2q: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEqIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL2p: // global
           I64[Hp - 64] = sat_sbJw5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJw4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.414777445 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure" {
     Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure:
         const Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info;
 },
 sat_sbJw7_entry() //  [R1]
         { info_tbl: [(cbL2O,
                       label: sat_sbJw7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL2O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL2P; else goto cbL2Q;
       cbL2P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL2Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbL2R,
                       label: Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL2R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbL2V; else goto cbL2U;
       cbL2V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL2U: // global
           I64[Hp - 16] = sat_sbJw7_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.421064353 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_closure" {
     Data.Functor.Identity.$fOrdIdentity_closure:
         const Data.Functor.Identity.$fOrdIdentity_info;
 },
 sat_sbJwg_entry() //  [R1]
         { info_tbl: [(cbL3c,
                       label: sat_sbJwg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3d; else goto cbL3e;
       cbL3d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwf_entry() //  [R1]
         { info_tbl: [(cbL3j,
                       label: sat_sbJwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3k; else goto cbL3l;
       cbL3k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwe_entry() //  [R1]
         { info_tbl: [(cbL3q,
                       label: sat_sbJwe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3r; else goto cbL3s;
       cbL3r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwd_entry() //  [R1]
         { info_tbl: [(cbL3x,
                       label: sat_sbJwd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3y; else goto cbL3z;
       cbL3y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwc_entry() //  [R1]
         { info_tbl: [(cbL3E,
                       label: sat_sbJwc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3F; else goto cbL3G;
       cbL3F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwb_entry() //  [R1]
         { info_tbl: [(cbL3L,
                       label: sat_sbJwb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3M; else goto cbL3N;
       cbL3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwa_entry() //  [R1]
         { info_tbl: [(cbL3S,
                       label: sat_sbJwa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL3T; else goto cbL3U;
       cbL3T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL3U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJw9_entry() //  [R1]
         { info_tbl: [(cbL3Z,
                       label: sat_sbJw9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL3Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL40; else goto cbL41;
       cbL40: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL41: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_entry() //  [R2]
         { info_tbl: [(cbL43,
                       label: Data.Functor.Identity.$fOrdIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL43: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbL47; else goto cbL46;
       cbL47: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL46: // global
           I64[Hp - 256] = sat_sbJwg_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJwf_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJwe_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJwd_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJwc_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJwb_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJwa_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJw9_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.440376073 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure" {
     Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure:
         const Data.Functor.Identity.$fIxIdentity_$cp1Ix_info;
 },
 sat_sbJwi_entry() //  [R1]
         { info_tbl: [(cbL4Z,
                       label: sat_sbJwi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL4Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL50; else goto cbL51;
       cbL50: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL51: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry() //  [R2]
         { info_tbl: [(cbL52,
                       label: Data.Functor.Identity.$fIxIdentity_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL52: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbL56; else goto cbL55;
       cbL56: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL55: // global
           I64[Hp - 16] = sat_sbJwi_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.446647721 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_closure" {
     Data.Functor.Identity.$fIxIdentity_closure:
         const Data.Functor.Identity.$fIxIdentity_info;
 },
 sat_sbJwq_entry() //  [R1]
         { info_tbl: [(cbL5n,
                       label: sat_sbJwq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL5n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL5o; else goto cbL5p;
       cbL5o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL5p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwp_entry() //  [R1]
         { info_tbl: [(cbL5u,
                       label: sat_sbJwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL5u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL5v; else goto cbL5w;
       cbL5v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL5w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwo_entry() //  [R1]
         { info_tbl: [(cbL5B,
                       label: sat_sbJwo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL5B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL5C; else goto cbL5D;
       cbL5C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL5D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwn_entry() //  [R1]
         { info_tbl: [(cbL5I,
                       label: sat_sbJwn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL5I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL5J; else goto cbL5K;
       cbL5J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL5K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwm_entry() //  [R1]
         { info_tbl: [(cbL5P,
                       label: sat_sbJwm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL5P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL5Q; else goto cbL5R;
       cbL5Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL5R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwl_entry() //  [R1]
         { info_tbl: [(cbL5W,
                       label: sat_sbJwl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL5W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL5X; else goto cbL5Y;
       cbL5X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL5Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwk_entry() //  [R1]
         { info_tbl: [(cbL63,
                       label: sat_sbJwk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL63: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL64; else goto cbL65;
       cbL64: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL65: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_entry() //  [R2]
         { info_tbl: [(cbL67,
                       label: Data.Functor.Identity.$fIxIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL67: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbL6b; else goto cbL6a;
       cbL6b: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL6a: // global
           I64[Hp - 224] = sat_sbJwq_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwp_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwo_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwn_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJwm_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJwl_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJwk_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.464030567 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp2Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp2Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp2Real_info;
 },
 sat_sbJws_entry() //  [R1]
         { info_tbl: [(cbL6Y,
                       label: sat_sbJws_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL6Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL6Z; else goto cbL70;
       cbL6Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL70: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp2Real_entry() //  [R2]
         { info_tbl: [(cbL71,
                       label: Data.Functor.Identity.$fRealIdentity_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL71: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbL75; else goto cbL74;
       cbL75: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL74: // global
           I64[Hp - 16] = sat_sbJws_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.470379462 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_closure" {
     Data.Functor.Identity.$fRealIdentity_closure:
         const Data.Functor.Identity.$fRealIdentity_info;
 },
 sat_sbJww_entry() //  [R1]
         { info_tbl: [(cbL7m,
                       label: sat_sbJww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL7m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL7n; else goto cbL7o;
       cbL7n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL7o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwv_entry() //  [R1]
         { info_tbl: [(cbL7t,
                       label: sat_sbJwv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL7u; else goto cbL7v;
       cbL7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwu_entry() //  [R1]
         { info_tbl: [(cbL7A,
                       label: sat_sbJwu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL7B; else goto cbL7C;
       cbL7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_entry() //  [R2]
         { info_tbl: [(cbL7E,
                       label: Data.Functor.Identity.$fRealIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL7E: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbL7I; else goto cbL7H;
       cbL7I: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL7H: // global
           I64[Hp - 96] = sat_sbJww_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbJwv_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbJwu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.480272343 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info;
 },
 sat_sbJwy_entry() //  [R1]
         { info_tbl: [(cbL8b,
                       label: sat_sbJwy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL8b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL8c; else goto cbL8d;
       cbL8c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL8d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry() //  [R2]
         { info_tbl: [(cbL8e,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL8e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbL8i; else goto cbL8h;
       cbL8i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL8h: // global
           I64[Hp - 16] = sat_sbJwy_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.486230711 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info;
 },
 sat_sbJwA_entry() //  [R1]
         { info_tbl: [(cbL8z,
                       label: sat_sbJwA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL8z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL8A; else goto cbL8B;
       cbL8A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL8B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(cbL8C,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL8C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbL8G; else goto cbL8F;
       cbL8G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL8F: // global
           I64[Hp - 16] = sat_sbJwA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.492455606 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_closure" {
     Data.Functor.Identity.$fRealFracIdentity_closure:
         const Data.Functor.Identity.$fRealFracIdentity_info;
 },
 sat_sbJwI_entry() //  [R1]
         { info_tbl: [(cbL8X,
                       label: sat_sbJwI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL8X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL8Y; else goto cbL8Z;
       cbL8Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL8Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwH_entry() //  [R1]
         { info_tbl: [(cbL94,
                       label: sat_sbJwH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL94: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL95; else goto cbL96;
       cbL95: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL96: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwG_entry() //  [R1]
         { info_tbl: [(cbL9b,
                       label: sat_sbJwG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL9b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL9c; else goto cbL9d;
       cbL9c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL9d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwF_entry() //  [R1]
         { info_tbl: [(cbL9i,
                       label: sat_sbJwF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL9i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL9j; else goto cbL9k;
       cbL9j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL9k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwE_entry() //  [R1]
         { info_tbl: [(cbL9p,
                       label: sat_sbJwE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL9p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL9q; else goto cbL9r;
       cbL9q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL9r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwD_entry() //  [R1]
         { info_tbl: [(cbL9w,
                       label: sat_sbJwD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL9w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL9x; else goto cbL9y;
       cbL9x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL9y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwC_entry() //  [R1]
         { info_tbl: [(cbL9D,
                       label: sat_sbJwC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL9D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbL9E; else goto cbL9F;
       cbL9E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbL9F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_entry() //  [R2]
         { info_tbl: [(cbL9H,
                       label: Data.Functor.Identity.$fRealFracIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbL9H: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbL9L; else goto cbL9K;
       cbL9L: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbL9K: // global
           I64[Hp - 224] = sat_sbJwI_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwH_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwG_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwF_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbJwE_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJwD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJwC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.509280303 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info;
 },
 sat_sbJwK_entry() //  [R1]
         { info_tbl: [(cbLay,
                       label: sat_sbJwK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLay: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLaz; else goto cbLaA;
       cbLaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLaA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(cbLaB,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLaB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLaF; else goto cbLaE;
       cbLaF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLaE: // global
           I64[Hp - 16] = sat_sbJwK_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.516998355 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_info;
 },
 sat_sbJx1_entry() //  [R1]
         { info_tbl: [(cbLaW,
                       label: sat_sbJx1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLaW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLaX; else goto cbLaY;
       cbLaX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLaY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx0_entry() //  [R1]
         { info_tbl: [(cbLb3,
                       label: sat_sbJx0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLb3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLb4; else goto cbLb5;
       cbLb4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLb5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwZ_entry() //  [R1]
         { info_tbl: [(cbLba,
                       label: sat_sbJwZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLba: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbb; else goto cbLbc;
       cbLbb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwY_entry() //  [R1]
         { info_tbl: [(cbLbh,
                       label: sat_sbJwY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbi; else goto cbLbj;
       cbLbi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwX_entry() //  [R1]
         { info_tbl: [(cbLbo,
                       label: sat_sbJwX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbp; else goto cbLbq;
       cbLbp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwW_entry() //  [R1]
         { info_tbl: [(cbLbv,
                       label: sat_sbJwW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbw; else goto cbLbx;
       cbLbw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwV_entry() //  [R1]
         { info_tbl: [(cbLbC,
                       label: sat_sbJwV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbD; else goto cbLbE;
       cbLbD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwU_entry() //  [R1]
         { info_tbl: [(cbLbJ,
                       label: sat_sbJwU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbK; else goto cbLbL;
       cbLbK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwT_entry() //  [R1]
         { info_tbl: [(cbLbQ,
                       label: sat_sbJwT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbR; else goto cbLbS;
       cbLbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwS_entry() //  [R1]
         { info_tbl: [(cbLbX,
                       label: sat_sbJwS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLbX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLbY; else goto cbLbZ;
       cbLbY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLbZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwR_entry() //  [R1]
         { info_tbl: [(cbLc4,
                       label: sat_sbJwR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLc4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLc5; else goto cbLc6;
       cbLc5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLc6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwQ_entry() //  [R1]
         { info_tbl: [(cbLcb,
                       label: sat_sbJwQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLcb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLcc; else goto cbLcd;
       cbLcc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLcd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwP_entry() //  [R1]
         { info_tbl: [(cbLci,
                       label: sat_sbJwP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLci: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLcj; else goto cbLck;
       cbLcj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLck: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwO_entry() //  [R1]
         { info_tbl: [(cbLcp,
                       label: sat_sbJwO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLcq; else goto cbLcr;
       cbLcq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLcr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwN_entry() //  [R1]
         { info_tbl: [(cbLcw,
                       label: sat_sbJwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLcw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLcx; else goto cbLcy;
       cbLcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLcy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJwM_entry() //  [R1]
         { info_tbl: [(cbLcD,
                       label: sat_sbJwM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLcD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLcE; else goto cbLcF;
       cbLcE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLcF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_entry() //  [R2]
         { info_tbl: [(cbLcH,
                       label: Data.Functor.Identity.$fRealFloatIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLcH: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cbLcL; else goto cbLcK;
       cbLcL: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLcK: // global
           I64[Hp - 512] = sat_sbJx1_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_sbJx0_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sbJwZ_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_sbJwY_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sbJwX_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_sbJwW_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sbJwV_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_sbJwU_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sbJwT_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_sbJwS_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sbJwR_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_sbJwQ_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sbJwP_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbJwO_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbJwN_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbJwM_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.551761127 UTC

[section ""data" . Data.Functor.Identity.$fEnumIdentity_closure" {
     Data.Functor.Identity.$fEnumIdentity_closure:
         const Data.Functor.Identity.$fEnumIdentity_info;
 },
 sat_sbJxa_entry() //  [R1]
         { info_tbl: [(cbLeh,
                       label: sat_sbJxa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLeh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLei; else goto cbLej;
       cbLei: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLej: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx9_entry() //  [R1]
         { info_tbl: [(cbLeo,
                       label: sat_sbJx9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLeo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLep; else goto cbLeq;
       cbLep: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLeq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx8_entry() //  [R1]
         { info_tbl: [(cbLev,
                       label: sat_sbJx8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLev: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLew; else goto cbLex;
       cbLew: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLex: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx7_entry() //  [R1]
         { info_tbl: [(cbLeC,
                       label: sat_sbJx7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLeC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLeD; else goto cbLeE;
       cbLeD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLeE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx6_entry() //  [R1]
         { info_tbl: [(cbLeJ,
                       label: sat_sbJx6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLeJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLeK; else goto cbLeL;
       cbLeK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLeL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx5_entry() //  [R1]
         { info_tbl: [(cbLeQ,
                       label: sat_sbJx5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLeQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLeR; else goto cbLeS;
       cbLeR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLeS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx4_entry() //  [R1]
         { info_tbl: [(cbLeX,
                       label: sat_sbJx4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLeX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLeY; else goto cbLeZ;
       cbLeY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLeZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJx3_entry() //  [R1]
         { info_tbl: [(cbLf4,
                       label: sat_sbJx3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLf4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLf5; else goto cbLf6;
       cbLf5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLf6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEnumIdentity_entry() //  [R2]
         { info_tbl: [(cbLf8,
                       label: Data.Functor.Identity.$fEnumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLf8: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbLfc; else goto cbLfb;
       cbLfc: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEnumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLfb: // global
           I64[Hp - 256] = sat_sbJxa_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJx9_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJx8_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbJx7_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbJx6_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbJx5_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbJx4_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbJx3_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.571750869 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info;
 },
 sat_sbJxc_entry() //  [R1]
         { info_tbl: [(cbLg4,
                       label: sat_sbJxc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLg4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLg5; else goto cbLg6;
       cbLg5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLg6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry() //  [R2]
         { info_tbl: [(cbLg7,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLg7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLgb; else goto cbLga;
       cbLgb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLga: // global
           I64[Hp - 16] = sat_sbJxc_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEnumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.578667314 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_closure" {
     Data.Functor.Identity.$fIntegralIdentity_closure:
         const Data.Functor.Identity.$fIntegralIdentity_info;
 },
 sat_sbJxm_entry() //  [R1]
         { info_tbl: [(cbLgs,
                       label: sat_sbJxm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLgs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLgt; else goto cbLgu;
       cbLgt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLgu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxl_entry() //  [R1]
         { info_tbl: [(cbLgz,
                       label: sat_sbJxl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLgz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLgA; else goto cbLgB;
       cbLgA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxk_entry() //  [R1]
         { info_tbl: [(cbLgG,
                       label: sat_sbJxk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLgG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLgH; else goto cbLgI;
       cbLgH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLgI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxj_entry() //  [R1]
         { info_tbl: [(cbLgN,
                       label: sat_sbJxj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLgN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLgO; else goto cbLgP;
       cbLgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLgP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxi_entry() //  [R1]
         { info_tbl: [(cbLgU,
                       label: sat_sbJxi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLgU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLgV; else goto cbLgW;
       cbLgV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLgW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxh_entry() //  [R1]
         { info_tbl: [(cbLh1,
                       label: sat_sbJxh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLh1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLh2; else goto cbLh3;
       cbLh2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLh3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxg_entry() //  [R1]
         { info_tbl: [(cbLh8,
                       label: sat_sbJxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLh9; else goto cbLha;
       cbLh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLha: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxf_entry() //  [R1]
         { info_tbl: [(cbLhf,
                       label: sat_sbJxf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLhf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLhg; else goto cbLhh;
       cbLhg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLhh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxe_entry() //  [R1]
         { info_tbl: [(cbLhm,
                       label: sat_sbJxe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLhm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLhn; else goto cbLho;
       cbLhn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLho: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_entry() //  [R2]
         { info_tbl: [(cbLhq,
                       label: Data.Functor.Identity.$fIntegralIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLhq: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto cbLhu; else goto cbLht;
       cbLhu: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLht: // global
           I64[Hp - 288] = sat_sbJxm_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_sbJxl_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sbJxk_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_sbJxj_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_sbJxi_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbJxh_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbJxg_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbJxf_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbJxe_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.600470813 UTC

[section ""data" . Data.Functor.Identity.$fBoundedIdentity_closure" {
     Data.Functor.Identity.$fBoundedIdentity_closure:
         const Data.Functor.Identity.$fBoundedIdentity_info;
 },
 sat_sbJxp_entry() //  [R1]
         { info_tbl: [(cbLir,
                       label: sat_sbJxp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLir: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLis; else goto cbLit;
       cbLis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxo_entry() //  [R1]
         { info_tbl: [(cbLiy,
                       label: sat_sbJxo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLiy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLiz; else goto cbLiA;
       cbLiz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLiA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBoundedIdentity_entry() //  [R2]
         { info_tbl: [(cbLiC,
                       label: Data.Functor.Identity.$fBoundedIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLiC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbLiG; else goto cbLiF;
       cbLiG: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBoundedIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLiF: // global
           I64[Hp - 64] = sat_sbJxp_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbJxo_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.608835346 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure" {
     Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure:
         const Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info;
 },
 sat_sbJxr_entry() //  [R1]
         { info_tbl: [(cbLj4,
                       label: sat_sbJxr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLj4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLj5; else goto cbLj6;
       cbLj5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLj6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry() //  [R2]
         { info_tbl: [(cbLj7,
                       label: Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLj7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLjb; else goto cbLja;
       cbLjb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLja: // global
           I64[Hp - 16] = sat_sbJxr_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.617011343 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_closure" {
     Data.Functor.Identity.$fBitsIdentity_closure:
         const Data.Functor.Identity.$fBitsIdentity_info;
 },
 sat_sbJxP_entry() //  [R1]
         { info_tbl: [(cbLjs,
                       label: sat_sbJxP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLjs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLjt; else goto cbLju;
       cbLjt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLju: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxO_entry() //  [R1]
         { info_tbl: [(cbLjz,
                       label: sat_sbJxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLjz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLjA; else goto cbLjB;
       cbLjA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLjB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxN_entry() //  [R1]
         { info_tbl: [(cbLjG,
                       label: sat_sbJxN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLjG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLjH; else goto cbLjI;
       cbLjH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLjI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxM_entry() //  [R1]
         { info_tbl: [(cbLjN,
                       label: sat_sbJxM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLjO; else goto cbLjP;
       cbLjO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLjP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxL_entry() //  [R1]
         { info_tbl: [(cbLjU,
                       label: sat_sbJxL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLjU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLjV; else goto cbLjW;
       cbLjV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLjW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxK_entry() //  [R1]
         { info_tbl: [(cbLk1,
                       label: sat_sbJxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLk1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLk2; else goto cbLk3;
       cbLk2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLk3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxJ_entry() //  [R1]
         { info_tbl: [(cbLk8,
                       label: sat_sbJxJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLk8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLk9; else goto cbLka;
       cbLk9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLka: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxI_entry() //  [R1]
         { info_tbl: [(cbLkf,
                       label: sat_sbJxI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLkg; else goto cbLkh;
       cbLkg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLkh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxH_entry() //  [R1]
         { info_tbl: [(cbLkm,
                       label: sat_sbJxH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLkn; else goto cbLko;
       cbLkn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLko: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxG_entry() //  [R1]
         { info_tbl: [(cbLkt,
                       label: sat_sbJxG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLku; else goto cbLkv;
       cbLku: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLkv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxF_entry() //  [R1]
         { info_tbl: [(cbLkA,
                       label: sat_sbJxF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLkB; else goto cbLkC;
       cbLkB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLkC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxE_entry() //  [R1]
         { info_tbl: [(cbLkH,
                       label: sat_sbJxE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLkI; else goto cbLkJ;
       cbLkI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxD_entry() //  [R1]
         { info_tbl: [(cbLkO,
                       label: sat_sbJxD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLkP; else goto cbLkQ;
       cbLkP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLkQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxC_entry() //  [R1]
         { info_tbl: [(cbLkV,
                       label: sat_sbJxC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLkV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLkW; else goto cbLkX;
       cbLkW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLkX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxB_entry() //  [R1]
         { info_tbl: [(cbLl2,
                       label: sat_sbJxB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLl2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLl3; else goto cbLl4;
       cbLl3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLl4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxA_entry() //  [R1]
         { info_tbl: [(cbLl9,
                       label: sat_sbJxA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLl9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLla; else goto cbLlb;
       cbLla: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxz_entry() //  [R1]
         { info_tbl: [(cbLlg,
                       label: sat_sbJxz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLlg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlh; else goto cbLli;
       cbLlh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLli: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxy_entry() //  [R1]
         { info_tbl: [(cbLln,
                       label: sat_sbJxy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLln: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlo; else goto cbLlp;
       cbLlo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxx_entry() //  [R1]
         { info_tbl: [(cbLlu,
                       label: sat_sbJxx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLlu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlv; else goto cbLlw;
       cbLlv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxw_entry() //  [R1]
         { info_tbl: [(cbLlB,
                       label: sat_sbJxw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLlB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlC; else goto cbLlD;
       cbLlC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxv_entry() //  [R1]
         { info_tbl: [(cbLlI,
                       label: sat_sbJxv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLlI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlJ; else goto cbLlK;
       cbLlJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxu_entry() //  [R1]
         { info_tbl: [(cbLlP,
                       label: sat_sbJxu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLlP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlQ; else goto cbLlR;
       cbLlQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxt_entry() //  [R1]
         { info_tbl: [(cbLlW,
                       label: sat_sbJxt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLlW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLlX; else goto cbLlY;
       cbLlX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLlY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbLm0,
                       label: Data.Functor.Identity.$fBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLm0: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbLm4; else goto cbLm3;
       cbLm4: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLm3: // global
           I64[Hp - 736] = sat_sbJxP_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbJxO_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbJxN_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbJxM_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbJxL_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbJxK_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbJxJ_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbJxI_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbJxH_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbJxG_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbJxF_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbJxE_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbJxD_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbJxC_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbJxB_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbJxA_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbJxz_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbJxy_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbJxx_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbJxw_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbJxv_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbJxu_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbJxt_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.665086357 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info;
 },
 sat_sbJxR_entry() //  [R1]
         { info_tbl: [(cbLo9,
                       label: sat_sbJxR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLo9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLoa; else goto cbLob;
       cbLoa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(cbLoc,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLoc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLog; else goto cbLof;
       cbLog: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLof: // global
           I64[Hp - 16] = sat_sbJxR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fBitsIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.671393256 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_info;
 },
 sat_sbJxW_entry() //  [R1]
         { info_tbl: [(cbLox,
                       label: sat_sbJxW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLoy; else goto cbLoz;
       cbLoy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLoz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxV_entry() //  [R1]
         { info_tbl: [(cbLoE,
                       label: sat_sbJxV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLoE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLoF; else goto cbLoG;
       cbLoF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLoG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxU_entry() //  [R1]
         { info_tbl: [(cbLoL,
                       label: sat_sbJxU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLoL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLoM; else goto cbLoN;
       cbLoM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLoN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbJxT_entry() //  [R1]
         { info_tbl: [(cbLoS,
                       label: sat_sbJxT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLoS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLoT; else goto cbLoU;
       cbLoT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLoU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbLoW,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLoW: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbLp0; else goto cbLoZ;
       cbLp0: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLoZ: // global
           I64[Hp - 128] = sat_sbJxW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbJxV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbJxU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbJxT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.683329887 UTC

[section ""data" . Data.Functor.Identity.runIdentity_closure" {
     Data.Functor.Identity.runIdentity_closure:
         const Data.Functor.Identity.runIdentity_info;
 },
 Data.Functor.Identity.runIdentity_entry() //  [R2]
         { info_tbl: [(cbLpu,
                       label: Data.Functor.Identity.runIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLpu: // global
           R2 = R2;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.68680002 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure:
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info;
 },
 Data.Functor.Identity.$fMonadFixIdentity_$cmfix_entry() //  [R2]
         { info_tbl: [(cbLpG,
                       label: Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLpG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbLpK; else goto cbLpJ;
       cbLpK: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLpJ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbLpF::P64 = Hp - 24;
           P64[Hp] = _cbLpF::P64;
           R1 = _cbLpF::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.690687934 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>=_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>=_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbLpT,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLpT: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.694338059 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>_entry() //  [R2, R3]
         { info_tbl: [(cbLq4,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLq4: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.69769707 UTC

[section ""data" . lvl_rbJt6_closure" {
     lvl_rbJt6_closure:
         const lvl_rbJt6_info;
         const 0;
 },
 lvl_rbJt6_entry() //  [R2]
         { info_tbl: [(cbLqf,
                       label: lvl_rbJt6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLqf: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.700854525 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_closure" {
     Data.Functor.Identity.$fMonadIdentity_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Functor.Identity.$fApplicativeIdentity_closure+1;
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_closure+2;
         const Data.Functor.Identity.$fMonadIdentity_$c>>_closure+2;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const lvl_rbJt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.702719742 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure+1;
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.704589432 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity5_closure" {
     Data.Functor.Identity.$fFoldableIdentity5_closure:
         const Data.Functor.Identity.$fFoldableIdentity5_info;
 },
 Data.Functor.Identity.$fFoldableIdentity5_entry() //  [R3]
         { info_tbl: [(cbLqs,
                       label: Data.Functor.Identity.$fFoldableIdentity5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLqs: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.708665124 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity3_closure" {
     Data.Functor.Identity.$fFoldableIdentity3_closure:
         const Data.Functor.Identity.$fFoldableIdentity3_info;
 },
 Data.Functor.Identity.$fFoldableIdentity3_entry() //  [R3]
         { info_tbl: [(cbLqD,
                       label: Data.Functor.Identity.$fFoldableIdentity3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLqD: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.712365938 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity1_closure" {
     Data.Functor.Identity.$fFoldableIdentity1_closure:
         const Data.Functor.Identity.$fFoldableIdentity1_info;
 },
 Data.Functor.Identity.$fFoldableIdentity1_entry() //  [R3]
         { info_tbl: [(cbLqO,
                       label: Data.Functor.Identity.$fFoldableIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLqO: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.715781449 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity8_closure" {
     Data.Functor.Identity.$fFoldableIdentity8_closure:
         const Data.Functor.Identity.$fFoldableIdentity8_info;
 },
 Data.Functor.Identity.$fFoldableIdentity8_entry() //  [R3]
         { info_tbl: [(cbLqZ,
                       label: Data.Functor.Identity.$fFoldableIdentity8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLqZ: // global
           R2 = R3;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.718966719 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_closure" {
     Data.Functor.Identity.$fFoldableIdentity_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Identity.$fFoldableIdentity8_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity7_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$clength_closure+1;
         const GHC.Classes.==_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.721159338 UTC

[section ""cstring" . Data.Functor.Identity.$trModule4_bytes" {
     Data.Functor.Identity.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.722906029 UTC

[section ""data" . Data.Functor.Identity.$trModule3_closure" {
     Data.Functor.Identity.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.72466382 UTC

[section ""cstring" . Data.Functor.Identity.$trModule2_bytes" {
     Data.Functor.Identity.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.726846553 UTC

[section ""data" . Data.Functor.Identity.$trModule1_closure" {
     Data.Functor.Identity.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.728495311 UTC

[section ""data" . Data.Functor.Identity.$trModule_closure" {
     Data.Functor.Identity.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Identity.$trModule3_closure+1;
         const Data.Functor.Identity.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.730272548 UTC

[section ""data" . $krep_rbJt7_closure" {
     $krep_rbJt7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.732028022 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity1_closure" {
     Data.Functor.Identity.$tcIdentity1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$fReadIdentity6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.733813153 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity_closure" {
     Data.Functor.Identity.$tcIdentity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tcIdentity1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 3410104521590905987;
         const 16392070908630191652;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.736255753 UTC

[section ""data" . $krep1_rbJt8_closure" {
     $krep1_rbJt8_closure:
         const :_con_info;
         const $krep_rbJt7_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.738051216 UTC

[section ""data" . $krep2_rbJt9_closure" {
     $krep2_rbJt9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Identity.$tcIdentity_closure+1;
         const $krep1_rbJt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.739766076 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity1_closure" {
     Data.Functor.Identity.$tc'Identity1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbJt7_closure+2;
         const $krep2_rbJt9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.741992415 UTC

[section ""cstring" . Data.Functor.Identity.$tc'Identity3_bytes" {
     Data.Functor.Identity.$tc'Identity3_bytes:
         I8[] [39,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.743758628 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity2_closure" {
     Data.Functor.Identity.$tc'Identity2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$tc'Identity3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.745559524 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity_closure" {
     Data.Functor.Identity.$tc'Identity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tc'Identity2_closure+1;
         const Data.Functor.Identity.$tc'Identity1_closure+4;
         const 11920310844698764515;
         const 3935129235072617509;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:36.747397296 UTC

[section ""relreadonly" . SbJA1_srt" {
     SbJA1_srt:
         const Data.Functor.Identity.$fReadIdentity5_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Identity.$w$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity3_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadList_closure;
         const Data.Functor.Identity.$w$creadListPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_closure;
         const Data.Functor.Identity.$fShowIdentity1_closure;
         const Data.Functor.Identity.$w$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshow_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
         const Data.Functor.Identity.$fShowIdentity_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.768344322 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:38.769495736 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity4_closure" {
     Data.Functor.Identity.$fReadIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.77127081 UTC

[section ""cstring" . Data.Functor.Identity.$fReadIdentity6_bytes" {
     Data.Functor.Identity.$fReadIdentity6_bytes:
         I8[] [73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.773332956 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity5_closure" {
     Data.Functor.Identity.$fReadIdentity5_closure:
         const Data.Functor.Identity.$fReadIdentity5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity5_entry() //  [R1]
         { info_tbl: [(cbLwp,
                       label: Data.Functor.Identity.$fReadIdentity5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLwp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLwq; else goto cbLwr;
       cbLwq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLwr: // global
           (_cbLwm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbLwm::I64 == 0) goto cbLwo; else goto cbLwn;
       cbLwo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbLwn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbLwm::I64;
           R2 = Data.Functor.Identity.$fReadIdentity6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.779144231 UTC

[section ""data" . Data.Functor.Identity.$w$creadsPrec_closure" {
     Data.Functor.Identity.$w$creadsPrec_closure:
         const Data.Functor.Identity.$w$creadsPrec_info;
         const 0;
 },
 go1_sbLrz_entry() //  [R1, R2]
         { info_tbl: [(cbLxc,
                       label: go1_sbLrz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLxc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbLxd; else goto cbLxe;
       cbLxd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLxe: // global
           I64[Sp - 24] = block_cbLx5_info;
           _sbLrz::P64 = R1;
           _sbLry::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sbLry::P64;
           P64[Sp - 8] = _sbLrz::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubLxw; else goto cbLx6;
       ubLxw: // global
           call _cbLx5(R1) args: 0, res: 0, upd: 0;
       cbLx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLx5() //  [R1]
         { info_tbl: [(cbLx5,
                       label: block_cbLx5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLx5: // global
           if (R1 & 7 == 1) goto cbLx9; else goto cbLxa;
       cbLx9: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbLxa: // global
           I64[Sp] = block_cbLxk_info;
           _sbLrD::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbLrD::P64;
           if (R1 & 7 != 0) goto ubLxv; else goto cbLxl;
       ubLxv: // global
           call _cbLxk(R1) args: 0, res: 0, upd: 0;
       cbLxl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLxk() //  [R1]
         { info_tbl: [(cbLxk,
                       label: block_cbLxk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLxk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbLxu; else goto cbLxt;
       cbLxu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbLxt: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sbLrp_entry() //  [R1, R2]
         { info_tbl: [(cbLxB,
                       label: go_sbLrp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLxB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbLxC; else goto ubLxW;
       cbLxC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubLxW: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbLwG() args: 0, res: 0, upd: 0;
     }
 },
 _cbLwG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLwG: // global
           _sbLrm::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cbLwJ_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbLrm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubLxY; else goto cbLwK;
       ubLxY: // global
           call _cbLwJ(R1) args: 0, res: 0, upd: 0;
       cbLwK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLwJ() //  [R1]
         { info_tbl: [(cbLwJ,
                       label: block_cbLwJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLwJ: // global
           if (R1 & 7 == 1) goto cbLxy; else goto cbLxz;
       cbLxy: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbLxz: // global
           I64[Sp - 8] = block_cbLwP_info;
           _sbLrt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbLrt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubLxZ; else goto cbLwQ;
       ubLxZ: // global
           call _cbLwP(R1) args: 0, res: 0, upd: 0;
       cbLwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLwP() //  [R1]
         { info_tbl: [(cbLwP,
                       label: block_cbLwP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLwP: // global
           I64[Sp - 8] = block_cbLwU_info;
           R3 = Data.Functor.Identity.$fReadIdentity5_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbLwU() //  [R1]
         { info_tbl: [(cbLwU,
                       label: block_cbLwU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLwU: // global
           _sbLrt::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbLxL; else goto cbLxN;
       cbLxL: // global
           P64[Sp + 32] = _sbLrt::P64;
           Sp = Sp + 24;
           call _cbLwG() args: 0, res: 0, upd: 0;
       cbLxN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbLxQ; else goto cbLxP;
       cbLxQ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbLxP: // global
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbLrt::P64;
           I64[Hp - 8] = go1_sbLrz_info;
           P64[Hp] = Hp - 40;
           I64[Sp + 24] = block_cbLxM_info;
           R2 = P64[Sp + 32];
           I64[Sp] = stg_ap_pp_info;
           _sbLrw::P64 = P64[Sp + 8];
           P64[Sp + 8] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp + 16] = _sbLrw::P64;
           P64[Sp + 32] = Hp - 7;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbLxM() //  [R1]
         { info_tbl: [(cbLxM,
                       label: block_cbLxM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLxM: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbLrz_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLrO_entry() //  [R1, R2]
         { info_tbl: [(cbLy9,
                       label: sat_sbLrO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLy9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLya; else goto cbLyb;
       cbLya: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLyb: // global
           I64[Sp - 16] = block_cbLy7_info;
           R3 = R2;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbLy7() //  [R1]
         { info_tbl: [(cbLy7,
                       label: block_cbLy7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLy7: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sbLrp_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbLyh,
                       label: Data.Functor.Identity.$w$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLyh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbLyl; else goto cbLyk;
       cbLyl: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLyk: // global
           I64[Hp - 24] = go_sbLrp_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbLrO_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           _sbLrL::P64 = I64[(%MO_S_Gt_W64(R3,
                                           10) << 3) + GHC.Types.Bool_closure_tbl];
           R3 = Hp - 7;
           R2 = _sbLrL::P64;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.807171724 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbLzO,
                       label: Data.Functor.Identity.$fReadIdentity_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLzO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbLzP; else goto cbLzQ;
       cbLzP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLzQ: // global
           I64[Sp - 24] = block_cbLzL_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubLzU; else goto cbLzM;
       ubLzU: // global
           call _cbLzL(R1) args: 0, res: 0, upd: 0;
       cbLzM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLzL() //  [R1]
         { info_tbl: [(cbLzL,
                       label: block_cbLzL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLzL: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$creadsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.81310942 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity3_closure" {
     Data.Functor.Identity.$fReadIdentity3_closure:
         const Data.Functor.Identity.$fReadIdentity3_info;
         const 0;
 },
 sat_sbLrX_entry() //  [R1, R2]
         { info_tbl: [(cbLAe,
                       label: sat_sbLrX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLAe: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbLAk,
                       label: Data.Functor.Identity.$fReadIdentity3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLAk: // global
           _sbLrW::P64 = R4;
           _sbLrV::P64 = R3;
           _sbLrU::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbLAl; else goto cbLAm;
       cbLAm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLAo; else goto cbLAn;
       cbLAo: // global
           HpAlloc = 24;
           goto cbLAl;
       cbLAl: // global
           R4 = _sbLrW::P64;
           R3 = _sbLrV::P64;
           R2 = _sbLrU::P64;
           R1 = Data.Functor.Identity.$fReadIdentity3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLAn: // global
           I64[Hp - 16] = sat_sbLrX_info;
           P64[Hp - 8] = _sbLrU::P64;
           P64[Hp] = _sbLrV::P64;
           I64[Sp - 8] = block_cbLAh_info;
           R3 = _sbLrW::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbLAh() //  [R1]
         { info_tbl: [(cbLAh,
                       label: block_cbLAh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLAh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbLAr; else goto cbLAq;
       cbLAr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbLAq: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.82036725 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity2_closure" {
     Data.Functor.Identity.$fReadIdentity2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.822506897 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_$creadList_closure" {
     Data.Functor.Identity.$fReadIdentity_$creadList_closure:
         const Data.Functor.Identity.$fReadIdentity_$creadList_info;
         const 0;
 },
 sat_sbLs1_entry() //  [R1, R2, R3]
         { info_tbl: [(cbLAV,
                       label: sat_sbLs1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLAV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLs2_entry() //  [R1]
         { info_tbl: [(cbLAY,
                       label: sat_sbLs2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLAY: // global
           _sbLs2::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbLAZ; else goto cbLB0;
       cbLB0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbLB2; else goto cbLB1;
       cbLB2: // global
           HpAlloc = 16;
           goto cbLAZ;
       cbLAZ: // global
           R1 = _sbLs2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLB1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbLs2::P64;
           _sbLs0::P64 = P64[_sbLs2::P64 + 16];
           I64[Hp - 8] = sat_sbLs1_info;
           P64[Hp] = _sbLs0::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fReadIdentity_$creadList_entry() //  [R2]
         { info_tbl: [(cbLB3,
                       label: Data.Functor.Identity.$fReadIdentity_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLB3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLB7; else goto cbLB6;
       cbLB7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLB6: // global
           I64[Hp - 16] = sat_sbLs2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.832864049 UTC

[section ""data" . Data.Functor.Identity.$w$creadListPrec_closure" {
     Data.Functor.Identity.$w$creadListPrec_closure:
         const Data.Functor.Identity.$w$creadListPrec_info;
         const 0;
 },
 sat_sbLs5_entry() //  [R1, R2, R3]
         { info_tbl: [(cbLBE,
                       label: sat_sbLs5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLBE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 w1_sbLs4_entry() //  [R1]
         { info_tbl: [(cbLBH,
                       label: w1_sbLs4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLBH: // global
           _sbLs4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbLBI; else goto cbLBJ;
       cbLBJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbLBL; else goto cbLBK;
       cbLBL: // global
           HpAlloc = 16;
           goto cbLBI;
       cbLBI: // global
           R1 = _sbLs4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLBK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbLs4::P64;
           _sbLs3::P64 = P64[_sbLs4::P64 + 16];
           I64[Hp - 8] = sat_sbLs5_info;
           P64[Hp] = _sbLs3::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity2_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 w2_sbLs6_entry() //  [R1, R2]
         { info_tbl: [(cbLBR,
                       label: w2_sbLs6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLBR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsa_entry() //  [R1, R2]
         { info_tbl: [(cbLC2,
                       label: sat_sbLsa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLC2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbLC3; else goto cbLC4;
       cbLC3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLC4: // global
           I64[Sp - 8] = block_cbLBZ_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbLBZ() //  [R1]
         { info_tbl: [(cbLBZ,
                       label: block_cbLBZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLBZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbLC7; else goto cbLC6;
       cbLC7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbLC6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbLC8,
                       label: Data.Functor.Identity.$w$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLC8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbLCc; else goto cbLCb;
       cbLCc: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLCb: // global
           I64[Hp - 48] = w1_sbLs4_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w2_sbLs6_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbLsa_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.847935891 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity1_closure" {
     Data.Functor.Identity.$fReadIdentity1_closure:
         const Data.Functor.Identity.$fReadIdentity1_info;
         const 0;
 },
 Data.Functor.Identity.$fReadIdentity1_entry() //  [R2]
         { info_tbl: [(cbLCR,
                       label: Data.Functor.Identity.$fReadIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLCR: // global
           R2 = R2;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.852291258 UTC

[section ""data" . Data.Functor.Identity.$fReadIdentity_closure" {
     Data.Functor.Identity.$fReadIdentity_closure:
         const Data.Functor.Identity.$fReadIdentity_info;
         const 0;
 },
 lvl1_sbLse_entry() //  [R1]
         { info_tbl: [(cbLD6,
                       label: lvl1_sbLse_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLD6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLD7; else goto cbLD8;
       cbLD7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLD8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$w$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLsj_entry() //  [R1]
         { info_tbl: [(cbLDe,
                       label: sat_sbLsj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLDe: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsh_entry() //  [R1, R2, R3]
         { info_tbl: [(cbLDm,
                       label: sat_sbLsh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLDm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity3_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsg_entry() //  [R1]
         { info_tbl: [(cbLDt,
                       label: sat_sbLsg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLDt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLDu; else goto cbLDv;
       cbLDu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLDv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fReadIdentity_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLsf_entry() //  [R1, R2, R3]
         { info_tbl: [(cbLDB,
                       label: sat_sbLsf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLDB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fReadIdentity_$creadsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fReadIdentity_entry() //  [R2]
         { info_tbl: [(cbLDF,
                       label: Data.Functor.Identity.$fReadIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLDF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbLDJ; else goto cbLDI;
       cbLDJ: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fReadIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLDI: // global
           I64[Hp - 128] = lvl1_sbLse_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLsj_info;
           P64[Hp - 96] = Hp - 128;
           I64[Hp - 88] = sat_sbLsh_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbLsg_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbLsf_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.86520368 UTC

[section ""cstring" . Data.Functor.Identity.$fShowIdentity2_bytes" {
     Data.Functor.Identity.$fShowIdentity2_bytes:
         I8[] [73,100,101,110,116,105,116,121,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.867232575 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity1_closure" {
     Data.Functor.Identity.$fShowIdentity1_closure:
         const Data.Functor.Identity.$fShowIdentity1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity1_entry() //  [R1]
         { info_tbl: [(cbLEq,
                       label: Data.Functor.Identity.$fShowIdentity1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLEq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLEr; else goto cbLEs;
       cbLEr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLEs: // global
           (_cbLEn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbLEn::I64 == 0) goto cbLEp; else goto cbLEo;
       cbLEp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbLEo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbLEn::I64;
           R2 = Data.Functor.Identity.$fShowIdentity2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.87247409 UTC

[section ""data" . Data.Functor.Identity.$w$cshowsPrec_closure" {
     Data.Functor.Identity.$w$cshowsPrec_closure:
         const Data.Functor.Identity.$w$cshowsPrec_info;
         const 0;
 },
 g_sbLsn_entry() //  [R1]
         { info_tbl: [(cbLEJ,
                       label: g_sbLsn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLEJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbLEK; else goto cbLEL;
       cbLEK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLEL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbLsq_entry() //  [R1]
         { info_tbl: [(cbLEY,
                       label: sat_sbLsq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLEY: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsr_entry() //  [R1, R2]
         { info_tbl: [(cbLF1,
                       label: sat_sbLsr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLF1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbLF5; else goto cbLF4;
       cbLF5: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLF4: // global
           _sbLsn::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbLsq_info;
           P64[Hp - 8] = _sbLsn::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsu_entry() //  [R1]
         { info_tbl: [(cbLFl,
                       label: sat_sbLsu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLFl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLFp; else goto cbLFo;
       cbLFp: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLFo: // global
           _sbLsn::P64 = P64[R1 + 16];
           _sbLss::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbLss::P64;
           R2 = Hp - 14;
           R1 = _sbLsn::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsv_entry() //  [R1]
         { info_tbl: [(cbLFq,
                       label: sat_sbLsv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLFq: // global
           _sbLsv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbLFr; else goto cbLFs;
       cbLFs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbLFu; else goto cbLFt;
       cbLFu: // global
           HpAlloc = 32;
           goto cbLFr;
       cbLFr: // global
           R1 = _sbLsv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLFt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbLsv::P64;
           _sbLsn::P64 = P64[_sbLsv::P64 + 16];
           _sbLss::P64 = P64[_sbLsv::P64 + 24];
           I64[Hp - 24] = sat_sbLsu_info;
           P64[Hp - 8] = _sbLsn::P64;
           P64[Hp] = _sbLss::P64;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLsw_entry() //  [R1, R2]
         { info_tbl: [(cbLFw,
                       label: sat_sbLsw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLFw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbLFA; else goto cbLFz;
       cbLFA: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLFz: // global
           _sbLsn::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbLsv_info;
           P64[Hp - 32] = _sbLsn::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbLFE,
                       label: Data.Functor.Identity.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLFE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbLFI; else goto cbLFH;
       cbLFI: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLFH: // global
           I64[Hp - 40] = g_sbLsn_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbLEF::P64 = Hp - 40;
           if (%MO_S_Le_W64(R3, 10)) goto cbLFC; else goto cbLFD;
       cbLFC: // global
           I64[Hp - 8] = sat_sbLsr_info;
           P64[Hp] = _cbLEF::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbLFD: // global
           I64[Hp - 8] = sat_sbLsw_info;
           P64[Hp] = _cbLEF::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.889527701 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info;
         const 0;
 },
 Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbLGx,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLGx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbLGy; else goto cbLGz;
       cbLGy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLGz: // global
           I64[Sp - 24] = block_cbLGu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubLGD; else goto cbLGv;
       ubLGD: // global
           call _cbLGu(R1) args: 0, res: 0, upd: 0;
       cbLGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLGu() //  [R1]
         { info_tbl: [(cbLGu,
                       label: block_cbLGu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLGu: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.895332652 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshow_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshow_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshow_info;
         const 0;
 },
 sat_sbLsE_entry() //  [R1]
         { info_tbl: [(cbLGW,
                       label: sat_sbLsE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLGW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbLGX; else goto cbLGY;
       cbLGX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLGY: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Functor.Identity.$fReadIdentity4_closure+1;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbLGZ,
                       label: Data.Functor.Identity.$fShowIdentity_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLGZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbLH3; else goto cbLH2;
       cbLH3: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLH2: // global
           I64[Hp - 24] = sat_sbLsE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Functor.Identity.$fShowIdentity1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.901594388 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_$cshowList_closure" {
     Data.Functor.Identity.$fShowIdentity_$cshowList_closure:
         const Data.Functor.Identity.$fShowIdentity_$cshowList_info;
         const 0;
 },
 sat_sbLsJ_entry() //  [R1, R2]
         { info_tbl: [(cbLHr,
                       label: sat_sbLsJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLHr: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$w$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_$cshowList_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbLHu,
                       label: Data.Functor.Identity.$fShowIdentity_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLHu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbLHy; else goto cbLHx;
       cbLHy: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLHx: // global
           I64[Hp - 8] = sat_sbLsJ_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.907317681 UTC

[section ""data" . Data.Functor.Identity.$fShowIdentity_closure" {
     Data.Functor.Identity.$fShowIdentity_closure:
         const Data.Functor.Identity.$fShowIdentity_info;
         const 0;
 },
 sat_sbLsN_entry() //  [R1, R2, R3]
         { info_tbl: [(cbLHQ,
                       label: sat_sbLsN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLHQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowList_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsM_entry() //  [R1, R2]
         { info_tbl: [(cbLHY,
                       label: sat_sbLsM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLHY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Functor.Identity.$fShowIdentity_$cshow_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbLsL_entry() //  [R1, R2, R3]
         { info_tbl: [(cbLI6,
                       label: sat_sbLsL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLI6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Functor.Identity.$fShowIdentity_$cshowsPrec_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Functor.Identity.$fShowIdentity_entry() //  [R2]
         { info_tbl: [(cbLIa,
                       label: Data.Functor.Identity.$fShowIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLIa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbLIe; else goto cbLId;
       cbLIe: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Functor.Identity.$fShowIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLId: // global
           I64[Hp - 72] = sat_sbLsN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbLsM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbLsL_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.916718283 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity4_closure" {
     Data.Functor.Identity.$fFoldableIdentity4_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.918574396 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$clength_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$clength_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$clength_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$clength_entry() //  []
         { info_tbl: [(cbLIF,
                       label: Data.Functor.Identity.$fFoldableIdentity_$clength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLIF: // global
           R1 = Data.Functor.Identity.$fFoldableIdentity4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.921871722 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cnull_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cnull_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cnull_entry() //  []
         { info_tbl: [(cbLIR,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cnull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLIR: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.925237088 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$ctoList_entry() //  [R2]
         { info_tbl: [(cbLJ5,
                       label: Data.Functor.Identity.$fFoldableIdentity_$ctoList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLJ5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLJ9; else goto cbLJ8;
       cbLJ9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLJ8: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.929073091 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity6_closure" {
     Data.Functor.Identity.$fFoldableIdentity6_closure:
         const Data.Functor.Identity.$fFoldableIdentity6_info;
 },
 Data.Functor.Identity.$fFoldableIdentity6_entry() //  [R2]
         { info_tbl: [(cbLJm,
                       label: Data.Functor.Identity.$fFoldableIdentity6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLJm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.932715609 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure" {
     Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure:
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info;
 },
 Data.Functor.Identity.$fFoldableIdentity_$cfoldr_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbLJx,
                       label: Data.Functor.Identity.$fFoldableIdentity_$cfoldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLJx: // global
           R3 = R3;
           _sbLsS::P64 = R2;
           R2 = R4;
           R1 = _sbLsS::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.936183134 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity7_closure" {
     Data.Functor.Identity.$fFoldableIdentity7_closure:
         const Data.Functor.Identity.$fFoldableIdentity7_info;
 },
 Data.Functor.Identity.$fFoldableIdentity7_entry() //  [R3]
         { info_tbl: [(cbLJI,
                       label: Data.Functor.Identity.$fFoldableIdentity7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLJI: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.939466255 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity2_closure" {
     Data.Functor.Identity.$fFunctorIdentity2_closure:
         const Data.Functor.Identity.$fFunctorIdentity2_info;
 },
 Data.Functor.Identity.$fFunctorIdentity2_entry() //  [R2]
         { info_tbl: [(cbLJT,
                       label: Data.Functor.Identity.$fFunctorIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLJT: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.942801284 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity1_closure" {
     Data.Functor.Identity.$fFunctorIdentity1_closure:
         const Data.Functor.Identity.$fFunctorIdentity1_info;
 },
 Data.Functor.Identity.$fFunctorIdentity1_entry() //  [R2]
         { info_tbl: [(cbLK4,
                       label: Data.Functor.Identity.$fFunctorIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLK4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.94695761 UTC

[section ""data" . Data.Functor.Identity.$fFunctorIdentity_closure" {
     Data.Functor.Identity.$fFunctorIdentity_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Functor.Identity.$fFunctorIdentity2_closure+1;
         const Data.Functor.Identity.$fFunctorIdentity1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.94874953 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity1_closure" {
     Data.Functor.Identity.$fApplicativeIdentity1_closure:
         const Data.Functor.Identity.$fApplicativeIdentity1_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity1_entry() //  [R2]
         { info_tbl: [(cbLKg,
                       label: Data.Functor.Identity.$fApplicativeIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLKg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.951968236 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity2_closure" {
     Data.Functor.Identity.$fApplicativeIdentity2_closure:
         const Data.Functor.Identity.$fApplicativeIdentity2_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity2_entry() //  [R2]
         { info_tbl: [(cbLKr,
                       label: Data.Functor.Identity.$fApplicativeIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLKr: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.95522792 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity3_closure" {
     Data.Functor.Identity.$fApplicativeIdentity3_closure:
         const Data.Functor.Identity.$fApplicativeIdentity3_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity3_entry() //  [R2]
         { info_tbl: [(cbLKC,
                       label: Data.Functor.Identity.$fApplicativeIdentity3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLKC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.958980361 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure:
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_info;
 },
 Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry() //  [R3]
         { info_tbl: [(cbLKN,
                       label: Data.Functor.Identity.$fApplicativeIdentity_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLKN: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.96213309 UTC

[section ""data" . Data.Functor.Identity.$fApplicativeIdentity_closure" {
     Data.Functor.Identity.$fApplicativeIdentity_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity2_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity1_closure+1;
         const Data.Functor.Identity.$fApplicativeIdentity_$c*>_closure+2;
         const GHC.Base.const_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.965065553 UTC

[section ""data" . Data.Functor.Identity.$fStorableIdentity_closure" {
     Data.Functor.Identity.$fStorableIdentity_closure:
         const Data.Functor.Identity.$fStorableIdentity_info;
 },
 sat_sbLtd_entry() //  [R1]
         { info_tbl: [(cbLL3,
                       label: sat_sbLtd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLL3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLL4; else goto cbLL5;
       cbLL4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLL5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtc_entry() //  [R1]
         { info_tbl: [(cbLLa,
                       label: sat_sbLtc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLb; else goto cbLLc;
       cbLLb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtb_entry() //  [R1]
         { info_tbl: [(cbLLh,
                       label: sat_sbLtb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLi; else goto cbLLj;
       cbLLi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLta_entry() //  [R1]
         { info_tbl: [(cbLLo,
                       label: sat_sbLta_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLp; else goto cbLLq;
       cbLLp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekByteOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLt9_entry() //  [R1]
         { info_tbl: [(cbLLv,
                       label: sat_sbLt9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLw; else goto cbLLx;
       cbLLw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLt8_entry() //  [R1]
         { info_tbl: [(cbLLC,
                       label: sat_sbLt8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLD; else goto cbLLE;
       cbLLD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLt7_entry() //  [R1]
         { info_tbl: [(cbLLJ,
                       label: sat_sbLt7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLK; else goto cbLLL;
       cbLLK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLt6_entry() //  [R1]
         { info_tbl: [(cbLLQ,
                       label: sat_sbLt6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLLR; else goto cbLLS;
       cbLLR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLLS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fStorableIdentity_entry() //  [R2]
         { info_tbl: [(cbLLU,
                       label: Data.Functor.Identity.$fStorableIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLLU: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbLLY; else goto cbLLX;
       cbLLY: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fStorableIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLLX: // global
           I64[Hp - 256] = sat_sbLtd_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbLtc_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbLtb_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbLta_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbLt9_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbLt8_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbLt7_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbLt6_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:38.985623855 UTC

[section ""data" . Data.Functor.Identity.$fNumIdentity_closure" {
     Data.Functor.Identity.$fNumIdentity_closure:
         const Data.Functor.Identity.$fNumIdentity_info;
 },
 sat_sbLtl_entry() //  [R1]
         { info_tbl: [(cbLN7,
                       label: sat_sbLtl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLN7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLN8; else goto cbLN9;
       cbLN8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLN9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtk_entry() //  [R1]
         { info_tbl: [(cbLNe,
                       label: sat_sbLtk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLNf; else goto cbLNg;
       cbLNf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLNg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtj_entry() //  [R1]
         { info_tbl: [(cbLNl,
                       label: sat_sbLtj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLNm; else goto cbLNn;
       cbLNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLNn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLti_entry() //  [R1]
         { info_tbl: [(cbLNs,
                       label: sat_sbLti_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLNt; else goto cbLNu;
       cbLNt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLNu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLth_entry() //  [R1]
         { info_tbl: [(cbLNz,
                       label: sat_sbLth_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLNA; else goto cbLNB;
       cbLNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLNB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtg_entry() //  [R1]
         { info_tbl: [(cbLNG,
                       label: sat_sbLtg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLNH; else goto cbLNI;
       cbLNH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLNI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtf_entry() //  [R1]
         { info_tbl: [(cbLNN,
                       label: sat_sbLtf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLNO; else goto cbLNP;
       cbLNO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLNP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fNumIdentity_entry() //  [R2]
         { info_tbl: [(cbLNR,
                       label: Data.Functor.Identity.$fNumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLNR: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbLNV; else goto cbLNU;
       cbLNV: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fNumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLNU: // global
           I64[Hp - 224] = sat_sbLtl_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbLtk_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbLtj_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbLti_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbLth_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLtg_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbLtf_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.002430097 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp1Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp1Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp1Real_info;
 },
 sat_sbLtn_entry() //  [R1]
         { info_tbl: [(cbLOX,
                       label: sat_sbLtn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLOY; else goto cbLOZ;
       cbLOY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLOZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp1Real_entry() //  [R2]
         { info_tbl: [(cbLP0,
                       label: Data.Functor.Identity.$fRealIdentity_$cp1Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLP0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLP4; else goto cbLP3;
       cbLP4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp1Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLP3: // global
           I64[Hp - 16] = sat_sbLtn_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.008196719 UTC

[section ""data" . Data.Functor.Identity.$fSemigroupIdentity_closure" {
     Data.Functor.Identity.$fSemigroupIdentity_closure:
         const Data.Functor.Identity.$fSemigroupIdentity_info;
 },
 sat_sbLtr_entry() //  [R1]
         { info_tbl: [(cbLPn,
                       label: sat_sbLtr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLPn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLPo; else goto cbLPp;
       cbLPo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLPp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.stimes_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtq_entry() //  [R1]
         { info_tbl: [(cbLPu,
                       label: sat_sbLtq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLPu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLPv; else goto cbLPw;
       cbLPv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLPw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.sconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtp_entry() //  [R1]
         { info_tbl: [(cbLPB,
                       label: sat_sbLtp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLPB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLPC; else goto cbLPD;
       cbLPC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLPD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fSemigroupIdentity_entry() //  [R2]
         { info_tbl: [(cbLPF,
                       label: Data.Functor.Identity.$fSemigroupIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLPF: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbLPJ; else goto cbLPI;
       cbLPJ: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fSemigroupIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLPI: // global
           I64[Hp - 96] = sat_sbLtr_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbLtq_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbLtp_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.018198364 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure" {
     Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure:
         const Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info;
 },
 sat_sbLtt_entry() //  [R1]
         { info_tbl: [(cbLQj,
                       label: sat_sbLtt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLQj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLQk; else goto cbLQl;
       cbLQk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLQl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cbLQm,
                       label: Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLQm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLQq; else goto cbLQp;
       cbLQq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLQp: // global
           I64[Hp - 16] = sat_sbLtt_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fSemigroupIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.024278889 UTC

[section ""data" . Data.Functor.Identity.$fMonoidIdentity_closure" {
     Data.Functor.Identity.$fMonoidIdentity_closure:
         const Data.Functor.Identity.$fMonoidIdentity_info;
 },
 sat_sbLty_entry() //  [R1]
         { info_tbl: [(cbLQJ,
                       label: sat_sbLty_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLQJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLQK; else goto cbLQL;
       cbLQK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLQL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtx_entry() //  [R1]
         { info_tbl: [(cbLQQ,
                       label: sat_sbLtx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLQQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLQR; else goto cbLQS;
       cbLQR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLQS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtw_entry() //  [R1]
         { info_tbl: [(cbLQX,
                       label: sat_sbLtw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLQX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLQY; else goto cbLQZ;
       cbLQY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLQZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtv_entry() //  [R1]
         { info_tbl: [(cbLR4,
                       label: sat_sbLtv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLR4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLR5; else goto cbLR6;
       cbLR5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLR6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fMonoidIdentity_entry() //  [R2]
         { info_tbl: [(cbLR8,
                       label: Data.Functor.Identity.$fMonoidIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLR8: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbLRc; else goto cbLRb;
       cbLRc: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonoidIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLRb: // global
           I64[Hp - 128] = sat_sbLty_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLtx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbLtw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbLtv_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.035088299 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity1_closure" {
     Data.Functor.Identity.$fGeneric1Identity1_closure:
         const Data.Functor.Identity.$fGeneric1Identity1_info;
 },
 Data.Functor.Identity.$fGeneric1Identity1_entry() //  [R2]
         { info_tbl: [(cbLRP,
                       label: Data.Functor.Identity.$fGeneric1Identity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLRP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.038660408 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity2_closure" {
     Data.Functor.Identity.$fFoldableIdentity2_closure:
         const Data.Functor.Identity.$fFoldableIdentity2_info;
 },
 Data.Functor.Identity.$fFoldableIdentity2_entry() //  [R2]
         { info_tbl: [(cbLS0,
                       label: Data.Functor.Identity.$fFoldableIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLS0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.041786889 UTC

[section ""data" . Data.Functor.Identity.$fGeneric1Identity_closure" {
     Data.Functor.Identity.$fGeneric1Identity_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Functor.Identity.$fFoldableIdentity2_closure+1;
         const Data.Functor.Identity.$fGeneric1Identity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.043685308 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity1_closure" {
     Data.Functor.Identity.$fGenericIdentity1_closure:
         const Data.Functor.Identity.$fGenericIdentity1_info;
 },
 Data.Functor.Identity.$fGenericIdentity1_entry() //  [R2]
         { info_tbl: [(cbLSc,
                       label: Data.Functor.Identity.$fGenericIdentity1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLSc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.046891976 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity2_closure" {
     Data.Functor.Identity.$fGenericIdentity2_closure:
         const Data.Functor.Identity.$fGenericIdentity2_info;
 },
 Data.Functor.Identity.$fGenericIdentity2_entry() //  [R2]
         { info_tbl: [(cbLSn,
                       label: Data.Functor.Identity.$fGenericIdentity2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLSn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.050959866 UTC

[section ""data" . Data.Functor.Identity.$fGenericIdentity_closure" {
     Data.Functor.Identity.$fGenericIdentity_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Functor.Identity.$fGenericIdentity2_closure+1;
         const Data.Functor.Identity.$fGenericIdentity1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.053026252 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure" {
     Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure:
         const Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info;
 },
 sat_sbLtE_entry() //  [R1]
         { info_tbl: [(cbLSD,
                       label: sat_sbLtE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLSD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLSE; else goto cbLSF;
       cbLSE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLSF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry() //  [R2]
         { info_tbl: [(cbLSG,
                       label: Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLSG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLSK; else goto cbLSJ;
       cbLSK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLSJ: // global
           I64[Hp - 16] = sat_sbLtE_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fNumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.059009835 UTC

[section ""data" . Data.Functor.Identity.$fFractionalIdentity_closure" {
     Data.Functor.Identity.$fFractionalIdentity_closure:
         const Data.Functor.Identity.$fFractionalIdentity_info;
 },
 sat_sbLtJ_entry() //  [R1]
         { info_tbl: [(cbLT3,
                       label: sat_sbLtJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLT3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLT4; else goto cbLT5;
       cbLT4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLT5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.fromRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtI_entry() //  [R1]
         { info_tbl: [(cbLTa,
                       label: sat_sbLtI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLTa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLTb; else goto cbLTc;
       cbLTb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLTc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.recip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtH_entry() //  [R1]
         { info_tbl: [(cbLTh,
                       label: sat_sbLtH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLTh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLTi; else goto cbLTj;
       cbLTi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real./_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtG_entry() //  [R1]
         { info_tbl: [(cbLTo,
                       label: sat_sbLtG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLTo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLTp; else goto cbLTq;
       cbLTp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLTq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFractionalIdentity_entry() //  [R2]
         { info_tbl: [(cbLTs,
                       label: Data.Functor.Identity.$fFractionalIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLTs: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbLTw; else goto cbLTv;
       cbLTw: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFractionalIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLTv: // global
           I64[Hp - 128] = sat_sbLtJ_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLtI_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbLtH_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbLtG_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.070590487 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info;
 },
 sat_sbLtL_entry() //  [R1]
         { info_tbl: [(cbLUd,
                       label: sat_sbLtL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLUd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLUe; else goto cbLUf;
       cbLUe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLUf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry() //  [R2]
         { info_tbl: [(cbLUg,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLUg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLUk; else goto cbLUj;
       cbLUk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLUj: // global
           I64[Hp - 16] = sat_sbLtL_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.076228756 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure" {
     Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure:
         const Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info;
 },
 sat_sbLtN_entry() //  [R1]
         { info_tbl: [(cbLUD,
                       label: sat_sbLtN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLUD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLUE; else goto cbLUF;
       cbLUE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLUF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry() //  [R2]
         { info_tbl: [(cbLUG,
                       label: Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLUG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbLUK; else goto cbLUJ;
       cbLUK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLUJ: // global
           I64[Hp - 16] = sat_sbLtN_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFractionalIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.084561275 UTC

[section ""data" . Data.Functor.Identity.$fFloatingIdentity_closure" {
     Data.Functor.Identity.$fFloatingIdentity_closure:
         const Data.Functor.Identity.$fFloatingIdentity_info;
 },
 sat_sbLub_entry() //  [R1]
         { info_tbl: [(cbLV3,
                       label: sat_sbLub_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLV4; else goto cbLV5;
       cbLV4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLV5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1mexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLua_entry() //  [R1]
         { info_tbl: [(cbLVa,
                       label: sat_sbLua_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVb; else goto cbLVc;
       cbLVb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1pexp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu9_entry() //  [R1]
         { info_tbl: [(cbLVh,
                       label: sat_sbLu9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVi; else goto cbLVj;
       cbLVi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.expm1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu8_entry() //  [R1]
         { info_tbl: [(cbLVo,
                       label: sat_sbLu8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVp; else goto cbLVq;
       cbLVp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log1p_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu7_entry() //  [R1]
         { info_tbl: [(cbLVv,
                       label: sat_sbLu7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVw; else goto cbLVx;
       cbLVw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu6_entry() //  [R1]
         { info_tbl: [(cbLVC,
                       label: sat_sbLu6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVD; else goto cbLVE;
       cbLVD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu5_entry() //  [R1]
         { info_tbl: [(cbLVJ,
                       label: sat_sbLu5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVK; else goto cbLVL;
       cbLVK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu4_entry() //  [R1]
         { info_tbl: [(cbLVQ,
                       label: sat_sbLu4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVR; else goto cbLVS;
       cbLVR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tanh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu3_entry() //  [R1]
         { info_tbl: [(cbLVX,
                       label: sat_sbLu3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLVX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLVY; else goto cbLVZ;
       cbLVY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLVZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cosh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu2_entry() //  [R1]
         { info_tbl: [(cbLW4,
                       label: sat_sbLu2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLW4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLW5; else goto cbLW6;
       cbLW5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLW6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sinh_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu1_entry() //  [R1]
         { info_tbl: [(cbLWb,
                       label: sat_sbLu1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWc; else goto cbLWd;
       cbLWc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLu0_entry() //  [R1]
         { info_tbl: [(cbLWi,
                       label: sat_sbLu0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWj; else goto cbLWk;
       cbLWj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.acos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtZ_entry() //  [R1]
         { info_tbl: [(cbLWp,
                       label: sat_sbLtZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWq; else goto cbLWr;
       cbLWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.asin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtY_entry() //  [R1]
         { info_tbl: [(cbLWw,
                       label: sat_sbLtY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWx; else goto cbLWy;
       cbLWx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.tan_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtX_entry() //  [R1]
         { info_tbl: [(cbLWD,
                       label: sat_sbLtX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWE; else goto cbLWF;
       cbLWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.cos_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtW_entry() //  [R1]
         { info_tbl: [(cbLWK,
                       label: sat_sbLtW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWL; else goto cbLWM;
       cbLWL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtV_entry() //  [R1]
         { info_tbl: [(cbLWR,
                       label: sat_sbLtV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWS; else goto cbLWT;
       cbLWS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLWT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.logBase_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtU_entry() //  [R1]
         { info_tbl: [(cbLWY,
                       label: sat_sbLtU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLWY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLWZ; else goto cbLX0;
       cbLWZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLX0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.**_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtT_entry() //  [R1]
         { info_tbl: [(cbLX5,
                       label: sat_sbLtT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLX5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLX6; else goto cbLX7;
       cbLX6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLX7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.sqrt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtS_entry() //  [R1]
         { info_tbl: [(cbLXc,
                       label: sat_sbLtS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLXd; else goto cbLXe;
       cbLXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLXe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.log_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtR_entry() //  [R1]
         { info_tbl: [(cbLXj,
                       label: sat_sbLtR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLXj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLXk; else goto cbLXl;
       cbLXk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLXl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exp_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtQ_entry() //  [R1]
         { info_tbl: [(cbLXq,
                       label: sat_sbLtQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLXq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLXr; else goto cbLXs;
       cbLXr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLXs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.pi_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLtP_entry() //  [R1]
         { info_tbl: [(cbLXx,
                       label: sat_sbLtP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLXx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLXy; else goto cbLXz;
       cbLXy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLXz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_$cp1Floating_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFloatingIdentity_entry() //  [R2]
         { info_tbl: [(cbLXB,
                       label: Data.Functor.Identity.$fFloatingIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLXB: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbLXF; else goto cbLXE;
       cbLXF: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFloatingIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbLXE: // global
           I64[Hp - 736] = sat_sbLub_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbLua_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbLu9_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbLu8_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbLu7_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbLu6_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbLu5_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbLu4_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbLu3_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbLu2_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbLu1_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbLu0_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbLtZ_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbLtY_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbLtX_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbLtW_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbLtV_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbLtU_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbLtT_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbLtS_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbLtR_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbLtQ_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbLtP_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = GHC.Float.C:Floating_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.133052049 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info;
 },
 sat_sbLud_entry() //  [R1]
         { info_tbl: [(cbM0v,
                       label: sat_sbLud_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM0v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM0w; else goto cbM0x;
       cbM0w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM0x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry() //  [R2]
         { info_tbl: [(cbM0y,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM0y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbM0C; else goto cbM0B;
       cbM0C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM0B: // global
           I64[Hp - 16] = sat_sbLud_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fFloatingIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.138910394 UTC

[section ""data" . Data.Functor.Identity.$fEqIdentity_closure" {
     Data.Functor.Identity.$fEqIdentity_closure:
         const Data.Functor.Identity.$fEqIdentity_info;
 },
 sat_sbLug_entry() //  [R1]
         { info_tbl: [(cbM0V,
                       label: sat_sbLug_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM0V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM0W; else goto cbM0X;
       cbM0W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM0X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuf_entry() //  [R1]
         { info_tbl: [(cbM12,
                       label: sat_sbLuf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM12: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM13; else goto cbM14;
       cbM13: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM14: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEqIdentity_entry() //  [R2]
         { info_tbl: [(cbM16,
                       label: Data.Functor.Identity.$fEqIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM16: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbM1a; else goto cbM19;
       cbM1a: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEqIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM19: // global
           I64[Hp - 64] = sat_sbLug_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbLuf_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.146917801 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure" {
     Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure:
         const Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info;
 },
 sat_sbLui_entry() //  [R1]
         { info_tbl: [(cbM1D,
                       label: sat_sbLui_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM1D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM1E; else goto cbM1F;
       cbM1E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM1F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbM1G,
                       label: Data.Functor.Identity.$fOrdIdentity_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM1G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbM1K; else goto cbM1J;
       cbM1K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM1J: // global
           I64[Hp - 16] = sat_sbLui_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.15368375 UTC

[section ""data" . Data.Functor.Identity.$fOrdIdentity_closure" {
     Data.Functor.Identity.$fOrdIdentity_closure:
         const Data.Functor.Identity.$fOrdIdentity_info;
 },
 sat_sbLur_entry() //  [R1]
         { info_tbl: [(cbM23,
                       label: sat_sbLur_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM23: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM24; else goto cbM25;
       cbM24: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM25: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuq_entry() //  [R1]
         { info_tbl: [(cbM2a,
                       label: sat_sbLuq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2b; else goto cbM2c;
       cbM2b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLup_entry() //  [R1]
         { info_tbl: [(cbM2h,
                       label: sat_sbLup_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2i; else goto cbM2j;
       cbM2i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuo_entry() //  [R1]
         { info_tbl: [(cbM2o,
                       label: sat_sbLuo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2p; else goto cbM2q;
       cbM2p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLun_entry() //  [R1]
         { info_tbl: [(cbM2v,
                       label: sat_sbLun_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2w; else goto cbM2x;
       cbM2w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLum_entry() //  [R1]
         { info_tbl: [(cbM2C,
                       label: sat_sbLum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2D; else goto cbM2E;
       cbM2D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLul_entry() //  [R1]
         { info_tbl: [(cbM2J,
                       label: sat_sbLul_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2K; else goto cbM2L;
       cbM2K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuk_entry() //  [R1]
         { info_tbl: [(cbM2Q,
                       label: sat_sbLuk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM2R; else goto cbM2S;
       cbM2R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM2S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fOrdIdentity_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fOrdIdentity_entry() //  [R2]
         { info_tbl: [(cbM2U,
                       label: Data.Functor.Identity.$fOrdIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM2U: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbM2Y; else goto cbM2X;
       cbM2Y: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fOrdIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM2X: // global
           I64[Hp - 256] = sat_sbLur_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbLuq_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbLup_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbLuo_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbLun_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbLum_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbLul_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbLuk_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.173395549 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure" {
     Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure:
         const Data.Functor.Identity.$fIxIdentity_$cp1Ix_info;
 },
 sat_sbLut_entry() //  [R1]
         { info_tbl: [(cbM47,
                       label: sat_sbLut_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM47: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM48; else goto cbM49;
       cbM48: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM49: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.$p1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry() //  [R2]
         { info_tbl: [(cbM4a,
                       label: Data.Functor.Identity.$fIxIdentity_$cp1Ix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM4a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbM4e; else goto cbM4d;
       cbM4e: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_$cp1Ix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM4d: // global
           I64[Hp - 16] = sat_sbLut_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.179916642 UTC

[section ""data" . Data.Functor.Identity.$fIxIdentity_closure" {
     Data.Functor.Identity.$fIxIdentity_closure:
         const Data.Functor.Identity.$fIxIdentity_info;
 },
 sat_sbLuB_entry() //  [R1]
         { info_tbl: [(cbM4x,
                       label: sat_sbLuB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM4x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM4y; else goto cbM4z;
       cbM4y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeRangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuA_entry() //  [R1]
         { info_tbl: [(cbM4E,
                       label: sat_sbLuA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM4E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM4F; else goto cbM4G;
       cbM4F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM4G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.rangeSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuz_entry() //  [R1]
         { info_tbl: [(cbM4L,
                       label: sat_sbLuz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM4M; else goto cbM4N;
       cbM4M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM4N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.inRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuy_entry() //  [R1]
         { info_tbl: [(cbM4S,
                       label: sat_sbLuy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM4T; else goto cbM4U;
       cbM4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.unsafeIndex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLux_entry() //  [R1]
         { info_tbl: [(cbM4Z,
                       label: sat_sbLux_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM4Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM50; else goto cbM51;
       cbM50: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM51: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.index_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuw_entry() //  [R1]
         { info_tbl: [(cbM56,
                       label: sat_sbLuw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM56: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM57; else goto cbM58;
       cbM57: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM58: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.range_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuv_entry() //  [R1]
         { info_tbl: [(cbM5d,
                       label: sat_sbLuv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM5d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM5e; else goto cbM5f;
       cbM5e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM5f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIxIdentity_$cp1Ix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIxIdentity_entry() //  [R2]
         { info_tbl: [(cbM5h,
                       label: Data.Functor.Identity.$fIxIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM5h: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbM5l; else goto cbM5k;
       cbM5l: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIxIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM5k: // global
           I64[Hp - 224] = sat_sbLuB_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbLuA_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbLuz_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbLuy_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbLux_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLuw_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbLuv_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Arr.C:Ix_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.197561096 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_$cp2Real_closure" {
     Data.Functor.Identity.$fRealIdentity_$cp2Real_closure:
         const Data.Functor.Identity.$fRealIdentity_$cp2Real_info;
 },
 sat_sbLuD_entry() //  [R1]
         { info_tbl: [(cbM6n,
                       label: sat_sbLuD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM6n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM6o; else goto cbM6p;
       cbM6o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM6p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_$cp2Real_entry() //  [R2]
         { info_tbl: [(cbM6q,
                       label: Data.Functor.Identity.$fRealIdentity_$cp2Real_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM6q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbM6u; else goto cbM6t;
       cbM6u: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_$cp2Real_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM6t: // global
           I64[Hp - 16] = sat_sbLuD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fOrdIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.20348336 UTC

[section ""data" . Data.Functor.Identity.$fRealIdentity_closure" {
     Data.Functor.Identity.$fRealIdentity_closure:
         const Data.Functor.Identity.$fRealIdentity_info;
 },
 sat_sbLuH_entry() //  [R1]
         { info_tbl: [(cbM6N,
                       label: sat_sbLuH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM6N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM6O; else goto cbM6P;
       cbM6O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM6P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuG_entry() //  [R1]
         { info_tbl: [(cbM6U,
                       label: sat_sbLuG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM6U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM6V; else goto cbM6W;
       cbM6V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM6W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuF_entry() //  [R1]
         { info_tbl: [(cbM71,
                       label: sat_sbLuF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM71: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM72; else goto cbM73;
       cbM72: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM73: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealIdentity_$cp1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealIdentity_entry() //  [R2]
         { info_tbl: [(cbM75,
                       label: Data.Functor.Identity.$fRealIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM75: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbM79; else goto cbM78;
       cbM79: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM78: // global
           I64[Hp - 96] = sat_sbLuH_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbLuG_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sbLuF_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.214396701 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info;
 },
 sat_sbLuJ_entry() //  [R1]
         { info_tbl: [(cbM7J,
                       label: sat_sbLuJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM7J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM7K; else goto cbM7L;
       cbM7K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM7L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry() //  [R2]
         { info_tbl: [(cbM7M,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM7M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbM7Q; else goto cbM7P;
       cbM7Q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM7P: // global
           I64[Hp - 16] = sat_sbLuJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.220183658 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure" {
     Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure:
         const Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info;
 },
 sat_sbLuL_entry() //  [R1]
         { info_tbl: [(cbM89,
                       label: sat_sbLuL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM89: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM8a; else goto cbM8b;
       cbM8a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM8b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry() //  [R2]
         { info_tbl: [(cbM8c,
                       label: Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM8c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbM8g; else goto cbM8f;
       cbM8g: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM8f: // global
           I64[Hp - 16] = sat_sbLuL_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.226871809 UTC

[section ""data" . Data.Functor.Identity.$fRealFracIdentity_closure" {
     Data.Functor.Identity.$fRealFracIdentity_closure:
         const Data.Functor.Identity.$fRealFracIdentity_info;
 },
 sat_sbLuT_entry() //  [R1]
         { info_tbl: [(cbM8z,
                       label: sat_sbLuT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM8z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM8A; else goto cbM8B;
       cbM8A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM8B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.floor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuS_entry() //  [R1]
         { info_tbl: [(cbM8G,
                       label: sat_sbLuS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM8G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM8H; else goto cbM8I;
       cbM8H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM8I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.ceiling_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuR_entry() //  [R1]
         { info_tbl: [(cbM8N,
                       label: sat_sbLuR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM8N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM8O; else goto cbM8P;
       cbM8O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM8P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.round_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuQ_entry() //  [R1]
         { info_tbl: [(cbM8U,
                       label: sat_sbLuQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM8V; else goto cbM8W;
       cbM8V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM8W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.truncate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuP_entry() //  [R1]
         { info_tbl: [(cbM91,
                       label: sat_sbLuP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM91: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM92; else goto cbM93;
       cbM92: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM93: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.properFraction_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuO_entry() //  [R1]
         { info_tbl: [(cbM98,
                       label: sat_sbLuO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM98: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM99; else goto cbM9a;
       cbM99: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM9a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuN_entry() //  [R1]
         { info_tbl: [(cbM9f,
                       label: sat_sbLuN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM9f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbM9g; else goto cbM9h;
       cbM9g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbM9h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFracIdentity_entry() //  [R2]
         { info_tbl: [(cbM9j,
                       label: Data.Functor.Identity.$fRealFracIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM9j: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cbM9n; else goto cbM9m;
       cbM9n: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFracIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM9m: // global
           I64[Hp - 224] = sat_sbLuT_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbLuS_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbLuR_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbLuQ_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbLuP_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLuO_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbLuN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.24396848 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info;
 },
 sat_sbLuV_entry() //  [R1]
         { info_tbl: [(cbMap,
                       label: sat_sbLuV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMap: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMaq; else goto cbMar;
       cbMaq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMar: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.$p1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry() //  [R2]
         { info_tbl: [(cbMas,
                       label: Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMas: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbMaw; else goto cbMav;
       cbMaw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMav: // global
           I64[Hp - 16] = sat_sbLuV_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fRealFracIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.252040994 UTC

[section ""data" . Data.Functor.Identity.$fRealFloatIdentity_closure" {
     Data.Functor.Identity.$fRealFloatIdentity_closure:
         const Data.Functor.Identity.$fRealFloatIdentity_info;
 },
 sat_sbLvc_entry() //  [R1]
         { info_tbl: [(cbMaP,
                       label: sat_sbLvc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMaP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMaQ; else goto cbMaR;
       cbMaQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMaR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.atan2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvb_entry() //  [R1]
         { info_tbl: [(cbMaW,
                       label: sat_sbLvb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMaW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMaX; else goto cbMaY;
       cbMaX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMaY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isIEEE_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLva_entry() //  [R1]
         { info_tbl: [(cbMb3,
                       label: sat_sbLva_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMb3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMb4; else goto cbMb5;
       cbMb4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMb5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv9_entry() //  [R1]
         { info_tbl: [(cbMba,
                       label: sat_sbLv9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMba: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbb; else goto cbMbc;
       cbMbb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isDenormalized_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv8_entry() //  [R1]
         { info_tbl: [(cbMbh,
                       label: sat_sbLv8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbi; else goto cbMbj;
       cbMbi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv7_entry() //  [R1]
         { info_tbl: [(cbMbo,
                       label: sat_sbLv7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbp; else goto cbMbq;
       cbMbp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv6_entry() //  [R1]
         { info_tbl: [(cbMbv,
                       label: sat_sbLv6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbw; else goto cbMbx;
       cbMbw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.scaleFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv5_entry() //  [R1]
         { info_tbl: [(cbMbC,
                       label: sat_sbLv5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbD; else goto cbMbE;
       cbMbD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.significand_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv4_entry() //  [R1]
         { info_tbl: [(cbMbJ,
                       label: sat_sbLv4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbK; else goto cbMbL;
       cbMbK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.exponent_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv3_entry() //  [R1]
         { info_tbl: [(cbMbQ,
                       label: sat_sbLv3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbR; else goto cbMbS;
       cbMbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.encodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv2_entry() //  [R1]
         { info_tbl: [(cbMbX,
                       label: sat_sbLv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMbX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMbY; else goto cbMbZ;
       cbMbY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMbZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.decodeFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv1_entry() //  [R1]
         { info_tbl: [(cbMc4,
                       label: sat_sbLv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMc4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMc5; else goto cbMc6;
       cbMc5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMc6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRange_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLv0_entry() //  [R1]
         { info_tbl: [(cbMcb,
                       label: sat_sbLv0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMcb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMcc; else goto cbMcd;
       cbMcc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMcd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatDigits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuZ_entry() //  [R1]
         { info_tbl: [(cbMci,
                       label: sat_sbLuZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMci: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMcj; else goto cbMck;
       cbMcj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMck: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.floatRadix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuY_entry() //  [R1]
         { info_tbl: [(cbMcp,
                       label: sat_sbLuY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMcq; else goto cbMcr;
       cbMcq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMcr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLuX_entry() //  [R1]
         { info_tbl: [(cbMcw,
                       label: sat_sbLuX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMcw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMcx; else goto cbMcy;
       cbMcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMcy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fRealFloatIdentity_entry() //  [R2]
         { info_tbl: [(cbMcA,
                       label: Data.Functor.Identity.$fRealFloatIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMcA: // global
           Hp = Hp + 520;
           if (Hp > HpLim) (likely: False) goto cbMcE; else goto cbMcD;
       cbMcE: // global
           HpAlloc = 520;
           R2 = R2;
           R1 = Data.Functor.Identity.$fRealFloatIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMcD: // global
           I64[Hp - 512] = sat_sbLvc_info;
           P64[Hp - 496] = R2;
           I64[Hp - 488] = sat_sbLvb_info;
           P64[Hp - 472] = R2;
           I64[Hp - 464] = sat_sbLva_info;
           P64[Hp - 448] = R2;
           I64[Hp - 440] = sat_sbLv9_info;
           P64[Hp - 424] = R2;
           I64[Hp - 416] = sat_sbLv8_info;
           P64[Hp - 400] = R2;
           I64[Hp - 392] = sat_sbLv7_info;
           P64[Hp - 376] = R2;
           I64[Hp - 368] = sat_sbLv6_info;
           P64[Hp - 352] = R2;
           I64[Hp - 344] = sat_sbLv5_info;
           P64[Hp - 328] = R2;
           I64[Hp - 320] = sat_sbLv4_info;
           P64[Hp - 304] = R2;
           I64[Hp - 296] = sat_sbLv3_info;
           P64[Hp - 280] = R2;
           I64[Hp - 272] = sat_sbLv2_info;
           P64[Hp - 256] = R2;
           I64[Hp - 248] = sat_sbLv1_info;
           P64[Hp - 232] = R2;
           I64[Hp - 224] = sat_sbLv0_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_sbLuZ_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_sbLuY_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbLuX_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = GHC.Float.C:RealFloat_con_info;
           P64[Hp - 120] = Hp - 152;
           P64[Hp - 112] = Hp - 176;
           P64[Hp - 104] = Hp - 200;
           P64[Hp - 96] = Hp - 224;
           P64[Hp - 88] = Hp - 248;
           P64[Hp - 80] = Hp - 272;
           P64[Hp - 72] = Hp - 296;
           P64[Hp - 64] = Hp - 320;
           P64[Hp - 56] = Hp - 344;
           P64[Hp - 48] = Hp - 368;
           P64[Hp - 40] = Hp - 392;
           P64[Hp - 32] = Hp - 416;
           P64[Hp - 24] = Hp - 440;
           P64[Hp - 16] = Hp - 464;
           P64[Hp - 8] = Hp - 488;
           P64[Hp] = Hp - 512;
           R1 = Hp - 127;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.288751204 UTC

[section ""data" . Data.Functor.Identity.$fEnumIdentity_closure" {
     Data.Functor.Identity.$fEnumIdentity_closure:
         const Data.Functor.Identity.$fEnumIdentity_info;
 },
 sat_sbLvl_entry() //  [R1]
         { info_tbl: [(cbMeH,
                       label: sat_sbLvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMeH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMeI; else goto cbMeJ;
       cbMeI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMeJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvk_entry() //  [R1]
         { info_tbl: [(cbMeO,
                       label: sat_sbLvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMeO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMeP; else goto cbMeQ;
       cbMeP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMeQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvj_entry() //  [R1]
         { info_tbl: [(cbMeV,
                       label: sat_sbLvj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMeV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMeW; else goto cbMeX;
       cbMeW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMeX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvi_entry() //  [R1]
         { info_tbl: [(cbMf2,
                       label: sat_sbLvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMf2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMf3; else goto cbMf4;
       cbMf3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMf4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvh_entry() //  [R1]
         { info_tbl: [(cbMf9,
                       label: sat_sbLvh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMfa; else goto cbMfb;
       cbMfa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMfb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvg_entry() //  [R1]
         { info_tbl: [(cbMfg,
                       label: sat_sbLvg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMfg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMfh; else goto cbMfi;
       cbMfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMfi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvf_entry() //  [R1]
         { info_tbl: [(cbMfn,
                       label: sat_sbLvf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMfn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMfo; else goto cbMfp;
       cbMfo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMfp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLve_entry() //  [R1]
         { info_tbl: [(cbMfu,
                       label: sat_sbLve_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMfu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMfv; else goto cbMfw;
       cbMfv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMfw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fEnumIdentity_entry() //  [R2]
         { info_tbl: [(cbMfy,
                       label: Data.Functor.Identity.$fEnumIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMfy: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cbMfC; else goto cbMfB;
       cbMfC: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Functor.Identity.$fEnumIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMfB: // global
           I64[Hp - 256] = sat_sbLvl_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbLvk_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbLvj_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbLvi_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sbLvh_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbLvg_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbLvf_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbLve_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.308976087 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure" {
     Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure:
         const Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info;
 },
 sat_sbLvn_entry() //  [R1]
         { info_tbl: [(cbMgL,
                       label: sat_sbLvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMgL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMgM; else goto cbMgN;
       cbMgM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMgN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry() //  [R2]
         { info_tbl: [(cbMgO,
                       label: Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMgO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbMgS; else goto cbMgR;
       cbMgS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMgR: // global
           I64[Hp - 16] = sat_sbLvn_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEnumIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.31554853 UTC

[section ""data" . Data.Functor.Identity.$fIntegralIdentity_closure" {
     Data.Functor.Identity.$fIntegralIdentity_closure:
         const Data.Functor.Identity.$fIntegralIdentity_info;
 },
 sat_sbLvx_entry() //  [R1]
         { info_tbl: [(cbMhb,
                       label: sat_sbLvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhc; else goto cbMhd;
       cbMhc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvw_entry() //  [R1]
         { info_tbl: [(cbMhi,
                       label: sat_sbLvw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhj; else goto cbMhk;
       cbMhj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.divMod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvv_entry() //  [R1]
         { info_tbl: [(cbMhp,
                       label: sat_sbLvv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhq; else goto cbMhr;
       cbMhq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quotRem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvu_entry() //  [R1]
         { info_tbl: [(cbMhw,
                       label: sat_sbLvu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhx; else goto cbMhy;
       cbMhx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.mod_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvt_entry() //  [R1]
         { info_tbl: [(cbMhD,
                       label: sat_sbLvt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhE; else goto cbMhF;
       cbMhE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.div_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvs_entry() //  [R1]
         { info_tbl: [(cbMhK,
                       label: sat_sbLvs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhL; else goto cbMhM;
       cbMhL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.rem_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvr_entry() //  [R1]
         { info_tbl: [(cbMhR,
                       label: sat_sbLvr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhS; else goto cbMhT;
       cbMhS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMhT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.quot_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvq_entry() //  [R1]
         { info_tbl: [(cbMhY,
                       label: sat_sbLvq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMhY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMhZ; else goto cbMi0;
       cbMhZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMi0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp2Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvp_entry() //  [R1]
         { info_tbl: [(cbMi5,
                       label: sat_sbLvp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMi5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMi6; else goto cbMi7;
       cbMi6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMi7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fIntegralIdentity_$cp1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fIntegralIdentity_entry() //  [R2]
         { info_tbl: [(cbMi9,
                       label: Data.Functor.Identity.$fIntegralIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMi9: // global
           Hp = Hp + 296;
           if (Hp > HpLim) (likely: False) goto cbMid; else goto cbMic;
       cbMid: // global
           HpAlloc = 296;
           R2 = R2;
           R1 = Data.Functor.Identity.$fIntegralIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMic: // global
           I64[Hp - 288] = sat_sbLvx_info;
           P64[Hp - 272] = R2;
           I64[Hp - 264] = sat_sbLvw_info;
           P64[Hp - 248] = R2;
           I64[Hp - 240] = sat_sbLvv_info;
           P64[Hp - 224] = R2;
           I64[Hp - 216] = sat_sbLvu_info;
           P64[Hp - 200] = R2;
           I64[Hp - 192] = sat_sbLvt_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbLvs_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbLvr_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbLvq_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbLvp_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = GHC.Real.C:Integral_con_info;
           P64[Hp - 64] = Hp - 96;
           P64[Hp - 56] = Hp - 120;
           P64[Hp - 48] = Hp - 144;
           P64[Hp - 40] = Hp - 168;
           P64[Hp - 32] = Hp - 192;
           P64[Hp - 24] = Hp - 216;
           P64[Hp - 16] = Hp - 240;
           P64[Hp - 8] = Hp - 264;
           P64[Hp] = Hp - 288;
           R1 = Hp - 71;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.337476166 UTC

[section ""data" . Data.Functor.Identity.$fBoundedIdentity_closure" {
     Data.Functor.Identity.$fBoundedIdentity_closure:
         const Data.Functor.Identity.$fBoundedIdentity_info;
 },
 sat_sbLvA_entry() //  [R1]
         { info_tbl: [(cbMjt,
                       label: sat_sbLvA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMjt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMju; else goto cbMjv;
       cbMju: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMjv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvz_entry() //  [R1]
         { info_tbl: [(cbMjA,
                       label: sat_sbLvz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMjA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMjB; else goto cbMjC;
       cbMjB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMjC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBoundedIdentity_entry() //  [R2]
         { info_tbl: [(cbMjE,
                       label: Data.Functor.Identity.$fBoundedIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMjE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbMjI; else goto cbMjH;
       cbMjI: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBoundedIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMjH: // global
           I64[Hp - 64] = sat_sbLvA_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbLvz_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.344956026 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure" {
     Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure:
         const Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info;
 },
 sat_sbLvC_entry() //  [R1]
         { info_tbl: [(cbMkb,
                       label: sat_sbLvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMkb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMkc; else goto cbMkd;
       cbMkc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMkd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry() //  [R2]
         { info_tbl: [(cbMke,
                       label: Data.Functor.Identity.$fBitsIdentity_$cp1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMke: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbMki; else goto cbMkh;
       cbMki: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_$cp1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMkh: // global
           I64[Hp - 16] = sat_sbLvC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fEqIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.353618435 UTC

[section ""data" . Data.Functor.Identity.$fBitsIdentity_closure" {
     Data.Functor.Identity.$fBitsIdentity_closure:
         const Data.Functor.Identity.$fBitsIdentity_info;
 },
 sat_sbLw0_entry() //  [R1]
         { info_tbl: [(cbMkB,
                       label: sat_sbLw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMkB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMkC; else goto cbMkD;
       cbMkC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMkD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.popCount_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvZ_entry() //  [R1]
         { info_tbl: [(cbMkI,
                       label: sat_sbLvZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMkI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMkJ; else goto cbMkK;
       cbMkJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMkK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvY_entry() //  [R1]
         { info_tbl: [(cbMkP,
                       label: sat_sbLvY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMkP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMkQ; else goto cbMkR;
       cbMkQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotateL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvX_entry() //  [R1]
         { info_tbl: [(cbMkW,
                       label: sat_sbLvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMkW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMkX; else goto cbMkY;
       cbMkX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMkY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvW_entry() //  [R1]
         { info_tbl: [(cbMl3,
                       label: sat_sbLvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMl3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMl4; else goto cbMl5;
       cbMl4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMl5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftR_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvV_entry() //  [R1]
         { info_tbl: [(cbMla,
                       label: sat_sbLvV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMla: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlb; else goto cbMlc;
       cbMlb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.unsafeShiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvU_entry() //  [R1]
         { info_tbl: [(cbMlh,
                       label: sat_sbLvU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMli; else goto cbMlj;
       cbMli: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shiftL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvT_entry() //  [R1]
         { info_tbl: [(cbMlo,
                       label: sat_sbLvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlp; else goto cbMlq;
       cbMlp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvS_entry() //  [R1]
         { info_tbl: [(cbMlv,
                       label: sat_sbLvS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlw; else goto cbMlx;
       cbMlw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvR_entry() //  [R1]
         { info_tbl: [(cbMlC,
                       label: sat_sbLvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlD; else goto cbMlE;
       cbMlD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvQ_entry() //  [R1]
         { info_tbl: [(cbMlJ,
                       label: sat_sbLvQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlK; else goto cbMlL;
       cbMlK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.testBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvP_entry() //  [R1]
         { info_tbl: [(cbMlQ,
                       label: sat_sbLvP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlR; else goto cbMlS;
       cbMlR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complementBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvO_entry() //  [R1]
         { info_tbl: [(cbMlX,
                       label: sat_sbLvO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMlX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMlY; else goto cbMlZ;
       cbMlY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMlZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.clearBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvN_entry() //  [R1]
         { info_tbl: [(cbMm4,
                       label: sat_sbLvN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMm4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMm5; else goto cbMm6;
       cbMm5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMm6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.setBit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvM_entry() //  [R1]
         { info_tbl: [(cbMmb,
                       label: sat_sbLvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmc; else goto cbMmd;
       cbMmc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.bit_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvL_entry() //  [R1]
         { info_tbl: [(cbMmi,
                       label: sat_sbLvL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmj; else goto cbMmk;
       cbMmj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.zeroBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvK_entry() //  [R1]
         { info_tbl: [(cbMmp,
                       label: sat_sbLvK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmq; else goto cbMmr;
       cbMmq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.rotate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvJ_entry() //  [R1]
         { info_tbl: [(cbMmw,
                       label: sat_sbLvJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmx; else goto cbMmy;
       cbMmx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.shift_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvI_entry() //  [R1]
         { info_tbl: [(cbMmD,
                       label: sat_sbLvI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmE; else goto cbMmF;
       cbMmE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.complement_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvH_entry() //  [R1]
         { info_tbl: [(cbMmK,
                       label: sat_sbLvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmL; else goto cbMmM;
       cbMmL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.xor_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvG_entry() //  [R1]
         { info_tbl: [(cbMmR,
                       label: sat_sbLvG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmS; else goto cbMmT;
       cbMmS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMmT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..|._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvF_entry() //  [R1]
         { info_tbl: [(cbMmY,
                       label: sat_sbLvF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMmY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMmZ; else goto cbMn0;
       cbMmZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMn0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits..&._entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLvE_entry() //  [R1]
         { info_tbl: [(cbMn5,
                       label: sat_sbLvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMn5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMn6; else goto cbMn7;
       cbMn6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMn7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fBitsIdentity_$cp1Bits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbMn9,
                       label: Data.Functor.Identity.$fBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMn9: // global
           Hp = Hp + 744;
           if (Hp > HpLim) (likely: False) goto cbMnd; else goto cbMnc;
       cbMnd: // global
           HpAlloc = 744;
           R2 = R2;
           R1 = Data.Functor.Identity.$fBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMnc: // global
           I64[Hp - 736] = sat_sbLw0_info;
           P64[Hp - 720] = R2;
           I64[Hp - 712] = sat_sbLvZ_info;
           P64[Hp - 696] = R2;
           I64[Hp - 688] = sat_sbLvY_info;
           P64[Hp - 672] = R2;
           I64[Hp - 664] = sat_sbLvX_info;
           P64[Hp - 648] = R2;
           I64[Hp - 640] = sat_sbLvW_info;
           P64[Hp - 624] = R2;
           I64[Hp - 616] = sat_sbLvV_info;
           P64[Hp - 600] = R2;
           I64[Hp - 592] = sat_sbLvU_info;
           P64[Hp - 576] = R2;
           I64[Hp - 568] = sat_sbLvT_info;
           P64[Hp - 552] = R2;
           I64[Hp - 544] = sat_sbLvS_info;
           P64[Hp - 528] = R2;
           I64[Hp - 520] = sat_sbLvR_info;
           P64[Hp - 504] = R2;
           I64[Hp - 496] = sat_sbLvQ_info;
           P64[Hp - 480] = R2;
           I64[Hp - 472] = sat_sbLvP_info;
           P64[Hp - 456] = R2;
           I64[Hp - 448] = sat_sbLvO_info;
           P64[Hp - 432] = R2;
           I64[Hp - 424] = sat_sbLvN_info;
           P64[Hp - 408] = R2;
           I64[Hp - 400] = sat_sbLvM_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_sbLvL_info;
           P64[Hp - 360] = R2;
           I64[Hp - 352] = sat_sbLvK_info;
           P64[Hp - 336] = R2;
           I64[Hp - 328] = sat_sbLvJ_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_sbLvI_info;
           P64[Hp - 288] = R2;
           I64[Hp - 280] = sat_sbLvH_info;
           P64[Hp - 264] = R2;
           I64[Hp - 256] = sat_sbLvG_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_sbLvF_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_sbLvE_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = Hp - 208;
           P64[Hp - 168] = Hp - 232;
           P64[Hp - 160] = Hp - 256;
           P64[Hp - 152] = Hp - 280;
           P64[Hp - 144] = Hp - 304;
           P64[Hp - 136] = Hp - 328;
           P64[Hp - 128] = Hp - 352;
           P64[Hp - 120] = Hp - 376;
           P64[Hp - 112] = Hp - 400;
           P64[Hp - 104] = Hp - 424;
           P64[Hp - 96] = Hp - 448;
           P64[Hp - 88] = Hp - 472;
           P64[Hp - 80] = Hp - 496;
           P64[Hp - 72] = Hp - 520;
           P64[Hp - 64] = Hp - 544;
           P64[Hp - 56] = Hp - 568;
           P64[Hp - 48] = Hp - 592;
           P64[Hp - 40] = Hp - 616;
           P64[Hp - 32] = Hp - 640;
           P64[Hp - 24] = Hp - 664;
           P64[Hp - 16] = Hp - 688;
           P64[Hp - 8] = Hp - 712;
           P64[Hp] = Hp - 736;
           R1 = Hp - 183;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.402047958 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info;
 },
 sat_sbLw2_entry() //  [R1]
         { info_tbl: [(cbMq3,
                       label: sat_sbLw2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMq3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMq4; else goto cbMq5;
       cbMq4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMq5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry() //  [R2]
         { info_tbl: [(cbMq6,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMq6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbMqa; else goto cbMq9;
       cbMqa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMq9: // global
           I64[Hp - 16] = sat_sbLw2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Functor.Identity.$fBitsIdentity_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.408159804 UTC

[section ""data" . Data.Functor.Identity.$fFiniteBitsIdentity_closure" {
     Data.Functor.Identity.$fFiniteBitsIdentity_closure:
         const Data.Functor.Identity.$fFiniteBitsIdentity_info;
 },
 sat_sbLw7_entry() //  [R1]
         { info_tbl: [(cbMqt,
                       label: sat_sbLw7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMqu; else goto cbMqv;
       cbMqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMqv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countTrailingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLw6_entry() //  [R1]
         { info_tbl: [(cbMqA,
                       label: sat_sbLw6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMqB; else goto cbMqC;
       cbMqB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMqC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.countLeadingZeros_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLw5_entry() //  [R1]
         { info_tbl: [(cbMqH,
                       label: sat_sbLw5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMqH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMqI; else goto cbMqJ;
       cbMqI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMqJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbLw4_entry() //  [R1]
         { info_tbl: [(cbMqO,
                       label: sat_sbLw4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMqO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMqP; else goto cbMqQ;
       cbMqP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbMqQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Functor.Identity.$fFiniteBitsIdentity_entry() //  [R2]
         { info_tbl: [(cbMqS,
                       label: Data.Functor.Identity.$fFiniteBitsIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMqS: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbMqW; else goto cbMqV;
       cbMqW: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Functor.Identity.$fFiniteBitsIdentity_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMqV: // global
           I64[Hp - 128] = sat_sbLw7_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbLw6_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbLw5_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbLw4_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.420572278 UTC

[section ""data" . Data.Functor.Identity.runIdentity_closure" {
     Data.Functor.Identity.runIdentity_closure:
         const Data.Functor.Identity.runIdentity_info;
 },
 Data.Functor.Identity.runIdentity_entry() //  [R2]
         { info_tbl: [(cbMrz,
                       label: Data.Functor.Identity.runIdentity_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMrz: // global
           R2 = R2;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.42411065 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure:
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info;
 },
 Data.Functor.Identity.$fMonadFixIdentity_$cmfix_entry() //  [R2]
         { info_tbl: [(cbMrL,
                       label: Data.Functor.Identity.$fMonadFixIdentity_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMrL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbMrP; else goto cbMrO;
       cbMrP: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbMrO: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbMrK::P64 = Hp - 24;
           P64[Hp] = _cbMrK::P64;
           R1 = _cbMrK::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.427945881 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>=_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>=_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbMrZ,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMrZ: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.43119133 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_$c>>_closure" {
     Data.Functor.Identity.$fMonadIdentity_$c>>_closure:
         const Data.Functor.Identity.$fMonadIdentity_$c>>_info;
 },
 Data.Functor.Identity.$fMonadIdentity_$c>>_entry() //  [R2, R3]
         { info_tbl: [(cbMsa,
                       label: Data.Functor.Identity.$fMonadIdentity_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMsa: // global
           R3 = R3;
           R2 = R2;
           call Data.Functor.Identity.$fApplicativeIdentity_$c*>_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.43452275 UTC

[section ""data" . lvl_rbJt6_closure" {
     lvl_rbJt6_closure:
         const lvl_rbJt6_info;
         const 0;
 },
 lvl_rbJt6_entry() //  [R2]
         { info_tbl: [(cbMsl,
                       label: lvl_rbJt6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMsl: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.437669477 UTC

[section ""data" . Data.Functor.Identity.$fMonadIdentity_closure" {
     Data.Functor.Identity.$fMonadIdentity_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Functor.Identity.$fApplicativeIdentity_closure+1;
         const Data.Functor.Identity.$fMonadIdentity_$c>>=_closure+2;
         const Data.Functor.Identity.$fMonadIdentity_$c>>_closure+2;
         const Data.Functor.Identity.$fApplicativeIdentity3_closure+1;
         const lvl_rbJt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.43950523 UTC

[section ""data" . Data.Functor.Identity.$fMonadFixIdentity_closure" {
     Data.Functor.Identity.$fMonadFixIdentity_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure+1;
         const Data.Functor.Identity.$fMonadFixIdentity_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.442125882 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity5_closure" {
     Data.Functor.Identity.$fFoldableIdentity5_closure:
         const Data.Functor.Identity.$fFoldableIdentity5_info;
 },
 Data.Functor.Identity.$fFoldableIdentity5_entry() //  [R3]
         { info_tbl: [(cbMsy,
                       label: Data.Functor.Identity.$fFoldableIdentity5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMsy: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.446120312 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity3_closure" {
     Data.Functor.Identity.$fFoldableIdentity3_closure:
         const Data.Functor.Identity.$fFoldableIdentity3_info;
 },
 Data.Functor.Identity.$fFoldableIdentity3_entry() //  [R3]
         { info_tbl: [(cbMsJ,
                       label: Data.Functor.Identity.$fFoldableIdentity3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMsJ: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.4493705 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity1_closure" {
     Data.Functor.Identity.$fFoldableIdentity1_closure:
         const Data.Functor.Identity.$fFoldableIdentity1_info;
 },
 Data.Functor.Identity.$fFoldableIdentity1_entry() //  [R3]
         { info_tbl: [(cbMsU,
                       label: Data.Functor.Identity.$fFoldableIdentity1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMsU: // global
           R2 = R3;
           call Data.Functor.Identity.$fFoldableIdentity2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.452683977 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity8_closure" {
     Data.Functor.Identity.$fFoldableIdentity8_closure:
         const Data.Functor.Identity.$fFoldableIdentity8_info;
 },
 Data.Functor.Identity.$fFoldableIdentity8_entry() //  [R3]
         { info_tbl: [(cbMt5,
                       label: Data.Functor.Identity.$fFoldableIdentity8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMt5: // global
           R2 = R3;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.456370704 UTC

[section ""data" . Data.Functor.Identity.$fFoldableIdentity_closure" {
     Data.Functor.Identity.$fFoldableIdentity_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Functor.Identity.$fFoldableIdentity8_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity7_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity_$cfoldr_closure+3;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity6_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity5_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity_$ctoList_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$cnull_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity_$clength_closure+1;
         const GHC.Classes.==_closure+1;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity3_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const Data.Functor.Identity.$fFoldableIdentity1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.458461302 UTC

[section ""cstring" . Data.Functor.Identity.$trModule4_bytes" {
     Data.Functor.Identity.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.46014181 UTC

[section ""data" . Data.Functor.Identity.$trModule3_closure" {
     Data.Functor.Identity.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.461872364 UTC

[section ""cstring" . Data.Functor.Identity.$trModule2_bytes" {
     Data.Functor.Identity.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,117,110,99,116,111,114,46,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.463472725 UTC

[section ""data" . Data.Functor.Identity.$trModule1_closure" {
     Data.Functor.Identity.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.465182788 UTC

[section ""data" . Data.Functor.Identity.$trModule_closure" {
     Data.Functor.Identity.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Functor.Identity.$trModule3_closure+1;
         const Data.Functor.Identity.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.46701279 UTC

[section ""data" . $krep_rbJt7_closure" {
     $krep_rbJt7_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.46870254 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity1_closure" {
     Data.Functor.Identity.$tcIdentity1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$fReadIdentity6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.470735953 UTC

[section ""data" . Data.Functor.Identity.$tcIdentity_closure" {
     Data.Functor.Identity.$tcIdentity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tcIdentity1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 3410104521590905987;
         const 16392070908630191652;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.473232268 UTC

[section ""data" . $krep1_rbJt8_closure" {
     $krep1_rbJt8_closure:
         const :_con_info;
         const $krep_rbJt7_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.474924536 UTC

[section ""data" . $krep2_rbJt9_closure" {
     $krep2_rbJt9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Functor.Identity.$tcIdentity_closure+1;
         const $krep1_rbJt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.476536761 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity1_closure" {
     Data.Functor.Identity.$tc'Identity1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbJt7_closure+2;
         const $krep2_rbJt9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.478304657 UTC

[section ""cstring" . Data.Functor.Identity.$tc'Identity3_bytes" {
     Data.Functor.Identity.$tc'Identity3_bytes:
         I8[] [39,73,100,101,110,116,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.479938991 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity2_closure" {
     Data.Functor.Identity.$tc'Identity2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Functor.Identity.$tc'Identity3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.481630601 UTC

[section ""data" . Data.Functor.Identity.$tc'Identity_closure" {
     Data.Functor.Identity.$tc'Identity_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Functor.Identity.$trModule_closure+1;
         const Data.Functor.Identity.$tc'Identity2_closure+1;
         const Data.Functor.Identity.$tc'Identity1_closure+4;
         const 11920310844698764515;
         const 3935129235072617509;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:39.483374033 UTC

[section ""relreadonly" . SbLym_srt" {
     SbLym_srt:
         const Data.Functor.Identity.$fReadIdentity5_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Data.Functor.Identity.$w$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadsPrec_closure;
         const Data.Functor.Identity.$fReadIdentity3_closure;
         const GHC.Read.list_closure;
         const Data.Functor.Identity.$fReadIdentity_$creadList_closure;
         const Data.Functor.Identity.$w$creadListPrec_closure;
         const Data.Functor.Identity.$fReadIdentity_closure;
         const Data.Functor.Identity.$fShowIdentity1_closure;
         const Data.Functor.Identity.$w$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowsPrec_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshow_closure;
         const Data.Functor.Identity.$fShowIdentity_$cshowList_closure;
         const Data.Functor.Identity.$fShowIdentity_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
 }]

