
==================== Tidy Core ====================
2018-03-16 16:06:57.847484107 UTC

Result size of Tidy Core
  = {terms: 898, types: 1,062, coercions: 400, joins: 0/16}

-- RHS size: {terms: 8, types: 78, coercions: 156, joins: 0/0}
Data.Version.$fGenericVersion_$cto
  :: forall x. Rep Version x -> Version
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ x_ac3pl) (ds_dc3to [Occ=Once] :: Rep Version x_ac3pl) ->
                 case ds_dc3to
                      `cast` ((Sub (Data.Version.Rep_Version[0]) ; (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <D>_P
                                                                        <'MetaData
                                                                           "Version"
                                                                           "Data.Version"
                                                                           "base"
                                                                           'GHC.Types.False>_P
                                                                        <M1
                                                                           C
                                                                           ('MetaCons
                                                                              "Version"
                                                                              'PrefixI
                                                                              'GHC.Types.True)
                                                                           (M1
                                                                              S
                                                                              ('MetaSel
                                                                                 ('GHC.Base.Just
                                                                                    "versionBranch")
                                                                                 'NoSourceUnpackedness
                                                                                 'NoSourceStrictness
                                                                                 'DecidedLazy)
                                                                              (K1 R [Int])
                                                                            :*: M1
                                                                                  S
                                                                                  ('MetaSel
                                                                                     ('GHC.Base.Just
                                                                                        "versionTags")
                                                                                     'NoSourceUnpackedness
                                                                                     'NoSourceStrictness
                                                                                     'DecidedLazy)
                                                                                  (K1
                                                                                     R
                                                                                     [String]))>_R ; GHC.Generics.N:M1[0]
                                                                                                         <*>_N
                                                                                                         <C>_P
                                                                                                         <'MetaCons
                                                                                                            "Version"
                                                                                                            'PrefixI
                                                                                                            'GHC.Types.True>_P
                                                                                                         <M1
                                                                                                            S
                                                                                                            ('MetaSel
                                                                                                               ('GHC.Base.Just
                                                                                                                  "versionBranch")
                                                                                                               'NoSourceUnpackedness
                                                                                                               'NoSourceStrictness
                                                                                                               'DecidedLazy)
                                                                                                            (K1
                                                                                                               R
                                                                                                               [Int])
                                                                                                          :*: M1
                                                                                                                S
                                                                                                                ('MetaSel
                                                                                                                   ('GHC.Base.Just
                                                                                                                      "versionTags")
                                                                                                                   'NoSourceUnpackedness
                                                                                                                   'NoSourceStrictness
                                                                                                                   'DecidedLazy)
                                                                                                                (K1
                                                                                                                   R
                                                                                                                   [String])>_R)) <x_ac3pl>_N
                              :: (Rep Version x_ac3pl :: *)
                                 ~R# ((:*:)
                                        (M1
                                           S
                                           ('MetaSel
                                              ('GHC.Base.Just "versionBranch")
                                              'NoSourceUnpackedness
                                              'NoSourceStrictness
                                              'DecidedLazy)
                                           (K1 R [Int]))
                                        (M1
                                           S
                                           ('MetaSel
                                              ('GHC.Base.Just "versionTags")
                                              'NoSourceUnpackedness
                                              'NoSourceStrictness
                                              'DecidedLazy)
                                           (K1 R [String]))
                                        x_ac3pl :: *))
                 of
                 { :*: ds1_dc3tr [Occ=Once] ds2_dc3ts [Occ=Once] ->
                 Data.Version.Version
                   (ds1_dc3tr
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <S>_P
                                <'MetaSel
                                   ('GHC.Base.Just "versionBranch")
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy>_P
                                <K1 R [Int]>_R <x_ac3pl>_N ; GHC.Generics.N:K1[0]
                                                                 <*>_N <R>_P <[Int]>_R <x_ac3pl>_P
                            :: (M1
                                  S
                                  ('MetaSel
                                     ('GHC.Base.Just "versionBranch")
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R [Int])
                                  x_ac3pl :: *)
                               ~R# ([Int] :: *)))
                   (ds2_dc3ts
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <S>_P
                                <'MetaSel
                                   ('GHC.Base.Just "versionTags")
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy>_P
                                <K1 R [String]>_R <x_ac3pl>_N ; GHC.Generics.N:K1[0]
                                                                    <*>_N
                                                                    <R>_P
                                                                    <[String]>_R
                                                                    <x_ac3pl>_P
                            :: (M1
                                  S
                                  ('MetaSel
                                     ('GHC.Base.Just "versionTags")
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R [String])
                                  x_ac3pl :: *)
                               ~R# ([String] :: *)))
                 }}]
Data.Version.$fGenericVersion_$cto
  = \ (@ x_ac3pl) (ds_dc3to :: Rep Version x_ac3pl) ->
      case ds_dc3to
           `cast` ((Sub (Data.Version.Rep_Version[0]) ; (GHC.Generics.N:M1[0]
                                                             <*>_N
                                                             <D>_P
                                                             <'MetaData
                                                                "Version"
                                                                "Data.Version"
                                                                "base"
                                                                'GHC.Types.False>_P
                                                             <M1
                                                                C
                                                                ('MetaCons
                                                                   "Version"
                                                                   'PrefixI
                                                                   'GHC.Types.True)
                                                                (M1
                                                                   S
                                                                   ('MetaSel
                                                                      ('GHC.Base.Just
                                                                         "versionBranch")
                                                                      'NoSourceUnpackedness
                                                                      'NoSourceStrictness
                                                                      'DecidedLazy)
                                                                   (K1 R [Int])
                                                                 :*: M1
                                                                       S
                                                                       ('MetaSel
                                                                          ('GHC.Base.Just
                                                                             "versionTags")
                                                                          'NoSourceUnpackedness
                                                                          'NoSourceStrictness
                                                                          'DecidedLazy)
                                                                       (K1
                                                                          R
                                                                          [String]))>_R ; GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "Version"
                                                                                                 'PrefixI
                                                                                                 'GHC.Types.True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('GHC.Base.Just
                                                                                                       "versionBranch")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 (K1
                                                                                                    R
                                                                                                    [Int])
                                                                                               :*: M1
                                                                                                     S
                                                                                                     ('MetaSel
                                                                                                        ('GHC.Base.Just
                                                                                                           "versionTags")
                                                                                                        'NoSourceUnpackedness
                                                                                                        'NoSourceStrictness
                                                                                                        'DecidedLazy)
                                                                                                     (K1
                                                                                                        R
                                                                                                        [String])>_R)) <x_ac3pl>_N
                   :: (Rep Version x_ac3pl :: *)
                      ~R# ((:*:)
                             (M1
                                S
                                ('MetaSel
                                   ('GHC.Base.Just "versionBranch")
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy)
                                (K1 R [Int]))
                             (M1
                                S
                                ('MetaSel
                                   ('GHC.Base.Just "versionTags")
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy)
                                (K1 R [String]))
                             x_ac3pl :: *))
      of
      { :*: ds1_dc3tr ds2_dc3ts ->
      Data.Version.Version
        (ds1_dc3tr
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <S>_P
                     <'MetaSel
                        ('GHC.Base.Just "versionBranch")
                        'NoSourceUnpackedness
                        'NoSourceStrictness
                        'DecidedLazy>_P
                     <K1 R [Int]>_R <x_ac3pl>_N ; GHC.Generics.N:K1[0]
                                                      <*>_N <R>_P <[Int]>_R <x_ac3pl>_P
                 :: (M1
                       S
                       ('MetaSel
                          ('GHC.Base.Just "versionBranch")
                          'NoSourceUnpackedness
                          'NoSourceStrictness
                          'DecidedLazy)
                       (K1 R [Int])
                       x_ac3pl :: *)
                    ~R# ([Int] :: *)))
        (ds2_dc3ts
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <S>_P
                     <'MetaSel
                        ('GHC.Base.Just "versionTags")
                        'NoSourceUnpackedness
                        'NoSourceStrictness
                        'DecidedLazy>_P
                     <K1 R [String]>_R <x_ac3pl>_N ; GHC.Generics.N:K1[0]
                                                         <*>_N <R>_P <[String]>_R <x_ac3pl>_P
                 :: (M1
                       S
                       ('MetaSel
                          ('GHC.Base.Just "versionTags")
                          'NoSourceUnpackedness
                          'NoSourceStrictness
                          'DecidedLazy)
                       (K1 R [String])
                       x_ac3pl :: *)
                    ~R# ([String] :: *)))
      }

-- RHS size: {terms: 8, types: 44, coercions: 103, joins: 0/0}
Data.Version.$fGenericVersion1
  :: forall x.
     Version
     -> M1
          C
          ('MetaCons "Version" 'PrefixI 'GHC.Types.True)
          (M1
             S
             ('MetaSel
                ('GHC.Base.Just "versionBranch")
                'NoSourceUnpackedness
                'NoSourceStrictness
                'DecidedLazy)
             (K1 R [Int])
           :*: M1
                 S
                 ('MetaSel
                    ('GHC.Base.Just "versionTags")
                    'NoSourceUnpackedness
                    'NoSourceStrictness
                    'DecidedLazy)
                 (K1 R [String]))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ x_ac3oG) (x1_ac3lD [Occ=Once!] :: Version) ->
                 case x1_ac3lD of
                 { Version g1_ac3lE [Occ=Once] g2_ac3lF [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ *
                    @ (M1
                         S
                         ('MetaSel
                            ('GHC.Base.Just "versionBranch")
                            'NoSourceUnpackedness
                            'NoSourceStrictness
                            'DecidedLazy)
                         (K1 R [Int]))
                    @ (M1
                         S
                         ('MetaSel
                            ('GHC.Base.Just "versionTags")
                            'NoSourceUnpackedness
                            'NoSourceStrictness
                            'DecidedLazy)
                         (K1 R [String]))
                    @ x_ac3oG
                    (g1_ac3lE
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N <R>_P <[Int]>_R <x_ac3oG>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('GHC.Base.Just
                                                                                          "versionBranch")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <K1
                                                                                       R
                                                                                       [Int]>_R) <x_ac3oG>_N
                             :: ([Int] :: *)
                                ~R# (M1
                                       S
                                       ('MetaSel
                                          ('GHC.Base.Just "versionBranch")
                                          'NoSourceUnpackedness
                                          'NoSourceStrictness
                                          'DecidedLazy)
                                       (K1 R [Int])
                                       x_ac3oG :: *)))
                    (g2_ac3lF
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <R>_P
                                      <[String]>_R
                                      <x_ac3oG>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <S>_P
                                                              <'MetaSel
                                                                 ('GHC.Base.Just "versionTags")
                                                                 'NoSourceUnpackedness
                                                                 'NoSourceStrictness
                                                                 'DecidedLazy>_P
                                                              <K1 R [String]>_R) <x_ac3oG>_N
                             :: ([String] :: *)
                                ~R# (M1
                                       S
                                       ('MetaSel
                                          ('GHC.Base.Just "versionTags")
                                          'NoSourceUnpackedness
                                          'NoSourceStrictness
                                          'DecidedLazy)
                                       (K1 R [String])
                                       x_ac3oG :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <C>_P
                                  <'MetaCons "Version" 'PrefixI 'GHC.Types.True>_P
                                  <M1
                                     S
                                     ('MetaSel
                                        ('GHC.Base.Just "versionBranch")
                                        'NoSourceUnpackedness
                                        'NoSourceStrictness
                                        'DecidedLazy)
                                     (K1 R [Int])
                                   :*: M1
                                         S
                                         ('MetaSel
                                            ('GHC.Base.Just "versionTags")
                                            'NoSourceUnpackedness
                                            'NoSourceStrictness
                                            'DecidedLazy)
                                         (K1 R [String])>_R) <x_ac3oG>_N
                         :: ((:*:)
                               (M1
                                  S
                                  ('MetaSel
                                     ('GHC.Base.Just "versionBranch")
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R [Int]))
                               (M1
                                  S
                                  ('MetaSel
                                     ('GHC.Base.Just "versionTags")
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R [String]))
                               x_ac3oG :: *)
                            ~R# (M1
                                   C
                                   ('MetaCons "Version" 'PrefixI 'GHC.Types.True)
                                   (M1
                                      S
                                      ('MetaSel
                                         ('GHC.Base.Just "versionBranch")
                                         'NoSourceUnpackedness
                                         'NoSourceStrictness
                                         'DecidedLazy)
                                      (K1 R [Int])
                                    :*: M1
                                          S
                                          ('MetaSel
                                             ('GHC.Base.Just "versionTags")
                                             'NoSourceUnpackedness
                                             'NoSourceStrictness
                                             'DecidedLazy)
                                          (K1 R [String]))
                                   x_ac3oG :: *))
                 }}]
Data.Version.$fGenericVersion1
  = \ (@ x_ac3oG) (x1_ac3lD :: Version) ->
      case x1_ac3lD of { Version g1_ac3lE g2_ac3lF ->
      (GHC.Generics.:*:
         @ *
         @ (M1
              S
              ('MetaSel
                 ('GHC.Base.Just "versionBranch")
                 'NoSourceUnpackedness
                 'NoSourceStrictness
                 'DecidedLazy)
              (K1 R [Int]))
         @ (M1
              S
              ('MetaSel
                 ('GHC.Base.Just "versionTags")
                 'NoSourceUnpackedness
                 'NoSourceStrictness
                 'DecidedLazy)
              (K1 R [String]))
         @ x_ac3oG
         (g1_ac3lE
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N <R>_P <[Int]>_R <x_ac3oG>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <S>_P
                                                                         <'MetaSel
                                                                            ('GHC.Base.Just
                                                                               "versionBranch")
                                                                            'NoSourceUnpackedness
                                                                            'NoSourceStrictness
                                                                            'DecidedLazy>_P
                                                                         <K1 R [Int]>_R) <x_ac3oG>_N
                  :: ([Int] :: *)
                     ~R# (M1
                            S
                            ('MetaSel
                               ('GHC.Base.Just "versionBranch")
                               'NoSourceUnpackedness
                               'NoSourceStrictness
                               'DecidedLazy)
                            (K1 R [Int])
                            x_ac3oG :: *)))
         (g2_ac3lF
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N <R>_P <[String]>_R <x_ac3oG>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               ('GHC.Base.Just
                                                                                  "versionTags")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               [String]>_R) <x_ac3oG>_N
                  :: ([String] :: *)
                     ~R# (M1
                            S
                            ('MetaSel
                               ('GHC.Base.Just "versionTags")
                               'NoSourceUnpackedness
                               'NoSourceStrictness
                               'DecidedLazy)
                            (K1 R [String])
                            x_ac3oG :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <*>_N
                       <C>_P
                       <'MetaCons "Version" 'PrefixI 'GHC.Types.True>_P
                       <M1
                          S
                          ('MetaSel
                             ('GHC.Base.Just "versionBranch")
                             'NoSourceUnpackedness
                             'NoSourceStrictness
                             'DecidedLazy)
                          (K1 R [Int])
                        :*: M1
                              S
                              ('MetaSel
                                 ('GHC.Base.Just "versionTags")
                                 'NoSourceUnpackedness
                                 'NoSourceStrictness
                                 'DecidedLazy)
                              (K1 R [String])>_R) <x_ac3oG>_N
              :: ((:*:)
                    (M1
                       S
                       ('MetaSel
                          ('GHC.Base.Just "versionBranch")
                          'NoSourceUnpackedness
                          'NoSourceStrictness
                          'DecidedLazy)
                       (K1 R [Int]))
                    (M1
                       S
                       ('MetaSel
                          ('GHC.Base.Just "versionTags")
                          'NoSourceUnpackedness
                          'NoSourceStrictness
                          'DecidedLazy)
                       (K1 R [String]))
                    x_ac3oG :: *)
                 ~R# (M1
                        C
                        ('MetaCons "Version" 'PrefixI 'GHC.Types.True)
                        (M1
                           S
                           ('MetaSel
                              ('GHC.Base.Just "versionBranch")
                              'NoSourceUnpackedness
                              'NoSourceStrictness
                              'DecidedLazy)
                           (K1 R [Int])
                         :*: M1
                               S
                               ('MetaSel
                                  ('GHC.Base.Just "versionTags")
                                  'NoSourceUnpackedness
                                  'NoSourceStrictness
                                  'DecidedLazy)
                               (K1 R [String]))
                        x_ac3oG :: *))
      }

-- RHS size: {terms: 3, types: 1, coercions: 64, joins: 0/0}
Data.Version.$fGenericVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic Version
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic TYPE: Version
                              Data.Version.$fGenericVersion1
                              `cast` (forall (x :: <*>_N).
                                      <Version>_R
                                      ->_R (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <D>_P
                                                     <'MetaData
                                                        "Version"
                                                        "Data.Version"
                                                        "base"
                                                        'GHC.Types.False>_P
                                                     <M1
                                                        C
                                                        ('MetaCons
                                                           "Version" 'PrefixI 'GHC.Types.True)
                                                        (M1
                                                           S
                                                           ('MetaSel
                                                              ('GHC.Base.Just "versionBranch")
                                                              'NoSourceUnpackedness
                                                              'NoSourceStrictness
                                                              'DecidedLazy)
                                                           (K1 R [Int])
                                                         :*: M1
                                                               S
                                                               ('MetaSel
                                                                  ('GHC.Base.Just "versionTags")
                                                                  'NoSourceUnpackedness
                                                                  'NoSourceStrictness
                                                                  'DecidedLazy)
                                                               (K1
                                                                  R
                                                                  [String]))>_R) ; Sub (Sym (Data.Version.Rep_Version[0]))) <x>_N
                                      :: (forall x.
                                          Version
                                          -> M1
                                               C
                                               ('MetaCons "Version" 'PrefixI 'GHC.Types.True)
                                               (M1
                                                  S
                                                  ('MetaSel
                                                     ('GHC.Base.Just "versionBranch")
                                                     'NoSourceUnpackedness
                                                     'NoSourceStrictness
                                                     'DecidedLazy)
                                                  (K1 R [Int])
                                                :*: M1
                                                      S
                                                      ('MetaSel
                                                         ('GHC.Base.Just "versionTags")
                                                         'NoSourceUnpackedness
                                                         'NoSourceStrictness
                                                         'DecidedLazy)
                                                      (K1 R [String]))
                                               x :: *)
                                         ~R# (forall x. Version -> Rep Version x :: *))
                              Data.Version.$fGenericVersion_$cto]
Data.Version.$fGenericVersion
  = GHC.Generics.C:Generic
      @ Version
      (Data.Version.$fGenericVersion1
       `cast` (forall (x :: <*>_N).
               <Version>_R
               ->_R (Sym (GHC.Generics.N:M1[0]
                              <*>_N
                              <D>_P
                              <'MetaData "Version" "Data.Version" "base" 'GHC.Types.False>_P
                              <M1
                                 C
                                 ('MetaCons "Version" 'PrefixI 'GHC.Types.True)
                                 (M1
                                    S
                                    ('MetaSel
                                       ('GHC.Base.Just "versionBranch")
                                       'NoSourceUnpackedness
                                       'NoSourceStrictness
                                       'DecidedLazy)
                                    (K1 R [Int])
                                  :*: M1
                                        S
                                        ('MetaSel
                                           ('GHC.Base.Just "versionTags")
                                           'NoSourceUnpackedness
                                           'NoSourceStrictness
                                           'DecidedLazy)
                                        (K1
                                           R
                                           [String]))>_R) ; Sub (Sym (Data.Version.Rep_Version[0]))) <x>_N
               :: (forall x.
                   Version
                   -> M1
                        C
                        ('MetaCons "Version" 'PrefixI 'GHC.Types.True)
                        (M1
                           S
                           ('MetaSel
                              ('GHC.Base.Just "versionBranch")
                              'NoSourceUnpackedness
                              'NoSourceStrictness
                              'DecidedLazy)
                           (K1 R [Int])
                         :*: M1
                               S
                               ('MetaSel
                                  ('GHC.Base.Just "versionTags")
                                  'NoSourceUnpackedness
                                  'NoSourceStrictness
                                  'DecidedLazy)
                               (K1 R [String]))
                        x :: *)
                  ~R# (forall x. Version -> Rep Version x :: *)))
      Data.Version.$fGenericVersion_$cto

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
versionTags :: Version -> [String]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dc3th [Occ=Once!] :: Version) ->
                 case ds_dc3th of { Version _ [Occ=Dead] ds2_dc3tj [Occ=Once] ->
                 ds2_dc3tj
                 }}]
versionTags
  = \ (ds_dc3th :: Version) ->
      case ds_dc3th of { Version ds1_dc3ti ds2_dc3tj -> ds2_dc3tj }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
versionBranch :: Version -> [Int]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dc3te [Occ=Once!] :: Version) ->
                 case ds_dc3te of { Version ds1_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 ds1_dc3tf
                 }}]
versionBranch
  = \ (ds_dc3te :: Version) ->
      case ds_dc3te of { Version ds1_dc3tf ds2_dc3tg -> ds1_dc3tf }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$ccompare
  :: Version -> Version -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)><S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (v1_ac3kr [Occ=Once!] :: Version)
                 (v2_ac3ks [Occ=Once!] :: Version) ->
                 case v1_ac3kr of { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case v2_ac3ks of { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf
                 }
                 }}]
Data.Version.$fOrdVersion_$ccompare
  = \ (v1_ac3kr :: Version) (v2_ac3ks :: Version) ->
      case v1_ac3kr of { Version ds_dc3tf ds1_dc3tg ->
      case v2_ac3ks of { Version ds2_Xc3vf ds3_Xc3vh ->
      GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf
      }
      }

-- RHS size: {terms: 18, types: 11, coercions: 0, joins: 0/0}
Data.Version.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: [Int] -> [String] -> [Int] -> [String] -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 140 10}]
Data.Version.$w$c==
  = \ (ww_sc3Mz :: [Int])
      (ww1_sc3MA :: [String])
      (ww2_sc3ME :: [Int])
      (ww3_sc3MF :: [String]) ->
      case GHC.Classes.$fEq[]_$s$c== ww_sc3Mz ww2_sc3ME of {
        GHC.Types.False -> GHC.Types.False;
        GHC.Types.True ->
          GHC.Classes.$fEq[]_$s$c==1
            (sortBy @ String GHC.Classes.$fOrd[]_$s$ccompare1 ww1_sc3MA)
            (sortBy @ String GHC.Classes.$fOrd[]_$s$ccompare1 ww3_sc3MF)
      }

-- RHS size: {terms: 13, types: 12, coercions: 0, joins: 0/0}
Data.Version.$fEqVersion_$c== [InlPrag=NOUSERINLINE[0]]
  :: Version -> Version -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sc3Mv [Occ=Once!] :: Version)
                 (w1_sc3Mw [Occ=Once!] :: Version) ->
                 case w_sc3Mv of
                 { Version ww1_sc3Mz [Occ=Once] ww2_sc3MA [Occ=Once] ->
                 case w1_sc3Mw of
                 { Version ww4_sc3ME [Occ=Once] ww5_sc3MF [Occ=Once] ->
                 Data.Version.$w$c== ww1_sc3Mz ww2_sc3MA ww4_sc3ME ww5_sc3MF
                 }
                 }}]
Data.Version.$fEqVersion_$c==
  = \ (w_sc3Mv :: Version) (w1_sc3Mw :: Version) ->
      case w_sc3Mv of { Version ww1_sc3Mz ww2_sc3MA ->
      case w1_sc3Mw of { Version ww4_sc3ME ww5_sc3MF ->
      Data.Version.$w$c== ww1_sc3Mz ww2_sc3MA ww4_sc3ME ww5_sc3MF
      }
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fEqVersion_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Version -> Version -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once] :: Version)
                 (y_a22c [Occ=Once] :: Version) ->
                 case Data.Version.$fEqVersion_$c== x_a22b y_a22c of {
                   GHC.Types.False -> GHC.Types.True;
                   GHC.Types.True -> GHC.Types.False
                 }}]
Data.Version.$fEqVersion_$c/=
  = \ (eta_B2 :: Version) (eta1_B1 :: Version) ->
      case eta_B2 of { Version ww1_sc3Mz ww2_sc3MA ->
      case eta1_B1 of { Version ww4_sc3ME ww5_sc3MF ->
      case Data.Version.$w$c== ww1_sc3Mz ww2_sc3MA ww4_sc3ME ww5_sc3MF
      of {
        GHC.Types.False -> GHC.Types.True;
        GHC.Types.True -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Version.$fEqVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq Version
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Version
                        Data.Version.$fEqVersion_$c==
                        Data.Version.$fEqVersion_$c/=]
Data.Version.$fEqVersion
  = GHC.Classes.C:Eq
      @ Version
      Data.Version.$fEqVersion_$c==
      Data.Version.$fEqVersion_$c/=

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$c<
  :: Version -> Version -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)><S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1MiF [Occ=Once!] :: Version)
                 (y_a1MiG [Occ=Once!] :: Version) ->
                 case x_a1MiF of { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case y_a1MiG of { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
                   __DEFAULT -> GHC.Types.False;
                   LT -> GHC.Types.True
                 }
                 }
                 }}]
Data.Version.$fOrdVersion_$c<
  = \ (x_a1MiF :: Version) (y_a1MiG :: Version) ->
      case x_a1MiF of { Version ds_dc3tf ds1_dc3tg ->
      case y_a1MiG of { Version ds2_Xc3vf ds3_Xc3vh ->
      case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
        __DEFAULT -> GHC.Types.False;
        LT -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$c>=
  :: Version -> Version -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)><S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fiT [Occ=Once!] :: Version)
                 (y_a1fiU [Occ=Once!] :: Version) ->
                 case x_a1fiT of { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case y_a1fiU of { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
                   __DEFAULT -> GHC.Types.True;
                   LT -> GHC.Types.False
                 }
                 }
                 }}]
Data.Version.$fOrdVersion_$c>=
  = \ (x_a1fiT :: Version) (y_a1fiU :: Version) ->
      case x_a1fiT of { Version ds_dc3tf ds1_dc3tg ->
      case y_a1fiU of { Version ds2_Xc3vf ds3_Xc3vh ->
      case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
        __DEFAULT -> GHC.Types.True;
        LT -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$c>
  :: Version -> Version -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)><S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fiM [Occ=Once!] :: Version)
                 (y_a1fiN [Occ=Once!] :: Version) ->
                 case x_a1fiM of { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case y_a1fiN of { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
                   __DEFAULT -> GHC.Types.False;
                   GT -> GHC.Types.True
                 }
                 }
                 }}]
Data.Version.$fOrdVersion_$c>
  = \ (x_a1fiM :: Version) (y_a1fiN :: Version) ->
      case x_a1fiM of { Version ds_dc3tf ds1_dc3tg ->
      case y_a1fiN of { Version ds2_Xc3vf ds3_Xc3vh ->
      case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
        __DEFAULT -> GHC.Types.False;
        GT -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$c<=
  :: Version -> Version -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)><S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1MiL [Occ=Once!] :: Version)
                 (y_a1MiM [Occ=Once!] :: Version) ->
                 case x_a1MiL of { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case y_a1MiM of { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
                   __DEFAULT -> GHC.Types.True;
                   GT -> GHC.Types.False
                 }
                 }
                 }}]
Data.Version.$fOrdVersion_$c<=
  = \ (x_a1MiL :: Version) (y_a1MiM :: Version) ->
      case x_a1MiL of { Version ds_dc3tf ds1_dc3tg ->
      case y_a1MiM of { Version ds2_Xc3vf ds3_Xc3vh ->
      case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
        __DEFAULT -> GHC.Types.True;
        GT -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$cmax :: Version -> Version -> Version
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,U)><S(SL),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Version)
                 (y_a55e [Occ=Once!] :: Version) ->
                 case x_a55d of wild_XM
                 { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case y_a55e of wild1_X2K
                 { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
                   __DEFAULT -> wild1_X2K;
                   GT -> wild_XM
                 }
                 }
                 }}]
Data.Version.$fOrdVersion_$cmax
  = \ (x_a55d :: Version) (y_a55e :: Version) ->
      case x_a55d of wild_XM { Version ds_dc3tf ds1_dc3tg ->
      case y_a55e of wild1_X2K { Version ds2_Xc3vf ds3_Xc3vh ->
      case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
        __DEFAULT -> wild1_X2K;
        GT -> wild_XM
      }
      }
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion_$cmin :: Version -> Version -> Version
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,U)><S(SL),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Version)
                 (y_a55n [Occ=Once!] :: Version) ->
                 case x_a55m of wild_XM
                 { Version ds_dc3tf [Occ=Once] _ [Occ=Dead] ->
                 case y_a55n of wild1_X2K
                 { Version ds2_Xc3vf [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
                   __DEFAULT -> wild_XM;
                   GT -> wild1_X2K
                 }
                 }
                 }}]
Data.Version.$fOrdVersion_$cmin
  = \ (x_a55m :: Version) (y_a55n :: Version) ->
      case x_a55m of wild_XM { Version ds_dc3tf ds1_dc3tg ->
      case y_a55n of wild1_X2K { Version ds2_Xc3vf ds3_Xc3vh ->
      case GHC.Classes.$fOrd[]_$s$ccompare ds_dc3tf ds2_Xc3vf of {
        __DEFAULT -> wild_XM;
        GT -> wild1_X2K
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
Data.Version.$fOrdVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord Version
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Version
                         Data.Version.$fEqVersion
                         Data.Version.$fOrdVersion_$ccompare
                         Data.Version.$fOrdVersion_$c<
                         Data.Version.$fOrdVersion_$c<=
                         Data.Version.$fOrdVersion_$c>
                         Data.Version.$fOrdVersion_$c>=
                         Data.Version.$fOrdVersion_$cmax
                         Data.Version.$fOrdVersion_$cmin]
Data.Version.$fOrdVersion
  = GHC.Classes.C:Ord
      @ Version
      Data.Version.$fEqVersion
      Data.Version.$fOrdVersion_$ccompare
      Data.Version.$fOrdVersion_$c<
      Data.Version.$fOrdVersion_$c<=
      Data.Version.$fOrdVersion_$c>
      Data.Version.$fOrdVersion_$c>=
      Data.Version.$fOrdVersion_$cmax
      Data.Version.$fOrdVersion_$cmin

-- RHS size: {terms: 4, types: 3, coercions: 0, joins: 0/0}
makeVersion :: [Int] -> Version
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_ac3kz [Occ=Once] :: [Int]) ->
                 Data.Version.Version b_ac3kz (GHC.Types.[] @ String)}]
makeVersion
  = \ (b_ac3kz :: [Int]) ->
      Data.Version.Version b_ac3kz (GHC.Types.[] @ String)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$trModule3 = GHC.Types.TrNameS Data.Version.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Version.$trModule2 = "Data.Version"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$trModule1 = GHC.Types.TrNameS Data.Version.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Version.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Version.$trModule
  = GHC.Types.Module Data.Version.$trModule3 Data.Version.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rc3Yn :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rc3Yn
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcChar (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rc3Yo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rc3Yo
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2_rc3Yp :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rc3Yp
  = GHC.Types.:
      @ GHC.Types.KindRep $krep_rc3Yn (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_rc3Yq :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_rc3Yq
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep2_rc3Yp

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4_rc3Yr :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_rc3Yr
  = GHC.Types.:
      @ GHC.Types.KindRep $krep1_rc3Yo (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_rc3Ys :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep5_rc3Ys
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep4_rc3Yr

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_rc3Yt :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_rc3Yt
  = GHC.Types.:
      @ GHC.Types.KindRep $krep3_rc3Yq (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_rc3Yu :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_rc3Yu
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep6_rc3Yt

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion19 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Version.$fReadVersion19 = "Version"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$tcVersion1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$tcVersion1
  = GHC.Types.TrNameS Data.Version.$fReadVersion19

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Version.$tcVersion :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Version.$tcVersion
  = GHC.Types.TyCon
      18148779789861942324##
      12675349638857785520##
      Data.Version.$trModule
      Data.Version.$tcVersion1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8_rc3Yv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_rc3Yv
  = GHC.Types.KindRepTyConApp
      Data.Version.$tcVersion (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_rc3Yw :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep9_rc3Yw = GHC.Types.KindRepFun $krep7_rc3Yu $krep8_rc3Yv

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Version.$tc'Version1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Version.$tc'Version1
  = GHC.Types.KindRepFun $krep5_rc3Ys $krep9_rc3Yw

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$tc'Version3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Version.$tc'Version3 = "'Version"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$tc'Version2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$tc'Version2
  = GHC.Types.TrNameS Data.Version.$tc'Version3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Version.$tc'Version :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Version.$tc'Version
  = GHC.Types.TyCon
      3698077959655346891##
      8062481246695158651##
      Data.Version.$trModule
      Data.Version.$tc'Version2
      0#
      Data.Version.$tc'Version1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
f_rc3Yx :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
f_rc3Yx = "Version {"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
f1_rc3Yy :: [GHC.Types.Char]
[GblId]
f1_rc3Yy = GHC.CString.unpackCString# f_rc3Yx

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rc3Yz :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_rc3Yz = "versionBranch = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_rc3YA :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_rc3YA = "versionTags = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion5 = "}"#

-- RHS size: {terms: 121, types: 93, coercions: 0, joins: 0/7}
Data.Version.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> [Int] -> [String] -> String -> String
[GblId, Arity=4, Str=<S,U><L,1*U><L,1*U><L,U>, Unf=OtherCon []]
Data.Version.$w$cshowsPrec
  = \ (ww_sc3MQ :: GHC.Prim.Int#)
      (ww1_sc3MU :: [Int])
      (ww2_sc3MV :: [String])
      (w_sc3MN :: String) ->
      let {
        g_sc3AV [Dmd=<L,1*C1(U)>] :: String -> String
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        g_sc3AV
          = \ (x_X7Rzb [OS=OneShot] :: String) ->
              GHC.CString.unpackAppendCString#
                lvl_rc3Yz
                (let {
                   s_sc3B4 :: String
                   [LclId]
                   s_sc3B4
                     = ++
                         @ GHC.Types.Char
                         GHC.Show.showCommaSpace1
                         (GHC.CString.unpackAppendCString#
                            lvl1_rc3YA
                            (let {
                               s1_sc3Ba :: String
                               [LclId]
                               s1_sc3Ba
                                 = GHC.CString.unpackAppendCString#
                                     Data.Version.$fReadVersion5 x_X7Rzb } in
                             case ww2_sc3MV of {
                               [] ->
                                 GHC.CString.unpackAppendCString# GHC.Show.showList__4 s1_sc3Ba;
                               : x1_i7Jf2 xs_i7Jf3 ->
                                 GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showList__3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (showLitString
                                         x1_i7Jf2
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)3
                                            (let {
                                               lvl45_sc3Bb :: [GHC.Types.Char]
                                               [LclId, Unf=OtherCon []]
                                               lvl45_sc3Bb
                                                 = GHC.Types.:
                                                     @ GHC.Types.Char
                                                     GHC.Show.showList__2
                                                     s1_sc3Ba } in
                                             letrec {
                                               showl_sc3B9 [Occ=LoopBreaker]
                                                 :: [[GHC.Types.Char]] -> String
                                               [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                               showl_sc3B9
                                                 = \ (ds2_i7Jf8 :: [[GHC.Types.Char]]) ->
                                                     case ds2_i7Jf8 of {
                                                       [] -> lvl45_sc3Bb;
                                                       : y_i7Jfe ys_i7Jff ->
                                                         GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.showList__1
                                                           (GHC.Types.:
                                                              @ GHC.Types.Char
                                                              GHC.Show.$fShow(,)3
                                                              (showLitString
                                                                 y_i7Jfe
                                                                 (GHC.Types.:
                                                                    @ GHC.Types.Char
                                                                    GHC.Show.$fShow(,)3
                                                                    (showl_sc3B9 ys_i7Jff))))
                                                     }; } in
                                             showl_sc3B9 xs_i7Jf3))))
                             })) } in
                 case ww1_sc3MU of {
                   [] ->
                     GHC.CString.unpackAppendCString# GHC.Show.showList__4 s_sc3B4;
                   : x1_i7Jf2 xs_i7Jf3 ->
                     GHC.Types.:
                       @ GHC.Types.Char
                       GHC.Show.showList__3
                       (case x1_i7Jf2 of { GHC.Types.I# ww4_ic3uw ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4_ic3uw
                               (let {
                                  lvl45_sc3B5 :: [GHC.Types.Char]
                                  [LclId, Unf=OtherCon []]
                                  lvl45_sc3B5
                                    = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s_sc3B4 } in
                                letrec {
                                  showl_sc3B3 [Occ=LoopBreaker] :: [Int] -> String
                                  [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                  showl_sc3B3
                                    = \ (ds2_i7Jf8 :: [Int]) ->
                                        case ds2_i7Jf8 of {
                                          [] -> lvl45_sc3B5;
                                          : y_i7Jfe ys_i7Jff ->
                                            GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showList__1
                                              (case y_i7Jfe of { GHC.Types.I# ww6_Xc3wR ->
                                               case GHC.Show.$wshowSignedInt
                                                      0# ww6_Xc3wR (showl_sc3B3 ys_i7Jff)
                                               of
                                               { (# ww8_ic3uA, ww9_ic3uB #) ->
                                               GHC.Types.: @ GHC.Types.Char ww8_ic3uA ww9_ic3uB
                                               }
                                               })
                                        }; } in
                                showl_sc3B3 xs_i7Jf3)
                        of
                        { (# ww6_ic3uA, ww7_ic3uB #) ->
                        GHC.Types.: @ GHC.Types.Char ww6_ic3uA ww7_ic3uB
                        }
                        })
                 }) } in
      case GHC.Prim.>=# ww_sc3MQ 11# of {
        __DEFAULT -> ++ @ GHC.Types.Char f1_rc3Yy (g_sc3AV w_sc3MN);
        1# ->
          GHC.Types.:
            @ GHC.Types.Char
            GHC.Show.$fShow(,)4
            (++
               @ GHC.Types.Char
               f1_rc3Yy
               (g_sc3AV
                  (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w_sc3MN)))
      }

-- RHS size: {terms: 14, types: 10, coercions: 0, joins: 0/0}
Data.Version.$fShowVersion_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> Version -> ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S,1*U(1*U,1*U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sc3ML [Occ=Once!] :: Int)
                 (w1_sc3MM [Occ=Once!] :: Version)
                 (w2_sc3MN [Occ=Once] :: String) ->
                 case w_sc3ML of { GHC.Types.I# ww1_sc3MQ [Occ=Once] ->
                 case w1_sc3MM of
                 { Version ww3_sc3MU [Occ=Once] ww4_sc3MV [Occ=Once] ->
                 Data.Version.$w$cshowsPrec ww1_sc3MQ ww3_sc3MU ww4_sc3MV w2_sc3MN
                 }
                 }}]
Data.Version.$fShowVersion_$cshowsPrec
  = \ (w_sc3ML :: Int) (w1_sc3MM :: Version) (w2_sc3MN :: String) ->
      case w_sc3ML of { GHC.Types.I# ww1_sc3MQ ->
      case w1_sc3MM of { Version ww3_sc3MU ww4_sc3MV ->
      Data.Version.$w$cshowsPrec ww1_sc3MQ ww3_sc3MU ww4_sc3MV w2_sc3MN
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fShowVersion2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$fShowVersion2 = GHC.Types.I# 0#

-- RHS size: {terms: 9, types: 7, coercions: 0, joins: 0/0}
Data.Version.$fShowVersion_$cshow :: Version -> String
[GblId,
 Arity=1,
 Str=<S,1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once] :: Version) ->
                 Data.Version.$fShowVersion_$cshowsPrec
                   Data.Version.$fShowVersion2
                   x_i7Jay
                   (GHC.Types.[] @ GHC.Types.Char)}]
Data.Version.$fShowVersion_$cshow
  = \ (x_i7Jay :: Version) ->
      case x_i7Jay of { Version ww1_sc3MU ww2_sc3MV ->
      Data.Version.$w$cshowsPrec
        0# ww1_sc3MU ww2_sc3MV (GHC.Types.[] @ GHC.Types.Char)
      }

-- RHS size: {terms: 10, types: 7, coercions: 0, joins: 0/0}
Data.Version.$fShowVersion1 :: Version -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U(1*U,1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 60 0}]
Data.Version.$fShowVersion1
  = \ (w_sc3MM :: Version) (w1_sc3MN :: String) ->
      case w_sc3MM of { Version ww1_sc3MU ww2_sc3MV ->
      Data.Version.$w$cshowsPrec 0# ww1_sc3MU ww2_sc3MV w1_sc3MN
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Version.$fShowVersion_$cshowList :: [Version] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [Version])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__ @ Version Data.Version.$fShowVersion1 ls_i7JaB s_i7JaC}]
Data.Version.$fShowVersion_$cshowList
  = \ (ls_i7JaB :: [Version]) (s_i7JaC :: String) ->
      showList__ @ Version Data.Version.$fShowVersion1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Version.$fShowVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: Show Version
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Version
                       Data.Version.$fShowVersion_$cshowsPrec
                       Data.Version.$fShowVersion_$cshow
                       Data.Version.$fShowVersion_$cshowList]
Data.Version.$fShowVersion
  = GHC.Show.C:Show
      @ Version
      Data.Version.$fShowVersion_$cshowsPrec
      Data.Version.$fShowVersion_$cshow
      Data.Version.$fShowVersion_$cshowList

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
f2_rc3YB :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
f2_rc3YB = GHC.Types.C# '-'#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.showVersion2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.showVersion2 = "."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.showVersion1 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.showVersion1
  = GHC.CString.unpackCString# Data.Version.showVersion2

Rec {
-- RHS size: {terms: 12, types: 14, coercions: 0, joins: 0/0}
Data.Version.showVersion_go [Occ=LoopBreaker]
  :: [[GHC.Types.Char]] -> [GHC.Types.Char]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Data.Version.showVersion_go
  = \ (ds_i7Jck :: [[GHC.Types.Char]]) ->
      case ds_i7Jck of {
        [] -> GHC.Types.[] @ GHC.Types.Char;
        : y_i7Jcp ys_i7Jcq ->
          ++
            @ GHC.Types.Char
            (GHC.Types.: @ GHC.Types.Char f2_rc3YB y_i7Jcp)
            (Data.Version.showVersion_go ys_i7Jcq)
      }
end Rec }

-- RHS size: {terms: 29, types: 38, coercions: 0, joins: 0/2}
Data.Version.$wshowVersion [InlPrag=NOUSERINLINE[0]]
  :: [Int] -> [String] -> String
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 230 0}]
Data.Version.$wshowVersion
  = \ (ww_sc3N3 :: [Int]) (ww1_sc3N4 :: [String]) ->
      let {
        arg_sc3CM :: [GHC.Types.Char]
        [LclId]
        arg_sc3CM = Data.Version.showVersion_go ww1_sc3N4 } in
      case map
             @ Int @ [GHC.Types.Char] GHC.Show.$fShowInt_$cshow ww_sc3N3
      of {
        [] -> arg_sc3CM;
        : x_ic3sW xs_ic3sX ->
          letrec {
            go_i7Jcj [Occ=LoopBreaker]
              :: [[GHC.Types.Char]] -> [GHC.Types.Char]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i7Jcj
              = \ (ds_i7Jck :: [[GHC.Types.Char]]) ->
                  case ds_i7Jck of {
                    [] -> arg_sc3CM;
                    : y_i7Jcp ys_i7Jcq ->
                      ++ @ GHC.Types.Char y_i7Jcp (go_i7Jcj ys_i7Jcq)
                  }; } in
          go_i7Jcj
            (GHC.Types.:
               @ [GHC.Types.Char]
               x_ic3sW
               (Data.OldList.prependToAll
                  @ [GHC.Types.Char] Data.Version.showVersion1 xs_ic3sX))
      }

-- RHS size: {terms: 7, types: 6, coercions: 0, joins: 0/0}
showVersion [InlPrag=NOUSERINLINE[0]] :: Version -> String
[GblId,
 Arity=1,
 Str=<S(SL),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sc3N0 [Occ=Once!] :: Version) ->
                 case w_sc3N0 of
                 { Version ww1_sc3N3 [Occ=Once] ww2_sc3N4 [Occ=Once] ->
                 Data.Version.$wshowVersion ww1_sc3N3 ww2_sc3N4
                 }}]
showVersion
  = \ (w_sc3N0 :: Version) ->
      case w_sc3N0 of { Version ww1_sc3N3 ww2_sc3N4 ->
      Data.Version.$wshowVersion ww1_sc3N3 ww2_sc3N4
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion18 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion18
  = GHC.CString.unpackCString# Data.Version.$fReadVersion19

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion_lexeme1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$fReadVersion_lexeme1
  = Text.Read.Lex.Ident Data.Version.$fReadVersion18

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion17 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion17 = "{"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion16 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion16
  = GHC.CString.unpackCString# Data.Version.$fReadVersion17

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$fReadVersion_lexeme
  = Text.Read.Lex.Punc Data.Version.$fReadVersion16

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion15 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Version.$fReadVersion15 = "versionBranch"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion14 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion14
  = GHC.CString.unpackCString# Data.Version.$fReadVersion15

-- RHS size: {terms: 2, types: 0, coercions: 3, joins: 0/0}
Data.Version.$fReadVersion13 :: ReadP [Int]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion13
  = (GHC.Read.$fReadInt_$creadListPrec
     `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Int]>_R
             :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int] :: *)
                ~R# (Text.ParserCombinators.ReadPrec.Prec -> ReadP [Int] :: *)))
      Text.ParserCombinators.ReadPrec.minPrec

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion12
  :: Text.ParserCombinators.ReadPrec.Prec -> ReadP [Int]
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Version.$fReadVersion13}]
Data.Version.$fReadVersion12
  = \ _ [Occ=Dead] -> Data.Version.$fReadVersion13

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion_n
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$fReadVersion_n = GHC.Types.I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion11 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion11 = ","#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion10 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion10
  = GHC.CString.unpackCString# Data.Version.$fReadVersion11

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion9 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$fReadVersion9
  = Text.Read.Lex.Punc Data.Version.$fReadVersion10

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion8 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Version.$fReadVersion8 = "versionTags"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion7 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion7
  = GHC.CString.unpackCString# Data.Version.$fReadVersion8

-- RHS size: {terms: 3, types: 1, coercions: 3, joins: 0/0}
Data.Version.$fReadVersion6
  :: Text.ParserCombinators.ReadPrec.Prec -> ReadP [String]
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead, OS=OneShot] ->
                 (GHC.Read.$fRead[]_$s$creadListPrec1
                  `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[String]>_R
                          :: (Text.ParserCombinators.ReadPrec.ReadPrec [String] :: *)
                             ~R# (Text.ParserCombinators.ReadPrec.Prec -> ReadP [String] :: *)))
                   Text.ParserCombinators.ReadPrec.minPrec}]
Data.Version.$fReadVersion6
  = \ _ [Occ=Dead, OS=OneShot] ->
      (GHC.Read.$fRead[]_$s$creadListPrec1
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[String]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [String] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec -> ReadP [String] :: *)))
        Text.ParserCombinators.ReadPrec.minPrec

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion4 :: [GHC.Types.Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion4
  = GHC.CString.unpackCString# Data.Version.$fReadVersion5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion3 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Version.$fReadVersion3
  = Text.Read.Lex.Punc Data.Version.$fReadVersion4

-- RHS size: {terms: 52, types: 62, coercions: 20, joins: 0/0}
Data.Version.$w$creadPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Version -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<S,U><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60] 411 30}]
Data.Version.$w$creadPrec
  = \ (ww_sc3Nc :: GHC.Prim.Int#)
      (@ b_sc3N8)
      (w_sc3N9 :: Version -> Text.ParserCombinators.ReadP.P b_sc3N8) ->
      case GHC.Prim.<=# ww_sc3Nc 11# of {
        __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_sc3N8;
        1# ->
          case Text.Read.Lex.$wexpect
                 Data.Version.$fReadVersion_lexeme1
                 @ b_sc3N8
                 (\ _ [Occ=Dead, OS=OneShot] ->
                    case Text.Read.Lex.$wexpect
                           Data.Version.$fReadVersion_lexeme
                           @ b_sc3N8
                           (\ _ [Occ=Dead, OS=OneShot] ->
                              ((((readField
                                    @ [Int]
                                    Data.Version.$fReadVersion14
                                    (Data.Version.$fReadVersion12
                                     `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      <[Int]>_R)
                                             :: (Text.ParserCombinators.ReadPrec.Prec
                                                 -> ReadP [Int] :: *)
                                                ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                       [Int] :: *))))
                                 `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Int]>_R
                                         :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int] :: *)
                                            ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                 -> ReadP [Int] :: *)))
                                  Data.Version.$fReadVersion_n)
                               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Int]>_R
                                       :: (ReadP [Int] :: *)
                                          ~R# (forall b.
                                               ([Int] -> Text.ParserCombinators.ReadP.P b)
                                               -> Text.ParserCombinators.ReadP.P b :: *)))
                                @ b_sc3N8
                                (\ (a3_i88WJ :: [Int]) ->
                                   case Text.Read.Lex.$wexpect
                                          Data.Version.$fReadVersion9
                                          @ b_sc3N8
                                          (\ _ [Occ=Dead, OS=OneShot] ->
                                             ((((readField
                                                   @ [String]
                                                   Data.Version.$fReadVersion7
                                                   (Data.Version.$fReadVersion6
                                                    `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <[String]>_R)
                                                            :: (Text.ParserCombinators.ReadPrec.Prec
                                                                -> ReadP [String] :: *)
                                                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                                      [String] :: *))))
                                                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <[String]>_R
                                                        :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                              [String] :: *)
                                                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                                -> ReadP [String] :: *)))
                                                 Data.Version.$fReadVersion_n)
                                              `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                          <[String]>_R
                                                      :: (ReadP [String] :: *)
                                                         ~R# (forall b.
                                                              ([String]
                                                               -> Text.ParserCombinators.ReadP.P b)
                                                              -> Text.ParserCombinators.ReadP.P
                                                                   b :: *)))
                                               @ b_sc3N8
                                               (\ (a5_X88YY :: [String]) ->
                                                  case Text.Read.Lex.$wexpect
                                                         Data.Version.$fReadVersion3
                                                         @ b_sc3N8
                                                         (\ _ [Occ=Dead, OS=OneShot] ->
                                                            w_sc3N9
                                                              (Data.Version.Version
                                                                 a3_i88WJ a5_X88YY))
                                                  of
                                                  { (# ww2_i88Ww #) ->
                                                  Text.ParserCombinators.ReadP.Look
                                                    @ b_sc3N8 ww2_i88Ww
                                                  }))
                                   of
                                   { (# ww2_i88Ww #) ->
                                   Text.ParserCombinators.ReadP.Look @ b_sc3N8 ww2_i88Ww
                                   }))
                    of
                    { (# ww2_i88Ww #) ->
                    Text.ParserCombinators.ReadP.Look @ b_sc3N8 ww2_i88Ww
                    })
          of
          { (# ww2_i88Ww #) ->
          Text.ParserCombinators.ReadP.Look @ b_sc3N8 ww2_i88Ww
          }
      }

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Version -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sc3N7 [Occ=Once!]
                    :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_sc3N8)
                 (w1_sc3N9 [Occ=Once]
                    :: Version -> Text.ParserCombinators.ReadP.P b_sc3N8) ->
                 case w_sc3N7 of { GHC.Types.I# ww1_sc3Nc [Occ=Once] ->
                 Data.Version.$w$creadPrec ww1_sc3Nc @ b_sc3N8 w1_sc3N9
                 }}]
Data.Version.$fReadVersion2
  = \ (w_sc3N7 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_sc3N8)
      (w1_sc3N9 :: Version -> Text.ParserCombinators.ReadP.P b_sc3N8) ->
      case w_sc3N7 of { GHC.Types.I# ww1_sc3Nc ->
      Data.Version.$w$creadPrec ww1_sc3Nc @ b_sc3N8 w1_sc3N9
      }

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
Data.Version.$fReadVersion1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Version -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Version.$fReadVersion1
  = GHC.Read.list3
      @ Version
      (Data.Version.$fReadVersion2
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Version>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Version -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Version :: *)))

-- RHS size: {terms: 6, types: 5, coercions: 9, joins: 0/0}
Data.Version.$fReadVersion_$creadsPrec :: Int -> ReadS Version
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i8156 [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Version
                   (GHC.Read.list3
                      @ Version
                      (Data.Version.$fReadVersion2
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <Version>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Version -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Version :: *)))
                      n_i8156
                      @ Version
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Version))}]
Data.Version.$fReadVersion_$creadsPrec
  = \ (n_i8156 :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ Version
        (GHC.Read.list3
           @ Version
           (Data.Version.$fReadVersion2
            `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <Version>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> forall b.
                           (Version -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Version :: *)))
           n_i8156
           @ Version
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Version))

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
Data.Version.$fReadVersion_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Version]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
Data.Version.$fReadVersion_$creadListPrec
  = list
      @ Version
      (Data.Version.$fReadVersion1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Version>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Version -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Version :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
Data.Version.$fReadVersion20
  :: Text.ParserCombinators.ReadP.P [Version]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Data.Version.$fReadVersion20
  = (((Data.Version.$fReadVersion_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Version]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Version] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> ReadP [Version] :: *)))
        GHC.Read.$fRead()7)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Version]>_R
             :: (ReadP [Version] :: *)
                ~R# (forall b.
                     ([Version] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Version]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Version])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Version.$fReadVersion_$creadList :: ReadS [Version]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Version.$fReadVersion_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [Version] Data.Version.$fReadVersion20

-- RHS size: {terms: 5, types: 1, coercions: 9, joins: 0/0}
Data.Version.$fReadVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: Read Version
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Version
                       Data.Version.$fReadVersion_$creadsPrec
                       Data.Version.$fReadVersion_$creadList
                       Data.Version.$fReadVersion1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <Version>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Version -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Version :: *))
                       Data.Version.$fReadVersion_$creadListPrec]
Data.Version.$fReadVersion
  = GHC.Read.C:Read
      @ Version
      Data.Version.$fReadVersion_$creadsPrec
      Data.Version.$fReadVersion_$creadList
      (Data.Version.$fReadVersion1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Version>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Version -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Version :: *)))
      Data.Version.$fReadVersion_$creadListPrec

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Version.parseVersion5 :: Int
[GblId, Str=x]
Data.Version.parseVersion5
  = GHC.Err.errorWithoutStackTrace
      @ 'GHC.Types.LiftedRep @ Int Text.Read.readEither5

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Version.parseVersion4 :: Int
[GblId, Str=x]
Data.Version.parseVersion4
  = GHC.Err.errorWithoutStackTrace
      @ 'GHC.Types.LiftedRep @ Int Text.Read.readEither2

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Version.parseVersion6 :: Text.ParserCombinators.ReadP.P Int
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Data.Version.parseVersion6
  = GHC.Read.$fReadInt_$sreadNumber
      GHC.Read.$fReadInt2
      Text.ParserCombinators.ReadPrec.minPrec
      @ Int
      (Text.Read.readEither7 @ Int)

-- RHS size: {terms: 42, types: 38, coercions: 0, joins: 0/0}
Data.Version.$wp [InlPrag=NOUSERINLINE[0]]
  :: forall b1.
     (Int -> Text.ParserCombinators.ReadP.P b1)
     -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 222 20}]
Data.Version.$wp
  = \ (@ b1_sc3Nf)
      (w_sc3Ng :: Int -> Text.ParserCombinators.ReadP.P b1_sc3Nf) ->
      (# \ (a_ic3I3 :: GHC.Types.Char) ->
           case a_ic3I3 of wild_ic3sA { GHC.Types.C# c#_ic3sC ->
           case GHC.Prim.leWord#
                  (GHC.Prim.int2Word# (GHC.Prim.-# (GHC.Prim.ord# c#_ic3sC) 48#)) 9##
           of {
             __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_sc3Nf;
             1# ->
               case Text.ParserCombinators.ReadP.$wmunch
                      isDigit
                      @ b1_sc3Nf
                      (\ (a1_ic3Ia :: String) ->
                         w_sc3Ng
                           (case Text.Read.readEither8
                                   @ Int
                                   (Text.ParserCombinators.ReadP.run
                                      @ Int
                                      Data.Version.parseVersion6
                                      (GHC.Types.: @ GHC.Types.Char wild_ic3sA a1_ic3Ia))
                            of {
                              [] -> Data.Version.parseVersion5;
                              : x_ic3wM ds_ic3wN ->
                                case ds_ic3wN of {
                                  [] -> x_ic3wM;
                                  : ipv_ic3CS ipv1_ic3CT -> Data.Version.parseVersion4
                                }
                            }))
               of
               { (# ww1_ic3Id #) ->
               Text.ParserCombinators.ReadP.Look @ b1_sc3Nf ww1_ic3Id
               }
           }
           } #)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Data.Version.parseVersion3 [InlPrag=NOUSERINLINE[0]]
  :: forall b1.
     (Int -> Text.ParserCombinators.ReadP.P b1)
     -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=1,
 Str=<L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b1_sc3Nf)
                 (w_sc3Ng [Occ=Once]
                    :: Int -> Text.ParserCombinators.ReadP.P b1_sc3Nf) ->
                 case Data.Version.$wp @ b1_sc3Nf w_sc3Ng of
                 { (# ww1_sc3ND [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Get @ b1_sc3Nf ww1_sc3ND
                 }}]
Data.Version.parseVersion3
  = \ (@ b1_sc3Nf)
      (w_sc3Ng :: Int -> Text.ParserCombinators.ReadP.P b1_sc3Nf) ->
      case Data.Version.$wp @ b1_sc3Nf w_sc3Ng of { (# ww1_sc3ND #) ->
      Text.ParserCombinators.ReadP.Get @ b1_sc3Nf ww1_sc3ND
      }

-- RHS size: {terms: 20, types: 23, coercions: 0, joins: 0/1}
Data.Version.parseVersion_m2
  :: forall b1.
     (Int -> Text.ParserCombinators.ReadP.P b1)
     -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=1,
 Str=<L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b1_ic3wf)
                 (k_ic3wg [Occ=Once]
                    :: Int -> Text.ParserCombinators.ReadP.P b1_ic3wf) ->
                 let {
                   lvl4_ic3wh [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_ic3wf
                   [LclId]
                   lvl4_ic3wh = Data.Version.parseVersion3 @ b1_ic3wf k_ic3wg } in
                 Text.ParserCombinators.ReadP.Get
                   @ b1_ic3wf
                   (\ (a_ic3xb [Occ=Once!] :: GHC.Types.Char) ->
                      case a_ic3xb of { GHC.Types.C# y_ic3xi [Occ=Once!] ->
                      case y_ic3xi of {
                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_ic3wf;
                        '.'# -> lvl4_ic3wh
                      }
                      })}]
Data.Version.parseVersion_m2
  = \ (@ b1_ic3w9)
      (k_ic3wa :: Int -> Text.ParserCombinators.ReadP.P b1_ic3w9) ->
      let {
        lvl4_sc3AL :: Text.ParserCombinators.ReadP.P b1_ic3w9
        [LclId]
        lvl4_sc3AL
          = case Data.Version.$wp @ b1_ic3w9 k_ic3wa of { (# ww1_sc3ND #) ->
            Text.ParserCombinators.ReadP.Get @ b1_ic3w9 ww1_sc3ND
            } } in
      Text.ParserCombinators.ReadP.Get
        @ b1_ic3w9
        (\ (a_ic3xb :: GHC.Types.Char) ->
           case a_ic3xb of { GHC.Types.C# y_ic3xi ->
           case y_ic3xi of {
             __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_ic3w9;
             '.'# -> lvl4_sc3AL
           }
           })

-- RHS size: {terms: 50, types: 53, coercions: 0, joins: 0/4}
Data.Version.$wlvl [InlPrag=NOUSERINLINE[0]]
  :: forall b1.
     (String -> Text.ParserCombinators.ReadP.P b1)
     -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 280 20}]
Data.Version.$wlvl
  = \ (@ b1_sc3Nr)
      (w_sc3Ns :: String -> Text.ParserCombinators.ReadP.P b1_sc3Nr) ->
      let {
        $www1_sc3Nq [InlPrag=NOUSERINLINE[0], Dmd=<L,C(U)>]
          :: GHC.Prim.Char# -> Text.ParserCombinators.ReadP.P b1_sc3Nr
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        $www1_sc3Nq
          = \ (ww_sc3No :: GHC.Prim.Char#) ->
              case {__pkg_ccall base-4.11.0.0 Int#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_ic3s7
                     (GHC.Prim.ord# ww_sc3No) GHC.Prim.realWorld#
              of
              { (# ds_ic3sc, ds1_ic3sd #) ->
              case ds1_ic3sd of {
                __DEFAULT ->
                  let {
                    wild_ic3s5 :: GHC.Types.Char
                    [LclId, Unf=OtherCon []]
                    wild_ic3s5 = GHC.Types.C# ww_sc3No } in
                  case Text.ParserCombinators.ReadP.$wmunch
                         isAlphaNum
                         @ b1_sc3Nr
                         (\ (a1_ic3Ia :: String) ->
                            w_sc3Ns (GHC.Types.: @ GHC.Types.Char wild_ic3s5 a1_ic3Ia))
                  of
                  { (# ww2_ic3Id #) ->
                  Text.ParserCombinators.ReadP.Look @ b1_sc3Nr ww2_ic3Id
                  };
                0# -> Text.ParserCombinators.ReadP.Fail @ b1_sc3Nr
              }
              } } in
      let {
        ww1_ic3x3 [InlPrag=NOUSERINLINE[0]]
          :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1_sc3Nr
        [LclId,
         Arity=1,
         Str=<S(S),1*U(U)>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (w1_sc3Nl [Occ=Once!] :: GHC.Types.Char) ->
                         case w1_sc3Nl of { GHC.Types.C# ww1_sc3No [Occ=Once] ->
                         $www1_sc3Nq ww1_sc3No
                         }}]
        ww1_ic3x3
          = \ (w1_sc3Nl :: GHC.Types.Char) ->
              case w1_sc3Nl of { GHC.Types.C# ww2_sc3No ->
              $www1_sc3Nq ww2_sc3No
              } } in
      let {
        lvl4_sc3AJ :: Text.ParserCombinators.ReadP.P b1_sc3Nr
        [LclId, Unf=OtherCon []]
        lvl4_sc3AJ
          = Text.ParserCombinators.ReadP.Get @ b1_sc3Nr ww1_ic3x3 } in
      (# \ (a_ic3xb :: GHC.Types.Char) ->
           case a_ic3xb of { GHC.Types.C# y_ic3xi ->
           case y_ic3xi of {
             __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_sc3Nr;
             '-'# -> lvl4_sc3AJ
           }
           } #)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Data.Version.parseVersion2 [InlPrag=NOUSERINLINE[0]]
  :: forall b1.
     (String -> Text.ParserCombinators.ReadP.P b1)
     -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b1_sc3Nr)
                 (w_sc3Ns [Occ=Once]
                    :: String -> Text.ParserCombinators.ReadP.P b1_sc3Nr) ->
                 case Data.Version.$wlvl @ b1_sc3Nr w_sc3Ns of
                 { (# ww1_sc3NF [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Get @ b1_sc3Nr ww1_sc3NF
                 }}]
Data.Version.parseVersion2
  = \ (@ b1_sc3Nr)
      (w_sc3Ns :: String -> Text.ParserCombinators.ReadP.P b1_sc3Nr) ->
      case Data.Version.$wlvl @ b1_sc3Nr w_sc3Ns of { (# ww1_sc3NF #) ->
      Text.ParserCombinators.ReadP.Get @ b1_sc3Nr ww1_sc3NF
      }

-- RHS size: {terms: 56, types: 50, coercions: 6, joins: 0/2}
Data.Version.$wparseVersion [InlPrag=NOUSERINLINE[0]]
  :: forall b1.
     (Version -> Text.ParserCombinators.ReadP.P b1)
     -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 342 20}]
Data.Version.$wparseVersion
  = \ (@ b1_sc3Nx)
      (w_sc3Ny :: Version -> Text.ParserCombinators.ReadP.P b1_sc3Nx) ->
      (# \ (a_ic3I3 :: GHC.Types.Char) ->
           case a_ic3I3 of wild_ic3sA { GHC.Types.C# c#_ic3sC ->
           case GHC.Prim.leWord#
                  (GHC.Prim.int2Word# (GHC.Prim.-# (GHC.Prim.ord# c#_ic3sC) 48#)) 9##
           of {
             __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_sc3Nx;
             1# ->
               case Text.ParserCombinators.ReadP.$wmunch
                      isDigit
                      @ b1_sc3Nx
                      (\ (a1_ic3Ia :: String) ->
                         let {
                           a2_sc3AG :: Int
                           [LclId]
                           a2_sc3AG
                             = case Text.Read.readEither8
                                      @ Int
                                      (Text.ParserCombinators.ReadP.run
                                         @ Int
                                         Data.Version.parseVersion6
                                         (GHC.Types.: @ GHC.Types.Char wild_ic3sA a1_ic3Ia))
                               of {
                                 [] -> Data.Version.parseVersion5;
                                 : x_ic3wM ds_ic3wN ->
                                   case ds_ic3wN of {
                                     [] -> x_ic3wM;
                                     : ipv_ic3CS ipv1_ic3CT -> Data.Version.parseVersion4
                                   }
                               } } in
                         Text.ParserCombinators.ReadP.endBy3
                           @ Int
                           (Data.Version.parseVersion_m2
                            `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Int>_R)
                                    :: (forall b.
                                        (Int -> Text.ParserCombinators.ReadP.P b)
                                        -> Text.ParserCombinators.ReadP.P b :: *)
                                       ~R# (ReadP Int :: *)))
                           @ b1_sc3Nx
                           (\ (a3_ic3we :: [Int]) ->
                              let {
                                a4_sc3AF :: [Int]
                                [LclId, Unf=OtherCon []]
                                a4_sc3AF = GHC.Types.: @ Int a2_sc3AG a3_ic3we } in
                              Text.ParserCombinators.ReadP.endBy3
                                @ String
                                (Data.Version.parseVersion2
                                 `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
                                         :: (forall b.
                                             (String -> Text.ParserCombinators.ReadP.P b)
                                             -> Text.ParserCombinators.ReadP.P b :: *)
                                            ~R# (ReadP String :: *)))
                                @ b1_sc3Nx
                                (\ (a5_Xc3xV :: [String]) ->
                                   w_sc3Ny (Data.Version.Version a4_sc3AF a5_Xc3xV))))
               of
               { (# ww1_ic3Id #) ->
               Text.ParserCombinators.ReadP.Look @ b1_sc3Nx ww1_ic3Id
               }
           }
           } #)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Data.Version.parseVersion1 [InlPrag=NOUSERINLINE[0]]
  :: forall b1.
     (Version -> Text.ParserCombinators.ReadP.P b1)
     -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=1,
 Str=<L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b1_sc3Nx)
                 (w_sc3Ny [Occ=Once]
                    :: Version -> Text.ParserCombinators.ReadP.P b1_sc3Nx) ->
                 case Data.Version.$wparseVersion @ b1_sc3Nx w_sc3Ny of
                 { (# ww1_sc3NH [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Get @ b1_sc3Nx ww1_sc3NH
                 }}]
Data.Version.parseVersion1
  = \ (@ b1_sc3Nx)
      (w_sc3Ny :: Version -> Text.ParserCombinators.ReadP.P b1_sc3Nx) ->
      case Data.Version.$wparseVersion @ b1_sc3Nx w_sc3Ny of
      { (# ww1_sc3NH #) ->
      Text.ParserCombinators.ReadP.Get @ b1_sc3Nx ww1_sc3NH
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
parseVersion :: ReadP Version
[GblId,
 Arity=1,
 Str=<L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Version.parseVersion1
               `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Version>_R)
                       :: (forall b.
                           (Version -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadP Version :: *))}]
parseVersion
  = Data.Version.parseVersion1
    `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Version>_R)
            :: (forall b.
                (Version -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b :: *)
               ~R# (ReadP Version :: *))


