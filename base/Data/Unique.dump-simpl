
==================== Tidy Core ====================
2018-03-16 16:07:30.19411332 UTC

Result size of Tidy Core
  = {terms: 128, types: 159, coercions: 76, joins: 0/0}

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Data.Unique.$fEqUnique [InlPrag=NOUSERINLINE CONLIKE] :: Eq Unique
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Unique
                        eqInteger
                        `cast` (Sym (Data.Unique.N:Unique[0])
                                ->_R Sym (Data.Unique.N:Unique[0])
                                ->_R <Bool>_R
                                :: (Integer -> Integer -> Bool :: *)
                                   ~R# (Unique -> Unique -> Bool :: *))
                        neqInteger
                        `cast` (Sym (Data.Unique.N:Unique[0])
                                ->_R Sym (Data.Unique.N:Unique[0])
                                ->_R <Bool>_R
                                :: (Integer -> Integer -> Bool :: *)
                                   ~R# (Unique -> Unique -> Bool :: *))]
Data.Unique.$fEqUnique
  = GHC.Classes.C:Eq
      @ Unique
      (eqInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Unique -> Unique -> Bool :: *)))
      (neqInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Unique -> Unique -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Data.Unique.$fOrdUnique [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord Unique
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Unique
                         Data.Unique.$fEqUnique
                         compareInteger
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R <Ordering>_R
                                 :: (Integer -> Integer -> Ordering :: *)
                                    ~R# (Unique -> Unique -> Ordering :: *))
                         ltInteger
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Unique -> Unique -> Bool :: *))
                         leInteger
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Unique -> Unique -> Bool :: *))
                         gtInteger
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Unique -> Unique -> Bool :: *))
                         geInteger
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Unique -> Unique -> Bool :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmax
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 :: (Integer -> Integer -> Integer :: *)
                                    ~R# (Unique -> Unique -> Unique :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmin
                         `cast` (Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 ->_R Sym (Data.Unique.N:Unique[0])
                                 :: (Integer -> Integer -> Integer :: *)
                                    ~R# (Unique -> Unique -> Unique :: *))]
Data.Unique.$fOrdUnique
  = GHC.Classes.C:Ord
      @ Unique
      Data.Unique.$fEqUnique
      (compareInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Ordering>_R
               :: (Integer -> Integer -> Ordering :: *)
                  ~R# (Unique -> Unique -> Ordering :: *)))
      (ltInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Unique -> Unique -> Bool :: *)))
      (leInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Unique -> Unique -> Bool :: *)))
      (gtInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Unique -> Unique -> Bool :: *)))
      (geInteger
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R <Bool>_R
               :: (Integer -> Integer -> Bool :: *)
                  ~R# (Unique -> Unique -> Bool :: *)))
      (integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmax
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               :: (Integer -> Integer -> Integer :: *)
                  ~R# (Unique -> Unique -> Unique :: *)))
      (integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmin
       `cast` (Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               ->_R Sym (Data.Unique.N:Unique[0])
               :: (Integer -> Integer -> Integer :: *)
                  ~R# (Unique -> Unique -> Unique :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rcBip :: Integer
[GblId, Unf=OtherCon []]
lvl_rcBip = 0

-- RHS size: {terms: 14, types: 32, coercions: 3, joins: 0/0}
lvl1_rcBiq
  :: State# RealWorld -> (# State# RealWorld, IORef Integer #)
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []]
lvl1_rcBiq
  = \ (s_i91ZD [OS=OneShot] :: State# RealWorld) ->
      case noDuplicate# @ RealWorld s_i91ZD of s'_i91ZE { __DEFAULT ->
      case newMutVar# @ Integer @ RealWorld lvl_rcBip s'_i91ZE of
      { (# ipv_icBfx, ipv1_icBfy #) ->
      (# ipv_icBfx,
         (GHC.STRef.STRef @ RealWorld @ Integer ipv1_icBfy)
         `cast` (Sym (GHC.IORef.N:IORef[0]) <Integer>_N
                 :: (GHC.STRef.STRef RealWorld Integer :: *)
                    ~R# (IORef Integer :: *)) #)
      }
      }

-- RHS size: {terms: 5, types: 33, coercions: 0, joins: 0/0}
uniqSource [InlPrag=NOINLINE] :: IORef Integer
[GblId]
uniqSource
  = case runRW#
           @ ('TupleRep '['TupleRep '[], 'LiftedRep])
           @ (# State# RealWorld, IORef Integer #)
           lvl1_rcBiq
    of
    { (# ipv_i91ZH, ipv1_i91ZI #) ->
    ipv1_i91ZI
    }

-- RHS size: {terms: 7, types: 2, coercions: 1, joins: 0/0}
hashUnique :: Unique -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dcBf8 [Occ=Once] :: Unique) ->
                 case hashInteger
                        (ds_dcBf8
                         `cast` (Data.Unique.N:Unique[0]
                                 :: (Unique :: *) ~R# (Integer :: *)))
                 of wild_Xy
                 { __DEFAULT ->
                 GHC.Types.I# wild_Xy
                 }}]
hashUnique
  = \ (ds_dcBf8 :: Unique) ->
      case hashInteger
             (ds_dcBf8
              `cast` (Data.Unique.N:Unique[0]
                      :: (Unique :: *) ~R# (Integer :: *)))
      of wild_Xy
      { __DEFAULT ->
      GHC.Types.I# wild_Xy
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Unique.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Unique.$trModule3 = GHC.Types.TrNameS Data.Unique.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Unique.$trModule2 = "Data.Unique"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Unique.$trModule1 = GHC.Types.TrNameS Data.Unique.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Unique.$trModule
  = GHC.Types.Module Data.Unique.$trModule3 Data.Unique.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rcBir :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rcBir
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tcUnique2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Unique.$tcUnique2 = "Unique"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tcUnique1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Unique.$tcUnique1 = GHC.Types.TrNameS Data.Unique.$tcUnique2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tcUnique :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Unique.$tcUnique
  = GHC.Types.TyCon
      9376197555697821408##
      12289580968443169787##
      Data.Unique.$trModule
      Data.Unique.$tcUnique1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rcBis :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rcBis
  = GHC.Types.KindRepTyConApp
      Data.Unique.$tcUnique (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tc'Unique1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Unique.$tc'Unique1
  = GHC.Types.KindRepFun $krep_rcBir $krep1_rcBis

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tc'Unique3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Unique.$tc'Unique3 = "'Unique"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tc'Unique2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Unique.$tc'Unique2 = GHC.Types.TrNameS Data.Unique.$tc'Unique3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Unique.$tc'Unique :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Unique.$tc'Unique
  = GHC.Types.TyCon
      6673795421757133892##
      3923002115329816747##
      Data.Unique.$trModule
      Data.Unique.$tc'Unique2
      0#
      Data.Unique.$tc'Unique1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Unique.newUnique3 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Unique.newUnique3 = 1

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
Data.Unique.newUnique2 :: Integer -> (Integer, Integer)
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 50 30}]
Data.Unique.newUnique2
  = \ (a1_icBfU :: Integer) ->
      case plusInteger a1_icBfU Data.Unique.newUnique3 of a'1_icBg0
      { __DEFAULT ->
      (a'1_icBg0, a'1_icBg0)
      }

-- RHS size: {terms: 16, types: 33, coercions: 4, joins: 0/0}
Data.Unique.newUnique1
  :: State# RealWorld -> (# State# RealWorld, Unique #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 34 30}]
Data.Unique.newUnique1
  = \ (s_i7IAv :: State# RealWorld) ->
      case uniqSource
           `cast` (GHC.IORef.N:IORef[0] <Integer>_N
                   :: (IORef Integer :: *)
                      ~R# (GHC.STRef.STRef RealWorld Integer :: *))
      of
      { GHC.STRef.STRef r#_icBfS ->
      case atomicModifyMutVar#
             @ RealWorld
             @ Integer
             @ (Integer, Integer)
             @ Integer
             r#_icBfS
             Data.Unique.newUnique2
             s_i7IAv
      of
      { (# ipv_icBg3, ipv1_icBg4 #) ->
      case ipv1_icBg4 of b1_icBg6 { __DEFAULT ->
      (# ipv_icBg3,
         b1_icBg6
         `cast` (Sym (Data.Unique.N:Unique[0])
                 :: (Integer :: *) ~R# (Unique :: *)) #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
newUnique :: IO Unique
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Unique.newUnique1
               `cast` (Sym (GHC.Types.N:IO[0] <Unique>_R)
                       :: (State# RealWorld -> (# State# RealWorld, Unique #) :: *)
                          ~R# (IO Unique :: *))}]
newUnique
  = Data.Unique.newUnique1
    `cast` (Sym (GHC.Types.N:IO[0] <Unique>_R)
            :: (State# RealWorld -> (# State# RealWorld, Unique #) :: *)
               ~R# (IO Unique :: *))


