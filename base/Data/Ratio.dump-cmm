
==================== Output Cmm ====================
2018-03-16 16:07:30.808057101 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.808928343 UTC

[section ""data" . lvl_rcBZq_closure" {
     lvl_rcBZq_closure:
         const lvl_rcBZq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBZq_entry() //  [R1]
         { info_tbl: [(ccC0F,
                       label: lvl_rcBZq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC0F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC0G; else goto ccC0H;
       ccC0G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC0H: // global
           (_ccC0C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC0C::I64 == 0) goto ccC0E; else goto ccC0D;
       ccC0E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC0D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC0C::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.809915329 UTC

[section ""data" . sat_scBZu_closure" {
     sat_scBZu_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.810469518 UTC

[section ""data" . sat_scBZv_closure" {
     sat_scBZv_closure:
         const :_con_info;
         const sat_scBZu_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.811246697 UTC

[section ""data" . lvl1_rcBZr_closure" {
     lvl1_rcBZr_closure:
         const lvl1_rcBZr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rcBZr_entry() //  [R1]
         { info_tbl: [(ccC0O,
                       label: lvl1_rcBZr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC0O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC0P; else goto ccC0Q;
       ccC0P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC0Q: // global
           (_ccC0L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC0L::I64 == 0) goto ccC0N; else goto ccC0M;
       ccC0N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC0M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC0L::I64;
           R3 = sat_scBZv_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.81314145 UTC

[section ""data" . $wsimplest'_rcBZs_closure" {
     $wsimplest'_rcBZs_closure:
         const $wsimplest'_rcBZs_info;
         const 0;
 },
 $wsimplest'_rcBZs_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccC11,
                       label: $wsimplest'_rcBZs_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC11: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccC12; else goto ccC13;
       ccC12: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wsimplest'_rcBZs_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC13: // global
           I64[Sp - 40] = block_ccC0W_info;
           _scBZx::P64 = R3;
           R3 = lvl_rcBZq_closure;
           _scBZw::P64 = R2;
           R2 = _scBZx::P64;
           P64[Sp - 32] = _scBZw::P64;
           P64[Sp - 24] = _scBZx::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC0W() //  [R1]
         { info_tbl: [(ccC0W,
                       label: block_ccC0W_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC0W: // global
           if (R1 == 1) goto ucC2b; else goto ccC0Z;
       ucC2b: // global
           Sp = Sp + 40;
           call _ccC10() args: 0, res: 0, upd: 0;
       ccC0Z: // global
           _scBZw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC16_info;
           R3 = P64[Sp + 16];
           R2 = _scBZw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC16() //  [R1, R2]
         { info_tbl: [(ccC16,
                       label: block_ccC16_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC16: // global
           I64[Sp - 16] = block_ccC18_info;
           R3 = lvl_rcBZq_closure;
           _scBZD::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _scBZD::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC18() //  [R1]
         { info_tbl: [(ccC18,
                       label: block_ccC18_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC18: // global
           if (R1 == 1) goto ccC22; else goto ccC1h;
       ccC22: // global
           I64[Sp + 40] = block_ccC20_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ucC2e; else goto ccC23;
       ucC2e: // global
           call _ccC20(R1) args: 0, res: 0, upd: 0;
       ccC23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccC1h: // global
           I64[Sp] = block_ccC1e_info;
           R3 = lvl_rcBZq_closure;
           R2 = P64[Sp + 40];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC20() //  [R1]
         { info_tbl: [(ccC20,
                       label: block_ccC20_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC20: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC1e() //  [R1]
         { info_tbl: [(ccC1e,
                       label: block_ccC1e_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1e: // global
           if (R1 == 1) goto ucC2c; else goto ccC1q;
       ucC2c: // global
           Sp = Sp + 48;
           call _ccC10() args: 0, res: 0, upd: 0;
       ccC1q: // global
           I64[Sp] = block_ccC1l_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC10() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC10: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC1l() //  [R1, R2]
         { info_tbl: [(ccC1l,
                       label: block_ccC1l_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1l: // global
           I64[Sp] = block_ccC1n_info;
           R3 = R1;
           _scBZI::P64 = R2;
           R2 = P64[Sp + 16];
           P64[Sp + 32] = _scBZI::P64;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC1n() //  [R1]
         { info_tbl: [(ccC1n,
                       label: block_ccC1n_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1n: // global
           if (R1 == 1) goto ccC1P; else goto ccC1E;
       ccC1P: // global
           I64[Sp + 40] = block_ccC1N_info;
           R3 = lvl1_rcBZr_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 40;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccC1E: // global
           _scBZD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC1v_info;
           R5 = _scBZD::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC1N() //  [R1]
         { info_tbl: [(ccC1N,
                       label: block_ccC1N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1N: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC1v() //  [R1, R2]
         { info_tbl: [(ccC1v,
                       label: block_ccC1v_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1v: // global
           I64[Sp + 16] = block_ccC1x_info;
           R3 = R1;
           _scBZM::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp + 24] = _scBZM::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC1x() //  [R1]
         { info_tbl: [(ccC1x,
                       label: block_ccC1x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1x: // global
           _scBZM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC1B_info;
           R3 = _scBZM::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC1B() //  [R1]
         { info_tbl: [(ccC1B,
                       label: block_ccC1B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC1B: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.817483336 UTC

[section ""data" . Data.Ratio.$wsimplest_closure" {
     Data.Ratio.$wsimplest_closure:
         const Data.Ratio.$wsimplest_info;
         const 0;
 },
 sat_scC06_entry() //  [R1]
         { info_tbl: [(ccC2W,
                       label: sat_scC06_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2W: // global
           R2 = P64[R1 + 16];
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Ratio.$wsimplest_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccC2Z,
                       label: Data.Ratio.$wsimplest_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2Z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccC30; else goto ucC45;
       ccC30: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wsimplest_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucC45: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ccC2h() args: 0, res: 0, upd: 0;
     }
 },
 _ccC2h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2h: // global
           I64[Sp - 8] = block_ccC2k_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2k() //  [R1]
         { info_tbl: [(ccC2k,
                       label: block_ccC2k_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2k: // global
           I64[Sp - 8] = block_ccC2o_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2o() //  [R1]
         { info_tbl: [(ccC2o,
                       label: block_ccC2o_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2o: // global
           _scBZY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC2s_info;
           R3 = _scBZY::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2s() //  [R1]
         { info_tbl: [(ccC2s,
                       label: block_ccC2s_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2s: // global
           _scBZT::P64 = P64[Sp + 8];
           _scBZV::P64 = P64[Sp + 24];
           if (R1 == 1) goto ccC41; else goto ccC3C;
       ccC41: // global
           _ccC43::P64 = _scBZV::P64;
           P64[Sp + 8] = _ccC43::P64;
           _scBZW::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 24] = _scBZT::P64;
           P64[Sp + 32] = _scBZW::P64;
           Sp = Sp + 8;
           call _ccC2h() args: 0, res: 0, upd: 0;
       ccC3C: // global
           I64[Sp] = block_ccC34_info;
           R3 = _scBZV::P64;
           R2 = _scBZT::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC34() //  [R1]
         { info_tbl: [(ccC34,
                       label: block_ccC34_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC34: // global
           if (R1 == 1) goto ccC3N; else goto ucC46;
       ccC3N: // global
           I64[Sp] = block_ccC3L_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucC46: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 _ccC3L() //  [R1]
         { info_tbl: [(ccC3L,
                       label: block_ccC3L_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC3L: // global
           if (R1 == 1) goto ccC3X; else goto ucC47;
       ccC3X: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ucC47: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 _scC00() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scC00: // global
           I64[Sp - 8] = block_ccC2B_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = lvl_rcBZq_closure;
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2B() //  [R1]
         { info_tbl: [(ccC2B,
                       label: block_ccC2B_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2B: // global
           _scBZW::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto ccC3A; else goto ccC39;
       ccC3A: // global
           R5 = _scBZW::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
       ccC39: // global
           I64[Sp] = block_ccC2F_info;
           R3 = _scBZW::P64;
           R2 = lvl_rcBZq_closure;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2F() //  [R1]
         { info_tbl: [(ccC2F,
                       label: block_ccC2F_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2F: // global
           I64[Sp - 8] = block_ccC2J_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2J() //  [R1]
         { info_tbl: [(ccC2J,
                       label: block_ccC2J_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2J: // global
           _scC03::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC2N_info;
           R3 = _scC03::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC2N() //  [R1]
         { info_tbl: [(ccC2N,
                       label: block_ccC2N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC2N: // global
           if (R1 == 1) goto ccC3n; else goto ccC3f;
       ccC3n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccC3q; else goto ccC3p;
       ccC3q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccC3p: // global
           I64[Hp - 16] = sat_scC06_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccC3g_info;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       ccC3f: // global
           R2 = lvl1_rcBZr_closure;
           R1 = lvl_rcBZq_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC3g() //  [R1]
         { info_tbl: [(ccC3g,
                       label: block_ccC3g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC3g: // global
           _scBZW::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccC3k_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = _scBZW::P64;
           R2 = R1;
           Sp = Sp + 24;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC3k() //  [R1, R2]
         { info_tbl: [(ccC3k,
                       label: block_ccC3k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC3k: // global
           I64[Sp - 8] = block_ccC3m_info;
           _scC09::P64 = R2;
           R2 = R1;
           P64[Sp] = _scC09::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC3m() //  [R1]
         { info_tbl: [(ccC3m,
                       label: block_ccC3m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC3m: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.821532485 UTC

[section ""data" . Data.Ratio.$wapproxRational_closure" {
     Data.Ratio.$wapproxRational_closure:
         const Data.Ratio.$wapproxRational_info;
         const 0;
 },
 Data.Ratio.$wapproxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccC4j,
                       label: Data.Ratio.$wapproxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4j: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccC4x; else goto ccC4y;
       ccC4x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wapproxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC4y: // global
           I64[Sp - 24] = block_ccC4h_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC4h() //  [R1]
         { info_tbl: [(ccC4h,
                       label: block_ccC4h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4h: // global
           I64[Sp] = block_ccC4m_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccC4m() //  [R1]
         { info_tbl: [(ccC4m,
                       label: block_ccC4m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4m: // global
           I64[Sp] = block_ccC4q_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccC4q() //  [R1]
         { info_tbl: [(ccC4q,
                       label: block_ccC4q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4q: // global
           I64[Sp - 16] = block_ccC4u_info;
           _scC0m::P64 = P64[R1 + 15];
           R5 = _scC0m::P64;
           _scC0l::P64 = P64[R1 + 7];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp - 8] = _scC0m::P64;
           P64[Sp] = _scC0l::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC4u() //  [R1, R2]
         { info_tbl: [(ccC4u,
                       label: block_ccC4u_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4u: // global
           _scC0l::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccC4w_info;
           R5 = P64[Sp + 8];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 24];
           _scC0p::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp + 24] = _scC0p::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC4w() //  [R1, R2]
         { info_tbl: [(ccC4w,
                       label: block_ccC4w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4w: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Ratio.$wsimplest_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.823572015 UTC

[section ""data" . Data.Ratio.approxRational_closure" {
     Data.Ratio.approxRational_closure:
         const Data.Ratio.approxRational_info;
         const 0;
 },
 Data.Ratio.approxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccC4M,
                       label: Data.Ratio.approxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccC4N; else goto ccC4O;
       ccC4N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.approxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC4O: // global
           I64[Sp - 8] = block_ccC4J_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Ratio.$wapproxRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC4J() //  [R1, R2]
         { info_tbl: [(ccC4J,
                       label: block_ccC4J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccC4R; else goto ccC4Q;
       ccC4R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccC4Q: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.824654172 UTC

[section ""cstring" . Data.Ratio.$trModule4_bytes" {
     Data.Ratio.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.825491436 UTC

[section ""data" . Data.Ratio.$trModule3_closure" {
     Data.Ratio.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.82605106 UTC

[section ""cstring" . Data.Ratio.$trModule2_bytes" {
     Data.Ratio.$trModule2_bytes:
         I8[] [68,97,116,97,46,82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.826568642 UTC

[section ""data" . Data.Ratio.$trModule1_closure" {
     Data.Ratio.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.82712475 UTC

[section ""data" . Data.Ratio.$trModule_closure" {
     Data.Ratio.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Ratio.$trModule3_closure+1;
         const Data.Ratio.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.827694819 UTC

[section ""relreadonly" . ScC0R_srt" {
     ScC0R_srt:
         const sat_scBZv_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.divZeroError_closure;
         const lvl_rcBZq_closure;
         const lvl1_rcBZr_closure;
         const $wsimplest'_rcBZs_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Ratio.$wsimplest_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$w$s$c-_closure;
         const Data.Ratio.$wapproxRational_closure;
         const Data.Ratio.approxRational_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.828319796 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.829051077 UTC

[section ""data" . lvl_rcBZq_closure" {
     lvl_rcBZq_closure:
         const lvl_rcBZq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBZq_entry() //  [R1]
         { info_tbl: [(ccC4Y,
                       label: lvl_rcBZq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC4Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC4Z; else goto ccC50;
       ccC4Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC50: // global
           (_ccC4V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC4V::I64 == 0) goto ccC4X; else goto ccC4W;
       ccC4X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC4W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC4V::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.830028193 UTC

[section ""data" . sat_scBZu_closure" {
     sat_scBZu_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.830606083 UTC

[section ""data" . sat_scBZv_closure" {
     sat_scBZv_closure:
         const :_con_info;
         const sat_scBZu_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.831386677 UTC

[section ""data" . lvl1_rcBZr_closure" {
     lvl1_rcBZr_closure:
         const lvl1_rcBZr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rcBZr_entry() //  [R1]
         { info_tbl: [(ccC57,
                       label: lvl1_rcBZr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC57: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC58; else goto ccC59;
       ccC58: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC59: // global
           (_ccC54::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC54::I64 == 0) goto ccC56; else goto ccC55;
       ccC56: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC55: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC54::I64;
           R3 = sat_scBZv_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.833340995 UTC

[section ""data" . $wsimplest'_rcBZs_closure" {
     $wsimplest'_rcBZs_closure:
         const $wsimplest'_rcBZs_info;
         const 0;
 },
 $wsimplest'_rcBZs_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccC5j,
                       label: $wsimplest'_rcBZs_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5j: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccC5k; else goto ccC5l;
       ccC5k: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wsimplest'_rcBZs_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC5l: // global
           I64[Sp - 40] = block_ccC5e_info;
           _scBZx::P64 = R3;
           R3 = lvl_rcBZq_closure;
           _scBZw::P64 = R2;
           R2 = _scBZx::P64;
           P64[Sp - 32] = _scBZw::P64;
           P64[Sp - 24] = _scBZx::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5e() //  [R1]
         { info_tbl: [(ccC5e,
                       label: block_ccC5e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5e: // global
           if (R1 == 1) goto ucC6t; else goto ccC5h;
       ucC6t: // global
           Sp = Sp + 40;
           call _ccC5i() args: 0, res: 0, upd: 0;
       ccC5h: // global
           _scBZw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC5o_info;
           R3 = P64[Sp + 16];
           R2 = _scBZw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5o() //  [R1, R2]
         { info_tbl: [(ccC5o,
                       label: block_ccC5o_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5o: // global
           I64[Sp - 16] = block_ccC5q_info;
           R3 = lvl_rcBZq_closure;
           _scBZD::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _scBZD::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5q() //  [R1]
         { info_tbl: [(ccC5q,
                       label: block_ccC5q_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5q: // global
           if (R1 == 1) goto ccC6k; else goto ccC5z;
       ccC6k: // global
           I64[Sp + 40] = block_ccC6i_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ucC6w; else goto ccC6l;
       ucC6w: // global
           call _ccC6i(R1) args: 0, res: 0, upd: 0;
       ccC6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccC5z: // global
           I64[Sp] = block_ccC5w_info;
           R3 = lvl_rcBZq_closure;
           R2 = P64[Sp + 40];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC6i() //  [R1]
         { info_tbl: [(ccC6i,
                       label: block_ccC6i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6i: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC5w() //  [R1]
         { info_tbl: [(ccC5w,
                       label: block_ccC5w_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5w: // global
           if (R1 == 1) goto ucC6u; else goto ccC5I;
       ucC6u: // global
           Sp = Sp + 48;
           call _ccC5i() args: 0, res: 0, upd: 0;
       ccC5I: // global
           I64[Sp] = block_ccC5D_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5i: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC5D() //  [R1, R2]
         { info_tbl: [(ccC5D,
                       label: block_ccC5D_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5D: // global
           I64[Sp] = block_ccC5F_info;
           R3 = R1;
           _scBZI::P64 = R2;
           R2 = P64[Sp + 16];
           P64[Sp + 32] = _scBZI::P64;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5F() //  [R1]
         { info_tbl: [(ccC5F,
                       label: block_ccC5F_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5F: // global
           if (R1 == 1) goto ccC67; else goto ccC5W;
       ccC67: // global
           I64[Sp + 40] = block_ccC65_info;
           R3 = lvl1_rcBZr_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 40;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccC5W: // global
           _scBZD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC5N_info;
           R5 = _scBZD::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC65() //  [R1]
         { info_tbl: [(ccC65,
                       label: block_ccC65_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC65: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC5N() //  [R1, R2]
         { info_tbl: [(ccC5N,
                       label: block_ccC5N_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5N: // global
           I64[Sp + 16] = block_ccC5P_info;
           R3 = R1;
           _scBZM::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp + 24] = _scBZM::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5P() //  [R1]
         { info_tbl: [(ccC5P,
                       label: block_ccC5P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5P: // global
           _scBZM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC5T_info;
           R3 = _scBZM::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC5T() //  [R1]
         { info_tbl: [(ccC5T,
                       label: block_ccC5T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC5T: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.837714026 UTC

[section ""data" . Data.Ratio.$wsimplest_closure" {
     Data.Ratio.$wsimplest_closure:
         const Data.Ratio.$wsimplest_info;
         const 0;
 },
 sat_scC06_entry() //  [R1]
         { info_tbl: [(ccC7e,
                       label: sat_scC06_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC7e: // global
           R2 = P64[R1 + 16];
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Ratio.$wsimplest_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccC7h,
                       label: Data.Ratio.$wsimplest_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC7h: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccC7i; else goto ucC8n;
       ccC7i: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wsimplest_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucC8n: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ccC6z() args: 0, res: 0, upd: 0;
     }
 },
 _ccC6z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6z: // global
           I64[Sp - 8] = block_ccC6C_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC6C() //  [R1]
         { info_tbl: [(ccC6C,
                       label: block_ccC6C_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6C: // global
           I64[Sp - 8] = block_ccC6G_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC6G() //  [R1]
         { info_tbl: [(ccC6G,
                       label: block_ccC6G_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6G: // global
           _scBZY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC6K_info;
           R3 = _scBZY::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC6K() //  [R1]
         { info_tbl: [(ccC6K,
                       label: block_ccC6K_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6K: // global
           _scBZT::P64 = P64[Sp + 8];
           _scBZV::P64 = P64[Sp + 24];
           if (R1 == 1) goto ccC8j; else goto ccC7U;
       ccC8j: // global
           _ccC8l::P64 = _scBZV::P64;
           P64[Sp + 8] = _ccC8l::P64;
           _scBZW::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 24] = _scBZT::P64;
           P64[Sp + 32] = _scBZW::P64;
           Sp = Sp + 8;
           call _ccC6z() args: 0, res: 0, upd: 0;
       ccC7U: // global
           I64[Sp] = block_ccC7m_info;
           R3 = _scBZV::P64;
           R2 = _scBZT::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC7m() //  [R1]
         { info_tbl: [(ccC7m,
                       label: block_ccC7m_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC7m: // global
           if (R1 == 1) goto ccC85; else goto ucC8o;
       ccC85: // global
           I64[Sp] = block_ccC83_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucC8o: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 _ccC83() //  [R1]
         { info_tbl: [(ccC83,
                       label: block_ccC83_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC83: // global
           if (R1 == 1) goto ccC8f; else goto ucC8p;
       ccC8f: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ucC8p: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 _scC00() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scC00: // global
           I64[Sp - 8] = block_ccC6T_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = lvl_rcBZq_closure;
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC6T() //  [R1]
         { info_tbl: [(ccC6T,
                       label: block_ccC6T_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6T: // global
           _scBZW::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto ccC7S; else goto ccC7r;
       ccC7S: // global
           R5 = _scBZW::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
       ccC7r: // global
           I64[Sp] = block_ccC6X_info;
           R3 = _scBZW::P64;
           R2 = lvl_rcBZq_closure;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC6X() //  [R1]
         { info_tbl: [(ccC6X,
                       label: block_ccC6X_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6X: // global
           I64[Sp - 8] = block_ccC71_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC71() //  [R1]
         { info_tbl: [(ccC71,
                       label: block_ccC71_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC71: // global
           _scC03::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC75_info;
           R3 = _scC03::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC75() //  [R1]
         { info_tbl: [(ccC75,
                       label: block_ccC75_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC75: // global
           if (R1 == 1) goto ccC7F; else goto ccC7x;
       ccC7F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccC7I; else goto ccC7H;
       ccC7I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccC7H: // global
           I64[Hp - 16] = sat_scC06_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccC7y_info;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       ccC7x: // global
           R2 = lvl1_rcBZr_closure;
           R1 = lvl_rcBZq_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccC7y() //  [R1]
         { info_tbl: [(ccC7y,
                       label: block_ccC7y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC7y: // global
           _scBZW::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccC7C_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = _scBZW::P64;
           R2 = R1;
           Sp = Sp + 24;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC7C() //  [R1, R2]
         { info_tbl: [(ccC7C,
                       label: block_ccC7C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC7C: // global
           I64[Sp - 8] = block_ccC7E_info;
           _scC09::P64 = R2;
           R2 = R1;
           P64[Sp] = _scC09::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC7E() //  [R1]
         { info_tbl: [(ccC7E,
                       label: block_ccC7E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC7E: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.841803209 UTC

[section ""data" . Data.Ratio.$wapproxRational_closure" {
     Data.Ratio.$wapproxRational_closure:
         const Data.Ratio.$wapproxRational_info;
         const 0;
 },
 Data.Ratio.$wapproxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccC8B,
                       label: Data.Ratio.$wapproxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC8B: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccC8P; else goto ccC8Q;
       ccC8P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wapproxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC8Q: // global
           I64[Sp - 24] = block_ccC8z_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC8z() //  [R1]
         { info_tbl: [(ccC8z,
                       label: block_ccC8z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC8z: // global
           I64[Sp] = block_ccC8E_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccC8E() //  [R1]
         { info_tbl: [(ccC8E,
                       label: block_ccC8E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC8E: // global
           I64[Sp] = block_ccC8I_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccC8I() //  [R1]
         { info_tbl: [(ccC8I,
                       label: block_ccC8I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC8I: // global
           I64[Sp - 16] = block_ccC8M_info;
           _scC0m::P64 = P64[R1 + 15];
           R5 = _scC0m::P64;
           _scC0l::P64 = P64[R1 + 7];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp - 8] = _scC0m::P64;
           P64[Sp] = _scC0l::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC8M() //  [R1, R2]
         { info_tbl: [(ccC8M,
                       label: block_ccC8M_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC8M: // global
           _scC0l::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccC8O_info;
           R5 = P64[Sp + 8];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 24];
           _scC0p::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp + 24] = _scC0p::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC8O() //  [R1, R2]
         { info_tbl: [(ccC8O,
                       label: block_ccC8O_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC8O: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Ratio.$wsimplest_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.843868459 UTC

[section ""data" . Data.Ratio.approxRational_closure" {
     Data.Ratio.approxRational_closure:
         const Data.Ratio.approxRational_info;
         const 0;
 },
 Data.Ratio.approxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccC94,
                       label: Data.Ratio.approxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC94: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccC95; else goto ccC96;
       ccC95: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.approxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC96: // global
           I64[Sp - 8] = block_ccC91_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Ratio.$wapproxRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC91() //  [R1, R2]
         { info_tbl: [(ccC91,
                       label: block_ccC91_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC91: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccC99; else goto ccC98;
       ccC99: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccC98: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.84497434 UTC

[section ""cstring" . Data.Ratio.$trModule4_bytes" {
     Data.Ratio.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.845554908 UTC

[section ""data" . Data.Ratio.$trModule3_closure" {
     Data.Ratio.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.846145764 UTC

[section ""cstring" . Data.Ratio.$trModule2_bytes" {
     Data.Ratio.$trModule2_bytes:
         I8[] [68,97,116,97,46,82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.846705283 UTC

[section ""data" . Data.Ratio.$trModule1_closure" {
     Data.Ratio.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.847339042 UTC

[section ""data" . Data.Ratio.$trModule_closure" {
     Data.Ratio.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Ratio.$trModule3_closure+1;
         const Data.Ratio.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.847930107 UTC

[section ""relreadonly" . ScC0R_srt" {
     ScC0R_srt:
         const sat_scBZv_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.divZeroError_closure;
         const lvl_rcBZq_closure;
         const lvl1_rcBZr_closure;
         const $wsimplest'_rcBZs_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Ratio.$wsimplest_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$w$s$c-_closure;
         const Data.Ratio.$wapproxRational_closure;
         const Data.Ratio.approxRational_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.848827452 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.850439916 UTC

[section ""data" . lvl_rcBZq_closure" {
     lvl_rcBZq_closure:
         const lvl_rcBZq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBZq_entry() //  [R1]
         { info_tbl: [(ccC9g,
                       label: lvl_rcBZq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC9h; else goto ccC9i;
       ccC9h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC9i: // global
           (_ccC9d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC9d::I64 == 0) goto ccC9f; else goto ccC9e;
       ccC9f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC9e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC9d::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.854658328 UTC

[section ""data" . sat_scBZu_closure" {
     sat_scBZu_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.857797579 UTC

[section ""data" . sat_scBZv_closure" {
     sat_scBZv_closure:
         const :_con_info;
         const sat_scBZu_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.859667124 UTC

[section ""data" . lvl1_rcBZr_closure" {
     lvl1_rcBZr_closure:
         const lvl1_rcBZr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rcBZr_entry() //  [R1]
         { info_tbl: [(ccC9y,
                       label: lvl1_rcBZr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC9z; else goto ccC9A;
       ccC9z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC9A: // global
           (_ccC9v::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC9v::I64 == 0) goto ccC9x; else goto ccC9w;
       ccC9x: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC9w: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC9v::I64;
           R3 = sat_scBZv_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.868423136 UTC

[section ""data" . $wsimplest'_rcBZs_closure" {
     $wsimplest'_rcBZs_closure:
         const $wsimplest'_rcBZs_info;
         const 0;
 },
 $wsimplest'_rcBZs_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccC9R,
                       label: $wsimplest'_rcBZs_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccC9S; else goto ccC9T;
       ccC9S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wsimplest'_rcBZs_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC9T: // global
           I64[Sp - 40] = block_ccC9M_info;
           _scBZx::P64 = R3;
           R3 = lvl_rcBZq_closure;
           _scBZw::P64 = R2;
           R2 = _scBZx::P64;
           P64[Sp - 32] = _scBZw::P64;
           P64[Sp - 24] = _scBZx::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC9M() //  [R1]
         { info_tbl: [(ccC9M,
                       label: block_ccC9M_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9M: // global
           if (R1 == 1) goto ucCb1; else goto ccC9P;
       ucCb1: // global
           Sp = Sp + 40;
           call _ccC9Q() args: 0, res: 0, upd: 0;
       ccC9P: // global
           _scBZw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC9W_info;
           R3 = P64[Sp + 16];
           R2 = _scBZw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC9W() //  [R1, R2]
         { info_tbl: [(ccC9W,
                       label: block_ccC9W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9W: // global
           I64[Sp - 16] = block_ccC9Y_info;
           R3 = lvl_rcBZq_closure;
           _scBZD::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _scBZD::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC9Y() //  [R1]
         { info_tbl: [(ccC9Y,
                       label: block_ccC9Y_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9Y: // global
           if (R1 == 1) goto ccCaS; else goto ccCa7;
       ccCaS: // global
           I64[Sp + 40] = block_ccCaQ_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ucCb4; else goto ccCaT;
       ucCb4: // global
           call _ccCaQ(R1) args: 0, res: 0, upd: 0;
       ccCaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccCa7: // global
           I64[Sp] = block_ccCa4_info;
           R3 = lvl_rcBZq_closure;
           R2 = P64[Sp + 40];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCaQ() //  [R1]
         { info_tbl: [(ccCaQ,
                       label: block_ccCaQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCaQ: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCa4() //  [R1]
         { info_tbl: [(ccCa4,
                       label: block_ccCa4_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCa4: // global
           if (R1 == 1) goto ucCb2; else goto ccCag;
       ucCb2: // global
           Sp = Sp + 48;
           call _ccC9Q() args: 0, res: 0, upd: 0;
       ccCag: // global
           I64[Sp] = block_ccCab_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccC9Q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC9Q: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCab() //  [R1, R2]
         { info_tbl: [(ccCab,
                       label: block_ccCab_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCab: // global
           I64[Sp] = block_ccCad_info;
           R3 = R1;
           _scBZI::P64 = R2;
           R2 = P64[Sp + 16];
           P64[Sp + 32] = _scBZI::P64;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCad() //  [R1]
         { info_tbl: [(ccCad,
                       label: block_ccCad_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCad: // global
           if (R1 == 1) goto ccCaF; else goto ccCau;
       ccCaF: // global
           I64[Sp + 40] = block_ccCaD_info;
           R3 = lvl1_rcBZr_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 40;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccCau: // global
           _scBZD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCal_info;
           R5 = _scBZD::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCaD() //  [R1]
         { info_tbl: [(ccCaD,
                       label: block_ccCaD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCaD: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCal() //  [R1, R2]
         { info_tbl: [(ccCal,
                       label: block_ccCal_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCal: // global
           I64[Sp + 16] = block_ccCan_info;
           R3 = R1;
           _scBZM::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp + 24] = _scBZM::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCan() //  [R1]
         { info_tbl: [(ccCan,
                       label: block_ccCan_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCan: // global
           _scBZM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCar_info;
           R3 = _scBZM::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCar() //  [R1]
         { info_tbl: [(ccCar,
                       label: block_ccCar_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCar: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.899064994 UTC

[section ""data" . Data.Ratio.$wsimplest_closure" {
     Data.Ratio.$wsimplest_closure:
         const Data.Ratio.$wsimplest_info;
         const 0;
 },
 sat_scC06_entry() //  [R1]
         { info_tbl: [(ccCcu,
                       label: sat_scC06_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcu: // global
           R2 = P64[R1 + 16];
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Ratio.$wsimplest_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccCcx,
                       label: Data.Ratio.$wsimplest_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccCcy; else goto ucCdD;
       ccCcy: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wsimplest_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucCdD: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ccCbP() args: 0, res: 0, upd: 0;
     }
 },
 _ccCbP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCbP: // global
           I64[Sp - 8] = block_ccCbS_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCbS() //  [R1]
         { info_tbl: [(ccCbS,
                       label: block_ccCbS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCbS: // global
           I64[Sp - 8] = block_ccCbW_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCbW() //  [R1]
         { info_tbl: [(ccCbW,
                       label: block_ccCbW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCbW: // global
           _scBZY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCc0_info;
           R3 = _scBZY::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCc0() //  [R1]
         { info_tbl: [(ccCc0,
                       label: block_ccCc0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCc0: // global
           _scBZT::P64 = P64[Sp + 8];
           _scBZV::P64 = P64[Sp + 24];
           if (R1 == 1) goto ccCdz; else goto ccCda;
       ccCdz: // global
           _ccCdB::P64 = _scBZV::P64;
           P64[Sp + 8] = _ccCdB::P64;
           _scBZW::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 24] = _scBZT::P64;
           P64[Sp + 32] = _scBZW::P64;
           Sp = Sp + 8;
           call _ccCbP() args: 0, res: 0, upd: 0;
       ccCda: // global
           I64[Sp] = block_ccCcC_info;
           R3 = _scBZV::P64;
           R2 = _scBZT::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCcC() //  [R1]
         { info_tbl: [(ccCcC,
                       label: block_ccCcC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcC: // global
           if (R1 == 1) goto ccCdl; else goto ucCdE;
       ccCdl: // global
           I64[Sp] = block_ccCdj_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucCdE: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 _ccCdj() //  [R1]
         { info_tbl: [(ccCdj,
                       label: block_ccCdj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCdj: // global
           if (R1 == 1) goto ccCdv; else goto ucCdF;
       ccCdv: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ucCdF: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 _scC00() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scC00: // global
           I64[Sp - 8] = block_ccCc9_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = lvl_rcBZq_closure;
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCc9() //  [R1]
         { info_tbl: [(ccCc9,
                       label: block_ccCc9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCc9: // global
           _scBZW::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto ccCd8; else goto ccCcH;
       ccCd8: // global
           R5 = _scBZW::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
       ccCcH: // global
           I64[Sp] = block_ccCcd_info;
           R3 = _scBZW::P64;
           R2 = lvl_rcBZq_closure;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCcd() //  [R1]
         { info_tbl: [(ccCcd,
                       label: block_ccCcd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcd: // global
           I64[Sp - 8] = block_ccCch_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCch() //  [R1]
         { info_tbl: [(ccCch,
                       label: block_ccCch_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCch: // global
           _scC03::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCcl_info;
           R3 = _scC03::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCcl() //  [R1]
         { info_tbl: [(ccCcl,
                       label: block_ccCcl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcl: // global
           if (R1 == 1) goto ccCcV; else goto ccCcN;
       ccCcV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCcY; else goto ccCcX;
       ccCcY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccCcX: // global
           I64[Hp - 16] = sat_scC06_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccCcO_info;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       ccCcN: // global
           R2 = lvl1_rcBZr_closure;
           R1 = lvl_rcBZq_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCcO() //  [R1]
         { info_tbl: [(ccCcO,
                       label: block_ccCcO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcO: // global
           _scBZW::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccCcS_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = _scBZW::P64;
           R2 = R1;
           Sp = Sp + 24;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCcS() //  [R1, R2]
         { info_tbl: [(ccCcS,
                       label: block_ccCcS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcS: // global
           I64[Sp - 8] = block_ccCcU_info;
           _scC09::P64 = R2;
           R2 = R1;
           P64[Sp] = _scC09::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCcU() //  [R1]
         { info_tbl: [(ccCcU,
                       label: block_ccCcU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCcU: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.931912772 UTC

[section ""data" . Data.Ratio.$wapproxRational_closure" {
     Data.Ratio.$wapproxRational_closure:
         const Data.Ratio.$wapproxRational_info;
         const 0;
 },
 Data.Ratio.$wapproxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccCeL,
                       label: Data.Ratio.$wapproxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCeL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCeZ; else goto ccCf0;
       ccCeZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wapproxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCf0: // global
           I64[Sp - 24] = block_ccCeJ_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCeJ() //  [R1]
         { info_tbl: [(ccCeJ,
                       label: block_ccCeJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCeJ: // global
           I64[Sp] = block_ccCeO_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccCeO() //  [R1]
         { info_tbl: [(ccCeO,
                       label: block_ccCeO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCeO: // global
           I64[Sp] = block_ccCeS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccCeS() //  [R1]
         { info_tbl: [(ccCeS,
                       label: block_ccCeS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCeS: // global
           I64[Sp - 16] = block_ccCeW_info;
           _scC0m::P64 = P64[R1 + 15];
           R5 = _scC0m::P64;
           _scC0l::P64 = P64[R1 + 7];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp - 8] = _scC0m::P64;
           P64[Sp] = _scC0l::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCeW() //  [R1, R2]
         { info_tbl: [(ccCeW,
                       label: block_ccCeW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCeW: // global
           _scC0l::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccCeY_info;
           R5 = P64[Sp + 8];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 24];
           _scC0p::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp + 24] = _scC0p::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCeY() //  [R1, R2]
         { info_tbl: [(ccCeY,
                       label: block_ccCeY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCeY: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Ratio.$wsimplest_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.945018761 UTC

[section ""data" . Data.Ratio.approxRational_closure" {
     Data.Ratio.approxRational_closure:
         const Data.Ratio.approxRational_info;
         const 0;
 },
 Data.Ratio.approxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccCfC,
                       label: Data.Ratio.approxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCfC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCfD; else goto ccCfE;
       ccCfD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.approxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCfE: // global
           I64[Sp - 8] = block_ccCfz_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Ratio.$wapproxRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCfz() //  [R1, R2]
         { info_tbl: [(ccCfz,
                       label: block_ccCfz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCfz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCfH; else goto ccCfG;
       ccCfH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccCfG: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.95093898 UTC

[section ""cstring" . Data.Ratio.$trModule4_bytes" {
     Data.Ratio.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.952658947 UTC

[section ""data" . Data.Ratio.$trModule3_closure" {
     Data.Ratio.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.954359781 UTC

[section ""cstring" . Data.Ratio.$trModule2_bytes" {
     Data.Ratio.$trModule2_bytes:
         I8[] [68,97,116,97,46,82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.955969876 UTC

[section ""data" . Data.Ratio.$trModule1_closure" {
     Data.Ratio.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.957648717 UTC

[section ""data" . Data.Ratio.$trModule_closure" {
     Data.Ratio.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Ratio.$trModule3_closure+1;
         const Data.Ratio.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.959414567 UTC

[section ""relreadonly" . ScC0R_srt" {
     ScC0R_srt:
         const sat_scBZv_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.divZeroError_closure;
         const lvl_rcBZq_closure;
         const lvl1_rcBZr_closure;
         const $wsimplest'_rcBZs_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Ratio.$wsimplest_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$w$s$c-_closure;
         const Data.Ratio.$wapproxRational_closure;
         const Data.Ratio.approxRational_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.129959477 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:31.131446945 UTC

[section ""data" . lvl_rcBZq_closure" {
     lvl_rcBZq_closure:
         const lvl_rcBZq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBZq_entry() //  [R1]
         { info_tbl: [(ccCh8,
                       label: lvl_rcBZq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCh9; else goto ccCha;
       ccCh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCha: // global
           (_ccCh5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCh5::I64 == 0) goto ccCh7; else goto ccCh6;
       ccCh7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCh6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCh5::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.135858152 UTC

[section ""data" . sat_scCfX_closure" {
     sat_scCfX_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.137605927 UTC

[section ""data" . sat_scCfY_closure" {
     sat_scCfY_closure:
         const :_con_info;
         const sat_scCfX_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.13972887 UTC

[section ""data" . lvl1_rcBZr_closure" {
     lvl1_rcBZr_closure:
         const lvl1_rcBZr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rcBZr_entry() //  [R1]
         { info_tbl: [(ccCht,
                       label: lvl1_rcBZr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccChu; else goto ccChv;
       ccChu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccChv: // global
           (_ccChq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccChq::I64 == 0) goto ccChs; else goto ccChr;
       ccChs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccChr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccChq::I64;
           R3 = sat_scCfY_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.145389557 UTC

[section ""data" . $wsimplest'_rcBZs_closure" {
     $wsimplest'_rcBZs_closure:
         const $wsimplest'_rcBZs_info;
         const 0;
 },
 $wsimplest'_rcBZs_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccChP,
                       label: $wsimplest'_rcBZs_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccChP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccChQ; else goto ccChR;
       ccChQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wsimplest'_rcBZs_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccChR: // global
           I64[Sp - 40] = block_ccChK_info;
           _scCg0::P64 = R3;
           R3 = lvl_rcBZq_closure;
           _scCfZ::P64 = R2;
           R2 = _scCg0::P64;
           P64[Sp - 32] = _scCfZ::P64;
           P64[Sp - 24] = _scCg0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccChK() //  [R1]
         { info_tbl: [(ccChK,
                       label: block_ccChK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccChK: // global
           if (R1 == 1) goto ucCiZ; else goto ccChN;
       ucCiZ: // global
           Sp = Sp + 40;
           call _ccChO() args: 0, res: 0, upd: 0;
       ccChN: // global
           _scCfZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccChU_info;
           R3 = P64[Sp + 16];
           R2 = _scCfZ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccChU() //  [R1, R2]
         { info_tbl: [(ccChU,
                       label: block_ccChU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccChU: // global
           I64[Sp - 16] = block_ccChW_info;
           R3 = lvl_rcBZq_closure;
           _scCg6::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _scCg6::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccChW() //  [R1]
         { info_tbl: [(ccChW,
                       label: block_ccChW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccChW: // global
           if (R1 == 1) goto ccCiQ; else goto ccCi5;
       ccCiQ: // global
           I64[Sp + 40] = block_ccCiO_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ucCj2; else goto ccCiR;
       ucCj2: // global
           call _ccCiO(R1) args: 0, res: 0, upd: 0;
       ccCiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccCi5: // global
           I64[Sp] = block_ccCi2_info;
           R3 = lvl_rcBZq_closure;
           R2 = P64[Sp + 40];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCiO() //  [R1]
         { info_tbl: [(ccCiO,
                       label: block_ccCiO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCiO: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCi2() //  [R1]
         { info_tbl: [(ccCi2,
                       label: block_ccCi2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCi2: // global
           if (R1 == 1) goto ucCj0; else goto ccCie;
       ucCj0: // global
           Sp = Sp + 48;
           call _ccChO() args: 0, res: 0, upd: 0;
       ccCie: // global
           I64[Sp] = block_ccCi9_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccChO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccChO: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCi9() //  [R1, R2]
         { info_tbl: [(ccCi9,
                       label: block_ccCi9_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCi9: // global
           I64[Sp] = block_ccCib_info;
           R3 = R1;
           _scCgb::P64 = R2;
           R2 = P64[Sp + 16];
           P64[Sp + 32] = _scCgb::P64;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCib() //  [R1]
         { info_tbl: [(ccCib,
                       label: block_ccCib_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCib: // global
           if (R1 == 1) goto ccCiD; else goto ccCis;
       ccCiD: // global
           I64[Sp + 40] = block_ccCiB_info;
           R3 = lvl1_rcBZr_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 40;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccCis: // global
           _scCg6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCij_info;
           R5 = _scCg6::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCiB() //  [R1]
         { info_tbl: [(ccCiB,
                       label: block_ccCiB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCiB: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCij() //  [R1, R2]
         { info_tbl: [(ccCij,
                       label: block_ccCij_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCij: // global
           I64[Sp + 16] = block_ccCil_info;
           R3 = R1;
           _scCgf::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp + 24] = _scCgf::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCil() //  [R1]
         { info_tbl: [(ccCil,
                       label: block_ccCil_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCil: // global
           _scCgf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCip_info;
           R3 = _scCgf::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCip() //  [R1]
         { info_tbl: [(ccCip,
                       label: block_ccCip_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCip: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.172243825 UTC

[section ""data" . Data.Ratio.$wsimplest_closure" {
     Data.Ratio.$wsimplest_closure:
         const Data.Ratio.$wsimplest_info;
         const 0;
 },
 sat_scCgz_entry() //  [R1]
         { info_tbl: [(ccCkD,
                       label: sat_scCgz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCkD: // global
           R2 = P64[R1 + 16];
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Ratio.$wsimplest_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccCkG,
                       label: Data.Ratio.$wsimplest_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCkG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccCkH; else goto ucClM;
       ccCkH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wsimplest_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucClM: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ccCjY() args: 0, res: 0, upd: 0;
     }
 },
 _ccCjY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCjY: // global
           I64[Sp - 8] = block_ccCk1_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCk1() //  [R1]
         { info_tbl: [(ccCk1,
                       label: block_ccCk1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCk1: // global
           I64[Sp - 8] = block_ccCk5_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCk5() //  [R1]
         { info_tbl: [(ccCk5,
                       label: block_ccCk5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCk5: // global
           _scCgr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCk9_info;
           R3 = _scCgr::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCk9() //  [R1]
         { info_tbl: [(ccCk9,
                       label: block_ccCk9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCk9: // global
           _scCgm::P64 = P64[Sp + 8];
           _scCgo::P64 = P64[Sp + 24];
           if (R1 == 1) goto ccClI; else goto ccClj;
       ccClI: // global
           _ccClK::P64 = _scCgo::P64;
           P64[Sp + 8] = _ccClK::P64;
           _scCgp::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 24] = _scCgm::P64;
           P64[Sp + 32] = _scCgp::P64;
           Sp = Sp + 8;
           call _ccCjY() args: 0, res: 0, upd: 0;
       ccClj: // global
           I64[Sp] = block_ccCkL_info;
           R3 = _scCgo::P64;
           R2 = _scCgm::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCkL() //  [R1]
         { info_tbl: [(ccCkL,
                       label: block_ccCkL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCkL: // global
           if (R1 == 1) goto ccClu; else goto ucClN;
       ccClu: // global
           I64[Sp] = block_ccCls_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucClN: // global
           Sp = Sp + 8;
           call _scCgt() args: 0, res: 0, upd: 0;
     }
 },
 _ccCls() //  [R1]
         { info_tbl: [(ccCls,
                       label: block_ccCls_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCls: // global
           if (R1 == 1) goto ccClE; else goto ucClO;
       ccClE: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ucClO: // global
           Sp = Sp + 8;
           call _scCgt() args: 0, res: 0, upd: 0;
     }
 },
 _scCgt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scCgt: // global
           I64[Sp - 8] = block_ccCki_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = lvl_rcBZq_closure;
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCki() //  [R1]
         { info_tbl: [(ccCki,
                       label: block_ccCki_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCki: // global
           _scCgp::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto ccClh; else goto ccCkQ;
       ccClh: // global
           R5 = _scCgp::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
       ccCkQ: // global
           I64[Sp] = block_ccCkm_info;
           R3 = _scCgp::P64;
           R2 = lvl_rcBZq_closure;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCkm() //  [R1]
         { info_tbl: [(ccCkm,
                       label: block_ccCkm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCkm: // global
           I64[Sp - 8] = block_ccCkq_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCkq() //  [R1]
         { info_tbl: [(ccCkq,
                       label: block_ccCkq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCkq: // global
           _scCgw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCku_info;
           R3 = _scCgw::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCku() //  [R1]
         { info_tbl: [(ccCku,
                       label: block_ccCku_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCku: // global
           if (R1 == 1) goto ccCl4; else goto ccCkW;
       ccCl4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCl7; else goto ccCl6;
       ccCl7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccCl6: // global
           I64[Hp - 16] = sat_scCgz_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccCkX_info;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       ccCkW: // global
           R2 = lvl1_rcBZr_closure;
           R1 = lvl_rcBZq_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCkX() //  [R1]
         { info_tbl: [(ccCkX,
                       label: block_ccCkX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCkX: // global
           _scCgp::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccCl1_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = _scCgp::P64;
           R2 = R1;
           Sp = Sp + 24;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCl1() //  [R1, R2]
         { info_tbl: [(ccCl1,
                       label: block_ccCl1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCl1: // global
           I64[Sp - 8] = block_ccCl3_info;
           _scCgC::P64 = R2;
           R2 = R1;
           P64[Sp] = _scCgC::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCl3() //  [R1]
         { info_tbl: [(ccCl3,
                       label: block_ccCl3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCl3: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.218107873 UTC

[section ""data" . Data.Ratio.$wapproxRational_closure" {
     Data.Ratio.$wapproxRational_closure:
         const Data.Ratio.$wapproxRational_info;
         const 0;
 },
 Data.Ratio.$wapproxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccCn7,
                       label: Data.Ratio.$wapproxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCn7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCnl; else goto ccCnm;
       ccCnl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wapproxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCnm: // global
           I64[Sp - 24] = block_ccCn5_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCn5() //  [R1]
         { info_tbl: [(ccCn5,
                       label: block_ccCn5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCn5: // global
           I64[Sp] = block_ccCna_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccCna() //  [R1]
         { info_tbl: [(ccCna,
                       label: block_ccCna_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCna: // global
           I64[Sp] = block_ccCne_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccCne() //  [R1]
         { info_tbl: [(ccCne,
                       label: block_ccCne_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCne: // global
           I64[Sp - 16] = block_ccCni_info;
           _scCgP::P64 = P64[R1 + 15];
           R5 = _scCgP::P64;
           _scCgO::P64 = P64[R1 + 7];
           R4 = _scCgO::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp - 8] = _scCgP::P64;
           P64[Sp] = _scCgO::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCni() //  [R1, R2]
         { info_tbl: [(ccCni,
                       label: block_ccCni_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCni: // global
           _scCgO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccCnk_info;
           R5 = P64[Sp + 8];
           R4 = _scCgO::P64;
           R3 = P64[Sp + 24];
           _scCgS::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp + 24] = _scCgS::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCnk() //  [R1, R2]
         { info_tbl: [(ccCnk,
                       label: block_ccCnk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCnk: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Ratio.$wsimplest_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.231386456 UTC

[section ""data" . Data.Ratio.approxRational_closure" {
     Data.Ratio.approxRational_closure:
         const Data.Ratio.approxRational_info;
         const 0;
 },
 Data.Ratio.approxRational_entry() //  [R2, R3, R4]
         { info_tbl: [(ccCo5,
                       label: Data.Ratio.approxRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCo5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCo6; else goto ccCo7;
       ccCo6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.approxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCo7: // global
           I64[Sp - 8] = block_ccCo2_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Ratio.$wapproxRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCo2() //  [R1, R2]
         { info_tbl: [(ccCo2,
                       label: block_ccCo2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCo2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCoa; else goto ccCo9;
       ccCoa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccCo9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.237100791 UTC

[section ""cstring" . Data.Ratio.$trModule4_bytes" {
     Data.Ratio.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.23934245 UTC

[section ""data" . Data.Ratio.$trModule3_closure" {
     Data.Ratio.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.241057775 UTC

[section ""cstring" . Data.Ratio.$trModule2_bytes" {
     Data.Ratio.$trModule2_bytes:
         I8[] [68,97,116,97,46,82,97,116,105,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.242752383 UTC

[section ""data" . Data.Ratio.$trModule1_closure" {
     Data.Ratio.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.244441059 UTC

[section ""data" . Data.Ratio.$trModule_closure" {
     Data.Ratio.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Ratio.$trModule3_closure+1;
         const Data.Ratio.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.246151115 UTC

[section ""relreadonly" . ScChw_srt" {
     ScChw_srt:
         const sat_scCfY_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.divZeroError_closure;
         const lvl_rcBZq_closure;
         const lvl1_rcBZr_closure;
         const $wsimplest'_rcBZs_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Ratio.$wsimplest_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$w$s$c-_closure;
         const Data.Ratio.$wapproxRational_closure;
         const Data.Ratio.approxRational_closure;
 }]

