
==================== Output Cmm ====================
2018-03-16 16:12:18.206146393 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:18.207231877 UTC

[section ""data" . Data.Fixed.resolution_closure" {
     Data.Fixed.resolution_closure:
         const Data.Fixed.resolution_info;
 },
 Data.Fixed.resolution_entry() //  [R2]
         { info_tbl: [(cgoH9,
                       label: Data.Fixed.resolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoH9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.208352817 UTC

[section ""data" . Data.Fixed.$fDataFixed2_closure" {
     Data.Fixed.$fDataFixed2_closure:
         const Data.Fixed.$fDataFixed2_info;
 },
 Data.Fixed.$fDataFixed2_entry() //  [R2]
         { info_tbl: [(cgoHg,
                       label: Data.Fixed.$fDataFixed2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoHg: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.20963615 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgfoldl_closure" {
     Data.Fixed.$fDataFixed_$cgfoldl_closure:
         const Data.Fixed.$fDataFixed_$cgfoldl_info;
         const 0;
 },
 sat_sgoz3_entry() //  [R1]
         { info_tbl: [(cgoHr,
                       label: sat_sgoz3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoHs; else goto cgoHt;
       cgoHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_$cgfoldl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoHu,
                       label: Data.Fixed.$fDataFixed_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoHu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoHy; else goto cgoHx;
       cgoHy: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgfoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoHx: // global
           I64[Hp - 16] = sat_sgoz3_info;
           P64[Hp] = R4;
           R4 = R5;
           _sgoz0::P64 = R3;
           R3 = Hp - 16;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoz0::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.211299916 UTC

[section ""data" . Data.Fixed.$fEnumFixed1_closure" {
     Data.Fixed.$fEnumFixed1_closure:
         const Data.Fixed.$fEnumFixed1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed1_entry() //  [R1]
         { info_tbl: [(cgoHG,
                       label: Data.Fixed.$fEnumFixed1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoHH; else goto cgoHI;
       cgoHH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoHI: // global
           (_cgoHD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoHD::I64 == 0) goto cgoHF; else goto cgoHE;
       cgoHF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoHE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoHD::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.214116692 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_info;
         const 0;
 },
 sat_sgozd_entry() //  [R1]
         { info_tbl: [(cgoIa,
                       label: sat_sgozd_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoIa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoIb; else goto cgoIc;
       cgoIb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoIc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgoI8_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgoI8() //  [R1]
         { info_tbl: [(cgoI8,
                       label: block_cgoI8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoI8: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgoz9_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgoz9_entry() //  [R1, R2]
         { info_tbl: [(cgoIj,
                       label: go_sgoz9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoIj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoIk; else goto cgoIl;
       cgoIk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoIl: // global
           I64[Sp - 32] = block_cgoI0_info;
           R3 = P64[R1 + 7];
           _sgoza::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgoza::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoI0() //  [R1]
         { info_tbl: [(cgoI0,
                       label: block_cgoI0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoI0: // global
           if (R1 == 1) goto cgoIi; else goto cgoIh;
       cgoIi: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgoIh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgoIp; else goto cgoIo;
       cgoIp: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgoIo: // global
           I64[Hp - 56] = sat_sgozd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgoza::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgoza::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgoza::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgozi_entry() //  [R1]
         { info_tbl: [(cgoIK,
                       label: sat_sgozi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoIK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoIL; else goto cgoIM;
       cgoIL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoIM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgoII_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgoII() //  [R1]
         { info_tbl: [(cgoII,
                       label: block_cgoII_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoII: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgoze_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgoze_entry() //  [R1, R2]
         { info_tbl: [(cgoIT,
                       label: go_sgoze_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoIT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoIU; else goto cgoIV;
       cgoIU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoIV: // global
           I64[Sp - 32] = block_cgoIA_info;
           R3 = P64[R1 + 7];
           _sgozf::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgozf::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoIA() //  [R1]
         { info_tbl: [(cgoIA,
                       label: block_cgoIA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoIA: // global
           if (R1 == 1) goto cgoIS; else goto cgoIR;
       cgoIS: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgoIR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgoIZ; else goto cgoIY;
       cgoIZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgoIY: // global
           I64[Hp - 56] = sat_sgozi_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgozf::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgozf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgozf::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgoJ3,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoJ3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoJ4; else goto cgoJ5;
       cgoJ4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoJ5: // global
           I64[Sp - 24] = block_cgoHN_info;
           _sgoz5::P64 = R3;
           R3 = R2;
           _sgoz4::P64 = R2;
           R2 = _sgoz5::P64;
           P64[Sp - 16] = _sgoz4::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoHN() //  [R1]
         { info_tbl: [(cgoHN,
                       label: block_cgoHN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoHN: // global
           I64[Sp - 8] = block_cgoHR_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoHR() //  [R1]
         { info_tbl: [(cgoHR,
                       label: block_cgoHR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoHR: // global
           _sgoz4::P64 = P64[Sp + 16];
           _sgoz6::P64 = P64[Sp + 24];
           _sgoz7::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgoJc; else goto cgoJ8;
       cgoJc: // global
           Hp = Hp + 24;
           _sgoz8::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgoJf; else goto cgoJe;
       cgoJe: // global
           I64[Hp - 16] = go_sgoze_info;
           P64[Hp - 8] = _sgoz6::P64;
           P64[Hp] = _sgoz7::P64;
           R2 = _sgoz4::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgoze_entry(R2, R1) args: 8, res: 0, upd: 8;
       cgoJ8: // global
           Hp = Hp + 24;
           _sgoz8::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgoJf; else goto cgoJa;
       cgoJf: // global
           HpAlloc = 24;
           R1 = _sgoz8::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgoJa: // global
           I64[Hp - 16] = go_sgoz9_info;
           P64[Hp - 8] = _sgoz6::P64;
           P64[Hp] = _sgoz7::P64;
           R2 = _sgoz4::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgoz9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.218332546 UTC

[section ""data" . sat_sgozj_closure" {
     sat_sgozj_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.219015201 UTC

[section ""data" . sat_sgozk_closure" {
     sat_sgozk_closure:
         const :_con_info;
         const sat_sgozj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.219982971 UTC

[section ""data" . Data.Fixed.$fEnumFixed2_closure" {
     Data.Fixed.$fEnumFixed2_closure:
         const Data.Fixed.$fEnumFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed2_entry() //  [R1]
         { info_tbl: [(cgoJm,
                       label: Data.Fixed.$fEnumFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoJm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoJn; else goto cgoJo;
       cgoJn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoJo: // global
           (_cgoJj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoJj::I64 == 0) goto cgoJl; else goto cgoJk;
       cgoJl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoJk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoJj::I64;
           R3 = sat_sgozk_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.221960952 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromTo_info;
         const 0;
 },
 sat_sgozr_entry() //  [R1]
         { info_tbl: [(cgoJI,
                       label: sat_sgozr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoJI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoJJ; else goto cgoJK;
       cgoJJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoJK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgoJG_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgoJG() //  [R1]
         { info_tbl: [(cgoJG,
                       label: block_cgoJG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoJG: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgozn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgozn_entry() //  [R1, R2]
         { info_tbl: [(cgoJR,
                       label: go_sgozn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoJR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgoJS; else goto cgoJT;
       cgoJS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoJT: // global
           I64[Sp - 24] = block_cgoJy_info;
           R3 = P64[R1 + 7];
           _sgozo::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgozo::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoJy() //  [R1]
         { info_tbl: [(cgoJy,
                       label: block_cgoJy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoJy: // global
           if (R1 == 1) goto cgoJQ; else goto cgoJP;
       cgoJQ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgoJP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoJX; else goto cgoJW;
       cgoJX: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgoJW: // global
           I64[Hp - 48] = sat_sgozr_info;
           P64[Hp - 32] = P64[Sp + 8];
           _sgozo::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sgozo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgozo::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(cgoK1,
                       label: Data.Fixed.$fEnumFixed_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoK1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgoK5; else goto cgoK4;
       cgoK5: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoK4: // global
           I64[Hp - 8] = go_sgozn_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgozn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.22523512 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThen_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThen_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThen_info;
         const 0;
 },
 d_sgozu_entry() //  [R1]
         { info_tbl: [(cgoKe,
                       label: d_sgozu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoKf; else goto cgoKg;
       cgoKf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoKg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgozz_entry() //  [R1]
         { info_tbl: [(cgoKx,
                       label: sat_sgozz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoKy; else goto cgoKz;
       cgoKy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoKz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgoKv_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgoKv() //  [R1]
         { info_tbl: [(cgoKv,
                       label: block_cgoKv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKv: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgozv_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgozv_entry() //  [R1, R2]
         { info_tbl: [(cgoKD,
                       label: go_sgozv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgoKF; else goto cgoKG;
       cgoKF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoKG: // global
           I64[Sp - 24] = block_cgoKm_info;
           _sgozv::P64 = R1;
           _sgozu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgozu::P64;
           P64[Sp - 8] = _sgozv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugoKK; else goto cgoKn;
       ugoKK: // global
           call _cgoKm(R1) args: 0, res: 0, upd: 0;
       cgoKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoKm() //  [R1]
         { info_tbl: [(cgoKm,
                       label: block_cgoKm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgoKJ; else goto cgoKI;
       cgoKJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoKI: // global
           I64[Hp - 56] = sat_sgozz_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(cgoKL,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgoKP; else goto cgoKO;
       cgoKP: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoKO: // global
           I64[Hp - 40] = d_sgozu_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = go_sgozv_info;
           P64[Hp] = Hp - 40;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgozv_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.22842593 UTC

[section ""data" . Data.Fixed.$fEnumFixed3_closure" {
     Data.Fixed.$fEnumFixed3_closure:
         const Data.Fixed.$fEnumFixed3_info;
         const 0;
 },
 sat_sgozD_entry() //  [R1]
         { info_tbl: [(cgoL5,
                       label: sat_sgozD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoL5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgoL6; else goto cgoL7;
       cgoL6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoL7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgoL3_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgoL3() //  [R1]
         { info_tbl: [(cgoL3,
                       label: block_cgoL3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoL3: // global
           R2 = R1;
           Sp = Sp + 8;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fEnumFixed3_entry() //  [R2]
         { info_tbl: [(cgoLb,
                       label: Data.Fixed.$fEnumFixed3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgoLd; else goto cgoLe;
       cgoLd: // global
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoLe: // global
           I64[Sp - 8] = block_cgoKU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugoLi; else goto cgoKV;
       ugoLi: // global
           call _cgoKU(R1) args: 0, res: 0, upd: 0;
       cgoKV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoKU() //  [R1]
         { info_tbl: [(cgoKU,
                       label: block_cgoKU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoKU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgoLh; else goto cgoLg;
       cgoLh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoLg: // global
           I64[Hp - 40] = sat_sgozD_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.232323309 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFrom_closure" {
     Data.Fixed.$fEnumFixed_$cenumFrom_closure:
         const Data.Fixed.$fEnumFixed_$cenumFrom_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed_$cenumFrom_entry() //  [R2]
         { info_tbl: [(cgoLn,
                       label: Data.Fixed.$fEnumFixed_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLn: // global
           R2 = R2;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.233435949 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cfromEnum_closure" {
     Data.Fixed.$fEnumFixed_$cfromEnum_closure:
         const Data.Fixed.$fEnumFixed_$cfromEnum_info;
 },
 Data.Fixed.$fEnumFixed_$cfromEnum_entry() //  [R2]
         { info_tbl: [(cgoLu,
                       label: Data.Fixed.$fEnumFixed_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLu: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.234345814 UTC

[section ""data" . Data.Fixed.$fEnumFixed4_closure" {
     Data.Fixed.$fEnumFixed4_closure:
         const Data.Fixed.$fEnumFixed4_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed4_entry() //  [R2]
         { info_tbl: [(cgoLB,
                       label: Data.Fixed.$fEnumFixed4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLB: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.235272336 UTC

[section ""data" . Data.Fixed.$fEnumFixed5_closure" {
     Data.Fixed.$fEnumFixed5_closure:
         const Data.Fixed.$fEnumFixed5_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed5_entry() //  [R2]
         { info_tbl: [(cgoLI,
                       label: Data.Fixed.$fEnumFixed5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLI: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.236102671 UTC

[section ""data" . Data.Fixed.$fEnumFixed_closure" {
     Data.Fixed.$fEnumFixed_closure:
         const GHC.Enum.C:Enum_con_info;
         const Data.Fixed.$fEnumFixed5_closure+1;
         const Data.Fixed.$fEnumFixed4_closure+1;
         const GHC.Enum.$fEnumInteger_$ctoEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cfromEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFrom_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.236916195 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE0_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE0_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_$cresolution_entry() //  []
         { info_tbl: [(cgoLP,
                       label: Data.Fixed.$fHasResolutionE0_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLP: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.237866779 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_closure" {
     Data.Fixed.$fHasResolutionE0_closure:
         const Data.Fixed.$fHasResolutionE0_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_entry() //  [R2]
         { info_tbl: [(cgoLW,
                       label: Data.Fixed.$fHasResolutionE0_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoLW: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE0_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.238670908 UTC

[section ""data" . sat_sgozJ_closure" {
     sat_sgozJ_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.239319864 UTC

[section ""data" . sat_sgozK_closure" {
     sat_sgozK_closure:
         const :_con_info;
         const sat_sgozJ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.240176171 UTC

[section ""data" . Data.Fixed.$fHasResolutionE4_closure" {
     Data.Fixed.$fHasResolutionE4_closure:
         const Data.Fixed.$fHasResolutionE4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE4_entry() //  [R1]
         { info_tbl: [(cgoM5,
                       label: Data.Fixed.$fHasResolutionE4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoM5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoM6; else goto cgoM7;
       cgoM6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoM7: // global
           (_cgoM2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoM2::I64 == 0) goto cgoM4; else goto cgoM3;
       cgoM4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoM3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoM2::I64;
           R3 = sat_sgozK_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.241366789 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE1_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE1_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_$cresolution_entry() //  []
         { info_tbl: [(cgoMc,
                       label: Data.Fixed.$fHasResolutionE1_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMc: // global
           R1 = Data.Fixed.$fHasResolutionE4_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.24231976 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_closure" {
     Data.Fixed.$fHasResolutionE1_closure:
         const Data.Fixed.$fHasResolutionE1_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_entry() //  [R2]
         { info_tbl: [(cgoMj,
                       label: Data.Fixed.$fHasResolutionE1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMj: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE1_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.243074013 UTC

[section ""data" . sat_sgozM_closure" {
     sat_sgozM_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.243778324 UTC

[section ""data" . sat_sgozN_closure" {
     sat_sgozN_closure:
         const :_con_info;
         const sat_sgozM_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.244561545 UTC

[section ""data" . Data.Fixed.$fHasResolutionE7_closure" {
     Data.Fixed.$fHasResolutionE7_closure:
         const Data.Fixed.$fHasResolutionE7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE7_entry() //  [R1]
         { info_tbl: [(cgoMs,
                       label: Data.Fixed.$fHasResolutionE7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoMt; else goto cgoMu;
       cgoMt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoMu: // global
           (_cgoMp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoMp::I64 == 0) goto cgoMr; else goto cgoMq;
       cgoMr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoMq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoMp::I64;
           R3 = sat_sgozN_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.245860132 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE2_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE2_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_$cresolution_entry() //  []
         { info_tbl: [(cgoMz,
                       label: Data.Fixed.$fHasResolutionE2_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMz: // global
           R1 = Data.Fixed.$fHasResolutionE7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.246820479 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_closure" {
     Data.Fixed.$fHasResolutionE2_closure:
         const Data.Fixed.$fHasResolutionE2_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_entry() //  [R2]
         { info_tbl: [(cgoMG,
                       label: Data.Fixed.$fHasResolutionE2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMG: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE2_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.247611863 UTC

[section ""data" . sat_sgozP_closure" {
     sat_sgozP_closure:
         const GHC.Types.I#_con_info;
         const 1000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.248268192 UTC

[section ""data" . sat_sgozQ_closure" {
     sat_sgozQ_closure:
         const :_con_info;
         const sat_sgozP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.249046917 UTC

[section ""data" . Data.Fixed.$fHasResolutionE8_closure" {
     Data.Fixed.$fHasResolutionE8_closure:
         const Data.Fixed.$fHasResolutionE8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE8_entry() //  [R1]
         { info_tbl: [(cgoMP,
                       label: Data.Fixed.$fHasResolutionE8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoMQ; else goto cgoMR;
       cgoMQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoMR: // global
           (_cgoMM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoMM::I64 == 0) goto cgoMO; else goto cgoMN;
       cgoMO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoMN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoMM::I64;
           R3 = sat_sgozQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.250212955 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE3_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE3_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_$cresolution_entry() //  []
         { info_tbl: [(cgoMW,
                       label: Data.Fixed.$fHasResolutionE3_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoMW: // global
           R1 = Data.Fixed.$fHasResolutionE8_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.251154599 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_closure" {
     Data.Fixed.$fHasResolutionE3_closure:
         const Data.Fixed.$fHasResolutionE3_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_entry() //  [R2]
         { info_tbl: [(cgoN3,
                       label: Data.Fixed.$fHasResolutionE3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoN3: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE3_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.251956035 UTC

[section ""data" . sat_sgozS_closure" {
     sat_sgozS_closure:
         const GHC.Types.I#_con_info;
         const 1000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.252562254 UTC

[section ""data" . sat_sgozT_closure" {
     sat_sgozT_closure:
         const :_con_info;
         const sat_sgozS_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.253469043 UTC

[section ""data" . Data.Fixed.$fHasResolutionE10_closure" {
     Data.Fixed.$fHasResolutionE10_closure:
         const Data.Fixed.$fHasResolutionE10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE10_entry() //  [R1]
         { info_tbl: [(cgoNc,
                       label: Data.Fixed.$fHasResolutionE10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoNd; else goto cgoNe;
       cgoNd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoNe: // global
           (_cgoN9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoN9::I64 == 0) goto cgoNb; else goto cgoNa;
       cgoNb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoNa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoN9::I64;
           R3 = sat_sgozT_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.254633998 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE6_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE6_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_$cresolution_entry() //  []
         { info_tbl: [(cgoNj,
                       label: Data.Fixed.$fHasResolutionE6_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNj: // global
           R1 = Data.Fixed.$fHasResolutionE10_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.25553858 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_closure" {
     Data.Fixed.$fHasResolutionE6_closure:
         const Data.Fixed.$fHasResolutionE6_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_entry() //  [R2]
         { info_tbl: [(cgoNq,
                       label: Data.Fixed.$fHasResolutionE6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNq: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE6_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.256348466 UTC

[section ""data" . sat_sgozV_closure" {
     sat_sgozV_closure:
         const GHC.Types.I#_con_info;
         const 1000000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.256957622 UTC

[section ""data" . sat_sgozW_closure" {
     sat_sgozW_closure:
         const :_con_info;
         const sat_sgozV_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.257895721 UTC

[section ""data" . Data.Fixed.$fHasResolutionE11_closure" {
     Data.Fixed.$fHasResolutionE11_closure:
         const Data.Fixed.$fHasResolutionE11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE11_entry() //  [R1]
         { info_tbl: [(cgoNz,
                       label: Data.Fixed.$fHasResolutionE11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoNA; else goto cgoNB;
       cgoNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoNB: // global
           (_cgoNw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoNw::I64 == 0) goto cgoNy; else goto cgoNx;
       cgoNy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoNx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoNw::I64;
           R3 = sat_sgozW_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.259059144 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE9_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE9_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_$cresolution_entry() //  []
         { info_tbl: [(cgoNG,
                       label: Data.Fixed.$fHasResolutionE9_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNG: // global
           R1 = Data.Fixed.$fHasResolutionE11_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.259939423 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_closure" {
     Data.Fixed.$fHasResolutionE9_closure:
         const Data.Fixed.$fHasResolutionE9_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_entry() //  [R2]
         { info_tbl: [(cgoNN,
                       label: Data.Fixed.$fHasResolutionE9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNN: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE9_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.260771321 UTC

[section ""data" . sat_sgozZ_closure" {
     sat_sgozZ_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.261674432 UTC

[section ""data" . sat_sgoA0_closure" {
     sat_sgoA0_closure:
         const :_con_info;
         const sat_sgozZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.262328735 UTC

[section ""data" . sat_sgozY_closure" {
     sat_sgozY_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.262905331 UTC

[section ""data" . sat_sgoA1_closure" {
     sat_sgoA1_closure:
         const :_con_info;
         const sat_sgozY_closure+1;
         const sat_sgoA0_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.263825848 UTC

[section ""data" . Data.Fixed.$fHasResolutionE5_closure" {
     Data.Fixed.$fHasResolutionE5_closure:
         const Data.Fixed.$fHasResolutionE5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE5_entry() //  [R1]
         { info_tbl: [(cgoNW,
                       label: Data.Fixed.$fHasResolutionE5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoNW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoNX; else goto cgoNY;
       cgoNX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoNY: // global
           (_cgoNT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoNT::I64 == 0) goto cgoNV; else goto cgoNU;
       cgoNV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoNU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoNT::I64;
           R3 = sat_sgoA1_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.264951464 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE12_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE12_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_$cresolution_entry() //  []
         { info_tbl: [(cgoO3,
                       label: Data.Fixed.$fHasResolutionE12_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoO3: // global
           R1 = Data.Fixed.$fHasResolutionE5_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.26580867 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_closure" {
     Data.Fixed.$fHasResolutionE12_closure:
         const Data.Fixed.$fHasResolutionE12_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_entry() //  [R2]
         { info_tbl: [(cgoOa,
                       label: Data.Fixed.$fHasResolutionE12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOa: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE12_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.266507798 UTC

[section ""cstring" . Data.Fixed.$fDataFixed6_bytes" {
     Data.Fixed.$fDataFixed6_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.267264459 UTC

[section ""data" . Data.Fixed.$fDataFixed5_closure" {
     Data.Fixed.$fDataFixed5_closure:
         const Data.Fixed.$fDataFixed5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed5_entry() //  [R1]
         { info_tbl: [(cgoOj,
                       label: Data.Fixed.$fDataFixed5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoOk; else goto cgoOl;
       cgoOk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoOl: // global
           (_cgoOg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoOg::I64 == 0) goto cgoOi; else goto cgoOh;
       cgoOi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoOh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoOg::I64;
           R2 = Data.Fixed.$fDataFixed6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.268205975 UTC

[section ""cstring" . w1_rgoyk_bytes" {
     w1_rgoyk_bytes:
         I8[] [77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.269972179 UTC

[section ""data" . w2_rgoyl_closure" {
     w2_rgoyl_closure:
         const w2_rgoyl_info;
         const 0;
         const 0;
         const 0;
 },
 w2_rgoyl_entry() //  [R1]
         { info_tbl: [(cgoOs,
                       label: w2_rgoyl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoOt; else goto cgoOu;
       cgoOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoOu: // global
           (_cgoOp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoOp::I64 == 0) goto cgoOr; else goto cgoOq;
       cgoOr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoOq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoOp::I64;
           R2 = w1_rgoyk_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.271717722 UTC

[section ""data" . go61_rgoym_closure" {
     go61_rgoym_closure:
         const go61_rgoym_info;
         const 0;
 },
 go61_rgoym_entry() //  [R2, R3]
         { info_tbl: [(cgoOG,
                       label: go61_rgoym_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoOH; else goto ugoPk;
       cgoOH: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgoym_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugoPk: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgoOw() args: 0, res: 0, upd: 0;
     }
 },
 _cgoOw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOw: // global
           _sgoA3::P64 = P64[Sp];
           I64[Sp] = block_cgoOz_info;
           R1 = _sgoA3::P64;
           if (R1 & 7 != 0) goto ugoPo; else goto cgoOA;
       ugoPo: // global
           call _cgoOz(R1) args: 0, res: 0, upd: 0;
       cgoOA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoOz() //  [R1]
         { info_tbl: [(cgoOz,
                       label: block_cgoOz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOz: // global
           if (R1 & 7 == 1) goto ugoPl; else goto cgoOE;
       ugoPl: // global
           Sp = Sp + 16;
           call _cgoOW() args: 0, res: 0, upd: 0;
       cgoOE: // global
           I64[Sp - 8] = block_cgoOO_info;
           _sgoA6::P64 = P64[R1 + 6];
           _sgoA7::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgoA7::P64;
           P64[Sp + 8] = _sgoA6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugoPp; else goto cgoOQ;
       ugoPp: // global
           call _cgoOO(R1) args: 0, res: 0, upd: 0;
       cgoOQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoOO() //  [R1]
         { info_tbl: [(cgoOO,
                       label: block_cgoOO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOO: // global
           if (R1 & 7 == 1) goto ugoPm; else goto cgoP1;
       ugoPm: // global
           Sp = Sp + 24;
           call _cgoOW() args: 0, res: 0, upd: 0;
       cgoP1: // global
           I64[Sp - 8] = block_cgoOZ_info;
           _sgoA9::P64 = P64[R1 + 6];
           _sgoAa::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgoAa::P64;
           P64[Sp + 16] = _sgoA9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugoPs; else goto cgoP2;
       ugoPs: // global
           call _cgoOZ(R1) args: 0, res: 0, upd: 0;
       cgoP2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoOW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOW: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgoOZ() //  [R1]
         { info_tbl: [(cgoOZ,
                       label: block_cgoOZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoOZ: // global
           I64[Sp] = block_cgoP6_info;
           R3 = w2_rgoyl_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoP6() //  [R1]
         { info_tbl: [(cgoP6,
                       label: block_cgoP6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoP6: // global
           if (R1 & 7 == 1) goto cgoPd; else goto cgoPh;
       cgoPd: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgoOw() args: 0, res: 0, upd: 0;
       cgoPh: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.273935556 UTC

[section ""data" . conMkFixed1_rgoyn_closure" {
     conMkFixed1_rgoyn_closure:
         const Data.Data.AlgConstr_con_info;
         const conMkFixed2_rgoyo_closure;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed4_closure" {
     Data.Fixed.$fDataFixed4_closure:
         const :_con_info;
         const Data.Fixed.conMkFixed_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed3_closure" {
     Data.Fixed.$fDataFixed3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Fixed.$fDataFixed4_closure+2;
         const 0;
 },
 section ""data" . Data.Fixed.tyFixed_closure" {
     Data.Fixed.tyFixed_closure:
         const Data.Data.DataType_con_info;
         const Data.Fixed.$fDataFixed5_closure;
         const Data.Fixed.$fDataFixed3_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.conMkFixed_closure" {
     Data.Fixed.conMkFixed_closure:
         const Data.Data.Constr_con_info;
         const conMkFixed1_rgoyn_closure+1;
         const w2_rgoyl_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Fixed.tyFixed_closure+1;
         const 0;
 },
 section ""data" . conMkFixed2_rgoyo_closure" {
     conMkFixed2_rgoyo_closure:
         const conMkFixed2_rgoyo_info;
         const 0;
         const 0;
         const 0;
 },
 conMkFixed2_rgoyo_entry() //  [R1]
         { info_tbl: [(cgoPB,
                       label: conMkFixed2_rgoyo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoPB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoPC; else goto cgoPD;
       cgoPC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoPD: // global
           (_cgoPy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoPy::I64 == 0) goto cgoPA; else goto cgoPz;
       cgoPA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoPz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoPy::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Fixed.$fDataFixed4_closure+2;
           Sp = Sp - 16;
           call go61_rgoym_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.275133772 UTC

[section ""cstring" . Data.Fixed.$trModule4_bytes" {
     Data.Fixed.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.275873181 UTC

[section ""data" . loc_rgoyp_closure" {
     loc_rgoyp_closure:
         const loc_rgoyp_info;
         const 0;
         const 0;
         const 0;
 },
 loc_rgoyp_entry() //  [R1]
         { info_tbl: [(cgoPK,
                       label: loc_rgoyp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoPK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoPL; else goto cgoPM;
       cgoPL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoPM: // global
           (_cgoPH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoPH::I64 == 0) goto cgoPJ; else goto cgoPI;
       cgoPJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoPI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoPH::I64;
           R2 = Data.Fixed.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.276752686 UTC

[section ""cstring" . Data.Fixed.$trModule2_bytes" {
     Data.Fixed.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.277506983 UTC

[section ""data" . loc1_rgoyq_closure" {
     loc1_rgoyq_closure:
         const loc1_rgoyq_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rgoyq_entry() //  [R1]
         { info_tbl: [(cgoPT,
                       label: loc1_rgoyq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoPT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoPU; else goto cgoPV;
       cgoPU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoPV: // global
           (_cgoPQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoPQ::I64 == 0) goto cgoPS; else goto cgoPR;
       cgoPS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoPR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoPQ::I64;
           R2 = Data.Fixed.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.278409525 UTC

[section ""cstring" . loc2_rgoyr_bytes" {
     loc2_rgoyr_bytes:
         I8[] [46,47,68,97,116,97,47,70,105,120,101,100,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.279106833 UTC

[section ""data" . loc3_rgoys_closure" {
     loc3_rgoys_closure:
         const loc3_rgoys_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rgoys_entry() //  [R1]
         { info_tbl: [(cgoQ2,
                       label: loc3_rgoys_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoQ3; else goto cgoQ4;
       cgoQ3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoQ4: // global
           (_cgoPZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoPZ::I64 == 0) goto cgoQ1; else goto cgoQ0;
       cgoQ1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoQ0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoPZ::I64;
           R2 = loc2_rgoyr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.280020973 UTC

[section ""data" . loc4_rgoyt_closure" {
     loc4_rgoyt_closure:
         const GHC.Types.I#_con_info;
         const 83;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.280560406 UTC

[section ""data" . loc5_rgoyu_closure" {
     loc5_rgoyu_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.281159152 UTC

[section ""data" . loc6_rgoyv_closure" {
     loc6_rgoyv_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.281728354 UTC

[section ""cstring" . $dIP_rgoyw_bytes" {
     $dIP_rgoyw_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.282462775 UTC

[section ""data" . $dIP1_rgoyx_closure" {
     $dIP1_rgoyx_closure:
         const $dIP1_rgoyx_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rgoyx_entry() //  [R1]
         { info_tbl: [(cgoQb,
                       label: $dIP1_rgoyx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoQc; else goto cgoQd;
       cgoQc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoQd: // global
           (_cgoQ8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoQ8::I64 == 0) goto cgoQa; else goto cgoQ9;
       cgoQa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoQ9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoQ8::I64;
           R2 = $dIP_rgoyw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.283378098 UTC

[section ""data" . $dIP2_rgoyy_closure" {
     $dIP2_rgoyy_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const loc4_rgoyt_closure+1;
         const loc5_rgoyu_closure+1;
         const loc4_rgoyt_closure+1;
         const loc6_rgoyv_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.284011963 UTC

[section ""data" . $dIP3_rgoyz_closure" {
     $dIP3_rgoyz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const $dIP2_rgoyy_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.284626453 UTC

[section ""data" . Data.Fixed.$trModule3_closure" {
     Data.Fixed.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.285212366 UTC

[section ""data" . Data.Fixed.$trModule1_closure" {
     Data.Fixed.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.285806437 UTC

[section ""data" . Data.Fixed.$trModule_closure" {
     Data.Fixed.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Fixed.$trModule3_closure+1;
         const Data.Fixed.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.286410733 UTC

[section ""data" . $krep_rgoyA_closure" {
     $krep_rgoyA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.286997636 UTC

[section ""data" . $krep1_rgoyB_closure" {
     $krep1_rgoyB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.287559134 UTC

[section ""data" . Data.Fixed.$tcHasResolution1_closure" {
     Data.Fixed.$tcHasResolution1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rgoyB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.288143636 UTC

[section ""data" . $krep2_rgoyC_closure" {
     $krep2_rgoyC_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.288727361 UTC

[section ""cstring" . Data.Fixed.$fDataFixed10_bytes" {
     Data.Fixed.$fDataFixed10_bytes:
         I8[] [70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.289523007 UTC

[section ""data" . Data.Fixed.$fDataFixed9_closure" {
     Data.Fixed.$fDataFixed9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$fDataFixed10_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.290104236 UTC

[section ""data" . Data.Fixed.$tcFixed_closure" {
     Data.Fixed.$tcFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$fDataFixed9_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12850707307297787398;
         const 5875431371990069009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.290715536 UTC

[section ""data" . $krep3_rgoyD_closure" {
     $krep3_rgoyD_closure:
         const :_con_info;
         const $krep2_rgoyC_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.291275222 UTC

[section ""data" . $krep4_rgoyE_closure" {
     $krep4_rgoyE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Fixed.$tcFixed_closure+1;
         const $krep3_rgoyD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.29189501 UTC

[section ""data" . Data.Fixed.$tc'MkFixed1_closure" {
     Data.Fixed.$tc'MkFixed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgoyA_closure+1;
         const $krep4_rgoyE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.292453655 UTC

[section ""cstring" . Data.Fixed.$tc'MkFixed3_bytes" {
     Data.Fixed.$tc'MkFixed3_bytes:
         I8[] [39,77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.293030719 UTC

[section ""data" . Data.Fixed.$tc'MkFixed2_closure" {
     Data.Fixed.$tc'MkFixed2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tc'MkFixed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.293649393 UTC

[section ""data" . Data.Fixed.$tc'MkFixed_closure" {
     Data.Fixed.$tc'MkFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tc'MkFixed2_closure+1;
         const Data.Fixed.$tc'MkFixed1_closure+4;
         const 8992689233320522225;
         const 9587721628087041380;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.294876481 UTC

[section ""data" . Data.Fixed.$fDataFixed8_closure" {
     Data.Fixed.$fDataFixed8_closure:
         const Data.Fixed.$fDataFixed8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed8_entry() //  [R1]
         { info_tbl: [(cgoQp,
                       label: Data.Fixed.$fDataFixed8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQp: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgoQq; else goto cgoQr;
       cgoQq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoQr: // global
           (_cgoQh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgoQh::I64 == 0) goto cgoQj; else goto cgoQi;
       cgoQj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgoQi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgoQh::I64;
           I64[Sp - 24] = block_cgoQk_info;
           R6 = 0;
           R5 = Data.Fixed.$fDataFixed9_closure+1;
           R4 = Data.Fixed.$trModule_closure+1;
           R3 = 5875431371990069009;
           R2 = 12850707307297787398;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgoQk() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgoQk,
                       label: block_cgoQk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQk: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgoQl() args: 0, res: 0, upd: 0;
     }
 },
 _cgoQl() //  []
         { info_tbl: [(cgoQl,
                       label: block_cgoQl_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgoQu; else goto cgoQt;
       cgoQu: // global
           HpAlloc = 48;
           I64[Sp] = block_cgoQl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cgoQt: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.296584993 UTC

[section ""data" . Data.Fixed.$fDataFixed7_closure" {
     Data.Fixed.$fDataFixed7_closure:
         const Data.Fixed.$fDataFixed7_info;
         const 0;
 },
 Data.Fixed.$fDataFixed7_entry() //  [R2]
         { info_tbl: [(cgoQB,
                       label: Data.Fixed.$fDataFixed7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQB: // global
           R3 = R2;
           R2 = Data.Fixed.$fDataFixed8_closure;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.297429147 UTC

[section ""data" . Data.Fixed.$fDataFixed1_closure" {
     Data.Fixed.$fDataFixed1_closure:
         const (,)_con_info;
         const Data.Fixed.$fDataFixed2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.300226323 UTC

[section ""data" . Data.Fixed.$w$cgmapMp_closure" {
     Data.Fixed.$w$cgmapMp_closure:
         const Data.Fixed.$w$cgmapMp_info;
         const 0;
 },
 lvl17_sgoAs_entry() //  [R1]
         { info_tbl: [(cgoQM,
                       label: lvl17_sgoAs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoQN; else goto cgoQO;
       cgoQN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoQO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoAP_entry() //  [R1, R2]
         { info_tbl: [(cgoR1,
                       label: sat_sgoAP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoR1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoR2; else goto cgoR3;
       cgoR2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoR3: // global
           I64[Sp - 24] = block_cgoQY_info;
           _sgoAs::P64 = P64[R1 + 7];
           _sgoAt::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgoAs::P64;
           P64[Sp - 8] = _sgoAt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugoRl; else goto cgoQZ;
       ugoRl: // global
           call _cgoQY(R1) args: 0, res: 0, upd: 0;
       cgoQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoQY() //  [R1]
         { info_tbl: [(cgoQY,
                       label: block_cgoQY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQY: // global
           I64[Sp - 8] = block_cgoR6_info;
           _sgoAM::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoAM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugoRk; else goto cgoR8;
       ugoRk: // global
           call _cgoR6(R1) args: 0, res: 0, upd: 0;
       cgoR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoR6() //  [R1]
         { info_tbl: [(cgoR6,
                       label: block_cgoR6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoR6: // global
           if (R1 & 7 == 1) goto cgoRe; else goto cgoRi;
       cgoRe: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgoRi: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgoAu_entry() //  [R1]
         { info_tbl: [(cgoRu,
                       label: lvl18_sgoAu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoRu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoRv; else goto cgoRw;
       cgoRv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoRw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoAH_entry() //  [R1]
         { info_tbl: [(cgoRN,
                       label: sat_sgoAH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoRN: // global
           _sgoAH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgoRO; else goto cgoRP;
       cgoRP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoRR; else goto cgoRQ;
       cgoRR: // global
           HpAlloc = 56;
           goto cgoRO;
       cgoRO: // global
           R1 = _sgoAH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoRQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAH::P64;
           _sgoAr::P64 = P64[_sgoAH::P64 + 16];
           _sgoAt::P64 = P64[_sgoAH::P64 + 24];
           _sgoAy::P64 = P64[_sgoAH::P64 + 32];
           _sgoAz::P64 = P64[_sgoAH::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoAy::P64;
           P64[Hp - 24] = _sgoAr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sgoAz::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoAD_entry() //  [R1, R2]
         { info_tbl: [(cgoS3,
                       label: sat_sgoAD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoS3: // global
           _sgoAA::P64 = R2;
           _sgoAD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgoS4; else goto cgoS5;
       cgoS5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoS7; else goto cgoS6;
       cgoS7: // global
           HpAlloc = 56;
           goto cgoS4;
       cgoS4: // global
           R2 = _sgoAA::P64;
           R1 = _sgoAD::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoS6: // global
           _sgoAt::P64 = P64[_sgoAD::P64 + 7];
           _sgoAy::P64 = P64[_sgoAD::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoAy::P64;
           P64[Hp - 24] = _sgoAA::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoAt::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoAE_entry() //  [R1]
         { info_tbl: [(cgoS8,
                       label: sat_sgoAE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoS8: // global
           _sgoAE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoS9; else goto cgoSa;
       cgoSa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoSc; else goto cgoSb;
       cgoSc: // global
           HpAlloc = 24;
           goto cgoS9;
       cgoS9: // global
           R1 = _sgoAE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoSb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAE::P64;
           _sgoAt::P64 = P64[_sgoAE::P64 + 16];
           _sgoAu::P64 = P64[_sgoAE::P64 + 24];
           _sgoAy::P64 = P64[_sgoAE::P64 + 32];
           I64[Hp - 16] = sat_sgoAD_info;
           P64[Hp - 8] = _sgoAt::P64;
           P64[Hp] = _sgoAy::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgoAu::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoAI_entry() //  [R1, R2]
         { info_tbl: [(cgoSd,
                       label: sat_sgoAI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoSd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgoSe; else goto cgoSf;
       cgoSe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoSf: // global
           I64[Sp - 40] = block_cgoRC_info;
           _sgoAp::P64 = P64[R1 + 7];
           _sgoAr::P64 = P64[R1 + 15];
           _sgoAt::P64 = P64[R1 + 23];
           _sgoAu::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoAp::P64;
           P64[Sp - 24] = _sgoAr::P64;
           P64[Sp - 16] = _sgoAt::P64;
           P64[Sp - 8] = _sgoAu::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugoSj; else goto cgoRD;
       ugoSj: // global
           call _cgoRC(R1) args: 0, res: 0, upd: 0;
       cgoRD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoRC() //  [R1]
         { info_tbl: [(cgoRC,
                       label: block_cgoRC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoRC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgoSi; else goto cgoSh;
       cgoSi: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoSh: // global
           _sgoAy::P64 = P64[R1 + 7];
           _sgoAz::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgoAH_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sgoAt::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sgoAt::P64;
           P64[Hp - 48] = _sgoAy::P64;
           P64[Hp - 40] = _sgoAz::P64;
           I64[Hp - 32] = sat_sgoAE_info;
           P64[Hp - 16] = _sgoAt::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sgoAy::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgoAv_entry() //  [R1]
         { info_tbl: [(cgoSo,
                       label: sat_sgoAv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoSo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoSp; else goto cgoSq;
       cgoSp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoSq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoAJ_entry() //  [R1]
         { info_tbl: [(cgoSr,
                       label: sat_sgoAJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoSr: // global
           _sgoAJ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoSs; else goto cgoSt;
       cgoSt: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgoSv; else goto cgoSu;
       cgoSv: // global
           HpAlloc = 96;
           goto cgoSs;
       cgoSs: // global
           R1 = _sgoAJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoSu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAJ::P64;
           _sgoAp::P64 = P64[_sgoAJ::P64 + 16];
           _sgoAq::P64 = P64[_sgoAJ::P64 + 24];
           _sgoAr::P64 = P64[_sgoAJ::P64 + 32];
           _sgoAt::P64 = P64[_sgoAJ::P64 + 40];
           I64[Hp - 88] = lvl18_sgoAu_info;
           P64[Hp - 72] = _sgoAq::P64;
           P64[Hp - 64] = _sgoAr::P64;
           I64[Hp - 56] = sat_sgoAI_info;
           P64[Hp - 48] = _sgoAp::P64;
           P64[Hp - 40] = _sgoAr::P64;
           P64[Hp - 32] = _sgoAt::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoAv_info;
           P64[Hp] = _sgoAt::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMp_entry() //  [R2, R3, R4]
         { info_tbl: [(cgoSw,
                       label: Data.Fixed.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoSw: // global
           _sgoAr::P64 = R4;
           _sgoAq::P64 = R3;
           _sgoAp::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoSx; else goto cgoSy;
       cgoSy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoSA; else goto cgoSz;
       cgoSA: // global
           HpAlloc = 24;
           goto cgoSx;
       cgoSx: // global
           R4 = _sgoAr::P64;
           R3 = _sgoAq::P64;
           R2 = _sgoAp::P64;
           R1 = Data.Fixed.$w$cgmapMp_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoSz: // global
           I64[Hp - 16] = lvl17_sgoAs_info;
           P64[Hp] = _sgoAp::P64;
           I64[Sp - 40] = block_cgoQP_info;
           R2 = _sgoAp::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgoAp::P64;
           P64[Sp - 16] = _sgoAq::P64;
           P64[Sp - 8] = _sgoAr::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoQP() //  [R1]
         { info_tbl: [(cgoQP,
                       label: block_cgoQP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoQP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgoSD; else goto cgoSC;
       cgoSD: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoSC: // global
           I64[Hp - 64] = sat_sgoAP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgoAJ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.305921581 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMp_closure" {
     Data.Fixed.$fDataFixed_$cgmapMp_closure:
         const Data.Fixed.$fDataFixed_$cgmapMp_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMp_entry() //  [R3, R4, R5]
         { info_tbl: [(cgoSI,
                       label: Data.Fixed.$fDataFixed_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoSI: // global
           _sgoAS::P64 = R4;
           R4 = R5;
           _sgoAR::P64 = R3;
           R3 = _sgoAS::P64;
           R2 = _sgoAR::P64;
           call Data.Fixed.$w$cgmapMp_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.307532457 UTC

[section ""data" . Data.Fixed.$w$cgmapM_closure" {
     Data.Fixed.$w$cgmapM_closure:
         const Data.Fixed.$w$cgmapM_info;
         const 0;
 },
 lvl17_sgoAX_entry() //  [R1]
         { info_tbl: [(cgoST,
                       label: lvl17_sgoAX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoST: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoSU; else goto cgoSV;
       cgoSU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoSV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoB2_entry() //  [R1, R2]
         { info_tbl: [(cgoT7,
                       label: sat_sgoB2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoT7: // global
           _sgoB0::P64 = R2;
           _sgoB2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgoT8; else goto cgoT9;
       cgoT9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgoTb; else goto cgoTa;
       cgoTb: // global
           HpAlloc = 32;
           goto cgoT8;
       cgoT8: // global
           R2 = _sgoB0::P64;
           R1 = _sgoB2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoTa: // global
           _sgoAU::P64 = P64[_sgoB2::P64 + 7];
           _sgoAZ::P64 = P64[_sgoB2::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgoAZ::P64;
           P64[Hp] = _sgoB0::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoB3_entry() //  [R1, R2]
         { info_tbl: [(cgoTc,
                       label: sat_sgoB3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoTc: // global
           _sgoAZ::P64 = R2;
           _sgoB3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgoTd; else goto cgoTe;
       cgoTe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoTg; else goto cgoTf;
       cgoTg: // global
           HpAlloc = 24;
           goto cgoTd;
       cgoTd: // global
           R2 = _sgoAZ::P64;
           R1 = _sgoB3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoTf: // global
           _sgoAU::P64 = P64[_sgoB3::P64 + 7];
           _sgoAX::P64 = P64[_sgoB3::P64 + 15];
           I64[Hp - 16] = sat_sgoB2_info;
           P64[Hp - 8] = _sgoAU::P64;
           P64[Hp] = _sgoAZ::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgoAX::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgoAY_entry() //  [R1]
         { info_tbl: [(cgoTl,
                       label: sat_sgoAY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoTl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoTm; else goto cgoTn;
       cgoTm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoTn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cgoTo,
                       label: Data.Fixed.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoTo: // global
           _sgoAW::P64 = R4;
           _sgoAV::P64 = R3;
           _sgoAU::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgoTp; else goto cgoTq;
       cgoTq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgoTs; else goto cgoTr;
       cgoTs: // global
           HpAlloc = 80;
           goto cgoTp;
       cgoTp: // global
           R4 = _sgoAW::P64;
           R3 = _sgoAV::P64;
           R2 = _sgoAU::P64;
           R1 = Data.Fixed.$w$cgmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoTr: // global
           I64[Hp - 72] = lvl17_sgoAX_info;
           P64[Hp - 56] = _sgoAV::P64;
           P64[Hp - 48] = _sgoAW::P64;
           I64[Hp - 40] = sat_sgoB3_info;
           P64[Hp - 32] = _sgoAU::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = sat_sgoAY_info;
           P64[Hp] = _sgoAU::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.310068886 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapM_closure" {
     Data.Fixed.$fDataFixed_$cgmapM_closure:
         const Data.Fixed.$fDataFixed_$cgmapM_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapM_entry() //  [R3, R4, R5]
         { info_tbl: [(cgoTx,
                       label: Data.Fixed.$fDataFixed_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoTx: // global
           _sgoB6::P64 = R4;
           R4 = R5;
           _sgoB5::P64 = R3;
           R3 = _sgoB6::P64;
           R2 = _sgoB5::P64;
           call Data.Fixed.$w$cgmapM_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.311300355 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapQi_closure" {
     Data.Fixed.$fDataFixed_$cgmapQi_closure:
         const Data.Fixed.$fDataFixed_$cgmapQi_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapQi_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoTH,
                       label: Data.Fixed.$fDataFixed_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoTH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgoTI; else goto cgoTJ;
       cgoTI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgmapQi_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoTJ: // global
           I64[Sp - 24] = block_cgoTE_info;
           R1 = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugoTR; else goto cgoTF;
       ugoTR: // global
           call _cgoTE(R1) args: 0, res: 0, upd: 0;
       cgoTF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoTE() //  [R1]
         { info_tbl: [(cgoTE,
                       label: block_cgoTE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoTE: // global
           if (I64[R1 + 7] == 0) goto cgoTQ; else goto cgoTP;
       cgoTQ: // global
           R3 = P64[Sp + 16];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoTP: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.31550821 UTC

[section ""data" . Data.Fixed.$w$cgmapMo_closure" {
     Data.Fixed.$w$cgmapMo_closure:
         const Data.Fixed.$w$cgmapMo_info;
         const 0;
 },
 lvl17_sgoBi_entry() //  [R1]
         { info_tbl: [(cgoU0,
                       label: lvl17_sgoBi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoU0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoU1; else goto cgoU2;
       cgoU1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoU2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoBI_entry() //  [R1, R2]
         { info_tbl: [(cgoUf,
                       label: sat_sgoBI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoUf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoUg; else goto cgoUh;
       cgoUg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoUh: // global
           I64[Sp - 24] = block_cgoUc_info;
           _sgoBi::P64 = P64[R1 + 7];
           _sgoBj::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgoBi::P64;
           P64[Sp - 8] = _sgoBj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugoUz; else goto cgoUd;
       ugoUz: // global
           call _cgoUc(R1) args: 0, res: 0, upd: 0;
       cgoUd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoUc() //  [R1]
         { info_tbl: [(cgoUc,
                       label: block_cgoUc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoUc: // global
           I64[Sp - 8] = block_cgoUk_info;
           _sgoBF::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoBF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugoUy; else goto cgoUm;
       ugoUy: // global
           call _cgoUk(R1) args: 0, res: 0, upd: 0;
       cgoUm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoUk() //  [R1]
         { info_tbl: [(cgoUk,
                       label: block_cgoUk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoUk: // global
           if (R1 & 7 == 1) goto cgoUs; else goto cgoUw;
       cgoUs: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgoUw: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgoBk_entry() //  [R1]
         { info_tbl: [(cgoUI,
                       label: lvl18_sgoBk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoUJ; else goto cgoUK;
       cgoUJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoUK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoBy_entry() //  [R1]
         { info_tbl: [(cgoV6,
                       label: sat_sgoBy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoV6: // global
           _sgoBy::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgoV7; else goto cgoV8;
       cgoV8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoVa; else goto cgoV9;
       cgoVa: // global
           HpAlloc = 56;
           goto cgoV7;
       cgoV7: // global
           R1 = _sgoBy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoV9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBy::P64;
           _sgoBh::P64 = P64[_sgoBy::P64 + 16];
           _sgoBj::P64 = P64[_sgoBy::P64 + 24];
           _sgoBo::P64 = P64[_sgoBy::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sgoBj::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoBu_entry() //  [R1, R2]
         { info_tbl: [(cgoVm,
                       label: sat_sgoBu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoVm: // global
           _sgoBr::P64 = R2;
           _sgoBu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgoVn; else goto cgoVo;
       cgoVo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoVq; else goto cgoVp;
       cgoVq: // global
           HpAlloc = 56;
           goto cgoVn;
       cgoVn: // global
           R2 = _sgoBr::P64;
           R1 = _sgoBu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoVp: // global
           _sgoBj::P64 = P64[_sgoBu::P64 + 7];
           _sgoBo::P64 = P64[_sgoBu::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoBj::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoBv_entry() //  [R1]
         { info_tbl: [(cgoVr,
                       label: sat_sgoBv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoVr: // global
           _sgoBv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoVs; else goto cgoVt;
       cgoVt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoVv; else goto cgoVu;
       cgoVv: // global
           HpAlloc = 24;
           goto cgoVs;
       cgoVs: // global
           R1 = _sgoBv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoVu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBv::P64;
           _sgoBj::P64 = P64[_sgoBv::P64 + 16];
           _sgoBk::P64 = P64[_sgoBv::P64 + 24];
           _sgoBo::P64 = P64[_sgoBv::P64 + 32];
           I64[Hp - 16] = sat_sgoBu_info;
           P64[Hp - 8] = _sgoBj::P64;
           P64[Hp] = _sgoBo::P64;
           R2 = _sgoBj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgoBk::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoBB_entry() //  [R1, R2]
         { info_tbl: [(cgoVw,
                       label: sat_sgoBB_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoVw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgoVx; else goto cgoVy;
       cgoVx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoVy: // global
           I64[Sp - 40] = block_cgoUQ_info;
           _sgoBf::P64 = P64[R1 + 7];
           _sgoBh::P64 = P64[R1 + 15];
           _sgoBj::P64 = P64[R1 + 23];
           _sgoBk::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoBf::P64;
           P64[Sp - 24] = _sgoBh::P64;
           P64[Sp - 16] = _sgoBj::P64;
           P64[Sp - 8] = _sgoBk::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugoVP; else goto cgoUR;
       ugoVP: // global
           call _cgoUQ(R1) args: 0, res: 0, upd: 0;
       cgoUR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoUQ() //  [R1]
         { info_tbl: [(cgoUQ,
                       label: block_cgoUQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoUQ: // global
           I64[Sp - 8] = block_cgoUV_info;
           _sgoBo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoBo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugoVO; else goto cgoUW;
       ugoVO: // global
           call _cgoUV(R1) args: 0, res: 0, upd: 0;
       cgoUW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgoUV() //  [R1]
         { info_tbl: [(cgoUV,
                       label: block_cgoUV_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoUV: // global
           _sgoBh::P64 = P64[Sp + 24];
           _sgoBj::P64 = P64[Sp + 32];
           _sgoBo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgoVB; else goto cgoVF;
       cgoVB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgoVE; else goto cgoVD;
       cgoVE: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoVD: // global
           I64[Hp - 72] = sat_sgoBy_info;
           P64[Hp - 56] = _sgoBh::P64;
           P64[Hp - 48] = _sgoBj::P64;
           P64[Hp - 40] = _sgoBo::P64;
           I64[Hp - 32] = sat_sgoBv_info;
           P64[Hp - 16] = _sgoBj::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgoBo::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgoVF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoVK; else goto cgoVJ;
       cgoVK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoVJ: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoBj::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoBl_entry() //  [R1]
         { info_tbl: [(cgoVU,
                       label: sat_sgoBl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoVU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoVV; else goto cgoVW;
       cgoVV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoVW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoBC_entry() //  [R1]
         { info_tbl: [(cgoVX,
                       label: sat_sgoBC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoVX: // global
           _sgoBC::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoVY; else goto cgoVZ;
       cgoVZ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgoW1; else goto cgoW0;
       cgoW1: // global
           HpAlloc = 96;
           goto cgoVY;
       cgoVY: // global
           R1 = _sgoBC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoW0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBC::P64;
           _sgoBf::P64 = P64[_sgoBC::P64 + 16];
           _sgoBg::P64 = P64[_sgoBC::P64 + 24];
           _sgoBh::P64 = P64[_sgoBC::P64 + 32];
           _sgoBj::P64 = P64[_sgoBC::P64 + 40];
           I64[Hp - 88] = lvl18_sgoBk_info;
           P64[Hp - 72] = _sgoBg::P64;
           P64[Hp - 64] = _sgoBh::P64;
           I64[Hp - 56] = sat_sgoBB_info;
           P64[Hp - 48] = _sgoBf::P64;
           P64[Hp - 40] = _sgoBh::P64;
           P64[Hp - 32] = _sgoBj::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoBl_info;
           P64[Hp] = _sgoBj::P64;
           R2 = _sgoBj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgoW2,
                       label: Data.Fixed.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoW2: // global
           _sgoBh::P64 = R4;
           _sgoBg::P64 = R3;
           _sgoBf::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoW3; else goto cgoW4;
       cgoW4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoW6; else goto cgoW5;
       cgoW6: // global
           HpAlloc = 24;
           goto cgoW3;
       cgoW3: // global
           R4 = _sgoBh::P64;
           R3 = _sgoBg::P64;
           R2 = _sgoBf::P64;
           R1 = Data.Fixed.$w$cgmapMo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoW5: // global
           I64[Hp - 16] = lvl17_sgoBi_info;
           P64[Hp] = _sgoBf::P64;
           I64[Sp - 40] = block_cgoU3_info;
           R2 = _sgoBf::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgoBf::P64;
           P64[Sp - 16] = _sgoBg::P64;
           P64[Sp - 8] = _sgoBh::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoU3() //  [R1]
         { info_tbl: [(cgoU3,
                       label: block_cgoU3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoU3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgoW9; else goto cgoW8;
       cgoW9: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgoW8: // global
           I64[Hp - 64] = sat_sgoBI_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgoBC_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.322802434 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMo_closure" {
     Data.Fixed.$fDataFixed_$cgmapMo_closure:
         const Data.Fixed.$fDataFixed_$cgmapMo_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMo_entry() //  [R3, R4, R5]
         { info_tbl: [(cgoWe,
                       label: Data.Fixed.$fDataFixed_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWe: // global
           _sgoBL::P64 = R4;
           R4 = R5;
           _sgoBK::P64 = R3;
           R3 = _sgoBL::P64;
           R2 = _sgoBK::P64;
           call Data.Fixed.$w$cgmapMo_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.32368148 UTC

[section ""data" . lvl_rgoyF_closure" {
     lvl_rgoyF_closure:
         const lvl_rgoyF_info;
         const 0;
 },
 lvl_rgoyF_entry() //  []
         { info_tbl: [(cgoWl,
                       label: lvl_rgoyF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWl: // global
           R1 = Data.Fixed.conMkFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.324471131 UTC

[section ""data" . lvl1_rgoyG_closure" {
     lvl1_rgoyG_closure:
         const lvl1_rgoyG_info;
         const 0;
 },
 lvl1_rgoyG_entry() //  []
         { info_tbl: [(cgoWs,
                       label: lvl1_rgoyG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWs: // global
           R1 = Data.Fixed.tyFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.325314911 UTC

[section ""data" . lvl2_rgoyH_closure" {
     lvl2_rgoyH_closure:
         const lvl2_rgoyH_info;
 },
 lvl2_rgoyH_entry() //  []
         { info_tbl: [(cgoWz,
                       label: lvl2_rgoyH_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWz: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.32612749 UTC

[section ""data" . lvl3_rgoyI_closure" {
     lvl3_rgoyI_closure:
         const lvl3_rgoyI_info;
 },
 lvl3_rgoyI_entry() //  []
         { info_tbl: [(cgoWG,
                       label: lvl3_rgoyI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWG: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.326935045 UTC

[section ""data" . lvl4_rgoyJ_closure" {
     lvl4_rgoyJ_closure:
         const lvl4_rgoyJ_info;
         const 0;
 },
 lvl4_rgoyJ_entry() //  [R2, R3]
         { info_tbl: [(cgoWN,
                       label: lvl4_rgoyJ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWN: // global
           R3 = R3;
           _sgoBT::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoBT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.32802818 UTC

[section ""data" . lvl5_rgoyK_closure" {
     lvl5_rgoyK_closure:
         const lvl5_rgoyK_info;
         const 0;
 },
 sat_sgoBZ_entry() //  [R1]
         { info_tbl: [(cgoWY,
                       label: sat_sgoBZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoWY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoWZ; else goto cgoX0;
       cgoWZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoX0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl5_rgoyK_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoX1,
                       label: lvl5_rgoyK_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoX1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgoX5; else goto cgoX4;
       cgoX5: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl5_rgoyK_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoX4: // global
           I64[Hp - 24] = sat_sgoBZ_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sgoBW::P64 = R3;
           R3 = Hp - 24;
           _sgoBV::P64 = R2;
           R2 = _sgoBW::P64;
           R1 = _sgoBV::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.329663081 UTC

[section ""data" . lvl6_rgoyL_closure" {
     lvl6_rgoyL_closure:
         const lvl6_rgoyL_info;
         const 0;
 },
 sat_sgoC4_entry() //  [R1]
         { info_tbl: [(cgoXe,
                       label: sat_sgoC4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoXe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoXf; else goto cgoXg;
       cgoXf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoXg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl6_rgoyL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoXh,
                       label: lvl6_rgoyL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoXh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgoXl; else goto cgoXk;
       cgoXl: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl6_rgoyL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoXk: // global
           I64[Hp - 24] = sat_sgoC4_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R3;
           _sgoC0::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgoC0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.331084061 UTC

[section ""data" . lvl7_rgoyM_closure" {
     lvl7_rgoyM_closure:
         const lvl7_rgoyM_info;
         const 0;
 },
 sat_sgoC7_entry() //  [R1]
         { info_tbl: [(cgoXu,
                       label: sat_sgoC7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoXu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoXv; else goto cgoXw;
       cgoXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rgoyM_entry() //  [R2, R3]
         { info_tbl: [(cgoXy,
                       label: lvl7_rgoyM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoXy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgoXC; else goto cgoXB;
       cgoXC: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rgoyM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoXB: // global
           I64[Hp - 48] = sat_sgoC7_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.332513744 UTC

[section ""data" . lvl8_rgoyN_closure" {
     lvl8_rgoyN_closure:
         const lvl8_rgoyN_info;
         const 0;
 },
 sat_sgoCb_entry() //  [R1]
         { info_tbl: [(cgoXL,
                       label: sat_sgoCb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoXL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoXM; else goto cgoXN;
       cgoXM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoXN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rgoyN_entry() //  [R2, R3, R4]
         { info_tbl: [(cgoXO,
                       label: lvl8_rgoyN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoXO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoXS; else goto cgoXR;
       cgoXS: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl8_rgoyN_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoXR: // global
           I64[Hp - 16] = sat_sgoCb_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sgoC8::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoC8::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.334204365 UTC

[section ""data" . Data.Fixed.$fDataFixed_closure" {
     Data.Fixed.$fDataFixed_closure:
         const Data.Fixed.$fDataFixed_info;
         const 0;
 },
 sat_sgoCf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgoY2,
                       label: sat_sgoCf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoY2: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgmapQi_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoCe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgoYa,
                       label: sat_sgoCe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYa: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgfoldl_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoCd_entry() //  [R1]
         { info_tbl: [(cgoYh,
                       label: sat_sgoCd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoYi; else goto cgoYj;
       cgoYi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoYj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fDataFixed7_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_entry() //  [R2]
         { info_tbl: [(cgoYl,
                       label: Data.Fixed.$fDataFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYl: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cgoYp; else goto cgoYo;
       cgoYp: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgoYo: // global
           I64[Hp - 176] = sat_sgoCf_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sgoCe_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sgoCd_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 144;
           P64[Hp - 104] = Hp - 157;
           P64[Hp - 96] = lvl8_rgoyN_closure+3;
           P64[Hp - 88] = lvl_rgoyF_closure+1;
           P64[Hp - 80] = lvl1_rgoyG_closure+1;
           P64[Hp - 72] = lvl2_rgoyH_closure+2;
           P64[Hp - 64] = lvl3_rgoyI_closure+2;
           P64[Hp - 56] = lvl4_rgoyJ_closure+2;
           P64[Hp - 48] = lvl5_rgoyK_closure+4;
           P64[Hp - 40] = lvl6_rgoyL_closure+4;
           P64[Hp - 32] = lvl7_rgoyM_closure+2;
           P64[Hp - 24] = Hp - 173;
           P64[Hp - 16] = Data.Fixed.$w$cgmapM_closure+3;
           P64[Hp - 8] = Data.Fixed.$w$cgmapMp_closure+3;
           P64[Hp] = Data.Fixed.$w$cgmapMo_closure+3;
           R1 = Hp - 119;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.335828978 UTC

[section ""cstring" . Data.Fixed.$tcHasResolution3_bytes" {
     Data.Fixed.$tcHasResolution3_bytes:
         I8[] [72,97,115,82,101,115,111,108,117,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.33640491 UTC

[section ""data" . Data.Fixed.$tcHasResolution2_closure" {
     Data.Fixed.$tcHasResolution2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcHasResolution3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.33695619 UTC

[section ""data" . Data.Fixed.$tcHasResolution_closure" {
     Data.Fixed.$tcHasResolution_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcHasResolution2_closure+1;
         const Data.Fixed.$tcHasResolution1_closure+4;
         const 7410670074803796200;
         const 11622449620609036983;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.337543315 UTC

[section ""cstring" . Data.Fixed.$tcE5_bytes" {
     Data.Fixed.$tcE5_bytes:
         I8[] [69,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.338128363 UTC

[section ""data" . Data.Fixed.$tcE4_closure" {
     Data.Fixed.$tcE4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.338676326 UTC

[section ""data" . Data.Fixed.$tcE0_closure" {
     Data.Fixed.$tcE0_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE4_closure+1;
         const GHC.Types.krep$*_closure;
         const 1111589946053822622;
         const 14645449775626969178;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.339278776 UTC

[section ""cstring" . Data.Fixed.$tcE8_bytes" {
     Data.Fixed.$tcE8_bytes:
         I8[] [69,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.339801944 UTC

[section ""data" . Data.Fixed.$tcE7_closure" {
     Data.Fixed.$tcE7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.340358478 UTC

[section ""data" . Data.Fixed.$tcE1_closure" {
     Data.Fixed.$tcE1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE7_closure+1;
         const GHC.Types.krep$*_closure;
         const 17242267792727872229;
         const 10571291330004494282;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.340959365 UTC

[section ""cstring" . Data.Fixed.$tcE14_bytes" {
     Data.Fixed.$tcE14_bytes:
         I8[] [69,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.341740913 UTC

[section ""data" . Data.Fixed.$tcE13_closure" {
     Data.Fixed.$tcE13_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE14_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.3423455 UTC

[section ""data" . Data.Fixed.$tcE2_closure" {
     Data.Fixed.$tcE2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE13_closure+1;
         const GHC.Types.krep$*_closure;
         const 18184774527647329547;
         const 15895109557895358229;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.342928416 UTC

[section ""cstring" . Data.Fixed.$tcE16_bytes" {
     Data.Fixed.$tcE16_bytes:
         I8[] [69,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.343464779 UTC

[section ""data" . Data.Fixed.$tcE15_closure" {
     Data.Fixed.$tcE15_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE16_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.344036604 UTC

[section ""data" . Data.Fixed.$tcE3_closure" {
     Data.Fixed.$tcE3_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE15_closure+1;
         const GHC.Types.krep$*_closure;
         const 2281297682271263739;
         const 13982938170987291273;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.344641477 UTC

[section ""cstring" . Data.Fixed.$tcE18_bytes" {
     Data.Fixed.$tcE18_bytes:
         I8[] [69,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.345272303 UTC

[section ""data" . Data.Fixed.$tcE17_closure" {
     Data.Fixed.$tcE17_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE18_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.345862762 UTC

[section ""data" . Data.Fixed.$tcE6_closure" {
     Data.Fixed.$tcE6_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE17_closure+1;
         const GHC.Types.krep$*_closure;
         const 6430880657524859014;
         const 16351944333195325805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.346451281 UTC

[section ""cstring" . Data.Fixed.$tcE20_bytes" {
     Data.Fixed.$tcE20_bytes:
         I8[] [69,57]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.347011662 UTC

[section ""data" . Data.Fixed.$tcE19_closure" {
     Data.Fixed.$tcE19_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE20_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.347561116 UTC

[section ""data" . Data.Fixed.$tcE9_closure" {
     Data.Fixed.$tcE9_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE19_closure+1;
         const GHC.Types.krep$*_closure;
         const 8202840314884717291;
         const 5390706447224283764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.348153145 UTC

[section ""cstring" . Data.Fixed.$tcE11_bytes" {
     Data.Fixed.$tcE11_bytes:
         I8[] [69,49,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.348748286 UTC

[section ""data" . Data.Fixed.$tcE10_closure" {
     Data.Fixed.$tcE10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.34936526 UTC

[section ""data" . Data.Fixed.$tcE12_closure" {
     Data.Fixed.$tcE12_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE10_closure+1;
         const GHC.Types.krep$*_closure;
         const 11177455628646877585;
         const 1804744900678580889;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.350545144 UTC

[section ""data" . Data.Fixed.div'_closure" {
     Data.Fixed.div'_closure:
         const Data.Fixed.div'_info;
         const 0;
 },
 Data.Fixed.div'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoYw,
                       label: Data.Fixed.div'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgoYE; else goto cgoYF;
       cgoYE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.div'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoYF: // global
           I64[Sp - 32] = block_cgoYu_info;
           _sgoCg::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _sgoCg::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgoYu() //  [R1]
         { info_tbl: [(cgoYu,
                       label: block_cgoYu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYu: // global
           I64[Sp] = block_cgoYz_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgoYz() //  [R1]
         { info_tbl: [(cgoYz,
                       label: block_cgoYz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYz: // global
           _sgoCm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgoYD_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sgoCm::P64;
           R2 = P64[Sp + 24];
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoYD() //  [R1, R2]
         { info_tbl: [(cgoYD,
                       label: block_cgoYD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYD: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.353232662 UTC

[section ""data" . Data.Fixed.$wdivMod'_closure" {
     Data.Fixed.$wdivMod'_closure:
         const Data.Fixed.$wdivMod'_info;
         const 0;
 },
 f_sgoCx_entry() //  [R1]
         { info_tbl: [(cgoYS,
                       label: f_sgoCx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoYT; else goto cgoYU;
       cgoYT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoYU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoCz_entry() //  [R1]
         { info_tbl: [(cgoZf,
                       label: sat_sgoCz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgoZg; else goto cgoZh;
       cgoZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCA_entry() //  [R1]
         { info_tbl: [(cgoZi,
                       label: sat_sgoCA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZi: // global
           _sgoCA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgoZj; else goto cgoZk;
       cgoZk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgoZm; else goto cgoZl;
       cgoZm: // global
           HpAlloc = 32;
           goto cgoZj;
       cgoZj: // global
           R1 = _sgoCA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoZl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCA::P64;
           _sgoCu::P64 = P64[_sgoCA::P64 + 16];
           _sgoCx::P64 = P64[_sgoCA::P64 + 24];
           _sgoCy::P64 = P64[_sgoCA::P64 + 32];
           I64[Hp - 24] = sat_sgoCz_info;
           P64[Hp - 8] = _sgoCu::P64;
           P64[Hp] = _sgoCx::P64;
           R2 = _sgoCy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCB_entry() //  [R1]
         { info_tbl: [(cgoZn,
                       label: sat_sgoCB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZn: // global
           _sgoCB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgoZo; else goto cgoZp;
       cgoZp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgoZr; else goto cgoZq;
       cgoZr: // global
           HpAlloc = 40;
           goto cgoZo;
       cgoZo: // global
           R1 = _sgoCB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoZq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCB::P64;
           _sgoCu::P64 = P64[_sgoCB::P64 + 16];
           _sgoCw::P64 = P64[_sgoCB::P64 + 24];
           _sgoCx::P64 = P64[_sgoCB::P64 + 32];
           _sgoCy::P64 = P64[_sgoCB::P64 + 40];
           I64[Hp - 32] = sat_sgoCA_info;
           P64[Hp - 16] = _sgoCu::P64;
           P64[Hp - 8] = _sgoCx::P64;
           P64[Hp] = _sgoCy::P64;
           R2 = _sgoCy::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgoCw::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoCC_entry() //  [R1]
         { info_tbl: [(cgoZs,
                       label: sat_sgoCC_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZs: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgoZt; else goto cgoZu;
       cgoZt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoZu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgoYZ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 48] = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 56;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgoYZ() //  [R1]
         { info_tbl: [(cgoYZ,
                       label: block_cgoYZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoYZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgoZx; else goto cgoZw;
       cgoZx: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgoZw: // global
           I64[Hp - 40] = sat_sgoCB_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           _sgoCv::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _sgoCv::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$wdivMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoZy,
                       label: Data.Fixed.$wdivMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZy: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgoZC; else goto cgoZB;
       cgoZC: // global
           HpAlloc = 104;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$wdivMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoZB: // global
           I64[Hp - 96] = f_sgoCx_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = sat_sgoCC_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _cgoYO::P64 = Hp - 96;
           P64[Hp] = _cgoYO::P64;
           R2 = Hp - 48;
           R1 = _cgoYO::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.356721276 UTC

[section ""data" . Data.Fixed.divMod'_closure" {
     Data.Fixed.divMod'_closure:
         const Data.Fixed.divMod'_info;
         const 0;
 },
 Data.Fixed.divMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgoZK,
                       label: Data.Fixed.divMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgoZL; else goto cgoZM;
       cgoZL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.divMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgoZM: // global
           I64[Sp - 8] = block_cgoZH_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$wdivMod'_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoZH() //  [R1, R2]
         { info_tbl: [(cgoZH,
                       label: block_cgoZH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoZP; else goto cgoZO;
       cgoZP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgoZO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.35875286 UTC

[section ""data" . Data.Fixed.mod'_closure" {
     Data.Fixed.mod'_closure:
         const Data.Fixed.mod'_info;
         const 0;
 },
 sat_sgoCO_entry() //  [R1]
         { info_tbl: [(cgp0a,
                       label: sat_sgoCO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp0b; else goto cgp0c;
       cgp0b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp0c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoCP_entry() //  [R1]
         { info_tbl: [(cgp0d,
                       label: sat_sgoCP_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0d: // global
           _sgoCP::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgp0e; else goto cgp0f;
       cgp0f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgp0h; else goto cgp0g;
       cgp0h: // global
           HpAlloc = 40;
           goto cgp0e;
       cgp0e: // global
           R1 = _sgoCP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp0g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCP::P64;
           _sgoCK::P64 = P64[_sgoCP::P64 + 16];
           _sgoCL::P64 = P64[_sgoCP::P64 + 24];
           _sgoCM::P64 = P64[_sgoCP::P64 + 32];
           _sgoCN::P64 = P64[_sgoCP::P64 + 40];
           I64[Hp - 32] = sat_sgoCO_info;
           P64[Hp - 16] = _sgoCK::P64;
           P64[Hp - 8] = _sgoCL::P64;
           P64[Hp] = _sgoCM::P64;
           R2 = _sgoCN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCQ_entry() //  [R1]
         { info_tbl: [(cgp0i,
                       label: sat_sgoCQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0i: // global
           _sgoCQ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgp0j; else goto cgp0k;
       cgp0k: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgp0m; else goto cgp0l;
       cgp0m: // global
           HpAlloc = 48;
           goto cgp0j;
       cgp0j: // global
           R1 = _sgoCQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp0l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCQ::P64;
           _sgoCK::P64 = P64[_sgoCQ::P64 + 16];
           _sgoCL::P64 = P64[_sgoCQ::P64 + 24];
           _sgoCM::P64 = P64[_sgoCQ::P64 + 32];
           _sgoCN::P64 = P64[_sgoCQ::P64 + 40];
           I64[Hp - 40] = sat_sgoCP_info;
           P64[Hp - 24] = _sgoCK::P64;
           P64[Hp - 16] = _sgoCL::P64;
           P64[Hp - 8] = _sgoCM::P64;
           P64[Hp] = _sgoCN::P64;
           R2 = _sgoCN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sgoCM::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.mod'_entry() //  [R2, R3, R4]
         { info_tbl: [(cgp0n,
                       label: Data.Fixed.mod'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0n: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgp0o; else goto cgp0p;
       cgp0o: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.mod'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp0p: // global
           I64[Sp - 32] = block_cgoZU_info;
           _sgoCK::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sgoCK::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgoZU() //  [R1]
         { info_tbl: [(cgoZU,
                       label: block_cgoZU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoZU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgp0s; else goto cgp0r;
       cgp0s: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgp0r: // global
           I64[Hp - 40] = sat_sgoCQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.361375898 UTC

[section ""data" . Data.Fixed.$fFractionalFixed2_closure" {
     Data.Fixed.$fFractionalFixed2_closure:
         const Data.Fixed.$fFractionalFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fFractionalFixed2_entry() //  [R1]
         { info_tbl: [(cgp0z,
                       label: Data.Fixed.$fFractionalFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp0A; else goto cgp0B;
       cgp0A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp0B: // global
           (_cgp0w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgp0w::I64 == 0) goto cgp0y; else goto cgp0x;
       cgp0y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgp0x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgp0w::I64;
           R2 = $dIP3_rgoyz_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.362738452 UTC

[section ""data" . Data.Fixed.$w$cfromRational_closure" {
     Data.Fixed.$w$cfromRational_closure:
         const Data.Fixed.$w$cfromRational_info;
         const 0;
 },
 Data.Fixed.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(cgp0I,
                       label: Data.Fixed.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgp0U; else goto cgp0V;
       cgp0U: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp0V: // global
           I64[Sp - 24] = block_cgp0G_info;
           _sgoCR::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoCR::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp0G() //  [R1]
         { info_tbl: [(cgp0G,
                       label: block_cgp0G_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0G: // global
           I64[Sp] = block_cgp0L_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp0L() //  [R1]
         { info_tbl: [(cgp0L,
                       label: block_cgp0L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0L: // global
           _sgoCS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp0P_info;
           R3 = P64[Sp + 16];
           R2 = _sgoCS::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp0P() //  [R1]
         { info_tbl: [(cgp0P,
                       label: block_cgp0P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0P: // global
           _sgoCW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp0T_info;
           R3 = _sgoCW::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp0T() //  [R1, R2]
         { info_tbl: [(cgp0T,
                       label: block_cgp0T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp0T: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.364566691 UTC

[section ""data" . Data.Fixed.$fFractionalFixed1_closure" {
     Data.Fixed.$fFractionalFixed1_closure:
         const Data.Fixed.$fFractionalFixed1_info;
         const 0;
 },
 Data.Fixed.$fFractionalFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgp18,
                       label: Data.Fixed.$fFractionalFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp18: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp19; else goto cgp1a;
       cgp19: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp1a: // global
           I64[Sp - 16] = block_cgp15_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugp1e; else goto cgp16;
       ugp1e: // global
           call _cgp15(R1) args: 0, res: 0, upd: 0;
       cgp16: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp15() //  [R1]
         { info_tbl: [(cgp15,
                       label: block_cgp15_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp15: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Fixed.$w$cfromRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.367784717 UTC

[section ""data" . Data.Fixed.$fRealFixed_$ctoRational_closure" {
     Data.Fixed.$fRealFixed_$ctoRational_closure:
         const Data.Fixed.$fRealFixed_$ctoRational_info;
         const 0;
 },
 Data.Fixed.$fRealFixed_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(cgp1l,
                       label: Data.Fixed.$fRealFixed_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp1r; else goto cgp1s;
       cgp1r: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp1s: // global
           I64[Sp - 16] = block_cgp1j_info;
           _sgoD5::P64 = R2;
           R2 = R3;
           R1 = _sgoD5::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp1j() //  [R1]
         { info_tbl: [(cgp1j,
                       label: block_cgp1j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1j: // global
           _sgoD6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp1o_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgoD6::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp1o() //  [R1, R2]
         { info_tbl: [(cgp1o,
                       label: block_cgp1o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgp1w; else goto cgp1v;
       cgp1w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgp1v: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.369445189 UTC

[section ""data" . Data.Fixed.$fFractionalFixed3_closure" {
     Data.Fixed.$fFractionalFixed3_closure:
         const Data.Fixed.$fFractionalFixed3_info;
         const 0;
 },
 section ""relreadonly" . ugp1Z_srtd" {
     ugp1Z_srtd:
         const SgoHz_srt+40;
         const 72;
         const 4611686018427387905;
         const 224;
 },
 Data.Fixed.$fFractionalFixed3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgp1G,
                       label: Data.Fixed.$fFractionalFixed3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgp1H; else goto cgp1I;
       cgp1H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp1I: // global
           I64[Sp - 32] = block_cgp1B_info;
           _sgoDc::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoDb::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgoDb::P64;
           P64[Sp - 16] = _sgoDc::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp1B() //  [R1]
         { info_tbl: [(cgp1B,
                       label: block_cgp1B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1B: // global
           if (R1 == 1) goto cgp1F; else goto cgp1E;
       cgp1F: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgp1E: // global
           _sgoDb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp1L_info;
           R2 = P64[Sp + 16];
           R1 = _sgoDb::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp1L() //  [R1]
         { info_tbl: [(cgp1L,
                       label: block_cgp1L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1L: // global
           _sgoDc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp1P_info;
           R3 = R1;
           R2 = _sgoDc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp1P() //  [R1]
         { info_tbl: [(cgp1P,
                       label: block_cgp1P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp1P: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.371250946 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_$crecip_closure" {
     Data.Fixed.$fFractionalFixed_$crecip_closure:
         const Data.Fixed.$fFractionalFixed_$crecip_info;
         const 0;
 },
 section ""relreadonly" . ugp2s_srtd" {
     ugp2s_srtd:
         const SgoHz_srt+40;
         const 73;
         const 4611686018427387905;
         const 352;
 },
 Data.Fixed.$fFractionalFixed_$crecip_entry() //  [R2, R3]
         { info_tbl: [(cgp29,
                       label: Data.Fixed.$fFractionalFixed_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp29: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgp2a; else goto cgp2b;
       cgp2a: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp2b: // global
           I64[Sp - 24] = block_cgp24_info;
           _sgoDi::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoDh::P64 = R2;
           R2 = _sgoDi::P64;
           P64[Sp - 16] = _sgoDh::P64;
           P64[Sp - 8] = _sgoDi::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp24() //  [R1]
         { info_tbl: [(cgp24,
                       label: block_cgp24_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp24: // global
           if (R1 == 1) goto cgp28; else goto cgp27;
       cgp28: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgp27: // global
           _sgoDh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp2e_info;
           R2 = P64[Sp + 16];
           R1 = _sgoDh::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp2e() //  [R1]
         { info_tbl: [(cgp2e,
                       label: block_cgp2e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp2e: // global
           I64[Sp] = block_cgp2i_info;
           R3 = R1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp2i() //  [R1]
         { info_tbl: [(cgp2i,
                       label: block_cgp2i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp2i: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.373008595 UTC

[section ""data" . Data.Fixed.$fNumFixed_$c*_closure" {
     Data.Fixed.$fNumFixed_$c*_closure:
         const Data.Fixed.$fNumFixed_$c*_info;
         const 0;
 },
 section ""relreadonly" . ugp2V_srtd" {
     ugp2V_srtd:
         const SgoHz_srt+40;
         const 74;
         const 4611686018427387905;
         const 608;
 },
 Data.Fixed.$fNumFixed_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(cgp2z,
                       label: Data.Fixed.$fNumFixed_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp2z: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgp2A; else goto cgp2B;
       cgp2A: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp2B: // global
           I64[Sp - 24] = block_cgp2x_info;
           _sgoDm::P64 = R2;
           R2 = R3;
           R1 = _sgoDm::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugp2W_srtd" {
     ugp2W_srtd:
         const SgoHz_srt+40;
         const 71;
         const 4611686018427387905;
         const 96;
 },
 _cgp2x() //  [R1]
         { info_tbl: [(cgp2x,
                       label: block_cgp2x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp2x: // global
           I64[Sp - 8] = block_cgp2E_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp2E() //  [R1]
         { info_tbl: [(cgp2E,
                       label: block_cgp2E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp2E: // global
           if (R1 == 1) goto cgp2U; else goto cgp2M;
       cgp2U: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgp2M: // global
           I64[Sp] = block_cgp2J_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp2J() //  [R1]
         { info_tbl: [(cgp2J,
                       label: block_cgp2J_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp2J: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.374712316 UTC

[section ""data" . Data.Fixed.$fNumFixed1_closure" {
     Data.Fixed.$fNumFixed1_closure:
         const Data.Fixed.$fNumFixed1_info;
         const 0;
 },
 Data.Fixed.$fNumFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgp33,
                       label: Data.Fixed.$fNumFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp33: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp34; else goto cgp35;
       cgp34: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp35: // global
           I64[Sp - 16] = block_cgp31_info;
           _sgoDs::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoDs::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp31() //  [R1]
         { info_tbl: [(cgp31,
                       label: block_cgp31_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp31: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.375900942 UTC

[section ""data" . Data.Fixed.$fNumFixed2_closure" {
     Data.Fixed.$fNumFixed2_closure:
         const Data.Fixed.$fNumFixed2_info;
         const 0;
 },
 Data.Fixed.$fNumFixed2_entry() //  [R2, R3]
         { info_tbl: [(cgp3f,
                       label: Data.Fixed.$fNumFixed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp3j; else goto cgp3k;
       cgp3j: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgp3k: // global
           I64[Sp - 16] = block_cgp3d_info;
           _sgoDv::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoDv::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp3d() //  [R1]
         { info_tbl: [(cgp3d,
                       label: block_cgp3d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3d: // global
           I64[Sp] = block_cgp3i_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgp3i() //  [R1]
         { info_tbl: [(cgp3i,
                       label: block_cgp3i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3i: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.377549742 UTC

[section ""data" . Data.Fixed.$fNumFixed_closure" {
     Data.Fixed.$fNumFixed_closure:
         const Data.Fixed.$fNumFixed_info;
         const 0;
 },
 sat_sgoDC_entry() //  [R1, R2]
         { info_tbl: [(cgp3z,
                       label: sat_sgoDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3z: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDB_entry() //  [R1, R2]
         { info_tbl: [(cgp3H,
                       label: sat_sgoDB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3H: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgp3P,
                       label: sat_sgoDA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3P: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fNumFixed_$c*_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugp3Y_srtd" {
     ugp3Y_srtd:
         const SgoHz_srt+16;
         const 80;
         const 3;
         const 61440;
 },
 Data.Fixed.$fNumFixed_entry() //  [R2]
         { info_tbl: [(cgp3T,
                       label: Data.Fixed.$fNumFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3T: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgp3X; else goto cgp3W;
       cgp3X: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp3W: // global
           I64[Hp - 104] = sat_sgoDC_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgoDB_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgoDA_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = GHC.Integer.Type.plusInteger_closure+2;
           P64[Hp - 40] = GHC.Integer.Type.minusInteger_closure+2;
           P64[Hp - 32] = Hp - 70;
           P64[Hp - 24] = GHC.Integer.Type.negateInteger_closure+1;
           P64[Hp - 16] = GHC.Integer.Type.absInteger_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.379641002 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_closure" {
     Data.Fixed.$fFractionalFixed_closure:
         const Data.Fixed.$fFractionalFixed_info;
         const 0;
 },
 sat_sgoDH_entry() //  [R1, R2]
         { info_tbl: [(cgp48,
                       label: sat_sgoDH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp48: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDG_entry() //  [R1, R2]
         { info_tbl: [(cgp4g,
                       label: sat_sgoDG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp4g: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed_$crecip_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDF_entry() //  [R1, R2, R3]
         { info_tbl: [(cgp4o,
                       label: sat_sgoDF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp4o: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDE_entry() //  [R1]
         { info_tbl: [(cgp4v,
                       label: sat_sgoDE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp4v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp4w; else goto cgp4x;
       cgp4w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp4x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fFractionalFixed_entry() //  [R2]
         { info_tbl: [(cgp4z,
                       label: Data.Fixed.$fFractionalFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp4z: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgp4D; else goto cgp4C;
       cgp4D: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp4C: // global
           I64[Hp - 104] = sat_sgoDH_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgoDG_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgoDF_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoDE_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.381512732 UTC

[section ""data" . Data.Fixed.$fReadFixed2_closure" {
     Data.Fixed.$fReadFixed2_closure:
         const Data.Fixed.$fReadFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed2_entry() //  [R1]
         { info_tbl: [(cgp4N,
                       label: Data.Fixed.$fReadFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp4N: // global
           _rgoxK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgp4Q; else goto cgp4R;
       cgp4R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgp4T; else goto cgp4S;
       cgp4T: // global
           HpAlloc = 16;
           goto cgp4Q;
       cgp4Q: // global
           R1 = _rgoxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp4S: // global
           (_cgp4H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rgoxK::P64);
           if (_cgp4H::I64 == 0) goto cgp4J; else goto cgp4I;
       cgp4J: // global
           call (I64[I64[_rgoxK::P64]])() args: 8, res: 0, upd: 8;
       cgp4I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgp4H::I64;
           (_cgp4K::F64) = call MO_F64_Log(10.0 :: W64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _cgp4K::F64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.382554093 UTC

[section ""data" . lvl9_rgoyO_closure" {
     lvl9_rgoyO_closure:
         const GHC.Types.I#_con_info;
         const 172;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.383154913 UTC

[section ""data" . lvl10_rgoyP_closure" {
     lvl10_rgoyP_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.38373746 UTC

[section ""data" . lvl11_rgoyQ_closure" {
     lvl11_rgoyQ_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.38429087 UTC

[section ""data" . lvl12_rgoyR_closure" {
     lvl12_rgoyR_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const lvl9_rgoyO_closure+1;
         const lvl10_rgoyP_closure+1;
         const lvl9_rgoyO_closure+1;
         const lvl11_rgoyQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.384946608 UTC

[section ""data" . lvl13_rgoyS_closure" {
     lvl13_rgoyS_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const lvl12_rgoyR_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.385887081 UTC

[section ""data" . Data.Fixed.$fReadFixed3_closure" {
     Data.Fixed.$fReadFixed3_closure:
         const Data.Fixed.$fReadFixed3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed3_entry() //  [R1]
         { info_tbl: [(cgp50,
                       label: Data.Fixed.$fReadFixed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp51; else goto cgp52;
       cgp51: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp52: // global
           (_cgp4X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgp4X::I64 == 0) goto cgp4Z; else goto cgp4Y;
       cgp4Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgp4Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgp4X::I64;
           R2 = lvl13_rgoyS_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.389349781 UTC

[section ""data" . Data.Fixed.$fReadFixed1_closure" {
     Data.Fixed.$fReadFixed1_closure:
         const Data.Fixed.$fReadFixed1_info;
         const 0;
 },
 lvl17_sgoDK_entry() //  [R1]
         { info_tbl: [(cgp5b,
                       label: lvl17_sgoDK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp5c; else goto cgp5d;
       cgp5c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 e_sgoDL_entry() //  [R1]
         { info_tbl: [(cgp5k,
                       label: e_sgoDL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgp5w; else goto cgp5x;
       cgp5w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp5x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgp5i_info;
           R2 = Data.Fixed.$fReadFixed3_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgp5i() //  [R1]
         { info_tbl: [(cgp5i,
                       label: block_cgp5i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5i: // global
           I64[Sp] = block_cgp5n_info;
           R2 = R1;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgp5n() //  [D1]
         { info_tbl: [(cgp5n,
                       label: block_cgp5n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5n: // global
           _cgp5s::F64 = D1;
           (_cgp5r::F64) = call MO_F64_Log(_cgp5s::F64);
           I64[Sp - 8] = block_cgp5v_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgp5r::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugp6A; else goto cgp5A;
       ugp6A: // global
           call _cgp5v(R1) args: 0, res: 0, upd: 0;
       cgp5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgp5v() //  [R1]
         { info_tbl: [(cgp5v,
                       label: block_cgp5v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5v: // global
           _sgoDS::F64 = %MO_F_Neg_W64(%MO_F_Quot_W64(F64[Sp + 8],
                                                      F64[R1 + 7]));
           I64[Sp + 8] = block_cgp5L_info;
           D1 = _sgoDS::F64;
           Sp = Sp + 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 24;
     }
 },
 _cgp5L() //  [R1, R2]
         { info_tbl: [(cgp5L,
                       label: block_cgp5L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5L: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cgp5V; else goto cgp6z;
       cgp5V: // global
           I64[Sp] = block_cgp5T_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
       cgp6z: // global
           _sgoDY::I64 = -R2;
           if (%MO_S_Le_W64(_sgoDY::I64, 52)) goto cgp6g; else goto cgp6o;
       cgp6g: // global
           I64[Sp - 8] = block_cgp67_info;
           R2 = R1;
           I64[Sp] = _sgoDY::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
       cgp6o: // global
           I64[Sp] = block_cgp6n_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgp5T() //  [R1]
         { info_tbl: [(cgp5T,
                       label: block_cgp5T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp5T: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgp67() //  [R1]
         { info_tbl: [(cgp67,
                       label: block_cgp67_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp67: // global
           _sgoE1::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cgp6e_info;
           R2 = _sgoE1::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgp6e() //  [R1]
         { info_tbl: [(cgp6e,
                       label: block_cgp6e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp6e: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgp6n() //  [R1]
         { info_tbl: [(cgp6n,
                       label: block_cgp6n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp6n: // global
           if (R1 == 1) goto cgp6y; else goto cgp6u;
       cgp6y: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cgp6u: // global
           R1 = Data.Fixed.$fEnumFixed1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugp8u_srtd" {
     ugp8u_srtd:
         const SgoHz_srt+120;
         const 57;
         const 76561193665298433;
 },
 sat_sgoE7_entry() //  [R1]
         { info_tbl: [(cgp6L,
                       label: sat_sgoE7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp6L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgp6M; else goto cgp6N;
       cgp6M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp6N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgp6J_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugp8v_srtd" {
     ugp8v_srtd:
         const SgoHz_srt+120;
         const 53;
         const 4503599627370497;
 },
 _cgp6J() //  [R1]
         { info_tbl: [(cgp6J,
                       label: block_cgp6J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp6J: // global
           R3 = R1;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoE5_entry() //  [R1]
         { info_tbl: [(cgp6V,
                       label: sat_sgoE5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp6V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp6W; else goto cgp6X;
       cgp6W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp6X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugp8w_srtd" {
     ugp8w_srtd:
         const SgoHz_srt+120;
         const 75;
         const 76842668642009089;
         const 1028;
 },
 lvl18_sgoE4_entry() //  [R1]
         { info_tbl: [(cgp6Y,
                       label: lvl18_sgoE4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp6Y: // global
           _sgoE4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgp6Z; else goto cgp70;
       cgp70: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgp72; else goto cgp71;
       cgp72: // global
           HpAlloc = 48;
           goto cgp6Z;
       cgp6Z: // global
           R1 = _sgoE4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp71: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoE4::P64;
           _sgoDJ::P64 = P64[_sgoE4::P64 + 16];
           _sgoDL::P64 = P64[_sgoE4::P64 + 24];
           I64[Hp - 40] = sat_sgoE7_info;
           P64[Hp - 24] = _sgoDJ::P64;
           I64[Hp - 16] = sat_sgoE5_info;
           P64[Hp] = _sgoDJ::P64;
           R5 = _sgoDL::P64;
           R4 = Hp - 40;
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugp8x_srtd" {
     ugp8x_srtd:
         const SgoHz_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 x_sgoEh_entry() //  [R1]
         { info_tbl: [(cgp7u,
                       label: x_sgoEh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7u: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgp7C; else goto cgp7D;
       cgp7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp7D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgp7s_info;
           _sgoDK::P64 = P64[R1 + 24];
           R3 = _sgoDK::P64;
           R2 = P64[R1 + 48];
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = _sgoDK::P64;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 56;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugp8y_srtd" {
     ugp8y_srtd:
         const SgoHz_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 _cgp7s() //  [R1]
         { info_tbl: [(cgp7s,
                       label: block_cgp7s_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7s: // global
           _sgoDJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgp7x_info;
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = _sgoDJ::P64;
           Sp = Sp + 8;
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugp8z_srtd" {
     ugp8z_srtd:
         const SgoHz_srt+16;
         const 66;
         const 1;
         const 2;
 },
 _cgp7x() //  [R1]
         { info_tbl: [(cgp7x,
                       label: block_cgp7x_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7x: // global
           I64[Sp + 16] = block_cgp7B_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgp7B() //  [R1]
         { info_tbl: [(cgp7B,
                       label: block_cgp7B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7B: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEn_entry() //  [R1, R3]
         { info_tbl: [(cgp7P,
                       label: sat_sgoEn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7P: // global
           R2 = P64[R1 + 6];
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEo_entry() //  [R1, R2]
         { info_tbl: [(cgp7W,
                       label: sat_sgoEo_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgp7X; else goto cgp7Y;
       cgp7X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp7Y: // global
           I64[Sp - 40] = block_cgp78_info;
           _sgoDJ::P64 = P64[R1 + 7];
           _sgoDK::P64 = P64[R1 + 15];
           _sgoDL::P64 = P64[R1 + 23];
           _sgoE4::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoDJ::P64;
           P64[Sp - 24] = _sgoDK::P64;
           P64[Sp - 16] = _sgoDL::P64;
           P64[Sp - 8] = _sgoE4::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugp8h; else goto cgp79;
       ugp8h: // global
           call _cgp78(R1) args: 0, res: 0, upd: 0;
       cgp79: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp78() //  [R1]
         { info_tbl: [(cgp78,
                       label: block_cgp78_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp78: // global
           if (R1 & 7 == 6) goto cgp7U; else goto ugp8c;
       cgp7U: // global
           I64[Sp] = block_cgp7e_info;
           R3 = P64[R1 + 2];
           R2 = P64[Sp + 24];
           call Text.Read.Lex.numberToFixed_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ugp8c: // global
           Sp = Sp + 40;
           call _cgp85() args: 0, res: 0, upd: 0;
     }
 },
 _cgp7e() //  [R1]
         { info_tbl: [(cgp7e,
                       label: block_cgp7e_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7e: // global
           if (R1 & 7 == 1) goto ugp8d; else goto cgp87;
       ugp8d: // global
           Sp = Sp + 40;
           call _cgp85() args: 0, res: 0, upd: 0;
       cgp87: // global
           I64[Sp] = block_cgp7j_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ugp8f; else goto cgp7k;
       ugp8f: // global
           call _cgp7j(R1) args: 0, res: 0, upd: 0;
       cgp7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgp7j() //  [R1]
         { info_tbl: [(cgp7j,
                       label: block_cgp7j_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7j: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgp8a; else goto cgp89;
       cgp8a: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgp89: // global
           _sgoEf::P64 = P64[R1 + 7];
           _sgoEg::P64 = P64[R1 + 15];
           I64[Hp - 64] = x_sgoEh_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgoEf::P64;
           P64[Hp - 16] = _sgoEg::P64;
           I64[Hp - 8] = sat_sgoEn_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgp85() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp85: // global
           R1 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoE8_entry() //  [R1]
         { info_tbl: [(cgp8m,
                       label: sat_sgoE8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp8m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp8n; else goto cgp8o;
       cgp8n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp8o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugp8A_srtd" {
     ugp8A_srtd:
         const SgoHz_srt+120;
         const 79;
         const 2382685677855703041;
         const 32740;
 },
 Data.Fixed.$fReadFixed1_entry() //  [R2]
         { info_tbl: [(cgp8p,
                       label: Data.Fixed.$fReadFixed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp8p: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgp8t; else goto cgp8s;
       cgp8t: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp8s: // global
           I64[Hp - 136] = lvl17_sgoDK_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = e_sgoDL_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = lvl18_sgoE4_info;
           P64[Hp - 72] = R2;
           _cgp5e::P64 = Hp - 112;
           P64[Hp - 64] = _cgp5e::P64;
           I64[Hp - 56] = sat_sgoEo_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = _cgp5e::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoE8_info;
           P64[Hp] = R2;
           R3 = Hp - 55;
           R2 = Hp - 16;
           R1 = GHC.Read.readNumber1_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.397298866 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadsPrec_closure" {
     Data.Fixed.$fReadFixed_$creadsPrec_closure:
         const Data.Fixed.$fReadFixed_$creadsPrec_info;
         const 0;
 },
 ds_sgoEq_entry() //  [R1]
         { info_tbl: [(cgp8J,
                       label: ds_sgoEq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp8J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp8K; else goto cgp8L;
       cgp8K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp8L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEs_entry() //  [R1]
         { info_tbl: [(cgp8V,
                       label: sat_sgoEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp8V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp8W; else goto cgp8X;
       cgp8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp8X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEt_entry() //  [R1, R2]
         { info_tbl: [(cgp8Y,
                       label: sat_sgoEt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp8Y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgp92; else goto cgp91;
       cgp92: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp91: // global
           _sgoEq::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgoEs_info;
           P64[Hp - 8] = _sgoEq::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cgp93,
                       label: Data.Fixed.$fReadFixed_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp93: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgp97; else goto cgp96;
       cgp97: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp96: // global
           I64[Hp - 32] = ds_sgoEq_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sgoEt_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.399173574 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadListPrec_closure" {
     Data.Fixed.$fReadFixed_$creadListPrec_closure:
         const Data.Fixed.$fReadFixed_$creadListPrec_info;
         const 0;
 },
 sat_sgoEv_entry() //  [R1]
         { info_tbl: [(cgp9g,
                       label: sat_sgoEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp9g: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cgp9j,
                       label: Data.Fixed.$fReadFixed_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp9j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgp9n; else goto cgp9m;
       cgp9n: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp9m: // global
           I64[Hp - 16] = sat_sgoEv_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.400538324 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadList_closure" {
     Data.Fixed.$fReadFixed_$creadList_closure:
         const Data.Fixed.$fReadFixed_$creadList_info;
         const 0;
 },
 sat_sgoEx_entry() //  [R1]
         { info_tbl: [(cgp9A,
                       label: sat_sgoEx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp9A: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEy_entry() //  [R1]
         { info_tbl: [(cgp9D,
                       label: sat_sgoEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp9D: // global
           _sgoEy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgp9E; else goto cgp9F;
       cgp9F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgp9H; else goto cgp9G;
       cgp9H: // global
           HpAlloc = 24;
           goto cgp9E;
       cgp9E: // global
           R1 = _sgoEy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoEy::P64;
           _sgoEw::P64 = P64[_sgoEy::P64 + 16];
           I64[Hp - 16] = sat_sgoEx_info;
           P64[Hp] = _sgoEw::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_$creadList_entry() //  [R2]
         { info_tbl: [(cgp9I,
                       label: Data.Fixed.$fReadFixed_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp9I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgp9M; else goto cgp9L;
       cgp9M: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgp9L: // global
           I64[Hp - 16] = sat_sgoEy_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.40253064 UTC

[section ""data" . Data.Fixed.$fReadFixed_closure" {
     Data.Fixed.$fReadFixed_closure:
         const Data.Fixed.$fReadFixed_info;
         const 0;
 },
 sat_sgoED_entry() //  [R1]
         { info_tbl: [(cgp9V,
                       label: sat_sgoED_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp9V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp9W; else goto cgp9X;
       cgp9W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp9X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEC_entry() //  [R1]
         { info_tbl: [(cgpa2,
                       label: sat_sgoEC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpa2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpa3; else goto cgpa4;
       cgpa3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpa4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEB_entry() //  [R1]
         { info_tbl: [(cgpa9,
                       label: sat_sgoEB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpa9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpaa; else goto cgpab;
       cgpaa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpab: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEA_entry() //  [R1]
         { info_tbl: [(cgpag,
                       label: sat_sgoEA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpag: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpah; else goto cgpai;
       cgpah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_entry() //  [R2]
         { info_tbl: [(cgpak,
                       label: Data.Fixed.$fReadFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpak: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgpao; else goto cgpan;
       cgpao: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpan: // global
           I64[Hp - 128] = sat_sgoED_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgoEC_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgoEB_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoEA_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.404307513 UTC

[section ""data" . Data.Fixed.$fEqFixed_closure" {
     Data.Fixed.$fEqFixed_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.404936257 UTC

[section ""data" . Data.Fixed.$fOrdFixed_closure" {
     Data.Fixed.$fOrdFixed_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Fixed.$fEqFixed_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.406022783 UTC

[section ""data" . Data.Fixed.$fRealFixed_closure" {
     Data.Fixed.$fRealFixed_closure:
         const Data.Fixed.$fRealFixed_info;
         const 0;
 },
 sat_sgoEG_entry() //  [R1, R2]
         { info_tbl: [(cgpay,
                       label: sat_sgoEG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpay: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fRealFixed_$ctoRational_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEF_entry() //  [R1]
         { info_tbl: [(cgpaF,
                       label: sat_sgoEF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpaF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpaG; else goto cgpaH;
       cgpaG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpaH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fRealFixed_entry() //  [R2]
         { info_tbl: [(cgpaJ,
                       label: Data.Fixed.$fRealFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpaJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgpaN; else goto cgpaM;
       cgpaN: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpaM: // global
           I64[Hp - 64] = sat_sgoEG_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sgoEF_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Data.Fixed.$fOrdFixed_closure+1;
           P64[Hp] = Hp - 63;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.40803624 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$ctruncate_closure" {
     Data.Fixed.$fRealFracFixed_$ctruncate_closure:
         const Data.Fixed.$fRealFracFixed_$ctruncate_info;
         const 0;
 },
 sat_sgoEV_entry() //  [R1]
         { info_tbl: [(cgpb7,
                       label: sat_sgoEV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpb7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpb8; else goto cgpb9;
       cgpb8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpb9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgpb2_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoEN::P64 = P64[R1 + 24];
           R2 = _sgoEN::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _sgoEN::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpb2() //  [R1]
         { info_tbl: [(cgpb2,
                       label: block_cgpb2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpb2: // global
           if (R1 == 1) goto cgpb6; else goto cgpb5;
       cgpb6: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgpb5: // global
           _sgoEN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgpbc_info;
           R3 = _sgoEN::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpbc() //  [R1]
         { info_tbl: [(cgpbc,
                       label: block_cgpbc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbc: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpbA_srtd" {
     ugpbA_srtd:
         const SgoHz_srt+464;
         const 43;
         const 4399120386049;
 },
 Data.Fixed.$fRealFracFixed_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpbj,
                       label: Data.Fixed.$fRealFracFixed_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpbp; else goto cgpbq;
       cgpbp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpbq: // global
           I64[Sp - 24] = block_cgpaS_info;
           _sgoEH::P64 = R2;
           R2 = R4;
           R1 = _sgoEH::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpaS() //  [R1]
         { info_tbl: [(cgpaS,
                       label: block_cgpaS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpaS: // global
           I64[Sp] = block_cgpaW_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpaW() //  [R1, R2]
         { info_tbl: [(cgpaW,
                       label: block_cgpaW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpaW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpbu; else goto cgpbt;
       cgpbu: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpbt: // global
           I64[Hp - 24] = sat_sgoEV_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           _sgoEI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpbk_info;
           R2 = _sgoEI::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpbk() //  [R1]
         { info_tbl: [(cgpbk,
                       label: block_cgpbk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbk: // global
           I64[Sp] = block_cgpbo_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpbo() //  [R1]
         { info_tbl: [(cgpbo,
                       label: block_cgpbo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbo: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.410824855 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cround_closure" {
     Data.Fixed.$fRealFracFixed_$cround_closure:
         const Data.Fixed.$fRealFracFixed_$cround_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpbH,
                       label: Data.Fixed.$fRealFracFixed_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpbL; else goto cgpbM;
       cgpbL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpbM: // global
           I64[Sp - 24] = block_cgpbF_info;
           _sgoEW::P64 = R2;
           R2 = R4;
           R1 = _sgoEW::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpbF() //  [R1]
         { info_tbl: [(cgpbF,
                       label: block_cgpbF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbF: // global
           I64[Sp] = block_cgpbK_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpbK() //  [R1, R2]
         { info_tbl: [(cgpbK,
                       label: block_cgpbK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbK: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.412400871 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cceiling_closure" {
     Data.Fixed.$fRealFracFixed_$cceiling_closure:
         const Data.Fixed.$fRealFracFixed_$cceiling_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpbW,
                       label: Data.Fixed.$fRealFracFixed_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpc0; else goto cgpc1;
       cgpc0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpc1: // global
           I64[Sp - 24] = block_cgpbU_info;
           _sgoF3::P64 = R2;
           R2 = R4;
           R1 = _sgoF3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpbU() //  [R1]
         { info_tbl: [(cgpbU,
                       label: block_cgpbU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbU: // global
           I64[Sp] = block_cgpbZ_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpbZ() //  [R1, R2]
         { info_tbl: [(cgpbZ,
                       label: block_cgpbZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpbZ: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.414009691 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cfloor_closure" {
     Data.Fixed.$fRealFracFixed_$cfloor_closure:
         const Data.Fixed.$fRealFracFixed_$cfloor_info;
         const 0;
 },
 section ""relreadonly" . ugpck_srtd" {
     ugpck_srtd:
         const SgoHz_srt+472;
         const 49;
         const 334251534843905;
 },
 Data.Fixed.$fRealFracFixed_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpcb,
                       label: Data.Fixed.$fRealFracFixed_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpcf; else goto cgpcg;
       cgpcf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpcg: // global
           I64[Sp - 24] = block_cgpc9_info;
           _sgoFa::P64 = R2;
           R2 = R4;
           R1 = _sgoFa::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpcl_srtd" {
     ugpcl_srtd:
         const SgoHz_srt+472;
         const 46;
         const 52776558133249;
 },
 _cgpc9() //  [R1]
         { info_tbl: [(cgpc9,
                       label: block_cgpc9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpc9: // global
           I64[Sp] = block_cgpce_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpce() //  [R1, R2]
         { info_tbl: [(cgpce,
                       label: block_cgpce_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpce: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.416040288 UTC

[section ""data" . Data.Fixed.$w$cproperFraction_closure" {
     Data.Fixed.$w$cproperFraction_closure:
         const Data.Fixed.$w$cproperFraction_info;
         const 0;
 },
 i_sgoFk_entry() //  [R1]
         { info_tbl: [(cgpcu,
                       label: i_sgoFk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpcv; else goto cgpcw;
       cgpcv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpcw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoFo_entry() //  [R1]
         { info_tbl: [(cgpcD,
                       label: sat_sgoFo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcD: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgpcL; else goto cgpcM;
       cgpcL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpcM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cgpcB_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           _sgoFi::P64 = P64[R1 + 24];
           _sgoFj::P64 = P64[R1 + 32];
           _sgoFk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _sgoFi::P64;
           P64[Sp - 32] = _sgoFj::P64;
           P64[Sp - 24] = _sgoFk::P64;
           Sp = Sp - 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpcB() //  [R1]
         { info_tbl: [(cgpcB,
                       label: block_cgpcB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcB: // global
           _sgoFi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpcG_info;
           R2 = _sgoFi::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgpcG() //  [R1]
         { info_tbl: [(cgpcG,
                       label: block_cgpcG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcG: // global
           I64[Sp] = block_cgpcK_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpcK() //  [R1]
         { info_tbl: [(cgpcK,
                       label: block_cgpcK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcK: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpcT,
                       label: Data.Fixed.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpcT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgpcX; else goto cgpcW;
       cgpcX: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpcW: // global
           I64[Hp - 80] = i_sgoFk_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgoFo_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           _cgpcq::P64 = Hp - 80;
           P64[Hp] = _cgpcq::P64;
           R2 = Hp - 40;
           R1 = _cgpcq::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.420045427 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cproperFraction_closure" {
     Data.Fixed.$fRealFracFixed_$cproperFraction_closure:
         const Data.Fixed.$fRealFracFixed_$cproperFraction_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cproperFraction_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cgpd5,
                       label: Data.Fixed.$fRealFracFixed_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpd5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgpd6; else goto cgpd7;
       cgpd6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpd7: // global
           I64[Sp - 8] = block_cgpd2_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$w$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpd2() //  [R1, R2]
         { info_tbl: [(cgpd2,
                       label: block_cgpd2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpd2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpda; else goto cgpd9;
       cgpda: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpd9: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.422152665 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_closure" {
     Data.Fixed.$fRealFracFixed_closure:
         const Data.Fixed.$fRealFracFixed_info;
         const 0;
 },
 sat_sgoFC_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpdk,
                       label: sat_sgoFC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpdk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cfloor_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFB_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpds,
                       label: sat_sgoFB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpds: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cceiling_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpdA,
                       label: sat_sgoFA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpdA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cround_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFz_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpdI,
                       label: sat_sgoFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpdI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFy_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpdQ,
                       label: sat_sgoFy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpdQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cproperFraction_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFx_entry() //  [R1]
         { info_tbl: [(cgpdX,
                       label: sat_sgoFx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpdX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpdY; else goto cgpdZ;
       cgpdY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpdZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fFractionalFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoFw_entry() //  [R1]
         { info_tbl: [(cgpe4,
                       label: sat_sgoFw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpe4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpe5; else goto cgpe6;
       cgpe5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpe6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugped_srtd" {
     ugped_srtd:
         const SgoHz_srt+656;
         const 33;
         const 6494224385;
 },
 Data.Fixed.$fRealFracFixed_entry() //  [R2]
         { info_tbl: [(cgpe8,
                       label: Data.Fixed.$fRealFracFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpe8: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cgpec; else goto cgpeb;
       cgpec: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpeb: // global
           I64[Hp - 184] = sat_sgoFC_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sgoFB_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgoFA_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgoFz_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgoFy_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgoFx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgoFw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.424832663 UTC

[section ""data" . chopZeros_rgnn4_closure" {
     chopZeros_rgnn4_closure:
         const chopZeros_rgnn4_info;
         const 0;
 },
 section ""relreadonly" . ugpeV_srtd" {
     ugpeV_srtd:
         const SgoHz_srt+120;
         const 103;
         const 576460752303423489;
         const 481036337664;
 },
 chopZeros_rgnn4_entry() //  [R2]
         { info_tbl: [(cgpen,
                       label: chopZeros_rgnn4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpen: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpeo; else goto ugpeR;
       cgpeo: // global
           R2 = R2;
           R1 = chopZeros_rgnn4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ugpeR: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cgpef() args: 0, res: 0, upd: 0;
     }
 },
 _cgpef() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpef: // global
           I64[Sp - 8] = block_cgpei_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpeW_srtd" {
     ugpeW_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpei() //  [R1]
         { info_tbl: [(cgpei,
                       label: block_cgpei_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpei: // global
           if (R1 == 1) goto cgpem; else goto cgpel;
       cgpem: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpel: // global
           I64[Sp] = block_cgpes_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpeX_srtd" {
     ugpeX_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpes() //  [R1]
         { info_tbl: [(cgpes,
                       label: block_cgpes_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpes: // global
           I64[Sp] = block_cgpex_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpeY_srtd" {
     ugpeY_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpex() //  [R1]
         { info_tbl: [(cgpex,
                       label: block_cgpex_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpex: // global
           _sgoFD::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgpeJ; else goto cgpeE;
       cgpeJ: // global
           I64[Sp + 8] = block_cgpeH_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = _sgoFD::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cgpeE: // global
           R2 = _sgoFD::P64;
           Sp = Sp + 16;
           call GHC.Show.$fShowInteger_$cshow_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpeZ_srtd" {
     ugpeZ_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpeH() //  [R1]
         { info_tbl: [(cgpeH,
                       label: block_cgpeH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpeH: // global
           P64[Sp] = R1;
           call _cgpef() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.426857207 UTC

[section ""data" . lvl14_rgoyT_closure" {
     lvl14_rgoyT_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.427424078 UTC

[section ""data" . lvl15_rgoyU_closure" {
     lvl15_rgoyU_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.427964667 UTC

[section ""cstring" . lvl16_rgoyV_bytes" {
     lvl16_rgoyV_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.432255899 UTC

[section ""data" . Data.Fixed.showFixed_closure" {
     Data.Fixed.showFixed_closure:
         const Data.Fixed.showFixed_info;
         const 0;
 },
 n1_sgoGj_entry() //  [R1]
         { info_tbl: [(cgpgr,
                       label: n1_sgoGj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpgr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpgs; else goto cgpgt;
       cgpgs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpgt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgpgk_info;
           _sgoG5::P64 = P64[R1 + 24];
           _sgoGb::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sgoG5::P64;
           P64[Sp - 24] = _sgoGb::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugpgA; else goto cgpgl;
       ugpgA: // global
           call _cgpgk(R1) args: 0, res: 0, upd: 0;
       cgpgl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpgk() //  [R1]
         { info_tbl: [(cgpgk,
                       label: block_cgpgk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpgk: // global
           if (R1 & 7 == 1) goto cgpgo; else goto cgpgp;
       cgpgo: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cgpgp: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call chopZeros_rgnn4_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoGq_entry() //  [R1]
         { info_tbl: [(cgpgP,
                       label: sat_sgoGq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpgP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpgQ; else goto cgpgR;
       cgpgQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpgR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sgoGm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sgoGm_entry() //  [R1, R2]
         { info_tbl: [(cgpgV,
                       label: $wxs_sgoGm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpgV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpgZ; else goto cgpgY;
       cgpgZ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpgY: // global
           if (R2 == 1) goto cgpgU; else goto cgpgT;
       cgpgU: // global
           _sgoGl::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sgoGl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpgT: // global
           I64[Hp - 48] = sat_sgoGq_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rgoyT_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpki_srtd" {
     ugpki_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 sat_sgoGK_entry() //  [R1]
         { info_tbl: [(cgph1,
                       label: sat_sgoGK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgph1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgph2; else goto cgph3;
       cgph2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgph3: // global
           I64[Sp - 32] = block_cgpfo_info;
           _sgoFM::P64 = P64[R1 + 24];
           R2 = _sgoFM::P64;
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = _sgoFM::P64;
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 32;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkj_srtd" {
     ugpkj_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgpfo() //  [D1]
         { info_tbl: [(cgpfo,
                       label: block_cgpfo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpfo: // global
           _cgpft::F64 = D1;
           (_cgpfs::F64) = call MO_F64_Log(_cgpft::F64);
           I64[Sp - 8] = block_cgpfw_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgpfs::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpjx; else goto cgpfx;
       ugpjx: // global
           call _cgpfw(R1) args: 0, res: 0, upd: 0;
       cgpfx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkk_srtd" {
     ugpkk_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835136;
 },
 _cgpfw() //  [R1]
         { info_tbl: [(cgpfw,
                       label: block_cgpfw_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpfw: // global
           _sgoFQ::P64 = P64[Sp + 32];
           _sgoFZ::F64 = %MO_F_Quot_W64(F64[Sp + 8], F64[R1 + 7]);
           _sgoG0::I64 = %MO_FS_Conv_W64_W64(_sgoFZ::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_sgoG0::I64),
                            _sgoFZ::F64)) goto cgpji; else goto cgpjh;
       cgpji: // global
           _sgoG2::I64 = _sgoG0::I64 + 1;
           goto sgoG1;
       cgpjh: // global
           _sgoG2::I64 = _sgoG0::I64;
           goto sgoG1;
       sgoG1: // global
           if (%MO_S_Ge_W64(_sgoG2::I64, 0)) goto cgpjc; else goto cgpjd;
       cgpjc: // global
           if (_sgoG2::I64 == 0) goto cgpj3; else goto cgpiG;
       cgpj3: // global
           I64[Sp + 8] = block_cgpiQ_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgoFQ::P64;
           I64[Sp + 32] = _sgoG2::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cgpiG: // global
           I64[Sp] = block_cgpio_info;
           R3 = _sgoG2::I64;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           I64[Sp + 8] = _sgoG2::I64;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 8, upd: 8;
       cgpjd: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpkl_srtd" {
     ugpkl_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgpiQ() //  [R1]
         { info_tbl: [(cgpiQ,
                       label: block_cgpiQ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpiQ: // global
           I64[Sp] = block_cgpiU_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkm_srtd" {
     ugpkm_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgpiU() //  [R1]
         { info_tbl: [(cgpiU,
                       label: block_cgpiU_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpiU: // global
           I64[Sp] = block_cgpiY_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkn_srtd" {
     ugpkn_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgpiY() //  [R1]
         { info_tbl: [(cgpiY,
                       label: block_cgpiY_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpiY: // global
           I64[Sp] = block_cgpj2_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpj2() //  [R1]
         { info_tbl: [(cgpj2,
                       label: block_cgpj2_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpj2: // global
           I64[Sp] = I64[Sp + 24];
           P64[Sp + 24] = R1;
           call _sgoG4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ugpko_srtd" {
     ugpko_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26594437586945;
 },
 _cgpio() //  [R1]
         { info_tbl: [(cgpio,
                       label: block_cgpio_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpio: // global
           I64[Sp] = block_cgpis_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkp_srtd" {
     ugpkp_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgpis() //  [R1]
         { info_tbl: [(cgpis,
                       label: block_cgpis_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpis: // global
           I64[Sp] = block_cgpiw_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkq_srtd" {
     ugpkq_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgpiw() //  [R1]
         { info_tbl: [(cgpiw,
                       label: block_cgpiw_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpiw: // global
           I64[Sp] = block_cgpiA_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkr_srtd" {
     ugpkr_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgpiA() //  [R1]
         { info_tbl: [(cgpiA,
                       label: block_cgpiA_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpiA: // global
           I64[Sp] = block_cgpiE_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpiE() //  [R1]
         { info_tbl: [(cgpiE,
                       label: block_cgpiE_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpiE: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _sgoG4() args: 0, res: 0, upd: 0;
     }
 },
 _sgoG4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgoG4: // global
           I64[Sp - 8] = block_cgph7_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpjG; else goto cgpi0;
       ugpjG: // global
           call _cgph7(R1) args: 0, res: 0, upd: 0;
       cgpi0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgph7() //  [R1]
         { info_tbl: [(cgph7,
                       label: block_cgph7_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgph7: // global
           if (R1 & 7 == 1) goto ugpjs; else goto cgpib;
       ugpjs: // global
           Sp = Sp + 8;
           call _sgoG6() args: 0, res: 0, upd: 0;
       cgpib: // global
           I64[Sp] = block_cgpi9_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpi9() //  [R1]
         { info_tbl: [(cgpi9,
                       label: block_cgpi9_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpi9: // global
           if (R1 == 1) goto ugpjt; else goto ugpju;
       ugpjt: // global
           Sp = Sp + 40;
           call _cgpil() args: 0, res: 0, upd: 0;
       ugpju: // global
           Sp = Sp + 8;
           call _sgoG6() args: 0, res: 0, upd: 0;
     }
 },
 _sgoG6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgoG6: // global
           I64[Sp - 8] = block_cgpg2_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[Sp + 24];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpg2() //  [R1, R2]
         { info_tbl: [(cgpg2,
                       label: block_cgpg2_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpg2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgphc; else goto cgphb;
       cgphc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgphb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           I64[Sp] = block_cgpg5_info;
           R3 = 0;
           _cgpg4::P64 = Hp - 14;
           R2 = _cgpg4::P64;
           P64[Sp + 24] = _cgpg4::P64;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpg5() //  [R1]
         { info_tbl: [(cgpg5,
                       label: block_cgpg5_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpg5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgphf; else goto cgphe;
       cgphf: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgphe: // global
           _sgoFJ::P64 = P64[Sp + 16];
           _sgoGd::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sgoGd::I64)) goto cgphi; else goto cgphM;
       cgphi: // global
           Hp = Hp - 80;
           I64[Sp + 16] = block_cgphg_info;
           R1 = _sgoFJ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ugpjy; else goto cgphj;
       ugpjy: // global
           call _cgphg(R1) args: 0, res: 0, upd: 0;
       cgphj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cgphM: // global
           I64[Hp - 72] = n1_sgoGj_info;
           P64[Hp - 56] = _sgoFJ::P64;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = lvl14_rgoyT_closure+1;
           P64[Hp - 16] = Hp - 72;
           I64[Hp - 8] = $wxs_sgoGm_info;
           P64[Hp] = Hp - 30;
           I64[Sp + 32] = block_cgphL_info;
           R2 = _sgoGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call $wxs_sgoGm_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgphg() //  [R1]
         { info_tbl: [(cgphg,
                       label: block_cgphg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgphg: // global
           if (R1 & 7 == 1) goto cgphp; else goto cgphx;
       cgphp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgphs; else goto cgphr;
       cgphs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgphr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgphx: // global
           _sgoG5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgphv_info;
           R2 = _sgoG5::P64;
           Sp = Sp + 16;
           call chopZeros_rgnn4_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgphv() //  [R1]
         { info_tbl: [(cgphv,
                       label: block_cgphv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgphv: // global
           if (R1 & 7 == 1) goto ugpjv; else goto cgphH;
       ugpjv: // global
           Sp = Sp + 8;
           call _cgpil() args: 0, res: 0, upd: 0;
       cgphH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgphK; else goto cgphJ;
       cgphK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgphJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgphL() //  [R1]
         { info_tbl: [(cgphL,
                       label: block_cgphL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgphL: // global
           if (R1 & 7 == 1) goto ugpjw; else goto cgphW;
       ugpjw: // global
           Sp = Sp + 8;
           call _cgpil() args: 0, res: 0, upd: 0;
       cgphW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgphZ; else goto cgphY;
       cgphZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgphY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgpil() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpil: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoGN_entry() //  [R1]
         { info_tbl: [(cgpjP,
                       label: sat_sgoGN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpjP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpjQ; else goto cgpjR;
       cgpjQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpjR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgpjN_info;
           R2 = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpjN() //  [R1]
         { info_tbl: [(cgpjN,
                       label: block_cgpjN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpjN: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpks_srtd" {
     ugpks_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 Data.Fixed.showFixed_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpjY,
                       label: Data.Fixed.showFixed_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpjY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpjZ; else goto cgpk0;
       cgpjZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.showFixed_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpk0: // global
           I64[Sp - 32] = block_cgpf4_info;
           _sgoFJ::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoFI::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgoFI::P64;
           P64[Sp - 16] = _sgoFJ::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkt_srtd" {
     ugpkt_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 _cgpf4() //  [R1]
         { info_tbl: [(cgpf4,
                       label: block_cgpf4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpf4: // global
           _sgoFI::P64 = P64[Sp + 8];
           _sgoFK::P64 = P64[Sp + 24];
           if (R1 == 1) goto cgpjX; else goto cgpjW;
       cgpjX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgpkh; else goto cgpkg;
       cgpkh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpkg: // global
           I64[Hp - 32] = sat_sgoGN_info;
           P64[Hp - 16] = _sgoFI::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgoFK::P64;
           R3 = Hp - 32;
           R2 = lvl16_rgoyV_bytes;
           Sp = Sp + 32;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cgpjW: // global
           I64[Sp + 8] = block_cgpf8_info;
           R2 = _sgoFK::P64;
           R1 = _sgoFI::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpku_srtd" {
     ugpku_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgpf8() //  [R1]
         { info_tbl: [(cgpf8,
                       label: block_cgpf8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpf8: // global
           I64[Sp - 8] = block_cgpfc_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkv_srtd" {
     ugpkv_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgpfc() //  [R1]
         { info_tbl: [(cgpfc,
                       label: block_cgpfc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpfc: // global
           if (R1 == 1) goto cgpke; else goto cgpk6;
       cgpke: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpk6: // global
           I64[Sp] = block_cgpfg_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkw_srtd" {
     ugpkw_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgpfg() //  [R1, R2]
         { info_tbl: [(cgpfg,
                       label: block_cgpfg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpfg: // global
           I64[Sp] = block_cgpfi_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           _sgoFQ::P64 = R2;
           R2 = 0;
           P64[Sp + 24] = _sgoFQ::P64;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpkx_srtd" {
     ugpkx_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgpfi() //  [R1, R2]
         { info_tbl: [(cgpfi,
                       label: block_cgpfi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpfi: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgpka; else goto cgpk9;
       cgpka: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpk9: // global
           I64[Hp - 56] = sat_sgoGK_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 56;
           R2 = Hp - 14;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.441591451 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshow_closure" {
     Data.Fixed.$fShowFixed_$cshow_closure:
         const Data.Fixed.$fShowFixed_$cshow_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cgpkC,
                       label: Data.Fixed.$fShowFixed_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpkC: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.442595637 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowsPrec_closure" {
     Data.Fixed.$fShowFixed_$cshowsPrec_closure:
         const Data.Fixed.$fShowFixed_$cshowsPrec_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpkL,
                       label: Data.Fixed.$fShowFixed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpkL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpkM; else goto cgpkN;
       cgpkM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpkN: // global
           I64[Sp - 16] = block_cgpkJ_info;
           R4 = R4;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpkJ() //  [R1]
         { info_tbl: [(cgpkJ,
                       label: block_cgpkJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpkJ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.444003336 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowList_closure" {
     Data.Fixed.$fShowFixed_$cshowList_closure:
         const Data.Fixed.$fShowFixed_$cshowList_info;
         const 0;
 },
 sat_sgoH0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpl2,
                       label: sat_sgoH0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpl2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpl3; else goto cgpl4;
       cgpl3: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpl4: // global
           I64[Sp - 16] = block_cgpl0_info;
           R4 = R2;
           _sgoGY::P64 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sgoGY::P64;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpl0() //  [R1]
         { info_tbl: [(cgpl0,
                       label: block_cgpl0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpl0: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpl8,
                       label: Data.Fixed.$fShowFixed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpl8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgplc; else goto cgplb;
       cgplc: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgplb: // global
           I64[Hp - 8] = sat_sgoH0_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.445862077 UTC

[section ""data" . Data.Fixed.$fShowFixed_closure" {
     Data.Fixed.$fShowFixed_closure:
         const Data.Fixed.$fShowFixed_info;
         const 0;
 },
 sat_sgoH4_entry() //  [R1, R2, R3]
         { info_tbl: [(cgplm,
                       label: sat_sgoH4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgplm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fShowFixed_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoH3_entry() //  [R1, R2]
         { info_tbl: [(cgplu,
                       label: sat_sgoH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgplu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fShowFixed_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoH2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgplC,
                       label: sat_sgoH2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgplC: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fShowFixed_$cshowsPrec_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_entry() //  [R2]
         { info_tbl: [(cgplG,
                       label: Data.Fixed.$fShowFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgplG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgplK; else goto cgplJ;
       cgplK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgplJ: // global
           I64[Hp - 72] = sat_sgoH4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoH3_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgoH2_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.447298594 UTC

[section ""relreadonly" . SgoHz_srt" {
     SgoHz_srt:
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const sat_sgozk_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
         const Data.Fixed.$fEnumFixed3_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const Data.Fixed.$fHasResolutionE0_$cresolution_closure;
         const sat_sgozK_closure;
         const Data.Fixed.$fHasResolutionE4_closure;
         const Data.Fixed.$fHasResolutionE1_$cresolution_closure;
         const sat_sgozN_closure;
         const Data.Fixed.$fHasResolutionE7_closure;
         const Data.Fixed.$fHasResolutionE2_$cresolution_closure;
         const sat_sgozQ_closure;
         const Data.Fixed.$fHasResolutionE8_closure;
         const Data.Fixed.$fHasResolutionE3_$cresolution_closure;
         const sat_sgozT_closure;
         const Data.Fixed.$fHasResolutionE10_closure;
         const Data.Fixed.$fHasResolutionE6_$cresolution_closure;
         const sat_sgozW_closure;
         const Data.Fixed.$fHasResolutionE11_closure;
         const Data.Fixed.$fHasResolutionE9_$cresolution_closure;
         const sat_sgoA1_closure;
         const Data.Fixed.$fHasResolutionE5_closure;
         const Data.Fixed.$fHasResolutionE12_$cresolution_closure;
         const GHC.List.badHead_closure;
         const w2_rgoyl_closure;
         const go61_rgoym_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Fixed.$fDataFixed4_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Fixed.$fDataFixed8_closure;
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$w$cgmapMp_closure;
         const Data.Fixed.$w$cgmapM_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Fixed.$fDataFixed_$cgmapQi_closure;
         const Data.Fixed.$w$cgmapMo_closure;
         const Data.Fixed.conMkFixed_closure;
         const Data.Fixed.tyFixed_closure;
         const lvl5_rgoyK_closure;
         const lvl6_rgoyL_closure;
         const lvl7_rgoyM_closure;
         const lvl8_rgoyN_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const Data.Fixed.$fDataFixed7_closure;
         const Data.Fixed.$fDataFixed_closure;
         const lvl_rgoyF_closure;
         const lvl1_rgoyG_closure;
         const lvl4_rgoyJ_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.div'_closure;
         const Data.Fixed.$wdivMod'_closure;
         const Data.Fixed.divMod'_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Data.Fixed.mod'_closure;
         const GHC.Err.undefined_closure;
         const $dIP3_rgoyz_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Fixed.$w$cfromRational_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const Data.Fixed.$fFractionalFixed1_closure;
         const Data.Fixed.$fRealFixed_$ctoRational_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const Data.Fixed.$fFractionalFixed3_closure;
         const Data.Fixed.$fFractionalFixed_$crecip_closure;
         const Data.Fixed.$fNumFixed_$c*_closure;
         const Data.Fixed.$fNumFixed1_closure;
         const Data.Fixed.$fNumFixed2_closure;
         const Data.Fixed.$fNumFixed_closure;
         const Data.Fixed.$fFractionalFixed_closure;
         const lvl13_rgoyS_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const Data.Fixed.$fReadFixed2_closure;
         const Data.Fixed.$fReadFixed3_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const GHC.Real.^_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Text.Read.Lex.numberToFixed_closure;
         const GHC.Read.readNumber1_closure;
         const Data.Fixed.$fReadFixed1_closure;
         const Data.Fixed.$fReadFixed_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Fixed.$fReadFixed_$creadListPrec_closure;
         const Data.Fixed.$fReadFixed_$creadList_closure;
         const Data.Fixed.$fReadFixed_closure;
         const Data.Fixed.$fRealFixed_closure;
         const Data.Fixed.$fRealFracFixed_$ctruncate_closure;
         const GHC.Real.$w$s$cround_closure;
         const Data.Fixed.$fRealFracFixed_$cround_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cfloor_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$w$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Show.$fShowInteger_$cshow_closure;
         const chopZeros_rgnn4_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$wf_closure;
         const Data.Fixed.showFixed_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const Data.Fixed.$fShowFixed_$cshowsPrec_closure;
         const Data.Fixed.$fShowFixed_$cshowList_closure;
         const Data.Fixed.$fShowFixed_$cshow_closure;
         const Data.Fixed.$fShowFixed_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.448592744 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:18.44926123 UTC

[section ""data" . Data.Fixed.resolution_closure" {
     Data.Fixed.resolution_closure:
         const Data.Fixed.resolution_info;
 },
 Data.Fixed.resolution_entry() //  [R2]
         { info_tbl: [(cgplP,
                       label: Data.Fixed.resolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgplP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.450057656 UTC

[section ""data" . Data.Fixed.$fDataFixed2_closure" {
     Data.Fixed.$fDataFixed2_closure:
         const Data.Fixed.$fDataFixed2_info;
 },
 Data.Fixed.$fDataFixed2_entry() //  [R2]
         { info_tbl: [(cgplW,
                       label: Data.Fixed.$fDataFixed2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgplW: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.451094614 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgfoldl_closure" {
     Data.Fixed.$fDataFixed_$cgfoldl_closure:
         const Data.Fixed.$fDataFixed_$cgfoldl_info;
         const 0;
 },
 sat_sgoz3_entry() //  [R1]
         { info_tbl: [(cgpm7,
                       label: sat_sgoz3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpm8; else goto cgpm9;
       cgpm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpm9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_$cgfoldl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpma,
                       label: Data.Fixed.$fDataFixed_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpma: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpme; else goto cgpmd;
       cgpme: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgfoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpmd: // global
           I64[Hp - 16] = sat_sgoz3_info;
           P64[Hp] = R4;
           R4 = R5;
           _sgoz0::P64 = R3;
           R3 = Hp - 16;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoz0::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.452451842 UTC

[section ""data" . Data.Fixed.$fEnumFixed1_closure" {
     Data.Fixed.$fEnumFixed1_closure:
         const Data.Fixed.$fEnumFixed1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed1_entry() //  [R1]
         { info_tbl: [(cgpml,
                       label: Data.Fixed.$fEnumFixed1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpmm; else goto cgpmn;
       cgpmm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpmn: // global
           (_cgpmi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpmi::I64 == 0) goto cgpmk; else goto cgpmj;
       cgpmk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpmj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpmi::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.454862818 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_info;
         const 0;
 },
 sat_sgozd_entry() //  [R1]
         { info_tbl: [(cgpmP,
                       label: sat_sgozd_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpmP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpmQ; else goto cgpmR;
       cgpmQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpmR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgpmN_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpmN() //  [R1]
         { info_tbl: [(cgpmN,
                       label: block_cgpmN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpmN: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgoz9_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgoz9_entry() //  [R1, R2]
         { info_tbl: [(cgpmY,
                       label: go_sgoz9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpmY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpmZ; else goto cgpn0;
       cgpmZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpn0: // global
           I64[Sp - 32] = block_cgpmF_info;
           R3 = P64[R1 + 7];
           _sgoza::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgoza::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpmF() //  [R1]
         { info_tbl: [(cgpmF,
                       label: block_cgpmF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpmF: // global
           if (R1 == 1) goto cgpmX; else goto cgpmW;
       cgpmX: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpmW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgpn4; else goto cgpn3;
       cgpn4: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpn3: // global
           I64[Hp - 56] = sat_sgozd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgoza::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgoza::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgoza::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgozi_entry() //  [R1]
         { info_tbl: [(cgpnp,
                       label: sat_sgozi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpnp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpnq; else goto cgpnr;
       cgpnq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpnr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgpnn_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpnn() //  [R1]
         { info_tbl: [(cgpnn,
                       label: block_cgpnn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpnn: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgoze_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgoze_entry() //  [R1, R2]
         { info_tbl: [(cgpny,
                       label: go_sgoze_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpny: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpnz; else goto cgpnA;
       cgpnz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpnA: // global
           I64[Sp - 32] = block_cgpnf_info;
           R3 = P64[R1 + 7];
           _sgozf::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgozf::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpnf() //  [R1]
         { info_tbl: [(cgpnf,
                       label: block_cgpnf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpnf: // global
           if (R1 == 1) goto cgpnx; else goto cgpnw;
       cgpnx: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpnw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgpnE; else goto cgpnD;
       cgpnE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpnD: // global
           I64[Hp - 56] = sat_sgozi_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgozf::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgozf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgozf::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpnI,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpnI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpnJ; else goto cgpnK;
       cgpnJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpnK: // global
           I64[Sp - 24] = block_cgpms_info;
           _sgoz5::P64 = R3;
           R3 = R2;
           _sgoz4::P64 = R2;
           R2 = _sgoz5::P64;
           P64[Sp - 16] = _sgoz4::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpms() //  [R1]
         { info_tbl: [(cgpms,
                       label: block_cgpms_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpms: // global
           I64[Sp - 8] = block_cgpmw_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpmw() //  [R1]
         { info_tbl: [(cgpmw,
                       label: block_cgpmw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpmw: // global
           _sgoz4::P64 = P64[Sp + 16];
           _sgoz6::P64 = P64[Sp + 24];
           _sgoz7::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgpnR; else goto cgpnN;
       cgpnR: // global
           Hp = Hp + 24;
           _sgoz8::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgpnU; else goto cgpnT;
       cgpnT: // global
           I64[Hp - 16] = go_sgoze_info;
           P64[Hp - 8] = _sgoz6::P64;
           P64[Hp] = _sgoz7::P64;
           R2 = _sgoz4::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgoze_entry(R2, R1) args: 8, res: 0, upd: 8;
       cgpnN: // global
           Hp = Hp + 24;
           _sgoz8::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgpnU; else goto cgpnP;
       cgpnU: // global
           HpAlloc = 24;
           R1 = _sgoz8::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpnP: // global
           I64[Hp - 16] = go_sgoz9_info;
           P64[Hp - 8] = _sgoz6::P64;
           P64[Hp] = _sgoz7::P64;
           R2 = _sgoz4::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgoz9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.458512223 UTC

[section ""data" . sat_sgozj_closure" {
     sat_sgozj_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.459102767 UTC

[section ""data" . sat_sgozk_closure" {
     sat_sgozk_closure:
         const :_con_info;
         const sat_sgozj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.45989188 UTC

[section ""data" . Data.Fixed.$fEnumFixed2_closure" {
     Data.Fixed.$fEnumFixed2_closure:
         const Data.Fixed.$fEnumFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed2_entry() //  [R1]
         { info_tbl: [(cgpo1,
                       label: Data.Fixed.$fEnumFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpo1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpo2; else goto cgpo3;
       cgpo2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpo3: // global
           (_cgpnY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpnY::I64 == 0) goto cgpo0; else goto cgpnZ;
       cgpo0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpnZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpnY::I64;
           R3 = sat_sgozk_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.461549058 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromTo_info;
         const 0;
 },
 sat_sgozr_entry() //  [R1]
         { info_tbl: [(cgpon,
                       label: sat_sgozr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpon: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpoo; else goto cgpop;
       cgpoo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpop: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgpol_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpol() //  [R1]
         { info_tbl: [(cgpol,
                       label: block_cgpol_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpol: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgozn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgozn_entry() //  [R1, R2]
         { info_tbl: [(cgpow,
                       label: go_sgozn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpow: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpox; else goto cgpoy;
       cgpox: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpoy: // global
           I64[Sp - 24] = block_cgpod_info;
           R3 = P64[R1 + 7];
           _sgozo::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgozo::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpod() //  [R1]
         { info_tbl: [(cgpod,
                       label: block_cgpod_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpod: // global
           if (R1 == 1) goto cgpov; else goto cgpou;
       cgpov: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpou: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpoC; else goto cgpoB;
       cgpoC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpoB: // global
           I64[Hp - 48] = sat_sgozr_info;
           P64[Hp - 32] = P64[Sp + 8];
           _sgozo::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sgozo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgozo::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(cgpoG,
                       label: Data.Fixed.$fEnumFixed_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpoG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgpoK; else goto cgpoJ;
       cgpoK: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpoJ: // global
           I64[Hp - 8] = go_sgozn_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgozn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.46428731 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThen_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThen_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThen_info;
         const 0;
 },
 d_sgozu_entry() //  [R1]
         { info_tbl: [(cgpoT,
                       label: d_sgozu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpoT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpoU; else goto cgpoV;
       cgpoU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpoV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgozz_entry() //  [R1]
         { info_tbl: [(cgppc,
                       label: sat_sgozz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgppd; else goto cgppe;
       cgppd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgppe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgppa_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgppa() //  [R1]
         { info_tbl: [(cgppa,
                       label: block_cgppa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppa: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgozv_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgozv_entry() //  [R1, R2]
         { info_tbl: [(cgppi,
                       label: go_sgozv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgppk; else goto cgppl;
       cgppk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgppl: // global
           I64[Sp - 24] = block_cgpp1_info;
           _sgozv::P64 = R1;
           _sgozu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgozu::P64;
           P64[Sp - 8] = _sgozv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugppp; else goto cgpp2;
       ugppp: // global
           call _cgpp1(R1) args: 0, res: 0, upd: 0;
       cgpp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpp1() //  [R1]
         { info_tbl: [(cgpp1,
                       label: block_cgpp1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpp1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgppo; else goto cgppn;
       cgppo: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgppn: // global
           I64[Hp - 56] = sat_sgozz_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(cgppq,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgppu; else goto cgppt;
       cgppu: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgppt: // global
           I64[Hp - 40] = d_sgozu_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = go_sgozv_info;
           P64[Hp] = Hp - 40;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgozv_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.466924224 UTC

[section ""data" . Data.Fixed.$fEnumFixed3_closure" {
     Data.Fixed.$fEnumFixed3_closure:
         const Data.Fixed.$fEnumFixed3_info;
         const 0;
 },
 sat_sgozD_entry() //  [R1]
         { info_tbl: [(cgppK,
                       label: sat_sgozD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgppL; else goto cgppM;
       cgppL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgppM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgppI_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgppI() //  [R1]
         { info_tbl: [(cgppI,
                       label: block_cgppI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppI: // global
           R2 = R1;
           Sp = Sp + 8;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fEnumFixed3_entry() //  [R2]
         { info_tbl: [(cgppQ,
                       label: Data.Fixed.$fEnumFixed3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgppS; else goto cgppT;
       cgppS: // global
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgppT: // global
           I64[Sp - 8] = block_cgppz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugppX; else goto cgppA;
       ugppX: // global
           call _cgppz(R1) args: 0, res: 0, upd: 0;
       cgppA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgppz() //  [R1]
         { info_tbl: [(cgppz,
                       label: block_cgppz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgppz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgppW; else goto cgppV;
       cgppW: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgppV: // global
           I64[Hp - 40] = sat_sgozD_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.470675235 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFrom_closure" {
     Data.Fixed.$fEnumFixed_$cenumFrom_closure:
         const Data.Fixed.$fEnumFixed_$cenumFrom_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed_$cenumFrom_entry() //  [R2]
         { info_tbl: [(cgpq2,
                       label: Data.Fixed.$fEnumFixed_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpq2: // global
           R2 = R2;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.471491921 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cfromEnum_closure" {
     Data.Fixed.$fEnumFixed_$cfromEnum_closure:
         const Data.Fixed.$fEnumFixed_$cfromEnum_info;
 },
 Data.Fixed.$fEnumFixed_$cfromEnum_entry() //  [R2]
         { info_tbl: [(cgpq9,
                       label: Data.Fixed.$fEnumFixed_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpq9: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.47229045 UTC

[section ""data" . Data.Fixed.$fEnumFixed4_closure" {
     Data.Fixed.$fEnumFixed4_closure:
         const Data.Fixed.$fEnumFixed4_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed4_entry() //  [R2]
         { info_tbl: [(cgpqg,
                       label: Data.Fixed.$fEnumFixed4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqg: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.473080109 UTC

[section ""data" . Data.Fixed.$fEnumFixed5_closure" {
     Data.Fixed.$fEnumFixed5_closure:
         const Data.Fixed.$fEnumFixed5_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed5_entry() //  [R2]
         { info_tbl: [(cgpqn,
                       label: Data.Fixed.$fEnumFixed5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqn: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.473854782 UTC

[section ""data" . Data.Fixed.$fEnumFixed_closure" {
     Data.Fixed.$fEnumFixed_closure:
         const GHC.Enum.C:Enum_con_info;
         const Data.Fixed.$fEnumFixed5_closure+1;
         const Data.Fixed.$fEnumFixed4_closure+1;
         const GHC.Enum.$fEnumInteger_$ctoEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cfromEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFrom_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.474548118 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE0_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE0_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_$cresolution_entry() //  []
         { info_tbl: [(cgpqu,
                       label: Data.Fixed.$fHasResolutionE0_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqu: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.475328034 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_closure" {
     Data.Fixed.$fHasResolutionE0_closure:
         const Data.Fixed.$fHasResolutionE0_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_entry() //  [R2]
         { info_tbl: [(cgpqB,
                       label: Data.Fixed.$fHasResolutionE0_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqB: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE0_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.476045705 UTC

[section ""data" . sat_sgozJ_closure" {
     sat_sgozJ_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.47657629 UTC

[section ""data" . sat_sgozK_closure" {
     sat_sgozK_closure:
         const :_con_info;
         const sat_sgozJ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.477350363 UTC

[section ""data" . Data.Fixed.$fHasResolutionE4_closure" {
     Data.Fixed.$fHasResolutionE4_closure:
         const Data.Fixed.$fHasResolutionE4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE4_entry() //  [R1]
         { info_tbl: [(cgpqK,
                       label: Data.Fixed.$fHasResolutionE4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpqL; else goto cgpqM;
       cgpqL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpqM: // global
           (_cgpqH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpqH::I64 == 0) goto cgpqJ; else goto cgpqI;
       cgpqJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpqI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpqH::I64;
           R3 = sat_sgozK_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.478343233 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE1_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE1_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_$cresolution_entry() //  []
         { info_tbl: [(cgpqR,
                       label: Data.Fixed.$fHasResolutionE1_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqR: // global
           R1 = Data.Fixed.$fHasResolutionE4_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.47916369 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_closure" {
     Data.Fixed.$fHasResolutionE1_closure:
         const Data.Fixed.$fHasResolutionE1_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_entry() //  [R2]
         { info_tbl: [(cgpqY,
                       label: Data.Fixed.$fHasResolutionE1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpqY: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE1_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.479828691 UTC

[section ""data" . sat_sgozM_closure" {
     sat_sgozM_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.480403592 UTC

[section ""data" . sat_sgozN_closure" {
     sat_sgozN_closure:
         const :_con_info;
         const sat_sgozM_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.481141249 UTC

[section ""data" . Data.Fixed.$fHasResolutionE7_closure" {
     Data.Fixed.$fHasResolutionE7_closure:
         const Data.Fixed.$fHasResolutionE7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE7_entry() //  [R1]
         { info_tbl: [(cgpr7,
                       label: Data.Fixed.$fHasResolutionE7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpr7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpr8; else goto cgpr9;
       cgpr8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpr9: // global
           (_cgpr4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpr4::I64 == 0) goto cgpr6; else goto cgpr5;
       cgpr6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpr5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpr4::I64;
           R3 = sat_sgozN_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.482194368 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE2_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE2_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_$cresolution_entry() //  []
         { info_tbl: [(cgpre,
                       label: Data.Fixed.$fHasResolutionE2_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpre: // global
           R1 = Data.Fixed.$fHasResolutionE7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.482952023 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_closure" {
     Data.Fixed.$fHasResolutionE2_closure:
         const Data.Fixed.$fHasResolutionE2_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_entry() //  [R2]
         { info_tbl: [(cgprl,
                       label: Data.Fixed.$fHasResolutionE2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgprl: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE2_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.483675781 UTC

[section ""data" . sat_sgozP_closure" {
     sat_sgozP_closure:
         const GHC.Types.I#_con_info;
         const 1000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.484266399 UTC

[section ""data" . sat_sgozQ_closure" {
     sat_sgozQ_closure:
         const :_con_info;
         const sat_sgozP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.485013008 UTC

[section ""data" . Data.Fixed.$fHasResolutionE8_closure" {
     Data.Fixed.$fHasResolutionE8_closure:
         const Data.Fixed.$fHasResolutionE8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE8_entry() //  [R1]
         { info_tbl: [(cgpru,
                       label: Data.Fixed.$fHasResolutionE8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpru: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgprv; else goto cgprw;
       cgprv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgprw: // global
           (_cgprr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgprr::I64 == 0) goto cgprt; else goto cgprs;
       cgprt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgprs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgprr::I64;
           R3 = sat_sgozQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.486167593 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE3_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE3_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_$cresolution_entry() //  []
         { info_tbl: [(cgprB,
                       label: Data.Fixed.$fHasResolutionE3_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgprB: // global
           R1 = Data.Fixed.$fHasResolutionE8_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.486963468 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_closure" {
     Data.Fixed.$fHasResolutionE3_closure:
         const Data.Fixed.$fHasResolutionE3_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_entry() //  [R2]
         { info_tbl: [(cgprI,
                       label: Data.Fixed.$fHasResolutionE3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgprI: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE3_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.487663681 UTC

[section ""data" . sat_sgozS_closure" {
     sat_sgozS_closure:
         const GHC.Types.I#_con_info;
         const 1000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.488246129 UTC

[section ""data" . sat_sgozT_closure" {
     sat_sgozT_closure:
         const :_con_info;
         const sat_sgozS_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.488967966 UTC

[section ""data" . Data.Fixed.$fHasResolutionE10_closure" {
     Data.Fixed.$fHasResolutionE10_closure:
         const Data.Fixed.$fHasResolutionE10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE10_entry() //  [R1]
         { info_tbl: [(cgprR,
                       label: Data.Fixed.$fHasResolutionE10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgprR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgprS; else goto cgprT;
       cgprS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgprT: // global
           (_cgprO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgprO::I64 == 0) goto cgprQ; else goto cgprP;
       cgprQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgprP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgprO::I64;
           R3 = sat_sgozT_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.490014273 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE6_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE6_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_$cresolution_entry() //  []
         { info_tbl: [(cgprY,
                       label: Data.Fixed.$fHasResolutionE6_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgprY: // global
           R1 = Data.Fixed.$fHasResolutionE10_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.490812709 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_closure" {
     Data.Fixed.$fHasResolutionE6_closure:
         const Data.Fixed.$fHasResolutionE6_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_entry() //  [R2]
         { info_tbl: [(cgps5,
                       label: Data.Fixed.$fHasResolutionE6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgps5: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE6_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.491529096 UTC

[section ""data" . sat_sgozV_closure" {
     sat_sgozV_closure:
         const GHC.Types.I#_con_info;
         const 1000000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.492081285 UTC

[section ""data" . sat_sgozW_closure" {
     sat_sgozW_closure:
         const :_con_info;
         const sat_sgozV_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.49280805 UTC

[section ""data" . Data.Fixed.$fHasResolutionE11_closure" {
     Data.Fixed.$fHasResolutionE11_closure:
         const Data.Fixed.$fHasResolutionE11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE11_entry() //  [R1]
         { info_tbl: [(cgpse,
                       label: Data.Fixed.$fHasResolutionE11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpse: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpsf; else goto cgpsg;
       cgpsf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpsg: // global
           (_cgpsb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpsb::I64 == 0) goto cgpsd; else goto cgpsc;
       cgpsd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpsc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpsb::I64;
           R3 = sat_sgozW_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.493845501 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE9_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE9_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_$cresolution_entry() //  []
         { info_tbl: [(cgpsl,
                       label: Data.Fixed.$fHasResolutionE9_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpsl: // global
           R1 = Data.Fixed.$fHasResolutionE11_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.494652265 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_closure" {
     Data.Fixed.$fHasResolutionE9_closure:
         const Data.Fixed.$fHasResolutionE9_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_entry() //  [R2]
         { info_tbl: [(cgpss,
                       label: Data.Fixed.$fHasResolutionE9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpss: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE9_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.495379012 UTC

[section ""data" . sat_sgozZ_closure" {
     sat_sgozZ_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.495928139 UTC

[section ""data" . sat_sgoA0_closure" {
     sat_sgoA0_closure:
         const :_con_info;
         const sat_sgozZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.496516082 UTC

[section ""data" . sat_sgozY_closure" {
     sat_sgozY_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.497116515 UTC

[section ""data" . sat_sgoA1_closure" {
     sat_sgoA1_closure:
         const :_con_info;
         const sat_sgozY_closure+1;
         const sat_sgoA0_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.497856063 UTC

[section ""data" . Data.Fixed.$fHasResolutionE5_closure" {
     Data.Fixed.$fHasResolutionE5_closure:
         const Data.Fixed.$fHasResolutionE5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE5_entry() //  [R1]
         { info_tbl: [(cgpsB,
                       label: Data.Fixed.$fHasResolutionE5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpsB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpsC; else goto cgpsD;
       cgpsC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpsD: // global
           (_cgpsy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpsy::I64 == 0) goto cgpsA; else goto cgpsz;
       cgpsA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpsz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpsy::I64;
           R3 = sat_sgoA1_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.498899411 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE12_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE12_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_$cresolution_entry() //  []
         { info_tbl: [(cgpsI,
                       label: Data.Fixed.$fHasResolutionE12_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpsI: // global
           R1 = Data.Fixed.$fHasResolutionE5_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.49974249 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_closure" {
     Data.Fixed.$fHasResolutionE12_closure:
         const Data.Fixed.$fHasResolutionE12_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_entry() //  [R2]
         { info_tbl: [(cgpsP,
                       label: Data.Fixed.$fHasResolutionE12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpsP: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE12_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.500395892 UTC

[section ""cstring" . Data.Fixed.$fDataFixed6_bytes" {
     Data.Fixed.$fDataFixed6_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.501106904 UTC

[section ""data" . Data.Fixed.$fDataFixed5_closure" {
     Data.Fixed.$fDataFixed5_closure:
         const Data.Fixed.$fDataFixed5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed5_entry() //  [R1]
         { info_tbl: [(cgpsY,
                       label: Data.Fixed.$fDataFixed5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpsY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpsZ; else goto cgpt0;
       cgpsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpt0: // global
           (_cgpsV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpsV::I64 == 0) goto cgpsX; else goto cgpsW;
       cgpsX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpsW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpsV::I64;
           R2 = Data.Fixed.$fDataFixed6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.502145336 UTC

[section ""cstring" . w1_rgoyk_bytes" {
     w1_rgoyk_bytes:
         I8[] [77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.504071907 UTC

[section ""data" . w2_rgoyl_closure" {
     w2_rgoyl_closure:
         const w2_rgoyl_info;
         const 0;
         const 0;
         const 0;
 },
 w2_rgoyl_entry() //  [R1]
         { info_tbl: [(cgpt7,
                       label: w2_rgoyl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpt7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpt8; else goto cgpt9;
       cgpt8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpt9: // global
           (_cgpt4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpt4::I64 == 0) goto cgpt6; else goto cgpt5;
       cgpt6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpt5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpt4::I64;
           R2 = w1_rgoyk_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.505801088 UTC

[section ""data" . go61_rgoym_closure" {
     go61_rgoym_closure:
         const go61_rgoym_info;
         const 0;
 },
 go61_rgoym_entry() //  [R2, R3]
         { info_tbl: [(cgptl,
                       label: go61_rgoym_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgptl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgptm; else goto ugptZ;
       cgptm: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgoym_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugptZ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgptb() args: 0, res: 0, upd: 0;
     }
 },
 _cgptb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgptb: // global
           _sgoA3::P64 = P64[Sp];
           I64[Sp] = block_cgpte_info;
           R1 = _sgoA3::P64;
           if (R1 & 7 != 0) goto ugpu3; else goto cgptf;
       ugpu3: // global
           call _cgpte(R1) args: 0, res: 0, upd: 0;
       cgptf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpte() //  [R1]
         { info_tbl: [(cgpte,
                       label: block_cgpte_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpte: // global
           if (R1 & 7 == 1) goto ugpu0; else goto cgptj;
       ugpu0: // global
           Sp = Sp + 16;
           call _cgptB() args: 0, res: 0, upd: 0;
       cgptj: // global
           I64[Sp - 8] = block_cgptt_info;
           _sgoA6::P64 = P64[R1 + 6];
           _sgoA7::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgoA7::P64;
           P64[Sp + 8] = _sgoA6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpu4; else goto cgptv;
       ugpu4: // global
           call _cgptt(R1) args: 0, res: 0, upd: 0;
       cgptv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgptt() //  [R1]
         { info_tbl: [(cgptt,
                       label: block_cgptt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgptt: // global
           if (R1 & 7 == 1) goto ugpu1; else goto cgptG;
       ugpu1: // global
           Sp = Sp + 24;
           call _cgptB() args: 0, res: 0, upd: 0;
       cgptG: // global
           I64[Sp - 8] = block_cgptE_info;
           _sgoA9::P64 = P64[R1 + 6];
           _sgoAa::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgoAa::P64;
           P64[Sp + 16] = _sgoA9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpu7; else goto cgptH;
       ugpu7: // global
           call _cgptE(R1) args: 0, res: 0, upd: 0;
       cgptH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgptB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgptB: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgptE() //  [R1]
         { info_tbl: [(cgptE,
                       label: block_cgptE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgptE: // global
           I64[Sp] = block_cgptL_info;
           R3 = w2_rgoyl_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgptL() //  [R1]
         { info_tbl: [(cgptL,
                       label: block_cgptL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgptL: // global
           if (R1 & 7 == 1) goto cgptS; else goto cgptW;
       cgptS: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgptb() args: 0, res: 0, upd: 0;
       cgptW: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.507903605 UTC

[section ""data" . conMkFixed1_rgoyn_closure" {
     conMkFixed1_rgoyn_closure:
         const Data.Data.AlgConstr_con_info;
         const conMkFixed2_rgoyo_closure;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed4_closure" {
     Data.Fixed.$fDataFixed4_closure:
         const :_con_info;
         const Data.Fixed.conMkFixed_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed3_closure" {
     Data.Fixed.$fDataFixed3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Fixed.$fDataFixed4_closure+2;
         const 0;
 },
 section ""data" . Data.Fixed.tyFixed_closure" {
     Data.Fixed.tyFixed_closure:
         const Data.Data.DataType_con_info;
         const Data.Fixed.$fDataFixed5_closure;
         const Data.Fixed.$fDataFixed3_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.conMkFixed_closure" {
     Data.Fixed.conMkFixed_closure:
         const Data.Data.Constr_con_info;
         const conMkFixed1_rgoyn_closure+1;
         const w2_rgoyl_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Fixed.tyFixed_closure+1;
         const 0;
 },
 section ""data" . conMkFixed2_rgoyo_closure" {
     conMkFixed2_rgoyo_closure:
         const conMkFixed2_rgoyo_info;
         const 0;
         const 0;
         const 0;
 },
 conMkFixed2_rgoyo_entry() //  [R1]
         { info_tbl: [(cgpug,
                       label: conMkFixed2_rgoyo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpuh; else goto cgpui;
       cgpuh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpui: // global
           (_cgpud::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpud::I64 == 0) goto cgpuf; else goto cgpue;
       cgpuf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpue: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpud::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Fixed.$fDataFixed4_closure+2;
           Sp = Sp - 16;
           call go61_rgoym_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.509075409 UTC

[section ""cstring" . Data.Fixed.$trModule4_bytes" {
     Data.Fixed.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.509816302 UTC

[section ""data" . loc_rgoyp_closure" {
     loc_rgoyp_closure:
         const loc_rgoyp_info;
         const 0;
         const 0;
         const 0;
 },
 loc_rgoyp_entry() //  [R1]
         { info_tbl: [(cgpup,
                       label: loc_rgoyp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpup: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpuq; else goto cgpur;
       cgpuq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpur: // global
           (_cgpum::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpum::I64 == 0) goto cgpuo; else goto cgpun;
       cgpuo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpun: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpum::I64;
           R2 = Data.Fixed.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.510669053 UTC

[section ""cstring" . Data.Fixed.$trModule2_bytes" {
     Data.Fixed.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.511363356 UTC

[section ""data" . loc1_rgoyq_closure" {
     loc1_rgoyq_closure:
         const loc1_rgoyq_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rgoyq_entry() //  [R1]
         { info_tbl: [(cgpuy,
                       label: loc1_rgoyq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpuy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpuz; else goto cgpuA;
       cgpuz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpuA: // global
           (_cgpuv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpuv::I64 == 0) goto cgpux; else goto cgpuw;
       cgpux: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpuw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpuv::I64;
           R2 = Data.Fixed.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.512199685 UTC

[section ""cstring" . loc2_rgoyr_bytes" {
     loc2_rgoyr_bytes:
         I8[] [46,47,68,97,116,97,47,70,105,120,101,100,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.512888197 UTC

[section ""data" . loc3_rgoys_closure" {
     loc3_rgoys_closure:
         const loc3_rgoys_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rgoys_entry() //  [R1]
         { info_tbl: [(cgpuH,
                       label: loc3_rgoys_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpuH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpuI; else goto cgpuJ;
       cgpuI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpuJ: // global
           (_cgpuE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpuE::I64 == 0) goto cgpuG; else goto cgpuF;
       cgpuG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpuF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpuE::I64;
           R2 = loc2_rgoyr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.513827017 UTC

[section ""data" . loc4_rgoyt_closure" {
     loc4_rgoyt_closure:
         const GHC.Types.I#_con_info;
         const 83;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.514406639 UTC

[section ""data" . loc5_rgoyu_closure" {
     loc5_rgoyu_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.514973047 UTC

[section ""data" . loc6_rgoyv_closure" {
     loc6_rgoyv_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.515539099 UTC

[section ""cstring" . $dIP_rgoyw_bytes" {
     $dIP_rgoyw_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.516259004 UTC

[section ""data" . $dIP1_rgoyx_closure" {
     $dIP1_rgoyx_closure:
         const $dIP1_rgoyx_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rgoyx_entry() //  [R1]
         { info_tbl: [(cgpuQ,
                       label: $dIP1_rgoyx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpuQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpuR; else goto cgpuS;
       cgpuR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpuS: // global
           (_cgpuN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpuN::I64 == 0) goto cgpuP; else goto cgpuO;
       cgpuP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpuO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpuN::I64;
           R2 = $dIP_rgoyw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.517111405 UTC

[section ""data" . $dIP2_rgoyy_closure" {
     $dIP2_rgoyy_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const loc4_rgoyt_closure+1;
         const loc5_rgoyu_closure+1;
         const loc4_rgoyt_closure+1;
         const loc6_rgoyv_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.517739205 UTC

[section ""data" . $dIP3_rgoyz_closure" {
     $dIP3_rgoyz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const $dIP2_rgoyy_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.51835961 UTC

[section ""data" . Data.Fixed.$trModule3_closure" {
     Data.Fixed.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.518922356 UTC

[section ""data" . Data.Fixed.$trModule1_closure" {
     Data.Fixed.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.519476604 UTC

[section ""data" . Data.Fixed.$trModule_closure" {
     Data.Fixed.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Fixed.$trModule3_closure+1;
         const Data.Fixed.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.520034401 UTC

[section ""data" . $krep_rgoyA_closure" {
     $krep_rgoyA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.520630314 UTC

[section ""data" . $krep1_rgoyB_closure" {
     $krep1_rgoyB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.521199312 UTC

[section ""data" . Data.Fixed.$tcHasResolution1_closure" {
     Data.Fixed.$tcHasResolution1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rgoyB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.521762961 UTC

[section ""data" . $krep2_rgoyC_closure" {
     $krep2_rgoyC_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.522332033 UTC

[section ""cstring" . Data.Fixed.$fDataFixed10_bytes" {
     Data.Fixed.$fDataFixed10_bytes:
         I8[] [70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.522929589 UTC

[section ""data" . Data.Fixed.$fDataFixed9_closure" {
     Data.Fixed.$fDataFixed9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$fDataFixed10_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.523523428 UTC

[section ""data" . Data.Fixed.$tcFixed_closure" {
     Data.Fixed.$tcFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$fDataFixed9_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12850707307297787398;
         const 5875431371990069009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.524126138 UTC

[section ""data" . $krep3_rgoyD_closure" {
     $krep3_rgoyD_closure:
         const :_con_info;
         const $krep2_rgoyC_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.524688633 UTC

[section ""data" . $krep4_rgoyE_closure" {
     $krep4_rgoyE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Fixed.$tcFixed_closure+1;
         const $krep3_rgoyD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.52532807 UTC

[section ""data" . Data.Fixed.$tc'MkFixed1_closure" {
     Data.Fixed.$tc'MkFixed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgoyA_closure+1;
         const $krep4_rgoyE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.525898464 UTC

[section ""cstring" . Data.Fixed.$tc'MkFixed3_bytes" {
     Data.Fixed.$tc'MkFixed3_bytes:
         I8[] [39,77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.526432866 UTC

[section ""data" . Data.Fixed.$tc'MkFixed2_closure" {
     Data.Fixed.$tc'MkFixed2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tc'MkFixed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.526977899 UTC

[section ""data" . Data.Fixed.$tc'MkFixed_closure" {
     Data.Fixed.$tc'MkFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tc'MkFixed2_closure+1;
         const Data.Fixed.$tc'MkFixed1_closure+4;
         const 8992689233320522225;
         const 9587721628087041380;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.528132882 UTC

[section ""data" . Data.Fixed.$fDataFixed8_closure" {
     Data.Fixed.$fDataFixed8_closure:
         const Data.Fixed.$fDataFixed8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed8_entry() //  [R1]
         { info_tbl: [(cgpv4,
                       label: Data.Fixed.$fDataFixed8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpv4: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgpv5; else goto cgpv6;
       cgpv5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpv6: // global
           (_cgpuW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpuW::I64 == 0) goto cgpuY; else goto cgpuX;
       cgpuY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpuX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpuW::I64;
           I64[Sp - 24] = block_cgpuZ_info;
           R6 = 0;
           R5 = Data.Fixed.$fDataFixed9_closure+1;
           R4 = Data.Fixed.$trModule_closure+1;
           R3 = 5875431371990069009;
           R2 = 12850707307297787398;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgpuZ() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgpuZ,
                       label: block_cgpuZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpuZ: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgpv0() args: 0, res: 0, upd: 0;
     }
 },
 _cgpv0() //  []
         { info_tbl: [(cgpv0,
                       label: block_cgpv0_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpv0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgpv9; else goto cgpv8;
       cgpv9: // global
           HpAlloc = 48;
           I64[Sp] = block_cgpv0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cgpv8: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.530141514 UTC

[section ""data" . Data.Fixed.$fDataFixed7_closure" {
     Data.Fixed.$fDataFixed7_closure:
         const Data.Fixed.$fDataFixed7_info;
         const 0;
 },
 Data.Fixed.$fDataFixed7_entry() //  [R2]
         { info_tbl: [(cgpvg,
                       label: Data.Fixed.$fDataFixed7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpvg: // global
           R3 = R2;
           R2 = Data.Fixed.$fDataFixed8_closure;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.530876336 UTC

[section ""data" . Data.Fixed.$fDataFixed1_closure" {
     Data.Fixed.$fDataFixed1_closure:
         const (,)_con_info;
         const Data.Fixed.$fDataFixed2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.533638138 UTC

[section ""data" . Data.Fixed.$w$cgmapMp_closure" {
     Data.Fixed.$w$cgmapMp_closure:
         const Data.Fixed.$w$cgmapMp_info;
         const 0;
 },
 lvl17_sgoAs_entry() //  [R1]
         { info_tbl: [(cgpvr,
                       label: lvl17_sgoAs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpvr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpvs; else goto cgpvt;
       cgpvs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpvt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoAP_entry() //  [R1, R2]
         { info_tbl: [(cgpvG,
                       label: sat_sgoAP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpvG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpvH; else goto cgpvI;
       cgpvH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpvI: // global
           I64[Sp - 24] = block_cgpvD_info;
           _sgoAs::P64 = P64[R1 + 7];
           _sgoAt::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgoAs::P64;
           P64[Sp - 8] = _sgoAt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugpw0; else goto cgpvE;
       ugpw0: // global
           call _cgpvD(R1) args: 0, res: 0, upd: 0;
       cgpvE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpvD() //  [R1]
         { info_tbl: [(cgpvD,
                       label: block_cgpvD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpvD: // global
           I64[Sp - 8] = block_cgpvL_info;
           _sgoAM::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoAM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpvZ; else goto cgpvN;
       ugpvZ: // global
           call _cgpvL(R1) args: 0, res: 0, upd: 0;
       cgpvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpvL() //  [R1]
         { info_tbl: [(cgpvL,
                       label: block_cgpvL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpvL: // global
           if (R1 & 7 == 1) goto cgpvT; else goto cgpvX;
       cgpvT: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpvX: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgoAu_entry() //  [R1]
         { info_tbl: [(cgpw9,
                       label: lvl18_sgoAu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpw9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpwa; else goto cgpwb;
       cgpwa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpwb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoAH_entry() //  [R1]
         { info_tbl: [(cgpws,
                       label: sat_sgoAH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpws: // global
           _sgoAH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgpwt; else goto cgpwu;
       cgpwu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpww; else goto cgpwv;
       cgpww: // global
           HpAlloc = 56;
           goto cgpwt;
       cgpwt: // global
           R1 = _sgoAH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpwv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAH::P64;
           _sgoAr::P64 = P64[_sgoAH::P64 + 16];
           _sgoAt::P64 = P64[_sgoAH::P64 + 24];
           _sgoAy::P64 = P64[_sgoAH::P64 + 32];
           _sgoAz::P64 = P64[_sgoAH::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoAy::P64;
           P64[Hp - 24] = _sgoAr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sgoAz::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoAD_entry() //  [R1, R2]
         { info_tbl: [(cgpwI,
                       label: sat_sgoAD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpwI: // global
           _sgoAA::P64 = R2;
           _sgoAD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgpwJ; else goto cgpwK;
       cgpwK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpwM; else goto cgpwL;
       cgpwM: // global
           HpAlloc = 56;
           goto cgpwJ;
       cgpwJ: // global
           R2 = _sgoAA::P64;
           R1 = _sgoAD::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpwL: // global
           _sgoAt::P64 = P64[_sgoAD::P64 + 7];
           _sgoAy::P64 = P64[_sgoAD::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoAy::P64;
           P64[Hp - 24] = _sgoAA::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoAt::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoAE_entry() //  [R1]
         { info_tbl: [(cgpwN,
                       label: sat_sgoAE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpwN: // global
           _sgoAE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpwO; else goto cgpwP;
       cgpwP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpwR; else goto cgpwQ;
       cgpwR: // global
           HpAlloc = 24;
           goto cgpwO;
       cgpwO: // global
           R1 = _sgoAE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpwQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAE::P64;
           _sgoAt::P64 = P64[_sgoAE::P64 + 16];
           _sgoAu::P64 = P64[_sgoAE::P64 + 24];
           _sgoAy::P64 = P64[_sgoAE::P64 + 32];
           I64[Hp - 16] = sat_sgoAD_info;
           P64[Hp - 8] = _sgoAt::P64;
           P64[Hp] = _sgoAy::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgoAu::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoAI_entry() //  [R1, R2]
         { info_tbl: [(cgpwS,
                       label: sat_sgoAI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpwS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpwT; else goto cgpwU;
       cgpwT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpwU: // global
           I64[Sp - 40] = block_cgpwh_info;
           _sgoAp::P64 = P64[R1 + 7];
           _sgoAr::P64 = P64[R1 + 15];
           _sgoAt::P64 = P64[R1 + 23];
           _sgoAu::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoAp::P64;
           P64[Sp - 24] = _sgoAr::P64;
           P64[Sp - 16] = _sgoAt::P64;
           P64[Sp - 8] = _sgoAu::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugpwY; else goto cgpwi;
       ugpwY: // global
           call _cgpwh(R1) args: 0, res: 0, upd: 0;
       cgpwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpwh() //  [R1]
         { info_tbl: [(cgpwh,
                       label: block_cgpwh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpwh: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgpwX; else goto cgpwW;
       cgpwX: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpwW: // global
           _sgoAy::P64 = P64[R1 + 7];
           _sgoAz::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgoAH_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sgoAt::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sgoAt::P64;
           P64[Hp - 48] = _sgoAy::P64;
           P64[Hp - 40] = _sgoAz::P64;
           I64[Hp - 32] = sat_sgoAE_info;
           P64[Hp - 16] = _sgoAt::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sgoAy::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgoAv_entry() //  [R1]
         { info_tbl: [(cgpx3,
                       label: sat_sgoAv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpx3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpx4; else goto cgpx5;
       cgpx4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpx5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoAJ_entry() //  [R1]
         { info_tbl: [(cgpx6,
                       label: sat_sgoAJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpx6: // global
           _sgoAJ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpx7; else goto cgpx8;
       cgpx8: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgpxa; else goto cgpx9;
       cgpxa: // global
           HpAlloc = 96;
           goto cgpx7;
       cgpx7: // global
           R1 = _sgoAJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpx9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAJ::P64;
           _sgoAp::P64 = P64[_sgoAJ::P64 + 16];
           _sgoAq::P64 = P64[_sgoAJ::P64 + 24];
           _sgoAr::P64 = P64[_sgoAJ::P64 + 32];
           _sgoAt::P64 = P64[_sgoAJ::P64 + 40];
           I64[Hp - 88] = lvl18_sgoAu_info;
           P64[Hp - 72] = _sgoAq::P64;
           P64[Hp - 64] = _sgoAr::P64;
           I64[Hp - 56] = sat_sgoAI_info;
           P64[Hp - 48] = _sgoAp::P64;
           P64[Hp - 40] = _sgoAr::P64;
           P64[Hp - 32] = _sgoAt::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoAv_info;
           P64[Hp] = _sgoAt::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMp_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpxb,
                       label: Data.Fixed.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpxb: // global
           _sgoAr::P64 = R4;
           _sgoAq::P64 = R3;
           _sgoAp::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpxc; else goto cgpxd;
       cgpxd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpxf; else goto cgpxe;
       cgpxf: // global
           HpAlloc = 24;
           goto cgpxc;
       cgpxc: // global
           R4 = _sgoAr::P64;
           R3 = _sgoAq::P64;
           R2 = _sgoAp::P64;
           R1 = Data.Fixed.$w$cgmapMp_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpxe: // global
           I64[Hp - 16] = lvl17_sgoAs_info;
           P64[Hp] = _sgoAp::P64;
           I64[Sp - 40] = block_cgpvu_info;
           R2 = _sgoAp::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgoAp::P64;
           P64[Sp - 16] = _sgoAq::P64;
           P64[Sp - 8] = _sgoAr::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpvu() //  [R1]
         { info_tbl: [(cgpvu,
                       label: block_cgpvu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpvu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgpxi; else goto cgpxh;
       cgpxi: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpxh: // global
           I64[Hp - 64] = sat_sgoAP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgoAJ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.539027397 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMp_closure" {
     Data.Fixed.$fDataFixed_$cgmapMp_closure:
         const Data.Fixed.$fDataFixed_$cgmapMp_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMp_entry() //  [R3, R4, R5]
         { info_tbl: [(cgpxn,
                       label: Data.Fixed.$fDataFixed_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpxn: // global
           _sgoAS::P64 = R4;
           R4 = R5;
           _sgoAR::P64 = R3;
           R3 = _sgoAS::P64;
           R2 = _sgoAR::P64;
           call Data.Fixed.$w$cgmapMp_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.540599382 UTC

[section ""data" . Data.Fixed.$w$cgmapM_closure" {
     Data.Fixed.$w$cgmapM_closure:
         const Data.Fixed.$w$cgmapM_info;
         const 0;
 },
 lvl17_sgoAX_entry() //  [R1]
         { info_tbl: [(cgpxy,
                       label: lvl17_sgoAX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpxz; else goto cgpxA;
       cgpxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpxA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoB2_entry() //  [R1, R2]
         { info_tbl: [(cgpxM,
                       label: sat_sgoB2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpxM: // global
           _sgoB0::P64 = R2;
           _sgoB2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgpxN; else goto cgpxO;
       cgpxO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpxQ; else goto cgpxP;
       cgpxQ: // global
           HpAlloc = 32;
           goto cgpxN;
       cgpxN: // global
           R2 = _sgoB0::P64;
           R1 = _sgoB2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpxP: // global
           _sgoAU::P64 = P64[_sgoB2::P64 + 7];
           _sgoAZ::P64 = P64[_sgoB2::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgoAZ::P64;
           P64[Hp] = _sgoB0::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoB3_entry() //  [R1, R2]
         { info_tbl: [(cgpxR,
                       label: sat_sgoB3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpxR: // global
           _sgoAZ::P64 = R2;
           _sgoB3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgpxS; else goto cgpxT;
       cgpxT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpxV; else goto cgpxU;
       cgpxV: // global
           HpAlloc = 24;
           goto cgpxS;
       cgpxS: // global
           R2 = _sgoAZ::P64;
           R1 = _sgoB3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpxU: // global
           _sgoAU::P64 = P64[_sgoB3::P64 + 7];
           _sgoAX::P64 = P64[_sgoB3::P64 + 15];
           I64[Hp - 16] = sat_sgoB2_info;
           P64[Hp - 8] = _sgoAU::P64;
           P64[Hp] = _sgoAZ::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgoAX::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgoAY_entry() //  [R1]
         { info_tbl: [(cgpy0,
                       label: sat_sgoAY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpy0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpy1; else goto cgpy2;
       cgpy1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpy2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpy3,
                       label: Data.Fixed.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpy3: // global
           _sgoAW::P64 = R4;
           _sgoAV::P64 = R3;
           _sgoAU::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgpy4; else goto cgpy5;
       cgpy5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgpy7; else goto cgpy6;
       cgpy7: // global
           HpAlloc = 80;
           goto cgpy4;
       cgpy4: // global
           R4 = _sgoAW::P64;
           R3 = _sgoAV::P64;
           R2 = _sgoAU::P64;
           R1 = Data.Fixed.$w$cgmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpy6: // global
           I64[Hp - 72] = lvl17_sgoAX_info;
           P64[Hp - 56] = _sgoAV::P64;
           P64[Hp - 48] = _sgoAW::P64;
           I64[Hp - 40] = sat_sgoB3_info;
           P64[Hp - 32] = _sgoAU::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = sat_sgoAY_info;
           P64[Hp] = _sgoAU::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.543083989 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapM_closure" {
     Data.Fixed.$fDataFixed_$cgmapM_closure:
         const Data.Fixed.$fDataFixed_$cgmapM_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapM_entry() //  [R3, R4, R5]
         { info_tbl: [(cgpyc,
                       label: Data.Fixed.$fDataFixed_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyc: // global
           _sgoB6::P64 = R4;
           R4 = R5;
           _sgoB5::P64 = R3;
           R3 = _sgoB6::P64;
           R2 = _sgoB5::P64;
           call Data.Fixed.$w$cgmapM_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.544257059 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapQi_closure" {
     Data.Fixed.$fDataFixed_$cgmapQi_closure:
         const Data.Fixed.$fDataFixed_$cgmapQi_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapQi_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpym,
                       label: Data.Fixed.$fDataFixed_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpym: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpyn; else goto cgpyo;
       cgpyn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgmapQi_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpyo: // global
           I64[Sp - 24] = block_cgpyj_info;
           R1 = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugpyw; else goto cgpyk;
       ugpyw: // global
           call _cgpyj(R1) args: 0, res: 0, upd: 0;
       cgpyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpyj() //  [R1]
         { info_tbl: [(cgpyj,
                       label: block_cgpyj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyj: // global
           if (I64[R1 + 7] == 0) goto cgpyv; else goto cgpyu;
       cgpyv: // global
           R3 = P64[Sp + 16];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpyu: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.547915774 UTC

[section ""data" . Data.Fixed.$w$cgmapMo_closure" {
     Data.Fixed.$w$cgmapMo_closure:
         const Data.Fixed.$w$cgmapMo_info;
         const 0;
 },
 lvl17_sgoBi_entry() //  [R1]
         { info_tbl: [(cgpyF,
                       label: lvl17_sgoBi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpyG; else goto cgpyH;
       cgpyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpyH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoBI_entry() //  [R1, R2]
         { info_tbl: [(cgpyU,
                       label: sat_sgoBI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpyV; else goto cgpyW;
       cgpyV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpyW: // global
           I64[Sp - 24] = block_cgpyR_info;
           _sgoBi::P64 = P64[R1 + 7];
           _sgoBj::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgoBi::P64;
           P64[Sp - 8] = _sgoBj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugpze; else goto cgpyS;
       ugpze: // global
           call _cgpyR(R1) args: 0, res: 0, upd: 0;
       cgpyS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpyR() //  [R1]
         { info_tbl: [(cgpyR,
                       label: block_cgpyR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyR: // global
           I64[Sp - 8] = block_cgpyZ_info;
           _sgoBF::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoBF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpzd; else goto cgpz1;
       ugpzd: // global
           call _cgpyZ(R1) args: 0, res: 0, upd: 0;
       cgpz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpyZ() //  [R1]
         { info_tbl: [(cgpyZ,
                       label: block_cgpyZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyZ: // global
           if (R1 & 7 == 1) goto cgpz7; else goto cgpzb;
       cgpz7: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpzb: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgoBk_entry() //  [R1]
         { info_tbl: [(cgpzn,
                       label: lvl18_sgoBk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpzo; else goto cgpzp;
       cgpzo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpzp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoBy_entry() //  [R1]
         { info_tbl: [(cgpzL,
                       label: sat_sgoBy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpzL: // global
           _sgoBy::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgpzM; else goto cgpzN;
       cgpzN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpzP; else goto cgpzO;
       cgpzP: // global
           HpAlloc = 56;
           goto cgpzM;
       cgpzM: // global
           R1 = _sgoBy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpzO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBy::P64;
           _sgoBh::P64 = P64[_sgoBy::P64 + 16];
           _sgoBj::P64 = P64[_sgoBy::P64 + 24];
           _sgoBo::P64 = P64[_sgoBy::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sgoBj::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoBu_entry() //  [R1, R2]
         { info_tbl: [(cgpA1,
                       label: sat_sgoBu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpA1: // global
           _sgoBr::P64 = R2;
           _sgoBu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgpA2; else goto cgpA3;
       cgpA3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpA5; else goto cgpA4;
       cgpA5: // global
           HpAlloc = 56;
           goto cgpA2;
       cgpA2: // global
           R2 = _sgoBr::P64;
           R1 = _sgoBu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpA4: // global
           _sgoBj::P64 = P64[_sgoBu::P64 + 7];
           _sgoBo::P64 = P64[_sgoBu::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoBj::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoBv_entry() //  [R1]
         { info_tbl: [(cgpA6,
                       label: sat_sgoBv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpA6: // global
           _sgoBv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpA7; else goto cgpA8;
       cgpA8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpAa; else goto cgpA9;
       cgpAa: // global
           HpAlloc = 24;
           goto cgpA7;
       cgpA7: // global
           R1 = _sgoBv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpA9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBv::P64;
           _sgoBj::P64 = P64[_sgoBv::P64 + 16];
           _sgoBk::P64 = P64[_sgoBv::P64 + 24];
           _sgoBo::P64 = P64[_sgoBv::P64 + 32];
           I64[Hp - 16] = sat_sgoBu_info;
           P64[Hp - 8] = _sgoBj::P64;
           P64[Hp] = _sgoBo::P64;
           R2 = _sgoBj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgoBk::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoBB_entry() //  [R1, R2]
         { info_tbl: [(cgpAb,
                       label: sat_sgoBB_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpAb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgpAc; else goto cgpAd;
       cgpAc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpAd: // global
           I64[Sp - 40] = block_cgpzv_info;
           _sgoBf::P64 = P64[R1 + 7];
           _sgoBh::P64 = P64[R1 + 15];
           _sgoBj::P64 = P64[R1 + 23];
           _sgoBk::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoBf::P64;
           P64[Sp - 24] = _sgoBh::P64;
           P64[Sp - 16] = _sgoBj::P64;
           P64[Sp - 8] = _sgoBk::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugpAu; else goto cgpzw;
       ugpAu: // global
           call _cgpzv(R1) args: 0, res: 0, upd: 0;
       cgpzw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpzv() //  [R1]
         { info_tbl: [(cgpzv,
                       label: block_cgpzv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpzv: // global
           I64[Sp - 8] = block_cgpzA_info;
           _sgoBo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoBo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpAt; else goto cgpzB;
       ugpAt: // global
           call _cgpzA(R1) args: 0, res: 0, upd: 0;
       cgpzB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpzA() //  [R1]
         { info_tbl: [(cgpzA,
                       label: block_cgpzA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpzA: // global
           _sgoBh::P64 = P64[Sp + 24];
           _sgoBj::P64 = P64[Sp + 32];
           _sgoBo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgpAg; else goto cgpAk;
       cgpAg: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgpAj; else goto cgpAi;
       cgpAj: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpAi: // global
           I64[Hp - 72] = sat_sgoBy_info;
           P64[Hp - 56] = _sgoBh::P64;
           P64[Hp - 48] = _sgoBj::P64;
           P64[Hp - 40] = _sgoBo::P64;
           I64[Hp - 32] = sat_sgoBv_info;
           P64[Hp - 16] = _sgoBj::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgoBo::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgpAk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpAp; else goto cgpAo;
       cgpAp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpAo: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoBj::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoBl_entry() //  [R1]
         { info_tbl: [(cgpAz,
                       label: sat_sgoBl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpAz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpAA; else goto cgpAB;
       cgpAA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpAB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoBC_entry() //  [R1]
         { info_tbl: [(cgpAC,
                       label: sat_sgoBC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpAC: // global
           _sgoBC::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpAD; else goto cgpAE;
       cgpAE: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgpAG; else goto cgpAF;
       cgpAG: // global
           HpAlloc = 96;
           goto cgpAD;
       cgpAD: // global
           R1 = _sgoBC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpAF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBC::P64;
           _sgoBf::P64 = P64[_sgoBC::P64 + 16];
           _sgoBg::P64 = P64[_sgoBC::P64 + 24];
           _sgoBh::P64 = P64[_sgoBC::P64 + 32];
           _sgoBj::P64 = P64[_sgoBC::P64 + 40];
           I64[Hp - 88] = lvl18_sgoBk_info;
           P64[Hp - 72] = _sgoBg::P64;
           P64[Hp - 64] = _sgoBh::P64;
           I64[Hp - 56] = sat_sgoBB_info;
           P64[Hp - 48] = _sgoBf::P64;
           P64[Hp - 40] = _sgoBh::P64;
           P64[Hp - 32] = _sgoBj::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoBl_info;
           P64[Hp] = _sgoBj::P64;
           R2 = _sgoBj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpAH,
                       label: Data.Fixed.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpAH: // global
           _sgoBh::P64 = R4;
           _sgoBg::P64 = R3;
           _sgoBf::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpAI; else goto cgpAJ;
       cgpAJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpAL; else goto cgpAK;
       cgpAL: // global
           HpAlloc = 24;
           goto cgpAI;
       cgpAI: // global
           R4 = _sgoBh::P64;
           R3 = _sgoBg::P64;
           R2 = _sgoBf::P64;
           R1 = Data.Fixed.$w$cgmapMo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpAK: // global
           I64[Hp - 16] = lvl17_sgoBi_info;
           P64[Hp] = _sgoBf::P64;
           I64[Sp - 40] = block_cgpyI_info;
           R2 = _sgoBf::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgoBf::P64;
           P64[Sp - 16] = _sgoBg::P64;
           P64[Sp - 8] = _sgoBh::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpyI() //  [R1]
         { info_tbl: [(cgpyI,
                       label: block_cgpyI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpyI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgpAO; else goto cgpAN;
       cgpAO: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpAN: // global
           I64[Hp - 64] = sat_sgoBI_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgoBC_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.555264081 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMo_closure" {
     Data.Fixed.$fDataFixed_$cgmapMo_closure:
         const Data.Fixed.$fDataFixed_$cgmapMo_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMo_entry() //  [R3, R4, R5]
         { info_tbl: [(cgpAT,
                       label: Data.Fixed.$fDataFixed_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpAT: // global
           _sgoBL::P64 = R4;
           R4 = R5;
           _sgoBK::P64 = R3;
           R3 = _sgoBL::P64;
           R2 = _sgoBK::P64;
           call Data.Fixed.$w$cgmapMo_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.556138562 UTC

[section ""data" . lvl_rgoyF_closure" {
     lvl_rgoyF_closure:
         const lvl_rgoyF_info;
         const 0;
 },
 lvl_rgoyF_entry() //  []
         { info_tbl: [(cgpB0,
                       label: lvl_rgoyF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpB0: // global
           R1 = Data.Fixed.conMkFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.556961811 UTC

[section ""data" . lvl1_rgoyG_closure" {
     lvl1_rgoyG_closure:
         const lvl1_rgoyG_info;
         const 0;
 },
 lvl1_rgoyG_entry() //  []
         { info_tbl: [(cgpB7,
                       label: lvl1_rgoyG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpB7: // global
           R1 = Data.Fixed.tyFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.558163301 UTC

[section ""data" . lvl2_rgoyH_closure" {
     lvl2_rgoyH_closure:
         const lvl2_rgoyH_info;
 },
 lvl2_rgoyH_entry() //  []
         { info_tbl: [(cgpBe,
                       label: lvl2_rgoyH_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBe: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.558967541 UTC

[section ""data" . lvl3_rgoyI_closure" {
     lvl3_rgoyI_closure:
         const lvl3_rgoyI_info;
 },
 lvl3_rgoyI_entry() //  []
         { info_tbl: [(cgpBl,
                       label: lvl3_rgoyI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBl: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.559798657 UTC

[section ""data" . lvl4_rgoyJ_closure" {
     lvl4_rgoyJ_closure:
         const lvl4_rgoyJ_info;
         const 0;
 },
 lvl4_rgoyJ_entry() //  [R2, R3]
         { info_tbl: [(cgpBs,
                       label: lvl4_rgoyJ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBs: // global
           R3 = R3;
           _sgoBT::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoBT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.560901249 UTC

[section ""data" . lvl5_rgoyK_closure" {
     lvl5_rgoyK_closure:
         const lvl5_rgoyK_info;
         const 0;
 },
 sat_sgoBZ_entry() //  [R1]
         { info_tbl: [(cgpBD,
                       label: sat_sgoBZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpBE; else goto cgpBF;
       cgpBE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpBF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl5_rgoyK_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpBG,
                       label: lvl5_rgoyK_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpBK; else goto cgpBJ;
       cgpBK: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl5_rgoyK_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpBJ: // global
           I64[Hp - 24] = sat_sgoBZ_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sgoBW::P64 = R3;
           R3 = Hp - 24;
           _sgoBV::P64 = R2;
           R2 = _sgoBW::P64;
           R1 = _sgoBV::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.562413853 UTC

[section ""data" . lvl6_rgoyL_closure" {
     lvl6_rgoyL_closure:
         const lvl6_rgoyL_info;
         const 0;
 },
 sat_sgoC4_entry() //  [R1]
         { info_tbl: [(cgpBT,
                       label: sat_sgoC4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpBU; else goto cgpBV;
       cgpBU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpBV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl6_rgoyL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpBW,
                       label: lvl6_rgoyL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpBW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpC0; else goto cgpBZ;
       cgpC0: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl6_rgoyL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpBZ: // global
           I64[Hp - 24] = sat_sgoC4_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R3;
           _sgoC0::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgoC0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.563879156 UTC

[section ""data" . lvl7_rgoyM_closure" {
     lvl7_rgoyM_closure:
         const lvl7_rgoyM_info;
         const 0;
 },
 sat_sgoC7_entry() //  [R1]
         { info_tbl: [(cgpC9,
                       label: sat_sgoC7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpC9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpCa; else goto cgpCb;
       cgpCa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpCb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rgoyM_entry() //  [R2, R3]
         { info_tbl: [(cgpCd,
                       label: lvl7_rgoyM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpCd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpCh; else goto cgpCg;
       cgpCh: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rgoyM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpCg: // global
           I64[Hp - 48] = sat_sgoC7_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.56535808 UTC

[section ""data" . lvl8_rgoyN_closure" {
     lvl8_rgoyN_closure:
         const lvl8_rgoyN_info;
         const 0;
 },
 sat_sgoCb_entry() //  [R1]
         { info_tbl: [(cgpCq,
                       label: sat_sgoCb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpCq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpCr; else goto cgpCs;
       cgpCr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpCs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rgoyN_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpCt,
                       label: lvl8_rgoyN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpCt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpCx; else goto cgpCw;
       cgpCx: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl8_rgoyN_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpCw: // global
           I64[Hp - 16] = sat_sgoCb_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sgoC8::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoC8::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.566969894 UTC

[section ""data" . Data.Fixed.$fDataFixed_closure" {
     Data.Fixed.$fDataFixed_closure:
         const Data.Fixed.$fDataFixed_info;
         const 0;
 },
 sat_sgoCf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgpCH,
                       label: sat_sgoCf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpCH: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgmapQi_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoCe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgpCP,
                       label: sat_sgoCe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpCP: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgfoldl_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoCd_entry() //  [R1]
         { info_tbl: [(cgpCW,
                       label: sat_sgoCd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpCW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpCX; else goto cgpCY;
       cgpCX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpCY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fDataFixed7_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_entry() //  [R2]
         { info_tbl: [(cgpD0,
                       label: Data.Fixed.$fDataFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpD0: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cgpD4; else goto cgpD3;
       cgpD4: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpD3: // global
           I64[Hp - 176] = sat_sgoCf_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sgoCe_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sgoCd_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 144;
           P64[Hp - 104] = Hp - 157;
           P64[Hp - 96] = lvl8_rgoyN_closure+3;
           P64[Hp - 88] = lvl_rgoyF_closure+1;
           P64[Hp - 80] = lvl1_rgoyG_closure+1;
           P64[Hp - 72] = lvl2_rgoyH_closure+2;
           P64[Hp - 64] = lvl3_rgoyI_closure+2;
           P64[Hp - 56] = lvl4_rgoyJ_closure+2;
           P64[Hp - 48] = lvl5_rgoyK_closure+4;
           P64[Hp - 40] = lvl6_rgoyL_closure+4;
           P64[Hp - 32] = lvl7_rgoyM_closure+2;
           P64[Hp - 24] = Hp - 173;
           P64[Hp - 16] = Data.Fixed.$w$cgmapM_closure+3;
           P64[Hp - 8] = Data.Fixed.$w$cgmapMp_closure+3;
           P64[Hp] = Data.Fixed.$w$cgmapMo_closure+3;
           R1 = Hp - 119;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.568603381 UTC

[section ""cstring" . Data.Fixed.$tcHasResolution3_bytes" {
     Data.Fixed.$tcHasResolution3_bytes:
         I8[] [72,97,115,82,101,115,111,108,117,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.569182722 UTC

[section ""data" . Data.Fixed.$tcHasResolution2_closure" {
     Data.Fixed.$tcHasResolution2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcHasResolution3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.569763316 UTC

[section ""data" . Data.Fixed.$tcHasResolution_closure" {
     Data.Fixed.$tcHasResolution_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcHasResolution2_closure+1;
         const Data.Fixed.$tcHasResolution1_closure+4;
         const 7410670074803796200;
         const 11622449620609036983;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.570379775 UTC

[section ""cstring" . Data.Fixed.$tcE5_bytes" {
     Data.Fixed.$tcE5_bytes:
         I8[] [69,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.570913051 UTC

[section ""data" . Data.Fixed.$tcE4_closure" {
     Data.Fixed.$tcE4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.571450264 UTC

[section ""data" . Data.Fixed.$tcE0_closure" {
     Data.Fixed.$tcE0_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE4_closure+1;
         const GHC.Types.krep$*_closure;
         const 1111589946053822622;
         const 14645449775626969178;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.571997648 UTC

[section ""cstring" . Data.Fixed.$tcE8_bytes" {
     Data.Fixed.$tcE8_bytes:
         I8[] [69,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.572554051 UTC

[section ""data" . Data.Fixed.$tcE7_closure" {
     Data.Fixed.$tcE7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.573131225 UTC

[section ""data" . Data.Fixed.$tcE1_closure" {
     Data.Fixed.$tcE1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE7_closure+1;
         const GHC.Types.krep$*_closure;
         const 17242267792727872229;
         const 10571291330004494282;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.573969322 UTC

[section ""cstring" . Data.Fixed.$tcE14_bytes" {
     Data.Fixed.$tcE14_bytes:
         I8[] [69,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.574519769 UTC

[section ""data" . Data.Fixed.$tcE13_closure" {
     Data.Fixed.$tcE13_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE14_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.575141701 UTC

[section ""data" . Data.Fixed.$tcE2_closure" {
     Data.Fixed.$tcE2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE13_closure+1;
         const GHC.Types.krep$*_closure;
         const 18184774527647329547;
         const 15895109557895358229;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.575754735 UTC

[section ""cstring" . Data.Fixed.$tcE16_bytes" {
     Data.Fixed.$tcE16_bytes:
         I8[] [69,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.576302548 UTC

[section ""data" . Data.Fixed.$tcE15_closure" {
     Data.Fixed.$tcE15_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE16_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.576886721 UTC

[section ""data" . Data.Fixed.$tcE3_closure" {
     Data.Fixed.$tcE3_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE15_closure+1;
         const GHC.Types.krep$*_closure;
         const 2281297682271263739;
         const 13982938170987291273;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.577590687 UTC

[section ""cstring" . Data.Fixed.$tcE18_bytes" {
     Data.Fixed.$tcE18_bytes:
         I8[] [69,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.578143228 UTC

[section ""data" . Data.Fixed.$tcE17_closure" {
     Data.Fixed.$tcE17_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE18_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.578708701 UTC

[section ""data" . Data.Fixed.$tcE6_closure" {
     Data.Fixed.$tcE6_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE17_closure+1;
         const GHC.Types.krep$*_closure;
         const 6430880657524859014;
         const 16351944333195325805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.579316892 UTC

[section ""cstring" . Data.Fixed.$tcE20_bytes" {
     Data.Fixed.$tcE20_bytes:
         I8[] [69,57]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.579929477 UTC

[section ""data" . Data.Fixed.$tcE19_closure" {
     Data.Fixed.$tcE19_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE20_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.580552466 UTC

[section ""data" . Data.Fixed.$tcE9_closure" {
     Data.Fixed.$tcE9_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE19_closure+1;
         const GHC.Types.krep$*_closure;
         const 8202840314884717291;
         const 5390706447224283764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.581170061 UTC

[section ""cstring" . Data.Fixed.$tcE11_bytes" {
     Data.Fixed.$tcE11_bytes:
         I8[] [69,49,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.581787628 UTC

[section ""data" . Data.Fixed.$tcE10_closure" {
     Data.Fixed.$tcE10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.582386792 UTC

[section ""data" . Data.Fixed.$tcE12_closure" {
     Data.Fixed.$tcE12_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE10_closure+1;
         const GHC.Types.krep$*_closure;
         const 11177455628646877585;
         const 1804744900678580889;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.583543209 UTC

[section ""data" . Data.Fixed.div'_closure" {
     Data.Fixed.div'_closure:
         const Data.Fixed.div'_info;
         const 0;
 },
 Data.Fixed.div'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpDb,
                       label: Data.Fixed.div'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgpDj; else goto cgpDk;
       cgpDj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.div'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpDk: // global
           I64[Sp - 32] = block_cgpD9_info;
           _sgoCg::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _sgoCg::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgpD9() //  [R1]
         { info_tbl: [(cgpD9,
                       label: block_cgpD9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpD9: // global
           I64[Sp] = block_cgpDe_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgpDe() //  [R1]
         { info_tbl: [(cgpDe,
                       label: block_cgpDe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDe: // global
           _sgoCm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpDi_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sgoCm::P64;
           R2 = P64[Sp + 24];
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpDi() //  [R1, R2]
         { info_tbl: [(cgpDi,
                       label: block_cgpDi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDi: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.586220816 UTC

[section ""data" . Data.Fixed.$wdivMod'_closure" {
     Data.Fixed.$wdivMod'_closure:
         const Data.Fixed.$wdivMod'_info;
         const 0;
 },
 f_sgoCx_entry() //  [R1]
         { info_tbl: [(cgpDx,
                       label: f_sgoCx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpDy; else goto cgpDz;
       cgpDy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpDz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoCz_entry() //  [R1]
         { info_tbl: [(cgpDU,
                       label: sat_sgoCz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpDV; else goto cgpDW;
       cgpDV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpDW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCA_entry() //  [R1]
         { info_tbl: [(cgpDX,
                       label: sat_sgoCA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDX: // global
           _sgoCA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgpDY; else goto cgpDZ;
       cgpDZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpE1; else goto cgpE0;
       cgpE1: // global
           HpAlloc = 32;
           goto cgpDY;
       cgpDY: // global
           R1 = _sgoCA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpE0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCA::P64;
           _sgoCu::P64 = P64[_sgoCA::P64 + 16];
           _sgoCx::P64 = P64[_sgoCA::P64 + 24];
           _sgoCy::P64 = P64[_sgoCA::P64 + 32];
           I64[Hp - 24] = sat_sgoCz_info;
           P64[Hp - 8] = _sgoCu::P64;
           P64[Hp] = _sgoCx::P64;
           R2 = _sgoCy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCB_entry() //  [R1]
         { info_tbl: [(cgpE2,
                       label: sat_sgoCB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpE2: // global
           _sgoCB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpE3; else goto cgpE4;
       cgpE4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgpE6; else goto cgpE5;
       cgpE6: // global
           HpAlloc = 40;
           goto cgpE3;
       cgpE3: // global
           R1 = _sgoCB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpE5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCB::P64;
           _sgoCu::P64 = P64[_sgoCB::P64 + 16];
           _sgoCw::P64 = P64[_sgoCB::P64 + 24];
           _sgoCx::P64 = P64[_sgoCB::P64 + 32];
           _sgoCy::P64 = P64[_sgoCB::P64 + 40];
           I64[Hp - 32] = sat_sgoCA_info;
           P64[Hp - 16] = _sgoCu::P64;
           P64[Hp - 8] = _sgoCx::P64;
           P64[Hp] = _sgoCy::P64;
           R2 = _sgoCy::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgoCw::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoCC_entry() //  [R1]
         { info_tbl: [(cgpE7,
                       label: sat_sgoCC_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpE7: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgpE8; else goto cgpE9;
       cgpE8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpE9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgpDE_info;
           R2 = P64[R1 + 16];
           P64[Sp - 48] = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 56;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpDE() //  [R1]
         { info_tbl: [(cgpDE,
                       label: block_cgpDE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpDE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgpEc; else goto cgpEb;
       cgpEc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgpEb: // global
           I64[Hp - 40] = sat_sgoCB_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           _sgoCv::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _sgoCv::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$wdivMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpEd,
                       label: Data.Fixed.$wdivMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpEd: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgpEh; else goto cgpEg;
       cgpEh: // global
           HpAlloc = 104;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$wdivMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpEg: // global
           I64[Hp - 96] = f_sgoCx_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = sat_sgoCC_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _cgpDt::P64 = Hp - 96;
           P64[Hp] = _cgpDt::P64;
           R2 = Hp - 48;
           R1 = _cgpDt::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.589461604 UTC

[section ""data" . Data.Fixed.divMod'_closure" {
     Data.Fixed.divMod'_closure:
         const Data.Fixed.divMod'_info;
         const 0;
 },
 Data.Fixed.divMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpEp,
                       label: Data.Fixed.divMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpEp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgpEq; else goto cgpEr;
       cgpEq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.divMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpEr: // global
           I64[Sp - 8] = block_cgpEm_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$wdivMod'_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpEm() //  [R1, R2]
         { info_tbl: [(cgpEm,
                       label: block_cgpEm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpEm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpEu; else goto cgpEt;
       cgpEu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpEt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.591412723 UTC

[section ""data" . Data.Fixed.mod'_closure" {
     Data.Fixed.mod'_closure:
         const Data.Fixed.mod'_info;
         const 0;
 },
 sat_sgoCO_entry() //  [R1]
         { info_tbl: [(cgpEP,
                       label: sat_sgoCO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpEP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpEQ; else goto cgpER;
       cgpEQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpER: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoCP_entry() //  [R1]
         { info_tbl: [(cgpES,
                       label: sat_sgoCP_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpES: // global
           _sgoCP::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgpET; else goto cgpEU;
       cgpEU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgpEW; else goto cgpEV;
       cgpEW: // global
           HpAlloc = 40;
           goto cgpET;
       cgpET: // global
           R1 = _sgoCP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpEV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCP::P64;
           _sgoCK::P64 = P64[_sgoCP::P64 + 16];
           _sgoCL::P64 = P64[_sgoCP::P64 + 24];
           _sgoCM::P64 = P64[_sgoCP::P64 + 32];
           _sgoCN::P64 = P64[_sgoCP::P64 + 40];
           I64[Hp - 32] = sat_sgoCO_info;
           P64[Hp - 16] = _sgoCK::P64;
           P64[Hp - 8] = _sgoCL::P64;
           P64[Hp] = _sgoCM::P64;
           R2 = _sgoCN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCQ_entry() //  [R1]
         { info_tbl: [(cgpEX,
                       label: sat_sgoCQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpEX: // global
           _sgoCQ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpEY; else goto cgpEZ;
       cgpEZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgpF1; else goto cgpF0;
       cgpF1: // global
           HpAlloc = 48;
           goto cgpEY;
       cgpEY: // global
           R1 = _sgoCQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCQ::P64;
           _sgoCK::P64 = P64[_sgoCQ::P64 + 16];
           _sgoCL::P64 = P64[_sgoCQ::P64 + 24];
           _sgoCM::P64 = P64[_sgoCQ::P64 + 32];
           _sgoCN::P64 = P64[_sgoCQ::P64 + 40];
           I64[Hp - 40] = sat_sgoCP_info;
           P64[Hp - 24] = _sgoCK::P64;
           P64[Hp - 16] = _sgoCL::P64;
           P64[Hp - 8] = _sgoCM::P64;
           P64[Hp] = _sgoCN::P64;
           R2 = _sgoCN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sgoCM::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.mod'_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpF2,
                       label: Data.Fixed.mod'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpF2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpF3; else goto cgpF4;
       cgpF3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.mod'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpF4: // global
           I64[Sp - 32] = block_cgpEz_info;
           _sgoCK::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sgoCK::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpEz() //  [R1]
         { info_tbl: [(cgpEz,
                       label: block_cgpEz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpEz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgpF7; else goto cgpF6;
       cgpF7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpF6: // global
           I64[Hp - 40] = sat_sgoCQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.594377412 UTC

[section ""data" . Data.Fixed.$fFractionalFixed2_closure" {
     Data.Fixed.$fFractionalFixed2_closure:
         const Data.Fixed.$fFractionalFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fFractionalFixed2_entry() //  [R1]
         { info_tbl: [(cgpFe,
                       label: Data.Fixed.$fFractionalFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpFf; else goto cgpFg;
       cgpFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpFg: // global
           (_cgpFb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpFb::I64 == 0) goto cgpFd; else goto cgpFc;
       cgpFd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpFc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpFb::I64;
           R2 = $dIP3_rgoyz_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.595640519 UTC

[section ""data" . Data.Fixed.$w$cfromRational_closure" {
     Data.Fixed.$w$cfromRational_closure:
         const Data.Fixed.$w$cfromRational_info;
         const 0;
 },
 Data.Fixed.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpFn,
                       label: Data.Fixed.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpFz; else goto cgpFA;
       cgpFz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpFA: // global
           I64[Sp - 24] = block_cgpFl_info;
           _sgoCR::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoCR::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpFl() //  [R1]
         { info_tbl: [(cgpFl,
                       label: block_cgpFl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFl: // global
           I64[Sp] = block_cgpFq_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpFq() //  [R1]
         { info_tbl: [(cgpFq,
                       label: block_cgpFq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFq: // global
           _sgoCS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpFu_info;
           R3 = P64[Sp + 16];
           R2 = _sgoCS::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpFu() //  [R1]
         { info_tbl: [(cgpFu,
                       label: block_cgpFu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFu: // global
           _sgoCW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpFy_info;
           R3 = _sgoCW::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpFy() //  [R1, R2]
         { info_tbl: [(cgpFy,
                       label: block_cgpFy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFy: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.598968854 UTC

[section ""data" . Data.Fixed.$fFractionalFixed1_closure" {
     Data.Fixed.$fFractionalFixed1_closure:
         const Data.Fixed.$fFractionalFixed1_info;
         const 0;
 },
 Data.Fixed.$fFractionalFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgpFN,
                       label: Data.Fixed.$fFractionalFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpFO; else goto cgpFP;
       cgpFO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpFP: // global
           I64[Sp - 16] = block_cgpFK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugpFT; else goto cgpFL;
       ugpFT: // global
           call _cgpFK(R1) args: 0, res: 0, upd: 0;
       cgpFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpFK() //  [R1]
         { info_tbl: [(cgpFK,
                       label: block_cgpFK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFK: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Fixed.$w$cfromRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.600347697 UTC

[section ""data" . Data.Fixed.$fRealFixed_$ctoRational_closure" {
     Data.Fixed.$fRealFixed_$ctoRational_closure:
         const Data.Fixed.$fRealFixed_$ctoRational_info;
         const 0;
 },
 Data.Fixed.$fRealFixed_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(cgpG0,
                       label: Data.Fixed.$fRealFixed_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpG6; else goto cgpG7;
       cgpG6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpG7: // global
           I64[Sp - 16] = block_cgpFY_info;
           _sgoD5::P64 = R2;
           R2 = R3;
           R1 = _sgoD5::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpFY() //  [R1]
         { info_tbl: [(cgpFY,
                       label: block_cgpFY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpFY: // global
           _sgoD6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpG3_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgoD6::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpG3() //  [R1, R2]
         { info_tbl: [(cgpG3,
                       label: block_cgpG3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpG3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpGb; else goto cgpGa;
       cgpGb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpGa: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.602025742 UTC

[section ""data" . Data.Fixed.$fFractionalFixed3_closure" {
     Data.Fixed.$fFractionalFixed3_closure:
         const Data.Fixed.$fFractionalFixed3_info;
         const 0;
 },
 section ""relreadonly" . ugpGE_srtd" {
     ugpGE_srtd:
         const SgoHz_srt+40;
         const 72;
         const 4611686018427387905;
         const 224;
 },
 Data.Fixed.$fFractionalFixed3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpGl,
                       label: Data.Fixed.$fFractionalFixed3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpGm; else goto cgpGn;
       cgpGm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpGn: // global
           I64[Sp - 32] = block_cgpGg_info;
           _sgoDc::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoDb::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgoDb::P64;
           P64[Sp - 16] = _sgoDc::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpGg() //  [R1]
         { info_tbl: [(cgpGg,
                       label: block_cgpGg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGg: // global
           if (R1 == 1) goto cgpGk; else goto cgpGj;
       cgpGk: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpGj: // global
           _sgoDb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpGq_info;
           R2 = P64[Sp + 16];
           R1 = _sgoDb::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpGq() //  [R1]
         { info_tbl: [(cgpGq,
                       label: block_cgpGq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGq: // global
           _sgoDc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpGu_info;
           R3 = R1;
           R2 = _sgoDc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpGu() //  [R1]
         { info_tbl: [(cgpGu,
                       label: block_cgpGu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGu: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.60378497 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_$crecip_closure" {
     Data.Fixed.$fFractionalFixed_$crecip_closure:
         const Data.Fixed.$fFractionalFixed_$crecip_info;
         const 0;
 },
 section ""relreadonly" . ugpH7_srtd" {
     ugpH7_srtd:
         const SgoHz_srt+40;
         const 73;
         const 4611686018427387905;
         const 352;
 },
 Data.Fixed.$fFractionalFixed_$crecip_entry() //  [R2, R3]
         { info_tbl: [(cgpGO,
                       label: Data.Fixed.$fFractionalFixed_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpGP; else goto cgpGQ;
       cgpGP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpGQ: // global
           I64[Sp - 24] = block_cgpGJ_info;
           _sgoDi::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoDh::P64 = R2;
           R2 = _sgoDi::P64;
           P64[Sp - 16] = _sgoDh::P64;
           P64[Sp - 8] = _sgoDi::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpGJ() //  [R1]
         { info_tbl: [(cgpGJ,
                       label: block_cgpGJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGJ: // global
           if (R1 == 1) goto cgpGN; else goto cgpGM;
       cgpGN: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpGM: // global
           _sgoDh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpGT_info;
           R2 = P64[Sp + 16];
           R1 = _sgoDh::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpGT() //  [R1]
         { info_tbl: [(cgpGT,
                       label: block_cgpGT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGT: // global
           I64[Sp] = block_cgpGX_info;
           R3 = R1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpGX() //  [R1]
         { info_tbl: [(cgpGX,
                       label: block_cgpGX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpGX: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.605561573 UTC

[section ""data" . Data.Fixed.$fNumFixed_$c*_closure" {
     Data.Fixed.$fNumFixed_$c*_closure:
         const Data.Fixed.$fNumFixed_$c*_info;
         const 0;
 },
 section ""relreadonly" . ugpHA_srtd" {
     ugpHA_srtd:
         const SgoHz_srt+40;
         const 74;
         const 4611686018427387905;
         const 608;
 },
 Data.Fixed.$fNumFixed_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpHe,
                       label: Data.Fixed.$fNumFixed_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpHf; else goto cgpHg;
       cgpHf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpHg: // global
           I64[Sp - 24] = block_cgpHc_info;
           _sgoDm::P64 = R2;
           R2 = R3;
           R1 = _sgoDm::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpHB_srtd" {
     ugpHB_srtd:
         const SgoHz_srt+40;
         const 71;
         const 4611686018427387905;
         const 96;
 },
 _cgpHc() //  [R1]
         { info_tbl: [(cgpHc,
                       label: block_cgpHc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHc: // global
           I64[Sp - 8] = block_cgpHj_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpHj() //  [R1]
         { info_tbl: [(cgpHj,
                       label: block_cgpHj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHj: // global
           if (R1 == 1) goto cgpHz; else goto cgpHr;
       cgpHz: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpHr: // global
           I64[Sp] = block_cgpHo_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpHo() //  [R1]
         { info_tbl: [(cgpHo,
                       label: block_cgpHo_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHo: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.607220202 UTC

[section ""data" . Data.Fixed.$fNumFixed1_closure" {
     Data.Fixed.$fNumFixed1_closure:
         const Data.Fixed.$fNumFixed1_info;
         const 0;
 },
 Data.Fixed.$fNumFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgpHI,
                       label: Data.Fixed.$fNumFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpHJ; else goto cgpHK;
       cgpHJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpHK: // global
           I64[Sp - 16] = block_cgpHG_info;
           _sgoDs::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoDs::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpHG() //  [R1]
         { info_tbl: [(cgpHG,
                       label: block_cgpHG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHG: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.608453002 UTC

[section ""data" . Data.Fixed.$fNumFixed2_closure" {
     Data.Fixed.$fNumFixed2_closure:
         const Data.Fixed.$fNumFixed2_info;
         const 0;
 },
 Data.Fixed.$fNumFixed2_entry() //  [R2, R3]
         { info_tbl: [(cgpHU,
                       label: Data.Fixed.$fNumFixed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpHY; else goto cgpHZ;
       cgpHY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpHZ: // global
           I64[Sp - 16] = block_cgpHS_info;
           _sgoDv::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoDv::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpHS() //  [R1]
         { info_tbl: [(cgpHS,
                       label: block_cgpHS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHS: // global
           I64[Sp] = block_cgpHX_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpHX() //  [R1]
         { info_tbl: [(cgpHX,
                       label: block_cgpHX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpHX: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.610517441 UTC

[section ""data" . Data.Fixed.$fNumFixed_closure" {
     Data.Fixed.$fNumFixed_closure:
         const Data.Fixed.$fNumFixed_info;
         const 0;
 },
 sat_sgoDC_entry() //  [R1, R2]
         { info_tbl: [(cgpIe,
                       label: sat_sgoDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpIe: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDB_entry() //  [R1, R2]
         { info_tbl: [(cgpIm,
                       label: sat_sgoDB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpIm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpIu,
                       label: sat_sgoDA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpIu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fNumFixed_$c*_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpID_srtd" {
     ugpID_srtd:
         const SgoHz_srt+16;
         const 80;
         const 3;
         const 61440;
 },
 Data.Fixed.$fNumFixed_entry() //  [R2]
         { info_tbl: [(cgpIy,
                       label: Data.Fixed.$fNumFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpIy: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgpIC; else goto cgpIB;
       cgpIC: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpIB: // global
           I64[Hp - 104] = sat_sgoDC_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgoDB_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgoDA_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = GHC.Integer.Type.plusInteger_closure+2;
           P64[Hp - 40] = GHC.Integer.Type.minusInteger_closure+2;
           P64[Hp - 32] = Hp - 70;
           P64[Hp - 24] = GHC.Integer.Type.negateInteger_closure+1;
           P64[Hp - 16] = GHC.Integer.Type.absInteger_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.61260456 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_closure" {
     Data.Fixed.$fFractionalFixed_closure:
         const Data.Fixed.$fFractionalFixed_info;
         const 0;
 },
 sat_sgoDH_entry() //  [R1, R2]
         { info_tbl: [(cgpIN,
                       label: sat_sgoDH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpIN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDG_entry() //  [R1, R2]
         { info_tbl: [(cgpIV,
                       label: sat_sgoDG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpIV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed_$crecip_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDF_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpJ3,
                       label: sat_sgoDF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJ3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDE_entry() //  [R1]
         { info_tbl: [(cgpJa,
                       label: sat_sgoDE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpJb; else goto cgpJc;
       cgpJb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpJc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fFractionalFixed_entry() //  [R2]
         { info_tbl: [(cgpJe,
                       label: Data.Fixed.$fFractionalFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJe: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgpJi; else goto cgpJh;
       cgpJi: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpJh: // global
           I64[Hp - 104] = sat_sgoDH_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgoDG_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgoDF_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoDE_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.614501918 UTC

[section ""data" . Data.Fixed.$fReadFixed2_closure" {
     Data.Fixed.$fReadFixed2_closure:
         const Data.Fixed.$fReadFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed2_entry() //  [R1]
         { info_tbl: [(cgpJs,
                       label: Data.Fixed.$fReadFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJs: // global
           _rgoxK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgpJv; else goto cgpJw;
       cgpJw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgpJy; else goto cgpJx;
       cgpJy: // global
           HpAlloc = 16;
           goto cgpJv;
       cgpJv: // global
           R1 = _rgoxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpJx: // global
           (_cgpJm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rgoxK::P64);
           if (_cgpJm::I64 == 0) goto cgpJo; else goto cgpJn;
       cgpJo: // global
           call (I64[I64[_rgoxK::P64]])() args: 8, res: 0, upd: 8;
       cgpJn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpJm::I64;
           (_cgpJp::F64) = call MO_F64_Log(10.0 :: W64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _cgpJp::F64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.615559035 UTC

[section ""data" . lvl9_rgoyO_closure" {
     lvl9_rgoyO_closure:
         const GHC.Types.I#_con_info;
         const 172;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.616115457 UTC

[section ""data" . lvl10_rgoyP_closure" {
     lvl10_rgoyP_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.616694148 UTC

[section ""data" . lvl11_rgoyQ_closure" {
     lvl11_rgoyQ_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.617281469 UTC

[section ""data" . lvl12_rgoyR_closure" {
     lvl12_rgoyR_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const lvl9_rgoyO_closure+1;
         const lvl10_rgoyP_closure+1;
         const lvl9_rgoyO_closure+1;
         const lvl11_rgoyQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.617887167 UTC

[section ""data" . lvl13_rgoyS_closure" {
     lvl13_rgoyS_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const lvl12_rgoyR_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.618647103 UTC

[section ""data" . Data.Fixed.$fReadFixed3_closure" {
     Data.Fixed.$fReadFixed3_closure:
         const Data.Fixed.$fReadFixed3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed3_entry() //  [R1]
         { info_tbl: [(cgpJF,
                       label: Data.Fixed.$fReadFixed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpJG; else goto cgpJH;
       cgpJG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpJH: // global
           (_cgpJC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgpJC::I64 == 0) goto cgpJE; else goto cgpJD;
       cgpJE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgpJD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgpJC::I64;
           R2 = lvl13_rgoyS_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.622277052 UTC

[section ""data" . Data.Fixed.$fReadFixed1_closure" {
     Data.Fixed.$fReadFixed1_closure:
         const Data.Fixed.$fReadFixed1_info;
         const 0;
 },
 lvl17_sgoDK_entry() //  [R1]
         { info_tbl: [(cgpJQ,
                       label: lvl17_sgoDK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpJR; else goto cgpJS;
       cgpJR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpJS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 e_sgoDL_entry() //  [R1]
         { info_tbl: [(cgpJZ,
                       label: e_sgoDL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpKb; else goto cgpKc;
       cgpKb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpKc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgpJX_info;
           R2 = Data.Fixed.$fReadFixed3_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpJX() //  [R1]
         { info_tbl: [(cgpJX,
                       label: block_cgpJX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpJX: // global
           I64[Sp] = block_cgpK2_info;
           R2 = R1;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpK2() //  [D1]
         { info_tbl: [(cgpK2,
                       label: block_cgpK2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpK2: // global
           _cgpK7::F64 = D1;
           (_cgpK6::F64) = call MO_F64_Log(_cgpK7::F64);
           I64[Sp - 8] = block_cgpKa_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgpK6::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpLf; else goto cgpKf;
       ugpLf: // global
           call _cgpKa(R1) args: 0, res: 0, upd: 0;
       cgpKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpKa() //  [R1]
         { info_tbl: [(cgpKa,
                       label: block_cgpKa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpKa: // global
           _sgoDS::F64 = %MO_F_Neg_W64(%MO_F_Quot_W64(F64[Sp + 8],
                                                      F64[R1 + 7]));
           I64[Sp + 8] = block_cgpKq_info;
           D1 = _sgoDS::F64;
           Sp = Sp + 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpKq() //  [R1, R2]
         { info_tbl: [(cgpKq,
                       label: block_cgpKq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpKq: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cgpKA; else goto cgpLe;
       cgpKA: // global
           I64[Sp] = block_cgpKy_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
       cgpLe: // global
           _sgoDY::I64 = -R2;
           if (%MO_S_Le_W64(_sgoDY::I64, 52)) goto cgpKV; else goto cgpL3;
       cgpKV: // global
           I64[Sp - 8] = block_cgpKM_info;
           R2 = R1;
           I64[Sp] = _sgoDY::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
       cgpL3: // global
           I64[Sp] = block_cgpL2_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpKy() //  [R1]
         { info_tbl: [(cgpKy,
                       label: block_cgpKy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpKy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgpKM() //  [R1]
         { info_tbl: [(cgpKM,
                       label: block_cgpKM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpKM: // global
           _sgoE1::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cgpKT_info;
           R2 = _sgoE1::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpKT() //  [R1]
         { info_tbl: [(cgpKT,
                       label: block_cgpKT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpKT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgpL2() //  [R1]
         { info_tbl: [(cgpL2,
                       label: block_cgpL2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpL2: // global
           if (R1 == 1) goto cgpLd; else goto cgpL9;
       cgpLd: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cgpL9: // global
           R1 = Data.Fixed.$fEnumFixed1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpN9_srtd" {
     ugpN9_srtd:
         const SgoHz_srt+120;
         const 57;
         const 76561193665298433;
 },
 sat_sgoE7_entry() //  [R1]
         { info_tbl: [(cgpLq,
                       label: sat_sgoE7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpLr; else goto cgpLs;
       cgpLr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpLs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgpLo_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugpNa_srtd" {
     ugpNa_srtd:
         const SgoHz_srt+120;
         const 53;
         const 4503599627370497;
 },
 _cgpLo() //  [R1]
         { info_tbl: [(cgpLo,
                       label: block_cgpLo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLo: // global
           R3 = R1;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoE5_entry() //  [R1]
         { info_tbl: [(cgpLA,
                       label: sat_sgoE5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpLB; else goto cgpLC;
       cgpLB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpNb_srtd" {
     ugpNb_srtd:
         const SgoHz_srt+120;
         const 75;
         const 76842668642009089;
         const 1028;
 },
 lvl18_sgoE4_entry() //  [R1]
         { info_tbl: [(cgpLD,
                       label: lvl18_sgoE4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLD: // global
           _sgoE4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgpLE; else goto cgpLF;
       cgpLF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgpLH; else goto cgpLG;
       cgpLH: // global
           HpAlloc = 48;
           goto cgpLE;
       cgpLE: // global
           R1 = _sgoE4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpLG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoE4::P64;
           _sgoDJ::P64 = P64[_sgoE4::P64 + 16];
           _sgoDL::P64 = P64[_sgoE4::P64 + 24];
           I64[Hp - 40] = sat_sgoE7_info;
           P64[Hp - 24] = _sgoDJ::P64;
           I64[Hp - 16] = sat_sgoE5_info;
           P64[Hp] = _sgoDJ::P64;
           R5 = _sgoDL::P64;
           R4 = Hp - 40;
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpNc_srtd" {
     ugpNc_srtd:
         const SgoHz_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 x_sgoEh_entry() //  [R1]
         { info_tbl: [(cgpM9,
                       label: x_sgoEh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpM9: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgpMh; else goto cgpMi;
       cgpMh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpMi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgpM7_info;
           _sgoDK::P64 = P64[R1 + 24];
           R3 = _sgoDK::P64;
           R2 = P64[R1 + 48];
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = _sgoDK::P64;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 56;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugpNd_srtd" {
     ugpNd_srtd:
         const SgoHz_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 _cgpM7() //  [R1]
         { info_tbl: [(cgpM7,
                       label: block_cgpM7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpM7: // global
           _sgoDJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpMc_info;
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = _sgoDJ::P64;
           Sp = Sp + 8;
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugpNe_srtd" {
     ugpNe_srtd:
         const SgoHz_srt+16;
         const 66;
         const 1;
         const 2;
 },
 _cgpMc() //  [R1]
         { info_tbl: [(cgpMc,
                       label: block_cgpMc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpMc: // global
           I64[Sp + 16] = block_cgpMg_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpMg() //  [R1]
         { info_tbl: [(cgpMg,
                       label: block_cgpMg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpMg: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEn_entry() //  [R1, R3]
         { info_tbl: [(cgpMu,
                       label: sat_sgoEn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpMu: // global
           R2 = P64[R1 + 6];
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEo_entry() //  [R1, R2]
         { info_tbl: [(cgpMB,
                       label: sat_sgoEo_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpMB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpMC; else goto cgpMD;
       cgpMC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpMD: // global
           I64[Sp - 40] = block_cgpLN_info;
           _sgoDJ::P64 = P64[R1 + 7];
           _sgoDK::P64 = P64[R1 + 15];
           _sgoDL::P64 = P64[R1 + 23];
           _sgoE4::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoDJ::P64;
           P64[Sp - 24] = _sgoDK::P64;
           P64[Sp - 16] = _sgoDL::P64;
           P64[Sp - 8] = _sgoE4::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugpMW; else goto cgpLO;
       ugpMW: // global
           call _cgpLN(R1) args: 0, res: 0, upd: 0;
       cgpLO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpLN() //  [R1]
         { info_tbl: [(cgpLN,
                       label: block_cgpLN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLN: // global
           if (R1 & 7 == 6) goto cgpMz; else goto ugpMR;
       cgpMz: // global
           I64[Sp] = block_cgpLT_info;
           R3 = P64[R1 + 2];
           R2 = P64[Sp + 24];
           call Text.Read.Lex.numberToFixed_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ugpMR: // global
           Sp = Sp + 40;
           call _cgpMK() args: 0, res: 0, upd: 0;
     }
 },
 _cgpLT() //  [R1]
         { info_tbl: [(cgpLT,
                       label: block_cgpLT_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLT: // global
           if (R1 & 7 == 1) goto ugpMS; else goto cgpMM;
       ugpMS: // global
           Sp = Sp + 40;
           call _cgpMK() args: 0, res: 0, upd: 0;
       cgpMM: // global
           I64[Sp] = block_cgpLY_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ugpMU; else goto cgpLZ;
       ugpMU: // global
           call _cgpLY(R1) args: 0, res: 0, upd: 0;
       cgpLZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpLY() //  [R1]
         { info_tbl: [(cgpLY,
                       label: block_cgpLY_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpLY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgpMP; else goto cgpMO;
       cgpMP: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpMO: // global
           _sgoEf::P64 = P64[R1 + 7];
           _sgoEg::P64 = P64[R1 + 15];
           I64[Hp - 64] = x_sgoEh_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgoEf::P64;
           P64[Hp - 16] = _sgoEg::P64;
           I64[Hp - 8] = sat_sgoEn_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgpMK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpMK: // global
           R1 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoE8_entry() //  [R1]
         { info_tbl: [(cgpN1,
                       label: sat_sgoE8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpN2; else goto cgpN3;
       cgpN2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpN3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpNf_srtd" {
     ugpNf_srtd:
         const SgoHz_srt+120;
         const 79;
         const 2382685677855703041;
         const 32740;
 },
 Data.Fixed.$fReadFixed1_entry() //  [R2]
         { info_tbl: [(cgpN4,
                       label: Data.Fixed.$fReadFixed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpN4: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgpN8; else goto cgpN7;
       cgpN8: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpN7: // global
           I64[Hp - 136] = lvl17_sgoDK_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = e_sgoDL_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = lvl18_sgoE4_info;
           P64[Hp - 72] = R2;
           _cgpJT::P64 = Hp - 112;
           P64[Hp - 64] = _cgpJT::P64;
           I64[Hp - 56] = sat_sgoEo_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = _cgpJT::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoE8_info;
           P64[Hp] = R2;
           R3 = Hp - 55;
           R2 = Hp - 16;
           R1 = GHC.Read.readNumber1_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.629483207 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadsPrec_closure" {
     Data.Fixed.$fReadFixed_$creadsPrec_closure:
         const Data.Fixed.$fReadFixed_$creadsPrec_info;
         const 0;
 },
 ds_sgoEq_entry() //  [R1]
         { info_tbl: [(cgpNo,
                       label: ds_sgoEq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpNo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpNp; else goto cgpNq;
       cgpNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEs_entry() //  [R1]
         { info_tbl: [(cgpNA,
                       label: sat_sgoEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpNA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpNB; else goto cgpNC;
       cgpNB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpNC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEt_entry() //  [R1, R2]
         { info_tbl: [(cgpND,
                       label: sat_sgoEt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpND: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpNH; else goto cgpNG;
       cgpNH: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpNG: // global
           _sgoEq::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgoEs_info;
           P64[Hp - 8] = _sgoEq::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cgpNI,
                       label: Data.Fixed.$fReadFixed_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpNI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgpNM; else goto cgpNL;
       cgpNM: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpNL: // global
           I64[Hp - 32] = ds_sgoEq_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sgoEt_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.631373483 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadListPrec_closure" {
     Data.Fixed.$fReadFixed_$creadListPrec_closure:
         const Data.Fixed.$fReadFixed_$creadListPrec_info;
         const 0;
 },
 sat_sgoEv_entry() //  [R1]
         { info_tbl: [(cgpNV,
                       label: sat_sgoEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpNV: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cgpNY,
                       label: Data.Fixed.$fReadFixed_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpNY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpO2; else goto cgpO1;
       cgpO2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpO1: // global
           I64[Hp - 16] = sat_sgoEv_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.632782894 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadList_closure" {
     Data.Fixed.$fReadFixed_$creadList_closure:
         const Data.Fixed.$fReadFixed_$creadList_info;
         const 0;
 },
 sat_sgoEx_entry() //  [R1]
         { info_tbl: [(cgpOf,
                       label: sat_sgoEx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOf: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEy_entry() //  [R1]
         { info_tbl: [(cgpOi,
                       label: sat_sgoEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOi: // global
           _sgoEy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgpOj; else goto cgpOk;
       cgpOk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpOm; else goto cgpOl;
       cgpOm: // global
           HpAlloc = 24;
           goto cgpOj;
       cgpOj: // global
           R1 = _sgoEy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpOl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoEy::P64;
           _sgoEw::P64 = P64[_sgoEy::P64 + 16];
           I64[Hp - 16] = sat_sgoEx_info;
           P64[Hp] = _sgoEw::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_$creadList_entry() //  [R2]
         { info_tbl: [(cgpOn,
                       label: Data.Fixed.$fReadFixed_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpOr; else goto cgpOq;
       cgpOr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpOq: // global
           I64[Hp - 16] = sat_sgoEy_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.634798267 UTC

[section ""data" . Data.Fixed.$fReadFixed_closure" {
     Data.Fixed.$fReadFixed_closure:
         const Data.Fixed.$fReadFixed_info;
         const 0;
 },
 sat_sgoED_entry() //  [R1]
         { info_tbl: [(cgpOA,
                       label: sat_sgoED_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpOB; else goto cgpOC;
       cgpOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpOC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEC_entry() //  [R1]
         { info_tbl: [(cgpOH,
                       label: sat_sgoEC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpOI; else goto cgpOJ;
       cgpOI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpOJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEB_entry() //  [R1]
         { info_tbl: [(cgpOO,
                       label: sat_sgoEB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpOP; else goto cgpOQ;
       cgpOP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpOQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEA_entry() //  [R1]
         { info_tbl: [(cgpOV,
                       label: sat_sgoEA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpOW; else goto cgpOX;
       cgpOW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpOX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_entry() //  [R2]
         { info_tbl: [(cgpOZ,
                       label: Data.Fixed.$fReadFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpOZ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgpP3; else goto cgpP2;
       cgpP3: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpP2: // global
           I64[Hp - 128] = sat_sgoED_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgoEC_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgoEB_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoEA_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.636684601 UTC

[section ""data" . Data.Fixed.$fEqFixed_closure" {
     Data.Fixed.$fEqFixed_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.637505564 UTC

[section ""data" . Data.Fixed.$fOrdFixed_closure" {
     Data.Fixed.$fOrdFixed_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Fixed.$fEqFixed_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.638536042 UTC

[section ""data" . Data.Fixed.$fRealFixed_closure" {
     Data.Fixed.$fRealFixed_closure:
         const Data.Fixed.$fRealFixed_info;
         const 0;
 },
 sat_sgoEG_entry() //  [R1, R2]
         { info_tbl: [(cgpPd,
                       label: sat_sgoEG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fRealFixed_$ctoRational_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEF_entry() //  [R1]
         { info_tbl: [(cgpPk,
                       label: sat_sgoEF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpPl; else goto cgpPm;
       cgpPl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpPm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fRealFixed_entry() //  [R2]
         { info_tbl: [(cgpPo,
                       label: Data.Fixed.$fRealFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgpPs; else goto cgpPr;
       cgpPs: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpPr: // global
           I64[Hp - 64] = sat_sgoEG_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sgoEF_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Data.Fixed.$fOrdFixed_closure+1;
           P64[Hp] = Hp - 63;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.640622905 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$ctruncate_closure" {
     Data.Fixed.$fRealFracFixed_$ctruncate_closure:
         const Data.Fixed.$fRealFracFixed_$ctruncate_info;
         const 0;
 },
 sat_sgoEV_entry() //  [R1]
         { info_tbl: [(cgpPM,
                       label: sat_sgoEV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpPN; else goto cgpPO;
       cgpPN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpPO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgpPH_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoEN::P64 = P64[R1 + 24];
           R2 = _sgoEN::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _sgoEN::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpPH() //  [R1]
         { info_tbl: [(cgpPH,
                       label: block_cgpPH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPH: // global
           if (R1 == 1) goto cgpPL; else goto cgpPK;
       cgpPL: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgpPK: // global
           _sgoEN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgpPR_info;
           R3 = _sgoEN::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpPR() //  [R1]
         { info_tbl: [(cgpPR,
                       label: block_cgpPR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPR: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpQf_srtd" {
     ugpQf_srtd:
         const SgoHz_srt+464;
         const 43;
         const 4399120386049;
 },
 Data.Fixed.$fRealFracFixed_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpPY,
                       label: Data.Fixed.$fRealFracFixed_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpQ4; else goto cgpQ5;
       cgpQ4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpQ5: // global
           I64[Sp - 24] = block_cgpPx_info;
           _sgoEH::P64 = R2;
           R2 = R4;
           R1 = _sgoEH::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpPx() //  [R1]
         { info_tbl: [(cgpPx,
                       label: block_cgpPx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPx: // global
           I64[Sp] = block_cgpPB_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpPB() //  [R1, R2]
         { info_tbl: [(cgpPB,
                       label: block_cgpPB_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgpQ9; else goto cgpQ8;
       cgpQ9: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpQ8: // global
           I64[Hp - 24] = sat_sgoEV_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           _sgoEI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpPZ_info;
           R2 = _sgoEI::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpPZ() //  [R1]
         { info_tbl: [(cgpPZ,
                       label: block_cgpPZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpPZ: // global
           I64[Sp] = block_cgpQ3_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpQ3() //  [R1]
         { info_tbl: [(cgpQ3,
                       label: block_cgpQ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQ3: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.64322426 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cround_closure" {
     Data.Fixed.$fRealFracFixed_$cround_closure:
         const Data.Fixed.$fRealFracFixed_$cround_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpQm,
                       label: Data.Fixed.$fRealFracFixed_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpQq; else goto cgpQr;
       cgpQq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpQr: // global
           I64[Sp - 24] = block_cgpQk_info;
           _sgoEW::P64 = R2;
           R2 = R4;
           R1 = _sgoEW::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpQk() //  [R1]
         { info_tbl: [(cgpQk,
                       label: block_cgpQk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQk: // global
           I64[Sp] = block_cgpQp_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpQp() //  [R1, R2]
         { info_tbl: [(cgpQp,
                       label: block_cgpQp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQp: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.644777756 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cceiling_closure" {
     Data.Fixed.$fRealFracFixed_$cceiling_closure:
         const Data.Fixed.$fRealFracFixed_$cceiling_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpQB,
                       label: Data.Fixed.$fRealFracFixed_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpQF; else goto cgpQG;
       cgpQF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpQG: // global
           I64[Sp - 24] = block_cgpQz_info;
           _sgoF3::P64 = R2;
           R2 = R4;
           R1 = _sgoF3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpQz() //  [R1]
         { info_tbl: [(cgpQz,
                       label: block_cgpQz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQz: // global
           I64[Sp] = block_cgpQE_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpQE() //  [R1, R2]
         { info_tbl: [(cgpQE,
                       label: block_cgpQE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQE: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.646390277 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cfloor_closure" {
     Data.Fixed.$fRealFracFixed_$cfloor_closure:
         const Data.Fixed.$fRealFracFixed_$cfloor_info;
         const 0;
 },
 section ""relreadonly" . ugpQZ_srtd" {
     ugpQZ_srtd:
         const SgoHz_srt+472;
         const 49;
         const 334251534843905;
 },
 Data.Fixed.$fRealFracFixed_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpQQ,
                       label: Data.Fixed.$fRealFracFixed_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgpQU; else goto cgpQV;
       cgpQU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpQV: // global
           I64[Sp - 24] = block_cgpQO_info;
           _sgoFa::P64 = R2;
           R2 = R4;
           R1 = _sgoFa::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpR0_srtd" {
     ugpR0_srtd:
         const SgoHz_srt+472;
         const 46;
         const 52776558133249;
 },
 _cgpQO() //  [R1]
         { info_tbl: [(cgpQO,
                       label: block_cgpQO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQO: // global
           I64[Sp] = block_cgpQT_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpQT() //  [R1, R2]
         { info_tbl: [(cgpQT,
                       label: block_cgpQT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpQT: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.650234688 UTC

[section ""data" . Data.Fixed.$w$cproperFraction_closure" {
     Data.Fixed.$w$cproperFraction_closure:
         const Data.Fixed.$w$cproperFraction_info;
         const 0;
 },
 i_sgoFk_entry() //  [R1]
         { info_tbl: [(cgpR9,
                       label: i_sgoFk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpR9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpRa; else goto cgpRb;
       cgpRa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpRb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoFo_entry() //  [R1]
         { info_tbl: [(cgpRi,
                       label: sat_sgoFo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRi: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgpRq; else goto cgpRr;
       cgpRq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpRr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cgpRg_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           _sgoFi::P64 = P64[R1 + 24];
           _sgoFj::P64 = P64[R1 + 32];
           _sgoFk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _sgoFi::P64;
           P64[Sp - 32] = _sgoFj::P64;
           P64[Sp - 24] = _sgoFk::P64;
           Sp = Sp - 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpRg() //  [R1]
         { info_tbl: [(cgpRg,
                       label: block_cgpRg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRg: // global
           _sgoFi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgpRl_info;
           R2 = _sgoFi::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgpRl() //  [R1]
         { info_tbl: [(cgpRl,
                       label: block_cgpRl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRl: // global
           I64[Sp] = block_cgpRp_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpRp() //  [R1]
         { info_tbl: [(cgpRp,
                       label: block_cgpRp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRp: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpRy,
                       label: Data.Fixed.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRy: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgpRC; else goto cgpRB;
       cgpRC: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpRB: // global
           I64[Hp - 80] = i_sgoFk_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgoFo_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           _cgpR5::P64 = Hp - 80;
           P64[Hp] = _cgpR5::P64;
           R2 = Hp - 40;
           R1 = _cgpR5::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.65241073 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cproperFraction_closure" {
     Data.Fixed.$fRealFracFixed_$cproperFraction_closure:
         const Data.Fixed.$fRealFracFixed_$cproperFraction_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cproperFraction_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cgpRK,
                       label: Data.Fixed.$fRealFracFixed_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgpRL; else goto cgpRM;
       cgpRL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpRM: // global
           I64[Sp - 8] = block_cgpRH_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$w$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpRH() //  [R1, R2]
         { info_tbl: [(cgpRH,
                       label: block_cgpRH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpRP; else goto cgpRO;
       cgpRP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpRO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.654628061 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_closure" {
     Data.Fixed.$fRealFracFixed_closure:
         const Data.Fixed.$fRealFracFixed_info;
         const 0;
 },
 sat_sgoFC_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpRZ,
                       label: sat_sgoFC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpRZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cfloor_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFB_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpS7,
                       label: sat_sgoFB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpS7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cceiling_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpSf,
                       label: sat_sgoFA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cround_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFz_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpSn,
                       label: sat_sgoFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSn: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFy_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpSv,
                       label: sat_sgoFy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cproperFraction_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFx_entry() //  [R1]
         { info_tbl: [(cgpSC,
                       label: sat_sgoFx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpSD; else goto cgpSE;
       cgpSD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpSE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fFractionalFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoFw_entry() //  [R1]
         { info_tbl: [(cgpSJ,
                       label: sat_sgoFw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpSK; else goto cgpSL;
       cgpSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpSS_srtd" {
     ugpSS_srtd:
         const SgoHz_srt+656;
         const 33;
         const 6494224385;
 },
 Data.Fixed.$fRealFracFixed_entry() //  [R2]
         { info_tbl: [(cgpSN,
                       label: Data.Fixed.$fRealFracFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSN: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cgpSR; else goto cgpSQ;
       cgpSR: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpSQ: // global
           I64[Hp - 184] = sat_sgoFC_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sgoFB_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgoFA_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgoFz_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgoFy_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgoFx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgoFw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.657366658 UTC

[section ""data" . chopZeros_rgnn4_closure" {
     chopZeros_rgnn4_closure:
         const chopZeros_rgnn4_info;
         const 0;
 },
 section ""relreadonly" . ugpTA_srtd" {
     ugpTA_srtd:
         const SgoHz_srt+120;
         const 103;
         const 576460752303423489;
         const 481036337664;
 },
 chopZeros_rgnn4_entry() //  [R2]
         { info_tbl: [(cgpT2,
                       label: chopZeros_rgnn4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpT3; else goto ugpTw;
       cgpT3: // global
           R2 = R2;
           R1 = chopZeros_rgnn4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ugpTw: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cgpSU() args: 0, res: 0, upd: 0;
     }
 },
 _cgpSU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSU: // global
           I64[Sp - 8] = block_cgpSX_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpTB_srtd" {
     ugpTB_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpSX() //  [R1]
         { info_tbl: [(cgpSX,
                       label: block_cgpSX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpSX: // global
           if (R1 == 1) goto cgpT1; else goto cgpT0;
       cgpT1: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpT0: // global
           I64[Sp] = block_cgpT7_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpTC_srtd" {
     ugpTC_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpT7() //  [R1]
         { info_tbl: [(cgpT7,
                       label: block_cgpT7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpT7: // global
           I64[Sp] = block_cgpTc_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpTD_srtd" {
     ugpTD_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpTc() //  [R1]
         { info_tbl: [(cgpTc,
                       label: block_cgpTc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTc: // global
           _sgoFD::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgpTo; else goto cgpTj;
       cgpTo: // global
           I64[Sp + 8] = block_cgpTm_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = _sgoFD::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cgpTj: // global
           R2 = _sgoFD::P64;
           Sp = Sp + 16;
           call GHC.Show.$fShowInteger_$cshow_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpTE_srtd" {
     ugpTE_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgpTm() //  [R1]
         { info_tbl: [(cgpTm,
                       label: block_cgpTm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTm: // global
           P64[Sp] = R1;
           call _cgpSU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.659205321 UTC

[section ""data" . lvl14_rgoyT_closure" {
     lvl14_rgoyT_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.659758159 UTC

[section ""data" . lvl15_rgoyU_closure" {
     lvl15_rgoyU_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.66031312 UTC

[section ""cstring" . lvl16_rgoyV_bytes" {
     lvl16_rgoyV_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.664584381 UTC

[section ""data" . Data.Fixed.showFixed_closure" {
     Data.Fixed.showFixed_closure:
         const Data.Fixed.showFixed_info;
         const 0;
 },
 n1_sgoGj_entry() //  [R1]
         { info_tbl: [(cgpV6,
                       label: n1_sgoGj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpV6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpV7; else goto cgpV8;
       cgpV7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpV8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgpUZ_info;
           _sgoG5::P64 = P64[R1 + 24];
           _sgoGb::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sgoG5::P64;
           P64[Sp - 24] = _sgoGb::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugpVf; else goto cgpV0;
       ugpVf: // global
           call _cgpUZ(R1) args: 0, res: 0, upd: 0;
       cgpV0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgpUZ() //  [R1]
         { info_tbl: [(cgpUZ,
                       label: block_cgpUZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpUZ: // global
           if (R1 & 7 == 1) goto cgpV3; else goto cgpV4;
       cgpV3: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cgpV4: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call chopZeros_rgnn4_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoGq_entry() //  [R1]
         { info_tbl: [(cgpVu,
                       label: sat_sgoGq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpVu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpVv; else goto cgpVw;
       cgpVv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpVw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sgoGm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sgoGm_entry() //  [R1, R2]
         { info_tbl: [(cgpVA,
                       label: $wxs_sgoGm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpVA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgpVE; else goto cgpVD;
       cgpVE: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpVD: // global
           if (R2 == 1) goto cgpVz; else goto cgpVy;
       cgpVz: // global
           _sgoGl::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sgoGl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpVy: // global
           I64[Hp - 48] = sat_sgoGq_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rgoyT_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpYX_srtd" {
     ugpYX_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 sat_sgoGK_entry() //  [R1]
         { info_tbl: [(cgpVG,
                       label: sat_sgoGK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpVG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpVH; else goto cgpVI;
       cgpVH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpVI: // global
           I64[Sp - 32] = block_cgpU3_info;
           _sgoFM::P64 = P64[R1 + 24];
           R2 = _sgoFM::P64;
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = _sgoFM::P64;
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 32;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpYY_srtd" {
     ugpYY_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgpU3() //  [D1]
         { info_tbl: [(cgpU3,
                       label: block_cgpU3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpU3: // global
           _cgpU8::F64 = D1;
           (_cgpU7::F64) = call MO_F64_Log(_cgpU8::F64);
           I64[Sp - 8] = block_cgpUb_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgpU7::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpYc; else goto cgpUc;
       ugpYc: // global
           call _cgpUb(R1) args: 0, res: 0, upd: 0;
       cgpUc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpYZ_srtd" {
     ugpYZ_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835136;
 },
 _cgpUb() //  [R1]
         { info_tbl: [(cgpUb,
                       label: block_cgpUb_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpUb: // global
           _sgoFQ::P64 = P64[Sp + 32];
           _sgoFZ::F64 = %MO_F_Quot_W64(F64[Sp + 8], F64[R1 + 7]);
           _sgoG0::I64 = %MO_FS_Conv_W64_W64(_sgoFZ::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_sgoG0::I64),
                            _sgoFZ::F64)) goto cgpXX; else goto cgpXW;
       cgpXX: // global
           _sgoG2::I64 = _sgoG0::I64 + 1;
           goto sgoG1;
       cgpXW: // global
           _sgoG2::I64 = _sgoG0::I64;
           goto sgoG1;
       sgoG1: // global
           if (%MO_S_Ge_W64(_sgoG2::I64, 0)) goto cgpXR; else goto cgpXS;
       cgpXR: // global
           if (_sgoG2::I64 == 0) goto cgpXI; else goto cgpXl;
       cgpXI: // global
           I64[Sp + 8] = block_cgpXv_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgoFQ::P64;
           I64[Sp + 32] = _sgoG2::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cgpXl: // global
           I64[Sp] = block_cgpX3_info;
           R3 = _sgoG2::I64;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           I64[Sp + 8] = _sgoG2::I64;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 8, upd: 8;
       cgpXS: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ0_srtd" {
     ugpZ0_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgpXv() //  [R1]
         { info_tbl: [(cgpXv,
                       label: block_cgpXv_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXv: // global
           I64[Sp] = block_cgpXz_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ1_srtd" {
     ugpZ1_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgpXz() //  [R1]
         { info_tbl: [(cgpXz,
                       label: block_cgpXz_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXz: // global
           I64[Sp] = block_cgpXD_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ2_srtd" {
     ugpZ2_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgpXD() //  [R1]
         { info_tbl: [(cgpXD,
                       label: block_cgpXD_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXD: // global
           I64[Sp] = block_cgpXH_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpXH() //  [R1]
         { info_tbl: [(cgpXH,
                       label: block_cgpXH_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXH: // global
           I64[Sp] = I64[Sp + 24];
           P64[Sp + 24] = R1;
           call _sgoG4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ugpZ3_srtd" {
     ugpZ3_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26594437586945;
 },
 _cgpX3() //  [R1]
         { info_tbl: [(cgpX3,
                       label: block_cgpX3_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpX3: // global
           I64[Sp] = block_cgpX7_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ4_srtd" {
     ugpZ4_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgpX7() //  [R1]
         { info_tbl: [(cgpX7,
                       label: block_cgpX7_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpX7: // global
           I64[Sp] = block_cgpXb_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ5_srtd" {
     ugpZ5_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgpXb() //  [R1]
         { info_tbl: [(cgpXb,
                       label: block_cgpXb_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXb: // global
           I64[Sp] = block_cgpXf_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ6_srtd" {
     ugpZ6_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgpXf() //  [R1]
         { info_tbl: [(cgpXf,
                       label: block_cgpXf_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXf: // global
           I64[Sp] = block_cgpXj_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpXj() //  [R1]
         { info_tbl: [(cgpXj,
                       label: block_cgpXj_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpXj: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _sgoG4() args: 0, res: 0, upd: 0;
     }
 },
 _sgoG4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgoG4: // global
           I64[Sp - 8] = block_cgpVM_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugpYl; else goto cgpWF;
       ugpYl: // global
           call _cgpVM(R1) args: 0, res: 0, upd: 0;
       cgpWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpVM() //  [R1]
         { info_tbl: [(cgpVM,
                       label: block_cgpVM_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpVM: // global
           if (R1 & 7 == 1) goto ugpY7; else goto cgpWQ;
       ugpY7: // global
           Sp = Sp + 8;
           call _sgoG6() args: 0, res: 0, upd: 0;
       cgpWQ: // global
           I64[Sp] = block_cgpWO_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpWO() //  [R1]
         { info_tbl: [(cgpWO,
                       label: block_cgpWO_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpWO: // global
           if (R1 == 1) goto ugpY8; else goto ugpY9;
       ugpY8: // global
           Sp = Sp + 40;
           call _cgpX0() args: 0, res: 0, upd: 0;
       ugpY9: // global
           Sp = Sp + 8;
           call _sgoG6() args: 0, res: 0, upd: 0;
     }
 },
 _sgoG6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgoG6: // global
           I64[Sp - 8] = block_cgpUH_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[Sp + 24];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpUH() //  [R1, R2]
         { info_tbl: [(cgpUH,
                       label: block_cgpUH_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpUH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpVR; else goto cgpVQ;
       cgpVR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpVQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           I64[Sp] = block_cgpUK_info;
           R3 = 0;
           _cgpUJ::P64 = Hp - 14;
           R2 = _cgpUJ::P64;
           P64[Sp + 24] = _cgpUJ::P64;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpUK() //  [R1]
         { info_tbl: [(cgpUK,
                       label: block_cgpUK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpUK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgpVU; else goto cgpVT;
       cgpVU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpVT: // global
           _sgoFJ::P64 = P64[Sp + 16];
           _sgoGd::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sgoGd::I64)) goto cgpVX; else goto cgpWr;
       cgpVX: // global
           Hp = Hp - 80;
           I64[Sp + 16] = block_cgpVV_info;
           R1 = _sgoFJ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ugpYd; else goto cgpVY;
       ugpYd: // global
           call _cgpVV(R1) args: 0, res: 0, upd: 0;
       cgpVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cgpWr: // global
           I64[Hp - 72] = n1_sgoGj_info;
           P64[Hp - 56] = _sgoFJ::P64;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = lvl14_rgoyT_closure+1;
           P64[Hp - 16] = Hp - 72;
           I64[Hp - 8] = $wxs_sgoGm_info;
           P64[Hp] = Hp - 30;
           I64[Sp + 32] = block_cgpWq_info;
           R2 = _sgoGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call $wxs_sgoGm_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgpVV() //  [R1]
         { info_tbl: [(cgpVV,
                       label: block_cgpVV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpVV: // global
           if (R1 & 7 == 1) goto cgpW4; else goto cgpWc;
       cgpW4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpW7; else goto cgpW6;
       cgpW7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpW6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgpWc: // global
           _sgoG5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgpWa_info;
           R2 = _sgoG5::P64;
           Sp = Sp + 16;
           call chopZeros_rgnn4_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpWa() //  [R1]
         { info_tbl: [(cgpWa,
                       label: block_cgpWa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpWa: // global
           if (R1 & 7 == 1) goto ugpYa; else goto cgpWm;
       ugpYa: // global
           Sp = Sp + 8;
           call _cgpX0() args: 0, res: 0, upd: 0;
       cgpWm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpWp; else goto cgpWo;
       cgpWp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpWo: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgpWq() //  [R1]
         { info_tbl: [(cgpWq,
                       label: block_cgpWq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpWq: // global
           if (R1 & 7 == 1) goto ugpYb; else goto cgpWB;
       ugpYb: // global
           Sp = Sp + 8;
           call _cgpX0() args: 0, res: 0, upd: 0;
       cgpWB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpWE; else goto cgpWD;
       cgpWE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgpWD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgpX0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpX0: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoGN_entry() //  [R1]
         { info_tbl: [(cgpYu,
                       label: sat_sgoGN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpYu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgpYv; else goto cgpYw;
       cgpYv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgpYw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgpYs_info;
           R2 = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgpYs() //  [R1]
         { info_tbl: [(cgpYs,
                       label: block_cgpYs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpYs: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugpZ7_srtd" {
     ugpZ7_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 Data.Fixed.showFixed_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpYD,
                       label: Data.Fixed.showFixed_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpYD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgpYE; else goto cgpYF;
       cgpYE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.showFixed_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpYF: // global
           I64[Sp - 32] = block_cgpTJ_info;
           _sgoFJ::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoFI::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgoFI::P64;
           P64[Sp - 16] = _sgoFJ::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ8_srtd" {
     ugpZ8_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 _cgpTJ() //  [R1]
         { info_tbl: [(cgpTJ,
                       label: block_cgpTJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTJ: // global
           _sgoFI::P64 = P64[Sp + 8];
           _sgoFK::P64 = P64[Sp + 24];
           if (R1 == 1) goto cgpYC; else goto cgpYB;
       cgpYC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgpYW; else goto cgpYV;
       cgpYW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgpYV: // global
           I64[Hp - 32] = sat_sgoGN_info;
           P64[Hp - 16] = _sgoFI::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgoFK::P64;
           R3 = Hp - 32;
           R2 = lvl16_rgoyV_bytes;
           Sp = Sp + 32;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cgpYB: // global
           I64[Sp + 8] = block_cgpTN_info;
           R2 = _sgoFK::P64;
           R1 = _sgoFI::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZ9_srtd" {
     ugpZ9_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgpTN() //  [R1]
         { info_tbl: [(cgpTN,
                       label: block_cgpTN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTN: // global
           I64[Sp - 8] = block_cgpTR_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZa_srtd" {
     ugpZa_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgpTR() //  [R1]
         { info_tbl: [(cgpTR,
                       label: block_cgpTR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTR: // global
           if (R1 == 1) goto cgpYT; else goto cgpYL;
       cgpYT: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgpYL: // global
           I64[Sp] = block_cgpTV_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZb_srtd" {
     ugpZb_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgpTV() //  [R1, R2]
         { info_tbl: [(cgpTV,
                       label: block_cgpTV_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTV: // global
           I64[Sp] = block_cgpTX_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           _sgoFQ::P64 = R2;
           R2 = 0;
           P64[Sp + 24] = _sgoFQ::P64;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugpZc_srtd" {
     ugpZc_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgpTX() //  [R1, R2]
         { info_tbl: [(cgpTX,
                       label: block_cgpTX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpTX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgpYP; else goto cgpYO;
       cgpYP: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgpYO: // global
           I64[Hp - 56] = sat_sgoGK_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 56;
           R2 = Hp - 14;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.674030426 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshow_closure" {
     Data.Fixed.$fShowFixed_$cshow_closure:
         const Data.Fixed.$fShowFixed_$cshow_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cgpZh,
                       label: Data.Fixed.$fShowFixed_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpZh: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.675031981 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowsPrec_closure" {
     Data.Fixed.$fShowFixed_$cshowsPrec_closure:
         const Data.Fixed.$fShowFixed_$cshowsPrec_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgpZq,
                       label: Data.Fixed.$fShowFixed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpZq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpZr; else goto cgpZs;
       cgpZr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpZs: // global
           I64[Sp - 16] = block_cgpZo_info;
           R4 = R4;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpZo() //  [R1]
         { info_tbl: [(cgpZo,
                       label: block_cgpZo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpZo: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.676500997 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowList_closure" {
     Data.Fixed.$fShowFixed_$cshowList_closure:
         const Data.Fixed.$fShowFixed_$cshowList_info;
         const 0;
 },
 sat_sgoH0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgpZH,
                       label: sat_sgoH0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpZH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgpZI; else goto cgpZJ;
       cgpZI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpZJ: // global
           I64[Sp - 16] = block_cgpZF_info;
           R4 = R2;
           _sgoGY::P64 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sgoGY::P64;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgpZF() //  [R1]
         { info_tbl: [(cgpZF,
                       label: block_cgpZF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpZF: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cgpZN,
                       label: Data.Fixed.$fShowFixed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpZN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgpZR; else goto cgpZQ;
       cgpZR: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgpZQ: // global
           I64[Hp - 8] = sat_sgoH0_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.678375944 UTC

[section ""data" . Data.Fixed.$fShowFixed_closure" {
     Data.Fixed.$fShowFixed_closure:
         const Data.Fixed.$fShowFixed_info;
         const 0;
 },
 sat_sgoH4_entry() //  [R1, R2, R3]
         { info_tbl: [(cgq01,
                       label: sat_sgoH4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq01: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fShowFixed_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoH3_entry() //  [R1, R2]
         { info_tbl: [(cgq09,
                       label: sat_sgoH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq09: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fShowFixed_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoH2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgq0h,
                       label: sat_sgoH2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq0h: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fShowFixed_$cshowsPrec_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_entry() //  [R2]
         { info_tbl: [(cgq0l,
                       label: Data.Fixed.$fShowFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq0l: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgq0p; else goto cgq0o;
       cgq0p: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgq0o: // global
           I64[Hp - 72] = sat_sgoH4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoH3_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgoH2_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.679780477 UTC

[section ""relreadonly" . SgoHz_srt" {
     SgoHz_srt:
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const sat_sgozk_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
         const Data.Fixed.$fEnumFixed3_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const Data.Fixed.$fHasResolutionE0_$cresolution_closure;
         const sat_sgozK_closure;
         const Data.Fixed.$fHasResolutionE4_closure;
         const Data.Fixed.$fHasResolutionE1_$cresolution_closure;
         const sat_sgozN_closure;
         const Data.Fixed.$fHasResolutionE7_closure;
         const Data.Fixed.$fHasResolutionE2_$cresolution_closure;
         const sat_sgozQ_closure;
         const Data.Fixed.$fHasResolutionE8_closure;
         const Data.Fixed.$fHasResolutionE3_$cresolution_closure;
         const sat_sgozT_closure;
         const Data.Fixed.$fHasResolutionE10_closure;
         const Data.Fixed.$fHasResolutionE6_$cresolution_closure;
         const sat_sgozW_closure;
         const Data.Fixed.$fHasResolutionE11_closure;
         const Data.Fixed.$fHasResolutionE9_$cresolution_closure;
         const sat_sgoA1_closure;
         const Data.Fixed.$fHasResolutionE5_closure;
         const Data.Fixed.$fHasResolutionE12_$cresolution_closure;
         const GHC.List.badHead_closure;
         const w2_rgoyl_closure;
         const go61_rgoym_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Fixed.$fDataFixed4_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Fixed.$fDataFixed8_closure;
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$w$cgmapMp_closure;
         const Data.Fixed.$w$cgmapM_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Fixed.$fDataFixed_$cgmapQi_closure;
         const Data.Fixed.$w$cgmapMo_closure;
         const Data.Fixed.conMkFixed_closure;
         const Data.Fixed.tyFixed_closure;
         const lvl5_rgoyK_closure;
         const lvl6_rgoyL_closure;
         const lvl7_rgoyM_closure;
         const lvl8_rgoyN_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const Data.Fixed.$fDataFixed7_closure;
         const Data.Fixed.$fDataFixed_closure;
         const lvl_rgoyF_closure;
         const lvl1_rgoyG_closure;
         const lvl4_rgoyJ_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.div'_closure;
         const Data.Fixed.$wdivMod'_closure;
         const Data.Fixed.divMod'_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Data.Fixed.mod'_closure;
         const GHC.Err.undefined_closure;
         const $dIP3_rgoyz_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Fixed.$w$cfromRational_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const Data.Fixed.$fFractionalFixed1_closure;
         const Data.Fixed.$fRealFixed_$ctoRational_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const Data.Fixed.$fFractionalFixed3_closure;
         const Data.Fixed.$fFractionalFixed_$crecip_closure;
         const Data.Fixed.$fNumFixed_$c*_closure;
         const Data.Fixed.$fNumFixed1_closure;
         const Data.Fixed.$fNumFixed2_closure;
         const Data.Fixed.$fNumFixed_closure;
         const Data.Fixed.$fFractionalFixed_closure;
         const lvl13_rgoyS_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const Data.Fixed.$fReadFixed2_closure;
         const Data.Fixed.$fReadFixed3_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const GHC.Real.^_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Text.Read.Lex.numberToFixed_closure;
         const GHC.Read.readNumber1_closure;
         const Data.Fixed.$fReadFixed1_closure;
         const Data.Fixed.$fReadFixed_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Fixed.$fReadFixed_$creadListPrec_closure;
         const Data.Fixed.$fReadFixed_$creadList_closure;
         const Data.Fixed.$fReadFixed_closure;
         const Data.Fixed.$fRealFixed_closure;
         const Data.Fixed.$fRealFracFixed_$ctruncate_closure;
         const GHC.Real.$w$s$cround_closure;
         const Data.Fixed.$fRealFracFixed_$cround_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cfloor_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$w$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Show.$fShowInteger_$cshow_closure;
         const chopZeros_rgnn4_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$wf_closure;
         const Data.Fixed.showFixed_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const Data.Fixed.$fShowFixed_$cshowsPrec_closure;
         const Data.Fixed.$fShowFixed_$cshowList_closure;
         const Data.Fixed.$fShowFixed_$cshow_closure;
         const Data.Fixed.$fShowFixed_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.681330849 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:18.682586008 UTC

[section ""data" . Data.Fixed.resolution_closure" {
     Data.Fixed.resolution_closure:
         const Data.Fixed.resolution_info;
 },
 Data.Fixed.resolution_entry() //  [R2]
         { info_tbl: [(cgq0u,
                       label: Data.Fixed.resolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq0u: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.686244586 UTC

[section ""data" . Data.Fixed.$fDataFixed2_closure" {
     Data.Fixed.$fDataFixed2_closure:
         const Data.Fixed.$fDataFixed2_info;
 },
 Data.Fixed.$fDataFixed2_entry() //  [R2]
         { info_tbl: [(cgq0F,
                       label: Data.Fixed.$fDataFixed2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq0F: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.689912052 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgfoldl_closure" {
     Data.Fixed.$fDataFixed_$cgfoldl_closure:
         const Data.Fixed.$fDataFixed_$cgfoldl_info;
         const 0;
 },
 sat_sgoz3_entry() //  [R1]
         { info_tbl: [(cgq0W,
                       label: sat_sgoz3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq0W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq0X; else goto cgq0Y;
       cgq0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_$cgfoldl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgq0Z,
                       label: Data.Fixed.$fDataFixed_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq0Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgq13; else goto cgq12;
       cgq13: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgfoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgq12: // global
           I64[Hp - 16] = sat_sgoz3_info;
           P64[Hp] = R4;
           R4 = R5;
           _sgoz0::P64 = R3;
           R3 = Hp - 16;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoz0::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.696157132 UTC

[section ""data" . Data.Fixed.$fEnumFixed1_closure" {
     Data.Fixed.$fEnumFixed1_closure:
         const Data.Fixed.$fEnumFixed1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed1_entry() //  [R1]
         { info_tbl: [(cgq1i,
                       label: Data.Fixed.$fEnumFixed1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq1i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq1j; else goto cgq1k;
       cgq1j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq1k: // global
           (_cgq1f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgq1f::I64 == 0) goto cgq1h; else goto cgq1g;
       cgq1h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgq1g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgq1f::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.703330915 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_info;
         const 0;
 },
 sat_sgozd_entry() //  [R1]
         { info_tbl: [(cgq1T,
                       label: sat_sgozd_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq1T: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq1U; else goto cgq1V;
       cgq1U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq1V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgq1R_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgq1R() //  [R1]
         { info_tbl: [(cgq1R,
                       label: block_cgq1R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq1R: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgoz9_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgoz9_entry() //  [R1, R2]
         { info_tbl: [(cgq22,
                       label: go_sgoz9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq22: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq23; else goto cgq24;
       cgq23: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgq24: // global
           I64[Sp - 32] = block_cgq1J_info;
           R3 = P64[R1 + 7];
           _sgoza::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgoza::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgq1J() //  [R1]
         { info_tbl: [(cgq1J,
                       label: block_cgq1J_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq1J: // global
           if (R1 == 1) goto cgq21; else goto cgq20;
       cgq21: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgq20: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgq28; else goto cgq27;
       cgq28: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgq27: // global
           I64[Hp - 56] = sat_sgozd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgoza::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgoza::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgoza::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgozi_entry() //  [R1]
         { info_tbl: [(cgq2t,
                       label: sat_sgozi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq2t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq2u; else goto cgq2v;
       cgq2u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq2v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgq2r_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgq2r() //  [R1]
         { info_tbl: [(cgq2r,
                       label: block_cgq2r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq2r: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgoze_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgoze_entry() //  [R1, R2]
         { info_tbl: [(cgq2C,
                       label: go_sgoze_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq2C: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq2D; else goto cgq2E;
       cgq2D: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgq2E: // global
           I64[Sp - 32] = block_cgq2j_info;
           R3 = P64[R1 + 7];
           _sgozf::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgozf::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgq2j() //  [R1]
         { info_tbl: [(cgq2j,
                       label: block_cgq2j_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq2j: // global
           if (R1 == 1) goto cgq2B; else goto cgq2A;
       cgq2B: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgq2A: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgq2I; else goto cgq2H;
       cgq2I: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgq2H: // global
           I64[Hp - 56] = sat_sgozi_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgozf::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgozf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgozf::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgq2M,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq2M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq2N; else goto cgq2O;
       cgq2N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgq2O: // global
           I64[Sp - 24] = block_cgq1w_info;
           _sgoz5::P64 = R3;
           R3 = R2;
           _sgoz4::P64 = R2;
           R2 = _sgoz5::P64;
           P64[Sp - 16] = _sgoz4::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgq1w() //  [R1]
         { info_tbl: [(cgq1w,
                       label: block_cgq1w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq1w: // global
           I64[Sp - 8] = block_cgq1A_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgq1A() //  [R1]
         { info_tbl: [(cgq1A,
                       label: block_cgq1A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq1A: // global
           _sgoz4::P64 = P64[Sp + 16];
           _sgoz6::P64 = P64[Sp + 24];
           _sgoz7::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgq2V; else goto cgq2R;
       cgq2V: // global
           Hp = Hp + 24;
           _sgoz8::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgq2Y; else goto cgq2X;
       cgq2X: // global
           I64[Hp - 16] = go_sgoze_info;
           P64[Hp - 8] = _sgoz6::P64;
           P64[Hp] = _sgoz7::P64;
           R2 = _sgoz4::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgoze_entry(R2, R1) args: 8, res: 0, upd: 8;
       cgq2R: // global
           Hp = Hp + 24;
           _sgoz8::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgq2Y; else goto cgq2T;
       cgq2Y: // global
           HpAlloc = 24;
           R1 = _sgoz8::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgq2T: // global
           I64[Hp - 16] = go_sgoz9_info;
           P64[Hp - 8] = _sgoz6::P64;
           P64[Hp] = _sgoz7::P64;
           R2 = _sgoz4::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgoz9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.727086719 UTC

[section ""data" . sat_sgozj_closure" {
     sat_sgozj_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.728889018 UTC

[section ""data" . sat_sgozk_closure" {
     sat_sgozk_closure:
         const :_con_info;
         const sat_sgozj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.731127103 UTC

[section ""data" . Data.Fixed.$fEnumFixed2_closure" {
     Data.Fixed.$fEnumFixed2_closure:
         const Data.Fixed.$fEnumFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed2_entry() //  [R1]
         { info_tbl: [(cgq3Y,
                       label: Data.Fixed.$fEnumFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq3Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq3Z; else goto cgq40;
       cgq3Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq40: // global
           (_cgq3V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgq3V::I64 == 0) goto cgq3X; else goto cgq3W;
       cgq3X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgq3W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgq3V::I64;
           R3 = sat_sgozk_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.736026701 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromTo_info;
         const 0;
 },
 sat_sgozr_entry() //  [R1]
         { info_tbl: [(cgq4r,
                       label: sat_sgozr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq4r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq4s; else goto cgq4t;
       cgq4s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq4t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgq4p_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgq4p() //  [R1]
         { info_tbl: [(cgq4p,
                       label: block_cgq4p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq4p: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgozn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgozn_entry() //  [R1, R2]
         { info_tbl: [(cgq4A,
                       label: go_sgozn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq4A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgq4B; else goto cgq4C;
       cgq4B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgq4C: // global
           I64[Sp - 24] = block_cgq4h_info;
           R3 = P64[R1 + 7];
           _sgozo::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgozo::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgq4h() //  [R1]
         { info_tbl: [(cgq4h,
                       label: block_cgq4h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq4h: // global
           if (R1 == 1) goto cgq4z; else goto cgq4y;
       cgq4z: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgq4y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgq4G; else goto cgq4F;
       cgq4G: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgq4F: // global
           I64[Hp - 48] = sat_sgozr_info;
           P64[Hp - 32] = P64[Sp + 8];
           _sgozo::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sgozo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgozo::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(cgq4K,
                       label: Data.Fixed.$fEnumFixed_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgq4O; else goto cgq4N;
       cgq4O: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgq4N: // global
           I64[Hp - 8] = go_sgozn_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgozn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.749745036 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThen_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThen_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThen_info;
         const 0;
 },
 d_sgozu_entry() //  [R1]
         { info_tbl: [(cgq5k,
                       label: d_sgozu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq5k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq5l; else goto cgq5m;
       cgq5l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq5m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgozz_entry() //  [R1]
         { info_tbl: [(cgq5D,
                       label: sat_sgozz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq5D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgq5E; else goto cgq5F;
       cgq5E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq5F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgq5B_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgq5B() //  [R1]
         { info_tbl: [(cgq5B,
                       label: block_cgq5B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq5B: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgozv_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgozv_entry() //  [R1, R2]
         { info_tbl: [(cgq5J,
                       label: go_sgozv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq5J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgq5L; else goto cgq5M;
       cgq5L: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgq5M: // global
           I64[Sp - 24] = block_cgq5s_info;
           _sgozv::P64 = R1;
           _sgozu::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgozu::P64;
           P64[Sp - 8] = _sgozv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugq5Q; else goto cgq5t;
       ugq5Q: // global
           call _cgq5s(R1) args: 0, res: 0, upd: 0;
       cgq5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgq5s() //  [R1]
         { info_tbl: [(cgq5s,
                       label: block_cgq5s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq5s: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgq5P; else goto cgq5O;
       cgq5P: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgq5O: // global
           I64[Hp - 56] = sat_sgozz_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(cgq5R,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq5R: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgq5V; else goto cgq5U;
       cgq5V: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgq5U: // global
           I64[Hp - 40] = d_sgozu_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = go_sgozv_info;
           P64[Hp] = Hp - 40;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgozv_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.763317866 UTC

[section ""data" . Data.Fixed.$fEnumFixed3_closure" {
     Data.Fixed.$fEnumFixed3_closure:
         const Data.Fixed.$fEnumFixed3_info;
         const 0;
 },
 sat_sgozD_entry() //  [R1]
         { info_tbl: [(cgq6E,
                       label: sat_sgozD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq6E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgq6F; else goto cgq6G;
       cgq6F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq6G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgq6C_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgq6C() //  [R1]
         { info_tbl: [(cgq6C,
                       label: block_cgq6C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq6C: // global
           R2 = R1;
           Sp = Sp + 8;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fEnumFixed3_entry() //  [R2]
         { info_tbl: [(cgq6K,
                       label: Data.Fixed.$fEnumFixed3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq6K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgq6M; else goto cgq6N;
       cgq6M: // global
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgq6N: // global
           I64[Sp - 8] = block_cgq6t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugq6R; else goto cgq6u;
       ugq6R: // global
           call _cgq6t(R1) args: 0, res: 0, upd: 0;
       cgq6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgq6t() //  [R1]
         { info_tbl: [(cgq6t,
                       label: block_cgq6t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq6t: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgq6Q; else goto cgq6P;
       cgq6Q: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgq6P: // global
           I64[Hp - 40] = sat_sgozD_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.772662571 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFrom_closure" {
     Data.Fixed.$fEnumFixed_$cenumFrom_closure:
         const Data.Fixed.$fEnumFixed_$cenumFrom_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed_$cenumFrom_entry() //  [R2]
         { info_tbl: [(cgq7e,
                       label: Data.Fixed.$fEnumFixed_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq7e: // global
           R2 = R2;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.776032152 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cfromEnum_closure" {
     Data.Fixed.$fEnumFixed_$cfromEnum_closure:
         const Data.Fixed.$fEnumFixed_$cfromEnum_info;
 },
 Data.Fixed.$fEnumFixed_$cfromEnum_entry() //  [R2]
         { info_tbl: [(cgq7p,
                       label: Data.Fixed.$fEnumFixed_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq7p: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.780156816 UTC

[section ""data" . Data.Fixed.$fEnumFixed4_closure" {
     Data.Fixed.$fEnumFixed4_closure:
         const Data.Fixed.$fEnumFixed4_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed4_entry() //  [R2]
         { info_tbl: [(cgq7A,
                       label: Data.Fixed.$fEnumFixed4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq7A: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.783380481 UTC

[section ""data" . Data.Fixed.$fEnumFixed5_closure" {
     Data.Fixed.$fEnumFixed5_closure:
         const Data.Fixed.$fEnumFixed5_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed5_entry() //  [R2]
         { info_tbl: [(cgq7L,
                       label: Data.Fixed.$fEnumFixed5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq7L: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.786863252 UTC

[section ""data" . Data.Fixed.$fEnumFixed_closure" {
     Data.Fixed.$fEnumFixed_closure:
         const GHC.Enum.C:Enum_con_info;
         const Data.Fixed.$fEnumFixed5_closure+1;
         const Data.Fixed.$fEnumFixed4_closure+1;
         const GHC.Enum.$fEnumInteger_$ctoEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cfromEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFrom_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.78888306 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE0_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE0_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_$cresolution_entry() //  []
         { info_tbl: [(cgq7X,
                       label: Data.Fixed.$fHasResolutionE0_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq7X: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.792242193 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_closure" {
     Data.Fixed.$fHasResolutionE0_closure:
         const Data.Fixed.$fHasResolutionE0_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_entry() //  [R2]
         { info_tbl: [(cgq89,
                       label: Data.Fixed.$fHasResolutionE0_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq89: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE0_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.795405569 UTC

[section ""data" . sat_sgozJ_closure" {
     sat_sgozJ_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.797038791 UTC

[section ""data" . sat_sgozK_closure" {
     sat_sgozK_closure:
         const :_con_info;
         const sat_sgozJ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.799045495 UTC

[section ""data" . Data.Fixed.$fHasResolutionE4_closure" {
     Data.Fixed.$fHasResolutionE4_closure:
         const Data.Fixed.$fHasResolutionE4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE4_entry() //  [R1]
         { info_tbl: [(cgq8o,
                       label: Data.Fixed.$fHasResolutionE4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq8o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq8p; else goto cgq8q;
       cgq8p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq8q: // global
           (_cgq8l::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgq8l::I64 == 0) goto cgq8n; else goto cgq8m;
       cgq8n: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgq8m: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgq8l::I64;
           R3 = sat_sgozK_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.803445343 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE1_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE1_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_$cresolution_entry() //  []
         { info_tbl: [(cgq8C,
                       label: Data.Fixed.$fHasResolutionE1_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq8C: // global
           R1 = Data.Fixed.$fHasResolutionE4_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.807416319 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_closure" {
     Data.Fixed.$fHasResolutionE1_closure:
         const Data.Fixed.$fHasResolutionE1_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_entry() //  [R2]
         { info_tbl: [(cgq8O,
                       label: Data.Fixed.$fHasResolutionE1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq8O: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE1_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.811262763 UTC

[section ""data" . sat_sgozM_closure" {
     sat_sgozM_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.813192823 UTC

[section ""data" . sat_sgozN_closure" {
     sat_sgozN_closure:
         const :_con_info;
         const sat_sgozM_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.815508728 UTC

[section ""data" . Data.Fixed.$fHasResolutionE7_closure" {
     Data.Fixed.$fHasResolutionE7_closure:
         const Data.Fixed.$fHasResolutionE7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE7_entry() //  [R1]
         { info_tbl: [(cgq93,
                       label: Data.Fixed.$fHasResolutionE7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq93: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq94; else goto cgq95;
       cgq94: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq95: // global
           (_cgq90::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgq90::I64 == 0) goto cgq92; else goto cgq91;
       cgq92: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgq91: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgq90::I64;
           R3 = sat_sgozN_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.820130167 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE2_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE2_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_$cresolution_entry() //  []
         { info_tbl: [(cgq9h,
                       label: Data.Fixed.$fHasResolutionE2_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq9h: // global
           R1 = Data.Fixed.$fHasResolutionE7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.82390391 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_closure" {
     Data.Fixed.$fHasResolutionE2_closure:
         const Data.Fixed.$fHasResolutionE2_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_entry() //  [R2]
         { info_tbl: [(cgq9t,
                       label: Data.Fixed.$fHasResolutionE2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq9t: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE2_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.827417307 UTC

[section ""data" . sat_sgozP_closure" {
     sat_sgozP_closure:
         const GHC.Types.I#_con_info;
         const 1000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.829404028 UTC

[section ""data" . sat_sgozQ_closure" {
     sat_sgozQ_closure:
         const :_con_info;
         const sat_sgozP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.831397389 UTC

[section ""data" . Data.Fixed.$fHasResolutionE8_closure" {
     Data.Fixed.$fHasResolutionE8_closure:
         const Data.Fixed.$fHasResolutionE8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE8_entry() //  [R1]
         { info_tbl: [(cgq9I,
                       label: Data.Fixed.$fHasResolutionE8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq9I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgq9J; else goto cgq9K;
       cgq9J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgq9K: // global
           (_cgq9F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgq9F::I64 == 0) goto cgq9H; else goto cgq9G;
       cgq9H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgq9G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgq9F::I64;
           R3 = sat_sgozQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.835546846 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE3_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE3_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_$cresolution_entry() //  []
         { info_tbl: [(cgq9W,
                       label: Data.Fixed.$fHasResolutionE3_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgq9W: // global
           R1 = Data.Fixed.$fHasResolutionE8_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.839456305 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_closure" {
     Data.Fixed.$fHasResolutionE3_closure:
         const Data.Fixed.$fHasResolutionE3_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_entry() //  [R2]
         { info_tbl: [(cgqa8,
                       label: Data.Fixed.$fHasResolutionE3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqa8: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE3_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.843250032 UTC

[section ""data" . sat_sgozS_closure" {
     sat_sgozS_closure:
         const GHC.Types.I#_con_info;
         const 1000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.845562601 UTC

[section ""data" . sat_sgozT_closure" {
     sat_sgozT_closure:
         const :_con_info;
         const sat_sgozS_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.847735588 UTC

[section ""data" . Data.Fixed.$fHasResolutionE10_closure" {
     Data.Fixed.$fHasResolutionE10_closure:
         const Data.Fixed.$fHasResolutionE10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE10_entry() //  [R1]
         { info_tbl: [(cgqan,
                       label: Data.Fixed.$fHasResolutionE10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqan: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqao; else goto cgqap;
       cgqao: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqap: // global
           (_cgqak::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqak::I64 == 0) goto cgqam; else goto cgqal;
       cgqam: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqal: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqak::I64;
           R3 = sat_sgozT_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.852446445 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE6_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE6_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_$cresolution_entry() //  []
         { info_tbl: [(cgqaB,
                       label: Data.Fixed.$fHasResolutionE6_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqaB: // global
           R1 = Data.Fixed.$fHasResolutionE10_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.856362313 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_closure" {
     Data.Fixed.$fHasResolutionE6_closure:
         const Data.Fixed.$fHasResolutionE6_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_entry() //  [R2]
         { info_tbl: [(cgqaN,
                       label: Data.Fixed.$fHasResolutionE6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqaN: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE6_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.859939462 UTC

[section ""data" . sat_sgozV_closure" {
     sat_sgozV_closure:
         const GHC.Types.I#_con_info;
         const 1000000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.861782303 UTC

[section ""data" . sat_sgozW_closure" {
     sat_sgozW_closure:
         const :_con_info;
         const sat_sgozV_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.864131865 UTC

[section ""data" . Data.Fixed.$fHasResolutionE11_closure" {
     Data.Fixed.$fHasResolutionE11_closure:
         const Data.Fixed.$fHasResolutionE11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE11_entry() //  [R1]
         { info_tbl: [(cgqb2,
                       label: Data.Fixed.$fHasResolutionE11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqb3; else goto cgqb4;
       cgqb3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqb4: // global
           (_cgqaZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqaZ::I64 == 0) goto cgqb1; else goto cgqb0;
       cgqb1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqb0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqaZ::I64;
           R3 = sat_sgozW_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.869139094 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE9_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE9_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_$cresolution_entry() //  []
         { info_tbl: [(cgqbg,
                       label: Data.Fixed.$fHasResolutionE9_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqbg: // global
           R1 = Data.Fixed.$fHasResolutionE11_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.873058419 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_closure" {
     Data.Fixed.$fHasResolutionE9_closure:
         const Data.Fixed.$fHasResolutionE9_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_entry() //  [R2]
         { info_tbl: [(cgqbs,
                       label: Data.Fixed.$fHasResolutionE9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqbs: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE9_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.877679765 UTC

[section ""data" . sat_sgozZ_closure" {
     sat_sgozZ_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.879654123 UTC

[section ""data" . sat_sgoA0_closure" {
     sat_sgoA0_closure:
         const :_con_info;
         const sat_sgozZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.881706495 UTC

[section ""data" . sat_sgozY_closure" {
     sat_sgozY_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.883542409 UTC

[section ""data" . sat_sgoA1_closure" {
     sat_sgoA1_closure:
         const :_con_info;
         const sat_sgozY_closure+1;
         const sat_sgoA0_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.885868569 UTC

[section ""data" . Data.Fixed.$fHasResolutionE5_closure" {
     Data.Fixed.$fHasResolutionE5_closure:
         const Data.Fixed.$fHasResolutionE5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE5_entry() //  [R1]
         { info_tbl: [(cgqbJ,
                       label: Data.Fixed.$fHasResolutionE5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqbJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqbK; else goto cgqbL;
       cgqbK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqbL: // global
           (_cgqbG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqbG::I64 == 0) goto cgqbI; else goto cgqbH;
       cgqbI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqbH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqbG::I64;
           R3 = sat_sgoA1_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.890553194 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE12_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE12_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_$cresolution_entry() //  []
         { info_tbl: [(cgqbX,
                       label: Data.Fixed.$fHasResolutionE12_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqbX: // global
           R1 = Data.Fixed.$fHasResolutionE5_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.894764691 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_closure" {
     Data.Fixed.$fHasResolutionE12_closure:
         const Data.Fixed.$fHasResolutionE12_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_entry() //  [R2]
         { info_tbl: [(cgqc9,
                       label: Data.Fixed.$fHasResolutionE12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqc9: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE12_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.898620037 UTC

[section ""cstring" . Data.Fixed.$fDataFixed6_bytes" {
     Data.Fixed.$fDataFixed6_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.90095326 UTC

[section ""data" . Data.Fixed.$fDataFixed5_closure" {
     Data.Fixed.$fDataFixed5_closure:
         const Data.Fixed.$fDataFixed5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed5_entry() //  [R1]
         { info_tbl: [(cgqcn,
                       label: Data.Fixed.$fDataFixed5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqcn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqco; else goto cgqcp;
       cgqco: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqcp: // global
           (_cgqck::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqck::I64 == 0) goto cgqcm; else goto cgqcl;
       cgqcm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqcl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqck::I64;
           R2 = Data.Fixed.$fDataFixed6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.905395723 UTC

[section ""cstring" . w1_rgoyk_bytes" {
     w1_rgoyk_bytes:
         I8[] [77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.907357402 UTC

[section ""data" . w2_rgoyl_closure" {
     w2_rgoyl_closure:
         const w2_rgoyl_info;
         const 0;
         const 0;
         const 0;
 },
 w2_rgoyl_entry() //  [R1]
         { info_tbl: [(cgqcE,
                       label: w2_rgoyl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqcF; else goto cgqcG;
       cgqcF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqcG: // global
           (_cgqcB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqcB::I64 == 0) goto cgqcD; else goto cgqcC;
       cgqcD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqcC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqcB::I64;
           R2 = w1_rgoyk_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.91305506 UTC

[section ""data" . go61_rgoym_closure" {
     go61_rgoym_closure:
         const go61_rgoym_info;
         const 0;
 },
 go61_rgoym_entry() //  [R2, R3]
         { info_tbl: [(cgqcZ,
                       label: go61_rgoym_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqcZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqd0; else goto ugqdD;
       cgqd0: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgoym_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugqdD: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgqcP() args: 0, res: 0, upd: 0;
     }
 },
 _cgqcP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqcP: // global
           _sgoA3::P64 = P64[Sp];
           I64[Sp] = block_cgqcS_info;
           R1 = _sgoA3::P64;
           if (R1 & 7 != 0) goto ugqdH; else goto cgqcT;
       ugqdH: // global
           call _cgqcS(R1) args: 0, res: 0, upd: 0;
       cgqcT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqcS() //  [R1]
         { info_tbl: [(cgqcS,
                       label: block_cgqcS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqcS: // global
           if (R1 & 7 == 1) goto ugqdE; else goto cgqcX;
       ugqdE: // global
           Sp = Sp + 16;
           call _cgqdf() args: 0, res: 0, upd: 0;
       cgqcX: // global
           I64[Sp - 8] = block_cgqd7_info;
           _sgoA6::P64 = P64[R1 + 6];
           _sgoA7::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgoA7::P64;
           P64[Sp + 8] = _sgoA6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqdI; else goto cgqd9;
       ugqdI: // global
           call _cgqd7(R1) args: 0, res: 0, upd: 0;
       cgqd9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqd7() //  [R1]
         { info_tbl: [(cgqd7,
                       label: block_cgqd7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqd7: // global
           if (R1 & 7 == 1) goto ugqdF; else goto cgqdk;
       ugqdF: // global
           Sp = Sp + 24;
           call _cgqdf() args: 0, res: 0, upd: 0;
       cgqdk: // global
           I64[Sp - 8] = block_cgqdi_info;
           _sgoA9::P64 = P64[R1 + 6];
           _sgoAa::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgoAa::P64;
           P64[Sp + 16] = _sgoA9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqdL; else goto cgqdl;
       ugqdL: // global
           call _cgqdi(R1) args: 0, res: 0, upd: 0;
       cgqdl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqdf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqdf: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgqdi() //  [R1]
         { info_tbl: [(cgqdi,
                       label: block_cgqdi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqdi: // global
           I64[Sp] = block_cgqdp_info;
           R3 = w2_rgoyl_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqdp() //  [R1]
         { info_tbl: [(cgqdp,
                       label: block_cgqdp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqdp: // global
           if (R1 & 7 == 1) goto cgqdw; else goto cgqdA;
       cgqdw: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgqcP() args: 0, res: 0, upd: 0;
       cgqdA: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.926252261 UTC

[section ""data" . conMkFixed1_rgoyn_closure" {
     conMkFixed1_rgoyn_closure:
         const Data.Data.AlgConstr_con_info;
         const conMkFixed2_rgoyo_closure;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed4_closure" {
     Data.Fixed.$fDataFixed4_closure:
         const :_con_info;
         const Data.Fixed.conMkFixed_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed3_closure" {
     Data.Fixed.$fDataFixed3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Fixed.$fDataFixed4_closure+2;
         const 0;
 },
 section ""data" . Data.Fixed.tyFixed_closure" {
     Data.Fixed.tyFixed_closure:
         const Data.Data.DataType_con_info;
         const Data.Fixed.$fDataFixed5_closure;
         const Data.Fixed.$fDataFixed3_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.conMkFixed_closure" {
     Data.Fixed.conMkFixed_closure:
         const Data.Data.Constr_con_info;
         const conMkFixed1_rgoyn_closure+1;
         const w2_rgoyl_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Fixed.tyFixed_closure+1;
         const 0;
 },
 section ""data" . conMkFixed2_rgoyo_closure" {
     conMkFixed2_rgoyo_closure:
         const conMkFixed2_rgoyo_info;
         const 0;
         const 0;
         const 0;
 },
 conMkFixed2_rgoyo_entry() //  [R1]
         { info_tbl: [(cgqes,
                       label: conMkFixed2_rgoyo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqes: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqet; else goto cgqeu;
       cgqet: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqeu: // global
           (_cgqep::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqep::I64 == 0) goto cgqer; else goto cgqeq;
       cgqer: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqeq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqep::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Fixed.$fDataFixed4_closure+2;
           Sp = Sp - 16;
           call go61_rgoym_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.933827211 UTC

[section ""cstring" . Data.Fixed.$trModule4_bytes" {
     Data.Fixed.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.935673733 UTC

[section ""data" . loc_rgoyp_closure" {
     loc_rgoyp_closure:
         const loc_rgoyp_info;
         const 0;
         const 0;
         const 0;
 },
 loc_rgoyp_entry() //  [R1]
         { info_tbl: [(cgqeO,
                       label: loc_rgoyp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqeO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqeP; else goto cgqeQ;
       cgqeP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqeQ: // global
           (_cgqeL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqeL::I64 == 0) goto cgqeN; else goto cgqeM;
       cgqeN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqeM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqeL::I64;
           R2 = Data.Fixed.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.939451378 UTC

[section ""cstring" . Data.Fixed.$trModule2_bytes" {
     Data.Fixed.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.941372579 UTC

[section ""data" . loc1_rgoyq_closure" {
     loc1_rgoyq_closure:
         const loc1_rgoyq_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rgoyq_entry() //  [R1]
         { info_tbl: [(cgqf5,
                       label: loc1_rgoyq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqf5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqf6; else goto cgqf7;
       cgqf6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqf7: // global
           (_cgqf2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqf2::I64 == 0) goto cgqf4; else goto cgqf3;
       cgqf4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqf3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqf2::I64;
           R2 = Data.Fixed.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.945695806 UTC

[section ""cstring" . loc2_rgoyr_bytes" {
     loc2_rgoyr_bytes:
         I8[] [46,47,68,97,116,97,47,70,105,120,101,100,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.947469407 UTC

[section ""data" . loc3_rgoys_closure" {
     loc3_rgoys_closure:
         const loc3_rgoys_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rgoys_entry() //  [R1]
         { info_tbl: [(cgqfm,
                       label: loc3_rgoys_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqfm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqfn; else goto cgqfo;
       cgqfn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqfo: // global
           (_cgqfj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqfj::I64 == 0) goto cgqfl; else goto cgqfk;
       cgqfl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqfk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqfj::I64;
           R2 = loc2_rgoyr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.951416971 UTC

[section ""data" . loc4_rgoyt_closure" {
     loc4_rgoyt_closure:
         const GHC.Types.I#_con_info;
         const 83;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.953019348 UTC

[section ""data" . loc5_rgoyu_closure" {
     loc5_rgoyu_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.954622625 UTC

[section ""data" . loc6_rgoyv_closure" {
     loc6_rgoyv_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.956217422 UTC

[section ""cstring" . $dIP_rgoyw_bytes" {
     $dIP_rgoyw_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.958049678 UTC

[section ""data" . $dIP1_rgoyx_closure" {
     $dIP1_rgoyx_closure:
         const $dIP1_rgoyx_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rgoyx_entry() //  [R1]
         { info_tbl: [(cgqfG,
                       label: $dIP1_rgoyx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqfG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqfH; else goto cgqfI;
       cgqfH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqfI: // global
           (_cgqfD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqfD::I64 == 0) goto cgqfF; else goto cgqfE;
       cgqfF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqfE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqfD::I64;
           R2 = $dIP_rgoyw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.962238025 UTC

[section ""data" . $dIP2_rgoyy_closure" {
     $dIP2_rgoyy_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const loc4_rgoyt_closure+1;
         const loc5_rgoyu_closure+1;
         const loc4_rgoyt_closure+1;
         const loc6_rgoyv_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.963944928 UTC

[section ""data" . $dIP3_rgoyz_closure" {
     $dIP3_rgoyz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const $dIP2_rgoyy_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.965653384 UTC

[section ""data" . Data.Fixed.$trModule3_closure" {
     Data.Fixed.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.967334989 UTC

[section ""data" . Data.Fixed.$trModule1_closure" {
     Data.Fixed.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.969012296 UTC

[section ""data" . Data.Fixed.$trModule_closure" {
     Data.Fixed.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Fixed.$trModule3_closure+1;
         const Data.Fixed.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.971255296 UTC

[section ""data" . $krep_rgoyA_closure" {
     $krep_rgoyA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.972956863 UTC

[section ""data" . $krep1_rgoyB_closure" {
     $krep1_rgoyB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.974668444 UTC

[section ""data" . Data.Fixed.$tcHasResolution1_closure" {
     Data.Fixed.$tcHasResolution1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rgoyB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.976397988 UTC

[section ""data" . $krep2_rgoyC_closure" {
     $krep2_rgoyC_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.978481929 UTC

[section ""cstring" . Data.Fixed.$fDataFixed10_bytes" {
     Data.Fixed.$fDataFixed10_bytes:
         I8[] [70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.980107009 UTC

[section ""data" . Data.Fixed.$fDataFixed9_closure" {
     Data.Fixed.$fDataFixed9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$fDataFixed10_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.981818831 UTC

[section ""data" . Data.Fixed.$tcFixed_closure" {
     Data.Fixed.$tcFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$fDataFixed9_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12850707307297787398;
         const 5875431371990069009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.983533216 UTC

[section ""data" . $krep3_rgoyD_closure" {
     $krep3_rgoyD_closure:
         const :_con_info;
         const $krep2_rgoyC_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.985198799 UTC

[section ""data" . $krep4_rgoyE_closure" {
     $krep4_rgoyE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Fixed.$tcFixed_closure+1;
         const $krep3_rgoyD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.986938075 UTC

[section ""data" . Data.Fixed.$tc'MkFixed1_closure" {
     Data.Fixed.$tc'MkFixed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgoyA_closure+1;
         const $krep4_rgoyE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.98851943 UTC

[section ""cstring" . Data.Fixed.$tc'MkFixed3_bytes" {
     Data.Fixed.$tc'MkFixed3_bytes:
         I8[] [39,77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.990112928 UTC

[section ""data" . Data.Fixed.$tc'MkFixed2_closure" {
     Data.Fixed.$tc'MkFixed2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tc'MkFixed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.991825987 UTC

[section ""data" . Data.Fixed.$tc'MkFixed_closure" {
     Data.Fixed.$tc'MkFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tc'MkFixed2_closure+1;
         const Data.Fixed.$tc'MkFixed1_closure+4;
         const 8992689233320522225;
         const 9587721628087041380;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:18.99471617 UTC

[section ""data" . Data.Fixed.$fDataFixed8_closure" {
     Data.Fixed.$fDataFixed8_closure:
         const Data.Fixed.$fDataFixed8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed8_entry() //  [R1]
         { info_tbl: [(cgqgj,
                       label: Data.Fixed.$fDataFixed8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqgj: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgqgk; else goto cgqgl;
       cgqgk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqgl: // global
           (_cgqgb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqgb::I64 == 0) goto cgqgd; else goto cgqgc;
       cgqgd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqgc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqgb::I64;
           I64[Sp - 24] = block_cgqge_info;
           R6 = 0;
           R5 = Data.Fixed.$fDataFixed9_closure+1;
           R4 = Data.Fixed.$trModule_closure+1;
           R3 = 5875431371990069009;
           R2 = 12850707307297787398;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgqge() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgqge,
                       label: block_cgqge_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqge: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgqgf() args: 0, res: 0, upd: 0;
     }
 },
 _cgqgf() //  []
         { info_tbl: [(cgqgf,
                       label: block_cgqgf_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqgf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgqgo; else goto cgqgn;
       cgqgo: // global
           HpAlloc = 48;
           I64[Sp] = block_cgqgf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cgqgn: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.004395977 UTC

[section ""data" . Data.Fixed.$fDataFixed7_closure" {
     Data.Fixed.$fDataFixed7_closure:
         const Data.Fixed.$fDataFixed7_info;
         const 0;
 },
 Data.Fixed.$fDataFixed7_entry() //  [R2]
         { info_tbl: [(cgqgO,
                       label: Data.Fixed.$fDataFixed7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqgO: // global
           R3 = R2;
           R2 = Data.Fixed.$fDataFixed8_closure;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.00830512 UTC

[section ""data" . Data.Fixed.$fDataFixed1_closure" {
     Data.Fixed.$fDataFixed1_closure:
         const (,)_con_info;
         const Data.Fixed.$fDataFixed2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.013176108 UTC

[section ""data" . Data.Fixed.$w$cgmapMp_closure" {
     Data.Fixed.$w$cgmapMp_closure:
         const Data.Fixed.$w$cgmapMp_info;
         const 0;
 },
 lvl17_sgoAs_entry() //  [R1]
         { info_tbl: [(cgqh4,
                       label: lvl17_sgoAs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqh4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqh5; else goto cgqh6;
       cgqh5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqh6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoAP_entry() //  [R1, R2]
         { info_tbl: [(cgqhj,
                       label: sat_sgoAP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqhj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqhk; else goto cgqhl;
       cgqhk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqhl: // global
           I64[Sp - 24] = block_cgqhg_info;
           _sgoAs::P64 = P64[R1 + 7];
           _sgoAt::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgoAs::P64;
           P64[Sp - 8] = _sgoAt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugqhD; else goto cgqhh;
       ugqhD: // global
           call _cgqhg(R1) args: 0, res: 0, upd: 0;
       cgqhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqhg() //  [R1]
         { info_tbl: [(cgqhg,
                       label: block_cgqhg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqhg: // global
           I64[Sp - 8] = block_cgqho_info;
           _sgoAM::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoAM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqhC; else goto cgqhq;
       ugqhC: // global
           call _cgqho(R1) args: 0, res: 0, upd: 0;
       cgqhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqho() //  [R1]
         { info_tbl: [(cgqho,
                       label: block_cgqho_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqho: // global
           if (R1 & 7 == 1) goto cgqhw; else goto cgqhA;
       cgqhw: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgqhA: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgoAu_entry() //  [R1]
         { info_tbl: [(cgqhM,
                       label: lvl18_sgoAu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqhM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqhN; else goto cgqhO;
       cgqhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoAH_entry() //  [R1]
         { info_tbl: [(cgqi5,
                       label: sat_sgoAH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqi5: // global
           _sgoAH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgqi6; else goto cgqi7;
       cgqi7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqi9; else goto cgqi8;
       cgqi9: // global
           HpAlloc = 56;
           goto cgqi6;
       cgqi6: // global
           R1 = _sgoAH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqi8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAH::P64;
           _sgoAr::P64 = P64[_sgoAH::P64 + 16];
           _sgoAt::P64 = P64[_sgoAH::P64 + 24];
           _sgoAy::P64 = P64[_sgoAH::P64 + 32];
           _sgoAz::P64 = P64[_sgoAH::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoAy::P64;
           P64[Hp - 24] = _sgoAr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sgoAz::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoAD_entry() //  [R1, R2]
         { info_tbl: [(cgqil,
                       label: sat_sgoAD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqil: // global
           _sgoAA::P64 = R2;
           _sgoAD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgqim; else goto cgqin;
       cgqin: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqip; else goto cgqio;
       cgqip: // global
           HpAlloc = 56;
           goto cgqim;
       cgqim: // global
           R2 = _sgoAA::P64;
           R1 = _sgoAD::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqio: // global
           _sgoAt::P64 = P64[_sgoAD::P64 + 7];
           _sgoAy::P64 = P64[_sgoAD::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoAy::P64;
           P64[Hp - 24] = _sgoAA::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoAt::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoAE_entry() //  [R1]
         { info_tbl: [(cgqiq,
                       label: sat_sgoAE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqiq: // global
           _sgoAE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqir; else goto cgqis;
       cgqis: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqiu; else goto cgqit;
       cgqiu: // global
           HpAlloc = 24;
           goto cgqir;
       cgqir: // global
           R1 = _sgoAE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAE::P64;
           _sgoAt::P64 = P64[_sgoAE::P64 + 16];
           _sgoAu::P64 = P64[_sgoAE::P64 + 24];
           _sgoAy::P64 = P64[_sgoAE::P64 + 32];
           I64[Hp - 16] = sat_sgoAD_info;
           P64[Hp - 8] = _sgoAt::P64;
           P64[Hp] = _sgoAy::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgoAu::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoAI_entry() //  [R1, R2]
         { info_tbl: [(cgqiv,
                       label: sat_sgoAI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqiv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgqiw; else goto cgqix;
       cgqiw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqix: // global
           I64[Sp - 40] = block_cgqhU_info;
           _sgoAp::P64 = P64[R1 + 7];
           _sgoAr::P64 = P64[R1 + 15];
           _sgoAt::P64 = P64[R1 + 23];
           _sgoAu::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoAp::P64;
           P64[Sp - 24] = _sgoAr::P64;
           P64[Sp - 16] = _sgoAt::P64;
           P64[Sp - 8] = _sgoAu::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugqiB; else goto cgqhV;
       ugqiB: // global
           call _cgqhU(R1) args: 0, res: 0, upd: 0;
       cgqhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqhU() //  [R1]
         { info_tbl: [(cgqhU,
                       label: block_cgqhU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqhU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgqiA; else goto cgqiz;
       cgqiA: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqiz: // global
           _sgoAy::P64 = P64[R1 + 7];
           _sgoAz::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgoAH_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sgoAt::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sgoAt::P64;
           P64[Hp - 48] = _sgoAy::P64;
           P64[Hp - 40] = _sgoAz::P64;
           I64[Hp - 32] = sat_sgoAE_info;
           P64[Hp - 16] = _sgoAt::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sgoAy::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgoAv_entry() //  [R1]
         { info_tbl: [(cgqiG,
                       label: sat_sgoAv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqiG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqiH; else goto cgqiI;
       cgqiH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqiI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoAJ_entry() //  [R1]
         { info_tbl: [(cgqiJ,
                       label: sat_sgoAJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqiJ: // global
           _sgoAJ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqiK; else goto cgqiL;
       cgqiL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgqiN; else goto cgqiM;
       cgqiN: // global
           HpAlloc = 96;
           goto cgqiK;
       cgqiK: // global
           R1 = _sgoAJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqiM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoAJ::P64;
           _sgoAp::P64 = P64[_sgoAJ::P64 + 16];
           _sgoAq::P64 = P64[_sgoAJ::P64 + 24];
           _sgoAr::P64 = P64[_sgoAJ::P64 + 32];
           _sgoAt::P64 = P64[_sgoAJ::P64 + 40];
           I64[Hp - 88] = lvl18_sgoAu_info;
           P64[Hp - 72] = _sgoAq::P64;
           P64[Hp - 64] = _sgoAr::P64;
           I64[Hp - 56] = sat_sgoAI_info;
           P64[Hp - 48] = _sgoAp::P64;
           P64[Hp - 40] = _sgoAr::P64;
           P64[Hp - 32] = _sgoAt::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoAv_info;
           P64[Hp] = _sgoAt::P64;
           R2 = _sgoAt::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMp_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqiO,
                       label: Data.Fixed.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqiO: // global
           _sgoAr::P64 = R4;
           _sgoAq::P64 = R3;
           _sgoAp::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqiP; else goto cgqiQ;
       cgqiQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqiS; else goto cgqiR;
       cgqiS: // global
           HpAlloc = 24;
           goto cgqiP;
       cgqiP: // global
           R4 = _sgoAr::P64;
           R3 = _sgoAq::P64;
           R2 = _sgoAp::P64;
           R1 = Data.Fixed.$w$cgmapMp_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqiR: // global
           I64[Hp - 16] = lvl17_sgoAs_info;
           P64[Hp] = _sgoAp::P64;
           I64[Sp - 40] = block_cgqh7_info;
           R2 = _sgoAp::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgoAp::P64;
           P64[Sp - 16] = _sgoAq::P64;
           P64[Sp - 8] = _sgoAr::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqh7() //  [R1]
         { info_tbl: [(cgqh7,
                       label: block_cgqh7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqh7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgqiV; else goto cgqiU;
       cgqiV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqiU: // global
           I64[Hp - 64] = sat_sgoAP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgoAJ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.047841577 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMp_closure" {
     Data.Fixed.$fDataFixed_$cgmapMp_closure:
         const Data.Fixed.$fDataFixed_$cgmapMp_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMp_entry() //  [R3, R4, R5]
         { info_tbl: [(cgqkg,
                       label: Data.Fixed.$fDataFixed_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqkg: // global
           _sgoAS::P64 = R4;
           R4 = R5;
           _sgoAR::P64 = R3;
           R3 = _sgoAS::P64;
           R2 = _sgoAR::P64;
           call Data.Fixed.$w$cgmapMp_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.052008985 UTC

[section ""data" . Data.Fixed.$w$cgmapM_closure" {
     Data.Fixed.$w$cgmapM_closure:
         const Data.Fixed.$w$cgmapM_info;
         const 0;
 },
 lvl17_sgoAX_entry() //  [R1]
         { info_tbl: [(cgqkv,
                       label: lvl17_sgoAX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqkv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqkw; else goto cgqkx;
       cgqkw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqkx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoB2_entry() //  [R1, R2]
         { info_tbl: [(cgqkJ,
                       label: sat_sgoB2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqkJ: // global
           _sgoB0::P64 = R2;
           _sgoB2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgqkK; else goto cgqkL;
       cgqkL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgqkN; else goto cgqkM;
       cgqkN: // global
           HpAlloc = 32;
           goto cgqkK;
       cgqkK: // global
           R2 = _sgoB0::P64;
           R1 = _sgoB2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqkM: // global
           _sgoAU::P64 = P64[_sgoB2::P64 + 7];
           _sgoAZ::P64 = P64[_sgoB2::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgoAZ::P64;
           P64[Hp] = _sgoB0::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoB3_entry() //  [R1, R2]
         { info_tbl: [(cgqkO,
                       label: sat_sgoB3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqkO: // global
           _sgoAZ::P64 = R2;
           _sgoB3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgqkP; else goto cgqkQ;
       cgqkQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqkS; else goto cgqkR;
       cgqkS: // global
           HpAlloc = 24;
           goto cgqkP;
       cgqkP: // global
           R2 = _sgoAZ::P64;
           R1 = _sgoB3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqkR: // global
           _sgoAU::P64 = P64[_sgoB3::P64 + 7];
           _sgoAX::P64 = P64[_sgoB3::P64 + 15];
           I64[Hp - 16] = sat_sgoB2_info;
           P64[Hp - 8] = _sgoAU::P64;
           P64[Hp] = _sgoAZ::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgoAX::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgoAY_entry() //  [R1]
         { info_tbl: [(cgqkX,
                       label: sat_sgoAY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqkX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqkY; else goto cgqkZ;
       cgqkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqkZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cgql0,
                       label: Data.Fixed.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgql0: // global
           _sgoAW::P64 = R4;
           _sgoAV::P64 = R3;
           _sgoAU::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgql1; else goto cgql2;
       cgql2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgql4; else goto cgql3;
       cgql4: // global
           HpAlloc = 80;
           goto cgql1;
       cgql1: // global
           R4 = _sgoAW::P64;
           R3 = _sgoAV::P64;
           R2 = _sgoAU::P64;
           R1 = Data.Fixed.$w$cgmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgql3: // global
           I64[Hp - 72] = lvl17_sgoAX_info;
           P64[Hp - 56] = _sgoAV::P64;
           P64[Hp - 48] = _sgoAW::P64;
           I64[Hp - 40] = sat_sgoB3_info;
           P64[Hp - 32] = _sgoAU::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = sat_sgoAY_info;
           P64[Hp] = _sgoAU::P64;
           R2 = _sgoAU::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.064683575 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapM_closure" {
     Data.Fixed.$fDataFixed_$cgmapM_closure:
         const Data.Fixed.$fDataFixed_$cgmapM_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapM_entry() //  [R3, R4, R5]
         { info_tbl: [(cgqlz,
                       label: Data.Fixed.$fDataFixed_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqlz: // global
           _sgoB6::P64 = R4;
           R4 = R5;
           _sgoB5::P64 = R3;
           R3 = _sgoB6::P64;
           R2 = _sgoB5::P64;
           call Data.Fixed.$w$cgmapM_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.068284519 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapQi_closure" {
     Data.Fixed.$fDataFixed_$cgmapQi_closure:
         const Data.Fixed.$fDataFixed_$cgmapQi_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapQi_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgqlN,
                       label: Data.Fixed.$fDataFixed_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqlN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqlO; else goto cgqlP;
       cgqlO: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgmapQi_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqlP: // global
           I64[Sp - 24] = block_cgqlK_info;
           R1 = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugqlX; else goto cgqlL;
       ugqlX: // global
           call _cgqlK(R1) args: 0, res: 0, upd: 0;
       cgqlL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqlK() //  [R1]
         { info_tbl: [(cgqlK,
                       label: block_cgqlK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqlK: // global
           if (I64[R1 + 7] == 0) goto cgqlW; else goto cgqlV;
       cgqlW: // global
           R3 = P64[Sp + 16];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqlV: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.076734898 UTC

[section ""data" . Data.Fixed.$w$cgmapMo_closure" {
     Data.Fixed.$w$cgmapMo_closure:
         const Data.Fixed.$w$cgmapMo_info;
         const 0;
 },
 lvl17_sgoBi_entry() //  [R1]
         { info_tbl: [(cgqmf,
                       label: lvl17_sgoBi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqmf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqmg; else goto cgqmh;
       cgqmg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqmh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoBI_entry() //  [R1, R2]
         { info_tbl: [(cgqmu,
                       label: sat_sgoBI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqmu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqmv; else goto cgqmw;
       cgqmv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqmw: // global
           I64[Sp - 24] = block_cgqmr_info;
           _sgoBi::P64 = P64[R1 + 7];
           _sgoBj::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgoBi::P64;
           P64[Sp - 8] = _sgoBj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugqmO; else goto cgqms;
       ugqmO: // global
           call _cgqmr(R1) args: 0, res: 0, upd: 0;
       cgqms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqmr() //  [R1]
         { info_tbl: [(cgqmr,
                       label: block_cgqmr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqmr: // global
           I64[Sp - 8] = block_cgqmz_info;
           _sgoBF::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoBF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqmN; else goto cgqmB;
       ugqmN: // global
           call _cgqmz(R1) args: 0, res: 0, upd: 0;
       cgqmB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqmz() //  [R1]
         { info_tbl: [(cgqmz,
                       label: block_cgqmz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqmz: // global
           if (R1 & 7 == 1) goto cgqmH; else goto cgqmL;
       cgqmH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgqmL: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgoBk_entry() //  [R1]
         { info_tbl: [(cgqmX,
                       label: lvl18_sgoBk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqmX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqmY; else goto cgqmZ;
       cgqmY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqmZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoBy_entry() //  [R1]
         { info_tbl: [(cgqnl,
                       label: sat_sgoBy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqnl: // global
           _sgoBy::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgqnm; else goto cgqnn;
       cgqnn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqnp; else goto cgqno;
       cgqnp: // global
           HpAlloc = 56;
           goto cgqnm;
       cgqnm: // global
           R1 = _sgoBy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqno: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBy::P64;
           _sgoBh::P64 = P64[_sgoBy::P64 + 16];
           _sgoBj::P64 = P64[_sgoBy::P64 + 24];
           _sgoBo::P64 = P64[_sgoBy::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sgoBj::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoBu_entry() //  [R1, R2]
         { info_tbl: [(cgqnB,
                       label: sat_sgoBu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqnB: // global
           _sgoBr::P64 = R2;
           _sgoBu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgqnC; else goto cgqnD;
       cgqnD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqnF; else goto cgqnE;
       cgqnF: // global
           HpAlloc = 56;
           goto cgqnC;
       cgqnC: // global
           R2 = _sgoBr::P64;
           R1 = _sgoBu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqnE: // global
           _sgoBj::P64 = P64[_sgoBu::P64 + 7];
           _sgoBo::P64 = P64[_sgoBu::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBr::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoBj::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoBv_entry() //  [R1]
         { info_tbl: [(cgqnG,
                       label: sat_sgoBv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqnG: // global
           _sgoBv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqnH; else goto cgqnI;
       cgqnI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqnK; else goto cgqnJ;
       cgqnK: // global
           HpAlloc = 24;
           goto cgqnH;
       cgqnH: // global
           R1 = _sgoBv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqnJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBv::P64;
           _sgoBj::P64 = P64[_sgoBv::P64 + 16];
           _sgoBk::P64 = P64[_sgoBv::P64 + 24];
           _sgoBo::P64 = P64[_sgoBv::P64 + 32];
           I64[Hp - 16] = sat_sgoBu_info;
           P64[Hp - 8] = _sgoBj::P64;
           P64[Hp] = _sgoBo::P64;
           R2 = _sgoBj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgoBk::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoBB_entry() //  [R1, R2]
         { info_tbl: [(cgqnL,
                       label: sat_sgoBB_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqnL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgqnM; else goto cgqnN;
       cgqnM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqnN: // global
           I64[Sp - 40] = block_cgqn5_info;
           _sgoBf::P64 = P64[R1 + 7];
           _sgoBh::P64 = P64[R1 + 15];
           _sgoBj::P64 = P64[R1 + 23];
           _sgoBk::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoBf::P64;
           P64[Sp - 24] = _sgoBh::P64;
           P64[Sp - 16] = _sgoBj::P64;
           P64[Sp - 8] = _sgoBk::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugqo4; else goto cgqn6;
       ugqo4: // global
           call _cgqn5(R1) args: 0, res: 0, upd: 0;
       cgqn6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqn5() //  [R1]
         { info_tbl: [(cgqn5,
                       label: block_cgqn5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqn5: // global
           I64[Sp - 8] = block_cgqna_info;
           _sgoBo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgoBo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqo3; else goto cgqnb;
       ugqo3: // global
           call _cgqna(R1) args: 0, res: 0, upd: 0;
       cgqnb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqna() //  [R1]
         { info_tbl: [(cgqna,
                       label: block_cgqna_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqna: // global
           _sgoBh::P64 = P64[Sp + 24];
           _sgoBj::P64 = P64[Sp + 32];
           _sgoBo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgqnQ; else goto cgqnU;
       cgqnQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgqnT; else goto cgqnS;
       cgqnT: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqnS: // global
           I64[Hp - 72] = sat_sgoBy_info;
           P64[Hp - 56] = _sgoBh::P64;
           P64[Hp - 48] = _sgoBj::P64;
           P64[Hp - 40] = _sgoBo::P64;
           I64[Hp - 32] = sat_sgoBv_info;
           P64[Hp - 16] = _sgoBj::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgoBo::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgqnU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqnZ; else goto cgqnY;
       cgqnZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqnY: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgoBo::P64;
           P64[Hp - 24] = _sgoBh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgoBj::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgoBl_entry() //  [R1]
         { info_tbl: [(cgqo9,
                       label: sat_sgoBl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqo9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqoa; else goto cgqob;
       cgqoa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoBC_entry() //  [R1]
         { info_tbl: [(cgqoc,
                       label: sat_sgoBC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqoc: // global
           _sgoBC::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqod; else goto cgqoe;
       cgqoe: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgqog; else goto cgqof;
       cgqog: // global
           HpAlloc = 96;
           goto cgqod;
       cgqod: // global
           R1 = _sgoBC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqof: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoBC::P64;
           _sgoBf::P64 = P64[_sgoBC::P64 + 16];
           _sgoBg::P64 = P64[_sgoBC::P64 + 24];
           _sgoBh::P64 = P64[_sgoBC::P64 + 32];
           _sgoBj::P64 = P64[_sgoBC::P64 + 40];
           I64[Hp - 88] = lvl18_sgoBk_info;
           P64[Hp - 72] = _sgoBg::P64;
           P64[Hp - 64] = _sgoBh::P64;
           I64[Hp - 56] = sat_sgoBB_info;
           P64[Hp - 48] = _sgoBf::P64;
           P64[Hp - 40] = _sgoBh::P64;
           P64[Hp - 32] = _sgoBj::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoBl_info;
           P64[Hp] = _sgoBj::P64;
           R2 = _sgoBj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqoh,
                       label: Data.Fixed.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqoh: // global
           _sgoBh::P64 = R4;
           _sgoBg::P64 = R3;
           _sgoBf::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqoi; else goto cgqoj;
       cgqoj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqol; else goto cgqok;
       cgqol: // global
           HpAlloc = 24;
           goto cgqoi;
       cgqoi: // global
           R4 = _sgoBh::P64;
           R3 = _sgoBg::P64;
           R2 = _sgoBf::P64;
           R1 = Data.Fixed.$w$cgmapMo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqok: // global
           I64[Hp - 16] = lvl17_sgoBi_info;
           P64[Hp] = _sgoBf::P64;
           I64[Sp - 40] = block_cgqmi_info;
           R2 = _sgoBf::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgoBf::P64;
           P64[Sp - 16] = _sgoBg::P64;
           P64[Sp - 8] = _sgoBh::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqmi() //  [R1]
         { info_tbl: [(cgqmi,
                       label: block_cgqmi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqmi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgqoo; else goto cgqon;
       cgqoo: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqon: // global
           I64[Hp - 64] = sat_sgoBI_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgoBC_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.111698066 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMo_closure" {
     Data.Fixed.$fDataFixed_$cgmapMo_closure:
         const Data.Fixed.$fDataFixed_$cgmapMo_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMo_entry() //  [R3, R4, R5]
         { info_tbl: [(cgqpQ,
                       label: Data.Fixed.$fDataFixed_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqpQ: // global
           _sgoBL::P64 = R4;
           R4 = R5;
           _sgoBK::P64 = R3;
           R3 = _sgoBL::P64;
           R2 = _sgoBK::P64;
           call Data.Fixed.$w$cgmapMo_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.115279603 UTC

[section ""data" . lvl_rgoyF_closure" {
     lvl_rgoyF_closure:
         const lvl_rgoyF_info;
         const 0;
 },
 lvl_rgoyF_entry() //  []
         { info_tbl: [(cgqq1,
                       label: lvl_rgoyF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqq1: // global
           R1 = Data.Fixed.conMkFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.118531798 UTC

[section ""data" . lvl1_rgoyG_closure" {
     lvl1_rgoyG_closure:
         const lvl1_rgoyG_info;
         const 0;
 },
 lvl1_rgoyG_entry() //  []
         { info_tbl: [(cgqqd,
                       label: lvl1_rgoyG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqqd: // global
           R1 = Data.Fixed.tyFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.121748423 UTC

[section ""data" . lvl2_rgoyH_closure" {
     lvl2_rgoyH_closure:
         const lvl2_rgoyH_info;
 },
 lvl2_rgoyH_entry() //  []
         { info_tbl: [(cgqqp,
                       label: lvl2_rgoyH_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqqp: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.12554029 UTC

[section ""data" . lvl3_rgoyI_closure" {
     lvl3_rgoyI_closure:
         const lvl3_rgoyI_info;
 },
 lvl3_rgoyI_entry() //  []
         { info_tbl: [(cgqqB,
                       label: lvl3_rgoyI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqqB: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.128698388 UTC

[section ""data" . lvl4_rgoyJ_closure" {
     lvl4_rgoyJ_closure:
         const lvl4_rgoyJ_info;
         const 0;
 },
 lvl4_rgoyJ_entry() //  [R2, R3]
         { info_tbl: [(cgqqN,
                       label: lvl4_rgoyJ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqqN: // global
           R3 = R3;
           _sgoBT::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoBT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.132324709 UTC

[section ""data" . lvl5_rgoyK_closure" {
     lvl5_rgoyK_closure:
         const lvl5_rgoyK_info;
         const 0;
 },
 sat_sgoBZ_entry() //  [R1]
         { info_tbl: [(cgqr2,
                       label: sat_sgoBZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqr2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqr3; else goto cgqr4;
       cgqr3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqr4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl5_rgoyK_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgqr5,
                       label: lvl5_rgoyK_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqr5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgqr9; else goto cgqr8;
       cgqr9: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl5_rgoyK_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqr8: // global
           I64[Hp - 24] = sat_sgoBZ_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sgoBW::P64 = R3;
           R3 = Hp - 24;
           _sgoBV::P64 = R2;
           R2 = _sgoBW::P64;
           R1 = _sgoBV::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.138177563 UTC

[section ""data" . lvl6_rgoyL_closure" {
     lvl6_rgoyL_closure:
         const lvl6_rgoyL_info;
         const 0;
 },
 sat_sgoC4_entry() //  [R1]
         { info_tbl: [(cgqrq,
                       label: sat_sgoC4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqrq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqrr; else goto cgqrs;
       cgqrr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqrs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl6_rgoyL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgqrt,
                       label: lvl6_rgoyL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqrt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgqrx; else goto cgqrw;
       cgqrx: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl6_rgoyL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqrw: // global
           I64[Hp - 24] = sat_sgoC4_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R3;
           _sgoC0::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgoC0::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.143875582 UTC

[section ""data" . lvl7_rgoyM_closure" {
     lvl7_rgoyM_closure:
         const lvl7_rgoyM_info;
         const 0;
 },
 sat_sgoC7_entry() //  [R1]
         { info_tbl: [(cgqrO,
                       label: sat_sgoC7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqrO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqrP; else goto cgqrQ;
       cgqrP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqrQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rgoyM_entry() //  [R2, R3]
         { info_tbl: [(cgqrS,
                       label: lvl7_rgoyM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqrS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqrW; else goto cgqrV;
       cgqrW: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rgoyM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqrV: // global
           I64[Hp - 48] = sat_sgoC7_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.149815222 UTC

[section ""data" . lvl8_rgoyN_closure" {
     lvl8_rgoyN_closure:
         const lvl8_rgoyN_info;
         const 0;
 },
 sat_sgoCb_entry() //  [R1]
         { info_tbl: [(cgqsf,
                       label: sat_sgoCb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqsf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqsg; else goto cgqsh;
       cgqsg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqsh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rgoyN_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqsi,
                       label: lvl8_rgoyN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqsi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqsm; else goto cgqsl;
       cgqsm: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl8_rgoyN_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqsl: // global
           I64[Hp - 16] = sat_sgoCb_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sgoC8::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgoC8::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.156128636 UTC

[section ""data" . Data.Fixed.$fDataFixed_closure" {
     Data.Fixed.$fDataFixed_closure:
         const Data.Fixed.$fDataFixed_info;
         const 0;
 },
 sat_sgoCf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgqsE,
                       label: sat_sgoCf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqsE: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgmapQi_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoCe_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgqsM,
                       label: sat_sgoCe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqsM: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgfoldl_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoCd_entry() //  [R1]
         { info_tbl: [(cgqsT,
                       label: sat_sgoCd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqsT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqsU; else goto cgqsV;
       cgqsU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqsV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fDataFixed7_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_entry() //  [R2]
         { info_tbl: [(cgqsX,
                       label: Data.Fixed.$fDataFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqsX: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cgqt1; else goto cgqt0;
       cgqt1: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqt0: // global
           I64[Hp - 176] = sat_sgoCf_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sgoCe_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sgoCd_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 144;
           P64[Hp - 104] = Hp - 157;
           P64[Hp - 96] = lvl8_rgoyN_closure+3;
           P64[Hp - 88] = lvl_rgoyF_closure+1;
           P64[Hp - 80] = lvl1_rgoyG_closure+1;
           P64[Hp - 72] = lvl2_rgoyH_closure+2;
           P64[Hp - 64] = lvl3_rgoyI_closure+2;
           P64[Hp - 56] = lvl4_rgoyJ_closure+2;
           P64[Hp - 48] = lvl5_rgoyK_closure+4;
           P64[Hp - 40] = lvl6_rgoyL_closure+4;
           P64[Hp - 32] = lvl7_rgoyM_closure+2;
           P64[Hp - 24] = Hp - 173;
           P64[Hp - 16] = Data.Fixed.$w$cgmapM_closure+3;
           P64[Hp - 8] = Data.Fixed.$w$cgmapMp_closure+3;
           P64[Hp] = Data.Fixed.$w$cgmapMo_closure+3;
           R1 = Hp - 119;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.166186826 UTC

[section ""cstring" . Data.Fixed.$tcHasResolution3_bytes" {
     Data.Fixed.$tcHasResolution3_bytes:
         I8[] [72,97,115,82,101,115,111,108,117,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.16774006 UTC

[section ""data" . Data.Fixed.$tcHasResolution2_closure" {
     Data.Fixed.$tcHasResolution2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcHasResolution3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.169402373 UTC

[section ""data" . Data.Fixed.$tcHasResolution_closure" {
     Data.Fixed.$tcHasResolution_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcHasResolution2_closure+1;
         const Data.Fixed.$tcHasResolution1_closure+4;
         const 7410670074803796200;
         const 11622449620609036983;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.171189846 UTC

[section ""cstring" . Data.Fixed.$tcE5_bytes" {
     Data.Fixed.$tcE5_bytes:
         I8[] [69,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.172850456 UTC

[section ""data" . Data.Fixed.$tcE4_closure" {
     Data.Fixed.$tcE4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.174657231 UTC

[section ""data" . Data.Fixed.$tcE0_closure" {
     Data.Fixed.$tcE0_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE4_closure+1;
         const GHC.Types.krep$*_closure;
         const 1111589946053822622;
         const 14645449775626969178;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.17644604 UTC

[section ""cstring" . Data.Fixed.$tcE8_bytes" {
     Data.Fixed.$tcE8_bytes:
         I8[] [69,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.178061262 UTC

[section ""data" . Data.Fixed.$tcE7_closure" {
     Data.Fixed.$tcE7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.179793337 UTC

[section ""data" . Data.Fixed.$tcE1_closure" {
     Data.Fixed.$tcE1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE7_closure+1;
         const GHC.Types.krep$*_closure;
         const 17242267792727872229;
         const 10571291330004494282;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.181957763 UTC

[section ""cstring" . Data.Fixed.$tcE14_bytes" {
     Data.Fixed.$tcE14_bytes:
         I8[] [69,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.183649375 UTC

[section ""data" . Data.Fixed.$tcE13_closure" {
     Data.Fixed.$tcE13_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE14_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.185944826 UTC

[section ""data" . Data.Fixed.$tcE2_closure" {
     Data.Fixed.$tcE2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE13_closure+1;
         const GHC.Types.krep$*_closure;
         const 18184774527647329547;
         const 15895109557895358229;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.187782399 UTC

[section ""cstring" . Data.Fixed.$tcE16_bytes" {
     Data.Fixed.$tcE16_bytes:
         I8[] [69,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.18941978 UTC

[section ""data" . Data.Fixed.$tcE15_closure" {
     Data.Fixed.$tcE15_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE16_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.191028951 UTC

[section ""data" . Data.Fixed.$tcE3_closure" {
     Data.Fixed.$tcE3_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE15_closure+1;
         const GHC.Types.krep$*_closure;
         const 2281297682271263739;
         const 13982938170987291273;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.192897694 UTC

[section ""cstring" . Data.Fixed.$tcE18_bytes" {
     Data.Fixed.$tcE18_bytes:
         I8[] [69,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.195127398 UTC

[section ""data" . Data.Fixed.$tcE17_closure" {
     Data.Fixed.$tcE17_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE18_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.196824322 UTC

[section ""data" . Data.Fixed.$tcE6_closure" {
     Data.Fixed.$tcE6_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE17_closure+1;
         const GHC.Types.krep$*_closure;
         const 6430880657524859014;
         const 16351944333195325805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.198584225 UTC

[section ""cstring" . Data.Fixed.$tcE20_bytes" {
     Data.Fixed.$tcE20_bytes:
         I8[] [69,57]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.200047622 UTC

[section ""data" . Data.Fixed.$tcE19_closure" {
     Data.Fixed.$tcE19_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE20_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.201673616 UTC

[section ""data" . Data.Fixed.$tcE9_closure" {
     Data.Fixed.$tcE9_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE19_closure+1;
         const GHC.Types.krep$*_closure;
         const 8202840314884717291;
         const 5390706447224283764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.203381784 UTC

[section ""cstring" . Data.Fixed.$tcE11_bytes" {
     Data.Fixed.$tcE11_bytes:
         I8[] [69,49,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.204982419 UTC

[section ""data" . Data.Fixed.$tcE10_closure" {
     Data.Fixed.$tcE10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.20704994 UTC

[section ""data" . Data.Fixed.$tcE12_closure" {
     Data.Fixed.$tcE12_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE10_closure+1;
         const GHC.Types.krep$*_closure;
         const 11177455628646877585;
         const 1804744900678580889;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.209361525 UTC

[section ""data" . Data.Fixed.div'_closure" {
     Data.Fixed.div'_closure:
         const Data.Fixed.div'_info;
         const 0;
 },
 Data.Fixed.div'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgqtO,
                       label: Data.Fixed.div'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqtO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgqtW; else goto cgqtX;
       cgqtW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.div'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqtX: // global
           I64[Sp - 32] = block_cgqtM_info;
           _sgoCg::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _sgoCg::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgqtM() //  [R1]
         { info_tbl: [(cgqtM,
                       label: block_cgqtM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqtM: // global
           I64[Sp] = block_cgqtR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgqtR() //  [R1]
         { info_tbl: [(cgqtR,
                       label: block_cgqtR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqtR: // global
           _sgoCm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqtV_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sgoCm::P64;
           R2 = P64[Sp + 24];
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqtV() //  [R1, R2]
         { info_tbl: [(cgqtV,
                       label: block_cgqtV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqtV: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.220495294 UTC

[section ""data" . Data.Fixed.$wdivMod'_closure" {
     Data.Fixed.$wdivMod'_closure:
         const Data.Fixed.$wdivMod'_info;
         const 0;
 },
 f_sgoCx_entry() //  [R1]
         { info_tbl: [(cgqur,
                       label: f_sgoCx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqus; else goto cgqut;
       cgqus: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoCz_entry() //  [R1]
         { info_tbl: [(cgquO,
                       label: sat_sgoCz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgquO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgquP; else goto cgquQ;
       cgquP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgquQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCA_entry() //  [R1]
         { info_tbl: [(cgquR,
                       label: sat_sgoCA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgquR: // global
           _sgoCA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgquS; else goto cgquT;
       cgquT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgquV; else goto cgquU;
       cgquV: // global
           HpAlloc = 32;
           goto cgquS;
       cgquS: // global
           R1 = _sgoCA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgquU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCA::P64;
           _sgoCu::P64 = P64[_sgoCA::P64 + 16];
           _sgoCx::P64 = P64[_sgoCA::P64 + 24];
           _sgoCy::P64 = P64[_sgoCA::P64 + 32];
           I64[Hp - 24] = sat_sgoCz_info;
           P64[Hp - 8] = _sgoCu::P64;
           P64[Hp] = _sgoCx::P64;
           R2 = _sgoCy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCB_entry() //  [R1]
         { info_tbl: [(cgquW,
                       label: sat_sgoCB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgquW: // global
           _sgoCB::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgquX; else goto cgquY;
       cgquY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgqv0; else goto cgquZ;
       cgqv0: // global
           HpAlloc = 40;
           goto cgquX;
       cgquX: // global
           R1 = _sgoCB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgquZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCB::P64;
           _sgoCu::P64 = P64[_sgoCB::P64 + 16];
           _sgoCw::P64 = P64[_sgoCB::P64 + 24];
           _sgoCx::P64 = P64[_sgoCB::P64 + 32];
           _sgoCy::P64 = P64[_sgoCB::P64 + 40];
           I64[Hp - 32] = sat_sgoCA_info;
           P64[Hp - 16] = _sgoCu::P64;
           P64[Hp - 8] = _sgoCx::P64;
           P64[Hp] = _sgoCy::P64;
           R2 = _sgoCy::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgoCw::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgoCC_entry() //  [R1]
         { info_tbl: [(cgqv1,
                       label: sat_sgoCC_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqv1: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgqv2; else goto cgqv3;
       cgqv2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqv3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgquy_info;
           R2 = P64[R1 + 16];
           P64[Sp - 48] = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 56;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgquy() //  [R1]
         { info_tbl: [(cgquy,
                       label: block_cgquy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgquy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgqv6; else goto cgqv5;
       cgqv6: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgqv5: // global
           I64[Hp - 40] = sat_sgoCB_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           _sgoCv::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _sgoCv::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$wdivMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgqv7,
                       label: Data.Fixed.$wdivMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqv7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgqvb; else goto cgqva;
       cgqvb: // global
           HpAlloc = 104;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$wdivMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqva: // global
           I64[Hp - 96] = f_sgoCx_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = sat_sgoCC_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _cgqun::P64 = Hp - 96;
           P64[Hp] = _cgqun::P64;
           R2 = Hp - 48;
           R1 = _cgqun::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.237171572 UTC

[section ""data" . Data.Fixed.divMod'_closure" {
     Data.Fixed.divMod'_closure:
         const Data.Fixed.divMod'_info;
         const 0;
 },
 Data.Fixed.divMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgqvW,
                       label: Data.Fixed.divMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqvW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgqvX; else goto cgqvY;
       cgqvX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.divMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqvY: // global
           I64[Sp - 8] = block_cgqvT_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$wdivMod'_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqvT() //  [R1, R2]
         { info_tbl: [(cgqvT,
                       label: block_cgqvT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqvT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqw1; else goto cgqw0;
       cgqw1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqw0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.243634576 UTC

[section ""data" . Data.Fixed.mod'_closure" {
     Data.Fixed.mod'_closure:
         const Data.Fixed.mod'_info;
         const 0;
 },
 sat_sgoCO_entry() //  [R1]
         { info_tbl: [(cgqwv,
                       label: sat_sgoCO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqwv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqww; else goto cgqwx;
       cgqww: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqwx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoCP_entry() //  [R1]
         { info_tbl: [(cgqwy,
                       label: sat_sgoCP_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqwy: // global
           _sgoCP::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgqwz; else goto cgqwA;
       cgqwA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgqwC; else goto cgqwB;
       cgqwC: // global
           HpAlloc = 40;
           goto cgqwz;
       cgqwz: // global
           R1 = _sgoCP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqwB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCP::P64;
           _sgoCK::P64 = P64[_sgoCP::P64 + 16];
           _sgoCL::P64 = P64[_sgoCP::P64 + 24];
           _sgoCM::P64 = P64[_sgoCP::P64 + 32];
           _sgoCN::P64 = P64[_sgoCP::P64 + 40];
           I64[Hp - 32] = sat_sgoCO_info;
           P64[Hp - 16] = _sgoCK::P64;
           P64[Hp - 8] = _sgoCL::P64;
           P64[Hp] = _sgoCM::P64;
           R2 = _sgoCN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgoCQ_entry() //  [R1]
         { info_tbl: [(cgqwD,
                       label: sat_sgoCQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqwD: // global
           _sgoCQ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqwE; else goto cgqwF;
       cgqwF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgqwH; else goto cgqwG;
       cgqwH: // global
           HpAlloc = 48;
           goto cgqwE;
       cgqwE: // global
           R1 = _sgoCQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqwG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoCQ::P64;
           _sgoCK::P64 = P64[_sgoCQ::P64 + 16];
           _sgoCL::P64 = P64[_sgoCQ::P64 + 24];
           _sgoCM::P64 = P64[_sgoCQ::P64 + 32];
           _sgoCN::P64 = P64[_sgoCQ::P64 + 40];
           I64[Hp - 40] = sat_sgoCP_info;
           P64[Hp - 24] = _sgoCK::P64;
           P64[Hp - 16] = _sgoCL::P64;
           P64[Hp - 8] = _sgoCM::P64;
           P64[Hp] = _sgoCN::P64;
           R2 = _sgoCN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sgoCM::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.mod'_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqwI,
                       label: Data.Fixed.mod'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqwI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqwJ; else goto cgqwK;
       cgqwJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.mod'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqwK: // global
           I64[Sp - 32] = block_cgqwf_info;
           _sgoCK::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sgoCK::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqwf() //  [R1]
         { info_tbl: [(cgqwf,
                       label: block_cgqwf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqwf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgqwN; else goto cgqwM;
       cgqwN: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqwM: // global
           I64[Hp - 40] = sat_sgoCQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.257379168 UTC

[section ""data" . Data.Fixed.$fFractionalFixed2_closure" {
     Data.Fixed.$fFractionalFixed2_closure:
         const Data.Fixed.$fFractionalFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fFractionalFixed2_entry() //  [R1]
         { info_tbl: [(cgqxk,
                       label: Data.Fixed.$fFractionalFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqxk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqxl; else goto cgqxm;
       cgqxl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqxm: // global
           (_cgqxh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqxh::I64 == 0) goto cgqxj; else goto cgqxi;
       cgqxj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqxi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqxh::I64;
           R2 = $dIP3_rgoyz_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.261669524 UTC

[section ""data" . Data.Fixed.$w$cfromRational_closure" {
     Data.Fixed.$w$cfromRational_closure:
         const Data.Fixed.$w$cfromRational_info;
         const 0;
 },
 Data.Fixed.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqxA,
                       label: Data.Fixed.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqxA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqxM; else goto cgqxN;
       cgqxM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqxN: // global
           I64[Sp - 24] = block_cgqxy_info;
           _sgoCR::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoCR::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqxy() //  [R1]
         { info_tbl: [(cgqxy,
                       label: block_cgqxy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqxy: // global
           I64[Sp] = block_cgqxD_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqxD() //  [R1]
         { info_tbl: [(cgqxD,
                       label: block_cgqxD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqxD: // global
           _sgoCS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqxH_info;
           R3 = P64[Sp + 16];
           R2 = _sgoCS::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqxH() //  [R1]
         { info_tbl: [(cgqxH,
                       label: block_cgqxH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqxH: // global
           _sgoCW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqxL_info;
           R3 = _sgoCW::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqxL() //  [R1, R2]
         { info_tbl: [(cgqxL,
                       label: block_cgqxL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqxL: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.272172429 UTC

[section ""data" . Data.Fixed.$fFractionalFixed1_closure" {
     Data.Fixed.$fFractionalFixed1_closure:
         const Data.Fixed.$fFractionalFixed1_info;
         const 0;
 },
 Data.Fixed.$fFractionalFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgqyh,
                       label: Data.Fixed.$fFractionalFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqyh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqyi; else goto cgqyj;
       cgqyi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqyj: // global
           I64[Sp - 16] = block_cgqye_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugqyn; else goto cgqyf;
       ugqyn: // global
           call _cgqye(R1) args: 0, res: 0, upd: 0;
       cgqyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqye() //  [R1]
         { info_tbl: [(cgqye,
                       label: block_cgqye_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqye: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Fixed.$w$cfromRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.277956839 UTC

[section ""data" . Data.Fixed.$fRealFixed_$ctoRational_closure" {
     Data.Fixed.$fRealFixed_$ctoRational_closure:
         const Data.Fixed.$fRealFixed_$ctoRational_info;
         const 0;
 },
 Data.Fixed.$fRealFixed_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(cgqyD,
                       label: Data.Fixed.$fRealFixed_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqyD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqyJ; else goto cgqyK;
       cgqyJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqyK: // global
           I64[Sp - 16] = block_cgqyB_info;
           _sgoD5::P64 = R2;
           R2 = R3;
           R1 = _sgoD5::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqyB() //  [R1]
         { info_tbl: [(cgqyB,
                       label: block_cgqyB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqyB: // global
           _sgoD6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqyG_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgoD6::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqyG() //  [R1, R2]
         { info_tbl: [(cgqyG,
                       label: block_cgqyG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqyG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqyO; else goto cgqyN;
       cgqyO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqyN: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.286068276 UTC

[section ""data" . Data.Fixed.$fFractionalFixed3_closure" {
     Data.Fixed.$fFractionalFixed3_closure:
         const Data.Fixed.$fFractionalFixed3_info;
         const 0;
 },
 section ""relreadonly" . ugqzt_srtd" {
     ugqzt_srtd:
         const SgoHz_srt+40;
         const 72;
         const 4611686018427387905;
         const 224;
 },
 Data.Fixed.$fFractionalFixed3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqza,
                       label: Data.Fixed.$fFractionalFixed3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqza: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqzb; else goto cgqzc;
       cgqzb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqzc: // global
           I64[Sp - 32] = block_cgqz5_info;
           _sgoDc::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoDb::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgoDb::P64;
           P64[Sp - 16] = _sgoDc::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqz5() //  [R1]
         { info_tbl: [(cgqz5,
                       label: block_cgqz5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqz5: // global
           if (R1 == 1) goto cgqz9; else goto cgqz8;
       cgqz9: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgqz8: // global
           _sgoDb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqzf_info;
           R2 = P64[Sp + 16];
           R1 = _sgoDb::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqzf() //  [R1]
         { info_tbl: [(cgqzf,
                       label: block_cgqzf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqzf: // global
           _sgoDc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqzj_info;
           R3 = R1;
           R2 = _sgoDc::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqzj() //  [R1]
         { info_tbl: [(cgqzj,
                       label: block_cgqzj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqzj: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.296399914 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_$crecip_closure" {
     Data.Fixed.$fFractionalFixed_$crecip_closure:
         const Data.Fixed.$fFractionalFixed_$crecip_info;
         const 0;
 },
 section ""relreadonly" . ugqAb_srtd" {
     ugqAb_srtd:
         const SgoHz_srt+40;
         const 73;
         const 4611686018427387905;
         const 352;
 },
 Data.Fixed.$fFractionalFixed_$crecip_entry() //  [R2, R3]
         { info_tbl: [(cgqzS,
                       label: Data.Fixed.$fFractionalFixed_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqzS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqzT; else goto cgqzU;
       cgqzT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqzU: // global
           I64[Sp - 24] = block_cgqzN_info;
           _sgoDi::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoDh::P64 = R2;
           R2 = _sgoDi::P64;
           P64[Sp - 16] = _sgoDh::P64;
           P64[Sp - 8] = _sgoDi::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqzN() //  [R1]
         { info_tbl: [(cgqzN,
                       label: block_cgqzN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqzN: // global
           if (R1 == 1) goto cgqzR; else goto cgqzQ;
       cgqzR: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgqzQ: // global
           _sgoDh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqzX_info;
           R2 = P64[Sp + 16];
           R1 = _sgoDh::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqzX() //  [R1]
         { info_tbl: [(cgqzX,
                       label: block_cgqzX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqzX: // global
           I64[Sp] = block_cgqA1_info;
           R3 = R1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqA1() //  [R1]
         { info_tbl: [(cgqA1,
                       label: block_cgqA1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqA1: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.306343665 UTC

[section ""data" . Data.Fixed.$fNumFixed_$c*_closure" {
     Data.Fixed.$fNumFixed_$c*_closure:
         const Data.Fixed.$fNumFixed_$c*_info;
         const 0;
 },
 section ""relreadonly" . ugqAT_srtd" {
     ugqAT_srtd:
         const SgoHz_srt+40;
         const 74;
         const 4611686018427387905;
         const 608;
 },
 Data.Fixed.$fNumFixed_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqAx,
                       label: Data.Fixed.$fNumFixed_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqAx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqAy; else goto cgqAz;
       cgqAy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqAz: // global
           I64[Sp - 24] = block_cgqAv_info;
           _sgoDm::P64 = R2;
           R2 = R3;
           R1 = _sgoDm::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqAU_srtd" {
     ugqAU_srtd:
         const SgoHz_srt+40;
         const 71;
         const 4611686018427387905;
         const 96;
 },
 _cgqAv() //  [R1]
         { info_tbl: [(cgqAv,
                       label: block_cgqAv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqAv: // global
           I64[Sp - 8] = block_cgqAC_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqAC() //  [R1]
         { info_tbl: [(cgqAC,
                       label: block_cgqAC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqAC: // global
           if (R1 == 1) goto cgqAS; else goto cgqAK;
       cgqAS: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgqAK: // global
           I64[Sp] = block_cgqAH_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqAH() //  [R1]
         { info_tbl: [(cgqAH,
                       label: block_cgqAH_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqAH: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.316492292 UTC

[section ""data" . Data.Fixed.$fNumFixed1_closure" {
     Data.Fixed.$fNumFixed1_closure:
         const Data.Fixed.$fNumFixed1_info;
         const 0;
 },
 Data.Fixed.$fNumFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgqBh,
                       label: Data.Fixed.$fNumFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqBh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqBi; else goto cgqBj;
       cgqBi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqBj: // global
           I64[Sp - 16] = block_cgqBf_info;
           _sgoDs::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoDs::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqBf() //  [R1]
         { info_tbl: [(cgqBf,
                       label: block_cgqBf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqBf: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.322061945 UTC

[section ""data" . Data.Fixed.$fNumFixed2_closure" {
     Data.Fixed.$fNumFixed2_closure:
         const Data.Fixed.$fNumFixed2_info;
         const 0;
 },
 Data.Fixed.$fNumFixed2_entry() //  [R2, R3]
         { info_tbl: [(cgqBB,
                       label: Data.Fixed.$fNumFixed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqBB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqBF; else goto cgqBG;
       cgqBF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqBG: // global
           I64[Sp - 16] = block_cgqBz_info;
           _sgoDv::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgoDv::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqBz() //  [R1]
         { info_tbl: [(cgqBz,
                       label: block_cgqBz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqBz: // global
           I64[Sp] = block_cgqBE_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqBE() //  [R1]
         { info_tbl: [(cgqBE,
                       label: block_cgqBE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqBE: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.329928249 UTC

[section ""data" . Data.Fixed.$fNumFixed_closure" {
     Data.Fixed.$fNumFixed_closure:
         const Data.Fixed.$fNumFixed_info;
         const 0;
 },
 sat_sgoDC_entry() //  [R1, R2]
         { info_tbl: [(cgqC6,
                       label: sat_sgoDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqC6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDB_entry() //  [R1, R2]
         { info_tbl: [(cgqCe,
                       label: sat_sgoDB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqCe: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqCm,
                       label: sat_sgoDA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqCm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fNumFixed_$c*_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugqCv_srtd" {
     ugqCv_srtd:
         const SgoHz_srt+16;
         const 80;
         const 3;
         const 61440;
 },
 Data.Fixed.$fNumFixed_entry() //  [R2]
         { info_tbl: [(cgqCq,
                       label: Data.Fixed.$fNumFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqCq: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgqCu; else goto cgqCt;
       cgqCu: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqCt: // global
           I64[Hp - 104] = sat_sgoDC_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgoDB_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgoDA_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = GHC.Integer.Type.plusInteger_closure+2;
           P64[Hp - 40] = GHC.Integer.Type.minusInteger_closure+2;
           P64[Hp - 32] = Hp - 70;
           P64[Hp - 24] = GHC.Integer.Type.negateInteger_closure+1;
           P64[Hp - 16] = GHC.Integer.Type.absInteger_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.340386483 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_closure" {
     Data.Fixed.$fFractionalFixed_closure:
         const Data.Fixed.$fFractionalFixed_info;
         const 0;
 },
 sat_sgoDH_entry() //  [R1, R2]
         { info_tbl: [(cgqCX,
                       label: sat_sgoDH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqCX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDG_entry() //  [R1, R2]
         { info_tbl: [(cgqD5,
                       label: sat_sgoDG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqD5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed_$crecip_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDF_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqDd,
                       label: sat_sgoDF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqDd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoDE_entry() //  [R1]
         { info_tbl: [(cgqDk,
                       label: sat_sgoDE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqDk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqDl; else goto cgqDm;
       cgqDl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqDm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fFractionalFixed_entry() //  [R2]
         { info_tbl: [(cgqDo,
                       label: Data.Fixed.$fFractionalFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqDo: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgqDs; else goto cgqDr;
       cgqDs: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqDr: // global
           I64[Hp - 104] = sat_sgoDH_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgoDG_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgoDF_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoDE_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.351238884 UTC

[section ""data" . Data.Fixed.$fReadFixed2_closure" {
     Data.Fixed.$fReadFixed2_closure:
         const Data.Fixed.$fReadFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed2_entry() //  [R1]
         { info_tbl: [(cgqDY,
                       label: Data.Fixed.$fReadFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqDY: // global
           _rgoxK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgqE1; else goto cgqE2;
       cgqE2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgqE4; else goto cgqE3;
       cgqE4: // global
           HpAlloc = 16;
           goto cgqE1;
       cgqE1: // global
           R1 = _rgoxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqE3: // global
           (_cgqDS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rgoxK::P64);
           if (_cgqDS::I64 == 0) goto cgqDU; else goto cgqDT;
       cgqDU: // global
           call (I64[I64[_rgoxK::P64]])() args: 8, res: 0, upd: 8;
       cgqDT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqDS::I64;
           (_cgqDV::F64) = call MO_F64_Log(10.0 :: W64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _cgqDV::F64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.355629571 UTC

[section ""data" . lvl9_rgoyO_closure" {
     lvl9_rgoyO_closure:
         const GHC.Types.I#_con_info;
         const 172;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.357915787 UTC

[section ""data" . lvl10_rgoyP_closure" {
     lvl10_rgoyP_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.359566128 UTC

[section ""data" . lvl11_rgoyQ_closure" {
     lvl11_rgoyQ_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.361738406 UTC

[section ""data" . lvl12_rgoyR_closure" {
     lvl12_rgoyR_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const lvl9_rgoyO_closure+1;
         const lvl10_rgoyP_closure+1;
         const lvl9_rgoyO_closure+1;
         const lvl11_rgoyQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.363664544 UTC

[section ""data" . lvl13_rgoyS_closure" {
     lvl13_rgoyS_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const lvl12_rgoyR_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.365646126 UTC

[section ""data" . Data.Fixed.$fReadFixed3_closure" {
     Data.Fixed.$fReadFixed3_closure:
         const Data.Fixed.$fReadFixed3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed3_entry() //  [R1]
         { info_tbl: [(cgqEp,
                       label: Data.Fixed.$fReadFixed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqEp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqEq; else goto cgqEr;
       cgqEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqEr: // global
           (_cgqEm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgqEm::I64 == 0) goto cgqEo; else goto cgqEn;
       cgqEo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgqEn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgqEm::I64;
           R2 = lvl13_rgoyS_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.372265786 UTC

[section ""data" . Data.Fixed.$fReadFixed1_closure" {
     Data.Fixed.$fReadFixed1_closure:
         const Data.Fixed.$fReadFixed1_info;
         const 0;
 },
 lvl17_sgoDK_entry() //  [R1]
         { info_tbl: [(cgqEH,
                       label: lvl17_sgoDK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqEH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqEI; else goto cgqEJ;
       cgqEI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqEJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 e_sgoDL_entry() //  [R1]
         { info_tbl: [(cgqEQ,
                       label: e_sgoDL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqEQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqF2; else goto cgqF3;
       cgqF2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqF3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgqEO_info;
           R2 = Data.Fixed.$fReadFixed3_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgqEO() //  [R1]
         { info_tbl: [(cgqEO,
                       label: block_cgqEO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqEO: // global
           I64[Sp] = block_cgqET_info;
           R2 = R1;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqET() //  [D1]
         { info_tbl: [(cgqET,
                       label: block_cgqET_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqET: // global
           _cgqEY::F64 = D1;
           (_cgqEX::F64) = call MO_F64_Log(_cgqEY::F64);
           I64[Sp - 8] = block_cgqF1_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgqEX::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqG6; else goto cgqF6;
       ugqG6: // global
           call _cgqF1(R1) args: 0, res: 0, upd: 0;
       cgqF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgqF1() //  [R1]
         { info_tbl: [(cgqF1,
                       label: block_cgqF1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqF1: // global
           _sgoDS::F64 = %MO_F_Neg_W64(%MO_F_Quot_W64(F64[Sp + 8],
                                                      F64[R1 + 7]));
           I64[Sp + 8] = block_cgqFh_info;
           D1 = _sgoDS::F64;
           Sp = Sp + 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 24;
     }
 },
 _cgqFh() //  [R1, R2]
         { info_tbl: [(cgqFh,
                       label: block_cgqFh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqFh: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cgqFr; else goto cgqG5;
       cgqFr: // global
           I64[Sp] = block_cgqFp_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
       cgqG5: // global
           _sgoDY::I64 = -R2;
           if (%MO_S_Le_W64(_sgoDY::I64, 52)) goto cgqFM; else goto cgqFU;
       cgqFM: // global
           I64[Sp - 8] = block_cgqFD_info;
           R2 = R1;
           I64[Sp] = _sgoDY::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
       cgqFU: // global
           I64[Sp] = block_cgqFT_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqFp() //  [R1]
         { info_tbl: [(cgqFp,
                       label: block_cgqFp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqFp: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgqFD() //  [R1]
         { info_tbl: [(cgqFD,
                       label: block_cgqFD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqFD: // global
           _sgoE1::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cgqFK_info;
           R2 = _sgoE1::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqFK() //  [R1]
         { info_tbl: [(cgqFK,
                       label: block_cgqFK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqFK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgqFT() //  [R1]
         { info_tbl: [(cgqFT,
                       label: block_cgqFT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqFT: // global
           if (R1 == 1) goto cgqG4; else goto cgqG0;
       cgqG4: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cgqG0: // global
           R1 = Data.Fixed.$fEnumFixed1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqI0_srtd" {
     ugqI0_srtd:
         const SgoHz_srt+120;
         const 57;
         const 76561193665298433;
 },
 sat_sgoE7_entry() //  [R1]
         { info_tbl: [(cgqGh,
                       label: sat_sgoE7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqGi; else goto cgqGj;
       cgqGi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqGj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgqGf_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugqI1_srtd" {
     ugqI1_srtd:
         const SgoHz_srt+120;
         const 53;
         const 4503599627370497;
 },
 _cgqGf() //  [R1]
         { info_tbl: [(cgqGf,
                       label: block_cgqGf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGf: // global
           R3 = R1;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoE5_entry() //  [R1]
         { info_tbl: [(cgqGr,
                       label: sat_sgoE5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqGs; else goto cgqGt;
       cgqGs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqGt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqI2_srtd" {
     ugqI2_srtd:
         const SgoHz_srt+120;
         const 75;
         const 76842668642009089;
         const 1028;
 },
 lvl18_sgoE4_entry() //  [R1]
         { info_tbl: [(cgqGu,
                       label: lvl18_sgoE4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGu: // global
           _sgoE4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgqGv; else goto cgqGw;
       cgqGw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgqGy; else goto cgqGx;
       cgqGy: // global
           HpAlloc = 48;
           goto cgqGv;
       cgqGv: // global
           R1 = _sgoE4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoE4::P64;
           _sgoDJ::P64 = P64[_sgoE4::P64 + 16];
           _sgoDL::P64 = P64[_sgoE4::P64 + 24];
           I64[Hp - 40] = sat_sgoE7_info;
           P64[Hp - 24] = _sgoDJ::P64;
           I64[Hp - 16] = sat_sgoE5_info;
           P64[Hp] = _sgoDJ::P64;
           R5 = _sgoDL::P64;
           R4 = Hp - 40;
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqI3_srtd" {
     ugqI3_srtd:
         const SgoHz_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 x_sgoEh_entry() //  [R1]
         { info_tbl: [(cgqH0,
                       label: x_sgoEh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqH0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgqH8; else goto cgqH9;
       cgqH8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgqGY_info;
           _sgoDK::P64 = P64[R1 + 24];
           R3 = _sgoDK::P64;
           R2 = P64[R1 + 48];
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = _sgoDK::P64;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 56;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugqI4_srtd" {
     ugqI4_srtd:
         const SgoHz_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 _cgqGY() //  [R1]
         { info_tbl: [(cgqGY,
                       label: block_cgqGY_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGY: // global
           _sgoDJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqH3_info;
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = _sgoDJ::P64;
           Sp = Sp + 8;
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugqI5_srtd" {
     ugqI5_srtd:
         const SgoHz_srt+16;
         const 66;
         const 1;
         const 2;
 },
 _cgqH3() //  [R1]
         { info_tbl: [(cgqH3,
                       label: block_cgqH3_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqH3: // global
           I64[Sp + 16] = block_cgqH7_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqH7() //  [R1]
         { info_tbl: [(cgqH7,
                       label: block_cgqH7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqH7: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEn_entry() //  [R1, R3]
         { info_tbl: [(cgqHl,
                       label: sat_sgoEn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqHl: // global
           R2 = P64[R1 + 6];
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEo_entry() //  [R1, R2]
         { info_tbl: [(cgqHs,
                       label: sat_sgoEo_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqHs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgqHt; else goto cgqHu;
       cgqHt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqHu: // global
           I64[Sp - 40] = block_cgqGE_info;
           _sgoDJ::P64 = P64[R1 + 7];
           _sgoDK::P64 = P64[R1 + 15];
           _sgoDL::P64 = P64[R1 + 23];
           _sgoE4::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgoDJ::P64;
           P64[Sp - 24] = _sgoDK::P64;
           P64[Sp - 16] = _sgoDL::P64;
           P64[Sp - 8] = _sgoE4::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugqHN; else goto cgqGF;
       ugqHN: // global
           call _cgqGE(R1) args: 0, res: 0, upd: 0;
       cgqGF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqGE() //  [R1]
         { info_tbl: [(cgqGE,
                       label: block_cgqGE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGE: // global
           if (R1 & 7 == 6) goto cgqHq; else goto ugqHI;
       cgqHq: // global
           I64[Sp] = block_cgqGK_info;
           R3 = P64[R1 + 2];
           R2 = P64[Sp + 24];
           call Text.Read.Lex.numberToFixed_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ugqHI: // global
           Sp = Sp + 40;
           call _cgqHB() args: 0, res: 0, upd: 0;
     }
 },
 _cgqGK() //  [R1]
         { info_tbl: [(cgqGK,
                       label: block_cgqGK_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGK: // global
           if (R1 & 7 == 1) goto ugqHJ; else goto cgqHD;
       ugqHJ: // global
           Sp = Sp + 40;
           call _cgqHB() args: 0, res: 0, upd: 0;
       cgqHD: // global
           I64[Sp] = block_cgqGP_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ugqHL; else goto cgqGQ;
       ugqHL: // global
           call _cgqGP(R1) args: 0, res: 0, upd: 0;
       cgqGQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqGP() //  [R1]
         { info_tbl: [(cgqGP,
                       label: block_cgqGP_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqGP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgqHG; else goto cgqHF;
       cgqHG: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqHF: // global
           _sgoEf::P64 = P64[R1 + 7];
           _sgoEg::P64 = P64[R1 + 15];
           I64[Hp - 64] = x_sgoEh_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgoEf::P64;
           P64[Hp - 16] = _sgoEg::P64;
           I64[Hp - 8] = sat_sgoEn_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgqHB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqHB: // global
           R1 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoE8_entry() //  [R1]
         { info_tbl: [(cgqHS,
                       label: sat_sgoE8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqHS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqHT; else goto cgqHU;
       cgqHT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqHU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqI6_srtd" {
     ugqI6_srtd:
         const SgoHz_srt+120;
         const 79;
         const 2382685677855703041;
         const 32740;
 },
 Data.Fixed.$fReadFixed1_entry() //  [R2]
         { info_tbl: [(cgqHV,
                       label: Data.Fixed.$fReadFixed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqHV: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgqHZ; else goto cgqHY;
       cgqHZ: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqHY: // global
           I64[Hp - 136] = lvl17_sgoDK_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = e_sgoDL_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = lvl18_sgoE4_info;
           P64[Hp - 72] = R2;
           _cgqEK::P64 = Hp - 112;
           P64[Hp - 64] = _cgqEK::P64;
           I64[Hp - 56] = sat_sgoEo_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = _cgqEK::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgoE8_info;
           P64[Hp] = R2;
           R3 = Hp - 55;
           R2 = Hp - 16;
           R1 = GHC.Read.readNumber1_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.426508236 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadsPrec_closure" {
     Data.Fixed.$fReadFixed_$creadsPrec_closure:
         const Data.Fixed.$fReadFixed_$creadsPrec_info;
         const 0;
 },
 ds_sgoEq_entry() //  [R1]
         { info_tbl: [(cgqK9,
                       label: ds_sgoEq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqK9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqKa; else goto cgqKb;
       cgqKa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqKb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEs_entry() //  [R1]
         { info_tbl: [(cgqKl,
                       label: sat_sgoEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqKl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqKm; else goto cgqKn;
       cgqKm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqKn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEt_entry() //  [R1, R2]
         { info_tbl: [(cgqKo,
                       label: sat_sgoEt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqKo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgqKs; else goto cgqKr;
       cgqKs: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqKr: // global
           _sgoEq::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgoEs_info;
           P64[Hp - 8] = _sgoEq::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cgqKt,
                       label: Data.Fixed.$fReadFixed_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqKt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgqKx; else goto cgqKw;
       cgqKx: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqKw: // global
           I64[Hp - 32] = ds_sgoEq_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sgoEt_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.43617055 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadListPrec_closure" {
     Data.Fixed.$fReadFixed_$creadListPrec_closure:
         const Data.Fixed.$fReadFixed_$creadListPrec_info;
         const 0;
 },
 sat_sgoEv_entry() //  [R1]
         { info_tbl: [(cgqKX,
                       label: sat_sgoEv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqKX: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cgqL0,
                       label: Data.Fixed.$fReadFixed_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqL0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqL4; else goto cgqL3;
       cgqL4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqL3: // global
           I64[Hp - 16] = sat_sgoEv_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.44306367 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadList_closure" {
     Data.Fixed.$fReadFixed_$creadList_closure:
         const Data.Fixed.$fReadFixed_$creadList_info;
         const 0;
 },
 sat_sgoEx_entry() //  [R1]
         { info_tbl: [(cgqLo,
                       label: sat_sgoEx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqLo: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEy_entry() //  [R1]
         { info_tbl: [(cgqLr,
                       label: sat_sgoEy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqLr: // global
           _sgoEy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgqLs; else goto cgqLt;
       cgqLt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqLv; else goto cgqLu;
       cgqLv: // global
           HpAlloc = 24;
           goto cgqLs;
       cgqLs: // global
           R1 = _sgoEy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqLu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgoEy::P64;
           _sgoEw::P64 = P64[_sgoEy::P64 + 16];
           I64[Hp - 16] = sat_sgoEx_info;
           P64[Hp] = _sgoEw::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_$creadList_entry() //  [R2]
         { info_tbl: [(cgqLw,
                       label: Data.Fixed.$fReadFixed_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqLw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqLA; else goto cgqLz;
       cgqLA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqLz: // global
           I64[Hp - 16] = sat_sgoEy_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.451094552 UTC

[section ""data" . Data.Fixed.$fReadFixed_closure" {
     Data.Fixed.$fReadFixed_closure:
         const Data.Fixed.$fReadFixed_info;
         const 0;
 },
 sat_sgoED_entry() //  [R1]
         { info_tbl: [(cgqLU,
                       label: sat_sgoED_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqLU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqLV; else goto cgqLW;
       cgqLV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqLW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEC_entry() //  [R1]
         { info_tbl: [(cgqM1,
                       label: sat_sgoEC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqM1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqM2; else goto cgqM3;
       cgqM2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqM3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEB_entry() //  [R1]
         { info_tbl: [(cgqM8,
                       label: sat_sgoEB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqM8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqM9; else goto cgqMa;
       cgqM9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqMa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoEA_entry() //  [R1]
         { info_tbl: [(cgqMf,
                       label: sat_sgoEA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqMf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqMg; else goto cgqMh;
       cgqMg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqMh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_entry() //  [R2]
         { info_tbl: [(cgqMj,
                       label: Data.Fixed.$fReadFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqMj: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgqMn; else goto cgqMm;
       cgqMn: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqMm: // global
           I64[Hp - 128] = sat_sgoED_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgoEC_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgoEB_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoEA_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.462266129 UTC

[section ""data" . Data.Fixed.$fEqFixed_closure" {
     Data.Fixed.$fEqFixed_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.464080431 UTC

[section ""data" . Data.Fixed.$fOrdFixed_closure" {
     Data.Fixed.$fOrdFixed_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Fixed.$fEqFixed_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.466535109 UTC

[section ""data" . Data.Fixed.$fRealFixed_closure" {
     Data.Fixed.$fRealFixed_closure:
         const Data.Fixed.$fRealFixed_info;
         const 0;
 },
 sat_sgoEG_entry() //  [R1, R2]
         { info_tbl: [(cgqMY,
                       label: sat_sgoEG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqMY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fRealFixed_$ctoRational_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoEF_entry() //  [R1]
         { info_tbl: [(cgqN5,
                       label: sat_sgoEF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqN5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqN6; else goto cgqN7;
       cgqN6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fRealFixed_entry() //  [R2]
         { info_tbl: [(cgqN9,
                       label: Data.Fixed.$fRealFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqN9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgqNd; else goto cgqNc;
       cgqNd: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqNc: // global
           I64[Hp - 64] = sat_sgoEG_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sgoEF_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Data.Fixed.$fOrdFixed_closure+1;
           P64[Hp] = Hp - 63;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.47450285 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$ctruncate_closure" {
     Data.Fixed.$fRealFracFixed_$ctruncate_closure:
         const Data.Fixed.$fRealFracFixed_$ctruncate_info;
         const 0;
 },
 sat_sgoEV_entry() //  [R1]
         { info_tbl: [(cgqNL,
                       label: sat_sgoEV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgqNM; else goto cgqNN;
       cgqNM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqNN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgqNG_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoEN::P64 = P64[R1 + 24];
           R2 = _sgoEN::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _sgoEN::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqNG() //  [R1]
         { info_tbl: [(cgqNG,
                       label: block_cgqNG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNG: // global
           if (R1 == 1) goto cgqNK; else goto cgqNJ;
       cgqNK: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgqNJ: // global
           _sgoEN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgqNQ_info;
           R3 = _sgoEN::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqNQ() //  [R1]
         { info_tbl: [(cgqNQ,
                       label: block_cgqNQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNQ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqOe_srtd" {
     ugqOe_srtd:
         const SgoHz_srt+464;
         const 43;
         const 4399120386049;
 },
 Data.Fixed.$fRealFracFixed_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqNX,
                       label: Data.Fixed.$fRealFracFixed_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqO3; else goto cgqO4;
       cgqO3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqO4: // global
           I64[Sp - 24] = block_cgqNw_info;
           _sgoEH::P64 = R2;
           R2 = R4;
           R1 = _sgoEH::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqNw() //  [R1]
         { info_tbl: [(cgqNw,
                       label: block_cgqNw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNw: // global
           I64[Sp] = block_cgqNA_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqNA() //  [R1, R2]
         { info_tbl: [(cgqNA,
                       label: block_cgqNA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgqO8; else goto cgqO7;
       cgqO8: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqO7: // global
           I64[Hp - 24] = sat_sgoEV_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           _sgoEI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqNY_info;
           R2 = _sgoEI::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqNY() //  [R1]
         { info_tbl: [(cgqNY,
                       label: block_cgqNY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqNY: // global
           I64[Sp] = block_cgqO2_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqO2() //  [R1]
         { info_tbl: [(cgqO2,
                       label: block_cgqO2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqO2: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.491420832 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cround_closure" {
     Data.Fixed.$fRealFracFixed_$cround_closure:
         const Data.Fixed.$fRealFracFixed_$cround_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqOR,
                       label: Data.Fixed.$fRealFracFixed_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqOR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqOV; else goto cgqOW;
       cgqOV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqOW: // global
           I64[Sp - 24] = block_cgqOP_info;
           _sgoEW::P64 = R2;
           R2 = R4;
           R1 = _sgoEW::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqOP() //  [R1]
         { info_tbl: [(cgqOP,
                       label: block_cgqOP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqOP: // global
           I64[Sp] = block_cgqOU_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqOU() //  [R1, R2]
         { info_tbl: [(cgqOU,
                       label: block_cgqOU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqOU: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.498657479 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cceiling_closure" {
     Data.Fixed.$fRealFracFixed_$cceiling_closure:
         const Data.Fixed.$fRealFracFixed_$cceiling_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqPh,
                       label: Data.Fixed.$fRealFracFixed_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqPh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqPl; else goto cgqPm;
       cgqPl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqPm: // global
           I64[Sp - 24] = block_cgqPf_info;
           _sgoF3::P64 = R2;
           R2 = R4;
           R1 = _sgoF3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqPf() //  [R1]
         { info_tbl: [(cgqPf,
                       label: block_cgqPf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqPf: // global
           I64[Sp] = block_cgqPk_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqPk() //  [R1, R2]
         { info_tbl: [(cgqPk,
                       label: block_cgqPk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqPk: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.506053025 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cfloor_closure" {
     Data.Fixed.$fRealFracFixed_$cfloor_closure:
         const Data.Fixed.$fRealFracFixed_$cfloor_info;
         const 0;
 },
 section ""relreadonly" . ugqPQ_srtd" {
     ugqPQ_srtd:
         const SgoHz_srt+472;
         const 49;
         const 334251534843905;
 },
 Data.Fixed.$fRealFracFixed_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqPH,
                       label: Data.Fixed.$fRealFracFixed_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqPH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgqPL; else goto cgqPM;
       cgqPL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqPM: // global
           I64[Sp - 24] = block_cgqPF_info;
           _sgoFa::P64 = R2;
           R2 = R4;
           R1 = _sgoFa::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqPR_srtd" {
     ugqPR_srtd:
         const SgoHz_srt+472;
         const 46;
         const 52776558133249;
 },
 _cgqPF() //  [R1]
         { info_tbl: [(cgqPF,
                       label: block_cgqPF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqPF: // global
           I64[Sp] = block_cgqPK_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqPK() //  [R1, R2]
         { info_tbl: [(cgqPK,
                       label: block_cgqPK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqPK: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.515496657 UTC

[section ""data" . Data.Fixed.$w$cproperFraction_closure" {
     Data.Fixed.$w$cproperFraction_closure:
         const Data.Fixed.$w$cproperFraction_info;
         const 0;
 },
 i_sgoFk_entry() //  [R1]
         { info_tbl: [(cgqQd,
                       label: i_sgoFk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqQd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqQe; else goto cgqQf;
       cgqQe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqQf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoFo_entry() //  [R1]
         { info_tbl: [(cgqQm,
                       label: sat_sgoFo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqQm: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgqQu; else goto cgqQv;
       cgqQu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cgqQk_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           _sgoFi::P64 = P64[R1 + 24];
           _sgoFj::P64 = P64[R1 + 32];
           _sgoFk::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _sgoFi::P64;
           P64[Sp - 32] = _sgoFj::P64;
           P64[Sp - 24] = _sgoFk::P64;
           Sp = Sp - 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgqQk() //  [R1]
         { info_tbl: [(cgqQk,
                       label: block_cgqQk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqQk: // global
           _sgoFi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgqQp_info;
           R2 = _sgoFi::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgqQp() //  [R1]
         { info_tbl: [(cgqQp,
                       label: block_cgqQp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqQp: // global
           I64[Sp] = block_cgqQt_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqQt() //  [R1]
         { info_tbl: [(cgqQt,
                       label: block_cgqQt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqQt: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqQC,
                       label: Data.Fixed.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqQC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgqQG; else goto cgqQF;
       cgqQG: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqQF: // global
           I64[Hp - 80] = i_sgoFk_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgoFo_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           _cgqQ9::P64 = Hp - 80;
           P64[Hp] = _cgqQ9::P64;
           R2 = Hp - 40;
           R1 = _cgqQ9::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.528757436 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cproperFraction_closure" {
     Data.Fixed.$fRealFracFixed_$cproperFraction_closure:
         const Data.Fixed.$fRealFracFixed_$cproperFraction_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cproperFraction_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cgqRb,
                       label: Data.Fixed.$fRealFracFixed_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqRb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgqRc; else goto cgqRd;
       cgqRc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqRd: // global
           I64[Sp - 8] = block_cgqR8_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$w$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqR8() //  [R1, R2]
         { info_tbl: [(cgqR8,
                       label: block_cgqR8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqR8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqRg; else goto cgqRf;
       cgqRg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqRf: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.535338085 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_closure" {
     Data.Fixed.$fRealFracFixed_closure:
         const Data.Fixed.$fRealFracFixed_info;
         const 0;
 },
 sat_sgoFC_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqRz,
                       label: sat_sgoFC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqRz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cfloor_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFB_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqRH,
                       label: sat_sgoFB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqRH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cceiling_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqRP,
                       label: sat_sgoFA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqRP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cround_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFz_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqRX,
                       label: sat_sgoFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqRX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFy_entry() //  [R1, R2, R3]
         { info_tbl: [(cgqS5,
                       label: sat_sgoFy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqS5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cproperFraction_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoFx_entry() //  [R1]
         { info_tbl: [(cgqSc,
                       label: sat_sgoFx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqSc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqSd; else goto cgqSe;
       cgqSd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqSe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fFractionalFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoFw_entry() //  [R1]
         { info_tbl: [(cgqSj,
                       label: sat_sgoFw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqSj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqSk; else goto cgqSl;
       cgqSk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqSl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqSs_srtd" {
     ugqSs_srtd:
         const SgoHz_srt+656;
         const 33;
         const 6494224385;
 },
 Data.Fixed.$fRealFracFixed_entry() //  [R2]
         { info_tbl: [(cgqSn,
                       label: Data.Fixed.$fRealFracFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqSn: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cgqSr; else goto cgqSq;
       cgqSr: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqSq: // global
           I64[Hp - 184] = sat_sgoFC_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sgoFB_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgoFA_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgoFz_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgoFy_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgoFx_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgoFw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.553640724 UTC

[section ""data" . chopZeros_rgnn4_closure" {
     chopZeros_rgnn4_closure:
         const chopZeros_rgnn4_info;
         const 0;
 },
 section ""relreadonly" . ugqTK_srtd" {
     ugqTK_srtd:
         const SgoHz_srt+120;
         const 103;
         const 576460752303423489;
         const 481036337664;
 },
 chopZeros_rgnn4_entry() //  [R2]
         { info_tbl: [(cgqTc,
                       label: chopZeros_rgnn4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqTc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqTd; else goto ugqTG;
       cgqTd: // global
           R2 = R2;
           R1 = chopZeros_rgnn4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ugqTG: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cgqT4() args: 0, res: 0, upd: 0;
     }
 },
 _cgqT4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqT4: // global
           I64[Sp - 8] = block_cgqT7_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqTL_srtd" {
     ugqTL_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgqT7() //  [R1]
         { info_tbl: [(cgqT7,
                       label: block_cgqT7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqT7: // global
           if (R1 == 1) goto cgqTb; else goto cgqTa;
       cgqTb: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgqTa: // global
           I64[Sp] = block_cgqTh_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqTM_srtd" {
     ugqTM_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgqTh() //  [R1]
         { info_tbl: [(cgqTh,
                       label: block_cgqTh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqTh: // global
           I64[Sp] = block_cgqTm_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqTN_srtd" {
     ugqTN_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgqTm() //  [R1]
         { info_tbl: [(cgqTm,
                       label: block_cgqTm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqTm: // global
           _sgoFD::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgqTy; else goto cgqTt;
       cgqTy: // global
           I64[Sp + 8] = block_cgqTw_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = _sgoFD::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cgqTt: // global
           R2 = _sgoFD::P64;
           Sp = Sp + 16;
           call GHC.Show.$fShowInteger_$cshow_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugqTO_srtd" {
     ugqTO_srtd:
         const SgoHz_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgqTw() //  [R1]
         { info_tbl: [(cgqTw,
                       label: block_cgqTw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqTw: // global
           P64[Sp] = R1;
           call _cgqT4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.56745665 UTC

[section ""data" . lvl14_rgoyT_closure" {
     lvl14_rgoyT_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.569096554 UTC

[section ""data" . lvl15_rgoyU_closure" {
     lvl15_rgoyU_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.570847002 UTC

[section ""cstring" . lvl16_rgoyV_bytes" {
     lvl16_rgoyV_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.576555415 UTC

[section ""data" . Data.Fixed.showFixed_closure" {
     Data.Fixed.showFixed_closure:
         const Data.Fixed.showFixed_info;
         const 0;
 },
 n1_sgoGj_entry() //  [R1]
         { info_tbl: [(cgqVI,
                       label: n1_sgoGj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqVI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgqVJ; else goto cgqVK;
       cgqVJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqVK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgqVB_info;
           _sgoG5::P64 = P64[R1 + 24];
           _sgoGb::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sgoG5::P64;
           P64[Sp - 24] = _sgoGb::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugqVR; else goto cgqVC;
       ugqVR: // global
           call _cgqVB(R1) args: 0, res: 0, upd: 0;
       cgqVC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgqVB() //  [R1]
         { info_tbl: [(cgqVB,
                       label: block_cgqVB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqVB: // global
           if (R1 & 7 == 1) goto cgqVF; else goto cgqVG;
       cgqVF: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cgqVG: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call chopZeros_rgnn4_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgoGq_entry() //  [R1]
         { info_tbl: [(cgqW6,
                       label: sat_sgoGq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqW6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgqW7; else goto cgqW8;
       cgqW7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqW8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sgoGm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sgoGm_entry() //  [R1, R2]
         { info_tbl: [(cgqWc,
                       label: $wxs_sgoGm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqWc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgqWg; else goto cgqWf;
       cgqWg: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqWf: // global
           if (R2 == 1) goto cgqWb; else goto cgqWa;
       cgqWb: // global
           _sgoGl::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sgoGl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgqWa: // global
           I64[Hp - 48] = sat_sgoGq_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rgoyT_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugqZz_srtd" {
     ugqZz_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 sat_sgoGK_entry() //  [R1]
         { info_tbl: [(cgqWi,
                       label: sat_sgoGK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqWi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgqWj; else goto cgqWk;
       cgqWj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqWk: // global
           I64[Sp - 32] = block_cgqUF_info;
           _sgoFM::P64 = P64[R1 + 24];
           R2 = _sgoFM::P64;
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = _sgoFM::P64;
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 32;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZA_srtd" {
     ugqZA_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgqUF() //  [D1]
         { info_tbl: [(cgqUF,
                       label: block_cgqUF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUF: // global
           _cgqUK::F64 = D1;
           (_cgqUJ::F64) = call MO_F64_Log(_cgqUK::F64);
           I64[Sp - 8] = block_cgqUN_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgqUJ::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqYO; else goto cgqUO;
       ugqYO: // global
           call _cgqUN(R1) args: 0, res: 0, upd: 0;
       cgqUO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZB_srtd" {
     ugqZB_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835136;
 },
 _cgqUN() //  [R1]
         { info_tbl: [(cgqUN,
                       label: block_cgqUN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUN: // global
           _sgoFQ::P64 = P64[Sp + 32];
           _sgoFZ::F64 = %MO_F_Quot_W64(F64[Sp + 8], F64[R1 + 7]);
           _sgoG0::I64 = %MO_FS_Conv_W64_W64(_sgoFZ::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_sgoG0::I64),
                            _sgoFZ::F64)) goto cgqYz; else goto cgqYy;
       cgqYz: // global
           _sgoG2::I64 = _sgoG0::I64 + 1;
           goto sgoG1;
       cgqYy: // global
           _sgoG2::I64 = _sgoG0::I64;
           goto sgoG1;
       sgoG1: // global
           if (%MO_S_Ge_W64(_sgoG2::I64, 0)) goto cgqYt; else goto cgqYu;
       cgqYt: // global
           if (_sgoG2::I64 == 0) goto cgqYk; else goto cgqXX;
       cgqYk: // global
           I64[Sp + 8] = block_cgqY7_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgoFQ::P64;
           I64[Sp + 32] = _sgoG2::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cgqXX: // global
           I64[Sp] = block_cgqXF_info;
           R3 = _sgoG2::I64;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           I64[Sp + 8] = _sgoG2::I64;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 8, upd: 8;
       cgqYu: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugqZC_srtd" {
     ugqZC_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgqY7() //  [R1]
         { info_tbl: [(cgqY7,
                       label: block_cgqY7_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqY7: // global
           I64[Sp] = block_cgqYb_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZD_srtd" {
     ugqZD_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgqYb() //  [R1]
         { info_tbl: [(cgqYb,
                       label: block_cgqYb_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqYb: // global
           I64[Sp] = block_cgqYf_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZE_srtd" {
     ugqZE_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgqYf() //  [R1]
         { info_tbl: [(cgqYf,
                       label: block_cgqYf_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqYf: // global
           I64[Sp] = block_cgqYj_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqYj() //  [R1]
         { info_tbl: [(cgqYj,
                       label: block_cgqYj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqYj: // global
           I64[Sp] = I64[Sp + 24];
           P64[Sp + 24] = R1;
           call _sgoG4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ugqZF_srtd" {
     ugqZF_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26594437586945;
 },
 _cgqXF() //  [R1]
         { info_tbl: [(cgqXF,
                       label: block_cgqXF_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXF: // global
           I64[Sp] = block_cgqXJ_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZG_srtd" {
     ugqZG_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgqXJ() //  [R1]
         { info_tbl: [(cgqXJ,
                       label: block_cgqXJ_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXJ: // global
           I64[Sp] = block_cgqXN_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZH_srtd" {
     ugqZH_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgqXN() //  [R1]
         { info_tbl: [(cgqXN,
                       label: block_cgqXN_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXN: // global
           I64[Sp] = block_cgqXR_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZI_srtd" {
     ugqZI_srtd:
         const SgoHz_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgqXR() //  [R1]
         { info_tbl: [(cgqXR,
                       label: block_cgqXR_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXR: // global
           I64[Sp] = block_cgqXV_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqXV() //  [R1]
         { info_tbl: [(cgqXV,
                       label: block_cgqXV_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXV: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _sgoG4() args: 0, res: 0, upd: 0;
     }
 },
 _sgoG4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgoG4: // global
           I64[Sp - 8] = block_cgqWo_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugqYX; else goto cgqXh;
       ugqYX: // global
           call _cgqWo(R1) args: 0, res: 0, upd: 0;
       cgqXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqWo() //  [R1]
         { info_tbl: [(cgqWo,
                       label: block_cgqWo_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqWo: // global
           if (R1 & 7 == 1) goto ugqYJ; else goto cgqXs;
       ugqYJ: // global
           Sp = Sp + 8;
           call _sgoG6() args: 0, res: 0, upd: 0;
       cgqXs: // global
           I64[Sp] = block_cgqXq_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqXq() //  [R1]
         { info_tbl: [(cgqXq,
                       label: block_cgqXq_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXq: // global
           if (R1 == 1) goto ugqYK; else goto ugqYL;
       ugqYK: // global
           Sp = Sp + 40;
           call _cgqXC() args: 0, res: 0, upd: 0;
       ugqYL: // global
           Sp = Sp + 8;
           call _sgoG6() args: 0, res: 0, upd: 0;
     }
 },
 _sgoG6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgoG6: // global
           I64[Sp - 8] = block_cgqVj_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[Sp + 24];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqVj() //  [R1, R2]
         { info_tbl: [(cgqVj,
                       label: block_cgqVj_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqVj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqWt; else goto cgqWs;
       cgqWt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqWs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           I64[Sp] = block_cgqVm_info;
           R3 = 0;
           _cgqVl::P64 = Hp - 14;
           R2 = _cgqVl::P64;
           P64[Sp + 24] = _cgqVl::P64;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqVm() //  [R1]
         { info_tbl: [(cgqVm,
                       label: block_cgqVm_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqVm: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgqWw; else goto cgqWv;
       cgqWw: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgqWv: // global
           _sgoFJ::P64 = P64[Sp + 16];
           _sgoGd::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sgoGd::I64)) goto cgqWz; else goto cgqX3;
       cgqWz: // global
           Hp = Hp - 80;
           I64[Sp + 16] = block_cgqWx_info;
           R1 = _sgoFJ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ugqYP; else goto cgqWA;
       ugqYP: // global
           call _cgqWx(R1) args: 0, res: 0, upd: 0;
       cgqWA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cgqX3: // global
           I64[Hp - 72] = n1_sgoGj_info;
           P64[Hp - 56] = _sgoFJ::P64;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = lvl14_rgoyT_closure+1;
           P64[Hp - 16] = Hp - 72;
           I64[Hp - 8] = $wxs_sgoGm_info;
           P64[Hp] = Hp - 30;
           I64[Sp + 32] = block_cgqX2_info;
           R2 = _sgoGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call $wxs_sgoGm_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgqWx() //  [R1]
         { info_tbl: [(cgqWx,
                       label: block_cgqWx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqWx: // global
           if (R1 & 7 == 1) goto cgqWG; else goto cgqWO;
       cgqWG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqWJ; else goto cgqWI;
       cgqWJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqWI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgqWO: // global
           _sgoG5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgqWM_info;
           R2 = _sgoG5::P64;
           Sp = Sp + 16;
           call chopZeros_rgnn4_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqWM() //  [R1]
         { info_tbl: [(cgqWM,
                       label: block_cgqWM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqWM: // global
           if (R1 & 7 == 1) goto ugqYM; else goto cgqWY;
       ugqYM: // global
           Sp = Sp + 8;
           call _cgqXC() args: 0, res: 0, upd: 0;
       cgqWY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqX1; else goto cgqX0;
       cgqX1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqX0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgqX2() //  [R1]
         { info_tbl: [(cgqX2,
                       label: block_cgqX2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqX2: // global
           if (R1 & 7 == 1) goto ugqYN; else goto cgqXd;
       ugqYN: // global
           Sp = Sp + 8;
           call _cgqXC() args: 0, res: 0, upd: 0;
       cgqXd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqXg; else goto cgqXf;
       cgqXg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgqXf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgqXC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqXC: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoGN_entry() //  [R1]
         { info_tbl: [(cgqZ6,
                       label: sat_sgoGN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqZ6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgqZ7; else goto cgqZ8;
       cgqZ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgqZ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgqZ4_info;
           R2 = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgqZ4() //  [R1]
         { info_tbl: [(cgqZ4,
                       label: block_cgqZ4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqZ4: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugqZJ_srtd" {
     ugqZJ_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 Data.Fixed.showFixed_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqZf,
                       label: Data.Fixed.showFixed_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqZf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgqZg; else goto cgqZh;
       cgqZg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.showFixed_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqZh: // global
           I64[Sp - 32] = block_cgqUl_info;
           _sgoFJ::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgoFI::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgoFI::P64;
           P64[Sp - 16] = _sgoFJ::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZK_srtd" {
     ugqZK_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 _cgqUl() //  [R1]
         { info_tbl: [(cgqUl,
                       label: block_cgqUl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUl: // global
           _sgoFI::P64 = P64[Sp + 8];
           _sgoFK::P64 = P64[Sp + 24];
           if (R1 == 1) goto cgqZe; else goto cgqZd;
       cgqZe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgqZy; else goto cgqZx;
       cgqZy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgqZx: // global
           I64[Hp - 32] = sat_sgoGN_info;
           P64[Hp - 16] = _sgoFI::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgoFK::P64;
           R3 = Hp - 32;
           R2 = lvl16_rgoyV_bytes;
           Sp = Sp + 32;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cgqZd: // global
           I64[Sp + 8] = block_cgqUp_info;
           R2 = _sgoFK::P64;
           R1 = _sgoFI::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZL_srtd" {
     ugqZL_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgqUp() //  [R1]
         { info_tbl: [(cgqUp,
                       label: block_cgqUp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUp: // global
           I64[Sp - 8] = block_cgqUt_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZM_srtd" {
     ugqZM_srtd:
         const SgoHz_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgqUt() //  [R1]
         { info_tbl: [(cgqUt,
                       label: block_cgqUt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUt: // global
           if (R1 == 1) goto cgqZv; else goto cgqZn;
       cgqZv: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgqZn: // global
           I64[Sp] = block_cgqUx_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZN_srtd" {
     ugqZN_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgqUx() //  [R1, R2]
         { info_tbl: [(cgqUx,
                       label: block_cgqUx_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUx: // global
           I64[Sp] = block_cgqUz_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           _sgoFQ::P64 = R2;
           R2 = 0;
           P64[Sp + 24] = _sgoFQ::P64;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugqZO_srtd" {
     ugqZO_srtd:
         const SgoHz_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgqUz() //  [R1, R2]
         { info_tbl: [(cgqUz,
                       label: block_cgqUz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqUz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgqZr; else goto cgqZq;
       cgqZr: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqZq: // global
           I64[Hp - 56] = sat_sgoGK_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 56;
           R2 = Hp - 14;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.654905986 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshow_closure" {
     Data.Fixed.$fShowFixed_$cshow_closure:
         const Data.Fixed.$fShowFixed_$cshow_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cgr2x,
                       label: Data.Fixed.$fShowFixed_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr2x: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.659530962 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowsPrec_closure" {
     Data.Fixed.$fShowFixed_$cshowsPrec_closure:
         const Data.Fixed.$fShowFixed_$cshowsPrec_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgr2K,
                       label: Data.Fixed.$fShowFixed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr2K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgr2L; else goto cgr2M;
       cgr2L: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgr2M: // global
           I64[Sp - 16] = block_cgr2I_info;
           R4 = R4;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgr2I() //  [R1]
         { info_tbl: [(cgr2I,
                       label: block_cgr2I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr2I: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.6663335 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowList_closure" {
     Data.Fixed.$fShowFixed_$cshowList_closure:
         const Data.Fixed.$fShowFixed_$cshowList_info;
         const 0;
 },
 sat_sgoH0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgr39,
                       label: sat_sgoH0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr39: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgr3a; else goto cgr3b;
       cgr3a: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgr3b: // global
           I64[Sp - 16] = block_cgr37_info;
           R4 = R2;
           _sgoGY::P64 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sgoGY::P64;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgr37() //  [R1]
         { info_tbl: [(cgr37,
                       label: block_cgr37_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr37: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cgr3f,
                       label: Data.Fixed.$fShowFixed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr3f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgr3j; else goto cgr3i;
       cgr3j: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgr3i: // global
           I64[Hp - 8] = sat_sgoH0_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.674906153 UTC

[section ""data" . Data.Fixed.$fShowFixed_closure" {
     Data.Fixed.$fShowFixed_closure:
         const Data.Fixed.$fShowFixed_info;
         const 0;
 },
 sat_sgoH4_entry() //  [R1, R2, R3]
         { info_tbl: [(cgr3E,
                       label: sat_sgoH4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr3E: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fShowFixed_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoH3_entry() //  [R1, R2]
         { info_tbl: [(cgr3M,
                       label: sat_sgoH3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr3M: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fShowFixed_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgoH2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgr3U,
                       label: sat_sgoH2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr3U: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fShowFixed_$cshowsPrec_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_entry() //  [R2]
         { info_tbl: [(cgr3Y,
                       label: Data.Fixed.$fShowFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr3Y: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgr42; else goto cgr41;
       cgr42: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgr41: // global
           I64[Hp - 72] = sat_sgoH4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgoH3_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgoH2_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:19.683753471 UTC

[section ""relreadonly" . SgoHz_srt" {
     SgoHz_srt:
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const sat_sgozk_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
         const Data.Fixed.$fEnumFixed3_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const Data.Fixed.$fHasResolutionE0_$cresolution_closure;
         const sat_sgozK_closure;
         const Data.Fixed.$fHasResolutionE4_closure;
         const Data.Fixed.$fHasResolutionE1_$cresolution_closure;
         const sat_sgozN_closure;
         const Data.Fixed.$fHasResolutionE7_closure;
         const Data.Fixed.$fHasResolutionE2_$cresolution_closure;
         const sat_sgozQ_closure;
         const Data.Fixed.$fHasResolutionE8_closure;
         const Data.Fixed.$fHasResolutionE3_$cresolution_closure;
         const sat_sgozT_closure;
         const Data.Fixed.$fHasResolutionE10_closure;
         const Data.Fixed.$fHasResolutionE6_$cresolution_closure;
         const sat_sgozW_closure;
         const Data.Fixed.$fHasResolutionE11_closure;
         const Data.Fixed.$fHasResolutionE9_$cresolution_closure;
         const sat_sgoA1_closure;
         const Data.Fixed.$fHasResolutionE5_closure;
         const Data.Fixed.$fHasResolutionE12_$cresolution_closure;
         const GHC.List.badHead_closure;
         const w2_rgoyl_closure;
         const go61_rgoym_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Fixed.$fDataFixed4_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Fixed.$fDataFixed8_closure;
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$w$cgmapMp_closure;
         const Data.Fixed.$w$cgmapM_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Fixed.$fDataFixed_$cgmapQi_closure;
         const Data.Fixed.$w$cgmapMo_closure;
         const Data.Fixed.conMkFixed_closure;
         const Data.Fixed.tyFixed_closure;
         const lvl5_rgoyK_closure;
         const lvl6_rgoyL_closure;
         const lvl7_rgoyM_closure;
         const lvl8_rgoyN_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const Data.Fixed.$fDataFixed7_closure;
         const Data.Fixed.$fDataFixed_closure;
         const lvl_rgoyF_closure;
         const lvl1_rgoyG_closure;
         const lvl4_rgoyJ_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.div'_closure;
         const Data.Fixed.$wdivMod'_closure;
         const Data.Fixed.divMod'_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Data.Fixed.mod'_closure;
         const GHC.Err.undefined_closure;
         const $dIP3_rgoyz_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Fixed.$w$cfromRational_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const Data.Fixed.$fFractionalFixed1_closure;
         const Data.Fixed.$fRealFixed_$ctoRational_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const Data.Fixed.$fFractionalFixed3_closure;
         const Data.Fixed.$fFractionalFixed_$crecip_closure;
         const Data.Fixed.$fNumFixed_$c*_closure;
         const Data.Fixed.$fNumFixed1_closure;
         const Data.Fixed.$fNumFixed2_closure;
         const Data.Fixed.$fNumFixed_closure;
         const Data.Fixed.$fFractionalFixed_closure;
         const lvl13_rgoyS_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const Data.Fixed.$fReadFixed2_closure;
         const Data.Fixed.$fReadFixed3_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const GHC.Real.^_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Text.Read.Lex.numberToFixed_closure;
         const GHC.Read.readNumber1_closure;
         const Data.Fixed.$fReadFixed1_closure;
         const Data.Fixed.$fReadFixed_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Fixed.$fReadFixed_$creadListPrec_closure;
         const Data.Fixed.$fReadFixed_$creadList_closure;
         const Data.Fixed.$fReadFixed_closure;
         const Data.Fixed.$fRealFixed_closure;
         const Data.Fixed.$fRealFracFixed_$ctruncate_closure;
         const GHC.Real.$w$s$cround_closure;
         const Data.Fixed.$fRealFracFixed_$cround_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cfloor_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$w$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Show.$fShowInteger_$cshow_closure;
         const chopZeros_rgnn4_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$wf_closure;
         const Data.Fixed.showFixed_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const Data.Fixed.$fShowFixed_$cshowsPrec_closure;
         const Data.Fixed.$fShowFixed_$cshowList_closure;
         const Data.Fixed.$fShowFixed_$cshow_closure;
         const Data.Fixed.$fShowFixed_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.576490456 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:12:22.578689353 UTC

[section ""data" . Data.Fixed.resolution_closure" {
     Data.Fixed.resolution_closure:
         const Data.Fixed.resolution_info;
 },
 Data.Fixed.resolution_entry() //  [R2]
         { info_tbl: [(cgrcx,
                       label: Data.Fixed.resolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrcx: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.584369236 UTC

[section ""data" . Data.Fixed.$fDataFixed2_closure" {
     Data.Fixed.$fDataFixed2_closure:
         const Data.Fixed.$fDataFixed2_info;
 },
 Data.Fixed.$fDataFixed2_entry() //  [R2]
         { info_tbl: [(cgrcI,
                       label: Data.Fixed.$fDataFixed2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrcI: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.590313518 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgfoldl_closure" {
     Data.Fixed.$fDataFixed_$cgfoldl_closure:
         const Data.Fixed.$fDataFixed_$cgfoldl_info;
         const 0;
 },
 sat_sgr4r_entry() //  [R1]
         { info_tbl: [(cgrcZ,
                       label: sat_sgr4r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrcZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrd0; else goto cgrd1;
       cgrd0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrd1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_$cgfoldl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrd2,
                       label: Data.Fixed.$fDataFixed_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrd2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrd6; else goto cgrd5;
       cgrd6: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgfoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrd5: // global
           I64[Hp - 16] = sat_sgr4r_info;
           P64[Hp] = R4;
           R4 = R5;
           _sgr4o::P64 = R3;
           R3 = Hp - 16;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgr4o::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.599847158 UTC

[section ""data" . Data.Fixed.$fEnumFixed1_closure" {
     Data.Fixed.$fEnumFixed1_closure:
         const Data.Fixed.$fEnumFixed1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed1_entry() //  [R1]
         { info_tbl: [(cgrdo,
                       label: Data.Fixed.$fEnumFixed1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrdo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrdp; else goto cgrdq;
       cgrdp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrdq: // global
           (_cgrdl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrdl::I64 == 0) goto cgrdn; else goto cgrdm;
       cgrdn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrdm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrdl::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.610816157 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_info;
         const 0;
 },
 sat_sgr4B_entry() //  [R1]
         { info_tbl: [(cgre2,
                       label: sat_sgr4B_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgre2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgre3; else goto cgre4;
       cgre3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgre4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgre0_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgre0() //  [R1]
         { info_tbl: [(cgre0,
                       label: block_cgre0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgre0: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgr4x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgr4x_entry() //  [R1, R2]
         { info_tbl: [(cgreb,
                       label: go_sgr4x_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgreb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrec; else goto cgred;
       cgrec: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgred: // global
           I64[Sp - 32] = block_cgrdS_info;
           R3 = P64[R1 + 7];
           _sgr4y::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgr4y::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrdS() //  [R1]
         { info_tbl: [(cgrdS,
                       label: block_cgrdS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrdS: // global
           if (R1 == 1) goto cgrea; else goto cgre9;
       cgrea: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgre9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgreh; else goto cgreg;
       cgreh: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgreg: // global
           I64[Hp - 56] = sat_sgr4B_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgr4y::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgr4y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgr4y::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr4G_entry() //  [R1]
         { info_tbl: [(cgreC,
                       label: sat_sgr4G_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgreC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgreD; else goto cgreE;
       cgreD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgreE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgreA_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgreA() //  [R1]
         { info_tbl: [(cgreA,
                       label: block_cgreA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgreA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgr4C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgr4C_entry() //  [R1, R2]
         { info_tbl: [(cgreL,
                       label: go_sgr4C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgreL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgreM; else goto cgreN;
       cgreM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgreN: // global
           I64[Sp - 32] = block_cgres_info;
           R3 = P64[R1 + 7];
           _sgr4D::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgr4D::P64;
           Sp = Sp - 32;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgres() //  [R1]
         { info_tbl: [(cgres,
                       label: block_cgres_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgres: // global
           if (R1 == 1) goto cgreK; else goto cgreJ;
       cgreK: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgreJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgreR; else goto cgreQ;
       cgreR: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgreQ: // global
           I64[Hp - 56] = sat_sgr4G_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           _sgr4D::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sgr4D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgr4D::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgreV,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgreV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgreW; else goto cgreX;
       cgreW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgreX: // global
           I64[Sp - 24] = block_cgrdF_info;
           _sgr4t::P64 = R3;
           R3 = R2;
           _sgr4s::P64 = R2;
           R2 = _sgr4t::P64;
           P64[Sp - 16] = _sgr4s::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrdF() //  [R1]
         { info_tbl: [(cgrdF,
                       label: block_cgrdF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrdF: // global
           I64[Sp - 8] = block_cgrdJ_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrdJ() //  [R1]
         { info_tbl: [(cgrdJ,
                       label: block_cgrdJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrdJ: // global
           _sgr4s::P64 = P64[Sp + 16];
           _sgr4u::P64 = P64[Sp + 24];
           _sgr4v::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgrf4; else goto cgrf0;
       cgrf4: // global
           Hp = Hp + 24;
           _sgr4w::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgrf7; else goto cgrf6;
       cgrf6: // global
           I64[Hp - 16] = go_sgr4C_info;
           P64[Hp - 8] = _sgr4u::P64;
           P64[Hp] = _sgr4v::P64;
           R2 = _sgr4s::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgr4C_entry(R2, R1) args: 8, res: 0, upd: 8;
       cgrf0: // global
           Hp = Hp + 24;
           _sgr4w::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cgrf7; else goto cgrf2;
       cgrf7: // global
           HpAlloc = 24;
           R1 = _sgr4w::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgrf2: // global
           I64[Hp - 16] = go_sgr4x_info;
           P64[Hp - 8] = _sgr4u::P64;
           P64[Hp] = _sgr4v::P64;
           R2 = _sgr4s::P64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call go_sgr4x_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.64638375 UTC

[section ""data" . sat_sgr4H_closure" {
     sat_sgr4H_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.648535923 UTC

[section ""data" . sat_sgr4I_closure" {
     sat_sgr4I_closure:
         const :_con_info;
         const sat_sgr4H_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.651514565 UTC

[section ""data" . Data.Fixed.$fEnumFixed2_closure" {
     Data.Fixed.$fEnumFixed2_closure:
         const Data.Fixed.$fEnumFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fEnumFixed2_entry() //  [R1]
         { info_tbl: [(cgrgn,
                       label: Data.Fixed.$fEnumFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrgn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrgo; else goto cgrgp;
       cgrgo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrgp: // global
           (_cgrgk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrgk::I64 == 0) goto cgrgm; else goto cgrgl;
       cgrgm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrgl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrgk::I64;
           R3 = sat_sgr4I_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.657125838 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromTo_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromTo_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromTo_info;
         const 0;
 },
 sat_sgr4P_entry() //  [R1]
         { info_tbl: [(cgrgS,
                       label: sat_sgr4P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrgS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrgT; else goto cgrgU;
       cgrgT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrgU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgrgQ_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrgQ() //  [R1]
         { info_tbl: [(cgrgQ,
                       label: block_cgrgQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrgQ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgr4L_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgr4L_entry() //  [R1, R2]
         { info_tbl: [(cgrh1,
                       label: go_sgr4L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrh1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrh2; else goto cgrh3;
       cgrh2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrh3: // global
           I64[Sp - 24] = block_cgrgI_info;
           R3 = P64[R1 + 7];
           _sgr4M::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _sgr4M::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.gtInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrgI() //  [R1]
         { info_tbl: [(cgrgI,
                       label: block_cgrgI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrgI: // global
           if (R1 == 1) goto cgrh0; else goto cgrgZ;
       cgrh0: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgrgZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrh7; else goto cgrh6;
       cgrh7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgrh6: // global
           I64[Hp - 48] = sat_sgr4P_info;
           P64[Hp - 32] = P64[Sp + 8];
           _sgr4M::P64 = P64[Sp + 16];
           P64[Hp - 24] = _sgr4M::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgr4M::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(cgrhb,
                       label: Data.Fixed.$fEnumFixed_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrhb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgrhf; else goto cgrhe;
       cgrhf: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrhe: // global
           I64[Hp - 8] = go_sgr4L_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgr4L_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.669775978 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFromThen_closure" {
     Data.Fixed.$fEnumFixed_$cenumFromThen_closure:
         const Data.Fixed.$fEnumFixed_$cenumFromThen_info;
         const 0;
 },
 d_sgr4S_entry() //  [R1]
         { info_tbl: [(cgrhS,
                       label: d_sgr4S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrhS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrhT; else goto cgrhU;
       cgrhT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrhU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr4X_entry() //  [R1]
         { info_tbl: [(cgrib,
                       label: sat_sgr4X_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrib: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgric; else goto cgrid;
       cgric: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrid: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cgri9_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgri9() //  [R1]
         { info_tbl: [(cgri9,
                       label: block_cgri9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgri9: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sgr4T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sgr4T_entry() //  [R1, R2]
         { info_tbl: [(cgrih,
                       label: go_sgr4T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrih: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrij; else goto cgrik;
       cgrij: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrik: // global
           I64[Sp - 24] = block_cgri0_info;
           _sgr4T::P64 = R1;
           _sgr4S::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgr4S::P64;
           P64[Sp - 8] = _sgr4T::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugrio; else goto cgri1;
       ugrio: // global
           call _cgri0(R1) args: 0, res: 0, upd: 0;
       cgri1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgri0() //  [R1]
         { info_tbl: [(cgri0,
                       label: block_cgri0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgri0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgrin; else goto cgrim;
       cgrin: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrim: // global
           I64[Hp - 56] = sat_sgr4X_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fEnumFixed_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(cgrip,
                       label: Data.Fixed.$fEnumFixed_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrip: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrit; else goto cgris;
       cgrit: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgris: // global
           I64[Hp - 40] = d_sgr4S_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = go_sgr4T_info;
           P64[Hp] = Hp - 40;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgr4T_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.686438106 UTC

[section ""data" . Data.Fixed.$fEnumFixed3_closure" {
     Data.Fixed.$fEnumFixed3_closure:
         const Data.Fixed.$fEnumFixed3_info;
         const 0;
 },
 sat_sgr51_entry() //  [R1]
         { info_tbl: [(cgrjk,
                       label: sat_sgr51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrjk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrjl; else goto cgrjm;
       cgrjl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrjm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgrji_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrji() //  [R1]
         { info_tbl: [(cgrji,
                       label: block_cgrji_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrji: // global
           R2 = R1;
           Sp = Sp + 8;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fEnumFixed3_entry() //  [R2]
         { info_tbl: [(cgrjq,
                       label: Data.Fixed.$fEnumFixed3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrjq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgrjs; else goto cgrjt;
       cgrjs: // global
           R2 = R2;
           R1 = Data.Fixed.$fEnumFixed3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrjt: // global
           I64[Sp - 8] = block_cgrj9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugrjx; else goto cgrja;
       ugrjx: // global
           call _cgrj9(R1) args: 0, res: 0, upd: 0;
       cgrja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrj9() //  [R1]
         { info_tbl: [(cgrj9,
                       label: block_cgrj9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrj9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrjw; else goto cgrjv;
       cgrjw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrjv: // global
           I64[Hp - 40] = sat_sgr51_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.697994117 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cenumFrom_closure" {
     Data.Fixed.$fEnumFixed_$cenumFrom_closure:
         const Data.Fixed.$fEnumFixed_$cenumFrom_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed_$cenumFrom_entry() //  [R2]
         { info_tbl: [(cgrjZ,
                       label: Data.Fixed.$fEnumFixed_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrjZ: // global
           R2 = R2;
           call Data.Fixed.$fEnumFixed3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.702024674 UTC

[section ""data" . Data.Fixed.$fEnumFixed_$cfromEnum_closure" {
     Data.Fixed.$fEnumFixed_$cfromEnum_closure:
         const Data.Fixed.$fEnumFixed_$cfromEnum_info;
 },
 Data.Fixed.$fEnumFixed_$cfromEnum_entry() //  [R2]
         { info_tbl: [(cgrka,
                       label: Data.Fixed.$fEnumFixed_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrka: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.706362264 UTC

[section ""data" . Data.Fixed.$fEnumFixed4_closure" {
     Data.Fixed.$fEnumFixed4_closure:
         const Data.Fixed.$fEnumFixed4_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed4_entry() //  [R2]
         { info_tbl: [(cgrkl,
                       label: Data.Fixed.$fEnumFixed4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrkl: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.711222048 UTC

[section ""data" . Data.Fixed.$fEnumFixed5_closure" {
     Data.Fixed.$fEnumFixed5_closure:
         const Data.Fixed.$fEnumFixed5_info;
         const 0;
 },
 Data.Fixed.$fEnumFixed5_entry() //  [R2]
         { info_tbl: [(cgrkw,
                       label: Data.Fixed.$fEnumFixed5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrkw: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.715280185 UTC

[section ""data" . Data.Fixed.$fEnumFixed_closure" {
     Data.Fixed.$fEnumFixed_closure:
         const GHC.Enum.C:Enum_con_info;
         const Data.Fixed.$fEnumFixed5_closure+1;
         const Data.Fixed.$fEnumFixed4_closure+1;
         const GHC.Enum.$fEnumInteger_$ctoEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cfromEnum_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFrom_closure+1;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure+2;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.717598793 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE0_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE0_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_$cresolution_entry() //  []
         { info_tbl: [(cgrkI,
                       label: Data.Fixed.$fHasResolutionE0_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrkI: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.721459335 UTC

[section ""data" . Data.Fixed.$fHasResolutionE0_closure" {
     Data.Fixed.$fHasResolutionE0_closure:
         const Data.Fixed.$fHasResolutionE0_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE0_entry() //  [R2]
         { info_tbl: [(cgrkU,
                       label: Data.Fixed.$fHasResolutionE0_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrkU: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE0_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.724916712 UTC

[section ""data" . sat_sgr57_closure" {
     sat_sgr57_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.726770188 UTC

[section ""data" . sat_sgr58_closure" {
     sat_sgr58_closure:
         const :_con_info;
         const sat_sgr57_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.728802742 UTC

[section ""data" . Data.Fixed.$fHasResolutionE4_closure" {
     Data.Fixed.$fHasResolutionE4_closure:
         const Data.Fixed.$fHasResolutionE4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE4_entry() //  [R1]
         { info_tbl: [(cgrl9,
                       label: Data.Fixed.$fHasResolutionE4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrl9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrla; else goto cgrlb;
       cgrla: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrlb: // global
           (_cgrl6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrl6::I64 == 0) goto cgrl8; else goto cgrl7;
       cgrl8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrl7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrl6::I64;
           R3 = sat_sgr58_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.733673135 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE1_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE1_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_$cresolution_entry() //  []
         { info_tbl: [(cgrlp,
                       label: Data.Fixed.$fHasResolutionE1_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrlp: // global
           R1 = Data.Fixed.$fHasResolutionE4_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.738409621 UTC

[section ""data" . Data.Fixed.$fHasResolutionE1_closure" {
     Data.Fixed.$fHasResolutionE1_closure:
         const Data.Fixed.$fHasResolutionE1_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE1_entry() //  [R2]
         { info_tbl: [(cgrlB,
                       label: Data.Fixed.$fHasResolutionE1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrlB: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE1_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.741870472 UTC

[section ""data" . sat_sgr5a_closure" {
     sat_sgr5a_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.743641448 UTC

[section ""data" . sat_sgr5b_closure" {
     sat_sgr5b_closure:
         const :_con_info;
         const sat_sgr5a_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.746004885 UTC

[section ""data" . Data.Fixed.$fHasResolutionE7_closure" {
     Data.Fixed.$fHasResolutionE7_closure:
         const Data.Fixed.$fHasResolutionE7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE7_entry() //  [R1]
         { info_tbl: [(cgrlQ,
                       label: Data.Fixed.$fHasResolutionE7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrlQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrlR; else goto cgrlS;
       cgrlR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrlS: // global
           (_cgrlN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrlN::I64 == 0) goto cgrlP; else goto cgrlO;
       cgrlP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrlO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrlN::I64;
           R3 = sat_sgr5b_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.750319374 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE2_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE2_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_$cresolution_entry() //  []
         { info_tbl: [(cgrm6,
                       label: Data.Fixed.$fHasResolutionE2_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrm6: // global
           R1 = Data.Fixed.$fHasResolutionE7_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.753748865 UTC

[section ""data" . Data.Fixed.$fHasResolutionE2_closure" {
     Data.Fixed.$fHasResolutionE2_closure:
         const Data.Fixed.$fHasResolutionE2_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE2_entry() //  [R2]
         { info_tbl: [(cgrmi,
                       label: Data.Fixed.$fHasResolutionE2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrmi: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE2_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.757008212 UTC

[section ""data" . sat_sgr5d_closure" {
     sat_sgr5d_closure:
         const GHC.Types.I#_con_info;
         const 1000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.758973117 UTC

[section ""data" . sat_sgr5e_closure" {
     sat_sgr5e_closure:
         const :_con_info;
         const sat_sgr5d_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.761192724 UTC

[section ""data" . Data.Fixed.$fHasResolutionE8_closure" {
     Data.Fixed.$fHasResolutionE8_closure:
         const Data.Fixed.$fHasResolutionE8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE8_entry() //  [R1]
         { info_tbl: [(cgrmx,
                       label: Data.Fixed.$fHasResolutionE8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrmx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrmy; else goto cgrmz;
       cgrmy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrmz: // global
           (_cgrmu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrmu::I64 == 0) goto cgrmw; else goto cgrmv;
       cgrmw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrmv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrmu::I64;
           R3 = sat_sgr5e_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.76628183 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE3_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE3_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_$cresolution_entry() //  []
         { info_tbl: [(cgrmN,
                       label: Data.Fixed.$fHasResolutionE3_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrmN: // global
           R1 = Data.Fixed.$fHasResolutionE8_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.770529875 UTC

[section ""data" . Data.Fixed.$fHasResolutionE3_closure" {
     Data.Fixed.$fHasResolutionE3_closure:
         const Data.Fixed.$fHasResolutionE3_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE3_entry() //  [R2]
         { info_tbl: [(cgrmZ,
                       label: Data.Fixed.$fHasResolutionE3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrmZ: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE3_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.773938283 UTC

[section ""data" . sat_sgr5g_closure" {
     sat_sgr5g_closure:
         const GHC.Types.I#_con_info;
         const 1000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.775747953 UTC

[section ""data" . sat_sgr5h_closure" {
     sat_sgr5h_closure:
         const :_con_info;
         const sat_sgr5g_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.777824088 UTC

[section ""data" . Data.Fixed.$fHasResolutionE10_closure" {
     Data.Fixed.$fHasResolutionE10_closure:
         const Data.Fixed.$fHasResolutionE10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE10_entry() //  [R1]
         { info_tbl: [(cgrne,
                       label: Data.Fixed.$fHasResolutionE10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrne: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrnf; else goto cgrng;
       cgrnf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrng: // global
           (_cgrnb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrnb::I64 == 0) goto cgrnd; else goto cgrnc;
       cgrnd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrnc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrnb::I64;
           R3 = sat_sgr5h_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.782246756 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE6_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE6_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_$cresolution_entry() //  []
         { info_tbl: [(cgrnu,
                       label: Data.Fixed.$fHasResolutionE6_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrnu: // global
           R1 = Data.Fixed.$fHasResolutionE10_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.786294613 UTC

[section ""data" . Data.Fixed.$fHasResolutionE6_closure" {
     Data.Fixed.$fHasResolutionE6_closure:
         const Data.Fixed.$fHasResolutionE6_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE6_entry() //  [R2]
         { info_tbl: [(cgrnG,
                       label: Data.Fixed.$fHasResolutionE6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrnG: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE6_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.790062328 UTC

[section ""data" . sat_sgr5j_closure" {
     sat_sgr5j_closure:
         const GHC.Types.I#_con_info;
         const 1000000000;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.791948567 UTC

[section ""data" . sat_sgr5k_closure" {
     sat_sgr5k_closure:
         const :_con_info;
         const sat_sgr5j_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.794751946 UTC

[section ""data" . Data.Fixed.$fHasResolutionE11_closure" {
     Data.Fixed.$fHasResolutionE11_closure:
         const Data.Fixed.$fHasResolutionE11_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE11_entry() //  [R1]
         { info_tbl: [(cgrnV,
                       label: Data.Fixed.$fHasResolutionE11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrnV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrnW; else goto cgrnX;
       cgrnW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrnX: // global
           (_cgrnS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrnS::I64 == 0) goto cgrnU; else goto cgrnT;
       cgrnU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrnT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrnS::I64;
           R3 = sat_sgr5k_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.799259753 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE9_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE9_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_$cresolution_entry() //  []
         { info_tbl: [(cgrob,
                       label: Data.Fixed.$fHasResolutionE9_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrob: // global
           R1 = Data.Fixed.$fHasResolutionE11_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.802919085 UTC

[section ""data" . Data.Fixed.$fHasResolutionE9_closure" {
     Data.Fixed.$fHasResolutionE9_closure:
         const Data.Fixed.$fHasResolutionE9_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE9_entry() //  [R2]
         { info_tbl: [(cgron,
                       label: Data.Fixed.$fHasResolutionE9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgron: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE9_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.806274408 UTC

[section ""data" . sat_sgr5n_closure" {
     sat_sgr5n_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.80802957 UTC

[section ""data" . sat_sgr5o_closure" {
     sat_sgr5o_closure:
         const :_con_info;
         const sat_sgr5n_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.809855884 UTC

[section ""data" . sat_sgr5m_closure" {
     sat_sgr5m_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.811638453 UTC

[section ""data" . sat_sgr5p_closure" {
     sat_sgr5p_closure:
         const :_con_info;
         const sat_sgr5m_closure+1;
         const sat_sgr5o_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.813966807 UTC

[section ""data" . Data.Fixed.$fHasResolutionE5_closure" {
     Data.Fixed.$fHasResolutionE5_closure:
         const Data.Fixed.$fHasResolutionE5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fHasResolutionE5_entry() //  [R1]
         { info_tbl: [(cgroE,
                       label: Data.Fixed.$fHasResolutionE5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgroE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgroF; else goto cgroG;
       cgroF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgroG: // global
           (_cgroB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgroB::I64 == 0) goto cgroD; else goto cgroC;
       cgroD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgroC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgroB::I64;
           R3 = sat_sgr5p_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.818845091 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_$cresolution_closure" {
     Data.Fixed.$fHasResolutionE12_$cresolution_closure:
         const Data.Fixed.$fHasResolutionE12_$cresolution_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_$cresolution_entry() //  []
         { info_tbl: [(cgroU,
                       label: Data.Fixed.$fHasResolutionE12_$cresolution_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgroU: // global
           R1 = Data.Fixed.$fHasResolutionE5_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.823557718 UTC

[section ""data" . Data.Fixed.$fHasResolutionE12_closure" {
     Data.Fixed.$fHasResolutionE12_closure:
         const Data.Fixed.$fHasResolutionE12_info;
         const 0;
 },
 Data.Fixed.$fHasResolutionE12_entry() //  [R2]
         { info_tbl: [(cgrp6,
                       label: Data.Fixed.$fHasResolutionE12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrp6: // global
           R2 = R2;
           call Data.Fixed.$fHasResolutionE12_$cresolution_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.827072733 UTC

[section ""cstring" . Data.Fixed.$fDataFixed6_bytes" {
     Data.Fixed.$fDataFixed6_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.829099401 UTC

[section ""data" . Data.Fixed.$fDataFixed5_closure" {
     Data.Fixed.$fDataFixed5_closure:
         const Data.Fixed.$fDataFixed5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed5_entry() //  [R1]
         { info_tbl: [(cgrpk,
                       label: Data.Fixed.$fDataFixed5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrpk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrpl; else goto cgrpm;
       cgrpl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrpm: // global
           (_cgrph::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrph::I64 == 0) goto cgrpj; else goto cgrpi;
       cgrpj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrpi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrph::I64;
           R2 = Data.Fixed.$fDataFixed6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.83395369 UTC

[section ""cstring" . w1_rgoyk_bytes" {
     w1_rgoyk_bytes:
         I8[] [77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.83594982 UTC

[section ""data" . w2_rgoyl_closure" {
     w2_rgoyl_closure:
         const w2_rgoyl_info;
         const 0;
         const 0;
         const 0;
 },
 w2_rgoyl_entry() //  [R1]
         { info_tbl: [(cgrpC,
                       label: w2_rgoyl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrpC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrpD; else goto cgrpE;
       cgrpD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrpE: // global
           (_cgrpz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrpz::I64 == 0) goto cgrpB; else goto cgrpA;
       cgrpB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrpA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrpz::I64;
           R2 = w1_rgoyk_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.840853546 UTC

[section ""data" . go61_rgoym_closure" {
     go61_rgoym_closure:
         const go61_rgoym_info;
         const 0;
 },
 go61_rgoym_entry() //  [R2, R3]
         { info_tbl: [(cgrpY,
                       label: go61_rgoym_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrpY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrpZ; else goto ugrqC;
       cgrpZ: // global
           R3 = R3;
           R2 = R2;
           R1 = go61_rgoym_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ugrqC: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cgrpO() args: 0, res: 0, upd: 0;
     }
 },
 _cgrpO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrpO: // global
           _sgr5r::P64 = P64[Sp];
           I64[Sp] = block_cgrpR_info;
           R1 = _sgr5r::P64;
           if (R1 & 7 != 0) goto ugrqG; else goto cgrpS;
       ugrqG: // global
           call _cgrpR(R1) args: 0, res: 0, upd: 0;
       cgrpS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrpR() //  [R1]
         { info_tbl: [(cgrpR,
                       label: block_cgrpR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrpR: // global
           if (R1 & 7 == 1) goto ugrqD; else goto cgrpW;
       ugrqD: // global
           Sp = Sp + 16;
           call _cgrqe() args: 0, res: 0, upd: 0;
       cgrpW: // global
           I64[Sp - 8] = block_cgrq6_info;
           _sgr5u::P64 = P64[R1 + 6];
           _sgr5v::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sgr5v::P64;
           P64[Sp + 8] = _sgr5u::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugrqH; else goto cgrq8;
       ugrqH: // global
           call _cgrq6(R1) args: 0, res: 0, upd: 0;
       cgrq8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrq6() //  [R1]
         { info_tbl: [(cgrq6,
                       label: block_cgrq6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrq6: // global
           if (R1 & 7 == 1) goto ugrqE; else goto cgrqj;
       ugrqE: // global
           Sp = Sp + 24;
           call _cgrqe() args: 0, res: 0, upd: 0;
       cgrqj: // global
           I64[Sp - 8] = block_cgrqh_info;
           _sgr5x::P64 = P64[R1 + 6];
           _sgr5y::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgr5y::P64;
           P64[Sp + 16] = _sgr5x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugrqK; else goto cgrqk;
       ugrqK: // global
           call _cgrqh(R1) args: 0, res: 0, upd: 0;
       cgrqk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrqe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrqe: // global
           R1 = GHC.List.badHead_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgrqh() //  [R1]
         { info_tbl: [(cgrqh,
                       label: block_cgrqh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrqh: // global
           I64[Sp] = block_cgrqo_info;
           R3 = w2_rgoyl_closure;
           R2 = P64[R1 + 15];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrqo() //  [R1]
         { info_tbl: [(cgrqo,
                       label: block_cgrqo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrqo: // global
           if (R1 & 7 == 1) goto cgrqv; else goto cgrqz;
       cgrqv: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cgrpO() args: 0, res: 0, upd: 0;
       cgrqz: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.856323372 UTC

[section ""data" . conMkFixed1_rgoyn_closure" {
     conMkFixed1_rgoyn_closure:
         const Data.Data.AlgConstr_con_info;
         const conMkFixed2_rgoyo_closure;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed4_closure" {
     Data.Fixed.$fDataFixed4_closure:
         const :_con_info;
         const Data.Fixed.conMkFixed_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.$fDataFixed3_closure" {
     Data.Fixed.$fDataFixed3_closure:
         const Data.Data.AlgRep_con_info;
         const Data.Fixed.$fDataFixed4_closure+2;
         const 0;
 },
 section ""data" . Data.Fixed.tyFixed_closure" {
     Data.Fixed.tyFixed_closure:
         const Data.Data.DataType_con_info;
         const Data.Fixed.$fDataFixed5_closure;
         const Data.Fixed.$fDataFixed3_closure+1;
         const 0;
 },
 section ""data" . Data.Fixed.conMkFixed_closure" {
     Data.Fixed.conMkFixed_closure:
         const Data.Data.Constr_con_info;
         const conMkFixed1_rgoyn_closure+1;
         const w2_rgoyl_closure;
         const GHC.Types.[]_closure+1;
         const Data.Data.Prefix_closure+1;
         const Data.Fixed.tyFixed_closure+1;
         const 0;
 },
 section ""data" . conMkFixed2_rgoyo_closure" {
     conMkFixed2_rgoyo_closure:
         const conMkFixed2_rgoyo_info;
         const 0;
         const 0;
         const 0;
 },
 conMkFixed2_rgoyo_entry() //  [R1]
         { info_tbl: [(cgrrv,
                       label: conMkFixed2_rgoyo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrrv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrrw; else goto cgrrx;
       cgrrw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrrx: // global
           (_cgrrs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrrs::I64 == 0) goto cgrru; else goto cgrrt;
       cgrru: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrrt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrrs::I64;
           R3 = Data.Data.mkConstr1_closure;
           R2 = Data.Fixed.$fDataFixed4_closure+2;
           Sp = Sp - 16;
           call go61_rgoym_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.864341236 UTC

[section ""cstring" . Data.Fixed.$trModule4_bytes" {
     Data.Fixed.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.86647749 UTC

[section ""data" . loc_rgoyp_closure" {
     loc_rgoyp_closure:
         const loc_rgoyp_info;
         const 0;
         const 0;
         const 0;
 },
 loc_rgoyp_entry() //  [R1]
         { info_tbl: [(cgrrS,
                       label: loc_rgoyp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrrS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrrT; else goto cgrrU;
       cgrrT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrrU: // global
           (_cgrrP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrrP::I64 == 0) goto cgrrR; else goto cgrrQ;
       cgrrR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrrQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrrP::I64;
           R2 = Data.Fixed.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.87078996 UTC

[section ""cstring" . Data.Fixed.$trModule2_bytes" {
     Data.Fixed.$trModule2_bytes:
         I8[] [68,97,116,97,46,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.872973525 UTC

[section ""data" . loc1_rgoyq_closure" {
     loc1_rgoyq_closure:
         const loc1_rgoyq_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rgoyq_entry() //  [R1]
         { info_tbl: [(cgrsa,
                       label: loc1_rgoyq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrsa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrsb; else goto cgrsc;
       cgrsb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrsc: // global
           (_cgrs7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrs7::I64 == 0) goto cgrs9; else goto cgrs8;
       cgrs9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrs8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrs7::I64;
           R2 = Data.Fixed.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.877345256 UTC

[section ""cstring" . loc2_rgoyr_bytes" {
     loc2_rgoyr_bytes:
         I8[] [46,47,68,97,116,97,47,70,105,120,101,100,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.879939012 UTC

[section ""data" . loc3_rgoys_closure" {
     loc3_rgoys_closure:
         const loc3_rgoys_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rgoys_entry() //  [R1]
         { info_tbl: [(cgrss,
                       label: loc3_rgoys_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrss: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrst; else goto cgrsu;
       cgrst: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrsu: // global
           (_cgrsp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrsp::I64 == 0) goto cgrsr; else goto cgrsq;
       cgrsr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrsq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrsp::I64;
           R2 = loc2_rgoyr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.88418382 UTC

[section ""data" . loc4_rgoyt_closure" {
     loc4_rgoyt_closure:
         const GHC.Types.I#_con_info;
         const 83;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.886025503 UTC

[section ""data" . loc5_rgoyu_closure" {
     loc5_rgoyu_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.887813151 UTC

[section ""data" . loc6_rgoyv_closure" {
     loc6_rgoyv_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.88963492 UTC

[section ""cstring" . $dIP_rgoyw_bytes" {
     $dIP_rgoyw_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.891634039 UTC

[section ""data" . $dIP1_rgoyx_closure" {
     $dIP1_rgoyx_closure:
         const $dIP1_rgoyx_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rgoyx_entry() //  [R1]
         { info_tbl: [(cgrsN,
                       label: $dIP1_rgoyx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrsN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrsO; else goto cgrsP;
       cgrsO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrsP: // global
           (_cgrsK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrsK::I64 == 0) goto cgrsM; else goto cgrsL;
       cgrsM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrsL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrsK::I64;
           R2 = $dIP_rgoyw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.896361383 UTC

[section ""data" . $dIP2_rgoyy_closure" {
     $dIP2_rgoyy_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const loc4_rgoyt_closure+1;
         const loc5_rgoyu_closure+1;
         const loc4_rgoyt_closure+1;
         const loc6_rgoyv_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.898438637 UTC

[section ""data" . $dIP3_rgoyz_closure" {
     $dIP3_rgoyz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const $dIP2_rgoyy_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.900444335 UTC

[section ""data" . Data.Fixed.$trModule3_closure" {
     Data.Fixed.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.902384231 UTC

[section ""data" . Data.Fixed.$trModule1_closure" {
     Data.Fixed.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.904338887 UTC

[section ""data" . Data.Fixed.$trModule_closure" {
     Data.Fixed.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Fixed.$trModule3_closure+1;
         const Data.Fixed.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.906914934 UTC

[section ""data" . $krep_rgoyA_closure" {
     $krep_rgoyA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.908657684 UTC

[section ""data" . $krep1_rgoyB_closure" {
     $krep1_rgoyB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.910422595 UTC

[section ""data" . Data.Fixed.$tcHasResolution1_closure" {
     Data.Fixed.$tcHasResolution1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rgoyB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.912263279 UTC

[section ""data" . $krep2_rgoyC_closure" {
     $krep2_rgoyC_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.914123701 UTC

[section ""cstring" . Data.Fixed.$fDataFixed10_bytes" {
     Data.Fixed.$fDataFixed10_bytes:
         I8[] [70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.915845207 UTC

[section ""data" . Data.Fixed.$fDataFixed9_closure" {
     Data.Fixed.$fDataFixed9_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$fDataFixed10_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.917653065 UTC

[section ""data" . Data.Fixed.$tcFixed_closure" {
     Data.Fixed.$tcFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$fDataFixed9_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12850707307297787398;
         const 5875431371990069009;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.919651446 UTC

[section ""data" . $krep3_rgoyD_closure" {
     $krep3_rgoyD_closure:
         const :_con_info;
         const $krep2_rgoyC_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.921499171 UTC

[section ""data" . $krep4_rgoyE_closure" {
     $krep4_rgoyE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Fixed.$tcFixed_closure+1;
         const $krep3_rgoyD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.923396372 UTC

[section ""data" . Data.Fixed.$tc'MkFixed1_closure" {
     Data.Fixed.$tc'MkFixed1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rgoyA_closure+1;
         const $krep4_rgoyE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.925383043 UTC

[section ""cstring" . Data.Fixed.$tc'MkFixed3_bytes" {
     Data.Fixed.$tc'MkFixed3_bytes:
         I8[] [39,77,107,70,105,120,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.927295141 UTC

[section ""data" . Data.Fixed.$tc'MkFixed2_closure" {
     Data.Fixed.$tc'MkFixed2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tc'MkFixed3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.929192048 UTC

[section ""data" . Data.Fixed.$tc'MkFixed_closure" {
     Data.Fixed.$tc'MkFixed_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tc'MkFixed2_closure+1;
         const Data.Fixed.$tc'MkFixed1_closure+4;
         const 8992689233320522225;
         const 9587721628087041380;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.93241892 UTC

[section ""data" . Data.Fixed.$fDataFixed8_closure" {
     Data.Fixed.$fDataFixed8_closure:
         const Data.Fixed.$fDataFixed8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fDataFixed8_entry() //  [R1]
         { info_tbl: [(cgrtr,
                       label: Data.Fixed.$fDataFixed8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrtr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cgrts; else goto cgrtt;
       cgrts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrtt: // global
           (_cgrtj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrtj::I64 == 0) goto cgrtl; else goto cgrtk;
       cgrtl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrtk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrtj::I64;
           I64[Sp - 24] = block_cgrtm_info;
           R6 = 0;
           R5 = Data.Fixed.$fDataFixed9_closure+1;
           R4 = Data.Fixed.$trModule_closure+1;
           R3 = 5875431371990069009;
           R2 = 12850707307297787398;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgrtm() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgrtm,
                       label: block_cgrtm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrtm: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cgrtn() args: 0, res: 0, upd: 0;
     }
 },
 _cgrtn() //  []
         { info_tbl: [(cgrtn,
                       label: block_cgrtn_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrtn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrtw; else goto cgrtv;
       cgrtw: // global
           HpAlloc = 48;
           I64[Sp] = block_cgrtn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cgrtv: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.941098738 UTC

[section ""data" . Data.Fixed.$fDataFixed7_closure" {
     Data.Fixed.$fDataFixed7_closure:
         const Data.Fixed.$fDataFixed7_info;
         const 0;
 },
 Data.Fixed.$fDataFixed7_entry() //  [R2]
         { info_tbl: [(cgru3,
                       label: Data.Fixed.$fDataFixed7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgru3: // global
           R3 = R2;
           R2 = Data.Fixed.$fDataFixed8_closure;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.944743869 UTC

[section ""data" . Data.Fixed.$fDataFixed1_closure" {
     Data.Fixed.$fDataFixed1_closure:
         const (,)_con_info;
         const Data.Fixed.$fDataFixed2_closure+1;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.949185388 UTC

[section ""data" . Data.Fixed.$w$cgmapMp_closure" {
     Data.Fixed.$w$cgmapMp_closure:
         const Data.Fixed.$w$cgmapMp_info;
         const 0;
 },
 lvl17_sgr5Q_entry() //  [R1]
         { info_tbl: [(cgruj,
                       label: lvl17_sgr5Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgruj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgruk; else goto cgrul;
       cgruk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrul: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr6d_entry() //  [R1, R2]
         { info_tbl: [(cgruy,
                       label: sat_sgr6d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgruy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgruz; else goto cgruA;
       cgruz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgruA: // global
           I64[Sp - 24] = block_cgruv_info;
           _sgr5Q::P64 = P64[R1 + 7];
           _sgr5R::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgr5Q::P64;
           P64[Sp - 8] = _sgr5R::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugruS; else goto cgruw;
       ugruS: // global
           call _cgruv(R1) args: 0, res: 0, upd: 0;
       cgruw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgruv() //  [R1]
         { info_tbl: [(cgruv,
                       label: block_cgruv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgruv: // global
           I64[Sp - 8] = block_cgruD_info;
           _sgr6a::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgr6a::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugruR; else goto cgruF;
       ugruR: // global
           call _cgruD(R1) args: 0, res: 0, upd: 0;
       cgruF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgruD() //  [R1]
         { info_tbl: [(cgruD,
                       label: block_cgruD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgruD: // global
           if (R1 & 7 == 1) goto cgruL; else goto cgruP;
       cgruL: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgruP: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgr5S_entry() //  [R1]
         { info_tbl: [(cgrv1,
                       label: lvl18_sgr5S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrv1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrv2; else goto cgrv3;
       cgrv2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrv3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr65_entry() //  [R1]
         { info_tbl: [(cgrvk,
                       label: sat_sgr65_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrvk: // global
           _sgr65::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgrvl; else goto cgrvm;
       cgrvm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrvo; else goto cgrvn;
       cgrvo: // global
           HpAlloc = 56;
           goto cgrvl;
       cgrvl: // global
           R1 = _sgr65::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrvn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr65::P64;
           _sgr5P::P64 = P64[_sgr65::P64 + 16];
           _sgr5R::P64 = P64[_sgr65::P64 + 24];
           _sgr5W::P64 = P64[_sgr65::P64 + 32];
           _sgr5X::P64 = P64[_sgr65::P64 + 40];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgr5W::P64;
           P64[Hp - 24] = _sgr5P::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = _sgr5X::P64;
           R2 = _sgr5R::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr61_entry() //  [R1, R2]
         { info_tbl: [(cgrvA,
                       label: sat_sgr61_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrvA: // global
           _sgr5Y::P64 = R2;
           _sgr61::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgrvB; else goto cgrvC;
       cgrvC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrvE; else goto cgrvD;
       cgrvE: // global
           HpAlloc = 56;
           goto cgrvB;
       cgrvB: // global
           R2 = _sgr5Y::P64;
           R1 = _sgr61::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrvD: // global
           _sgr5R::P64 = P64[_sgr61::P64 + 7];
           _sgr5W::P64 = P64[_sgr61::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgr5W::P64;
           P64[Hp - 24] = _sgr5Y::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgr5R::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgr62_entry() //  [R1]
         { info_tbl: [(cgrvF,
                       label: sat_sgr62_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrvF: // global
           _sgr62::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrvG; else goto cgrvH;
       cgrvH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrvJ; else goto cgrvI;
       cgrvJ: // global
           HpAlloc = 24;
           goto cgrvG;
       cgrvG: // global
           R1 = _sgr62::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrvI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr62::P64;
           _sgr5R::P64 = P64[_sgr62::P64 + 16];
           _sgr5S::P64 = P64[_sgr62::P64 + 24];
           _sgr5W::P64 = P64[_sgr62::P64 + 32];
           I64[Hp - 16] = sat_sgr61_info;
           P64[Hp - 8] = _sgr5R::P64;
           P64[Hp] = _sgr5W::P64;
           R2 = _sgr5R::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgr5S::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgr66_entry() //  [R1, R2]
         { info_tbl: [(cgrvK,
                       label: sat_sgr66_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrvK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgrvL; else goto cgrvM;
       cgrvL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrvM: // global
           I64[Sp - 40] = block_cgrv9_info;
           _sgr5N::P64 = P64[R1 + 7];
           _sgr5P::P64 = P64[R1 + 15];
           _sgr5R::P64 = P64[R1 + 23];
           _sgr5S::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgr5N::P64;
           P64[Sp - 24] = _sgr5P::P64;
           P64[Sp - 16] = _sgr5R::P64;
           P64[Sp - 8] = _sgr5S::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugrvQ; else goto cgrva;
       ugrvQ: // global
           call _cgrv9(R1) args: 0, res: 0, upd: 0;
       cgrva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrv9() //  [R1]
         { info_tbl: [(cgrv9,
                       label: block_cgrv9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrv9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgrvP; else goto cgrvO;
       cgrvP: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrvO: // global
           _sgr5W::P64 = P64[R1 + 7];
           _sgr5X::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sgr65_info;
           P64[Hp - 64] = P64[Sp + 16];
           _sgr5R::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sgr5R::P64;
           P64[Hp - 48] = _sgr5W::P64;
           P64[Hp - 40] = _sgr5X::P64;
           I64[Hp - 32] = sat_sgr62_info;
           P64[Hp - 16] = _sgr5R::P64;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sgr5W::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 80;
           Sp = Sp + 16;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgr5T_entry() //  [R1]
         { info_tbl: [(cgrvV,
                       label: sat_sgr5T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrvV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrvW; else goto cgrvX;
       cgrvW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrvX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr67_entry() //  [R1]
         { info_tbl: [(cgrvY,
                       label: sat_sgr67_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrvY: // global
           _sgr67::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrvZ; else goto cgrw0;
       cgrw0: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgrw2; else goto cgrw1;
       cgrw2: // global
           HpAlloc = 96;
           goto cgrvZ;
       cgrvZ: // global
           R1 = _sgr67::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrw1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr67::P64;
           _sgr5N::P64 = P64[_sgr67::P64 + 16];
           _sgr5O::P64 = P64[_sgr67::P64 + 24];
           _sgr5P::P64 = P64[_sgr67::P64 + 32];
           _sgr5R::P64 = P64[_sgr67::P64 + 40];
           I64[Hp - 88] = lvl18_sgr5S_info;
           P64[Hp - 72] = _sgr5O::P64;
           P64[Hp - 64] = _sgr5P::P64;
           I64[Hp - 56] = sat_sgr66_info;
           P64[Hp - 48] = _sgr5N::P64;
           P64[Hp - 40] = _sgr5P::P64;
           P64[Hp - 32] = _sgr5R::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgr5T_info;
           P64[Hp] = _sgr5R::P64;
           R2 = _sgr5R::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMp_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrw3,
                       label: Data.Fixed.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrw3: // global
           _sgr5P::P64 = R4;
           _sgr5O::P64 = R3;
           _sgr5N::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrw4; else goto cgrw5;
       cgrw5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrw7; else goto cgrw6;
       cgrw7: // global
           HpAlloc = 24;
           goto cgrw4;
       cgrw4: // global
           R4 = _sgr5P::P64;
           R3 = _sgr5O::P64;
           R2 = _sgr5N::P64;
           R1 = Data.Fixed.$w$cgmapMp_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrw6: // global
           I64[Hp - 16] = lvl17_sgr5Q_info;
           P64[Hp] = _sgr5N::P64;
           I64[Sp - 40] = block_cgrum_info;
           R2 = _sgr5N::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgr5N::P64;
           P64[Sp - 16] = _sgr5O::P64;
           P64[Sp - 8] = _sgr5P::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrum() //  [R1]
         { info_tbl: [(cgrum,
                       label: block_cgrum_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrum: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgrwa; else goto cgrw9;
       cgrwa: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrw9: // global
           I64[Hp - 64] = sat_sgr6d_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgr67_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.985951184 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMp_closure" {
     Data.Fixed.$fDataFixed_$cgmapMp_closure:
         const Data.Fixed.$fDataFixed_$cgmapMp_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMp_entry() //  [R3, R4, R5]
         { info_tbl: [(cgry3,
                       label: Data.Fixed.$fDataFixed_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgry3: // global
           _sgr6g::P64 = R4;
           R4 = R5;
           _sgr6f::P64 = R3;
           R3 = _sgr6g::P64;
           R2 = _sgr6f::P64;
           call Data.Fixed.$w$cgmapMp_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:22.991551435 UTC

[section ""data" . Data.Fixed.$w$cgmapM_closure" {
     Data.Fixed.$w$cgmapM_closure:
         const Data.Fixed.$w$cgmapM_info;
         const 0;
 },
 lvl17_sgr6l_entry() //  [R1]
         { info_tbl: [(cgryi,
                       label: lvl17_sgr6l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgryi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgryj; else goto cgryk;
       cgryj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgryk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr6q_entry() //  [R1, R2]
         { info_tbl: [(cgryw,
                       label: sat_sgr6q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgryw: // global
           _sgr6o::P64 = R2;
           _sgr6q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgryx; else goto cgryy;
       cgryy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgryA; else goto cgryz;
       cgryA: // global
           HpAlloc = 32;
           goto cgryx;
       cgryx: // global
           R2 = _sgr6o::P64;
           R1 = _sgr6q::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgryz: // global
           _sgr6i::P64 = P64[_sgr6q::P64 + 7];
           _sgr6n::P64 = P64[_sgr6q::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgr6n::P64;
           P64[Hp] = _sgr6o::P64;
           R2 = _sgr6i::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgr6r_entry() //  [R1, R2]
         { info_tbl: [(cgryB,
                       label: sat_sgr6r_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgryB: // global
           _sgr6n::P64 = R2;
           _sgr6r::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cgryC; else goto cgryD;
       cgryD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgryF; else goto cgryE;
       cgryF: // global
           HpAlloc = 24;
           goto cgryC;
       cgryC: // global
           R2 = _sgr6n::P64;
           R1 = _sgr6r::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgryE: // global
           _sgr6i::P64 = P64[_sgr6r::P64 + 7];
           _sgr6l::P64 = P64[_sgr6r::P64 + 15];
           I64[Hp - 16] = sat_sgr6q_info;
           P64[Hp - 8] = _sgr6i::P64;
           P64[Hp] = _sgr6n::P64;
           R2 = _sgr6i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgr6l::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgr6m_entry() //  [R1]
         { info_tbl: [(cgryK,
                       label: sat_sgr6m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgryK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgryL; else goto cgryM;
       cgryL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgryM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed2_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cgryN,
                       label: Data.Fixed.$w$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgryN: // global
           _sgr6k::P64 = R4;
           _sgr6j::P64 = R3;
           _sgr6i::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgryO; else goto cgryP;
       cgryP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgryR; else goto cgryQ;
       cgryR: // global
           HpAlloc = 80;
           goto cgryO;
       cgryO: // global
           R4 = _sgr6k::P64;
           R3 = _sgr6j::P64;
           R2 = _sgr6i::P64;
           R1 = Data.Fixed.$w$cgmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgryQ: // global
           I64[Hp - 72] = lvl17_sgr6l_info;
           P64[Hp - 56] = _sgr6j::P64;
           P64[Hp - 48] = _sgr6k::P64;
           I64[Hp - 40] = sat_sgr6r_info;
           P64[Hp - 32] = _sgr6i::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = sat_sgr6m_info;
           P64[Hp] = _sgr6i::P64;
           R2 = _sgr6i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.005182154 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapM_closure" {
     Data.Fixed.$fDataFixed_$cgmapM_closure:
         const Data.Fixed.$fDataFixed_$cgmapM_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapM_entry() //  [R3, R4, R5]
         { info_tbl: [(cgrzy,
                       label: Data.Fixed.$fDataFixed_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrzy: // global
           _sgr6u::P64 = R4;
           R4 = R5;
           _sgr6t::P64 = R3;
           R3 = _sgr6u::P64;
           R2 = _sgr6t::P64;
           call Data.Fixed.$w$cgmapM_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.009681605 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapQi_closure" {
     Data.Fixed.$fDataFixed_$cgmapQi_closure:
         const Data.Fixed.$fDataFixed_$cgmapQi_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapQi_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrzM,
                       label: Data.Fixed.$fDataFixed_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrzM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrzN; else goto cgrzO;
       cgrzN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_$cgmapQi_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrzO: // global
           I64[Sp - 24] = block_cgrzJ_info;
           R1 = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugrzW; else goto cgrzK;
       ugrzW: // global
           call _cgrzJ(R1) args: 0, res: 0, upd: 0;
       cgrzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrzJ() //  [R1]
         { info_tbl: [(cgrzJ,
                       label: block_cgrzJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrzJ: // global
           if (I64[R1 + 7] == 0) goto cgrzV; else goto cgrzU;
       cgrzV: // global
           R3 = P64[Sp + 16];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrzU: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.018785208 UTC

[section ""data" . Data.Fixed.$w$cgmapMo_closure" {
     Data.Fixed.$w$cgmapMo_closure:
         const Data.Fixed.$w$cgmapMo_info;
         const 0;
 },
 lvl17_sgr6G_entry() //  [R1]
         { info_tbl: [(cgrAf,
                       label: lvl17_sgr6G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrAf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrAg; else goto cgrAh;
       cgrAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrAh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr76_entry() //  [R1, R2]
         { info_tbl: [(cgrAu,
                       label: sat_sgr76_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrAu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrAv; else goto cgrAw;
       cgrAv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrAw: // global
           I64[Sp - 24] = block_cgrAr_info;
           _sgr6G::P64 = P64[R1 + 7];
           _sgr6H::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sgr6G::P64;
           P64[Sp - 8] = _sgr6H::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugrAO; else goto cgrAs;
       ugrAO: // global
           call _cgrAr(R1) args: 0, res: 0, upd: 0;
       cgrAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrAr() //  [R1]
         { info_tbl: [(cgrAr,
                       label: block_cgrAr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrAr: // global
           I64[Sp - 8] = block_cgrAz_info;
           _sgr73::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgr73::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugrAN; else goto cgrAB;
       ugrAN: // global
           call _cgrAz(R1) args: 0, res: 0, upd: 0;
       cgrAB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrAz() //  [R1]
         { info_tbl: [(cgrAz,
                       label: block_cgrAz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrAz: // global
           if (R1 & 7 == 1) goto cgrAH; else goto cgrAL;
       cgrAH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgrAL: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 lvl18_sgr6I_entry() //  [R1]
         { info_tbl: [(cgrAX,
                       label: lvl18_sgr6I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrAX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrAY; else goto cgrAZ;
       cgrAY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrAZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr6W_entry() //  [R1]
         { info_tbl: [(cgrBl,
                       label: sat_sgr6W_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrBl: // global
           _sgr6W::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgrBm; else goto cgrBn;
       cgrBn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrBp; else goto cgrBo;
       cgrBp: // global
           HpAlloc = 56;
           goto cgrBm;
       cgrBm: // global
           R1 = _sgr6W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr6W::P64;
           _sgr6F::P64 = P64[_sgr6W::P64 + 16];
           _sgr6H::P64 = P64[_sgr6W::P64 + 24];
           _sgr6M::P64 = P64[_sgr6W::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgr6M::P64;
           P64[Hp - 24] = _sgr6F::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.False_closure+1;
           R2 = _sgr6H::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr6S_entry() //  [R1, R2]
         { info_tbl: [(cgrBB,
                       label: sat_sgr6S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrBB: // global
           _sgr6P::P64 = R2;
           _sgr6S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgrBC; else goto cgrBD;
       cgrBD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrBF; else goto cgrBE;
       cgrBF: // global
           HpAlloc = 56;
           goto cgrBC;
       cgrBC: // global
           R2 = _sgr6P::P64;
           R1 = _sgr6S::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrBE: // global
           _sgr6H::P64 = P64[_sgr6S::P64 + 7];
           _sgr6M::P64 = P64[_sgr6S::P64 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgr6M::P64;
           P64[Hp - 24] = _sgr6P::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgr6H::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgr6T_entry() //  [R1]
         { info_tbl: [(cgrBG,
                       label: sat_sgr6T_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrBG: // global
           _sgr6T::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrBH; else goto cgrBI;
       cgrBI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrBK; else goto cgrBJ;
       cgrBK: // global
           HpAlloc = 24;
           goto cgrBH;
       cgrBH: // global
           R1 = _sgr6T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrBJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr6T::P64;
           _sgr6H::P64 = P64[_sgr6T::P64 + 16];
           _sgr6I::P64 = P64[_sgr6T::P64 + 24];
           _sgr6M::P64 = P64[_sgr6T::P64 + 32];
           I64[Hp - 16] = sat_sgr6S_info;
           P64[Hp - 8] = _sgr6H::P64;
           P64[Hp] = _sgr6M::P64;
           R2 = _sgr6H::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sgr6I::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgr6Z_entry() //  [R1, R2]
         { info_tbl: [(cgrBL,
                       label: sat_sgr6Z_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrBL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgrBM; else goto cgrBN;
       cgrBM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrBN: // global
           I64[Sp - 40] = block_cgrB5_info;
           _sgr6D::P64 = P64[R1 + 7];
           _sgr6F::P64 = P64[R1 + 15];
           _sgr6H::P64 = P64[R1 + 23];
           _sgr6I::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgr6D::P64;
           P64[Sp - 24] = _sgr6F::P64;
           P64[Sp - 16] = _sgr6H::P64;
           P64[Sp - 8] = _sgr6I::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugrC4; else goto cgrB6;
       ugrC4: // global
           call _cgrB5(R1) args: 0, res: 0, upd: 0;
       cgrB6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrB5() //  [R1]
         { info_tbl: [(cgrB5,
                       label: block_cgrB5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrB5: // global
           I64[Sp - 8] = block_cgrBa_info;
           _sgr6M::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sgr6M::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugrC3; else goto cgrBb;
       ugrC3: // global
           call _cgrBa(R1) args: 0, res: 0, upd: 0;
       cgrBb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrBa() //  [R1]
         { info_tbl: [(cgrBa,
                       label: block_cgrBa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrBa: // global
           _sgr6F::P64 = P64[Sp + 24];
           _sgr6H::P64 = P64[Sp + 32];
           _sgr6M::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cgrBQ; else goto cgrBU;
       cgrBQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgrBT; else goto cgrBS;
       cgrBT: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrBS: // global
           I64[Hp - 72] = sat_sgr6W_info;
           P64[Hp - 56] = _sgr6F::P64;
           P64[Hp - 48] = _sgr6H::P64;
           P64[Hp - 40] = _sgr6M::P64;
           I64[Hp - 32] = sat_sgr6T_info;
           P64[Hp - 16] = _sgr6H::P64;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _sgr6M::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_pp_info;
           P64[Sp + 32] = Hp - 32;
           P64[Sp + 40] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
       cgrBU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrBZ; else goto cgrBY;
       cgrBZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrBY: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgr6M::P64;
           P64[Hp - 24] = _sgr6F::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.True_closure+2;
           R2 = _sgr6H::P64;
           I64[Sp + 32] = stg_ap_p_info;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 32;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgr6J_entry() //  [R1]
         { info_tbl: [(cgrC9,
                       label: sat_sgr6J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrC9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrCa; else goto cgrCb;
       cgrCa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrCb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Fixed.$fDataFixed1_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr70_entry() //  [R1]
         { info_tbl: [(cgrCc,
                       label: sat_sgr70_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrCc: // global
           _sgr70::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrCd; else goto cgrCe;
       cgrCe: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cgrCg; else goto cgrCf;
       cgrCg: // global
           HpAlloc = 96;
           goto cgrCd;
       cgrCd: // global
           R1 = _sgr70::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrCf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr70::P64;
           _sgr6D::P64 = P64[_sgr70::P64 + 16];
           _sgr6E::P64 = P64[_sgr70::P64 + 24];
           _sgr6F::P64 = P64[_sgr70::P64 + 32];
           _sgr6H::P64 = P64[_sgr70::P64 + 40];
           I64[Hp - 88] = lvl18_sgr6I_info;
           P64[Hp - 72] = _sgr6E::P64;
           P64[Hp - 64] = _sgr6F::P64;
           I64[Hp - 56] = sat_sgr6Z_info;
           P64[Hp - 48] = _sgr6D::P64;
           P64[Hp - 40] = _sgr6F::P64;
           P64[Hp - 32] = _sgr6H::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgr6J_info;
           P64[Hp] = _sgr6H::P64;
           R2 = _sgr6H::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cgmapMo_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrCh,
                       label: Data.Fixed.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrCh: // global
           _sgr6F::P64 = R4;
           _sgr6E::P64 = R3;
           _sgr6D::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrCi; else goto cgrCj;
       cgrCj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrCl; else goto cgrCk;
       cgrCl: // global
           HpAlloc = 24;
           goto cgrCi;
       cgrCi: // global
           R4 = _sgr6F::P64;
           R3 = _sgr6E::P64;
           R2 = _sgr6D::P64;
           R1 = Data.Fixed.$w$cgmapMo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrCk: // global
           I64[Hp - 16] = lvl17_sgr6G_info;
           P64[Hp] = _sgr6D::P64;
           I64[Sp - 40] = block_cgrAi_info;
           R2 = _sgr6D::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sgr6D::P64;
           P64[Sp - 16] = _sgr6E::P64;
           P64[Sp - 8] = _sgr6F::P64;
           Sp = Sp - 40;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrAi() //  [R1]
         { info_tbl: [(cgrAi,
                       label: block_cgrAi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrAi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgrCo; else goto cgrCn;
       cgrCo: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrCn: // global
           I64[Hp - 64] = sat_sgr76_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_sgr70_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 63;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.059212871 UTC

[section ""data" . Data.Fixed.$fDataFixed_$cgmapMo_closure" {
     Data.Fixed.$fDataFixed_$cgmapMo_closure:
         const Data.Fixed.$fDataFixed_$cgmapMo_info;
         const 0;
 },
 Data.Fixed.$fDataFixed_$cgmapMo_entry() //  [R3, R4, R5]
         { info_tbl: [(cgrEw,
                       label: Data.Fixed.$fDataFixed_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrEw: // global
           _sgr79::P64 = R4;
           R4 = R5;
           _sgr78::P64 = R3;
           R3 = _sgr79::P64;
           R2 = _sgr78::P64;
           call Data.Fixed.$w$cgmapMo_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.06308283 UTC

[section ""data" . lvl_rgoyF_closure" {
     lvl_rgoyF_closure:
         const lvl_rgoyF_info;
         const 0;
 },
 lvl_rgoyF_entry() //  []
         { info_tbl: [(cgrEH,
                       label: lvl_rgoyF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrEH: // global
           R1 = Data.Fixed.conMkFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.066662758 UTC

[section ""data" . lvl1_rgoyG_closure" {
     lvl1_rgoyG_closure:
         const lvl1_rgoyG_info;
         const 0;
 },
 lvl1_rgoyG_entry() //  []
         { info_tbl: [(cgrET,
                       label: lvl1_rgoyG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrET: // global
           R1 = Data.Fixed.tyFixed_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.072047196 UTC

[section ""data" . lvl2_rgoyH_closure" {
     lvl2_rgoyH_closure:
         const lvl2_rgoyH_info;
 },
 lvl2_rgoyH_entry() //  []
         { info_tbl: [(cgrF5,
                       label: lvl2_rgoyH_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrF5: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.076685477 UTC

[section ""data" . lvl3_rgoyI_closure" {
     lvl3_rgoyI_closure:
         const lvl3_rgoyI_info;
 },
 lvl3_rgoyI_entry() //  []
         { info_tbl: [(cgrFi,
                       label: lvl3_rgoyI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrFi: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.081113536 UTC

[section ""data" . lvl4_rgoyJ_closure" {
     lvl4_rgoyJ_closure:
         const lvl4_rgoyJ_info;
         const 0;
 },
 lvl4_rgoyJ_entry() //  [R2, R3]
         { info_tbl: [(cgrFv,
                       label: lvl4_rgoyJ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrFv: // global
           R3 = R3;
           _sgr7h::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgr7h::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.085823559 UTC

[section ""data" . lvl5_rgoyK_closure" {
     lvl5_rgoyK_closure:
         const lvl5_rgoyK_info;
         const 0;
 },
 sat_sgr7n_entry() //  [R1]
         { info_tbl: [(cgrFK,
                       label: sat_sgr7n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrFK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrFL; else goto cgrFM;
       cgrFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrFM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl5_rgoyK_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrFN,
                       label: lvl5_rgoyK_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrFN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgrFR; else goto cgrFQ;
       cgrFR: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl5_rgoyK_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrFQ: // global
           I64[Hp - 24] = sat_sgr7n_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sgr7k::P64 = R3;
           R3 = Hp - 24;
           _sgr7j::P64 = R2;
           R2 = _sgr7k::P64;
           R1 = _sgr7j::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.093803469 UTC

[section ""data" . lvl6_rgoyL_closure" {
     lvl6_rgoyL_closure:
         const lvl6_rgoyL_info;
         const 0;
 },
 sat_sgr7s_entry() //  [R1]
         { info_tbl: [(cgrGa,
                       label: sat_sgr7s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrGa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrGb; else goto cgrGc;
       cgrGb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrGc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl6_rgoyL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrGd,
                       label: lvl6_rgoyL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrGd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgrGh; else goto cgrGg;
       cgrGh: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl6_rgoyL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrGg: // global
           I64[Hp - 24] = sat_sgr7s_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R3;
           _sgr7o::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgr7o::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.101144063 UTC

[section ""data" . lvl7_rgoyM_closure" {
     lvl7_rgoyM_closure:
         const lvl7_rgoyM_info;
         const 0;
 },
 sat_sgr7v_entry() //  [R1]
         { info_tbl: [(cgrGA,
                       label: sat_sgr7v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrGA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrGB; else goto cgrGC;
       cgrGB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrGC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = Data.Data.$fDataInteger_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rgoyM_entry() //  [R2, R3]
         { info_tbl: [(cgrGE,
                       label: lvl7_rgoyM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrGE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgrGI; else goto cgrGH;
       cgrGI: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rgoyM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrGH: // global
           I64[Hp - 48] = sat_sgr7v_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.109593838 UTC

[section ""data" . lvl8_rgoyN_closure" {
     lvl8_rgoyN_closure:
         const lvl8_rgoyN_info;
         const 0;
 },
 sat_sgr7z_entry() //  [R1]
         { info_tbl: [(cgrH6,
                       label: sat_sgr7z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrH6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrH7; else goto cgrH8;
       cgrH7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrH8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fDataFixed2_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rgoyN_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrH9,
                       label: lvl8_rgoyN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrH9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrHd; else goto cgrHc;
       cgrHd: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl8_rgoyN_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrHc: // global
           I64[Hp - 16] = sat_sgr7z_info;
           P64[Hp] = R3;
           R3 = Hp - 16;
           _sgr7w::P64 = R2;
           R2 = Data.Data.$fDataInteger_closure;
           R1 = _sgr7w::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.116329397 UTC

[section ""data" . Data.Fixed.$fDataFixed_closure" {
     Data.Fixed.$fDataFixed_closure:
         const Data.Fixed.$fDataFixed_info;
         const 0;
 },
 sat_sgr7D_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgrHx,
                       label: sat_sgr7D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrHx: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgmapQi_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr7C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgrHF,
                       label: sat_sgr7C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrHF: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fDataFixed_$cgfoldl_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr7B_entry() //  [R1]
         { info_tbl: [(cgrHM,
                       label: sat_sgr7B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrHM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrHN; else goto cgrHO;
       cgrHN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrHO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fDataFixed7_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fDataFixed_entry() //  [R2]
         { info_tbl: [(cgrHQ,
                       label: Data.Fixed.$fDataFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrHQ: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cgrHU; else goto cgrHT;
       cgrHU: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = Data.Fixed.$fDataFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrHT: // global
           I64[Hp - 176] = sat_sgr7D_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_sgr7C_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sgr7B_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = Data.Data.C:Data_con_info;
           P64[Hp - 112] = Hp - 144;
           P64[Hp - 104] = Hp - 157;
           P64[Hp - 96] = lvl8_rgoyN_closure+3;
           P64[Hp - 88] = lvl_rgoyF_closure+1;
           P64[Hp - 80] = lvl1_rgoyG_closure+1;
           P64[Hp - 72] = lvl2_rgoyH_closure+2;
           P64[Hp - 64] = lvl3_rgoyI_closure+2;
           P64[Hp - 56] = lvl4_rgoyJ_closure+2;
           P64[Hp - 48] = lvl5_rgoyK_closure+4;
           P64[Hp - 40] = lvl6_rgoyL_closure+4;
           P64[Hp - 32] = lvl7_rgoyM_closure+2;
           P64[Hp - 24] = Hp - 173;
           P64[Hp - 16] = Data.Fixed.$w$cgmapM_closure+3;
           P64[Hp - 8] = Data.Fixed.$w$cgmapMp_closure+3;
           P64[Hp] = Data.Fixed.$w$cgmapMo_closure+3;
           R1 = Hp - 119;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.128680864 UTC

[section ""cstring" . Data.Fixed.$tcHasResolution3_bytes" {
     Data.Fixed.$tcHasResolution3_bytes:
         I8[] [72,97,115,82,101,115,111,108,117,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.130532746 UTC

[section ""data" . Data.Fixed.$tcHasResolution2_closure" {
     Data.Fixed.$tcHasResolution2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcHasResolution3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.132297058 UTC

[section ""data" . Data.Fixed.$tcHasResolution_closure" {
     Data.Fixed.$tcHasResolution_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcHasResolution2_closure+1;
         const Data.Fixed.$tcHasResolution1_closure+4;
         const 7410670074803796200;
         const 11622449620609036983;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.134207167 UTC

[section ""cstring" . Data.Fixed.$tcE5_bytes" {
     Data.Fixed.$tcE5_bytes:
         I8[] [69,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.135943204 UTC

[section ""data" . Data.Fixed.$tcE4_closure" {
     Data.Fixed.$tcE4_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.137785761 UTC

[section ""data" . Data.Fixed.$tcE0_closure" {
     Data.Fixed.$tcE0_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE4_closure+1;
         const GHC.Types.krep$*_closure;
         const 1111589946053822622;
         const 14645449775626969178;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.139644211 UTC

[section ""cstring" . Data.Fixed.$tcE8_bytes" {
     Data.Fixed.$tcE8_bytes:
         I8[] [69,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.14148617 UTC

[section ""data" . Data.Fixed.$tcE7_closure" {
     Data.Fixed.$tcE7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE8_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.143370032 UTC

[section ""data" . Data.Fixed.$tcE1_closure" {
     Data.Fixed.$tcE1_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE7_closure+1;
         const GHC.Types.krep$*_closure;
         const 17242267792727872229;
         const 10571291330004494282;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.145237015 UTC

[section ""cstring" . Data.Fixed.$tcE14_bytes" {
     Data.Fixed.$tcE14_bytes:
         I8[] [69,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.147138691 UTC

[section ""data" . Data.Fixed.$tcE13_closure" {
     Data.Fixed.$tcE13_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE14_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.149544486 UTC

[section ""data" . Data.Fixed.$tcE2_closure" {
     Data.Fixed.$tcE2_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE13_closure+1;
         const GHC.Types.krep$*_closure;
         const 18184774527647329547;
         const 15895109557895358229;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.151354833 UTC

[section ""cstring" . Data.Fixed.$tcE16_bytes" {
     Data.Fixed.$tcE16_bytes:
         I8[] [69,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.153101544 UTC

[section ""data" . Data.Fixed.$tcE15_closure" {
     Data.Fixed.$tcE15_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE16_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.154924422 UTC

[section ""data" . Data.Fixed.$tcE3_closure" {
     Data.Fixed.$tcE3_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE15_closure+1;
         const GHC.Types.krep$*_closure;
         const 2281297682271263739;
         const 13982938170987291273;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.156675864 UTC

[section ""cstring" . Data.Fixed.$tcE18_bytes" {
     Data.Fixed.$tcE18_bytes:
         I8[] [69,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.158426456 UTC

[section ""data" . Data.Fixed.$tcE17_closure" {
     Data.Fixed.$tcE17_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE18_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.160211554 UTC

[section ""data" . Data.Fixed.$tcE6_closure" {
     Data.Fixed.$tcE6_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE17_closure+1;
         const GHC.Types.krep$*_closure;
         const 6430880657524859014;
         const 16351944333195325805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.162117655 UTC

[section ""cstring" . Data.Fixed.$tcE20_bytes" {
     Data.Fixed.$tcE20_bytes:
         I8[] [69,57]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.163815536 UTC

[section ""data" . Data.Fixed.$tcE19_closure" {
     Data.Fixed.$tcE19_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE20_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.165665105 UTC

[section ""data" . Data.Fixed.$tcE9_closure" {
     Data.Fixed.$tcE9_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE19_closure+1;
         const GHC.Types.krep$*_closure;
         const 8202840314884717291;
         const 5390706447224283764;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.16773542 UTC

[section ""cstring" . Data.Fixed.$tcE11_bytes" {
     Data.Fixed.$tcE11_bytes:
         I8[] [69,49,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.169629089 UTC

[section ""data" . Data.Fixed.$tcE10_closure" {
     Data.Fixed.$tcE10_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Fixed.$tcE11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.171614049 UTC

[section ""data" . Data.Fixed.$tcE12_closure" {
     Data.Fixed.$tcE12_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Fixed.$trModule_closure+1;
         const Data.Fixed.$tcE10_closure+1;
         const GHC.Types.krep$*_closure;
         const 11177455628646877585;
         const 1804744900678580889;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.174927978 UTC

[section ""data" . Data.Fixed.div'_closure" {
     Data.Fixed.div'_closure:
         const Data.Fixed.div'_info;
         const 0;
 },
 Data.Fixed.div'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrIY,
                       label: Data.Fixed.div'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrIY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgrJ6; else goto cgrJ7;
       cgrJ6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.div'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrJ7: // global
           I64[Sp - 32] = block_cgrIW_info;
           _sgr7E::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _sgr7E::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgrIW() //  [R1]
         { info_tbl: [(cgrIW,
                       label: block_cgrIW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrIW: // global
           I64[Sp] = block_cgrJ1_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cgrJ1() //  [R1]
         { info_tbl: [(cgrJ1,
                       label: block_cgrJ1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrJ1: // global
           _sgr7K::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrJ5_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sgr7K::P64;
           R2 = P64[Sp + 24];
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrJ5() //  [R1, R2]
         { info_tbl: [(cgrJ5,
                       label: block_cgrJ5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrJ5: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.186013306 UTC

[section ""data" . Data.Fixed.$wdivMod'_closure" {
     Data.Fixed.$wdivMod'_closure:
         const Data.Fixed.$wdivMod'_info;
         const 0;
 },
 f_sgr7V_entry() //  [R1]
         { info_tbl: [(cgrJG,
                       label: f_sgr7V_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrJG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrJH; else goto cgrJI;
       cgrJH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrJI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr7X_entry() //  [R1]
         { info_tbl: [(cgrK3,
                       label: sat_sgr7X_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrK3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrK4; else goto cgrK5;
       cgrK4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrK5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr7Y_entry() //  [R1]
         { info_tbl: [(cgrK6,
                       label: sat_sgr7Y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrK6: // global
           _sgr7Y::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgrK7; else goto cgrK8;
       cgrK8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgrKa; else goto cgrK9;
       cgrKa: // global
           HpAlloc = 32;
           goto cgrK7;
       cgrK7: // global
           R1 = _sgr7Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrK9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr7Y::P64;
           _sgr7S::P64 = P64[_sgr7Y::P64 + 16];
           _sgr7V::P64 = P64[_sgr7Y::P64 + 24];
           _sgr7W::P64 = P64[_sgr7Y::P64 + 32];
           I64[Hp - 24] = sat_sgr7X_info;
           P64[Hp - 8] = _sgr7S::P64;
           P64[Hp] = _sgr7V::P64;
           R2 = _sgr7W::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr7Z_entry() //  [R1]
         { info_tbl: [(cgrKb,
                       label: sat_sgr7Z_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrKb: // global
           _sgr7Z::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrKc; else goto cgrKd;
       cgrKd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgrKf; else goto cgrKe;
       cgrKf: // global
           HpAlloc = 40;
           goto cgrKc;
       cgrKc: // global
           R1 = _sgr7Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrKe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr7Z::P64;
           _sgr7S::P64 = P64[_sgr7Z::P64 + 16];
           _sgr7U::P64 = P64[_sgr7Z::P64 + 24];
           _sgr7V::P64 = P64[_sgr7Z::P64 + 32];
           _sgr7W::P64 = P64[_sgr7Z::P64 + 40];
           I64[Hp - 32] = sat_sgr7Y_info;
           P64[Hp - 16] = _sgr7S::P64;
           P64[Hp - 8] = _sgr7V::P64;
           P64[Hp] = _sgr7W::P64;
           R2 = _sgr7W::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sgr7U::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgr80_entry() //  [R1]
         { info_tbl: [(cgrKg,
                       label: sat_sgr80_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrKg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgrKh; else goto cgrKi;
       cgrKh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrKi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgrJN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 48] = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 56;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrJN() //  [R1]
         { info_tbl: [(cgrJN,
                       label: block_cgrJN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrJN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrKl; else goto cgrKk;
       cgrKl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cgrKk: // global
           I64[Hp - 40] = sat_sgr7Z_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = R1;
           _sgr7T::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _sgr7T::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$wdivMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrKm,
                       label: Data.Fixed.$wdivMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrKm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgrKq; else goto cgrKp;
       cgrKq: // global
           HpAlloc = 104;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$wdivMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrKp: // global
           I64[Hp - 96] = f_sgr7V_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           P64[Hp - 56] = R5;
           I64[Hp - 48] = sat_sgr80_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           _cgrJC::P64 = Hp - 96;
           P64[Hp] = _cgrJC::P64;
           R2 = Hp - 48;
           R1 = _cgrJC::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.206094383 UTC

[section ""data" . Data.Fixed.divMod'_closure" {
     Data.Fixed.divMod'_closure:
         const Data.Fixed.divMod'_info;
         const 0;
 },
 Data.Fixed.divMod'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgrLq,
                       label: Data.Fixed.divMod'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrLq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgrLr; else goto cgrLs;
       cgrLr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.divMod'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrLs: // global
           I64[Sp - 8] = block_cgrLn_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$wdivMod'_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrLn() //  [R1, R2]
         { info_tbl: [(cgrLn,
                       label: block_cgrLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrLn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrLv; else goto cgrLu;
       cgrLv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgrLu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.213299837 UTC

[section ""data" . Data.Fixed.mod'_closure" {
     Data.Fixed.mod'_closure:
         const Data.Fixed.mod'_info;
         const 0;
 },
 sat_sgr8c_entry() //  [R1]
         { info_tbl: [(cgrM1,
                       label: sat_sgr8c_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrM1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrM2; else goto cgrM3;
       cgrM2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrM3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.div'_entry(R5,
                                      R4,
                                      R3,
                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr8d_entry() //  [R1]
         { info_tbl: [(cgrM4,
                       label: sat_sgr8d_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrM4: // global
           _sgr8d::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cgrM5; else goto cgrM6;
       cgrM6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgrM8; else goto cgrM7;
       cgrM8: // global
           HpAlloc = 40;
           goto cgrM5;
       cgrM5: // global
           R1 = _sgr8d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrM7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr8d::P64;
           _sgr88::P64 = P64[_sgr8d::P64 + 16];
           _sgr89::P64 = P64[_sgr8d::P64 + 24];
           _sgr8a::P64 = P64[_sgr8d::P64 + 32];
           _sgr8b::P64 = P64[_sgr8d::P64 + 40];
           I64[Hp - 32] = sat_sgr8c_info;
           P64[Hp - 16] = _sgr88::P64;
           P64[Hp - 8] = _sgr89::P64;
           P64[Hp] = _sgr8a::P64;
           R2 = _sgr8b::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgr8e_entry() //  [R1]
         { info_tbl: [(cgrM9,
                       label: sat_sgr8e_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrM9: // global
           _sgr8e::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgrMa; else goto cgrMb;
       cgrMb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrMd; else goto cgrMc;
       cgrMd: // global
           HpAlloc = 48;
           goto cgrMa;
       cgrMa: // global
           R1 = _sgr8e::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrMc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr8e::P64;
           _sgr88::P64 = P64[_sgr8e::P64 + 16];
           _sgr89::P64 = P64[_sgr8e::P64 + 24];
           _sgr8a::P64 = P64[_sgr8e::P64 + 32];
           _sgr8b::P64 = P64[_sgr8e::P64 + 40];
           I64[Hp - 40] = sat_sgr8d_info;
           P64[Hp - 24] = _sgr88::P64;
           P64[Hp - 16] = _sgr89::P64;
           P64[Hp - 8] = _sgr8a::P64;
           P64[Hp] = _sgr8b::P64;
           R2 = _sgr8b::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sgr8a::P64;
           Sp = Sp - 40;
           call GHC.Num.*_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.mod'_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrMe,
                       label: Data.Fixed.mod'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrMe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrMf; else goto cgrMg;
       cgrMf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.mod'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrMg: // global
           I64[Sp - 32] = block_cgrLL_info;
           _sgr88::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sgr88::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrLL() //  [R1]
         { info_tbl: [(cgrLL,
                       label: block_cgrLL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrLL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrMj; else goto cgrMi;
       cgrMj: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrMi: // global
           I64[Hp - 40] = sat_sgr8e_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 8;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.227465101 UTC

[section ""data" . Data.Fixed.$fFractionalFixed2_closure" {
     Data.Fixed.$fFractionalFixed2_closure:
         const Data.Fixed.$fFractionalFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fFractionalFixed2_entry() //  [R1]
         { info_tbl: [(cgrN0,
                       label: Data.Fixed.$fFractionalFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrN0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrN1; else goto cgrN2;
       cgrN1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrN2: // global
           (_cgrMX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrMX::I64 == 0) goto cgrMZ; else goto cgrMY;
       cgrMZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrMY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrMX::I64;
           R2 = $dIP3_rgoyz_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.232517777 UTC

[section ""data" . Data.Fixed.$w$cfromRational_closure" {
     Data.Fixed.$w$cfromRational_closure:
         const Data.Fixed.$w$cfromRational_info;
         const 0;
 },
 Data.Fixed.$w$cfromRational_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrNh,
                       label: Data.Fixed.$w$cfromRational_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrNh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrNt; else goto cgrNu;
       cgrNt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cfromRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrNu: // global
           I64[Sp - 24] = block_cgrNf_info;
           _sgr8f::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgr8f::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrNf() //  [R1]
         { info_tbl: [(cgrNf,
                       label: block_cgrNf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrNf: // global
           I64[Sp] = block_cgrNk_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrNk() //  [R1]
         { info_tbl: [(cgrNk,
                       label: block_cgrNk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrNk: // global
           _sgr8g::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrNo_info;
           R3 = P64[Sp + 16];
           R2 = _sgr8g::P64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrNo() //  [R1]
         { info_tbl: [(cgrNo,
                       label: block_cgrNo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrNo: // global
           _sgr8k::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrNs_info;
           R3 = _sgr8k::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrNs() //  [R1, R2]
         { info_tbl: [(cgrNs,
                       label: block_cgrNs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrNs: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.244396722 UTC

[section ""data" . Data.Fixed.$fFractionalFixed1_closure" {
     Data.Fixed.$fFractionalFixed1_closure:
         const Data.Fixed.$fFractionalFixed1_info;
         const 0;
 },
 Data.Fixed.$fFractionalFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgrO2,
                       label: Data.Fixed.$fFractionalFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrO2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrO3; else goto cgrO4;
       cgrO3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrO4: // global
           I64[Sp - 16] = block_cgrNZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugrO8; else goto cgrO0;
       ugrO8: // global
           call _cgrNZ(R1) args: 0, res: 0, upd: 0;
       cgrO0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrNZ() //  [R1]
         { info_tbl: [(cgrNZ,
                       label: block_cgrNZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrNZ: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Fixed.$w$cfromRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.25240332 UTC

[section ""data" . Data.Fixed.$fRealFixed_$ctoRational_closure" {
     Data.Fixed.$fRealFixed_$ctoRational_closure:
         const Data.Fixed.$fRealFixed_$ctoRational_info;
         const 0;
 },
 Data.Fixed.$fRealFixed_$ctoRational_entry() //  [R2, R3]
         { info_tbl: [(cgrOp,
                       label: Data.Fixed.$fRealFixed_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrOp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrOv; else goto cgrOw;
       cgrOv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_$ctoRational_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrOw: // global
           I64[Sp - 16] = block_cgrOn_info;
           _sgr8t::P64 = R2;
           R2 = R3;
           R1 = _sgr8t::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrOn() //  [R1]
         { info_tbl: [(cgrOn,
                       label: block_cgrOn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrOn: // global
           _sgr8u::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrOs_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgr8u::P64;
           Sp = Sp + 8;
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrOs() //  [R1, R2]
         { info_tbl: [(cgrOs,
                       label: block_cgrOs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrOs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrOA; else goto cgrOz;
       cgrOA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgrOz: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.261940087 UTC

[section ""data" . Data.Fixed.$fFractionalFixed3_closure" {
     Data.Fixed.$fFractionalFixed3_closure:
         const Data.Fixed.$fFractionalFixed3_info;
         const 0;
 },
 section ""relreadonly" . ugrPi_srtd" {
     ugrPi_srtd:
         const Sgrd7_srt+40;
         const 72;
         const 4611686018427387905;
         const 224;
 },
 Data.Fixed.$fFractionalFixed3_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrOZ,
                       label: Data.Fixed.$fFractionalFixed3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrOZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrP0; else goto cgrP1;
       cgrP0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrP1: // global
           I64[Sp - 32] = block_cgrOU_info;
           _sgr8A::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgr8z::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgr8z::P64;
           P64[Sp - 16] = _sgr8A::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrOU() //  [R1]
         { info_tbl: [(cgrOU,
                       label: block_cgrOU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrOU: // global
           if (R1 == 1) goto cgrOY; else goto cgrOX;
       cgrOY: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgrOX: // global
           _sgr8z::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrP4_info;
           R2 = P64[Sp + 16];
           R1 = _sgr8z::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrP4() //  [R1]
         { info_tbl: [(cgrP4,
                       label: block_cgrP4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrP4: // global
           _sgr8A::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrP8_info;
           R3 = R1;
           R2 = _sgr8A::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrP8() //  [R1]
         { info_tbl: [(cgrP8,
                       label: block_cgrP8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrP8: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.274834428 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_$crecip_closure" {
     Data.Fixed.$fFractionalFixed_$crecip_closure:
         const Data.Fixed.$fFractionalFixed_$crecip_info;
         const 0;
 },
 section ""relreadonly" . ugrQ3_srtd" {
     ugrQ3_srtd:
         const Sgrd7_srt+40;
         const 73;
         const 4611686018427387905;
         const 352;
 },
 Data.Fixed.$fFractionalFixed_$crecip_entry() //  [R2, R3]
         { info_tbl: [(cgrPK,
                       label: Data.Fixed.$fFractionalFixed_$crecip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrPK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrPL; else goto cgrPM;
       cgrPL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_$crecip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrPM: // global
           I64[Sp - 24] = block_cgrPF_info;
           _sgr8G::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgr8F::P64 = R2;
           R2 = _sgr8G::P64;
           P64[Sp - 16] = _sgr8F::P64;
           P64[Sp - 8] = _sgr8G::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrPF() //  [R1]
         { info_tbl: [(cgrPF,
                       label: block_cgrPF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrPF: // global
           if (R1 == 1) goto cgrPJ; else goto cgrPI;
       cgrPJ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgrPI: // global
           _sgr8F::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrPP_info;
           R2 = P64[Sp + 16];
           R1 = _sgr8F::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrPP() //  [R1]
         { info_tbl: [(cgrPP,
                       label: block_cgrPP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrPP: // global
           I64[Sp] = block_cgrPT_info;
           R3 = R1;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrPT() //  [R1]
         { info_tbl: [(cgrPT,
                       label: block_cgrPT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrPT: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.287055149 UTC

[section ""data" . Data.Fixed.$fNumFixed_$c*_closure" {
     Data.Fixed.$fNumFixed_$c*_closure:
         const Data.Fixed.$fNumFixed_$c*_info;
         const 0;
 },
 section ""relreadonly" . ugrQO_srtd" {
     ugrQO_srtd:
         const Sgrd7_srt+40;
         const 74;
         const 4611686018427387905;
         const 608;
 },
 Data.Fixed.$fNumFixed_$c*_entry() //  [R2, R3, R4]
         { info_tbl: [(cgrQs,
                       label: Data.Fixed.$fNumFixed_$c*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrQs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrQt; else goto cgrQu;
       cgrQt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_$c*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrQu: // global
           I64[Sp - 24] = block_cgrQq_info;
           _sgr8K::P64 = R2;
           R2 = R3;
           R1 = _sgr8K::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugrQP_srtd" {
     ugrQP_srtd:
         const Sgrd7_srt+40;
         const 71;
         const 4611686018427387905;
         const 96;
 },
 _cgrQq() //  [R1]
         { info_tbl: [(cgrQq,
                       label: block_cgrQq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrQq: // global
           I64[Sp - 8] = block_cgrQx_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrQx() //  [R1]
         { info_tbl: [(cgrQx,
                       label: block_cgrQx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrQx: // global
           if (R1 == 1) goto cgrQN; else goto cgrQF;
       cgrQN: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgrQF: // global
           I64[Sp] = block_cgrQC_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrQC() //  [R1]
         { info_tbl: [(cgrQC,
                       label: block_cgrQC_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrQC: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 32;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.299320921 UTC

[section ""data" . Data.Fixed.$fNumFixed1_closure" {
     Data.Fixed.$fNumFixed1_closure:
         const Data.Fixed.$fNumFixed1_info;
         const 0;
 },
 Data.Fixed.$fNumFixed1_entry() //  [R2, R3]
         { info_tbl: [(cgrRf,
                       label: Data.Fixed.$fNumFixed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrRf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrRg; else goto cgrRh;
       cgrRg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrRh: // global
           I64[Sp - 16] = block_cgrRd_info;
           _sgr8Q::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgr8Q::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrRd() //  [R1]
         { info_tbl: [(cgrRd,
                       label: block_cgrRd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrRd: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.305372211 UTC

[section ""data" . Data.Fixed.$fNumFixed2_closure" {
     Data.Fixed.$fNumFixed2_closure:
         const Data.Fixed.$fNumFixed2_info;
         const 0;
 },
 Data.Fixed.$fNumFixed2_entry() //  [R2, R3]
         { info_tbl: [(cgrRA,
                       label: Data.Fixed.$fNumFixed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrRA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrRE; else goto cgrRF;
       cgrRE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrRF: // global
           I64[Sp - 16] = block_cgrRy_info;
           _sgr8T::P64 = R2;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = _sgr8T::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrRy() //  [R1]
         { info_tbl: [(cgrRy,
                       label: block_cgrRy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrRy: // global
           I64[Sp] = block_cgrRD_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrRD() //  [R1]
         { info_tbl: [(cgrRD,
                       label: block_cgrRD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrRD: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.313343763 UTC

[section ""data" . Data.Fixed.$fNumFixed_closure" {
     Data.Fixed.$fNumFixed_closure:
         const Data.Fixed.$fNumFixed_info;
         const 0;
 },
 sat_sgr90_entry() //  [R1, R2]
         { info_tbl: [(cgrS7,
                       label: sat_sgr90_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrS7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr8Z_entry() //  [R1, R2]
         { info_tbl: [(cgrSf,
                       label: sat_sgr8Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrSf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fNumFixed2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr8Y_entry() //  [R1, R2, R3]
         { info_tbl: [(cgrSn,
                       label: sat_sgr8Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrSn: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fNumFixed_$c*_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugrSw_srtd" {
     ugrSw_srtd:
         const Sgrd7_srt+16;
         const 80;
         const 3;
         const 61440;
 },
 Data.Fixed.$fNumFixed_entry() //  [R2]
         { info_tbl: [(cgrSr,
                       label: Data.Fixed.$fNumFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrSr: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgrSv; else goto cgrSu;
       cgrSv: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fNumFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrSu: // global
           I64[Hp - 104] = sat_sgr90_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgr8Z_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgr8Y_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = GHC.Integer.Type.plusInteger_closure+2;
           P64[Hp - 40] = GHC.Integer.Type.minusInteger_closure+2;
           P64[Hp - 32] = Hp - 70;
           P64[Hp - 24] = GHC.Integer.Type.negateInteger_closure+1;
           P64[Hp - 16] = GHC.Integer.Type.absInteger_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.324570932 UTC

[section ""data" . Data.Fixed.$fFractionalFixed_closure" {
     Data.Fixed.$fFractionalFixed_closure:
         const Data.Fixed.$fFractionalFixed_info;
         const 0;
 },
 sat_sgr95_entry() //  [R1, R2]
         { info_tbl: [(cgrTa,
                       label: sat_sgr95_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrTa: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr94_entry() //  [R1, R2]
         { info_tbl: [(cgrTi,
                       label: sat_sgr94_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrTi: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fFractionalFixed_$crecip_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr93_entry() //  [R1, R2, R3]
         { info_tbl: [(cgrTq,
                       label: sat_sgr93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrTq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr92_entry() //  [R1]
         { info_tbl: [(cgrTx,
                       label: sat_sgr92_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrTy; else goto cgrTz;
       cgrTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fFractionalFixed_entry() //  [R2]
         { info_tbl: [(cgrTB,
                       label: Data.Fixed.$fFractionalFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrTB: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cgrTF; else goto cgrTE;
       cgrTF: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Data.Fixed.$fFractionalFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrTE: // global
           I64[Hp - 104] = sat_sgr95_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgr94_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgr93_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgr92_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Real.C:Fractional_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.336351228 UTC

[section ""data" . Data.Fixed.$fReadFixed2_closure" {
     Data.Fixed.$fReadFixed2_closure:
         const Data.Fixed.$fReadFixed2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed2_entry() //  [R1]
         { info_tbl: [(cgrUh,
                       label: Data.Fixed.$fReadFixed2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrUh: // global
           _rgoxK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgrUk; else goto cgrUl;
       cgrUl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgrUn; else goto cgrUm;
       cgrUn: // global
           HpAlloc = 16;
           goto cgrUk;
       cgrUk: // global
           R1 = _rgoxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrUm: // global
           (_cgrUb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rgoxK::P64);
           if (_cgrUb::I64 == 0) goto cgrUd; else goto cgrUc;
       cgrUd: // global
           call (I64[I64[_rgoxK::P64]])() args: 8, res: 0, upd: 8;
       cgrUc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrUb::I64;
           (_cgrUe::F64) = call MO_F64_Log(10.0 :: W64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _cgrUe::F64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.341882088 UTC

[section ""data" . lvl9_rgoyO_closure" {
     lvl9_rgoyO_closure:
         const GHC.Types.I#_con_info;
         const 172;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.343630678 UTC

[section ""data" . lvl10_rgoyP_closure" {
     lvl10_rgoyP_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.345372012 UTC

[section ""data" . lvl11_rgoyQ_closure" {
     lvl11_rgoyQ_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.347194476 UTC

[section ""data" . lvl12_rgoyR_closure" {
     lvl12_rgoyR_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_rgoyp_closure;
         const loc1_rgoyq_closure;
         const loc3_rgoys_closure;
         const lvl9_rgoyO_closure+1;
         const lvl10_rgoyP_closure+1;
         const lvl9_rgoyO_closure+1;
         const lvl11_rgoyQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.349278753 UTC

[section ""data" . lvl13_rgoyS_closure" {
     lvl13_rgoyS_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rgoyx_closure;
         const lvl12_rgoyR_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.351525922 UTC

[section ""data" . Data.Fixed.$fReadFixed3_closure" {
     Data.Fixed.$fReadFixed3_closure:
         const Data.Fixed.$fReadFixed3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Fixed.$fReadFixed3_entry() //  [R1]
         { info_tbl: [(cgrUK,
                       label: Data.Fixed.$fReadFixed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrUK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrUL; else goto cgrUM;
       cgrUL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrUM: // global
           (_cgrUH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgrUH::I64 == 0) goto cgrUJ; else goto cgrUI;
       cgrUJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgrUI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgrUH::I64;
           R2 = lvl13_rgoyS_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.359550501 UTC

[section ""data" . Data.Fixed.$fReadFixed1_closure" {
     Data.Fixed.$fReadFixed1_closure:
         const Data.Fixed.$fReadFixed1_info;
         const 0;
 },
 lvl17_sgr98_entry() //  [R1]
         { info_tbl: [(cgrV3,
                       label: lvl17_sgr98_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrV4; else goto cgrV5;
       cgrV4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrV5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 e_sgr99_entry() //  [R1]
         { info_tbl: [(cgrVc,
                       label: e_sgr99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgrVo; else goto cgrVp;
       cgrVo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrVp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgrVa_info;
           R2 = Data.Fixed.$fReadFixed3_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgrVa() //  [R1]
         { info_tbl: [(cgrVa,
                       label: block_cgrVa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVa: // global
           I64[Sp] = block_cgrVf_info;
           R2 = R1;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrVf() //  [D1]
         { info_tbl: [(cgrVf,
                       label: block_cgrVf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVf: // global
           _cgrVk::F64 = D1;
           (_cgrVj::F64) = call MO_F64_Log(_cgrVk::F64);
           I64[Sp - 8] = block_cgrVn_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgrVj::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugrWs; else goto cgrVs;
       ugrWs: // global
           call _cgrVn(R1) args: 0, res: 0, upd: 0;
       cgrVs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgrVn() //  [R1]
         { info_tbl: [(cgrVn,
                       label: block_cgrVn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVn: // global
           _sgr9g::F64 = %MO_F_Neg_W64(%MO_F_Quot_W64(F64[Sp + 8],
                                                      F64[R1 + 7]));
           I64[Sp + 8] = block_cgrVD_info;
           D1 = _sgr9g::F64;
           Sp = Sp + 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 24;
     }
 },
 _cgrVD() //  [R1, R2]
         { info_tbl: [(cgrVD,
                       label: block_cgrVD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVD: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cgrVN; else goto cgrWr;
       cgrVN: // global
           I64[Sp] = block_cgrVL_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
       cgrWr: // global
           _sgr9m::I64 = -R2;
           if (%MO_S_Le_W64(_sgr9m::I64, 52)) goto cgrW8; else goto cgrWg;
       cgrW8: // global
           I64[Sp - 8] = block_cgrVZ_info;
           R2 = R1;
           I64[Sp] = _sgr9m::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
       cgrWg: // global
           I64[Sp] = block_cgrWf_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrVL() //  [R1]
         { info_tbl: [(cgrVL,
                       label: block_cgrVL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgrVZ() //  [R1]
         { info_tbl: [(cgrVZ,
                       label: block_cgrVZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrVZ: // global
           _sgr9p::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cgrW6_info;
           R2 = _sgr9p::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrW6() //  [R1]
         { info_tbl: [(cgrW6,
                       label: block_cgrW6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrW6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 _cgrWf() //  [R1]
         { info_tbl: [(cgrWf,
                       label: block_cgrWf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrWf: // global
           if (R1 == 1) goto cgrWq; else goto cgrWm;
       cgrWq: // global
           R1 = Data.Fixed.$fEnumFixed2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cgrWm: // global
           R1 = Data.Fixed.$fEnumFixed1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugrYm_srtd" {
     ugrYm_srtd:
         const Sgrd7_srt+120;
         const 57;
         const 76561193665298433;
 },
 sat_sgr9v_entry() //  [R1]
         { info_tbl: [(cgrWD,
                       label: sat_sgr9v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrWD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgrWE; else goto cgrWF;
       cgrWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgrWB_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugrYn_srtd" {
     ugrYn_srtd:
         const Sgrd7_srt+120;
         const 53;
         const 4503599627370497;
 },
 _cgrWB() //  [R1]
         { info_tbl: [(cgrWB,
                       label: block_cgrWB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrWB: // global
           R3 = R1;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr9t_entry() //  [R1]
         { info_tbl: [(cgrWN,
                       label: sat_sgr9t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrWN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrWO; else goto cgrWP;
       cgrWO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrWP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugrYo_srtd" {
     ugrYo_srtd:
         const Sgrd7_srt+120;
         const 75;
         const 76842668642009089;
         const 1028;
 },
 lvl18_sgr9s_entry() //  [R1]
         { info_tbl: [(cgrWQ,
                       label: lvl18_sgr9s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrWQ: // global
           _sgr9s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cgrWR; else goto cgrWS;
       cgrWS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgrWU; else goto cgrWT;
       cgrWU: // global
           HpAlloc = 48;
           goto cgrWR;
       cgrWR: // global
           R1 = _sgr9s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrWT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr9s::P64;
           _sgr97::P64 = P64[_sgr9s::P64 + 16];
           _sgr99::P64 = P64[_sgr9s::P64 + 24];
           I64[Hp - 40] = sat_sgr9v_info;
           P64[Hp - 24] = _sgr97::P64;
           I64[Hp - 16] = sat_sgr9t_info;
           P64[Hp] = _sgr97::P64;
           R5 = _sgr99::P64;
           R4 = Hp - 40;
           R3 = GHC.Real.$fIntegralInteger_closure;
           R2 = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugrYp_srtd" {
     ugrYp_srtd:
         const Sgrd7_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 x_sgr9F_entry() //  [R1]
         { info_tbl: [(cgrXm,
                       label: x_sgr9F_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXm: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgrXu; else goto cgrXv;
       cgrXu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrXv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cgrXk_info;
           _sgr98::P64 = P64[R1 + 24];
           R3 = _sgr98::P64;
           R2 = P64[R1 + 48];
           P64[Sp - 48] = P64[R1 + 16];
           P64[Sp - 40] = _sgr98::P64;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 56;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugrYq_srtd" {
     ugrYq_srtd:
         const Sgrd7_srt+16;
         const 75;
         const 1;
         const 1026;
 },
 _cgrXk() //  [R1]
         { info_tbl: [(cgrXk,
                       label: block_cgrXk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXk: // global
           _sgr97::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgrXp_info;
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = _sgr97::P64;
           Sp = Sp + 8;
           call Data.Fixed.$fFractionalFixed3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ugrYr_srtd" {
     ugrYr_srtd:
         const Sgrd7_srt+16;
         const 66;
         const 1;
         const 2;
 },
 _cgrXp() //  [R1]
         { info_tbl: [(cgrXp,
                       label: block_cgrXp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXp: // global
           I64[Sp + 16] = block_cgrXt_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgrXt() //  [R1]
         { info_tbl: [(cgrXt,
                       label: block_cgrXt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXt: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr9L_entry() //  [R1, R3]
         { info_tbl: [(cgrXH,
                       label: sat_sgr9L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXH: // global
           R2 = P64[R1 + 6];
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr9M_entry() //  [R1, R2]
         { info_tbl: [(cgrXO,
                       label: sat_sgr9M_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgrXP; else goto cgrXQ;
       cgrXP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrXQ: // global
           I64[Sp - 40] = block_cgrX0_info;
           _sgr97::P64 = P64[R1 + 7];
           _sgr98::P64 = P64[R1 + 15];
           _sgr99::P64 = P64[R1 + 23];
           _sgr9s::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sgr97::P64;
           P64[Sp - 24] = _sgr98::P64;
           P64[Sp - 16] = _sgr99::P64;
           P64[Sp - 8] = _sgr9s::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugrY9; else goto cgrX1;
       ugrY9: // global
           call _cgrX0(R1) args: 0, res: 0, upd: 0;
       cgrX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrX0() //  [R1]
         { info_tbl: [(cgrX0,
                       label: block_cgrX0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrX0: // global
           if (R1 & 7 == 6) goto cgrXM; else goto ugrY4;
       cgrXM: // global
           I64[Sp] = block_cgrX6_info;
           R3 = P64[R1 + 2];
           R2 = P64[Sp + 24];
           call Text.Read.Lex.numberToFixed_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ugrY4: // global
           Sp = Sp + 40;
           call _cgrXX() args: 0, res: 0, upd: 0;
     }
 },
 _cgrX6() //  [R1]
         { info_tbl: [(cgrX6,
                       label: block_cgrX6_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrX6: // global
           if (R1 & 7 == 1) goto ugrY5; else goto cgrXZ;
       ugrY5: // global
           Sp = Sp + 40;
           call _cgrXX() args: 0, res: 0, upd: 0;
       cgrXZ: // global
           I64[Sp] = block_cgrXb_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ugrY7; else goto cgrXc;
       ugrY7: // global
           call _cgrXb(R1) args: 0, res: 0, upd: 0;
       cgrXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgrXb() //  [R1]
         { info_tbl: [(cgrXb,
                       label: block_cgrXb_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgrY2; else goto cgrY1;
       cgrY2: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgrY1: // global
           _sgr9D::P64 = P64[R1 + 7];
           _sgr9E::P64 = P64[R1 + 15];
           I64[Hp - 64] = x_sgr9F_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgr9D::P64;
           P64[Hp - 16] = _sgr9E::P64;
           I64[Hp - 8] = sat_sgr9L_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgrXX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrXX: // global
           R1 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr9w_entry() //  [R1]
         { info_tbl: [(cgrYe,
                       label: sat_sgr9w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrYe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgrYf; else goto cgrYg;
       cgrYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgrYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugrYs_srtd" {
     ugrYs_srtd:
         const Sgrd7_srt+120;
         const 79;
         const 2382685677855703041;
         const 32740;
 },
 Data.Fixed.$fReadFixed1_entry() //  [R2]
         { info_tbl: [(cgrYh,
                       label: Data.Fixed.$fReadFixed1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrYh: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgrYl; else goto cgrYk;
       cgrYl: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrYk: // global
           I64[Hp - 136] = lvl17_sgr98_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = e_sgr99_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = lvl18_sgr9s_info;
           P64[Hp - 72] = R2;
           _cgrV6::P64 = Hp - 112;
           P64[Hp - 64] = _cgrV6::P64;
           I64[Hp - 56] = sat_sgr9M_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = _cgrV6::P64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sgr9w_info;
           P64[Hp] = R2;
           R3 = Hp - 55;
           R2 = Hp - 16;
           R1 = GHC.Read.readNumber1_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.421029694 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadsPrec_closure" {
     Data.Fixed.$fReadFixed_$creadsPrec_closure:
         const Data.Fixed.$fReadFixed_$creadsPrec_info;
         const 0;
 },
 ds_sgr9O_entry() //  [R1]
         { info_tbl: [(cgs12,
                       label: ds_sgr9O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs12: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs13; else goto cgs14;
       cgs13: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs14: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr9Q_entry() //  [R1]
         { info_tbl: [(cgs1e,
                       label: sat_sgr9Q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs1e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs1f; else goto cgs1g;
       cgs1f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs1g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr9R_entry() //  [R1, R2]
         { info_tbl: [(cgs1h,
                       label: sat_sgr9R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs1h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgs1l; else goto cgs1k;
       cgs1l: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgs1k: // global
           _sgr9O::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sgr9Q_info;
           P64[Hp - 8] = _sgr9O::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cgs1m,
                       label: Data.Fixed.$fReadFixed_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs1m: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgs1q; else goto cgs1p;
       cgs1q: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgs1p: // global
           I64[Hp - 32] = ds_sgr9O_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sgr9R_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.43153147 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadListPrec_closure" {
     Data.Fixed.$fReadFixed_$creadListPrec_closure:
         const Data.Fixed.$fReadFixed_$creadListPrec_info;
         const 0;
 },
 sat_sgr9T_entry() //  [R1]
         { info_tbl: [(cgs1X,
                       label: sat_sgr9T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs1X: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fReadFixed_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cgs20,
                       label: Data.Fixed.$fReadFixed_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs20: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgs24; else goto cgs23;
       cgs24: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgs23: // global
           I64[Hp - 16] = sat_sgr9T_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.437609214 UTC

[section ""data" . Data.Fixed.$fReadFixed_$creadList_closure" {
     Data.Fixed.$fReadFixed_$creadList_closure:
         const Data.Fixed.$fReadFixed_$creadList_info;
         const 0;
 },
 sat_sgr9V_entry() //  [R1]
         { info_tbl: [(cgs2p,
                       label: sat_sgr9V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs2p: // global
           R2 = P64[R1 + 16];
           call Data.Fixed.$fReadFixed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgr9W_entry() //  [R1]
         { info_tbl: [(cgs2s,
                       label: sat_sgr9W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs2s: // global
           _sgr9W::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cgs2t; else goto cgs2u;
       cgs2u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgs2w; else goto cgs2v;
       cgs2w: // global
           HpAlloc = 24;
           goto cgs2t;
       cgs2t: // global
           R1 = _sgr9W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs2v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgr9W::P64;
           _sgr9U::P64 = P64[_sgr9W::P64 + 16];
           I64[Hp - 16] = sat_sgr9V_info;
           P64[Hp] = _sgr9U::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_$creadList_entry() //  [R2]
         { info_tbl: [(cgs2x,
                       label: Data.Fixed.$fReadFixed_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs2x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgs2B; else goto cgs2A;
       cgs2B: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgs2A: // global
           I64[Hp - 16] = sat_sgr9W_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.447882895 UTC

[section ""data" . Data.Fixed.$fReadFixed_closure" {
     Data.Fixed.$fReadFixed_closure:
         const Data.Fixed.$fReadFixed_info;
         const 0;
 },
 sat_sgra1_entry() //  [R1]
         { info_tbl: [(cgs33,
                       label: sat_sgra1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs33: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs34; else goto cgs35;
       cgs34: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs35: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgra0_entry() //  [R1]
         { info_tbl: [(cgs3a,
                       label: sat_sgra0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs3a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs3b; else goto cgs3c;
       cgs3b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs3c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr9Z_entry() //  [R1]
         { info_tbl: [(cgs3h,
                       label: sat_sgr9Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs3h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs3i; else goto cgs3j;
       cgs3i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs3j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgr9Y_entry() //  [R1]
         { info_tbl: [(cgs3o,
                       label: sat_sgr9Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs3p; else goto cgs3q;
       cgs3p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs3q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fReadFixed_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fReadFixed_entry() //  [R2]
         { info_tbl: [(cgs3s,
                       label: Data.Fixed.$fReadFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs3s: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgs3w; else goto cgs3v;
       cgs3w: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Fixed.$fReadFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgs3v: // global
           I64[Hp - 128] = sat_sgra1_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgra0_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgr9Z_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgr9Y_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.459616014 UTC

[section ""data" . Data.Fixed.$fEqFixed_closure" {
     Data.Fixed.$fEqFixed_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.461540293 UTC

[section ""data" . Data.Fixed.$fOrdFixed_closure" {
     Data.Fixed.$fOrdFixed_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Fixed.$fEqFixed_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.464075603 UTC

[section ""data" . Data.Fixed.$fRealFixed_closure" {
     Data.Fixed.$fRealFixed_closure:
         const Data.Fixed.$fRealFixed_info;
         const 0;
 },
 sat_sgra4_entry() //  [R1, R2]
         { info_tbl: [(cgs4g,
                       label: sat_sgra4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs4g: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fRealFixed_$ctoRational_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgra3_entry() //  [R1]
         { info_tbl: [(cgs4n,
                       label: sat_sgra3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs4n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs4o; else goto cgs4p;
       cgs4o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs4p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fNumFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$fRealFixed_entry() //  [R2]
         { info_tbl: [(cgs4r,
                       label: Data.Fixed.$fRealFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs4r: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cgs4v; else goto cgs4u;
       cgs4v: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Fixed.$fRealFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgs4u: // global
           I64[Hp - 64] = sat_sgra4_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_sgra3_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Real.C:Real_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Data.Fixed.$fOrdFixed_closure+1;
           P64[Hp] = Hp - 63;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.472909761 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$ctruncate_closure" {
     Data.Fixed.$fRealFracFixed_$ctruncate_closure:
         const Data.Fixed.$fRealFracFixed_$ctruncate_info;
         const 0;
 },
 sat_sgraj_entry() //  [R1]
         { info_tbl: [(cgs58,
                       label: sat_sgraj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs58: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgs59; else goto cgs5a;
       cgs59: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs5a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgs53_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgrab::P64 = P64[R1 + 24];
           R2 = _sgrab::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _sgrab::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgs53() //  [R1]
         { info_tbl: [(cgs53,
                       label: block_cgs53_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs53: // global
           if (R1 == 1) goto cgs57; else goto cgs56;
       cgs57: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cgs56: // global
           _sgrab::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgs5d_info;
           R3 = _sgrab::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgs5d() //  [R1]
         { info_tbl: [(cgs5d,
                       label: block_cgs5d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs5d: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugs5B_srtd" {
     ugs5B_srtd:
         const Sgrd7_srt+464;
         const 43;
         const 4399120386049;
 },
 Data.Fixed.$fRealFracFixed_$ctruncate_entry() //  [R2, R3, R4]
         { info_tbl: [(cgs5k,
                       label: Data.Fixed.$fRealFracFixed_$ctruncate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs5k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgs5q; else goto cgs5r;
       cgs5q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$ctruncate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgs5r: // global
           I64[Sp - 24] = block_cgs4T_info;
           _sgra5::P64 = R2;
           R2 = R4;
           R1 = _sgra5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgs4T() //  [R1]
         { info_tbl: [(cgs4T,
                       label: block_cgs4T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs4T: // global
           I64[Sp] = block_cgs4X_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs4X() //  [R1, R2]
         { info_tbl: [(cgs4X,
                       label: block_cgs4X_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs4X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgs5v; else goto cgs5u;
       cgs5v: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgs5u: // global
           I64[Hp - 24] = sat_sgraj_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           _sgra6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgs5l_info;
           R2 = _sgra6::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs5l() //  [R1]
         { info_tbl: [(cgs5l,
                       label: block_cgs5l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs5l: // global
           I64[Sp] = block_cgs5p_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs5p() //  [R1]
         { info_tbl: [(cgs5p,
                       label: block_cgs5p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs5p: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.490875156 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cround_closure" {
     Data.Fixed.$fRealFracFixed_$cround_closure:
         const Data.Fixed.$fRealFracFixed_$cround_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cround_entry() //  [R2, R3, R4]
         { info_tbl: [(cgs6n,
                       label: Data.Fixed.$fRealFracFixed_$cround_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs6n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgs6r; else goto cgs6s;
       cgs6r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cround_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgs6s: // global
           I64[Sp - 24] = block_cgs6l_info;
           _sgrak::P64 = R2;
           R2 = R4;
           R1 = _sgrak::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgs6l() //  [R1]
         { info_tbl: [(cgs6l,
                       label: block_cgs6l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs6l: // global
           I64[Sp] = block_cgs6q_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs6q() //  [R1, R2]
         { info_tbl: [(cgs6q,
                       label: block_cgs6q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs6q: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.498698223 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cceiling_closure" {
     Data.Fixed.$fRealFracFixed_$cceiling_closure:
         const Data.Fixed.$fRealFracFixed_$cceiling_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cceiling_entry() //  [R2, R3, R4]
         { info_tbl: [(cgs6P,
                       label: Data.Fixed.$fRealFracFixed_$cceiling_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs6P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgs6T; else goto cgs6U;
       cgs6T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cceiling_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgs6U: // global
           I64[Sp - 24] = block_cgs6N_info;
           _sgrar::P64 = R2;
           R2 = R4;
           R1 = _sgrar::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgs6N() //  [R1]
         { info_tbl: [(cgs6N,
                       label: block_cgs6N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs6N: // global
           I64[Sp] = block_cgs6S_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs6S() //  [R1, R2]
         { info_tbl: [(cgs6S,
                       label: block_cgs6S_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs6S: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cceiling_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.506798295 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cfloor_closure" {
     Data.Fixed.$fRealFracFixed_$cfloor_closure:
         const Data.Fixed.$fRealFracFixed_$cfloor_info;
         const 0;
 },
 section ""relreadonly" . ugs7q_srtd" {
     ugs7q_srtd:
         const Sgrd7_srt+472;
         const 49;
         const 334251534843905;
 },
 Data.Fixed.$fRealFracFixed_$cfloor_entry() //  [R2, R3, R4]
         { info_tbl: [(cgs7h,
                       label: Data.Fixed.$fRealFracFixed_$cfloor_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs7h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgs7l; else goto cgs7m;
       cgs7l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cfloor_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgs7m: // global
           I64[Sp - 24] = block_cgs7f_info;
           _sgray::P64 = R2;
           R2 = R4;
           R1 = _sgray::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugs7r_srtd" {
     ugs7r_srtd:
         const Sgrd7_srt+472;
         const 46;
         const 52776558133249;
 },
 _cgs7f() //  [R1]
         { info_tbl: [(cgs7f,
                       label: block_cgs7f_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs7f: // global
           I64[Sp] = block_cgs7k_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = R1;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 16];
           call GHC.Real.$w$s$c/_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs7k() //  [R1, R2]
         { info_tbl: [(cgs7k,
                       label: block_cgs7k_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs7k: // global
           R4 = R2;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Real.$w$s$cfloor_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.515868724 UTC

[section ""data" . Data.Fixed.$w$cproperFraction_closure" {
     Data.Fixed.$w$cproperFraction_closure:
         const Data.Fixed.$w$cproperFraction_info;
         const 0;
 },
 i_sgraI_entry() //  [R1]
         { info_tbl: [(cgs7P,
                       label: i_sgraI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs7P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs7Q; else goto cgs7R;
       cgs7Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs7R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgraM_entry() //  [R1]
         { info_tbl: [(cgs7Y,
                       label: sat_sgraM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs7Y: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgs86; else goto cgs87;
       cgs86: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgs87: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cgs7W_info;
           R2 = Data.Fixed.$fFractionalFixed2_closure;
           _sgraG::P64 = P64[R1 + 24];
           _sgraH::P64 = P64[R1 + 32];
           _sgraI::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _sgraG::P64;
           P64[Sp - 32] = _sgraH::P64;
           P64[Sp - 24] = _sgraI::P64;
           Sp = Sp - 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgs7W() //  [R1]
         { info_tbl: [(cgs7W,
                       label: block_cgs7W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs7W: // global
           _sgraG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cgs81_info;
           R2 = _sgraG::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _cgs81() //  [R1]
         { info_tbl: [(cgs81,
                       label: block_cgs81_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs81: // global
           I64[Sp] = block_cgs85_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgs85() //  [R1]
         { info_tbl: [(cgs85,
                       label: block_cgs85_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs85: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Fixed.$w$cproperFraction_entry() //  [R2, R3, R4]
         { info_tbl: [(cgs8e,
                       label: Data.Fixed.$w$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs8e: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cgs8i; else goto cgs8h;
       cgs8i: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$w$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgs8h: // global
           I64[Hp - 80] = i_sgraI_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_sgraM_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           _cgs7L::P64 = Hp - 80;
           P64[Hp] = _cgs7L::P64;
           R2 = Hp - 40;
           R1 = _cgs7L::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.529833827 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_$cproperFraction_closure" {
     Data.Fixed.$fRealFracFixed_$cproperFraction_closure:
         const Data.Fixed.$fRealFracFixed_$cproperFraction_info;
         const 0;
 },
 Data.Fixed.$fRealFracFixed_$cproperFraction_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cgs8V,
                       label: Data.Fixed.$fRealFracFixed_$cproperFraction_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs8V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgs8W; else goto cgs8X;
       cgs8W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgs8X: // global
           I64[Sp - 8] = block_cgs8S_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Fixed.$w$cproperFraction_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgs8S() //  [R1, R2]
         { info_tbl: [(cgs8S,
                       label: block_cgs8S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs8S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgs90; else goto cgs8Z;
       cgs90: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgs8Z: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.537225417 UTC

[section ""data" . Data.Fixed.$fRealFracFixed_closure" {
     Data.Fixed.$fRealFracFixed_closure:
         const Data.Fixed.$fRealFracFixed_info;
         const 0;
 },
 sat_sgrb0_entry() //  [R1, R2, R3]
         { info_tbl: [(cgs9l,
                       label: sat_sgrb0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs9l: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cfloor_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgraZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cgs9t,
                       label: sat_sgraZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs9t: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cceiling_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgraY_entry() //  [R1, R2, R3]
         { info_tbl: [(cgs9B,
                       label: sat_sgraY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs9B: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cround_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgraX_entry() //  [R1, R2, R3]
         { info_tbl: [(cgs9J,
                       label: sat_sgraX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs9J: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$ctruncate_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgraW_entry() //  [R1, R2, R3]
         { info_tbl: [(cgs9R,
                       label: sat_sgraW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs9R: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fRealFracFixed_$cproperFraction_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgraV_entry() //  [R1]
         { info_tbl: [(cgs9Y,
                       label: sat_sgraV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgs9Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgs9Z; else goto cgsa0;
       cgs9Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgsa0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fFractionalFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgraU_entry() //  [R1]
         { info_tbl: [(cgsa5,
                       label: sat_sgraU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsa5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgsa6; else goto cgsa7;
       cgsa6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgsa7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Fixed.$fRealFixed_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugsae_srtd" {
     ugsae_srtd:
         const Sgrd7_srt+656;
         const 33;
         const 6494224385;
 },
 Data.Fixed.$fRealFracFixed_entry() //  [R2]
         { info_tbl: [(cgsa9,
                       label: Data.Fixed.$fRealFracFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsa9: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cgsad; else goto cgsac;
       cgsad: // global
           HpAlloc = 192;
           R2 = R2;
           R1 = Data.Fixed.$fRealFracFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgsac: // global
           I64[Hp - 184] = sat_sgrb0_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sgraZ_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sgraY_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sgraX_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sgraW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sgraV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sgraU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Real.C:RealFrac_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 118;
           P64[Hp - 24] = Hp - 134;
           P64[Hp - 16] = Hp - 150;
           P64[Hp - 8] = Hp - 166;
           P64[Hp] = Hp - 182;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.556355395 UTC

[section ""data" . chopZeros_rgnn4_closure" {
     chopZeros_rgnn4_closure:
         const chopZeros_rgnn4_info;
         const 0;
 },
 section ""relreadonly" . ugsbG_srtd" {
     ugsbG_srtd:
         const Sgrd7_srt+120;
         const 103;
         const 576460752303423489;
         const 481036337664;
 },
 chopZeros_rgnn4_entry() //  [R2]
         { info_tbl: [(cgsb8,
                       label: chopZeros_rgnn4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsb8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgsb9; else goto ugsbC;
       cgsb9: // global
           R2 = R2;
           R1 = chopZeros_rgnn4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ugsbC: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cgsb0() args: 0, res: 0, upd: 0;
     }
 },
 _cgsb0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsb0: // global
           I64[Sp - 8] = block_cgsb3_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugsbH_srtd" {
     ugsbH_srtd:
         const Sgrd7_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgsb3() //  [R1]
         { info_tbl: [(cgsb3,
                       label: block_cgsb3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsb3: // global
           if (R1 == 1) goto cgsb7; else goto cgsb6;
       cgsb7: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgsb6: // global
           I64[Sp] = block_cgsbd_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugsbI_srtd" {
     ugsbI_srtd:
         const Sgrd7_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgsbd() //  [R1]
         { info_tbl: [(cgsbd,
                       label: block_cgsbd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsbd: // global
           I64[Sp] = block_cgsbi_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugsbJ_srtd" {
     ugsbJ_srtd:
         const Sgrd7_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgsbi() //  [R1]
         { info_tbl: [(cgsbi,
                       label: block_cgsbi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsbi: // global
           _sgrb1::P64 = P64[Sp + 8];
           if (R1 == 1) goto cgsbu; else goto cgsbp;
       cgsbu: // global
           I64[Sp + 8] = block_cgsbs_info;
           R3 = Data.Fixed.$fHasResolutionE4_closure;
           R2 = _sgrb1::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cgsbp: // global
           R2 = _sgrb1::P64;
           Sp = Sp + 16;
           call GHC.Show.$fShowInteger_$cshow_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugsbK_srtd" {
     ugsbK_srtd:
         const Sgrd7_srt+120;
         const 102;
         const 576460752303423489;
         const 206158430720;
 },
 _cgsbs() //  [R1]
         { info_tbl: [(cgsbs,
                       label: block_cgsbs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsbs: // global
           P64[Sp] = R1;
           call _cgsb0() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.572048993 UTC

[section ""data" . lvl14_rgoyT_closure" {
     lvl14_rgoyT_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.573837723 UTC

[section ""data" . lvl15_rgoyU_closure" {
     lvl15_rgoyU_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.575519656 UTC

[section ""cstring" . lvl16_rgoyV_bytes" {
     lvl16_rgoyV_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.583138726 UTC

[section ""data" . Data.Fixed.showFixed_closure" {
     Data.Fixed.showFixed_closure:
         const Data.Fixed.showFixed_info;
         const 0;
 },
 n1_sgrbH_entry() //  [R1]
         { info_tbl: [(cgsdJ,
                       label: n1_sgrbH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsdJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgsdK; else goto cgsdL;
       cgsdK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgsdL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgsdC_info;
           _sgrbt::P64 = P64[R1 + 24];
           _sgrbz::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _sgrbt::P64;
           P64[Sp - 24] = _sgrbz::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugsdS; else goto cgsdD;
       ugsdS: // global
           call _cgsdC(R1) args: 0, res: 0, upd: 0;
       cgsdD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgsdC() //  [R1]
         { info_tbl: [(cgsdC,
                       label: block_cgsdC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsdC: // global
           if (R1 & 7 == 1) goto cgsdG; else goto cgsdH;
       cgsdG: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cgsdH: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call chopZeros_rgnn4_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgrbO_entry() //  [R1]
         { info_tbl: [(cgse7,
                       label: sat_sgrbO_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgse7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgse8; else goto cgse9;
       cgse8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgse9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sgrbK_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sgrbK_entry() //  [R1, R2]
         { info_tbl: [(cgsed,
                       label: $wxs_sgrbK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsed: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgseh; else goto cgseg;
       cgseh: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgseg: // global
           if (R2 == 1) goto cgsec; else goto cgseb;
       cgsec: // global
           _sgrbJ::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sgrbJ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgseb: // global
           I64[Hp - 48] = sat_sgrbO_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rgoyT_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugshA_srtd" {
     ugshA_srtd:
         const Sgrd7_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 sat_sgrc8_entry() //  [R1]
         { info_tbl: [(cgsej,
                       label: sat_sgrc8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsej: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgsek; else goto cgsel;
       cgsek: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgsel: // global
           I64[Sp - 32] = block_cgscG_info;
           _sgrba::P64 = P64[R1 + 24];
           R2 = _sgrba::P64;
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = _sgrba::P64;
           P64[Sp - 8] = P64[R1 + 32];
           Sp = Sp - 32;
           call GHC.Integer.Type.doubleFromInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshB_srtd" {
     ugshB_srtd:
         const Sgrd7_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgscG() //  [D1]
         { info_tbl: [(cgscG,
                       label: block_cgscG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscG: // global
           _cgscL::F64 = D1;
           (_cgscK::F64) = call MO_F64_Log(_cgscL::F64);
           I64[Sp - 8] = block_cgscO_info;
           R1 = Data.Fixed.$fReadFixed2_closure;
           F64[Sp] = _cgscK::F64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugsgP; else goto cgscP;
       ugsgP: // global
           call _cgscO(R1) args: 0, res: 0, upd: 0;
       cgscP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshC_srtd" {
     ugshC_srtd:
         const Sgrd7_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835136;
 },
 _cgscO() //  [R1]
         { info_tbl: [(cgscO,
                       label: block_cgscO_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscO: // global
           _sgrbe::P64 = P64[Sp + 32];
           _sgrbn::F64 = %MO_F_Quot_W64(F64[Sp + 8], F64[R1 + 7]);
           _sgrbo::I64 = %MO_FS_Conv_W64_W64(_sgrbn::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_sgrbo::I64),
                            _sgrbn::F64)) goto cgsgA; else goto cgsgz;
       cgsgA: // global
           _sgrbq::I64 = _sgrbo::I64 + 1;
           goto sgrbp;
       cgsgz: // global
           _sgrbq::I64 = _sgrbo::I64;
           goto sgrbp;
       sgrbp: // global
           if (%MO_S_Ge_W64(_sgrbq::I64, 0)) goto cgsgu; else goto cgsgv;
       cgsgu: // global
           if (_sgrbq::I64 == 0) goto cgsgl; else goto cgsfY;
       cgsgl: // global
           I64[Sp + 8] = block_cgsg8_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = _sgrbe::P64;
           I64[Sp + 32] = _sgrbq::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cgsfY: // global
           I64[Sp] = block_cgsfG_info;
           R3 = _sgrbq::I64;
           R2 = Data.Fixed.$fHasResolutionE4_closure;
           I64[Sp + 8] = _sgrbq::I64;
           call GHC.Real.$wf_entry(R3, R2) args: 8, res: 8, upd: 8;
       cgsgv: // global
           R1 = GHC.Real.^1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ugshD_srtd" {
     ugshD_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgsg8() //  [R1]
         { info_tbl: [(cgsg8,
                       label: block_cgsg8_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsg8: // global
           I64[Sp] = block_cgsgc_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshE_srtd" {
     ugshE_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgsgc() //  [R1]
         { info_tbl: [(cgsgc,
                       label: block_cgsgc_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsgc: // global
           I64[Sp] = block_cgsgg_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshF_srtd" {
     ugshF_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgsgg() //  [R1]
         { info_tbl: [(cgsgg,
                       label: block_cgsgg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsgg: // global
           I64[Sp] = block_cgsgk_info;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsgk() //  [R1]
         { info_tbl: [(cgsgk,
                       label: block_cgsgk_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsgk: // global
           I64[Sp] = I64[Sp + 24];
           P64[Sp + 24] = R1;
           call _sgrbs() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ugshG_srtd" {
     ugshG_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26594437586945;
 },
 _cgsfG() //  [R1]
         { info_tbl: [(cgsfG,
                       label: block_cgsfG_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfG: // global
           I64[Sp] = block_cgsfK_info;
           R3 = R1;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshH_srtd" {
     ugshH_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26525718110209;
 },
 _cgsfK() //  [R1]
         { info_tbl: [(cgsfK,
                       label: block_cgsfK_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfK: // global
           I64[Sp] = block_cgsfO_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshI_srtd" {
     ugshI_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26525718044673;
 },
 _cgsfO() //  [R1]
         { info_tbl: [(cgsfO,
                       label: block_cgsfO_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfO: // global
           I64[Sp] = block_cgsfS_info;
           R3 = Data.Fixed.$fEnumFixed2_closure;
           R2 = R1;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshJ_srtd" {
     ugshJ_srtd:
         const Sgrd7_srt+592;
         const 45;
         const 26388279083009;
 },
 _cgsfS() //  [R1]
         { info_tbl: [(cgsfS,
                       label: block_cgsfS_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfS: // global
           I64[Sp] = block_cgsfW_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsfW() //  [R1]
         { info_tbl: [(cgsfW,
                       label: block_cgsfW_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfW: // global
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _sgrbs() args: 0, res: 0, upd: 0;
     }
 },
 _sgrbs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgrbs: // global
           I64[Sp - 8] = block_cgsep_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugsgY; else goto cgsfi;
       ugsgY: // global
           call _cgsep(R1) args: 0, res: 0, upd: 0;
       cgsfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgsep() //  [R1]
         { info_tbl: [(cgsep,
                       label: block_cgsep_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsep: // global
           if (R1 & 7 == 1) goto ugsgK; else goto cgsft;
       ugsgK: // global
           Sp = Sp + 8;
           call _sgrbu() args: 0, res: 0, upd: 0;
       cgsft: // global
           I64[Sp] = block_cgsfr_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsfr() //  [R1]
         { info_tbl: [(cgsfr,
                       label: block_cgsfr_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfr: // global
           if (R1 == 1) goto ugsgL; else goto ugsgM;
       ugsgL: // global
           Sp = Sp + 40;
           call _cgsfD() args: 0, res: 0, upd: 0;
       ugsgM: // global
           Sp = Sp + 8;
           call _sgrbu() args: 0, res: 0, upd: 0;
     }
 },
 _sgrbu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sgrbu: // global
           I64[Sp - 8] = block_cgsdk_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[Sp + 24];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsdk() //  [R1, R2]
         { info_tbl: [(cgsdk,
                       label: block_cgsdk_info
                       rep:StackRep [True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsdk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgseu; else goto cgset;
       cgseu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgset: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           I64[Sp] = block_cgsdn_info;
           R3 = 0;
           _cgsdm::P64 = Hp - 14;
           R2 = _cgsdm::P64;
           P64[Sp + 24] = _cgsdm::P64;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsdn() //  [R1]
         { info_tbl: [(cgsdn,
                       label: block_cgsdn_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsdn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgsex; else goto cgsew;
       cgsex: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgsew: // global
           _sgrb7::P64 = P64[Sp + 16];
           _sgrbB::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sgrbB::I64)) goto cgseA; else goto cgsf4;
       cgseA: // global
           Hp = Hp - 80;
           I64[Sp + 16] = block_cgsey_info;
           R1 = _sgrb7::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ugsgQ; else goto cgseB;
       ugsgQ: // global
           call _cgsey(R1) args: 0, res: 0, upd: 0;
       cgseB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cgsf4: // global
           I64[Hp - 72] = n1_sgrbH_info;
           P64[Hp - 56] = _sgrb7::P64;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = lvl14_rgoyT_closure+1;
           P64[Hp - 16] = Hp - 72;
           I64[Hp - 8] = $wxs_sgrbK_info;
           P64[Hp] = Hp - 30;
           I64[Sp + 32] = block_cgsf3_info;
           R2 = _sgrbB::I64;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call $wxs_sgrbK_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgsey() //  [R1]
         { info_tbl: [(cgsey,
                       label: block_cgsey_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsey: // global
           if (R1 & 7 == 1) goto cgseH; else goto cgseP;
       cgseH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgseK; else goto cgseJ;
       cgseK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgseJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgseP: // global
           _sgrbt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cgseN_info;
           R2 = _sgrbt::P64;
           Sp = Sp + 16;
           call chopZeros_rgnn4_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgseN() //  [R1]
         { info_tbl: [(cgseN,
                       label: block_cgseN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgseN: // global
           if (R1 & 7 == 1) goto ugsgN; else goto cgseZ;
       ugsgN: // global
           Sp = Sp + 8;
           call _cgsfD() args: 0, res: 0, upd: 0;
       cgseZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgsf2; else goto cgsf1;
       cgsf2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgsf1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgsf3() //  [R1]
         { info_tbl: [(cgsf3,
                       label: block_cgsf3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsf3: // global
           if (R1 & 7 == 1) goto ugsgO; else goto cgsfe;
       ugsgO: // global
           Sp = Sp + 8;
           call _cgsfD() args: 0, res: 0, upd: 0;
       cgsfe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgsfh; else goto cgsfg;
       cgsfh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgsfg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl15_rgoyU_closure+1;
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgsfD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsfD: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgrcb_entry() //  [R1]
         { info_tbl: [(cgsh7,
                       label: sat_sgrcb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsh7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgsh8; else goto cgsh9;
       cgsh8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgsh9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cgsh5_info;
           R2 = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cgsh5() //  [R1]
         { info_tbl: [(cgsh5,
                       label: block_cgsh5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsh5: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ugshK_srtd" {
     ugshK_srtd:
         const Sgrd7_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 Data.Fixed.showFixed_entry() //  [R2, R3, R4]
         { info_tbl: [(cgshg,
                       label: Data.Fixed.showFixed_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgshg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgshh; else goto cgshi;
       cgshh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.showFixed_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgshi: // global
           I64[Sp - 32] = block_cgscm_info;
           _sgrb7::P64 = R3;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           _sgrb6::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sgrb6::P64;
           P64[Sp - 16] = _sgrb7::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshL_srtd" {
     ugshL_srtd:
         const Sgrd7_srt+120;
         const 108;
         const 1729382256910270465;
         const 17323767368512;
 },
 _cgscm() //  [R1]
         { info_tbl: [(cgscm,
                       label: block_cgscm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscm: // global
           _sgrb6::P64 = P64[Sp + 8];
           _sgrb8::P64 = P64[Sp + 24];
           if (R1 == 1) goto cgshf; else goto cgshe;
       cgshf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgshz; else goto cgshy;
       cgshz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cgshy: // global
           I64[Hp - 32] = sat_sgrcb_info;
           P64[Hp - 16] = _sgrb6::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgrb8::P64;
           R3 = Hp - 32;
           R2 = lvl16_rgoyV_bytes;
           Sp = Sp + 32;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cgshe: // global
           I64[Sp + 8] = block_cgscq_info;
           R2 = _sgrb8::P64;
           R1 = _sgrb6::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshM_srtd" {
     ugshM_srtd:
         const Sgrd7_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgscq() //  [R1]
         { info_tbl: [(cgscq,
                       label: block_cgscq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscq: // global
           I64[Sp - 8] = block_cgscu_info;
           R3 = Data.Fixed.$fEnumFixed1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshN_srtd" {
     ugshN_srtd:
         const Sgrd7_srt+120;
         const 108;
         const 1729382256910270465;
         const 12925720857408;
 },
 _cgscu() //  [R1]
         { info_tbl: [(cgscu,
                       label: block_cgscu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscu: // global
           if (R1 == 1) goto cgshw; else goto cgsho;
       cgshw: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cgsho: // global
           I64[Sp] = block_cgscy_info;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshO_srtd" {
     ugshO_srtd:
         const Sgrd7_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgscy() //  [R1, R2]
         { info_tbl: [(cgscy,
                       label: block_cgscy_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscy: // global
           I64[Sp] = block_cgscA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           _sgrbe::P64 = R2;
           R2 = 0;
           P64[Sp + 24] = _sgrbe::P64;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ugshP_srtd" {
     ugshP_srtd:
         const Sgrd7_srt+120;
         const 106;
         const 576460752303423489;
         const 4129627835200;
 },
 _cgscA() //  [R1, R2]
         { info_tbl: [(cgscA,
                       label: block_cgscA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgscA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgshs; else goto cgshr;
       cgshs: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgshr: // global
           I64[Hp - 56] = sat_sgrc8_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 56;
           R2 = Hp - 14;
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.665883824 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshow_closure" {
     Data.Fixed.$fShowFixed_$cshow_closure:
         const Data.Fixed.$fShowFixed_$cshow_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cgslk,
                       label: Data.Fixed.$fShowFixed_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgslk: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.669754801 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowsPrec_closure" {
     Data.Fixed.$fShowFixed_$cshowsPrec_closure:
         const Data.Fixed.$fShowFixed_$cshowsPrec_info;
         const 0;
 },
 Data.Fixed.$fShowFixed_$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgsly,
                       label: Data.Fixed.$fShowFixed_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgslz; else goto cgslA;
       cgslz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowsPrec_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgslA: // global
           I64[Sp - 16] = block_cgslw_info;
           R4 = R4;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           P64[Sp - 8] = R5;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgslw() //  [R1]
         { info_tbl: [(cgslw,
                       label: block_cgslw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgslw: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.67643839 UTC

[section ""data" . Data.Fixed.$fShowFixed_$cshowList_closure" {
     Data.Fixed.$fShowFixed_$cshowList_closure:
         const Data.Fixed.$fShowFixed_$cshowList_info;
         const 0;
 },
 sat_sgrco_entry() //  [R1, R2, R3]
         { info_tbl: [(cgslZ,
                       label: sat_sgrco_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgslZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgsm0; else goto cgsm1;
       cgsm0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgsm1: // global
           I64[Sp - 16] = block_cgslX_info;
           R4 = R2;
           _sgrcm::P64 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sgrcm::P64;
           Sp = Sp - 16;
           call Data.Fixed.showFixed_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgslX() //  [R1]
         { info_tbl: [(cgslX,
                       label: block_cgslX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgslX: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(cgsm5,
                       label: Data.Fixed.$fShowFixed_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsm5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgsm9; else goto cgsm8;
       cgsm9: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgsm8: // global
           I64[Hp - 8] = sat_sgrco_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.684659781 UTC

[section ""data" . Data.Fixed.$fShowFixed_closure" {
     Data.Fixed.$fShowFixed_closure:
         const Data.Fixed.$fShowFixed_info;
         const 0;
 },
 sat_sgrcs_entry() //  [R1, R2, R3]
         { info_tbl: [(cgsmx,
                       label: sat_sgrcs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsmx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Fixed.$fShowFixed_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgrcr_entry() //  [R1, R2]
         { info_tbl: [(cgsmF,
                       label: sat_sgrcr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsmF: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Fixed.$fShowFixed_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgrcq_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgsmN,
                       label: sat_sgrcq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsmN: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Fixed.$fShowFixed_$cshowsPrec_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Fixed.$fShowFixed_entry() //  [R2]
         { info_tbl: [(cgsmR,
                       label: Data.Fixed.$fShowFixed_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsmR: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgsmV; else goto cgsmU;
       cgsmV: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Fixed.$fShowFixed_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgsmU: // global
           I64[Hp - 72] = sat_sgrcs_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgrcr_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgrcq_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:12:23.69406455 UTC

[section ""relreadonly" . Sgrd7_srt" {
     Sgrd7_srt:
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThenTo_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const sat_sgr4I_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromTo_closure;
         const Data.Fixed.$fEnumFixed_$cenumFromThen_closure;
         const Data.Fixed.$fEnumFixed3_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const Data.Fixed.$fHasResolutionE0_$cresolution_closure;
         const sat_sgr58_closure;
         const Data.Fixed.$fHasResolutionE4_closure;
         const Data.Fixed.$fHasResolutionE1_$cresolution_closure;
         const sat_sgr5b_closure;
         const Data.Fixed.$fHasResolutionE7_closure;
         const Data.Fixed.$fHasResolutionE2_$cresolution_closure;
         const sat_sgr5e_closure;
         const Data.Fixed.$fHasResolutionE8_closure;
         const Data.Fixed.$fHasResolutionE3_$cresolution_closure;
         const sat_sgr5h_closure;
         const Data.Fixed.$fHasResolutionE10_closure;
         const Data.Fixed.$fHasResolutionE6_$cresolution_closure;
         const sat_sgr5k_closure;
         const Data.Fixed.$fHasResolutionE11_closure;
         const Data.Fixed.$fHasResolutionE9_$cresolution_closure;
         const sat_sgr5p_closure;
         const Data.Fixed.$fHasResolutionE5_closure;
         const Data.Fixed.$fHasResolutionE12_$cresolution_closure;
         const GHC.List.badHead_closure;
         const w2_rgoyl_closure;
         const go61_rgoym_closure;
         const Data.Data.mkConstr1_closure;
         const Data.Fixed.$fDataFixed4_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Fixed.$fDataFixed8_closure;
         const Data.Data.$fDataInteger_closure;
         const Data.Fixed.$w$cgmapMp_closure;
         const Data.Fixed.$w$cgmapM_closure;
         const Data.Maybe.fromJust1_closure;
         const Data.Fixed.$fDataFixed_$cgmapQi_closure;
         const Data.Fixed.$w$cgmapMo_closure;
         const Data.Fixed.conMkFixed_closure;
         const Data.Fixed.tyFixed_closure;
         const lvl5_rgoyK_closure;
         const lvl6_rgoyL_closure;
         const lvl7_rgoyM_closure;
         const lvl8_rgoyN_closure;
         const Data.Fixed.$fDataFixed_$cgfoldl_closure;
         const Data.Fixed.$fDataFixed7_closure;
         const Data.Fixed.$fDataFixed_closure;
         const lvl_rgoyF_closure;
         const lvl1_rgoyG_closure;
         const lvl4_rgoyJ_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.div'_closure;
         const Data.Fixed.$wdivMod'_closure;
         const Data.Fixed.divMod'_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Data.Fixed.mod'_closure;
         const GHC.Err.undefined_closure;
         const $dIP3_rgoyz_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Fixed.$w$cfromRational_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const Data.Fixed.$fFractionalFixed1_closure;
         const Data.Fixed.$fRealFixed_$ctoRational_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const Data.Fixed.$fFractionalFixed3_closure;
         const Data.Fixed.$fFractionalFixed_$crecip_closure;
         const Data.Fixed.$fNumFixed_$c*_closure;
         const Data.Fixed.$fNumFixed1_closure;
         const Data.Fixed.$fNumFixed2_closure;
         const Data.Fixed.$fNumFixed_closure;
         const Data.Fixed.$fFractionalFixed_closure;
         const lvl13_rgoyS_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const Data.Fixed.$fReadFixed2_closure;
         const Data.Fixed.$fReadFixed3_closure;
         const Data.Fixed.$fEnumFixed2_closure;
         const Data.Fixed.$fEnumFixed1_closure;
         const GHC.Real.^_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Text.Read.Lex.numberToFixed_closure;
         const GHC.Read.readNumber1_closure;
         const Data.Fixed.$fReadFixed1_closure;
         const Data.Fixed.$fReadFixed_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Fixed.$fReadFixed_$creadListPrec_closure;
         const Data.Fixed.$fReadFixed_$creadList_closure;
         const Data.Fixed.$fReadFixed_closure;
         const Data.Fixed.$fRealFixed_closure;
         const Data.Fixed.$fRealFracFixed_$ctruncate_closure;
         const GHC.Real.$w$s$cround_closure;
         const Data.Fixed.$fRealFracFixed_$cround_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const GHC.Real.$w$s$c/_closure;
         const GHC.Real.$w$s$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cceiling_closure;
         const Data.Fixed.$fRealFracFixed_$cfloor_closure;
         const GHC.Real.$w$s$cfloor_closure;
         const Data.Fixed.$fFractionalFixed2_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const Data.Fixed.$w$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_$cproperFraction_closure;
         const Data.Fixed.$fRealFracFixed_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Show.$fShowInteger_$cshow_closure;
         const chopZeros_rgnn4_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Real.^1_closure;
         const GHC.Real.$wf_closure;
         const Data.Fixed.showFixed_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const Data.Fixed.$fShowFixed_$cshowsPrec_closure;
         const Data.Fixed.$fShowFixed_$cshowList_closure;
         const Data.Fixed.$fShowFixed_$cshow_closure;
         const Data.Fixed.$fShowFixed_closure;
 }]

