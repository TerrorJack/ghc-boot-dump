
==================== Pre unarise: ====================
2018-03-16 16:09:03.35835383 UTC

Data.Bitraversable.$p1Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifunctor.Bifunctor t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdOxA]
        case v_sdOxA of {
          Data.Bitraversable.C:Bitraversable v_sdOxC [Occ=Once]
                                             _ [Occ=Dead]
                                             _ [Occ=Dead] ->
              v_sdOxC;
        };

Data.Bitraversable.$p2Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifoldable.Bifoldable t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdOxF]
        case v_sdOxF of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             v_sdOxI [Occ=Once]
                                             _ [Occ=Dead] ->
              v_sdOxI;
        };

Data.Bitraversable.bitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdOxK]
        case v_sdOxK of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             _ [Occ=Dead]
                                             v_sdOxO [Occ=Once] ->
              v_sdOxO;
        };

Data.Bitraversable.$fBitraversable(,)_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOxP f1_sdOxQ g_sdOxR ds_sdOxS]
        let {
          sat_sdOy2 [Occ=Once] :: f_adOkV d_adOkZ
          [LclId] =
              [g_sdOxR ds_sdOxS] \u []
                  let {
                    sat_sdOy1 [Occ=Once] :: b_adOkY
                    [LclId] =
                        [ds_sdOxS] \u []
                            case ds_sdOxS of {
                              (,) _ [Occ=Dead] b1_sdOy0 [Occ=Once] -> b1_sdOy0;
                            };
                  } in  g_sdOxR sat_sdOy1; } in
        let {
          sat_sdOxX [Occ=Once] :: f_adOkV c_adOkX
          [LclId] =
              [f1_sdOxQ ds_sdOxS] \u []
                  let {
                    sat_sdOxW [Occ=Once] :: a_adOkW
                    [LclId] =
                        [ds_sdOxS] \u []
                            case ds_sdOxS of {
                              (,) a1_sdOxU [Occ=Once] _ [Occ=Dead] -> a1_sdOxU;
                            };
                  } in  f1_sdOxQ sat_sdOxW;
        } in 
          GHC.Base.liftA2
              $dApplicative_sdOxP GHC.Tuple.(,) sat_sdOxX sat_sdOy2;

Data.Bitraversable.$fBitraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,)
                                                       Data.Bifoldable.$fBifoldable(,)
                                                       Data.Bitraversable.$fBitraversable(,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
  :: forall x (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, a, b) -> f (x, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOy3 f1_sdOy4 g_sdOy5 ds_sdOy6]
        let {
          sat_sdOyo [Occ=Once] :: f_adOks d_adOkw
          [LclId] =
              [g_sdOy5 ds_sdOy6] \u []
                  let {
                    sat_sdOyn [Occ=Once] :: b_adOkv
                    [LclId] =
                        [ds_sdOy6] \u []
                            case ds_sdOy6 of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdOym [Occ=Once] -> b1_sdOym;
                            };
                  } in  g_sdOy5 sat_sdOyn; } in
        let {
          sat_sdOyi [Occ=Once] :: f_adOks c_adOku
          [LclId] =
              [f1_sdOy4 ds_sdOy6] \u []
                  let {
                    sat_sdOyh [Occ=Once] :: a_adOkt
                    [LclId] =
                        [ds_sdOy6] \u []
                            case ds_sdOy6 of {
                              (,,) _ [Occ=Dead] a1_sdOyf [Occ=Once] _ [Occ=Dead] -> a1_sdOyf;
                            };
                  } in  f1_sdOy4 sat_sdOyh; } in
        let {
          sat_sdOyb [Occ=OnceL] :: x_adOkg
          [LclId] =
              [ds_sdOy6] \u []
                  case ds_sdOy6 of {
                    (,,) x1_sdOy8 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x1_sdOy8;
                  }; } in
        let {
          sat_sdOyc [Occ=Once]
            :: c_adOku -> d_adOkw -> (x_adOkg, c_adOku, d_adOkw)
          [LclId] =
              [sat_sdOyb] \r [eta_B2 eta_B1] (,,) [sat_sdOyb eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOy3 sat_sdOyc sat_sdOyi sat_sdOyo;

Data.Bitraversable.$fBitraversable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bitraversable.Bitraversable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,)
                                                       Data.Bifoldable.$fBifoldable(,,)
                                                       Data.Bitraversable.$fBitraversable(,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
  :: forall x y (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, a, b) -> f (x, y, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOyp f1_sdOyq g_sdOyr ds_sdOys]
        let {
          sat_sdOyT [Occ=Once] :: f_adOjX d_adOk1
          [LclId] =
              [g_sdOyr ds_sdOys] \u []
                  let {
                    sat_sdOyS [Occ=Once] :: b_adOk0
                    [LclId] =
                        [ds_sdOys] \u []
                            case ds_sdOys of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdOyR [Occ=Once] ->
                                  b1_sdOyR;
                            };
                  } in  g_sdOyr sat_sdOyS; } in
        let {
          sat_sdOyM [Occ=Once] :: f_adOjX c_adOjZ
          [LclId] =
              [f1_sdOyq ds_sdOys] \u []
                  let {
                    sat_sdOyL [Occ=Once] :: a_adOjY
                    [LclId] =
                        [ds_sdOys] \u []
                            case ds_sdOys of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdOyJ [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdOyJ;
                            };
                  } in  f1_sdOyq sat_sdOyL; } in
        let {
          sat_sdOyE [Occ=OnceL] :: y_adOjL
          [LclId] =
              [ds_sdOys] \u []
                  case ds_sdOys of {
                    (,,,) _ [Occ=Dead] y1_sdOyB [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        y1_sdOyB;
                  }; } in
        let {
          sat_sdOyy [Occ=OnceL] :: x_adOjK
          [LclId] =
              [ds_sdOys] \u []
                  case ds_sdOys of {
                    (,,,) x1_sdOyu [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x1_sdOyu;
                  }; } in
        let {
          sat_sdOyF [Occ=Once]
            :: c_adOjZ -> d_adOk1 -> (x_adOjK, y_adOjL, c_adOjZ, d_adOk1)
          [LclId] =
              [sat_sdOyy sat_sdOyE] \r [eta_B2 eta_B1]
                  (,,,) [sat_sdOyy sat_sdOyE eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOyp sat_sdOyF sat_sdOyM sat_sdOyT;

Data.Bitraversable.$fBitraversable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bitraversable.Bitraversable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
  :: forall x y z (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, z, a, b) -> f (x, y, z, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOyU f1_sdOyV g_sdOyW ds_sdOyX]
        let {
          sat_sdOzz [Occ=Once] :: f_adOjq d_adOju
          [LclId] =
              [g_sdOyW ds_sdOyX] \u []
                  let {
                    sat_sdOzy [Occ=Once] :: b_adOjt
                    [LclId] =
                        [ds_sdOyX] \u []
                            case ds_sdOyX of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdOzx [Occ=Once] ->
                                  b1_sdOzx;
                            };
                  } in  g_sdOyW sat_sdOzy; } in
        let {
          sat_sdOzr [Occ=Once] :: f_adOjq c_adOjs
          [LclId] =
              [f1_sdOyV ds_sdOyX] \u []
                  let {
                    sat_sdOzq [Occ=Once] :: a_adOjr
                    [LclId] =
                        [ds_sdOyX] \u []
                            case ds_sdOyX of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdOzo [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdOzo;
                            };
                  } in  f1_sdOyV sat_sdOzq; } in
        let {
          sat_sdOzi [Occ=OnceL] :: z_adOje
          [LclId] =
              [ds_sdOyX] \u []
                  case ds_sdOyX of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           z1_sdOzf [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        z1_sdOzf;
                  }; } in
        let {
          sat_sdOzb [Occ=OnceL] :: y_adOjd
          [LclId] =
              [ds_sdOyX] \u []
                  case ds_sdOyX of {
                    (,,,,) _ [Occ=Dead]
                           y1_sdOz7 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        y1_sdOz7;
                  }; } in
        let {
          sat_sdOz4 [Occ=OnceL] :: x_adOjc
          [LclId] =
              [ds_sdOyX] \u []
                  case ds_sdOyX of {
                    (,,,,) x1_sdOyZ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x1_sdOyZ;
                  }; } in
        let {
          sat_sdOzj [Occ=Once]
            :: c_adOjs
               -> d_adOju -> (x_adOjc, y_adOjd, z_adOje, c_adOjs, d_adOju)
          [LclId] =
              [sat_sdOz4 sat_sdOzb sat_sdOzi] \r [eta_B2 eta_B1]
                  (,,,,) [sat_sdOz4 sat_sdOzb sat_sdOzi eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOyU sat_sdOzj sat_sdOzr sat_sdOzz;

Data.Bitraversable.$fBitraversable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bitraversable.Bitraversable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
  :: forall x y z w (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, a, b) -> f (x, y, z, w, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOzA f1_sdOzB g_sdOzC ds_sdOzD]
        let {
          sat_sdOAs [Occ=Once] :: f_adOiR d_adOiV
          [LclId] =
              [g_sdOzC ds_sdOzD] \u []
                  let {
                    sat_sdOAr [Occ=Once] :: b_adOiU
                    [LclId] =
                        [ds_sdOzD] \u []
                            case ds_sdOzD of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdOAq [Occ=Once] ->
                                  b1_sdOAq;
                            };
                  } in  g_sdOzC sat_sdOAr; } in
        let {
          sat_sdOAj [Occ=Once] :: f_adOiR c_adOiT
          [LclId] =
              [f1_sdOzB ds_sdOzD] \u []
                  let {
                    sat_sdOAi [Occ=Once] :: a_adOiS
                    [LclId] =
                        [ds_sdOzD] \u []
                            case ds_sdOzD of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdOAg [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdOAg;
                            };
                  } in  f1_sdOzB sat_sdOAi; } in
        let {
          sat_sdOA9 [Occ=OnceL] :: w_adOiF
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            w1_sdOA6 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        w1_sdOA6;
                  }; } in
        let {
          sat_sdOA1 [Occ=OnceL] :: z_adOiE
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            z1_sdOzX [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        z1_sdOzX;
                  }; } in
        let {
          sat_sdOzT [Occ=OnceL] :: y_adOiD
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) _ [Occ=Dead]
                            y1_sdOzO [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        y1_sdOzO;
                  }; } in
        let {
          sat_sdOzL [Occ=OnceL] :: x_adOiC
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) x1_sdOzF [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x1_sdOzF;
                  }; } in
        let {
          sat_sdOAa [Occ=Once]
            :: c_adOiT
               -> d_adOiV
               -> (x_adOiC, y_adOiD, z_adOiE, w_adOiF, c_adOiT, d_adOiV)
          [LclId] =
              [sat_sdOzL sat_sdOzT sat_sdOA1 sat_sdOA9] \r [eta_B2 eta_B1]
                  (,,,,,) [sat_sdOzL sat_sdOzT sat_sdOA1 sat_sdOA9 eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOzA sat_sdOAa sat_sdOAj sat_sdOAs;

Data.Bitraversable.$fBitraversable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w.
     Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
  :: forall x y z w v (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, v, a, b) -> f (x, y, z, w, v, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOAt f1_sdOAu g_sdOAv ds_sdOAw]
        let {
          sat_sdOBA [Occ=Once] :: f_adOig d_adOik
          [LclId] =
              [g_sdOAv ds_sdOAw] \u []
                  let {
                    sat_sdOBz [Occ=Once] :: b_adOij
                    [LclId] =
                        [ds_sdOAw] \u []
                            case ds_sdOAw of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdOBy [Occ=Once] ->
                                  b1_sdOBy;
                            };
                  } in  g_sdOAv sat_sdOBz; } in
        let {
          sat_sdOBq [Occ=Once] :: f_adOig c_adOii
          [LclId] =
              [f1_sdOAu ds_sdOAw] \u []
                  let {
                    sat_sdOBp [Occ=Once] :: a_adOih
                    [LclId] =
                        [ds_sdOAw] \u []
                            case ds_sdOAw of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdOBn [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdOBn;
                            };
                  } in  f1_sdOAu sat_sdOBp; } in
        let {
          sat_sdOBf [Occ=OnceL] :: v_adOi4
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             v1_sdOBc [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        v1_sdOBc;
                  }; } in
        let {
          sat_sdOB6 [Occ=OnceL] :: w_adOi3
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             w1_sdOB2 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        w1_sdOB2;
                  }; } in
        let {
          sat_sdOAX [Occ=OnceL] :: z_adOi2
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             z1_sdOAS [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        z1_sdOAS;
                  }; } in
        let {
          sat_sdOAO [Occ=OnceL] :: y_adOi1
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             y1_sdOAI [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        y1_sdOAI;
                  }; } in
        let {
          sat_sdOAF [Occ=OnceL] :: x_adOi0
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) x1_sdOAy [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x1_sdOAy;
                  }; } in
        let {
          sat_sdOBg [Occ=Once]
            :: c_adOii
               -> d_adOik
               -> (x_adOi0, y_adOi1, z_adOi2, w_adOi3, v_adOi4, c_adOii, d_adOik)
          [LclId] =
              [sat_sdOAF sat_sdOAO sat_sdOAX sat_sdOB6 sat_sdOBf] \r [eta_B2
                                                                      eta_B1]
                  (,,,,,,) [sat_sdOAF
                            sat_sdOAO
                            sat_sdOAX
                            sat_sdOB6
                            sat_sdOBf
                            eta_B2
                            eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOAt sat_sdOBg sat_sdOBq sat_sdOBA;

Data.Bitraversable.$fBitraversable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversableEither_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Either.Either a b
     -> f (Data.Either.Either c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOBB eta_sdOBC eta1_sdOBD eta2_sdOBE]
        case eta2_sdOBE of {
          Data.Either.Left a1_sdOBG [Occ=Once] ->
              let {
                sat_sdOBI [Occ=Once] :: f_adOhE c_adOhG
                [LclId] =
                    [eta_sdOBC a1_sdOBG] \u [] eta_sdOBC a1_sdOBG;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdOBB of sat_sdOBH {
                  __DEFAULT -> GHC.Base.fmap sat_sdOBH Data.Either.Left sat_sdOBI;
                };
          Data.Either.Right b1_sdOBJ [Occ=Once] ->
              let {
                sat_sdOBL [Occ=Once] :: f_adOhE d_adOhI
                [LclId] =
                    [eta1_sdOBD b1_sdOBJ] \u [] eta1_sdOBD b1_sdOBJ;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdOBB of sat_sdOBK {
                  __DEFAULT -> GHC.Base.fmap sat_sdOBK Data.Either.Right sat_sdOBL;
                };
        };

Data.Bitraversable.$fBitraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorEither
                                                       Data.Bifoldable.$fBifoldableEither
                                                       Data.Bitraversable.$fBitraversableEither_$cbitraverse];

Data.Bitraversable.$fBitraversableConst1 :: forall c. c -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdOBM] v_sdOBM;

Data.Bitraversable.$fBitraversableConst_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Functor.Const.Const a b
     -> f (Data.Functor.Const.Const c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOBN eta_sdOBO eta1_sdOBP eta2_sdOBQ]
        let {
          sat_sdOBS [Occ=Once] :: f_adOhc c_adOhe
          [LclId] =
              [eta_sdOBO eta2_sdOBQ] \u [] eta_sdOBO eta2_sdOBQ;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdOBN of sat_sdOBR {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdOBR Data.Bitraversable.$fBitraversableConst1 sat_sdOBS;
          };

Data.Bitraversable.$fBitraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorConst
                                                       Data.Bifoldable.$fBifoldableConst
                                                       Data.Bitraversable.$fBitraversableConst_$cbitraverse];

Data.Bitraversable.$fBitraversableK1_$cbitraverse
  :: forall i (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> GHC.Generics.K1 i a b -> f (GHC.Generics.K1 i c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOBT eta_sdOBU eta1_sdOBV eta2_sdOBW]
        let {
          sat_sdOBY [Occ=Once] :: f_adOgJ c_adOgL
          [LclId] =
              [eta_sdOBU eta2_sdOBW] \u [] eta_sdOBU eta2_sdOBW;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdOBT of sat_sdOBX {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdOBX Data.Bitraversable.$fBitraversableConst1 sat_sdOBY;
          };

Data.Bitraversable.$fBitraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorK1
                                                       Data.Bifoldable.$fBifoldableK1
                                                       Data.Bitraversable.$fBitraversableK1_$cbitraverse];

Data.Bitraversable.bimapM
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOBZ $dApplicative_sdOC0]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOBZ $dApplicative_sdOC0;

Data.Bitraversable.bisequence
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOC1 $dApplicative_sdOC2]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOC1 $dApplicative_sdOC2 GHC.Base.id GHC.Base.id;

Data.Bitraversable.bisequenceA
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bitraversable.bisequence eta_B2 eta_B1;

Data.Bitraversable.$dmbitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(C(U))),A,A),A,1*C1(C1(C1(C(U)))))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOC3 eta_sdOC4 eta1_sdOC5 eta2_sdOC6]
        let {
          f1_sdOC7 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
               -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [$dBitraversable_sdOC3 eta_sdOC4] \u []
                  Data.Bitraversable.bitraverse
                      $dBitraversable_sdOC3 eta_sdOC4 GHC.Base.id GHC.Base.id; } in
        let {
          g_sdOC8 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x a_adOga b_adOgc
               -> t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
          [LclId] =
              [$dBitraversable_sdOC3 eta1_sdOC5 eta2_sdOC6] \u []
                  case
                      Data.Bitraversable.$p1Bitraversable $dBitraversable_sdOC3
                  of
                  sat_sdOC9
                  { __DEFAULT ->
                        Data.Bifunctor.bimap sat_sdOC9 eta1_sdOC5 eta2_sdOC6;
                  }; } in
        let {
          sat_sdOCc [Occ=OnceT[0]]
            :: t_adO2x a_adOga b_adOgc -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [f1_sdOC7 g_sdOC8] \r [x_sdOCa]
                  let {
                    sat_sdOCb [Occ=Once] :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
                    [LclId] =
                        [g_sdOC8 x_sdOCa] \u [] g_sdOC8 x_sdOCa;
                  } in  f1_sdOC7 sat_sdOCb;
        } in  sat_sdOCc;

Data.Bitraversable.bifor
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOCd
           $dApplicative_sdOCe
           t1_sdOCf
           f1_sdOCg
           g_sdOCh]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOCd
            $dApplicative_sdOCe
            f1_sdOCg
            g_sdOCh
            t1_sdOCf;

Data.Bitraversable.biforM
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.bifor eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bitraversable.bimapAccumL
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOCi f_sdOCj g_sdOCk s_sdOCl t1_sdOCm]
        let {
          sat_sdOCs [Occ=Once]
            :: d_adOee -> Data.Functor.Utils.StateL a_adOeb e_adOef
          [LclId] =
              [g_sdOCk] \r [x_sdOCq y_sdOCr] g_sdOCk y_sdOCr x_sdOCq; } in
        let {
          sat_sdOCp [Occ=Once]
            :: b_adOec -> Data.Functor.Utils.StateL a_adOeb c_adOed
          [LclId] =
              [f_sdOCj] \r [x_sdOCn y_sdOCo] f_sdOCj y_sdOCo x_sdOCn;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdOCi
              Data.Functor.Utils.$fApplicativeStateL
              sat_sdOCp
              sat_sdOCs
              t1_sdOCm
              s_sdOCl;

Data.Bitraversable.bimapAccumR
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOCt f_sdOCu g_sdOCv s_sdOCw t1_sdOCx]
        let {
          sat_sdOCD [Occ=Once]
            :: d_adOdF -> Data.Functor.Utils.StateR a_adOdC e_adOdG
          [LclId] =
              [g_sdOCv] \r [x_sdOCB y_sdOCC] g_sdOCv y_sdOCC x_sdOCB; } in
        let {
          sat_sdOCA [Occ=Once]
            :: b_adOdD -> Data.Functor.Utils.StateR a_adOdC c_adOdE
          [LclId] =
              [f_sdOCu] \r [x_sdOCy y_sdOCz] f_sdOCu y_sdOCz x_sdOCy;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdOCt
              Data.Functor.Utils.$fApplicativeStateR
              sat_sdOCA
              sat_sdOCD
              t1_sdOCx
              s_sdOCw;

bimapDefault1_rdOxw
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> (c -> Data.Functor.Identity.Identity d)
     -> t a c
     -> Data.Functor.Identity.Identity (t b d)
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdOCE]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOCE Data.Functor.Identity.$fApplicativeIdentity;

Data.Bitraversable.bimapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> b) -> (c -> d) -> t a c -> t b d
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B1] bimapDefault1_rdOxw eta_B1;

bifoldMapDefault1_rdOxx
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> (b -> Data.Functor.Const.Const m ())
     -> t a b
     -> Data.Functor.Const.Const m (t () ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdOCF $dMonoid_sdOCG]
        let {
          sat_sdOCH [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_adOct)
          [LclId] =
              [$dMonoid_sdOCG] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sdOCG;
        } in 
          Data.Bitraversable.bitraverse $dBitraversable_sdOCF sat_sdOCH;

Data.Bitraversable.bifoldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> m) -> (b -> m) -> t a b -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] bifoldMapDefault1_rdOxx eta_B2 eta_B1;

Data.Bitraversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bitraversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule4];

Data.Bitraversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bitraversable"#;

Data.Bitraversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule2];

Data.Bitraversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bitraversable.$trModule3
                                     Data.Bitraversable.$trModule1];

$krep_rdOxy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bitraversable.$tcBitraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdOxy];

Data.Bitraversable.$tcBitraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bitraversable"#;

Data.Bitraversable.$tcBitraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$tcBitraversable3];

Data.Bitraversable.$tcBitraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1654555613294690493##
                                    8030854156262073676##
                                    Data.Bitraversable.$trModule
                                    Data.Bitraversable.$tcBitraversable2
                                    0#
                                    Data.Bitraversable.$tcBitraversable1];

Data.Bitraversable.C:Bitraversable
  :: forall (t :: * -> * -> *).
     (Data.Bifunctor.Bifunctor t, Data.Bifoldable.Bifoldable t) =>
     (forall (f :: * -> *) a c b d.
      GHC.Base.Applicative f =>
      (a -> f c) -> (b -> f d) -> t a b -> f (t c d))
     -> Data.Bitraversable.Bitraversable t
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.C:Bitraversable [eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:09:03.374953058 UTC

Data.Bitraversable.$p1Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifunctor.Bifunctor t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdOxA]
        case v_sdOxA of {
          Data.Bitraversable.C:Bitraversable v_sdOxC [Occ=Once]
                                             _ [Occ=Dead]
                                             _ [Occ=Dead] ->
              v_sdOxC;
        };

Data.Bitraversable.$p2Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifoldable.Bifoldable t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdOxF]
        case v_sdOxF of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             v_sdOxI [Occ=Once]
                                             _ [Occ=Dead] ->
              v_sdOxI;
        };

Data.Bitraversable.bitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdOxK]
        case v_sdOxK of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             _ [Occ=Dead]
                                             v_sdOxO [Occ=Once] ->
              v_sdOxO;
        };

Data.Bitraversable.$fBitraversable(,)_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOxP f1_sdOxQ g_sdOxR ds_sdOxS]
        let {
          sat_sdOy2 [Occ=Once] :: f_adOkV d_adOkZ
          [LclId] =
              [g_sdOxR ds_sdOxS] \u []
                  let {
                    sat_sdOy1 [Occ=Once] :: b_adOkY
                    [LclId] =
                        [ds_sdOxS] \u []
                            case ds_sdOxS of {
                              (,) _ [Occ=Dead] b1_sdOy0 [Occ=Once] -> b1_sdOy0;
                            };
                  } in  g_sdOxR sat_sdOy1; } in
        let {
          sat_sdOxX [Occ=Once] :: f_adOkV c_adOkX
          [LclId] =
              [f1_sdOxQ ds_sdOxS] \u []
                  let {
                    sat_sdOxW [Occ=Once] :: a_adOkW
                    [LclId] =
                        [ds_sdOxS] \u []
                            case ds_sdOxS of {
                              (,) a1_sdOxU [Occ=Once] _ [Occ=Dead] -> a1_sdOxU;
                            };
                  } in  f1_sdOxQ sat_sdOxW;
        } in 
          GHC.Base.liftA2
              $dApplicative_sdOxP GHC.Tuple.(,) sat_sdOxX sat_sdOy2;

Data.Bitraversable.$fBitraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,)
                                                       Data.Bifoldable.$fBifoldable(,)
                                                       Data.Bitraversable.$fBitraversable(,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
  :: forall x (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, a, b) -> f (x, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOy3 f1_sdOy4 g_sdOy5 ds_sdOy6]
        let {
          sat_sdOyo [Occ=Once] :: f_adOks d_adOkw
          [LclId] =
              [g_sdOy5 ds_sdOy6] \u []
                  let {
                    sat_sdOyn [Occ=Once] :: b_adOkv
                    [LclId] =
                        [ds_sdOy6] \u []
                            case ds_sdOy6 of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdOym [Occ=Once] -> b1_sdOym;
                            };
                  } in  g_sdOy5 sat_sdOyn; } in
        let {
          sat_sdOyi [Occ=Once] :: f_adOks c_adOku
          [LclId] =
              [f1_sdOy4 ds_sdOy6] \u []
                  let {
                    sat_sdOyh [Occ=Once] :: a_adOkt
                    [LclId] =
                        [ds_sdOy6] \u []
                            case ds_sdOy6 of {
                              (,,) _ [Occ=Dead] a1_sdOyf [Occ=Once] _ [Occ=Dead] -> a1_sdOyf;
                            };
                  } in  f1_sdOy4 sat_sdOyh; } in
        let {
          sat_sdOyb [Occ=OnceL] :: x_adOkg
          [LclId] =
              [ds_sdOy6] \u []
                  case ds_sdOy6 of {
                    (,,) x1_sdOy8 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x1_sdOy8;
                  }; } in
        let {
          sat_sdOyc [Occ=Once]
            :: c_adOku -> d_adOkw -> (x_adOkg, c_adOku, d_adOkw)
          [LclId] =
              [sat_sdOyb] \r [eta_B2 eta_B1] (,,) [sat_sdOyb eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOy3 sat_sdOyc sat_sdOyi sat_sdOyo;

Data.Bitraversable.$fBitraversable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bitraversable.Bitraversable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,)
                                                       Data.Bifoldable.$fBifoldable(,,)
                                                       Data.Bitraversable.$fBitraversable(,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
  :: forall x y (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, a, b) -> f (x, y, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOyp f1_sdOyq g_sdOyr ds_sdOys]
        let {
          sat_sdOyT [Occ=Once] :: f_adOjX d_adOk1
          [LclId] =
              [g_sdOyr ds_sdOys] \u []
                  let {
                    sat_sdOyS [Occ=Once] :: b_adOk0
                    [LclId] =
                        [ds_sdOys] \u []
                            case ds_sdOys of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdOyR [Occ=Once] ->
                                  b1_sdOyR;
                            };
                  } in  g_sdOyr sat_sdOyS; } in
        let {
          sat_sdOyM [Occ=Once] :: f_adOjX c_adOjZ
          [LclId] =
              [f1_sdOyq ds_sdOys] \u []
                  let {
                    sat_sdOyL [Occ=Once] :: a_adOjY
                    [LclId] =
                        [ds_sdOys] \u []
                            case ds_sdOys of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdOyJ [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdOyJ;
                            };
                  } in  f1_sdOyq sat_sdOyL; } in
        let {
          sat_sdOyE [Occ=OnceL] :: y_adOjL
          [LclId] =
              [ds_sdOys] \u []
                  case ds_sdOys of {
                    (,,,) _ [Occ=Dead] y1_sdOyB [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        y1_sdOyB;
                  }; } in
        let {
          sat_sdOyy [Occ=OnceL] :: x_adOjK
          [LclId] =
              [ds_sdOys] \u []
                  case ds_sdOys of {
                    (,,,) x1_sdOyu [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x1_sdOyu;
                  }; } in
        let {
          sat_sdOyF [Occ=Once]
            :: c_adOjZ -> d_adOk1 -> (x_adOjK, y_adOjL, c_adOjZ, d_adOk1)
          [LclId] =
              [sat_sdOyy sat_sdOyE] \r [eta_B2 eta_B1]
                  (,,,) [sat_sdOyy sat_sdOyE eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOyp sat_sdOyF sat_sdOyM sat_sdOyT;

Data.Bitraversable.$fBitraversable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bitraversable.Bitraversable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
  :: forall x y z (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, z, a, b) -> f (x, y, z, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOyU f1_sdOyV g_sdOyW ds_sdOyX]
        let {
          sat_sdOzz [Occ=Once] :: f_adOjq d_adOju
          [LclId] =
              [g_sdOyW ds_sdOyX] \u []
                  let {
                    sat_sdOzy [Occ=Once] :: b_adOjt
                    [LclId] =
                        [ds_sdOyX] \u []
                            case ds_sdOyX of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdOzx [Occ=Once] ->
                                  b1_sdOzx;
                            };
                  } in  g_sdOyW sat_sdOzy; } in
        let {
          sat_sdOzr [Occ=Once] :: f_adOjq c_adOjs
          [LclId] =
              [f1_sdOyV ds_sdOyX] \u []
                  let {
                    sat_sdOzq [Occ=Once] :: a_adOjr
                    [LclId] =
                        [ds_sdOyX] \u []
                            case ds_sdOyX of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdOzo [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdOzo;
                            };
                  } in  f1_sdOyV sat_sdOzq; } in
        let {
          sat_sdOzi [Occ=OnceL] :: z_adOje
          [LclId] =
              [ds_sdOyX] \u []
                  case ds_sdOyX of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           z1_sdOzf [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        z1_sdOzf;
                  }; } in
        let {
          sat_sdOzb [Occ=OnceL] :: y_adOjd
          [LclId] =
              [ds_sdOyX] \u []
                  case ds_sdOyX of {
                    (,,,,) _ [Occ=Dead]
                           y1_sdOz7 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        y1_sdOz7;
                  }; } in
        let {
          sat_sdOz4 [Occ=OnceL] :: x_adOjc
          [LclId] =
              [ds_sdOyX] \u []
                  case ds_sdOyX of {
                    (,,,,) x1_sdOyZ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x1_sdOyZ;
                  }; } in
        let {
          sat_sdOzj [Occ=Once]
            :: c_adOjs
               -> d_adOju -> (x_adOjc, y_adOjd, z_adOje, c_adOjs, d_adOju)
          [LclId] =
              [sat_sdOz4 sat_sdOzb sat_sdOzi] \r [eta_B2 eta_B1]
                  (,,,,) [sat_sdOz4 sat_sdOzb sat_sdOzi eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOyU sat_sdOzj sat_sdOzr sat_sdOzz;

Data.Bitraversable.$fBitraversable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bitraversable.Bitraversable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
  :: forall x y z w (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, a, b) -> f (x, y, z, w, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOzA f1_sdOzB g_sdOzC ds_sdOzD]
        let {
          sat_sdOAs [Occ=Once] :: f_adOiR d_adOiV
          [LclId] =
              [g_sdOzC ds_sdOzD] \u []
                  let {
                    sat_sdOAr [Occ=Once] :: b_adOiU
                    [LclId] =
                        [ds_sdOzD] \u []
                            case ds_sdOzD of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdOAq [Occ=Once] ->
                                  b1_sdOAq;
                            };
                  } in  g_sdOzC sat_sdOAr; } in
        let {
          sat_sdOAj [Occ=Once] :: f_adOiR c_adOiT
          [LclId] =
              [f1_sdOzB ds_sdOzD] \u []
                  let {
                    sat_sdOAi [Occ=Once] :: a_adOiS
                    [LclId] =
                        [ds_sdOzD] \u []
                            case ds_sdOzD of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdOAg [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdOAg;
                            };
                  } in  f1_sdOzB sat_sdOAi; } in
        let {
          sat_sdOA9 [Occ=OnceL] :: w_adOiF
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            w1_sdOA6 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        w1_sdOA6;
                  }; } in
        let {
          sat_sdOA1 [Occ=OnceL] :: z_adOiE
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            z1_sdOzX [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        z1_sdOzX;
                  }; } in
        let {
          sat_sdOzT [Occ=OnceL] :: y_adOiD
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) _ [Occ=Dead]
                            y1_sdOzO [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        y1_sdOzO;
                  }; } in
        let {
          sat_sdOzL [Occ=OnceL] :: x_adOiC
          [LclId] =
              [ds_sdOzD] \u []
                  case ds_sdOzD of {
                    (,,,,,) x1_sdOzF [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x1_sdOzF;
                  }; } in
        let {
          sat_sdOAa [Occ=Once]
            :: c_adOiT
               -> d_adOiV
               -> (x_adOiC, y_adOiD, z_adOiE, w_adOiF, c_adOiT, d_adOiV)
          [LclId] =
              [sat_sdOzL sat_sdOzT sat_sdOA1 sat_sdOA9] \r [eta_B2 eta_B1]
                  (,,,,,) [sat_sdOzL sat_sdOzT sat_sdOA1 sat_sdOA9 eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOzA sat_sdOAa sat_sdOAj sat_sdOAs;

Data.Bitraversable.$fBitraversable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w.
     Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
  :: forall x y z w v (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, v, a, b) -> f (x, y, z, w, v, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOAt f1_sdOAu g_sdOAv ds_sdOAw]
        let {
          sat_sdOBA [Occ=Once] :: f_adOig d_adOik
          [LclId] =
              [g_sdOAv ds_sdOAw] \u []
                  let {
                    sat_sdOBz [Occ=Once] :: b_adOij
                    [LclId] =
                        [ds_sdOAw] \u []
                            case ds_sdOAw of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdOBy [Occ=Once] ->
                                  b1_sdOBy;
                            };
                  } in  g_sdOAv sat_sdOBz; } in
        let {
          sat_sdOBq [Occ=Once] :: f_adOig c_adOii
          [LclId] =
              [f1_sdOAu ds_sdOAw] \u []
                  let {
                    sat_sdOBp [Occ=Once] :: a_adOih
                    [LclId] =
                        [ds_sdOAw] \u []
                            case ds_sdOAw of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdOBn [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdOBn;
                            };
                  } in  f1_sdOAu sat_sdOBp; } in
        let {
          sat_sdOBf [Occ=OnceL] :: v_adOi4
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             v1_sdOBc [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        v1_sdOBc;
                  }; } in
        let {
          sat_sdOB6 [Occ=OnceL] :: w_adOi3
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             w1_sdOB2 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        w1_sdOB2;
                  }; } in
        let {
          sat_sdOAX [Occ=OnceL] :: z_adOi2
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             z1_sdOAS [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        z1_sdOAS;
                  }; } in
        let {
          sat_sdOAO [Occ=OnceL] :: y_adOi1
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) _ [Occ=Dead]
                             y1_sdOAI [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        y1_sdOAI;
                  }; } in
        let {
          sat_sdOAF [Occ=OnceL] :: x_adOi0
          [LclId] =
              [ds_sdOAw] \u []
                  case ds_sdOAw of {
                    (,,,,,,) x1_sdOAy [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x1_sdOAy;
                  }; } in
        let {
          sat_sdOBg [Occ=Once]
            :: c_adOii
               -> d_adOik
               -> (x_adOi0, y_adOi1, z_adOi2, w_adOi3, v_adOi4, c_adOii, d_adOik)
          [LclId] =
              [sat_sdOAF sat_sdOAO sat_sdOAX sat_sdOB6 sat_sdOBf] \r [eta_B2
                                                                      eta_B1]
                  (,,,,,,) [sat_sdOAF
                            sat_sdOAO
                            sat_sdOAX
                            sat_sdOB6
                            sat_sdOBf
                            eta_B2
                            eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdOAt sat_sdOBg sat_sdOBq sat_sdOBA;

Data.Bitraversable.$fBitraversable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversableEither_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Either.Either a b
     -> f (Data.Either.Either c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOBB eta_sdOBC eta1_sdOBD eta2_sdOBE]
        case eta2_sdOBE of {
          Data.Either.Left a1_sdOBG [Occ=Once] ->
              let {
                sat_sdOBI [Occ=Once] :: f_adOhE c_adOhG
                [LclId] =
                    [eta_sdOBC a1_sdOBG] \u [] eta_sdOBC a1_sdOBG;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdOBB of sat_sdOBH {
                  __DEFAULT -> GHC.Base.fmap sat_sdOBH Data.Either.Left sat_sdOBI;
                };
          Data.Either.Right b1_sdOBJ [Occ=Once] ->
              let {
                sat_sdOBL [Occ=Once] :: f_adOhE d_adOhI
                [LclId] =
                    [eta1_sdOBD b1_sdOBJ] \u [] eta1_sdOBD b1_sdOBJ;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdOBB of sat_sdOBK {
                  __DEFAULT -> GHC.Base.fmap sat_sdOBK Data.Either.Right sat_sdOBL;
                };
        };

Data.Bitraversable.$fBitraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorEither
                                                       Data.Bifoldable.$fBifoldableEither
                                                       Data.Bitraversable.$fBitraversableEither_$cbitraverse];

Data.Bitraversable.$fBitraversableConst1 :: forall c. c -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdOBM] v_sdOBM;

Data.Bitraversable.$fBitraversableConst_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Functor.Const.Const a b
     -> f (Data.Functor.Const.Const c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOBN eta_sdOBO eta1_sdOBP eta2_sdOBQ]
        let {
          sat_sdOBS [Occ=Once] :: f_adOhc c_adOhe
          [LclId] =
              [eta_sdOBO eta2_sdOBQ] \u [] eta_sdOBO eta2_sdOBQ;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdOBN of sat_sdOBR {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdOBR Data.Bitraversable.$fBitraversableConst1 sat_sdOBS;
          };

Data.Bitraversable.$fBitraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorConst
                                                       Data.Bifoldable.$fBifoldableConst
                                                       Data.Bitraversable.$fBitraversableConst_$cbitraverse];

Data.Bitraversable.$fBitraversableK1_$cbitraverse
  :: forall i (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> GHC.Generics.K1 i a b -> f (GHC.Generics.K1 i c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdOBT eta_sdOBU eta1_sdOBV eta2_sdOBW]
        let {
          sat_sdOBY [Occ=Once] :: f_adOgJ c_adOgL
          [LclId] =
              [eta_sdOBU eta2_sdOBW] \u [] eta_sdOBU eta2_sdOBW;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdOBT of sat_sdOBX {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdOBX Data.Bitraversable.$fBitraversableConst1 sat_sdOBY;
          };

Data.Bitraversable.$fBitraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorK1
                                                       Data.Bifoldable.$fBifoldableK1
                                                       Data.Bitraversable.$fBitraversableK1_$cbitraverse];

Data.Bitraversable.bimapM
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOBZ $dApplicative_sdOC0]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOBZ $dApplicative_sdOC0;

Data.Bitraversable.bisequence
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOC1 $dApplicative_sdOC2]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOC1 $dApplicative_sdOC2 GHC.Base.id GHC.Base.id;

Data.Bitraversable.bisequenceA
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bitraversable.bisequence eta_B2 eta_B1;

Data.Bitraversable.$dmbitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(C(U))),A,A),A,1*C1(C1(C1(C(U)))))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOC3 eta_sdOC4 eta1_sdOC5 eta2_sdOC6]
        let {
          f1_sdOC7 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
               -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [$dBitraversable_sdOC3 eta_sdOC4] \u []
                  Data.Bitraversable.bitraverse
                      $dBitraversable_sdOC3 eta_sdOC4 GHC.Base.id GHC.Base.id; } in
        let {
          g_sdOC8 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x a_adOga b_adOgc
               -> t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
          [LclId] =
              [$dBitraversable_sdOC3 eta1_sdOC5 eta2_sdOC6] \u []
                  case
                      Data.Bitraversable.$p1Bitraversable $dBitraversable_sdOC3
                  of
                  sat_sdOC9
                  { __DEFAULT ->
                        Data.Bifunctor.bimap sat_sdOC9 eta1_sdOC5 eta2_sdOC6;
                  }; } in
        let {
          sat_sdOCc [Occ=OnceT[0]]
            :: t_adO2x a_adOga b_adOgc -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [f1_sdOC7 g_sdOC8] \r [x_sdOCa]
                  let {
                    sat_sdOCb [Occ=Once] :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
                    [LclId] =
                        [g_sdOC8 x_sdOCa] \u [] g_sdOC8 x_sdOCa;
                  } in  f1_sdOC7 sat_sdOCb;
        } in  sat_sdOCc;

Data.Bitraversable.bifor
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOCd
           $dApplicative_sdOCe
           t1_sdOCf
           f1_sdOCg
           g_sdOCh]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOCd
            $dApplicative_sdOCe
            f1_sdOCg
            g_sdOCh
            t1_sdOCf;

Data.Bitraversable.biforM
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.bifor eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bitraversable.bimapAccumL
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOCi f_sdOCj g_sdOCk s_sdOCl t1_sdOCm]
        let {
          sat_sdOCs [Occ=Once]
            :: d_adOee -> Data.Functor.Utils.StateL a_adOeb e_adOef
          [LclId] =
              [g_sdOCk] \r [x_sdOCq y_sdOCr] g_sdOCk y_sdOCr x_sdOCq; } in
        let {
          sat_sdOCp [Occ=Once]
            :: b_adOec -> Data.Functor.Utils.StateL a_adOeb c_adOed
          [LclId] =
              [f_sdOCj] \r [x_sdOCn y_sdOCo] f_sdOCj y_sdOCo x_sdOCn;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdOCi
              Data.Functor.Utils.$fApplicativeStateL
              sat_sdOCp
              sat_sdOCs
              t1_sdOCm
              s_sdOCl;

Data.Bitraversable.bimapAccumR
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdOCt f_sdOCu g_sdOCv s_sdOCw t1_sdOCx]
        let {
          sat_sdOCD [Occ=Once]
            :: d_adOdF -> Data.Functor.Utils.StateR a_adOdC e_adOdG
          [LclId] =
              [g_sdOCv] \r [x_sdOCB y_sdOCC] g_sdOCv y_sdOCC x_sdOCB; } in
        let {
          sat_sdOCA [Occ=Once]
            :: b_adOdD -> Data.Functor.Utils.StateR a_adOdC c_adOdE
          [LclId] =
              [f_sdOCu] \r [x_sdOCy y_sdOCz] f_sdOCu y_sdOCz x_sdOCy;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdOCt
              Data.Functor.Utils.$fApplicativeStateR
              sat_sdOCA
              sat_sdOCD
              t1_sdOCx
              s_sdOCw;

bimapDefault1_rdOxw
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> (c -> Data.Functor.Identity.Identity d)
     -> t a c
     -> Data.Functor.Identity.Identity (t b d)
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdOCE]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdOCE Data.Functor.Identity.$fApplicativeIdentity;

Data.Bitraversable.bimapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> b) -> (c -> d) -> t a c -> t b d
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B1] bimapDefault1_rdOxw eta_B1;

bifoldMapDefault1_rdOxx
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> (b -> Data.Functor.Const.Const m ())
     -> t a b
     -> Data.Functor.Const.Const m (t () ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdOCF $dMonoid_sdOCG]
        let {
          sat_sdOCH [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_adOct)
          [LclId] =
              [$dMonoid_sdOCG] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sdOCG;
        } in 
          Data.Bitraversable.bitraverse $dBitraversable_sdOCF sat_sdOCH;

Data.Bitraversable.bifoldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> m) -> (b -> m) -> t a b -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] bifoldMapDefault1_rdOxx eta_B2 eta_B1;

Data.Bitraversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bitraversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule4];

Data.Bitraversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bitraversable"#;

Data.Bitraversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule2];

Data.Bitraversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bitraversable.$trModule3
                                     Data.Bitraversable.$trModule1];

$krep_rdOxy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bitraversable.$tcBitraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdOxy];

Data.Bitraversable.$tcBitraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bitraversable"#;

Data.Bitraversable.$tcBitraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$tcBitraversable3];

Data.Bitraversable.$tcBitraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1654555613294690493##
                                    8030854156262073676##
                                    Data.Bitraversable.$trModule
                                    Data.Bitraversable.$tcBitraversable2
                                    0#
                                    Data.Bitraversable.$tcBitraversable1];

Data.Bitraversable.C:Bitraversable
  :: forall (t :: * -> * -> *).
     (Data.Bifunctor.Bifunctor t, Data.Bifoldable.Bifoldable t) =>
     (forall (f :: * -> *) a c b d.
      GHC.Base.Applicative f =>
      (a -> f c) -> (b -> f d) -> t a b -> f (t c d))
     -> Data.Bitraversable.Bitraversable t
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.C:Bitraversable [eta_B3 eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:09:04.748089763 UTC

Data.Bitraversable.$p1Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifunctor.Bifunctor t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdP7O]
        case v_sdP7O of {
          Data.Bitraversable.C:Bitraversable v_sdP7Q [Occ=Once]
                                             _ [Occ=Dead]
                                             _ [Occ=Dead] ->
              v_sdP7Q;
        };

Data.Bitraversable.$p2Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifoldable.Bifoldable t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdP7T]
        case v_sdP7T of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             v_sdP7W [Occ=Once]
                                             _ [Occ=Dead] ->
              v_sdP7W;
        };

Data.Bitraversable.bitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdP7Y]
        case v_sdP7Y of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             _ [Occ=Dead]
                                             v_sdP82 [Occ=Once] ->
              v_sdP82;
        };

Data.Bitraversable.$fBitraversable(,)_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP83 f1_sdP84 g_sdP85 ds_sdP86]
        let {
          sat_sdP8g [Occ=Once] :: f_adOkV d_adOkZ
          [LclId] =
              [g_sdP85 ds_sdP86] \u []
                  let {
                    sat_sdP8f [Occ=Once] :: b_adOkY
                    [LclId] =
                        [ds_sdP86] \u []
                            case ds_sdP86 of {
                              (,) _ [Occ=Dead] b1_sdP8e [Occ=Once] -> b1_sdP8e;
                            };
                  } in  g_sdP85 sat_sdP8f; } in
        let {
          sat_sdP8b [Occ=Once] :: f_adOkV c_adOkX
          [LclId] =
              [f1_sdP84 ds_sdP86] \u []
                  let {
                    sat_sdP8a [Occ=Once] :: a_adOkW
                    [LclId] =
                        [ds_sdP86] \u []
                            case ds_sdP86 of {
                              (,) a1_sdP88 [Occ=Once] _ [Occ=Dead] -> a1_sdP88;
                            };
                  } in  f1_sdP84 sat_sdP8a;
        } in 
          GHC.Base.liftA2
              $dApplicative_sdP83 GHC.Tuple.(,) sat_sdP8b sat_sdP8g;

Data.Bitraversable.$fBitraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,)
                                                       Data.Bifoldable.$fBifoldable(,)
                                                       Data.Bitraversable.$fBitraversable(,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
  :: forall x (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, a, b) -> f (x, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP8h f1_sdP8i g_sdP8j ds_sdP8k]
        let {
          sat_sdP8C [Occ=Once] :: f_adOks d_adOkw
          [LclId] =
              [g_sdP8j ds_sdP8k] \u []
                  let {
                    sat_sdP8B [Occ=Once] :: b_adOkv
                    [LclId] =
                        [ds_sdP8k] \u []
                            case ds_sdP8k of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdP8A [Occ=Once] -> b1_sdP8A;
                            };
                  } in  g_sdP8j sat_sdP8B; } in
        let {
          sat_sdP8w [Occ=Once] :: f_adOks c_adOku
          [LclId] =
              [f1_sdP8i ds_sdP8k] \u []
                  let {
                    sat_sdP8v [Occ=Once] :: a_adOkt
                    [LclId] =
                        [ds_sdP8k] \u []
                            case ds_sdP8k of {
                              (,,) _ [Occ=Dead] a1_sdP8t [Occ=Once] _ [Occ=Dead] -> a1_sdP8t;
                            };
                  } in  f1_sdP8i sat_sdP8v; } in
        let {
          sat_sdP8p [Occ=OnceL] :: x_adOkg
          [LclId] =
              [ds_sdP8k] \u []
                  case ds_sdP8k of {
                    (,,) x1_sdP8m [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x1_sdP8m;
                  }; } in
        let {
          sat_sdP8q [Occ=Once]
            :: c_adOku -> d_adOkw -> (x_adOkg, c_adOku, d_adOkw)
          [LclId] =
              [sat_sdP8p] \r [eta_B2 eta_B1] (,,) [sat_sdP8p eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP8h sat_sdP8q sat_sdP8w sat_sdP8C;

Data.Bitraversable.$fBitraversable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bitraversable.Bitraversable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,)
                                                       Data.Bifoldable.$fBifoldable(,,)
                                                       Data.Bitraversable.$fBitraversable(,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
  :: forall x y (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, a, b) -> f (x, y, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP8D f1_sdP8E g_sdP8F ds_sdP8G]
        let {
          sat_sdP97 [Occ=Once] :: f_adOjX d_adOk1
          [LclId] =
              [g_sdP8F ds_sdP8G] \u []
                  let {
                    sat_sdP96 [Occ=Once] :: b_adOk0
                    [LclId] =
                        [ds_sdP8G] \u []
                            case ds_sdP8G of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdP95 [Occ=Once] ->
                                  b1_sdP95;
                            };
                  } in  g_sdP8F sat_sdP96; } in
        let {
          sat_sdP90 [Occ=Once] :: f_adOjX c_adOjZ
          [LclId] =
              [f1_sdP8E ds_sdP8G] \u []
                  let {
                    sat_sdP8Z [Occ=Once] :: a_adOjY
                    [LclId] =
                        [ds_sdP8G] \u []
                            case ds_sdP8G of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdP8X [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdP8X;
                            };
                  } in  f1_sdP8E sat_sdP8Z; } in
        let {
          sat_sdP8S [Occ=OnceL] :: y_adOjL
          [LclId] =
              [ds_sdP8G] \u []
                  case ds_sdP8G of {
                    (,,,) _ [Occ=Dead] y1_sdP8P [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        y1_sdP8P;
                  }; } in
        let {
          sat_sdP8M [Occ=OnceL] :: x_adOjK
          [LclId] =
              [ds_sdP8G] \u []
                  case ds_sdP8G of {
                    (,,,) x1_sdP8I [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x1_sdP8I;
                  }; } in
        let {
          sat_sdP8T [Occ=Once]
            :: c_adOjZ -> d_adOk1 -> (x_adOjK, y_adOjL, c_adOjZ, d_adOk1)
          [LclId] =
              [sat_sdP8M sat_sdP8S] \r [eta_B2 eta_B1]
                  (,,,) [sat_sdP8M sat_sdP8S eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP8D sat_sdP8T sat_sdP90 sat_sdP97;

Data.Bitraversable.$fBitraversable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bitraversable.Bitraversable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
  :: forall x y z (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, z, a, b) -> f (x, y, z, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP98 f1_sdP99 g_sdP9a ds_sdP9b]
        let {
          sat_sdP9N [Occ=Once] :: f_adOjq d_adOju
          [LclId] =
              [g_sdP9a ds_sdP9b] \u []
                  let {
                    sat_sdP9M [Occ=Once] :: b_adOjt
                    [LclId] =
                        [ds_sdP9b] \u []
                            case ds_sdP9b of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdP9L [Occ=Once] ->
                                  b1_sdP9L;
                            };
                  } in  g_sdP9a sat_sdP9M; } in
        let {
          sat_sdP9F [Occ=Once] :: f_adOjq c_adOjs
          [LclId] =
              [f1_sdP99 ds_sdP9b] \u []
                  let {
                    sat_sdP9E [Occ=Once] :: a_adOjr
                    [LclId] =
                        [ds_sdP9b] \u []
                            case ds_sdP9b of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdP9C [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdP9C;
                            };
                  } in  f1_sdP99 sat_sdP9E; } in
        let {
          sat_sdP9w [Occ=OnceL] :: z_adOje
          [LclId] =
              [ds_sdP9b] \u []
                  case ds_sdP9b of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           z1_sdP9t [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        z1_sdP9t;
                  }; } in
        let {
          sat_sdP9p [Occ=OnceL] :: y_adOjd
          [LclId] =
              [ds_sdP9b] \u []
                  case ds_sdP9b of {
                    (,,,,) _ [Occ=Dead]
                           y1_sdP9l [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        y1_sdP9l;
                  }; } in
        let {
          sat_sdP9i [Occ=OnceL] :: x_adOjc
          [LclId] =
              [ds_sdP9b] \u []
                  case ds_sdP9b of {
                    (,,,,) x1_sdP9d [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x1_sdP9d;
                  }; } in
        let {
          sat_sdP9x [Occ=Once]
            :: c_adOjs
               -> d_adOju -> (x_adOjc, y_adOjd, z_adOje, c_adOjs, d_adOju)
          [LclId] =
              [sat_sdP9i sat_sdP9p sat_sdP9w] \r [eta_B2 eta_B1]
                  (,,,,) [sat_sdP9i sat_sdP9p sat_sdP9w eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP98 sat_sdP9x sat_sdP9F sat_sdP9N;

Data.Bitraversable.$fBitraversable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bitraversable.Bitraversable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
  :: forall x y z w (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, a, b) -> f (x, y, z, w, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP9O f1_sdP9P g_sdP9Q ds_sdP9R]
        let {
          sat_sdPaG [Occ=Once] :: f_adOiR d_adOiV
          [LclId] =
              [g_sdP9Q ds_sdP9R] \u []
                  let {
                    sat_sdPaF [Occ=Once] :: b_adOiU
                    [LclId] =
                        [ds_sdP9R] \u []
                            case ds_sdP9R of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdPaE [Occ=Once] ->
                                  b1_sdPaE;
                            };
                  } in  g_sdP9Q sat_sdPaF; } in
        let {
          sat_sdPax [Occ=Once] :: f_adOiR c_adOiT
          [LclId] =
              [f1_sdP9P ds_sdP9R] \u []
                  let {
                    sat_sdPaw [Occ=Once] :: a_adOiS
                    [LclId] =
                        [ds_sdP9R] \u []
                            case ds_sdP9R of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdPau [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdPau;
                            };
                  } in  f1_sdP9P sat_sdPaw; } in
        let {
          sat_sdPan [Occ=OnceL] :: w_adOiF
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            w1_sdPak [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        w1_sdPak;
                  }; } in
        let {
          sat_sdPaf [Occ=OnceL] :: z_adOiE
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            z1_sdPab [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        z1_sdPab;
                  }; } in
        let {
          sat_sdPa7 [Occ=OnceL] :: y_adOiD
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) _ [Occ=Dead]
                            y1_sdPa2 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        y1_sdPa2;
                  }; } in
        let {
          sat_sdP9Z [Occ=OnceL] :: x_adOiC
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) x1_sdP9T [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x1_sdP9T;
                  }; } in
        let {
          sat_sdPao [Occ=Once]
            :: c_adOiT
               -> d_adOiV
               -> (x_adOiC, y_adOiD, z_adOiE, w_adOiF, c_adOiT, d_adOiV)
          [LclId] =
              [sat_sdP9Z sat_sdPa7 sat_sdPaf sat_sdPan] \r [eta_B2 eta_B1]
                  (,,,,,) [sat_sdP9Z sat_sdPa7 sat_sdPaf sat_sdPan eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP9O sat_sdPao sat_sdPax sat_sdPaG;

Data.Bitraversable.$fBitraversable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w.
     Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
  :: forall x y z w v (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, v, a, b) -> f (x, y, z, w, v, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPaH f1_sdPaI g_sdPaJ ds_sdPaK]
        let {
          sat_sdPbO [Occ=Once] :: f_adOig d_adOik
          [LclId] =
              [g_sdPaJ ds_sdPaK] \u []
                  let {
                    sat_sdPbN [Occ=Once] :: b_adOij
                    [LclId] =
                        [ds_sdPaK] \u []
                            case ds_sdPaK of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdPbM [Occ=Once] ->
                                  b1_sdPbM;
                            };
                  } in  g_sdPaJ sat_sdPbN; } in
        let {
          sat_sdPbE [Occ=Once] :: f_adOig c_adOii
          [LclId] =
              [f1_sdPaI ds_sdPaK] \u []
                  let {
                    sat_sdPbD [Occ=Once] :: a_adOih
                    [LclId] =
                        [ds_sdPaK] \u []
                            case ds_sdPaK of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdPbB [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdPbB;
                            };
                  } in  f1_sdPaI sat_sdPbD; } in
        let {
          sat_sdPbt [Occ=OnceL] :: v_adOi4
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             v1_sdPbq [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        v1_sdPbq;
                  }; } in
        let {
          sat_sdPbk [Occ=OnceL] :: w_adOi3
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             w1_sdPbg [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        w1_sdPbg;
                  }; } in
        let {
          sat_sdPbb [Occ=OnceL] :: z_adOi2
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             z1_sdPb6 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        z1_sdPb6;
                  }; } in
        let {
          sat_sdPb2 [Occ=OnceL] :: y_adOi1
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             y1_sdPaW [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        y1_sdPaW;
                  }; } in
        let {
          sat_sdPaT [Occ=OnceL] :: x_adOi0
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) x1_sdPaM [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x1_sdPaM;
                  }; } in
        let {
          sat_sdPbu [Occ=Once]
            :: c_adOii
               -> d_adOik
               -> (x_adOi0, y_adOi1, z_adOi2, w_adOi3, v_adOi4, c_adOii, d_adOik)
          [LclId] =
              [sat_sdPaT sat_sdPb2 sat_sdPbb sat_sdPbk sat_sdPbt] \r [eta_B2
                                                                      eta_B1]
                  (,,,,,,) [sat_sdPaT
                            sat_sdPb2
                            sat_sdPbb
                            sat_sdPbk
                            sat_sdPbt
                            eta_B2
                            eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdPaH sat_sdPbu sat_sdPbE sat_sdPbO;

Data.Bitraversable.$fBitraversable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversableEither_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Either.Either a b
     -> f (Data.Either.Either c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPbP eta_sdPbQ eta1_sdPbR eta2_sdPbS]
        case eta2_sdPbS of {
          Data.Either.Left a1_sdPbU [Occ=Once] ->
              let {
                sat_sdPbW [Occ=Once] :: f_adOhE c_adOhG
                [LclId] =
                    [eta_sdPbQ a1_sdPbU] \u [] eta_sdPbQ a1_sdPbU;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdPbP of sat_sdPbV {
                  __DEFAULT -> GHC.Base.fmap sat_sdPbV Data.Either.Left sat_sdPbW;
                };
          Data.Either.Right b1_sdPbX [Occ=Once] ->
              let {
                sat_sdPbZ [Occ=Once] :: f_adOhE d_adOhI
                [LclId] =
                    [eta1_sdPbR b1_sdPbX] \u [] eta1_sdPbR b1_sdPbX;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdPbP of sat_sdPbY {
                  __DEFAULT -> GHC.Base.fmap sat_sdPbY Data.Either.Right sat_sdPbZ;
                };
        };

Data.Bitraversable.$fBitraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorEither
                                                       Data.Bifoldable.$fBifoldableEither
                                                       Data.Bitraversable.$fBitraversableEither_$cbitraverse];

Data.Bitraversable.$fBitraversableConst1 :: forall c. c -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdPc0] v_sdPc0;

Data.Bitraversable.$fBitraversableConst_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Functor.Const.Const a b
     -> f (Data.Functor.Const.Const c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPc1 eta_sdPc2 eta1_sdPc3 eta2_sdPc4]
        let {
          sat_sdPc6 [Occ=Once] :: f_adOhc c_adOhe
          [LclId] =
              [eta_sdPc2 eta2_sdPc4] \u [] eta_sdPc2 eta2_sdPc4;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdPc1 of sat_sdPc5 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdPc5 Data.Bitraversable.$fBitraversableConst1 sat_sdPc6;
          };

Data.Bitraversable.$fBitraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorConst
                                                       Data.Bifoldable.$fBifoldableConst
                                                       Data.Bitraversable.$fBitraversableConst_$cbitraverse];

Data.Bitraversable.$fBitraversableK1_$cbitraverse
  :: forall i (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> GHC.Generics.K1 i a b -> f (GHC.Generics.K1 i c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPc7 eta_sdPc8 eta1_sdPc9 eta2_sdPca]
        let {
          sat_sdPcc [Occ=Once] :: f_adOgJ c_adOgL
          [LclId] =
              [eta_sdPc8 eta2_sdPca] \u [] eta_sdPc8 eta2_sdPca;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdPc7 of sat_sdPcb {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdPcb Data.Bitraversable.$fBitraversableConst1 sat_sdPcc;
          };

Data.Bitraversable.$fBitraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorK1
                                                       Data.Bifoldable.$fBifoldableK1
                                                       Data.Bitraversable.$fBitraversableK1_$cbitraverse];

Data.Bitraversable.bimapM
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcd $dApplicative_sdPce]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcd $dApplicative_sdPce;

Data.Bitraversable.bisequence
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcf $dApplicative_sdPcg]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcf $dApplicative_sdPcg GHC.Base.id GHC.Base.id;

Data.Bitraversable.bisequenceA
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bitraversable.bisequence eta_B2 eta_B1;

Data.Bitraversable.$dmbitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(C(U))),A,A),A,1*C1(C1(C1(C(U)))))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPch eta_sdPci eta1_sdPcj eta2_sdPck]
        let {
          f1_sdPcl [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
               -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [$dBitraversable_sdPch eta_sdPci] \u []
                  Data.Bitraversable.bitraverse
                      $dBitraversable_sdPch eta_sdPci GHC.Base.id GHC.Base.id; } in
        let {
          g_sdPcm [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x a_adOga b_adOgc
               -> t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
          [LclId] =
              [$dBitraversable_sdPch eta1_sdPcj eta2_sdPck] \u []
                  case
                      Data.Bitraversable.$p1Bitraversable $dBitraversable_sdPch
                  of
                  sat_sdPcn
                  { __DEFAULT ->
                        Data.Bifunctor.bimap sat_sdPcn eta1_sdPcj eta2_sdPck;
                  }; } in
        let {
          sat_sdPcq [Occ=OnceT[0]]
            :: t_adO2x a_adOga b_adOgc -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [f1_sdPcl g_sdPcm] \r [x_sdPco]
                  let {
                    sat_sdPcp [Occ=Once] :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
                    [LclId] =
                        [g_sdPcm x_sdPco] \u [] g_sdPcm x_sdPco;
                  } in  f1_sdPcl sat_sdPcp;
        } in  sat_sdPcq;

Data.Bitraversable.bifor
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcr
           $dApplicative_sdPcs
           t1_sdPct
           f1_sdPcu
           g_sdPcv]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcr
            $dApplicative_sdPcs
            f1_sdPcu
            g_sdPcv
            t1_sdPct;

Data.Bitraversable.biforM
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.bifor eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bitraversable.bimapAccumL
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcw f_sdPcx g_sdPcy s_sdPcz t1_sdPcA]
        let {
          sat_sdPcG [Occ=Once]
            :: d_adOee -> Data.Functor.Utils.StateL a_adOeb e_adOef
          [LclId] =
              [g_sdPcy] \r [x_sdPcE y_sdPcF] g_sdPcy y_sdPcF x_sdPcE; } in
        let {
          sat_sdPcD [Occ=Once]
            :: b_adOec -> Data.Functor.Utils.StateL a_adOeb c_adOed
          [LclId] =
              [f_sdPcx] \r [x_sdPcB y_sdPcC] f_sdPcx y_sdPcC x_sdPcB;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdPcw
              Data.Functor.Utils.$fApplicativeStateL
              sat_sdPcD
              sat_sdPcG
              t1_sdPcA
              s_sdPcz;

Data.Bitraversable.bimapAccumR
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcH f_sdPcI g_sdPcJ s_sdPcK t1_sdPcL]
        let {
          sat_sdPcR [Occ=Once]
            :: d_adOdF -> Data.Functor.Utils.StateR a_adOdC e_adOdG
          [LclId] =
              [g_sdPcJ] \r [x_sdPcP y_sdPcQ] g_sdPcJ y_sdPcQ x_sdPcP; } in
        let {
          sat_sdPcO [Occ=Once]
            :: b_adOdD -> Data.Functor.Utils.StateR a_adOdC c_adOdE
          [LclId] =
              [f_sdPcI] \r [x_sdPcM y_sdPcN] f_sdPcI y_sdPcN x_sdPcM;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdPcH
              Data.Functor.Utils.$fApplicativeStateR
              sat_sdPcO
              sat_sdPcR
              t1_sdPcL
              s_sdPcK;

bimapDefault1_rdOxw
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> (c -> Data.Functor.Identity.Identity d)
     -> t a c
     -> Data.Functor.Identity.Identity (t b d)
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdPcS]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcS Data.Functor.Identity.$fApplicativeIdentity;

Data.Bitraversable.bimapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> b) -> (c -> d) -> t a c -> t b d
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B1] bimapDefault1_rdOxw eta_B1;

bifoldMapDefault1_rdOxx
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> (b -> Data.Functor.Const.Const m ())
     -> t a b
     -> Data.Functor.Const.Const m (t () ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdPcT $dMonoid_sdPcU]
        let {
          sat_sdPcV [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_adOct)
          [LclId] =
              [$dMonoid_sdPcU] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sdPcU;
        } in 
          Data.Bitraversable.bitraverse $dBitraversable_sdPcT sat_sdPcV;

Data.Bitraversable.bifoldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> m) -> (b -> m) -> t a b -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] bifoldMapDefault1_rdOxx eta_B2 eta_B1;

Data.Bitraversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bitraversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule4];

Data.Bitraversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bitraversable"#;

Data.Bitraversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule2];

Data.Bitraversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bitraversable.$trModule3
                                     Data.Bitraversable.$trModule1];

$krep_rdOxy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bitraversable.$tcBitraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdOxy];

Data.Bitraversable.$tcBitraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bitraversable"#;

Data.Bitraversable.$tcBitraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$tcBitraversable3];

Data.Bitraversable.$tcBitraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1654555613294690493##
                                    8030854156262073676##
                                    Data.Bitraversable.$trModule
                                    Data.Bitraversable.$tcBitraversable2
                                    0#
                                    Data.Bitraversable.$tcBitraversable1];

Data.Bitraversable.C:Bitraversable
  :: forall (t :: * -> * -> *).
     (Data.Bifunctor.Bifunctor t, Data.Bifoldable.Bifoldable t) =>
     (forall (f :: * -> *) a c b d.
      GHC.Base.Applicative f =>
      (a -> f c) -> (b -> f d) -> t a b -> f (t c d))
     -> Data.Bitraversable.Bitraversable t
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.C:Bitraversable [eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:09:04.77176082 UTC

Data.Bitraversable.$p1Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifunctor.Bifunctor t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdP7O]
        case v_sdP7O of {
          Data.Bitraversable.C:Bitraversable v_sdP7Q [Occ=Once]
                                             _ [Occ=Dead]
                                             _ [Occ=Dead] ->
              v_sdP7Q;
        };

Data.Bitraversable.$p2Bitraversable
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     Data.Bifoldable.Bifoldable t
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdP7T]
        case v_sdP7T of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             v_sdP7W [Occ=Once]
                                             _ [Occ=Dead] ->
              v_sdP7W;
        };

Data.Bitraversable.bitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdP7Y]
        case v_sdP7Y of {
          Data.Bitraversable.C:Bitraversable _ [Occ=Dead]
                                             _ [Occ=Dead]
                                             v_sdP82 [Occ=Once] ->
              v_sdP82;
        };

Data.Bitraversable.$fBitraversable(,)_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP83 f1_sdP84 g_sdP85 ds_sdP86]
        let {
          sat_sdP8g [Occ=Once] :: f_adOkV d_adOkZ
          [LclId] =
              [g_sdP85 ds_sdP86] \u []
                  let {
                    sat_sdP8f [Occ=Once] :: b_adOkY
                    [LclId] =
                        [ds_sdP86] \u []
                            case ds_sdP86 of {
                              (,) _ [Occ=Dead] b1_sdP8e [Occ=Once] -> b1_sdP8e;
                            };
                  } in  g_sdP85 sat_sdP8f; } in
        let {
          sat_sdP8b [Occ=Once] :: f_adOkV c_adOkX
          [LclId] =
              [f1_sdP84 ds_sdP86] \u []
                  let {
                    sat_sdP8a [Occ=Once] :: a_adOkW
                    [LclId] =
                        [ds_sdP86] \u []
                            case ds_sdP86 of {
                              (,) a1_sdP88 [Occ=Once] _ [Occ=Dead] -> a1_sdP88;
                            };
                  } in  f1_sdP84 sat_sdP8a;
        } in 
          GHC.Base.liftA2
              $dApplicative_sdP83 GHC.Tuple.(,) sat_sdP8b sat_sdP8g;

Data.Bitraversable.$fBitraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,)
                                                       Data.Bifoldable.$fBifoldable(,)
                                                       Data.Bitraversable.$fBitraversable(,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
  :: forall x (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, a, b) -> f (x, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP8h f1_sdP8i g_sdP8j ds_sdP8k]
        let {
          sat_sdP8C [Occ=Once] :: f_adOks d_adOkw
          [LclId] =
              [g_sdP8j ds_sdP8k] \u []
                  let {
                    sat_sdP8B [Occ=Once] :: b_adOkv
                    [LclId] =
                        [ds_sdP8k] \u []
                            case ds_sdP8k of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdP8A [Occ=Once] -> b1_sdP8A;
                            };
                  } in  g_sdP8j sat_sdP8B; } in
        let {
          sat_sdP8w [Occ=Once] :: f_adOks c_adOku
          [LclId] =
              [f1_sdP8i ds_sdP8k] \u []
                  let {
                    sat_sdP8v [Occ=Once] :: a_adOkt
                    [LclId] =
                        [ds_sdP8k] \u []
                            case ds_sdP8k of {
                              (,,) _ [Occ=Dead] a1_sdP8t [Occ=Once] _ [Occ=Dead] -> a1_sdP8t;
                            };
                  } in  f1_sdP8i sat_sdP8v; } in
        let {
          sat_sdP8p [Occ=OnceL] :: x_adOkg
          [LclId] =
              [ds_sdP8k] \u []
                  case ds_sdP8k of {
                    (,,) x1_sdP8m [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x1_sdP8m;
                  }; } in
        let {
          sat_sdP8q [Occ=Once]
            :: c_adOku -> d_adOkw -> (x_adOkg, c_adOku, d_adOkw)
          [LclId] =
              [sat_sdP8p] \r [eta_B2 eta_B1] (,,) [sat_sdP8p eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP8h sat_sdP8q sat_sdP8w sat_sdP8C;

Data.Bitraversable.$fBitraversable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bitraversable.Bitraversable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,)
                                                       Data.Bifoldable.$fBifoldable(,,)
                                                       Data.Bitraversable.$fBitraversable(,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
  :: forall x y (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, a, b) -> f (x, y, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP8D f1_sdP8E g_sdP8F ds_sdP8G]
        let {
          sat_sdP97 [Occ=Once] :: f_adOjX d_adOk1
          [LclId] =
              [g_sdP8F ds_sdP8G] \u []
                  let {
                    sat_sdP96 [Occ=Once] :: b_adOk0
                    [LclId] =
                        [ds_sdP8G] \u []
                            case ds_sdP8G of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdP95 [Occ=Once] ->
                                  b1_sdP95;
                            };
                  } in  g_sdP8F sat_sdP96; } in
        let {
          sat_sdP90 [Occ=Once] :: f_adOjX c_adOjZ
          [LclId] =
              [f1_sdP8E ds_sdP8G] \u []
                  let {
                    sat_sdP8Z [Occ=Once] :: a_adOjY
                    [LclId] =
                        [ds_sdP8G] \u []
                            case ds_sdP8G of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdP8X [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdP8X;
                            };
                  } in  f1_sdP8E sat_sdP8Z; } in
        let {
          sat_sdP8S [Occ=OnceL] :: y_adOjL
          [LclId] =
              [ds_sdP8G] \u []
                  case ds_sdP8G of {
                    (,,,) _ [Occ=Dead] y1_sdP8P [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        y1_sdP8P;
                  }; } in
        let {
          sat_sdP8M [Occ=OnceL] :: x_adOjK
          [LclId] =
              [ds_sdP8G] \u []
                  case ds_sdP8G of {
                    (,,,) x1_sdP8I [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x1_sdP8I;
                  }; } in
        let {
          sat_sdP8T [Occ=Once]
            :: c_adOjZ -> d_adOk1 -> (x_adOjK, y_adOjL, c_adOjZ, d_adOk1)
          [LclId] =
              [sat_sdP8M sat_sdP8S] \r [eta_B2 eta_B1]
                  (,,,) [sat_sdP8M sat_sdP8S eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP8D sat_sdP8T sat_sdP90 sat_sdP97;

Data.Bitraversable.$fBitraversable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bitraversable.Bitraversable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
  :: forall x y z (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, z, a, b) -> f (x, y, z, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP98 f1_sdP99 g_sdP9a ds_sdP9b]
        let {
          sat_sdP9N [Occ=Once] :: f_adOjq d_adOju
          [LclId] =
              [g_sdP9a ds_sdP9b] \u []
                  let {
                    sat_sdP9M [Occ=Once] :: b_adOjt
                    [LclId] =
                        [ds_sdP9b] \u []
                            case ds_sdP9b of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdP9L [Occ=Once] ->
                                  b1_sdP9L;
                            };
                  } in  g_sdP9a sat_sdP9M; } in
        let {
          sat_sdP9F [Occ=Once] :: f_adOjq c_adOjs
          [LclId] =
              [f1_sdP99 ds_sdP9b] \u []
                  let {
                    sat_sdP9E [Occ=Once] :: a_adOjr
                    [LclId] =
                        [ds_sdP9b] \u []
                            case ds_sdP9b of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdP9C [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdP9C;
                            };
                  } in  f1_sdP99 sat_sdP9E; } in
        let {
          sat_sdP9w [Occ=OnceL] :: z_adOje
          [LclId] =
              [ds_sdP9b] \u []
                  case ds_sdP9b of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           z1_sdP9t [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        z1_sdP9t;
                  }; } in
        let {
          sat_sdP9p [Occ=OnceL] :: y_adOjd
          [LclId] =
              [ds_sdP9b] \u []
                  case ds_sdP9b of {
                    (,,,,) _ [Occ=Dead]
                           y1_sdP9l [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        y1_sdP9l;
                  }; } in
        let {
          sat_sdP9i [Occ=OnceL] :: x_adOjc
          [LclId] =
              [ds_sdP9b] \u []
                  case ds_sdP9b of {
                    (,,,,) x1_sdP9d [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x1_sdP9d;
                  }; } in
        let {
          sat_sdP9x [Occ=Once]
            :: c_adOjs
               -> d_adOju -> (x_adOjc, y_adOjd, z_adOje, c_adOjs, d_adOju)
          [LclId] =
              [sat_sdP9i sat_sdP9p sat_sdP9w] \r [eta_B2 eta_B1]
                  (,,,,) [sat_sdP9i sat_sdP9p sat_sdP9w eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP98 sat_sdP9x sat_sdP9F sat_sdP9N;

Data.Bitraversable.$fBitraversable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bitraversable.Bitraversable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
  :: forall x y z w (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, a, b) -> f (x, y, z, w, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdP9O f1_sdP9P g_sdP9Q ds_sdP9R]
        let {
          sat_sdPaG [Occ=Once] :: f_adOiR d_adOiV
          [LclId] =
              [g_sdP9Q ds_sdP9R] \u []
                  let {
                    sat_sdPaF [Occ=Once] :: b_adOiU
                    [LclId] =
                        [ds_sdP9R] \u []
                            case ds_sdP9R of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdPaE [Occ=Once] ->
                                  b1_sdPaE;
                            };
                  } in  g_sdP9Q sat_sdPaF; } in
        let {
          sat_sdPax [Occ=Once] :: f_adOiR c_adOiT
          [LclId] =
              [f1_sdP9P ds_sdP9R] \u []
                  let {
                    sat_sdPaw [Occ=Once] :: a_adOiS
                    [LclId] =
                        [ds_sdP9R] \u []
                            case ds_sdP9R of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdPau [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdPau;
                            };
                  } in  f1_sdP9P sat_sdPaw; } in
        let {
          sat_sdPan [Occ=OnceL] :: w_adOiF
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            w1_sdPak [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        w1_sdPak;
                  }; } in
        let {
          sat_sdPaf [Occ=OnceL] :: z_adOiE
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            z1_sdPab [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        z1_sdPab;
                  }; } in
        let {
          sat_sdPa7 [Occ=OnceL] :: y_adOiD
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) _ [Occ=Dead]
                            y1_sdPa2 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        y1_sdPa2;
                  }; } in
        let {
          sat_sdP9Z [Occ=OnceL] :: x_adOiC
          [LclId] =
              [ds_sdP9R] \u []
                  case ds_sdP9R of {
                    (,,,,,) x1_sdP9T [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x1_sdP9T;
                  }; } in
        let {
          sat_sdPao [Occ=Once]
            :: c_adOiT
               -> d_adOiV
               -> (x_adOiC, y_adOiD, z_adOiE, w_adOiF, c_adOiT, d_adOiV)
          [LclId] =
              [sat_sdP9Z sat_sdPa7 sat_sdPaf sat_sdPan] \r [eta_B2 eta_B1]
                  (,,,,,) [sat_sdP9Z sat_sdPa7 sat_sdPaf sat_sdPan eta_B2 eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdP9O sat_sdPao sat_sdPax sat_sdPaG;

Data.Bitraversable.$fBitraversable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w.
     Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
  :: forall x y z w v (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, v, a, b) -> f (x, y, z, w, v, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPaH f1_sdPaI g_sdPaJ ds_sdPaK]
        let {
          sat_sdPbO [Occ=Once] :: f_adOig d_adOik
          [LclId] =
              [g_sdPaJ ds_sdPaK] \u []
                  let {
                    sat_sdPbN [Occ=Once] :: b_adOij
                    [LclId] =
                        [ds_sdPaK] \u []
                            case ds_sdPaK of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdPbM [Occ=Once] ->
                                  b1_sdPbM;
                            };
                  } in  g_sdPaJ sat_sdPbN; } in
        let {
          sat_sdPbE [Occ=Once] :: f_adOig c_adOii
          [LclId] =
              [f1_sdPaI ds_sdPaK] \u []
                  let {
                    sat_sdPbD [Occ=Once] :: a_adOih
                    [LclId] =
                        [ds_sdPaK] \u []
                            case ds_sdPaK of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdPbB [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdPbB;
                            };
                  } in  f1_sdPaI sat_sdPbD; } in
        let {
          sat_sdPbt [Occ=OnceL] :: v_adOi4
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             v1_sdPbq [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        v1_sdPbq;
                  }; } in
        let {
          sat_sdPbk [Occ=OnceL] :: w_adOi3
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             w1_sdPbg [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        w1_sdPbg;
                  }; } in
        let {
          sat_sdPbb [Occ=OnceL] :: z_adOi2
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             z1_sdPb6 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        z1_sdPb6;
                  }; } in
        let {
          sat_sdPb2 [Occ=OnceL] :: y_adOi1
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) _ [Occ=Dead]
                             y1_sdPaW [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        y1_sdPaW;
                  }; } in
        let {
          sat_sdPaT [Occ=OnceL] :: x_adOi0
          [LclId] =
              [ds_sdPaK] \u []
                  case ds_sdPaK of {
                    (,,,,,,) x1_sdPaM [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x1_sdPaM;
                  }; } in
        let {
          sat_sdPbu [Occ=Once]
            :: c_adOii
               -> d_adOik
               -> (x_adOi0, y_adOi1, z_adOi2, w_adOi3, v_adOi4, c_adOii, d_adOik)
          [LclId] =
              [sat_sdPaT sat_sdPb2 sat_sdPbb sat_sdPbk sat_sdPbt] \r [eta_B2
                                                                      eta_B1]
                  (,,,,,,) [sat_sdPaT
                            sat_sdPb2
                            sat_sdPbb
                            sat_sdPbk
                            sat_sdPbt
                            eta_B2
                            eta_B1];
        } in 
          GHC.Base.liftA2 $dApplicative_sdPaH sat_sdPbu sat_sdPbE sat_sdPbO;

Data.Bitraversable.$fBitraversable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctor(,,,,,,)
                                                       Data.Bifoldable.$fBifoldable(,,,,,,)
                                                       Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse];

Data.Bitraversable.$fBitraversableEither_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Either.Either a b
     -> f (Data.Either.Either c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPbP eta_sdPbQ eta1_sdPbR eta2_sdPbS]
        case eta2_sdPbS of {
          Data.Either.Left a1_sdPbU [Occ=Once] ->
              let {
                sat_sdPbW [Occ=Once] :: f_adOhE c_adOhG
                [LclId] =
                    [eta_sdPbQ a1_sdPbU] \u [] eta_sdPbQ a1_sdPbU;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdPbP of sat_sdPbV {
                  __DEFAULT -> GHC.Base.fmap sat_sdPbV Data.Either.Left sat_sdPbW;
                };
          Data.Either.Right b1_sdPbX [Occ=Once] ->
              let {
                sat_sdPbZ [Occ=Once] :: f_adOhE d_adOhI
                [LclId] =
                    [eta1_sdPbR b1_sdPbX] \u [] eta1_sdPbR b1_sdPbX;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sdPbP of sat_sdPbY {
                  __DEFAULT -> GHC.Base.fmap sat_sdPbY Data.Either.Right sat_sdPbZ;
                };
        };

Data.Bitraversable.$fBitraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorEither
                                                       Data.Bifoldable.$fBifoldableEither
                                                       Data.Bitraversable.$fBitraversableEither_$cbitraverse];

Data.Bitraversable.$fBitraversableConst1 :: forall c. c -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdPc0] v_sdPc0;

Data.Bitraversable.$fBitraversableConst_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Functor.Const.Const a b
     -> f (Data.Functor.Const.Const c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPc1 eta_sdPc2 eta1_sdPc3 eta2_sdPc4]
        let {
          sat_sdPc6 [Occ=Once] :: f_adOhc c_adOhe
          [LclId] =
              [eta_sdPc2 eta2_sdPc4] \u [] eta_sdPc2 eta2_sdPc4;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdPc1 of sat_sdPc5 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdPc5 Data.Bitraversable.$fBitraversableConst1 sat_sdPc6;
          };

Data.Bitraversable.$fBitraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorConst
                                                       Data.Bifoldable.$fBifoldableConst
                                                       Data.Bitraversable.$fBitraversableConst_$cbitraverse];

Data.Bitraversable.$fBitraversableK1_$cbitraverse
  :: forall i (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d) -> GHC.Generics.K1 i a b -> f (GHC.Generics.K1 i c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sdPc7 eta_sdPc8 eta1_sdPc9 eta2_sdPca]
        let {
          sat_sdPcc [Occ=Once] :: f_adOgJ c_adOgL
          [LclId] =
              [eta_sdPc8 eta2_sdPca] \u [] eta_sdPc8 eta2_sdPca;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sdPc7 of sat_sdPcb {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sdPcb Data.Bitraversable.$fBitraversableConst1 sat_sdPcc;
          };

Data.Bitraversable.$fBitraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Bifunctor.$fBifunctorK1
                                                       Data.Bifoldable.$fBifoldableK1
                                                       Data.Bitraversable.$fBitraversableK1_$cbitraverse];

Data.Bitraversable.bimapM
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcd $dApplicative_sdPce]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcd $dApplicative_sdPce;

Data.Bitraversable.bisequence
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcf $dApplicative_sdPcg]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcf $dApplicative_sdPcg GHC.Base.id GHC.Base.id;

Data.Bitraversable.bisequenceA
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bitraversable.bisequence eta_B2 eta_B1;

Data.Bitraversable.$dmbitraverse
  :: forall (t :: * -> * -> *).
     Data.Bitraversable.Bitraversable t =>
     forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(C(U))),A,A),A,1*C1(C1(C1(C(U)))))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPch eta_sdPci eta1_sdPcj eta2_sdPck]
        let {
          f1_sdPcl [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
               -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [$dBitraversable_sdPch eta_sdPci] \u []
                  Data.Bitraversable.bitraverse
                      $dBitraversable_sdPch eta_sdPci GHC.Base.id GHC.Base.id; } in
        let {
          g_sdPcm [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adO2x a_adOga b_adOgc
               -> t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
          [LclId] =
              [$dBitraversable_sdPch eta1_sdPcj eta2_sdPck] \u []
                  case
                      Data.Bitraversable.$p1Bitraversable $dBitraversable_sdPch
                  of
                  sat_sdPcn
                  { __DEFAULT ->
                        Data.Bifunctor.bimap sat_sdPcn eta1_sdPcj eta2_sdPck;
                  }; } in
        let {
          sat_sdPcq [Occ=OnceT[0]]
            :: t_adO2x a_adOga b_adOgc -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
          [LclId] =
              [f1_sdPcl g_sdPcm] \r [x_sdPco]
                  let {
                    sat_sdPcp [Occ=Once] :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
                    [LclId] =
                        [g_sdPcm x_sdPco] \u [] g_sdPcm x_sdPco;
                  } in  f1_sdPcl sat_sdPcp;
        } in  sat_sdPcq;

Data.Bitraversable.bifor
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcr
           $dApplicative_sdPcs
           t1_sdPct
           f1_sdPcu
           g_sdPcv]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcr
            $dApplicative_sdPcs
            f1_sdPcu
            g_sdPcv
            t1_sdPct;

Data.Bitraversable.biforM
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.bifor eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bitraversable.bimapAccumL
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcw f_sdPcx g_sdPcy s_sdPcz t1_sdPcA]
        let {
          sat_sdPcG [Occ=Once]
            :: d_adOee -> Data.Functor.Utils.StateL a_adOeb e_adOef
          [LclId] =
              [g_sdPcy] \r [x_sdPcE y_sdPcF] g_sdPcy y_sdPcF x_sdPcE; } in
        let {
          sat_sdPcD [Occ=Once]
            :: b_adOec -> Data.Functor.Utils.StateL a_adOeb c_adOed
          [LclId] =
              [f_sdPcx] \r [x_sdPcB y_sdPcC] f_sdPcx y_sdPcC x_sdPcB;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdPcw
              Data.Functor.Utils.$fApplicativeStateL
              sat_sdPcD
              sat_sdPcG
              t1_sdPcA
              s_sdPcz;

Data.Bitraversable.bimapAccumR
  :: forall (t :: * -> * -> *) a b c d e.
     Data.Bitraversable.Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBitraversable_sdPcH f_sdPcI g_sdPcJ s_sdPcK t1_sdPcL]
        let {
          sat_sdPcR [Occ=Once]
            :: d_adOdF -> Data.Functor.Utils.StateR a_adOdC e_adOdG
          [LclId] =
              [g_sdPcJ] \r [x_sdPcP y_sdPcQ] g_sdPcJ y_sdPcQ x_sdPcP; } in
        let {
          sat_sdPcO [Occ=Once]
            :: b_adOdD -> Data.Functor.Utils.StateR a_adOdC c_adOdE
          [LclId] =
              [f_sdPcI] \r [x_sdPcM y_sdPcN] f_sdPcI y_sdPcN x_sdPcM;
        } in 
          Data.Bitraversable.bitraverse
              $dBitraversable_sdPcH
              Data.Functor.Utils.$fApplicativeStateR
              sat_sdPcO
              sat_sdPcR
              t1_sdPcL
              s_sdPcK;

bimapDefault1_rdOxw
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> (c -> Data.Functor.Identity.Identity d)
     -> t a c
     -> Data.Functor.Identity.Identity (t b d)
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdPcS]
        Data.Bitraversable.bitraverse
            $dBitraversable_sdPcS Data.Functor.Identity.$fApplicativeIdentity;

Data.Bitraversable.bimapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) a b c d.
     Data.Bitraversable.Bitraversable t =>
     (a -> b) -> (c -> d) -> t a c -> t b d
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B1] bimapDefault1_rdOxw eta_B1;

bifoldMapDefault1_rdOxx
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> (b -> Data.Functor.Const.Const m ())
     -> t a b
     -> Data.Functor.Const.Const m (t () ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dBitraversable_sdPcT $dMonoid_sdPcU]
        let {
          sat_sdPcV [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_adOct)
          [LclId] =
              [$dMonoid_sdPcU] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sdPcU;
        } in 
          Data.Bitraversable.bitraverse $dBitraversable_sdPcT sat_sdPcV;

Data.Bitraversable.bifoldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) m a b.
     (Data.Bitraversable.Bitraversable t, GHC.Base.Monoid m) =>
     (a -> m) -> (b -> m) -> t a b -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] bifoldMapDefault1_rdOxx eta_B2 eta_B1;

Data.Bitraversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bitraversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule4];

Data.Bitraversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bitraversable"#;

Data.Bitraversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$trModule2];

Data.Bitraversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bitraversable.$trModule3
                                     Data.Bitraversable.$trModule1];

$krep_rdOxy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bitraversable.$tcBitraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdOxy];

Data.Bitraversable.$tcBitraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bitraversable"#;

Data.Bitraversable.$tcBitraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bitraversable.$tcBitraversable3];

Data.Bitraversable.$tcBitraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1654555613294690493##
                                    8030854156262073676##
                                    Data.Bitraversable.$trModule
                                    Data.Bitraversable.$tcBitraversable2
                                    0#
                                    Data.Bitraversable.$tcBitraversable1];

Data.Bitraversable.C:Bitraversable
  :: forall (t :: * -> * -> *).
     (Data.Bifunctor.Bifunctor t, Data.Bifoldable.Bifoldable t) =>
     (forall (f :: * -> *) a c b d.
      GHC.Base.Applicative f =>
      (a -> f c) -> (b -> f d) -> t a b -> f (t c d))
     -> Data.Bitraversable.Bitraversable t
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bitraversable.C:Bitraversable [eta_B3 eta_B2 eta_B1];

