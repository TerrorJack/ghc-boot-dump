
==================== Tidy Core ====================
2018-03-16 16:06:49.566490984 UTC

Result size of Tidy Core
  = {terms: 2,519, types: 8,206, coercions: 832, joins: 0/29}

-- RHS size: {terms: 6, types: 76, coercions: 0, joins: 0/0}
Data.Traversable.$p1Traversable
  :: forall (t :: * -> *). Traversable t => Functor t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>,
 RULES: Built in rule for Data.Traversable.$p1Traversable: "Class op $p1Traversable"]
Data.Traversable.$p1Traversable
  = \ (@ (t_abVfw :: * -> *)) (v_B1 :: Traversable t_abVfw) ->
      case v_B1 of v_B1
      { Data.Traversable.C:Traversable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 76, coercions: 0, joins: 0/0}
Data.Traversable.$p2Traversable
  :: forall (t :: * -> *). Traversable t => Foldable t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>,
 RULES: Built in rule for Data.Traversable.$p2Traversable: "Class op $p2Traversable"]
Data.Traversable.$p2Traversable
  = \ (@ (t_abVfw :: * -> *)) (v_B1 :: Traversable t_abVfw) ->
      case v_B1 of v_B1
      { Data.Traversable.C:Traversable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 76, coercions: 0, joins: 0/0}
traverse
  :: forall (t :: * -> *).
     Traversable t =>
     forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>,
 RULES: Built in rule for traverse: "Class op traverse"]
traverse
  = \ (@ (t_abVfw :: * -> *)) (v_B1 :: Traversable t_abVfw) ->
      case v_B1 of v_B1
      { Data.Traversable.C:Traversable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 76, coercions: 0, joins: 0/0}
sequenceA
  :: forall (t :: * -> *).
     Traversable t =>
     forall (f :: * -> *) a. Applicative f => t (f a) -> f (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>,
 RULES: Built in rule for sequenceA: "Class op sequenceA"]
sequenceA
  = \ (@ (t_abVfw :: * -> *)) (v_B1 :: Traversable t_abVfw) ->
      case v_B1 of v_B1
      { Data.Traversable.C:Traversable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 76, coercions: 0, joins: 0/0}
mapM
  :: forall (t :: * -> *).
     Traversable t =>
     forall (m :: * -> *) a b. Monad m => (a -> m b) -> t a -> m (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>,
 RULES: Built in rule for mapM: "Class op mapM"]
mapM
  = \ (@ (t_abVfw :: * -> *)) (v_B1 :: Traversable t_abVfw) ->
      case v_B1 of v_B1
      { Data.Traversable.C:Traversable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 76, coercions: 0, joins: 0/0}
sequence
  :: forall (t :: * -> *).
     Traversable t =>
     forall (m :: * -> *) a. Monad m => t (m a) -> m (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>,
 RULES: Built in rule for sequence: "Class op sequence"]
sequence
  = \ (@ (t_abVfw :: * -> *)) (v_B1 :: Traversable t_abVfw) ->
      case v_B1 of v_B1
      { Data.Traversable.C:Traversable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B7
      }

-- RHS size: {terms: 19, types: 28, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Maybe a -> f (Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 60] 130 0}]
Data.Traversable.$fTraversableFirst_$ctraverse
  = \ (@ (f_abW15 :: * -> *))
      (@ a_abW16)
      (@ b_abW17)
      ($dApplicative_abW19 :: Applicative f_abW15)
      (eta_B2 :: a_abW16 -> f_abW15 b_abW17)
      (eta1_B1 :: Maybe a_abW16) ->
      case eta1_B1 of {
        Nothing ->
          pure
            @ f_abW15
            $dApplicative_abW19
            @ (Maybe b_abW17)
            (GHC.Base.Nothing @ b_abW17);
        Just x_abVgf ->
          fmap
            @ f_abW15
            (GHC.Base.$p1Applicative @ f_abW15 $dApplicative_abW19)
            @ b_abW17
            @ (Maybe b_abW17)
            (GHC.Base.Just @ b_abW17)
            (eta_B2 x_abVgf)
      }

-- RHS size: {terms: 24, types: 39, coercions: 0, joins: 0/2}
Data.Traversable.$fTraversable[]_$ctraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> [a] -> f [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVZK :: * -> *))
                 (@ a_abVZL)
                 (@ b_abVZM)
                 ($dApplicative_abVZO :: Applicative f_abVZK)
                 (f1_abVga [Occ=OnceL!] :: a_abVZL -> f_abVZK b_abVZM) ->
                 List.foldr
                   @ a_abVZL
                   @ (f_abVZK [b_abVZM])
                   (\ (x_abVgc [Occ=Once] :: a_abVZL)
                      (ys_abVgd [Occ=Once] :: f_abVZK [b_abVZM]) ->
                      liftA2
                        @ f_abVZK
                        $dApplicative_abVZO
                        @ b_abVZM
                        @ [b_abVZM]
                        @ [b_abVZM]
                        (GHC.Types.: @ b_abVZM)
                        (f1_abVga x_abVgc)
                        ys_abVgd)
                   (pure
                      @ f_abVZK
                      $dApplicative_abVZO
                      @ [b_abVZM]
                      (GHC.Types.[] @ b_abVZM))}]
Data.Traversable.$fTraversable[]_$ctraverse
  = \ (@ (f_abVZK :: * -> *))
      (@ a_abVZL)
      (@ b_abVZM)
      ($dApplicative_abVZO :: Applicative f_abVZK)
      (f1_abVga :: a_abVZL -> f_abVZK b_abVZM) ->
      let {
        z_i7Jci :: f_abVZK [b_abVZM]
        [LclId]
        z_i7Jci
          = pure
              @ f_abVZK
              $dApplicative_abVZO
              @ [b_abVZM]
              (GHC.Types.[] @ b_abVZM) } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker] :: [a_abVZL] -> f_abVZK [b_abVZM]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [a_abVZL]) ->
              case ds_i7Jck of {
                [] -> z_i7Jci;
                : y_i7Jcp ys_i7Jcq ->
                  liftA2
                    @ f_abVZK
                    $dApplicative_abVZO
                    @ b_abVZM
                    @ [b_abVZM]
                    @ [b_abVZM]
                    (GHC.Types.: @ b_abVZM)
                    (f1_abVga y_i7Jcp)
                    (go_i7Jcj ys_i7Jcq)
              }; } in
      go_i7Jcj

-- RHS size: {terms: 21, types: 37, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableEither_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     Applicative f =>
     (a2 -> f b) -> Either a1 a2 -> f (Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 70] 140 0}]
Data.Traversable.$fTraversableEither_$ctraverse
  = \ (@ a_abVXl)
      (@ (f_abVXx :: * -> *))
      (@ a1_abVXy)
      (@ b_abVXz)
      ($dApplicative_abVXB :: Applicative f_abVXx)
      (eta_B2 :: a1_abVXy -> f_abVXx b_abVXz)
      (eta1_B1 :: Either a_abVXl a1_abVXy) ->
      case eta1_B1 of {
        Left x_abVg4 ->
          pure
            @ f_abVXx
            $dApplicative_abVXB
            @ (Either a_abVXl b_abVXz)
            (Data.Either.Left @ a_abVXl @ b_abVXz x_abVg4);
        Right y_abVg6 ->
          fmap
            @ f_abVXx
            (GHC.Base.$p1Applicative @ f_abVXx $dApplicative_abVXB)
            @ b_abVXz
            @ (Either a_abVXl b_abVXz)
            (Data.Either.Right @ a_abVXl @ b_abVXz)
            (eta_B2 y_abVg6)
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable(,)_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     Applicative f =>
     (a2 -> f b) -> (a1, a2) -> f (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abVWj)
                 (@ (f_abVWv :: * -> *))
                 (@ a1_abVWw)
                 (@ b_abVWx)
                 ($dApplicative_abVWz [Occ=Once] :: Applicative f_abVWv)
                 (eta_B2 [Occ=Once!] :: a1_abVWw -> f_abVWv b_abVWx)
                 (eta1_B1 [Occ=Once!] :: (a_abVWj, a1_abVWw)) ->
                 case eta1_B1 of { (x_abVg1 [Occ=Once], y_abVg2 [Occ=Once]) ->
                 fmap
                   @ f_abVWv
                   (GHC.Base.$p1Applicative @ f_abVWv $dApplicative_abVWz)
                   @ b_abVWx
                   @ (a_abVWj, b_abVWx)
                   (GHC.Tuple.(,) @ a_abVWj @ b_abVWx x_abVg1)
                   (eta_B2 y_abVg2)
                 }}]
Data.Traversable.$fTraversable(,)_$ctraverse
  = \ (@ a_abVWj)
      (@ (f_abVWv :: * -> *))
      (@ a1_abVWw)
      (@ b_abVWx)
      ($dApplicative_abVWz :: Applicative f_abVWv)
      (eta_B2 :: a1_abVWw -> f_abVWv b_abVWx)
      (eta1_B1 :: (a_abVWj, a1_abVWw)) ->
      case eta1_B1 of { (x_abVg1, y_abVg2) ->
      fmap
        @ f_abVWv
        (GHC.Base.$p1Applicative @ f_abVWv $dApplicative_abVWz)
        @ b_abVWx
        @ (a_abVWj, b_abVWx)
        (GHC.Tuple.(,) @ a_abVWj @ b_abVWx x_abVg1)
        (eta_B2 y_abVg2)
      }

-- RHS size: {terms: 8, types: 22, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableProxy_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a. Monad m => Proxy (m a) -> m (Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVUN :: * -> *))
                 (@ a_abVUO)
                 ($dMonad_abVUQ [Occ=OnceL] :: Monad m_abVUN) ->
                 let {
                   $dApplicative_abVUS [Occ=OnceL] :: Applicative m_abVUN
                   [LclId]
                   $dApplicative_abVUS
                     = GHC.Base.$p1Monad @ m_abVUN $dMonad_abVUQ } in
                 \ _ [Occ=Dead] ->
                   pure
                     @ m_abVUN
                     $dApplicative_abVUS
                     @ (Proxy a_abVUO)
                     (Data.Proxy.Proxy @ * @ a_abVUO)}]
Data.Traversable.$fTraversableProxy_$csequence
  = \ (@ (m_abVUN :: * -> *))
      (@ a_abVUO)
      ($dMonad_abVUQ :: Monad m_abVUN)
      _ [Occ=Dead] ->
      pure
        @ m_abVUN
        (GHC.Base.$p1Monad @ m_abVUN $dMonad_abVUQ)
        @ (Proxy a_abVUO)
        (Data.Proxy.Proxy @ * @ a_abVUO)

-- RHS size: {terms: 10, types: 26, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableProxy_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Proxy a -> m (Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVUz :: * -> *))
                 (@ a_abVUA)
                 (@ b_abVUB)
                 ($dMonad_abVUD [Occ=OnceL] :: Monad m_abVUz) ->
                 let {
                   $dApplicative_abVUF [Occ=OnceL] :: Applicative m_abVUz
                   [LclId]
                   $dApplicative_abVUF
                     = GHC.Base.$p1Monad @ m_abVUz $dMonad_abVUD } in
                 \ _ [Occ=Dead] _ [Occ=Dead] ->
                   pure
                     @ m_abVUz
                     $dApplicative_abVUF
                     @ (Proxy b_abVUB)
                     (Data.Proxy.Proxy @ * @ b_abVUB)}]
Data.Traversable.$fTraversableProxy_$cmapM
  = \ (@ (m_abVUz :: * -> *))
      (@ a_abVUA)
      (@ b_abVUB)
      ($dMonad_abVUD :: Monad m_abVUz)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      pure
        @ m_abVUz
        (GHC.Base.$p1Monad @ m_abVUz $dMonad_abVUD)
        @ (Proxy b_abVUB)
        (Data.Proxy.Proxy @ * @ b_abVUB)

-- RHS size: {terms: 7, types: 21, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableProxy_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Proxy (f a) -> f (Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (f_abVUm :: * -> *))
                 (@ a_abVUn)
                 ($dApplicative_abVUp [Occ=Once] :: Applicative f_abVUm)
                 _ [Occ=Dead] ->
                 pure
                   @ f_abVUm
                   $dApplicative_abVUp
                   @ (Proxy a_abVUn)
                   (Data.Proxy.Proxy @ * @ a_abVUn)}]
Data.Traversable.$fTraversableProxy_$csequenceA
  = \ (@ (f_abVUm :: * -> *))
      (@ a_abVUn)
      ($dApplicative_abVUp :: Applicative f_abVUm)
      _ [Occ=Dead] ->
      pure
        @ f_abVUm
        $dApplicative_abVUp
        @ (Proxy a_abVUn)
        (Data.Proxy.Proxy @ * @ a_abVUn)

-- RHS size: {terms: 9, types: 25, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableProxy_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Proxy a -> f (Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (f_abVU7 :: * -> *))
                 (@ a_abVU8)
                 (@ b_abVU9)
                 ($dApplicative_abVUb [Occ=Once] :: Applicative f_abVU7)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 pure
                   @ f_abVU7
                   $dApplicative_abVUb
                   @ (Proxy b_abVU9)
                   (Data.Proxy.Proxy @ * @ b_abVU9)}]
Data.Traversable.$fTraversableProxy_$ctraverse
  = \ (@ (f_abVU7 :: * -> *))
      (@ a_abVU8)
      (@ b_abVU9)
      ($dApplicative_abVUb :: Applicative f_abVU7)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      pure
        @ f_abVU7
        $dApplicative_abVUb
        @ (Proxy b_abVU9)
        (Data.Proxy.Proxy @ * @ b_abVU9)

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Proxy
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Proxy
                                      Data.Proxy.$fFunctorProxy
                                      Data.Foldable.$fFoldableProxy
                                      Data.Traversable.$fTraversableProxy_$ctraverse
                                      Data.Traversable.$fTraversableProxy_$csequenceA
                                      Data.Traversable.$fTraversableProxy_$cmapM
                                      Data.Traversable.$fTraversableProxy_$csequence]
Data.Traversable.$fTraversableProxy
  = Data.Traversable.C:Traversable
      @ Proxy
      Data.Proxy.$fFunctorProxy
      Data.Foldable.$fFoldableProxy
      Data.Traversable.$fTraversableProxy_$ctraverse
      Data.Traversable.$fTraversableProxy_$csequenceA
      Data.Traversable.$fTraversableProxy_$cmapM
      Data.Traversable.$fTraversableProxy_$csequence

-- RHS size: {terms: 10, types: 26, coercions: 12, joins: 0/0}
Data.Traversable.$fTraversableConst_$ctraverse
  :: forall m (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Const m a -> f (Const m b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_abVSR)
                 (@ (f_abVT3 :: * -> *))
                 (@ a_abVT4)
                 (@ b_abVT5)
                 ($dApplicative_abVT7 [Occ=Once] :: Applicative f_abVT3)
                 _ [Occ=Dead]
                 (ds1_dbW83 [Occ=Once] :: Const m_abVSR a_abVT4) ->
                 pure
                   @ f_abVT3
                   $dApplicative_abVT7
                   @ (Const m_abVSR b_abVT5)
                   (ds1_dbW83
                    `cast` (Data.Functor.Const.N:Const[0]
                                <*>_N <m_abVSR>_R <a_abVT4>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                                         <*>_N
                                                                         <m_abVSR>_R
                                                                         <b_abVT5>_P)
                            :: (Const m_abVSR a_abVT4 :: *)
                               ~R# (Const m_abVSR b_abVT5 :: *)))}]
Data.Traversable.$fTraversableConst_$ctraverse
  = \ (@ m_abVSR)
      (@ (f_abVT3 :: * -> *))
      (@ a_abVT4)
      (@ b_abVT5)
      ($dApplicative_abVT7 :: Applicative f_abVT3)
      _ [Occ=Dead]
      (ds1_dbW83 :: Const m_abVSR a_abVT4) ->
      pure
        @ f_abVT3
        $dApplicative_abVT7
        @ (Const m_abVSR b_abVT5)
        (ds1_dbW83
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N <m_abVSR>_R <a_abVT4>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <m_abVSR>_R <b_abVT5>_P)
                 :: (Const m_abVSR a_abVT4 :: *) ~R# (Const m_abVSR b_abVT5 :: *)))

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableDual1 :: forall b. b -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abVS4) (v_X5 [Occ=Once] :: b_abVS4) -> v_X5}]
Data.Traversable.$fTraversableDual1
  = \ (@ b_abVS4) (v_X5 :: b_abVS4) -> v_X5

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableDual_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Dual a -> f (Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVS2 :: * -> *))
                 (@ a_abVS3)
                 (@ b_abVS4)
                 ($dApplicative_abVS6 [Occ=Once] :: Applicative f_abVS2)
                 (eta_B2 [Occ=Once!] :: a_abVS3 -> f_abVS2 b_abVS4)
                 (eta1_B1 [Occ=Once] :: Dual a_abVS3) ->
                 fmap
                   @ f_abVS2
                   (GHC.Base.$p1Applicative @ f_abVS2 $dApplicative_abVS6)
                   @ b_abVS4
                   @ (Dual b_abVS4)
                   ((Data.Traversable.$fTraversableDual1 @ b_abVS4)
                    `cast` (<b_abVS4>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <b_abVS4>_R)
                            :: (b_abVS4 -> b_abVS4 :: *) ~R# (b_abVS4 -> Dual b_abVS4 :: *)))
                   (eta_B2
                      (eta1_B1
                       `cast` (Data.Semigroup.Internal.N:Dual[0] <a_abVS3>_R
                               :: (Dual a_abVS3 :: *) ~R# (a_abVS3 :: *))))}]
Data.Traversable.$fTraversableDual_$ctraverse
  = \ (@ (f_abVS2 :: * -> *))
      (@ a_abVS3)
      (@ b_abVS4)
      ($dApplicative_abVS6 :: Applicative f_abVS2)
      (eta_B2 :: a_abVS3 -> f_abVS2 b_abVS4)
      (eta1_B1 :: Dual a_abVS3) ->
      fmap
        @ f_abVS2
        (GHC.Base.$p1Applicative @ f_abVS2 $dApplicative_abVS6)
        @ b_abVS4
        @ (Dual b_abVS4)
        ((Data.Traversable.$fTraversableDual1 @ b_abVS4)
         `cast` (<b_abVS4>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <b_abVS4>_R)
                 :: (b_abVS4 -> b_abVS4 :: *) ~R# (b_abVS4 -> Dual b_abVS4 :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Semigroup.Internal.N:Dual[0] <a_abVS3>_R
                    :: (Dual a_abVS3 :: *) ~R# (a_abVS3 :: *))))

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Sum a -> f (Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVR2 :: * -> *))
                 (@ a_abVR3)
                 (@ b_abVR4)
                 ($dApplicative_abVR6 [Occ=Once] :: Applicative f_abVR2)
                 (eta_B2 [Occ=Once!] :: a_abVR3 -> f_abVR2 b_abVR4)
                 (eta1_B1 [Occ=Once] :: Sum a_abVR3) ->
                 fmap
                   @ f_abVR2
                   (GHC.Base.$p1Applicative @ f_abVR2 $dApplicative_abVR6)
                   @ b_abVR4
                   @ (Sum b_abVR4)
                   ((Data.Traversable.$fTraversableDual1 @ b_abVR4)
                    `cast` (<b_abVR4>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <b_abVR4>_R)
                            :: (b_abVR4 -> b_abVR4 :: *) ~R# (b_abVR4 -> Sum b_abVR4 :: *)))
                   (eta_B2
                      (eta1_B1
                       `cast` (Data.Semigroup.Internal.N:Sum[0] <a_abVR3>_R
                               :: (Sum a_abVR3 :: *) ~R# (a_abVR3 :: *))))}]
Data.Traversable.$fTraversableSum_$ctraverse
  = \ (@ (f_abVR2 :: * -> *))
      (@ a_abVR3)
      (@ b_abVR4)
      ($dApplicative_abVR6 :: Applicative f_abVR2)
      (eta_B2 :: a_abVR3 -> f_abVR2 b_abVR4)
      (eta1_B1 :: Sum a_abVR3) ->
      fmap
        @ f_abVR2
        (GHC.Base.$p1Applicative @ f_abVR2 $dApplicative_abVR6)
        @ b_abVR4
        @ (Sum b_abVR4)
        ((Data.Traversable.$fTraversableDual1 @ b_abVR4)
         `cast` (<b_abVR4>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <b_abVR4>_R)
                 :: (b_abVR4 -> b_abVR4 :: *) ~R# (b_abVR4 -> Sum b_abVR4 :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Semigroup.Internal.N:Sum[0] <a_abVR3>_R
                    :: (Sum a_abVR3 :: *) ~R# (a_abVR3 :: *))))

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableProduct_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Product a -> f (Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVQ2 :: * -> *))
                 (@ a_abVQ3)
                 (@ b_abVQ4)
                 ($dApplicative_abVQ6 [Occ=Once] :: Applicative f_abVQ2)
                 (eta_B2 [Occ=Once!] :: a_abVQ3 -> f_abVQ2 b_abVQ4)
                 (eta1_B1 [Occ=Once] :: Product a_abVQ3) ->
                 fmap
                   @ f_abVQ2
                   (GHC.Base.$p1Applicative @ f_abVQ2 $dApplicative_abVQ6)
                   @ b_abVQ4
                   @ (Product b_abVQ4)
                   ((Data.Traversable.$fTraversableDual1 @ b_abVQ4)
                    `cast` (<b_abVQ4>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Product[0] <b_abVQ4>_R)
                            :: (b_abVQ4 -> b_abVQ4 :: *)
                               ~R# (b_abVQ4 -> Product b_abVQ4 :: *)))
                   (eta_B2
                      (eta1_B1
                       `cast` (Data.Semigroup.Internal.N:Product[0] <a_abVQ3>_R
                               :: (Product a_abVQ3 :: *) ~R# (a_abVQ3 :: *))))}]
Data.Traversable.$fTraversableProduct_$ctraverse
  = \ (@ (f_abVQ2 :: * -> *))
      (@ a_abVQ3)
      (@ b_abVQ4)
      ($dApplicative_abVQ6 :: Applicative f_abVQ2)
      (eta_B2 :: a_abVQ3 -> f_abVQ2 b_abVQ4)
      (eta1_B1 :: Product a_abVQ3) ->
      fmap
        @ f_abVQ2
        (GHC.Base.$p1Applicative @ f_abVQ2 $dApplicative_abVQ6)
        @ b_abVQ4
        @ (Product b_abVQ4)
        ((Data.Traversable.$fTraversableDual1 @ b_abVQ4)
         `cast` (<b_abVQ4>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Product[0] <b_abVQ4>_R)
                 :: (b_abVQ4 -> b_abVQ4 :: *)
                    ~R# (b_abVQ4 -> Product b_abVQ4 :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Semigroup.Internal.N:Product[0] <a_abVQ3>_R
                    :: (Product a_abVQ3 :: *) ~R# (a_abVQ3 :: *))))

-- RHS size: {terms: 8, types: 22, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableU1_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a. Monad m => U1 (m a) -> m (U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVMn :: * -> *))
                 (@ a_abVMo)
                 ($dMonad_abVMq [Occ=OnceL] :: Monad m_abVMn) ->
                 let {
                   $dApplicative_abVMs [Occ=OnceL] :: Applicative m_abVMn
                   [LclId]
                   $dApplicative_abVMs
                     = GHC.Base.$p1Monad @ m_abVMn $dMonad_abVMq } in
                 \ _ [Occ=Dead] ->
                   pure
                     @ m_abVMn
                     $dApplicative_abVMs
                     @ (U1 a_abVMo)
                     (GHC.Generics.U1 @ * @ a_abVMo)}]
Data.Traversable.$fTraversableU1_$csequence
  = \ (@ (m_abVMn :: * -> *))
      (@ a_abVMo)
      ($dMonad_abVMq :: Monad m_abVMn)
      _ [Occ=Dead] ->
      pure
        @ m_abVMn
        (GHC.Base.$p1Monad @ m_abVMn $dMonad_abVMq)
        @ (U1 a_abVMo)
        (GHC.Generics.U1 @ * @ a_abVMo)

-- RHS size: {terms: 10, types: 26, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableU1_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> U1 a -> m (U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVM9 :: * -> *))
                 (@ a_abVMa)
                 (@ b_abVMb)
                 ($dMonad_abVMd [Occ=OnceL] :: Monad m_abVM9) ->
                 let {
                   $dApplicative_abVMf [Occ=OnceL] :: Applicative m_abVM9
                   [LclId]
                   $dApplicative_abVMf
                     = GHC.Base.$p1Monad @ m_abVM9 $dMonad_abVMd } in
                 \ _ [Occ=Dead] _ [Occ=Dead] ->
                   pure
                     @ m_abVM9
                     $dApplicative_abVMf
                     @ (U1 b_abVMb)
                     (GHC.Generics.U1 @ * @ b_abVMb)}]
Data.Traversable.$fTraversableU1_$cmapM
  = \ (@ (m_abVM9 :: * -> *))
      (@ a_abVMa)
      (@ b_abVMb)
      ($dMonad_abVMd :: Monad m_abVM9)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      pure
        @ m_abVM9
        (GHC.Base.$p1Monad @ m_abVM9 $dMonad_abVMd)
        @ (U1 b_abVMb)
        (GHC.Generics.U1 @ * @ b_abVMb)

-- RHS size: {terms: 7, types: 21, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableU1_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a. Applicative f => U1 (f a) -> f (U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (f_abVLW :: * -> *))
                 (@ a_abVLX)
                 ($dApplicative_abVLZ [Occ=Once] :: Applicative f_abVLW)
                 _ [Occ=Dead] ->
                 pure
                   @ f_abVLW
                   $dApplicative_abVLZ
                   @ (U1 a_abVLX)
                   (GHC.Generics.U1 @ * @ a_abVLX)}]
Data.Traversable.$fTraversableU1_$csequenceA
  = \ (@ (f_abVLW :: * -> *))
      (@ a_abVLX)
      ($dApplicative_abVLZ :: Applicative f_abVLW)
      _ [Occ=Dead] ->
      pure
        @ f_abVLW
        $dApplicative_abVLZ
        @ (U1 a_abVLX)
        (GHC.Generics.U1 @ * @ a_abVLX)

-- RHS size: {terms: 9, types: 25, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableU1_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> U1 a -> f (U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (f_abVLI :: * -> *))
                 (@ a_abVLJ)
                 (@ b_abVLK)
                 ($dApplicative_abVLM [Occ=Once] :: Applicative f_abVLI)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 pure
                   @ f_abVLI
                   $dApplicative_abVLM
                   @ (U1 b_abVLK)
                   (GHC.Generics.U1 @ * @ b_abVLK)}]
Data.Traversable.$fTraversableU1_$ctraverse
  = \ (@ (f_abVLI :: * -> *))
      (@ a_abVLJ)
      (@ b_abVLK)
      ($dApplicative_abVLM :: Applicative f_abVLI)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      pure
        @ f_abVLI
        $dApplicative_abVLM
        @ (U1 b_abVLK)
        (GHC.Generics.U1 @ * @ b_abVLK)

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable U1
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: U1
                                      GHC.Generics.$fFunctorU1
                                      Data.Foldable.$fFoldableU1
                                      Data.Traversable.$fTraversableU1_$ctraverse
                                      Data.Traversable.$fTraversableU1_$csequenceA
                                      Data.Traversable.$fTraversableU1_$cmapM
                                      Data.Traversable.$fTraversableU1_$csequence]
Data.Traversable.$fTraversableU1
  = Data.Traversable.C:Traversable
      @ U1
      GHC.Generics.$fFunctorU1
      Data.Foldable.$fFoldableU1
      Data.Traversable.$fTraversableU1_$ctraverse
      Data.Traversable.$fTraversableU1_$csequenceA
      Data.Traversable.$fTraversableU1_$cmapM
      Data.Traversable.$fTraversableU1_$csequence

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableIdentity_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Identity a -> f (Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVKI :: * -> *))
                 (@ a_abVKJ)
                 (@ b_abVKK)
                 ($dApplicative_abVKM [Occ=Once] :: Applicative f_abVKI)
                 (eta_B2 [Occ=Once!] :: a_abVKJ -> f_abVKI b_abVKK)
                 (eta1_B1 [Occ=Once] :: Identity a_abVKJ) ->
                 fmap
                   @ f_abVKI
                   (GHC.Base.$p1Applicative @ f_abVKI $dApplicative_abVKM)
                   @ b_abVKK
                   @ (Identity b_abVKK)
                   ((Data.Traversable.$fTraversableDual1 @ b_abVKK)
                    `cast` (<b_abVKK>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0] <b_abVKK>_R)
                            :: (b_abVKK -> b_abVKK :: *)
                               ~R# (b_abVKK -> Identity b_abVKK :: *)))
                   (eta_B2
                      (eta1_B1
                       `cast` (Data.Functor.Identity.N:Identity[0] <a_abVKJ>_R
                               :: (Identity a_abVKJ :: *) ~R# (a_abVKJ :: *))))}]
Data.Traversable.$fTraversableIdentity_$ctraverse
  = \ (@ (f_abVKI :: * -> *))
      (@ a_abVKJ)
      (@ b_abVKK)
      ($dApplicative_abVKM :: Applicative f_abVKI)
      (eta_B2 :: a_abVKJ -> f_abVKI b_abVKK)
      (eta1_B1 :: Identity a_abVKJ) ->
      fmap
        @ f_abVKI
        (GHC.Base.$p1Applicative @ f_abVKI $dApplicative_abVKM)
        @ b_abVKK
        @ (Identity b_abVKK)
        ((Data.Traversable.$fTraversableDual1 @ b_abVKK)
         `cast` (<b_abVKK>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <b_abVKK>_R)
                 :: (b_abVKK -> b_abVKK :: *)
                    ~R# (b_abVKK -> Identity b_abVKK :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Functor.Identity.N:Identity[0] <a_abVKJ>_R
                    :: (Identity a_abVKJ :: *) ~R# (a_abVKJ :: *))))

-- RHS size: {terms: 9, types: 22, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableV1_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> V1 a -> f (V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_abVJH :: * -> *))
                 (@ a_abVJI)
                 (@ b_abVJJ)
                 ($dApplicative_abVJL [Occ=Once] :: Applicative f_abVJH)
                 _ [Occ=Dead]
                 (z_abVog [Occ=Once] :: V1 a_abVJI) ->
                 pure
                   @ f_abVJH
                   $dApplicative_abVJL
                   @ (V1 b_abVJJ)
                   (z_abVog
                    `cast` ((V1
                               <*>_N Univ(phantom phantom <*>_N :: a_abVJI, b_abVJJ))_R
                            :: (V1 a_abVJI :: *) ~R# (V1 b_abVJJ :: *)))}]
Data.Traversable.$fTraversableV1_$ctraverse
  = \ (@ (f_abVJH :: * -> *))
      (@ a_abVJI)
      (@ b_abVJJ)
      ($dApplicative_abVJL :: Applicative f_abVJH)
      _ [Occ=Dead]
      (z_abVog :: V1 a_abVJI) ->
      pure
        @ f_abVJH
        $dApplicative_abVJL
        @ (V1 b_abVJJ)
        (z_abVog
         `cast` ((V1
                    <*>_N Univ(phantom phantom <*>_N :: a_abVJI, b_abVJJ))_R
                 :: (V1 a_abVJI :: *) ~R# (V1 b_abVJJ :: *)))

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversablePar1_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Par1 a -> f (Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVIH :: * -> *))
                 (@ a_abVII)
                 (@ b_abVIJ)
                 ($dApplicative_abVIL [Occ=Once] :: Applicative f_abVIH)
                 (eta_B2 [Occ=Once!] :: a_abVII -> f_abVIH b_abVIJ)
                 (eta1_B1 [Occ=Once] :: Par1 a_abVII) ->
                 fmap
                   @ f_abVIH
                   (GHC.Base.$p1Applicative @ f_abVIH $dApplicative_abVIL)
                   @ b_abVIJ
                   @ (Par1 b_abVIJ)
                   ((Data.Traversable.$fTraversableDual1 @ b_abVIJ)
                    `cast` (<b_abVIJ>_R ->_R Sym (GHC.Generics.N:Par1[0] <b_abVIJ>_R)
                            :: (b_abVIJ -> b_abVIJ :: *) ~R# (b_abVIJ -> Par1 b_abVIJ :: *)))
                   (eta_B2
                      (eta1_B1
                       `cast` (GHC.Generics.N:Par1[0] <a_abVII>_R
                               :: (Par1 a_abVII :: *) ~R# (a_abVII :: *))))}]
Data.Traversable.$fTraversablePar1_$ctraverse
  = \ (@ (f_abVIH :: * -> *))
      (@ a_abVII)
      (@ b_abVIJ)
      ($dApplicative_abVIL :: Applicative f_abVIH)
      (eta_B2 :: a_abVII -> f_abVIH b_abVIJ)
      (eta1_B1 :: Par1 a_abVII) ->
      fmap
        @ f_abVIH
        (GHC.Base.$p1Applicative @ f_abVIH $dApplicative_abVIL)
        @ b_abVIJ
        @ (Par1 b_abVIJ)
        ((Data.Traversable.$fTraversableDual1 @ b_abVIJ)
         `cast` (<b_abVIJ>_R ->_R Sym (GHC.Generics.N:Par1[0] <b_abVIJ>_R)
                 :: (b_abVIJ -> b_abVIJ :: *) ~R# (b_abVIJ -> Par1 b_abVIJ :: *)))
        (eta_B2
           (eta1_B1
            `cast` (GHC.Generics.N:Par1[0] <a_abVII>_R
                    :: (Par1 a_abVII :: *) ~R# (a_abVII :: *))))

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableM2
  :: forall (f :: * -> *) b. f b -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 (@ b_abVHB)
                 (b1_abVoc [Occ=Once] :: f_abVHm b_abVHB) ->
                 b1_abVoc}]
Data.Traversable.$fTraversableM2
  = \ (@ (f_abVHm :: * -> *))
      (@ b_abVHB)
      (b1_abVoc :: f_abVHm b_abVHB) ->
      b1_abVoc

-- RHS size: {terms: 17, types: 39, coercions: 14, joins: 0/0}
Data.Traversable.$fTraversableRec1_$ctraverse
  :: forall (f :: * -> *).
     Traversable f =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> Rec1 f a -> f1 (Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 ($dTraversable_abVHn [Occ=Once] :: Traversable f_abVHm)
                 (@ (f1_abVHz :: * -> *))
                 (@ a_abVHA)
                 (@ b_abVHB)
                 ($dApplicative_abVHD :: Applicative f1_abVHz)
                 (eta_B2 [Occ=Once] :: a_abVHA -> f1_abVHz b_abVHB)
                 (eta1_B1 [Occ=Once] :: Rec1 f_abVHm a_abVHA) ->
                 fmap
                   @ f1_abVHz
                   (GHC.Base.$p1Applicative @ f1_abVHz $dApplicative_abVHD)
                   @ (f_abVHm b_abVHB)
                   @ (Rec1 f_abVHm b_abVHB)
                   ((Data.Traversable.$fTraversableM2 @ f_abVHm @ b_abVHB)
                    `cast` (<f_abVHm b_abVHB>_R
                            ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <b_abVHB>_N
                            :: (f_abVHm b_abVHB -> f_abVHm b_abVHB :: *)
                               ~R# (f_abVHm b_abVHB -> Rec1 f_abVHm b_abVHB :: *)))
                   (traverse
                      @ f_abVHm
                      $dTraversable_abVHn
                      @ f1_abVHz
                      @ a_abVHA
                      @ b_abVHB
                      $dApplicative_abVHD
                      eta_B2
                      (eta1_B1
                       `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R <a_abVHA>_N
                               :: (Rec1 f_abVHm a_abVHA :: *) ~R# (f_abVHm a_abVHA :: *))))}]
Data.Traversable.$fTraversableRec1_$ctraverse
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm)
      (@ (f1_abVHz :: * -> *))
      (@ a_abVHA)
      (@ b_abVHB)
      ($dApplicative_abVHD :: Applicative f1_abVHz)
      (eta_B2 :: a_abVHA -> f1_abVHz b_abVHB)
      (eta1_B1 :: Rec1 f_abVHm a_abVHA) ->
      fmap
        @ f1_abVHz
        (GHC.Base.$p1Applicative @ f1_abVHz $dApplicative_abVHD)
        @ (f_abVHm b_abVHB)
        @ (Rec1 f_abVHm b_abVHB)
        ((Data.Traversable.$fTraversableM2 @ f_abVHm @ b_abVHB)
         `cast` (<f_abVHm b_abVHB>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <b_abVHB>_N
                 :: (f_abVHm b_abVHB -> f_abVHm b_abVHB :: *)
                    ~R# (f_abVHm b_abVHB -> Rec1 f_abVHm b_abVHB :: *)))
        (traverse
           @ f_abVHm
           $dTraversable_abVHn
           @ f1_abVHz
           @ a_abVHA
           @ b_abVHB
           $dApplicative_abVHD
           eta_B2
           (eta1_B1
            `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R <a_abVHA>_N
                    :: (Rec1 f_abVHm a_abVHA :: *) ~R# (f_abVHm a_abVHA :: *))))

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableRec1_$cp2Traversable
  :: forall (f :: * -> *). Traversable f => Foldable (Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 ($dTraversable_abVHn [Occ=Once] :: Traversable f_abVHm) ->
                 Data.Foldable.$fFoldableRec1
                   @ f_abVHm
                   (Data.Traversable.$p2Traversable @ f_abVHm $dTraversable_abVHn)}]
Data.Traversable.$fTraversableRec1_$cp2Traversable
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm) ->
      Data.Foldable.$fFoldableRec1
        @ f_abVHm
        (Data.Traversable.$p2Traversable @ f_abVHm $dTraversable_abVHn)

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableRec1_$cp1Traversable
  :: forall (f :: * -> *). Traversable f => Functor (Rec1 f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 ($dTraversable_abVHn [Occ=Once] :: Traversable f_abVHm) ->
                 GHC.Generics.$fFunctorRec1
                   @ f_abVHm
                   (Data.Traversable.$p1Traversable @ f_abVHm $dTraversable_abVHn)}]
Data.Traversable.$fTraversableRec1_$cp1Traversable
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm) ->
      GHC.Generics.$fFunctorRec1
        @ f_abVHm
        (Data.Traversable.$p1Traversable @ f_abVHm $dTraversable_abVHn)

-- RHS size: {terms: 11, types: 29, coercions: 14, joins: 0/0}
Data.Traversable.$fTraversableK1_$ctraverse
  :: forall i c (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> K1 i c a -> f (K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_abVGj)
                 (@ c_abVGk)
                 (@ (f_abVGw :: * -> *))
                 (@ a_abVGx)
                 (@ b_abVGy)
                 ($dApplicative_abVGA [Occ=Once] :: Applicative f_abVGw)
                 _ [Occ=Dead]
                 (z_abVo9 [Occ=Once] :: K1 i_abVGj c_abVGk a_abVGx) ->
                 pure
                   @ f_abVGw
                   $dApplicative_abVGA
                   @ (K1 i_abVGj c_abVGk b_abVGy)
                   (z_abVo9
                    `cast` (GHC.Generics.N:K1[0]
                                <*>_N
                                <i_abVGj>_P
                                <c_abVGk>_R
                                <a_abVGx>_P ; Sym (GHC.Generics.N:K1[0]
                                                       <*>_N <i_abVGj>_P <c_abVGk>_R <b_abVGy>_P)
                            :: (K1 i_abVGj c_abVGk a_abVGx :: *)
                               ~R# (K1 i_abVGj c_abVGk b_abVGy :: *)))}]
Data.Traversable.$fTraversableK1_$ctraverse
  = \ (@ i_abVGj)
      (@ c_abVGk)
      (@ (f_abVGw :: * -> *))
      (@ a_abVGx)
      (@ b_abVGy)
      ($dApplicative_abVGA :: Applicative f_abVGw)
      _ [Occ=Dead]
      (z_abVo9 :: K1 i_abVGj c_abVGk a_abVGx) ->
      pure
        @ f_abVGw
        $dApplicative_abVGA
        @ (K1 i_abVGj c_abVGk b_abVGy)
        (z_abVo9
         `cast` (GHC.Generics.N:K1[0]
                     <*>_N
                     <i_abVGj>_P
                     <c_abVGk>_R
                     <a_abVGx>_P ; Sym (GHC.Generics.N:K1[0]
                                            <*>_N <i_abVGj>_P <c_abVGk>_R <b_abVGy>_P)
                 :: (K1 i_abVGj c_abVGk a_abVGx :: *)
                    ~R# (K1 i_abVGj c_abVGk b_abVGy :: *)))

-- RHS size: {terms: 19, types: 45, coercions: 18, joins: 0/0}
Data.Traversable.$fTraversableM1_$ctraverse
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> M1 i c f a -> f1 (M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVF5 :: * -> *))
                 (@ i_abVF6)
                 (@ (c_abVF7 :: Meta))
                 ($dTraversable_abVF8 [Occ=Once] :: Traversable f_abVF5)
                 (@ (f1_abVFk :: * -> *))
                 (@ a_abVFl)
                 (@ b_abVFm)
                 ($dApplicative_abVFo :: Applicative f1_abVFk)
                 (eta_B2 [Occ=Once] :: a_abVFl -> f1_abVFk b_abVFm)
                 (eta1_B1 [Occ=Once] :: M1 i_abVF6 c_abVF7 f_abVF5 a_abVFl) ->
                 fmap
                   @ f1_abVFk
                   (GHC.Base.$p1Applicative @ f1_abVFk $dApplicative_abVFo)
                   @ (f_abVF5 b_abVFm)
                   @ (M1 i_abVF6 c_abVF7 f_abVF5 b_abVFm)
                   ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ b_abVFm)
                    `cast` (<f_abVF5 b_abVFm>_R
                            ->_R Sym (GHC.Generics.N:M1[0]
                                          <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <b_abVFm>_N
                            :: (f_abVF5 b_abVFm -> f_abVF5 b_abVFm :: *)
                               ~R# (f_abVF5 b_abVFm -> M1 i_abVF6 c_abVF7 f_abVF5 b_abVFm :: *)))
                   (traverse
                      @ f_abVF5
                      $dTraversable_abVF8
                      @ f1_abVFk
                      @ a_abVFl
                      @ b_abVFm
                      $dApplicative_abVFo
                      eta_B2
                      (eta1_B1
                       `cast` (GHC.Generics.N:M1[0]
                                   <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <a_abVFl>_N
                               :: (M1 i_abVF6 c_abVF7 f_abVF5 a_abVFl :: *)
                                  ~R# (f_abVF5 a_abVFl :: *))))}]
Data.Traversable.$fTraversableM1_$ctraverse
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5)
      (@ (f1_abVFk :: * -> *))
      (@ a_abVFl)
      (@ b_abVFm)
      ($dApplicative_abVFo :: Applicative f1_abVFk)
      (eta_B2 :: a_abVFl -> f1_abVFk b_abVFm)
      (eta1_B1 :: M1 i_abVF6 c_abVF7 f_abVF5 a_abVFl) ->
      fmap
        @ f1_abVFk
        (GHC.Base.$p1Applicative @ f1_abVFk $dApplicative_abVFo)
        @ (f_abVF5 b_abVFm)
        @ (M1 i_abVF6 c_abVF7 f_abVF5 b_abVFm)
        ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ b_abVFm)
         `cast` (<f_abVF5 b_abVFm>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <b_abVFm>_N
                 :: (f_abVF5 b_abVFm -> f_abVF5 b_abVFm :: *)
                    ~R# (f_abVF5 b_abVFm -> M1 i_abVF6 c_abVF7 f_abVF5 b_abVFm :: *)))
        (traverse
           @ f_abVF5
           $dTraversable_abVF8
           @ f1_abVFk
           @ a_abVFl
           @ b_abVFm
           $dApplicative_abVFo
           eta_B2
           (eta1_B1
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <a_abVFl>_N
                    :: (M1 i_abVF6 c_abVF7 f_abVF5 a_abVFl :: *)
                       ~R# (f_abVF5 a_abVFl :: *))))

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableM1_$cp2Traversable
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     Foldable (M1 i c f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVF5 :: * -> *))
                 (@ i_abVF6)
                 (@ (c_abVF7 :: Meta))
                 ($dTraversable_abVF8 [Occ=Once] :: Traversable f_abVF5) ->
                 Data.Foldable.$fFoldableM1
                   @ f_abVF5
                   @ i_abVF6
                   @ c_abVF7
                   (Data.Traversable.$p2Traversable @ f_abVF5 $dTraversable_abVF8)}]
Data.Traversable.$fTraversableM1_$cp2Traversable
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5) ->
      Data.Foldable.$fFoldableM1
        @ f_abVF5
        @ i_abVF6
        @ c_abVF7
        (Data.Traversable.$p2Traversable @ f_abVF5 $dTraversable_abVF8)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableM1_$cp1Traversable
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     Functor (M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVF5 :: * -> *))
                 (@ i_abVF6)
                 (@ (c_abVF7 :: Meta))
                 ($dTraversable_abVF8 [Occ=Once] :: Traversable f_abVF5) ->
                 GHC.Generics.$fFunctorM1
                   @ i_abVF6
                   @ c_abVF7
                   @ f_abVF5
                   (Data.Traversable.$p1Traversable @ f_abVF5 $dTraversable_abVF8)}]
Data.Traversable.$fTraversableM1_$cp1Traversable
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5) ->
      GHC.Generics.$fFunctorM1
        @ i_abVF6
        @ c_abVF7
        @ f_abVF5
        (Data.Traversable.$p1Traversable @ f_abVF5 $dTraversable_abVF8)

-- RHS size: {terms: 32, types: 79, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> (:+:) f g a -> f1 ((:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 140] 240 0}]
Data.Traversable.$fTraversable:+:_$ctraverse
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF)
      (@ (f1_abVDT :: * -> *))
      (@ a_abVDU)
      (@ b_abVDV)
      ($dApplicative_abVDX :: Applicative f1_abVDT)
      (eta_B2 :: a_abVDU -> f1_abVDT b_abVDV)
      (eta1_B1 :: (:+:) f_abVDE g_abVDF a_abVDU) ->
      case eta1_B1 of {
        L1 a1_abVo1 ->
          fmap
            @ f1_abVDT
            (GHC.Base.$p1Applicative @ f1_abVDT $dApplicative_abVDX)
            @ (f_abVDE b_abVDV)
            @ ((:+:) f_abVDE g_abVDF b_abVDV)
            (GHC.Generics.L1 @ * @ f_abVDE @ g_abVDF @ b_abVDV)
            (traverse
               @ f_abVDE
               $dTraversable_abVDG
               @ f1_abVDT
               @ a_abVDU
               @ b_abVDV
               $dApplicative_abVDX
               eta_B2
               a1_abVo1);
        R1 a1_abVo4 ->
          fmap
            @ f1_abVDT
            (GHC.Base.$p1Applicative @ f1_abVDT $dApplicative_abVDX)
            @ (g_abVDF b_abVDV)
            @ ((:+:) f_abVDE g_abVDF b_abVDV)
            (GHC.Generics.R1 @ * @ f_abVDE @ g_abVDF @ b_abVDV)
            (traverse
               @ g_abVDF
               $dTraversable1_abVDH
               @ f1_abVDT
               @ a_abVDU
               @ b_abVDV
               $dApplicative_abVDX
               eta_B2
               a1_abVo4)
      }

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Foldable (f :+: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVDE :: * -> *))
                 (@ (g_abVDF :: * -> *))
                 ($dTraversable_abVDG [Occ=Once] :: Traversable f_abVDE)
                 ($dTraversable1_abVDH [Occ=Once] :: Traversable g_abVDF) ->
                 Data.Foldable.$fFoldable:+:
                   @ f_abVDE
                   @ g_abVDF
                   (Data.Traversable.$p2Traversable @ f_abVDE $dTraversable_abVDG)
                   (Data.Traversable.$p2Traversable @ g_abVDF $dTraversable1_abVDH)}]
Data.Traversable.$fTraversable:+:_$cp2Traversable
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF) ->
      Data.Foldable.$fFoldable:+:
        @ f_abVDE
        @ g_abVDF
        (Data.Traversable.$p2Traversable @ f_abVDE $dTraversable_abVDG)
        (Data.Traversable.$p2Traversable @ g_abVDF $dTraversable1_abVDH)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Functor (f :+: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVDE :: * -> *))
                 (@ (g_abVDF :: * -> *))
                 ($dTraversable_abVDG [Occ=Once] :: Traversable f_abVDE)
                 ($dTraversable1_abVDH [Occ=Once] :: Traversable g_abVDF) ->
                 GHC.Generics.$fFunctor:+:
                   @ f_abVDE
                   @ g_abVDF
                   (Data.Traversable.$p1Traversable @ f_abVDE $dTraversable_abVDG)
                   (Data.Traversable.$p1Traversable @ g_abVDF $dTraversable1_abVDH)}]
Data.Traversable.$fTraversable:+:_$cp1Traversable
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF) ->
      GHC.Generics.$fFunctor:+:
        @ f_abVDE
        @ g_abVDF
        (Data.Traversable.$p1Traversable @ f_abVDE $dTraversable_abVDG)
        (Data.Traversable.$p1Traversable @ g_abVDF $dTraversable1_abVDH)

-- RHS size: {terms: 24, types: 53, coercions: 0, joins: 0/0}
Data.Traversable.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> f a -> g a -> f1 ((:*:) f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0] 150 0}]
Data.Traversable.$w$ctraverse
  = \ (@ (f_sbWKx :: * -> *))
      (@ (g_sbWKy :: * -> *))
      (w_sbWKz :: Traversable f_sbWKx)
      (w1_sbWKA :: Traversable g_sbWKy)
      (@ (f1_sbWKB :: * -> *))
      (@ a_sbWKC)
      (@ b_sbWKD)
      (w2_sbWKE :: Applicative f1_sbWKB)
      (w3_sbWKF :: a_sbWKC -> f1_sbWKB b_sbWKD)
      (ww_sbWKJ :: f_sbWKx a_sbWKC)
      (ww1_sbWKK :: g_sbWKy a_sbWKC) ->
      liftA2
        @ f1_sbWKB
        w2_sbWKE
        @ (f_sbWKx b_sbWKD)
        @ (g_sbWKy b_sbWKD)
        @ ((:*:) f_sbWKx g_sbWKy b_sbWKD)
        (GHC.Generics.:*: @ * @ f_sbWKx @ g_sbWKy @ b_sbWKD)
        (traverse
           @ f_sbWKx
           w_sbWKz
           @ f1_sbWKB
           @ a_sbWKC
           @ b_sbWKD
           w2_sbWKE
           w3_sbWKF
           ww_sbWKJ)
        (traverse
           @ g_sbWKy
           w1_sbWKA
           @ f1_sbWKB
           @ a_sbWKC
           @ b_sbWKD
           w2_sbWKE
           w3_sbWKF
           ww1_sbWKK)

-- RHS size: {terms: 20, types: 46, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*:_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> (:*:) f g a -> f1 ((:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sbWKx :: * -> *))
                 (@ (g_sbWKy :: * -> *))
                 (w_sbWKz [Occ=Once] :: Traversable f_sbWKx)
                 (w1_sbWKA [Occ=Once] :: Traversable g_sbWKy)
                 (@ (f1_sbWKB :: * -> *))
                 (@ a_sbWKC)
                 (@ b_sbWKD)
                 (w2_sbWKE [Occ=Once] :: Applicative f1_sbWKB)
                 (w3_sbWKF [Occ=Once] :: a_sbWKC -> f1_sbWKB b_sbWKD)
                 (w4_sbWKG [Occ=Once!] :: (:*:) f_sbWKx g_sbWKy a_sbWKC) ->
                 case w4_sbWKG of { :*: ww1_sbWKJ [Occ=Once] ww2_sbWKK [Occ=Once] ->
                 Data.Traversable.$w$ctraverse
                   @ f_sbWKx
                   @ g_sbWKy
                   w_sbWKz
                   w1_sbWKA
                   @ f1_sbWKB
                   @ a_sbWKC
                   @ b_sbWKD
                   w2_sbWKE
                   w3_sbWKF
                   ww1_sbWKJ
                   ww2_sbWKK
                 }}]
Data.Traversable.$fTraversable:*:_$ctraverse
  = \ (@ (f_sbWKx :: * -> *))
      (@ (g_sbWKy :: * -> *))
      (w_sbWKz :: Traversable f_sbWKx)
      (w1_sbWKA :: Traversable g_sbWKy)
      (@ (f1_sbWKB :: * -> *))
      (@ a_sbWKC)
      (@ b_sbWKD)
      (w2_sbWKE :: Applicative f1_sbWKB)
      (w3_sbWKF :: a_sbWKC -> f1_sbWKB b_sbWKD)
      (w4_sbWKG :: (:*:) f_sbWKx g_sbWKy a_sbWKC) ->
      case w4_sbWKG of { :*: ww1_sbWKJ ww2_sbWKK ->
      Data.Traversable.$w$ctraverse
        @ f_sbWKx
        @ g_sbWKy
        w_sbWKz
        w1_sbWKA
        @ f1_sbWKB
        @ a_sbWKC
        @ b_sbWKD
        w2_sbWKE
        w3_sbWKF
        ww1_sbWKJ
        ww2_sbWKK
      }

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Foldable (f :*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVCk :: * -> *))
                 (@ (g_abVCl :: * -> *))
                 ($dTraversable_abVCm [Occ=Once] :: Traversable f_abVCk)
                 ($dTraversable1_abVCn [Occ=Once] :: Traversable g_abVCl) ->
                 Data.Foldable.$fFoldable:*:
                   @ f_abVCk
                   @ g_abVCl
                   (Data.Traversable.$p2Traversable @ f_abVCk $dTraversable_abVCm)
                   (Data.Traversable.$p2Traversable @ g_abVCl $dTraversable1_abVCn)}]
Data.Traversable.$fTraversable:*:_$cp2Traversable
  = \ (@ (f_abVCk :: * -> *))
      (@ (g_abVCl :: * -> *))
      ($dTraversable_abVCm :: Traversable f_abVCk)
      ($dTraversable1_abVCn :: Traversable g_abVCl) ->
      Data.Foldable.$fFoldable:*:
        @ f_abVCk
        @ g_abVCl
        (Data.Traversable.$p2Traversable @ f_abVCk $dTraversable_abVCm)
        (Data.Traversable.$p2Traversable @ g_abVCl $dTraversable1_abVCn)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Functor (f :*: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVCk :: * -> *))
                 (@ (g_abVCl :: * -> *))
                 ($dTraversable_abVCm [Occ=Once] :: Traversable f_abVCk)
                 ($dTraversable1_abVCn [Occ=Once] :: Traversable g_abVCl) ->
                 GHC.Generics.$fFunctor:*:
                   @ f_abVCk
                   @ g_abVCl
                   (Data.Traversable.$p1Traversable @ f_abVCk $dTraversable_abVCm)
                   (Data.Traversable.$p1Traversable @ g_abVCl $dTraversable1_abVCn)}]
Data.Traversable.$fTraversable:*:_$cp1Traversable
  = \ (@ (f_abVCk :: * -> *))
      (@ (g_abVCl :: * -> *))
      ($dTraversable_abVCm :: Traversable f_abVCk)
      ($dTraversable1_abVCn :: Traversable g_abVCl) ->
      GHC.Generics.$fFunctor:*:
        @ f_abVCk
        @ g_abVCl
        (Data.Traversable.$p1Traversable @ f_abVCk $dTraversable_abVCm)
        (Data.Traversable.$p1Traversable @ g_abVCl $dTraversable1_abVCn)

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.:1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_abVB0 :: * -> *))
                 (@ (g_abVB1 :: * -> *))
                 (@ b_abVBh)
                 (b1_abVnU [Occ=Once] :: f_abVB0 (g_abVB1 b_abVBh)) ->
                 b1_abVnU}]
Data.Traversable.$fTraversable:.:1
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      (@ b_abVBh)
      (b1_abVnU :: f_abVB0 (g_abVB1 b_abVBh)) ->
      b1_abVnU

-- RHS size: {terms: 22, types: 59, coercions: 21, joins: 0/0}
Data.Traversable.$fTraversable:.:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a b.
     Applicative f1 =>
     (a -> f1 b) -> (:.:) f g a -> f1 ((:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0] 150 0}]
Data.Traversable.$fTraversable:.:_$ctraverse
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1)
      (@ (f1_abVBf :: * -> *))
      (@ a_abVBg)
      (@ b_abVBh)
      ($dApplicative_abVBj :: Applicative f1_abVBf)
      (eta_B2 :: a_abVBg -> f1_abVBf b_abVBh)
      (eta1_B1 :: (:.:) f_abVB0 g_abVB1 a_abVBg) ->
      fmap
        @ f1_abVBf
        (GHC.Base.$p1Applicative @ f1_abVBf $dApplicative_abVBj)
        @ (f_abVB0 (g_abVB1 b_abVBh))
        @ ((:.:) f_abVB0 g_abVB1 b_abVBh)
        ((Data.Traversable.$fTraversable:.:1 @ f_abVB0 @ g_abVB1 @ b_abVBh)
         `cast` (<f_abVB0 (g_abVB1 b_abVBh)>_R
                 ->_R Sym (GHC.Generics.N::.:[0]
                               <*>_N <*>_N <f_abVB0>_R <g_abVB1>_N <b_abVBh>_N)
                 :: (f_abVB0 (g_abVB1 b_abVBh) -> f_abVB0 (g_abVB1 b_abVBh) :: *)
                    ~R# (f_abVB0 (g_abVB1 b_abVBh)
                         -> (:.:) f_abVB0 g_abVB1 b_abVBh :: *)))
        (traverse
           @ f_abVB0
           $dTraversable_abVB2
           @ f1_abVBf
           @ (g_abVB1 a_abVBg)
           @ (g_abVB1 b_abVBh)
           $dApplicative_abVBj
           (traverse
              @ g_abVB1
              $dTraversable1_abVB3
              @ f1_abVBf
              @ a_abVBg
              @ b_abVBh
              $dApplicative_abVBj
              eta_B2)
           (eta1_B1
            `cast` (GHC.Generics.N::.:[0]
                        <*>_N <*>_N <f_abVB0>_R <g_abVB1>_N <a_abVBg>_N
                    :: ((:.:) f_abVB0 g_abVB1 a_abVBg :: *)
                       ~R# (f_abVB0 (g_abVB1 a_abVBg) :: *))))

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Foldable (f :.: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVB0 :: * -> *))
                 (@ (g_abVB1 :: * -> *))
                 ($dTraversable_abVB2 [Occ=Once] :: Traversable f_abVB0)
                 ($dTraversable1_abVB3 [Occ=Once] :: Traversable g_abVB1) ->
                 Data.Foldable.$fFoldable:.:
                   @ f_abVB0
                   @ g_abVB1
                   (Data.Traversable.$p2Traversable @ f_abVB0 $dTraversable_abVB2)
                   (Data.Traversable.$p2Traversable @ g_abVB1 $dTraversable1_abVB3)}]
Data.Traversable.$fTraversable:.:_$cp2Traversable
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1) ->
      Data.Foldable.$fFoldable:.:
        @ f_abVB0
        @ g_abVB1
        (Data.Traversable.$p2Traversable @ f_abVB0 $dTraversable_abVB2)
        (Data.Traversable.$p2Traversable @ g_abVB1 $dTraversable1_abVB3)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Functor (f :.: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),C(U)),A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVB0 :: * -> *))
                 (@ (g_abVB1 :: * -> *))
                 ($dTraversable_abVB2 [Occ=Once] :: Traversable f_abVB0)
                 ($dTraversable1_abVB3 [Occ=Once] :: Traversable g_abVB1) ->
                 GHC.Generics.$fFunctor:.:
                   @ f_abVB0
                   @ g_abVB1
                   (Data.Traversable.$p1Traversable @ f_abVB0 $dTraversable_abVB2)
                   (Data.Traversable.$p1Traversable @ g_abVB1 $dTraversable1_abVB3)}]
Data.Traversable.$fTraversable:.:_$cp1Traversable
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1) ->
      GHC.Generics.$fFunctor:.:
        @ f_abVB0
        @ g_abVB1
        (Data.Traversable.$p1Traversable @ f_abVB0 $dTraversable_abVB2)
        (Data.Traversable.$p1Traversable @ g_abVB1 $dTraversable1_abVB3)

-- RHS size: {terms: 13, types: 34, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec4_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b)
     -> URec (GHC.Ptr.Ptr ()) a -> f (URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVA8 :: * -> *))
                 (@ a_abVA9)
                 (@ b_abVAa)
                 ($dApplicative_abVAc [Occ=Once] :: Applicative f_abVA8)
                 _ [Occ=Dead]
                 (ds_dbW70 [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_abVA9) ->
                 case ds_dbW70
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_abVA9>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_abVA9 :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_abVA9 :: *))
                 of
                 { UAddr a1_abVnR [Occ=Once] ->
                 pure
                   @ f_abVA8
                   $dApplicative_abVAc
                   @ (URec (GHC.Ptr.Ptr ()) b_abVAa)
                   ((GHC.Generics.UAddr @ * @ b_abVAa a1_abVnR)
                    `cast` (Sym (GHC.Generics.D:R:UReckPtrp0[0] <*>_N) <b_abVAa>_N
                            :: (GHC.Generics.R:UReckPtrp * b_abVAa :: *)
                               ~R# (URec (GHC.Ptr.Ptr ()) b_abVAa :: *)))
                 }}]
Data.Traversable.$fTraversableURec4_$ctraverse
  = \ (@ (f_abVA8 :: * -> *))
      (@ a_abVA9)
      (@ b_abVAa)
      ($dApplicative_abVAc :: Applicative f_abVA8)
      _ [Occ=Dead]
      (ds_dbW70 :: URec (GHC.Ptr.Ptr ()) a_abVA9) ->
      case ds_dbW70
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_abVA9>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_abVA9 :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_abVA9 :: *))
      of
      { UAddr a1_abVnR ->
      pure
        @ f_abVA8
        $dApplicative_abVAc
        @ (URec (GHC.Ptr.Ptr ()) b_abVAa)
        ((GHC.Generics.UAddr @ * @ b_abVAa a1_abVnR)
         `cast` (Sym (GHC.Generics.D:R:UReckPtrp0[0] <*>_N) <b_abVAa>_N
                 :: (GHC.Generics.R:UReckPtrp * b_abVAa :: *)
                    ~R# (URec (GHC.Ptr.Ptr ()) b_abVAa :: *)))
      }

-- RHS size: {terms: 13, types: 32, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec3_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> URec GHC.Types.Char a -> f (URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVz5 :: * -> *))
                 (@ a_abVz6)
                 (@ b_abVz7)
                 ($dApplicative_abVz9 [Occ=Once] :: Applicative f_abVz5)
                 _ [Occ=Dead]
                 (ds_dbW6X [Occ=Once] :: URec GHC.Types.Char a_abVz6) ->
                 case ds_dbW6X
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_abVz6>_N
                              :: (URec GHC.Types.Char a_abVz6 :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_abVz6 :: *))
                 of
                 { UChar a1_abVnP [Occ=Once] ->
                 pure
                   @ f_abVz5
                   $dApplicative_abVz9
                   @ (URec GHC.Types.Char b_abVz7)
                   ((GHC.Generics.UChar @ * @ b_abVz7 a1_abVnP)
                    `cast` (Sym (GHC.Generics.D:R:UReckCharp0[0] <*>_N) <b_abVz7>_N
                            :: (GHC.Generics.R:UReckCharp * b_abVz7 :: *)
                               ~R# (URec GHC.Types.Char b_abVz7 :: *)))
                 }}]
Data.Traversable.$fTraversableURec3_$ctraverse
  = \ (@ (f_abVz5 :: * -> *))
      (@ a_abVz6)
      (@ b_abVz7)
      ($dApplicative_abVz9 :: Applicative f_abVz5)
      _ [Occ=Dead]
      (ds_dbW6X :: URec GHC.Types.Char a_abVz6) ->
      case ds_dbW6X
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_abVz6>_N
                   :: (URec GHC.Types.Char a_abVz6 :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_abVz6 :: *))
      of
      { UChar a1_abVnP ->
      pure
        @ f_abVz5
        $dApplicative_abVz9
        @ (URec GHC.Types.Char b_abVz7)
        ((GHC.Generics.UChar @ * @ b_abVz7 a1_abVnP)
         `cast` (Sym (GHC.Generics.D:R:UReckCharp0[0] <*>_N) <b_abVz7>_N
                 :: (GHC.Generics.R:UReckCharp * b_abVz7 :: *)
                    ~R# (URec GHC.Types.Char b_abVz7 :: *)))
      }

-- RHS size: {terms: 13, types: 32, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec2_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b)
     -> URec GHC.Types.Double a -> f (URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVy2 :: * -> *))
                 (@ a_abVy3)
                 (@ b_abVy4)
                 ($dApplicative_abVy6 [Occ=Once] :: Applicative f_abVy2)
                 _ [Occ=Dead]
                 (ds_dbW6U [Occ=Once] :: URec GHC.Types.Double a_abVy3) ->
                 case ds_dbW6U
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_abVy3>_N
                              :: (URec GHC.Types.Double a_abVy3 :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_abVy3 :: *))
                 of
                 { UDouble a1_abVnN [Occ=Once] ->
                 pure
                   @ f_abVy2
                   $dApplicative_abVy6
                   @ (URec GHC.Types.Double b_abVy4)
                   ((GHC.Generics.UDouble @ * @ b_abVy4 a1_abVnN)
                    `cast` (Sym (GHC.Generics.D:R:UReckDoublep0[0] <*>_N) <b_abVy4>_N
                            :: (GHC.Generics.R:UReckDoublep * b_abVy4 :: *)
                               ~R# (URec GHC.Types.Double b_abVy4 :: *)))
                 }}]
Data.Traversable.$fTraversableURec2_$ctraverse
  = \ (@ (f_abVy2 :: * -> *))
      (@ a_abVy3)
      (@ b_abVy4)
      ($dApplicative_abVy6 :: Applicative f_abVy2)
      _ [Occ=Dead]
      (ds_dbW6U :: URec GHC.Types.Double a_abVy3) ->
      case ds_dbW6U
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_abVy3>_N
                   :: (URec GHC.Types.Double a_abVy3 :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_abVy3 :: *))
      of
      { UDouble a1_abVnN ->
      pure
        @ f_abVy2
        $dApplicative_abVy6
        @ (URec GHC.Types.Double b_abVy4)
        ((GHC.Generics.UDouble @ * @ b_abVy4 a1_abVnN)
         `cast` (Sym (GHC.Generics.D:R:UReckDoublep0[0] <*>_N) <b_abVy4>_N
                 :: (GHC.Generics.R:UReckDoublep * b_abVy4 :: *)
                    ~R# (URec GHC.Types.Double b_abVy4 :: *)))
      }

-- RHS size: {terms: 13, types: 32, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec1_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> URec GHC.Types.Float a -> f (URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVwZ :: * -> *))
                 (@ a_abVx0)
                 (@ b_abVx1)
                 ($dApplicative_abVx3 [Occ=Once] :: Applicative f_abVwZ)
                 _ [Occ=Dead]
                 (ds_dbW6R [Occ=Once] :: URec GHC.Types.Float a_abVx0) ->
                 case ds_dbW6R
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_abVx0>_N
                              :: (URec GHC.Types.Float a_abVx0 :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_abVx0 :: *))
                 of
                 { UFloat a1_abVnL [Occ=Once] ->
                 pure
                   @ f_abVwZ
                   $dApplicative_abVx3
                   @ (URec GHC.Types.Float b_abVx1)
                   ((GHC.Generics.UFloat @ * @ b_abVx1 a1_abVnL)
                    `cast` (Sym (GHC.Generics.D:R:UReckFloatp0[0] <*>_N) <b_abVx1>_N
                            :: (GHC.Generics.R:UReckFloatp * b_abVx1 :: *)
                               ~R# (URec GHC.Types.Float b_abVx1 :: *)))
                 }}]
Data.Traversable.$fTraversableURec1_$ctraverse
  = \ (@ (f_abVwZ :: * -> *))
      (@ a_abVx0)
      (@ b_abVx1)
      ($dApplicative_abVx3 :: Applicative f_abVwZ)
      _ [Occ=Dead]
      (ds_dbW6R :: URec GHC.Types.Float a_abVx0) ->
      case ds_dbW6R
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_abVx0>_N
                   :: (URec GHC.Types.Float a_abVx0 :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_abVx0 :: *))
      of
      { UFloat a1_abVnL ->
      pure
        @ f_abVwZ
        $dApplicative_abVx3
        @ (URec GHC.Types.Float b_abVx1)
        ((GHC.Generics.UFloat @ * @ b_abVx1 a1_abVnL)
         `cast` (Sym (GHC.Generics.D:R:UReckFloatp0[0] <*>_N) <b_abVx1>_N
                 :: (GHC.Generics.R:UReckFloatp * b_abVx1 :: *)
                    ~R# (URec GHC.Types.Float b_abVx1 :: *)))
      }

-- RHS size: {terms: 13, types: 32, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec0_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> URec GHC.Types.Int a -> f (URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVvW :: * -> *))
                 (@ a_abVvX)
                 (@ b_abVvY)
                 ($dApplicative_abVw0 [Occ=Once] :: Applicative f_abVvW)
                 _ [Occ=Dead]
                 (ds_dbW6O [Occ=Once] :: URec GHC.Types.Int a_abVvX) ->
                 case ds_dbW6O
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_abVvX>_N
                              :: (URec GHC.Types.Int a_abVvX :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_abVvX :: *))
                 of
                 { UInt a1_abVnJ [Occ=Once] ->
                 pure
                   @ f_abVvW
                   $dApplicative_abVw0
                   @ (URec GHC.Types.Int b_abVvY)
                   ((GHC.Generics.UInt @ * @ b_abVvY a1_abVnJ)
                    `cast` (Sym (GHC.Generics.D:R:UReckIntp0[0] <*>_N) <b_abVvY>_N
                            :: (GHC.Generics.R:UReckIntp * b_abVvY :: *)
                               ~R# (URec GHC.Types.Int b_abVvY :: *)))
                 }}]
Data.Traversable.$fTraversableURec0_$ctraverse
  = \ (@ (f_abVvW :: * -> *))
      (@ a_abVvX)
      (@ b_abVvY)
      ($dApplicative_abVw0 :: Applicative f_abVvW)
      _ [Occ=Dead]
      (ds_dbW6O :: URec GHC.Types.Int a_abVvX) ->
      case ds_dbW6O
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_abVvX>_N
                   :: (URec GHC.Types.Int a_abVvX :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_abVvX :: *))
      of
      { UInt a1_abVnJ ->
      pure
        @ f_abVvW
        $dApplicative_abVw0
        @ (URec GHC.Types.Int b_abVvY)
        ((GHC.Generics.UInt @ * @ b_abVvY a1_abVnJ)
         `cast` (Sym (GHC.Generics.D:R:UReckIntp0[0] <*>_N) <b_abVvY>_N
                 :: (GHC.Generics.R:UReckIntp * b_abVvY :: *)
                    ~R# (URec GHC.Types.Int b_abVvY :: *)))
      }

-- RHS size: {terms: 13, types: 32, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> URec GHC.Types.Word a -> f (URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVuT :: * -> *))
                 (@ a_abVuU)
                 (@ b_abVuV)
                 ($dApplicative_abVuX [Occ=Once] :: Applicative f_abVuT)
                 _ [Occ=Dead]
                 (ds_dbW6L [Occ=Once] :: URec GHC.Types.Word a_abVuU) ->
                 case ds_dbW6L
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_abVuU>_N
                              :: (URec GHC.Types.Word a_abVuU :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_abVuU :: *))
                 of
                 { UWord a1_abVnH [Occ=Once] ->
                 pure
                   @ f_abVuT
                   $dApplicative_abVuX
                   @ (URec GHC.Types.Word b_abVuV)
                   ((GHC.Generics.UWord @ * @ b_abVuV a1_abVnH)
                    `cast` (Sym (GHC.Generics.D:R:UReckWordp0[0] <*>_N) <b_abVuV>_N
                            :: (GHC.Generics.R:UReckWordp * b_abVuV :: *)
                               ~R# (URec GHC.Types.Word b_abVuV :: *)))
                 }}]
Data.Traversable.$fTraversableURec_$ctraverse
  = \ (@ (f_abVuT :: * -> *))
      (@ a_abVuU)
      (@ b_abVuV)
      ($dApplicative_abVuX :: Applicative f_abVuT)
      _ [Occ=Dead]
      (ds_dbW6L :: URec GHC.Types.Word a_abVuU) ->
      case ds_dbW6L
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_abVuU>_N
                   :: (URec GHC.Types.Word a_abVuU :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_abVuU :: *))
      of
      { UWord a1_abVnH ->
      pure
        @ f_abVuT
        $dApplicative_abVuX
        @ (URec GHC.Types.Word b_abVuV)
        ((GHC.Generics.UWord @ * @ b_abVuV a1_abVnH)
         `cast` (Sym (GHC.Generics.D:R:UReckWordp0[0] <*>_N) <b_abVuV>_N
                 :: (GHC.Generics.R:UReckWordp * b_abVuV :: *)
                    ~R# (URec GHC.Types.Word b_abVuV :: *)))
      }

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
Data.Traversable.$dmsequence [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Traversable t =>
     forall (m :: * -> *) a. Monad m => t (m a) -> m (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_abVfw :: * -> *))
                 ($dTraversable_abVtJ [Occ=Once] :: Traversable t_abVfw)
                 (@ (m_abVux :: * -> *))
                 (@ a_abVuy)
                 ($dMonad_abVuA [Occ=Once] :: Monad m_abVux) ->
                 sequenceA
                   @ t_abVfw
                   $dTraversable_abVtJ
                   @ m_abVux
                   @ a_abVuy
                   (GHC.Base.$p1Monad @ m_abVux $dMonad_abVuA)}]
Data.Traversable.$dmsequence
  = \ (@ (t_abVfw :: * -> *))
      ($dTraversable_abVtJ :: Traversable t_abVfw)
      (@ (m_abVux :: * -> *))
      (@ a_abVuy)
      ($dMonad_abVuA :: Monad m_abVux) ->
      sequenceA
        @ t_abVfw
        $dTraversable_abVtJ
        @ m_abVux
        @ a_abVuy
        (GHC.Base.$p1Monad @ m_abVux $dMonad_abVuA)

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/0}
Data.Traversable.$dmmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Traversable t =>
     forall (m :: * -> *) a b. Monad m => (a -> m b) -> t a -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_abVfw :: * -> *))
                 ($dTraversable_abVtJ [Occ=Once] :: Traversable t_abVfw)
                 (@ (m_abVuj :: * -> *))
                 (@ a_abVuk)
                 (@ b_abVul)
                 ($dMonad_abVun [Occ=Once] :: Monad m_abVuj) ->
                 traverse
                   @ t_abVfw
                   $dTraversable_abVtJ
                   @ m_abVuj
                   @ a_abVuk
                   @ b_abVul
                   (GHC.Base.$p1Monad @ m_abVuj $dMonad_abVun)}]
Data.Traversable.$dmmapM
  = \ (@ (t_abVfw :: * -> *))
      ($dTraversable_abVtJ :: Traversable t_abVfw)
      (@ (m_abVuj :: * -> *))
      (@ a_abVuk)
      (@ b_abVul)
      ($dMonad_abVun :: Monad m_abVuj) ->
      traverse
        @ t_abVfw
        $dTraversable_abVtJ
        @ m_abVuj
        @ a_abVuk
        @ b_abVul
        (GHC.Base.$p1Monad @ m_abVuj $dMonad_abVun)

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Traversable.$dmsequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Traversable t =>
     forall (f :: * -> *) a. Applicative f => t (f a) -> f (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),1*U(A,A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_abVfw :: * -> *))
                 ($dTraversable_abVtJ [Occ=Once] :: Traversable t_abVfw)
                 (@ (f_abVu5 :: * -> *))
                 (@ a_abVu6)
                 ($dApplicative_abVu8 [Occ=Once] :: Applicative f_abVu5) ->
                 traverse
                   @ t_abVfw
                   $dTraversable_abVtJ
                   @ f_abVu5
                   @ (f_abVu5 a_abVu6)
                   @ a_abVu6
                   $dApplicative_abVu8
                   (id @ (f_abVu5 a_abVu6))}]
Data.Traversable.$dmsequenceA
  = \ (@ (t_abVfw :: * -> *))
      ($dTraversable_abVtJ :: Traversable t_abVfw)
      (@ (f_abVu5 :: * -> *))
      (@ a_abVu6)
      ($dApplicative_abVu8 :: Applicative f_abVu5) ->
      traverse
        @ t_abVfw
        $dTraversable_abVtJ
        @ f_abVu5
        @ (f_abVu5 a_abVu6)
        @ a_abVu6
        $dApplicative_abVu8
        (id @ (f_abVu5 a_abVu6))

-- RHS size: {terms: 11, types: 29, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     URec GHC.Types.Word (f a) -> f (URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVva :: * -> *))
                 (@ a_abVvb)
                 ($dApplicative_abVvd [Occ=Once] :: Applicative f_abVva)
                 (ds_dbW6L [Occ=Once] :: URec GHC.Types.Word (f_abVva a_abVvb)) ->
                 case ds_dbW6L
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <f_abVva a_abVvb>_N
                              :: (URec GHC.Types.Word (f_abVva a_abVvb) :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * (f_abVva a_abVvb) :: *))
                 of
                 { UWord a1_abVnH [Occ=Once] ->
                 pure
                   @ f_abVva
                   $dApplicative_abVvd
                   @ (URec GHC.Types.Word a_abVvb)
                   (GHC.Generics.$WUWord @ * @ a_abVvb a1_abVnH)
                 }}]
Data.Traversable.$fTraversableURec_$csequenceA
  = \ (@ (f_abVva :: * -> *))
      (@ a_abVvb)
      ($dApplicative_abVvd :: Applicative f_abVva)
      (ds_dbW6L :: URec GHC.Types.Word (f_abVva a_abVvb)) ->
      case ds_dbW6L
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <f_abVva a_abVvb>_N
                   :: (URec GHC.Types.Word (f_abVva a_abVvb) :: *)
                      ~R# (GHC.Generics.R:UReckWordp * (f_abVva a_abVvb) :: *))
      of
      { UWord a1_abVnH ->
      pure
        @ f_abVva
        $dApplicative_abVvd
        @ (URec GHC.Types.Word a_abVvb)
        ((GHC.Generics.UWord @ * @ a_abVvb a1_abVnH)
         `cast` (Sym (GHC.Generics.D:R:UReckWordp0[0] <*>_N) <a_abVvb>_N
                 :: (GHC.Generics.R:UReckWordp * a_abVvb :: *)
                    ~R# (URec GHC.Types.Word a_abVvb :: *)))
      }

-- RHS size: {terms: 14, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> URec GHC.Types.Word a -> m (URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVvm :: * -> *))
                 (@ a_abVvn)
                 (@ b_abVvo)
                 ($dMonad_abVvq [Occ=OnceL] :: Monad m_abVvm) ->
                 let {
                   $dApplicative_abVuX [Occ=OnceL] :: Applicative m_abVvm
                   [LclId]
                   $dApplicative_abVuX
                     = GHC.Base.$p1Monad @ m_abVvm $dMonad_abVvq } in
                 \ _ [Occ=Dead]
                   (ds_dbW6L [Occ=Once] :: URec GHC.Types.Word a_abVvn) ->
                   case ds_dbW6L
                        `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_abVvn>_N
                                :: (URec GHC.Types.Word a_abVvn :: *)
                                   ~R# (GHC.Generics.R:UReckWordp * a_abVvn :: *))
                   of
                   { UWord a1_abVnH [Occ=Once] ->
                   pure
                     @ m_abVvm
                     $dApplicative_abVuX
                     @ (URec GHC.Types.Word b_abVvo)
                     (GHC.Generics.$WUWord @ * @ b_abVvo a1_abVnH)
                   }}]
Data.Traversable.$fTraversableURec_$cmapM
  = \ (@ (m_abVvm :: * -> *))
      (@ a_abVvn)
      (@ b_abVvo)
      ($dMonad_abVvq :: Monad m_abVvm)
      _ [Occ=Dead]
      (eta1_B1 :: URec GHC.Types.Word a_abVvn) ->
      case eta1_B1
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_abVvn>_N
                   :: (URec GHC.Types.Word a_abVvn :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_abVvn :: *))
      of
      { UWord a1_abVnH ->
      pure
        @ m_abVvm
        (GHC.Base.$p1Monad @ m_abVvm $dMonad_abVvq)
        @ (URec GHC.Types.Word b_abVvo)
        ((GHC.Generics.UWord @ * @ b_abVvo a1_abVnH)
         `cast` (Sym (GHC.Generics.D:R:UReckWordp0[0] <*>_N) <b_abVvo>_N
                 :: (GHC.Generics.R:UReckWordp * b_abVvo :: *)
                    ~R# (URec GHC.Types.Word b_abVvo :: *)))
      }

-- RHS size: {terms: 12, types: 30, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     URec GHC.Types.Word (m a) -> m (URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVvA :: * -> *))
                 (@ a_abVvB)
                 ($dMonad_abVvD [Occ=OnceL] :: Monad m_abVvA) ->
                 let {
                   $dApplicative_abVvd [Occ=OnceL] :: Applicative m_abVvA
                   [LclId]
                   $dApplicative_abVvd
                     = GHC.Base.$p1Monad @ m_abVvA $dMonad_abVvD } in
                 \ (ds_dbW6L [Occ=Once] :: URec GHC.Types.Word (m_abVvA a_abVvB)) ->
                   case ds_dbW6L
                        `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <m_abVvA a_abVvB>_N
                                :: (URec GHC.Types.Word (m_abVvA a_abVvB) :: *)
                                   ~R# (GHC.Generics.R:UReckWordp * (m_abVvA a_abVvB) :: *))
                   of
                   { UWord a1_abVnH [Occ=Once] ->
                   pure
                     @ m_abVvA
                     $dApplicative_abVvd
                     @ (URec GHC.Types.Word a_abVvB)
                     (GHC.Generics.$WUWord @ * @ a_abVvB a1_abVnH)
                   }}]
Data.Traversable.$fTraversableURec_$csequence
  = \ (@ (m_abVvA :: * -> *))
      (@ a_abVvB)
      ($dMonad_abVvD :: Monad m_abVvA)
      (eta_B1 :: URec GHC.Types.Word (m_abVvA a_abVvB)) ->
      case eta_B1
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <m_abVvA a_abVvB>_N
                   :: (URec GHC.Types.Word (m_abVvA a_abVvB) :: *)
                      ~R# (GHC.Generics.R:UReckWordp * (m_abVvA a_abVvB) :: *))
      of
      { UWord a1_abVnH ->
      pure
        @ m_abVvA
        (GHC.Base.$p1Monad @ m_abVvA $dMonad_abVvD)
        @ (URec GHC.Types.Word a_abVvB)
        ((GHC.Generics.UWord @ * @ a_abVvB a1_abVnH)
         `cast` (Sym (GHC.Generics.D:R:UReckWordp0[0] <*>_N) <a_abVvB>_N
                 :: (GHC.Generics.R:UReckWordp * a_abVvB :: *)
                    ~R# (URec GHC.Types.Word a_abVvB :: *)))
      }

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable (URec GHC.Types.Word)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: URec GHC.Types.Word
                                      GHC.Generics.$fFunctorURec
                                      Data.Foldable.$fFoldableURec
                                      Data.Traversable.$fTraversableURec_$ctraverse
                                      Data.Traversable.$fTraversableURec_$csequenceA
                                      Data.Traversable.$fTraversableURec_$cmapM
                                      Data.Traversable.$fTraversableURec_$csequence]
Data.Traversable.$fTraversableURec
  = Data.Traversable.C:Traversable
      @ (URec GHC.Types.Word)
      GHC.Generics.$fFunctorURec
      Data.Foldable.$fFoldableURec
      Data.Traversable.$fTraversableURec_$ctraverse
      Data.Traversable.$fTraversableURec_$csequenceA
      Data.Traversable.$fTraversableURec_$cmapM
      Data.Traversable.$fTraversableURec_$csequence

-- RHS size: {terms: 11, types: 29, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec0_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     URec GHC.Types.Int (f a) -> f (URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVwd :: * -> *))
                 (@ a_abVwe)
                 ($dApplicative_abVwg [Occ=Once] :: Applicative f_abVwd)
                 (ds_dbW6O [Occ=Once] :: URec GHC.Types.Int (f_abVwd a_abVwe)) ->
                 case ds_dbW6O
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <f_abVwd a_abVwe>_N
                              :: (URec GHC.Types.Int (f_abVwd a_abVwe) :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * (f_abVwd a_abVwe) :: *))
                 of
                 { UInt a1_abVnJ [Occ=Once] ->
                 pure
                   @ f_abVwd
                   $dApplicative_abVwg
                   @ (URec GHC.Types.Int a_abVwe)
                   (GHC.Generics.$WUInt @ * @ a_abVwe a1_abVnJ)
                 }}]
Data.Traversable.$fTraversableURec0_$csequenceA
  = \ (@ (f_abVwd :: * -> *))
      (@ a_abVwe)
      ($dApplicative_abVwg :: Applicative f_abVwd)
      (ds_dbW6O :: URec GHC.Types.Int (f_abVwd a_abVwe)) ->
      case ds_dbW6O
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <f_abVwd a_abVwe>_N
                   :: (URec GHC.Types.Int (f_abVwd a_abVwe) :: *)
                      ~R# (GHC.Generics.R:UReckIntp * (f_abVwd a_abVwe) :: *))
      of
      { UInt a1_abVnJ ->
      pure
        @ f_abVwd
        $dApplicative_abVwg
        @ (URec GHC.Types.Int a_abVwe)
        ((GHC.Generics.UInt @ * @ a_abVwe a1_abVnJ)
         `cast` (Sym (GHC.Generics.D:R:UReckIntp0[0] <*>_N) <a_abVwe>_N
                 :: (GHC.Generics.R:UReckIntp * a_abVwe :: *)
                    ~R# (URec GHC.Types.Int a_abVwe :: *)))
      }

-- RHS size: {terms: 14, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec0_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> URec GHC.Types.Int a -> m (URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVwp :: * -> *))
                 (@ a_abVwq)
                 (@ b_abVwr)
                 ($dMonad_abVwt [Occ=OnceL] :: Monad m_abVwp) ->
                 let {
                   $dApplicative_abVw0 [Occ=OnceL] :: Applicative m_abVwp
                   [LclId]
                   $dApplicative_abVw0
                     = GHC.Base.$p1Monad @ m_abVwp $dMonad_abVwt } in
                 \ _ [Occ=Dead]
                   (ds_dbW6O [Occ=Once] :: URec GHC.Types.Int a_abVwq) ->
                   case ds_dbW6O
                        `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_abVwq>_N
                                :: (URec GHC.Types.Int a_abVwq :: *)
                                   ~R# (GHC.Generics.R:UReckIntp * a_abVwq :: *))
                   of
                   { UInt a1_abVnJ [Occ=Once] ->
                   pure
                     @ m_abVwp
                     $dApplicative_abVw0
                     @ (URec GHC.Types.Int b_abVwr)
                     (GHC.Generics.$WUInt @ * @ b_abVwr a1_abVnJ)
                   }}]
Data.Traversable.$fTraversableURec0_$cmapM
  = \ (@ (m_abVwp :: * -> *))
      (@ a_abVwq)
      (@ b_abVwr)
      ($dMonad_abVwt :: Monad m_abVwp)
      _ [Occ=Dead]
      (eta1_B1 :: URec GHC.Types.Int a_abVwq) ->
      case eta1_B1
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_abVwq>_N
                   :: (URec GHC.Types.Int a_abVwq :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_abVwq :: *))
      of
      { UInt a1_abVnJ ->
      pure
        @ m_abVwp
        (GHC.Base.$p1Monad @ m_abVwp $dMonad_abVwt)
        @ (URec GHC.Types.Int b_abVwr)
        ((GHC.Generics.UInt @ * @ b_abVwr a1_abVnJ)
         `cast` (Sym (GHC.Generics.D:R:UReckIntp0[0] <*>_N) <b_abVwr>_N
                 :: (GHC.Generics.R:UReckIntp * b_abVwr :: *)
                    ~R# (URec GHC.Types.Int b_abVwr :: *)))
      }

-- RHS size: {terms: 12, types: 30, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec0_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     URec GHC.Types.Int (m a) -> m (URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVwD :: * -> *))
                 (@ a_abVwE)
                 ($dMonad_abVwG [Occ=OnceL] :: Monad m_abVwD) ->
                 let {
                   $dApplicative_abVwg [Occ=OnceL] :: Applicative m_abVwD
                   [LclId]
                   $dApplicative_abVwg
                     = GHC.Base.$p1Monad @ m_abVwD $dMonad_abVwG } in
                 \ (ds_dbW6O [Occ=Once] :: URec GHC.Types.Int (m_abVwD a_abVwE)) ->
                   case ds_dbW6O
                        `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <m_abVwD a_abVwE>_N
                                :: (URec GHC.Types.Int (m_abVwD a_abVwE) :: *)
                                   ~R# (GHC.Generics.R:UReckIntp * (m_abVwD a_abVwE) :: *))
                   of
                   { UInt a1_abVnJ [Occ=Once] ->
                   pure
                     @ m_abVwD
                     $dApplicative_abVwg
                     @ (URec GHC.Types.Int a_abVwE)
                     (GHC.Generics.$WUInt @ * @ a_abVwE a1_abVnJ)
                   }}]
Data.Traversable.$fTraversableURec0_$csequence
  = \ (@ (m_abVwD :: * -> *))
      (@ a_abVwE)
      ($dMonad_abVwG :: Monad m_abVwD)
      (eta_B1 :: URec GHC.Types.Int (m_abVwD a_abVwE)) ->
      case eta_B1
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <m_abVwD a_abVwE>_N
                   :: (URec GHC.Types.Int (m_abVwD a_abVwE) :: *)
                      ~R# (GHC.Generics.R:UReckIntp * (m_abVwD a_abVwE) :: *))
      of
      { UInt a1_abVnJ ->
      pure
        @ m_abVwD
        (GHC.Base.$p1Monad @ m_abVwD $dMonad_abVwG)
        @ (URec GHC.Types.Int a_abVwE)
        ((GHC.Generics.UInt @ * @ a_abVwE a1_abVnJ)
         `cast` (Sym (GHC.Generics.D:R:UReckIntp0[0] <*>_N) <a_abVwE>_N
                 :: (GHC.Generics.R:UReckIntp * a_abVwE :: *)
                    ~R# (URec GHC.Types.Int a_abVwE :: *)))
      }

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable (URec GHC.Types.Int)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: URec GHC.Types.Int
                                      GHC.Generics.$fFunctorURec0
                                      Data.Foldable.$fFoldableURec0
                                      Data.Traversable.$fTraversableURec0_$ctraverse
                                      Data.Traversable.$fTraversableURec0_$csequenceA
                                      Data.Traversable.$fTraversableURec0_$cmapM
                                      Data.Traversable.$fTraversableURec0_$csequence]
Data.Traversable.$fTraversableURec0
  = Data.Traversable.C:Traversable
      @ (URec GHC.Types.Int)
      GHC.Generics.$fFunctorURec0
      Data.Foldable.$fFoldableURec0
      Data.Traversable.$fTraversableURec0_$ctraverse
      Data.Traversable.$fTraversableURec0_$csequenceA
      Data.Traversable.$fTraversableURec0_$cmapM
      Data.Traversable.$fTraversableURec0_$csequence

-- RHS size: {terms: 11, types: 29, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     URec GHC.Types.Float (f a) -> f (URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVxg :: * -> *))
                 (@ a_abVxh)
                 ($dApplicative_abVxj [Occ=Once] :: Applicative f_abVxg)
                 (ds_dbW6R [Occ=Once] :: URec GHC.Types.Float (f_abVxg a_abVxh)) ->
                 case ds_dbW6R
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <f_abVxg a_abVxh>_N
                              :: (URec GHC.Types.Float (f_abVxg a_abVxh) :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * (f_abVxg a_abVxh) :: *))
                 of
                 { UFloat a1_abVnL [Occ=Once] ->
                 pure
                   @ f_abVxg
                   $dApplicative_abVxj
                   @ (URec GHC.Types.Float a_abVxh)
                   (GHC.Generics.$WUFloat @ * @ a_abVxh a1_abVnL)
                 }}]
Data.Traversable.$fTraversableURec1_$csequenceA
  = \ (@ (f_abVxg :: * -> *))
      (@ a_abVxh)
      ($dApplicative_abVxj :: Applicative f_abVxg)
      (ds_dbW6R :: URec GHC.Types.Float (f_abVxg a_abVxh)) ->
      case ds_dbW6R
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <f_abVxg a_abVxh>_N
                   :: (URec GHC.Types.Float (f_abVxg a_abVxh) :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * (f_abVxg a_abVxh) :: *))
      of
      { UFloat a1_abVnL ->
      pure
        @ f_abVxg
        $dApplicative_abVxj
        @ (URec GHC.Types.Float a_abVxh)
        ((GHC.Generics.UFloat @ * @ a_abVxh a1_abVnL)
         `cast` (Sym (GHC.Generics.D:R:UReckFloatp0[0] <*>_N) <a_abVxh>_N
                 :: (GHC.Generics.R:UReckFloatp * a_abVxh :: *)
                    ~R# (URec GHC.Types.Float a_abVxh :: *)))
      }

-- RHS size: {terms: 14, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> URec GHC.Types.Float a -> m (URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVxs :: * -> *))
                 (@ a_abVxt)
                 (@ b_abVxu)
                 ($dMonad_abVxw [Occ=OnceL] :: Monad m_abVxs) ->
                 let {
                   $dApplicative_abVx3 [Occ=OnceL] :: Applicative m_abVxs
                   [LclId]
                   $dApplicative_abVx3
                     = GHC.Base.$p1Monad @ m_abVxs $dMonad_abVxw } in
                 \ _ [Occ=Dead]
                   (ds_dbW6R [Occ=Once] :: URec GHC.Types.Float a_abVxt) ->
                   case ds_dbW6R
                        `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_abVxt>_N
                                :: (URec GHC.Types.Float a_abVxt :: *)
                                   ~R# (GHC.Generics.R:UReckFloatp * a_abVxt :: *))
                   of
                   { UFloat a1_abVnL [Occ=Once] ->
                   pure
                     @ m_abVxs
                     $dApplicative_abVx3
                     @ (URec GHC.Types.Float b_abVxu)
                     (GHC.Generics.$WUFloat @ * @ b_abVxu a1_abVnL)
                   }}]
Data.Traversable.$fTraversableURec1_$cmapM
  = \ (@ (m_abVxs :: * -> *))
      (@ a_abVxt)
      (@ b_abVxu)
      ($dMonad_abVxw :: Monad m_abVxs)
      _ [Occ=Dead]
      (eta1_B1 :: URec GHC.Types.Float a_abVxt) ->
      case eta1_B1
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_abVxt>_N
                   :: (URec GHC.Types.Float a_abVxt :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_abVxt :: *))
      of
      { UFloat a1_abVnL ->
      pure
        @ m_abVxs
        (GHC.Base.$p1Monad @ m_abVxs $dMonad_abVxw)
        @ (URec GHC.Types.Float b_abVxu)
        ((GHC.Generics.UFloat @ * @ b_abVxu a1_abVnL)
         `cast` (Sym (GHC.Generics.D:R:UReckFloatp0[0] <*>_N) <b_abVxu>_N
                 :: (GHC.Generics.R:UReckFloatp * b_abVxu :: *)
                    ~R# (URec GHC.Types.Float b_abVxu :: *)))
      }

-- RHS size: {terms: 12, types: 30, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     URec GHC.Types.Float (m a) -> m (URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVxG :: * -> *))
                 (@ a_abVxH)
                 ($dMonad_abVxJ [Occ=OnceL] :: Monad m_abVxG) ->
                 let {
                   $dApplicative_abVxj [Occ=OnceL] :: Applicative m_abVxG
                   [LclId]
                   $dApplicative_abVxj
                     = GHC.Base.$p1Monad @ m_abVxG $dMonad_abVxJ } in
                 \ (ds_dbW6R [Occ=Once]
                      :: URec GHC.Types.Float (m_abVxG a_abVxH)) ->
                   case ds_dbW6R
                        `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <m_abVxG a_abVxH>_N
                                :: (URec GHC.Types.Float (m_abVxG a_abVxH) :: *)
                                   ~R# (GHC.Generics.R:UReckFloatp * (m_abVxG a_abVxH) :: *))
                   of
                   { UFloat a1_abVnL [Occ=Once] ->
                   pure
                     @ m_abVxG
                     $dApplicative_abVxj
                     @ (URec GHC.Types.Float a_abVxH)
                     (GHC.Generics.$WUFloat @ * @ a_abVxH a1_abVnL)
                   }}]
Data.Traversable.$fTraversableURec1_$csequence
  = \ (@ (m_abVxG :: * -> *))
      (@ a_abVxH)
      ($dMonad_abVxJ :: Monad m_abVxG)
      (eta_B1 :: URec GHC.Types.Float (m_abVxG a_abVxH)) ->
      case eta_B1
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <m_abVxG a_abVxH>_N
                   :: (URec GHC.Types.Float (m_abVxG a_abVxH) :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * (m_abVxG a_abVxH) :: *))
      of
      { UFloat a1_abVnL ->
      pure
        @ m_abVxG
        (GHC.Base.$p1Monad @ m_abVxG $dMonad_abVxJ)
        @ (URec GHC.Types.Float a_abVxH)
        ((GHC.Generics.UFloat @ * @ a_abVxH a1_abVnL)
         `cast` (Sym (GHC.Generics.D:R:UReckFloatp0[0] <*>_N) <a_abVxH>_N
                 :: (GHC.Generics.R:UReckFloatp * a_abVxH :: *)
                    ~R# (URec GHC.Types.Float a_abVxH :: *)))
      }

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable (URec GHC.Types.Float)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: URec GHC.Types.Float
                                      GHC.Generics.$fFunctorURec1
                                      Data.Foldable.$fFoldableURec1
                                      Data.Traversable.$fTraversableURec1_$ctraverse
                                      Data.Traversable.$fTraversableURec1_$csequenceA
                                      Data.Traversable.$fTraversableURec1_$cmapM
                                      Data.Traversable.$fTraversableURec1_$csequence]
Data.Traversable.$fTraversableURec1
  = Data.Traversable.C:Traversable
      @ (URec GHC.Types.Float)
      GHC.Generics.$fFunctorURec1
      Data.Foldable.$fFoldableURec1
      Data.Traversable.$fTraversableURec1_$ctraverse
      Data.Traversable.$fTraversableURec1_$csequenceA
      Data.Traversable.$fTraversableURec1_$cmapM
      Data.Traversable.$fTraversableURec1_$csequence

-- RHS size: {terms: 11, types: 29, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec2_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     URec GHC.Types.Double (f a) -> f (URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVyj :: * -> *))
                 (@ a_abVyk)
                 ($dApplicative_abVym [Occ=Once] :: Applicative f_abVyj)
                 (ds_dbW6U [Occ=Once] :: URec GHC.Types.Double (f_abVyj a_abVyk)) ->
                 case ds_dbW6U
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <f_abVyj a_abVyk>_N
                              :: (URec GHC.Types.Double (f_abVyj a_abVyk) :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * (f_abVyj a_abVyk) :: *))
                 of
                 { UDouble a1_abVnN [Occ=Once] ->
                 pure
                   @ f_abVyj
                   $dApplicative_abVym
                   @ (URec GHC.Types.Double a_abVyk)
                   (GHC.Generics.$WUDouble @ * @ a_abVyk a1_abVnN)
                 }}]
Data.Traversable.$fTraversableURec2_$csequenceA
  = \ (@ (f_abVyj :: * -> *))
      (@ a_abVyk)
      ($dApplicative_abVym :: Applicative f_abVyj)
      (ds_dbW6U :: URec GHC.Types.Double (f_abVyj a_abVyk)) ->
      case ds_dbW6U
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <f_abVyj a_abVyk>_N
                   :: (URec GHC.Types.Double (f_abVyj a_abVyk) :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * (f_abVyj a_abVyk) :: *))
      of
      { UDouble a1_abVnN ->
      pure
        @ f_abVyj
        $dApplicative_abVym
        @ (URec GHC.Types.Double a_abVyk)
        ((GHC.Generics.UDouble @ * @ a_abVyk a1_abVnN)
         `cast` (Sym (GHC.Generics.D:R:UReckDoublep0[0] <*>_N) <a_abVyk>_N
                 :: (GHC.Generics.R:UReckDoublep * a_abVyk :: *)
                    ~R# (URec GHC.Types.Double a_abVyk :: *)))
      }

-- RHS size: {terms: 14, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec2_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b)
     -> URec GHC.Types.Double a -> m (URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVyv :: * -> *))
                 (@ a_abVyw)
                 (@ b_abVyx)
                 ($dMonad_abVyz [Occ=OnceL] :: Monad m_abVyv) ->
                 let {
                   $dApplicative_abVy6 [Occ=OnceL] :: Applicative m_abVyv
                   [LclId]
                   $dApplicative_abVy6
                     = GHC.Base.$p1Monad @ m_abVyv $dMonad_abVyz } in
                 \ _ [Occ=Dead]
                   (ds_dbW6U [Occ=Once] :: URec GHC.Types.Double a_abVyw) ->
                   case ds_dbW6U
                        `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_abVyw>_N
                                :: (URec GHC.Types.Double a_abVyw :: *)
                                   ~R# (GHC.Generics.R:UReckDoublep * a_abVyw :: *))
                   of
                   { UDouble a1_abVnN [Occ=Once] ->
                   pure
                     @ m_abVyv
                     $dApplicative_abVy6
                     @ (URec GHC.Types.Double b_abVyx)
                     (GHC.Generics.$WUDouble @ * @ b_abVyx a1_abVnN)
                   }}]
Data.Traversable.$fTraversableURec2_$cmapM
  = \ (@ (m_abVyv :: * -> *))
      (@ a_abVyw)
      (@ b_abVyx)
      ($dMonad_abVyz :: Monad m_abVyv)
      _ [Occ=Dead]
      (eta1_B1 :: URec GHC.Types.Double a_abVyw) ->
      case eta1_B1
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_abVyw>_N
                   :: (URec GHC.Types.Double a_abVyw :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_abVyw :: *))
      of
      { UDouble a1_abVnN ->
      pure
        @ m_abVyv
        (GHC.Base.$p1Monad @ m_abVyv $dMonad_abVyz)
        @ (URec GHC.Types.Double b_abVyx)
        ((GHC.Generics.UDouble @ * @ b_abVyx a1_abVnN)
         `cast` (Sym (GHC.Generics.D:R:UReckDoublep0[0] <*>_N) <b_abVyx>_N
                 :: (GHC.Generics.R:UReckDoublep * b_abVyx :: *)
                    ~R# (URec GHC.Types.Double b_abVyx :: *)))
      }

-- RHS size: {terms: 12, types: 30, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec2_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     URec GHC.Types.Double (m a) -> m (URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVyJ :: * -> *))
                 (@ a_abVyK)
                 ($dMonad_abVyM [Occ=OnceL] :: Monad m_abVyJ) ->
                 let {
                   $dApplicative_abVym [Occ=OnceL] :: Applicative m_abVyJ
                   [LclId]
                   $dApplicative_abVym
                     = GHC.Base.$p1Monad @ m_abVyJ $dMonad_abVyM } in
                 \ (ds_dbW6U [Occ=Once]
                      :: URec GHC.Types.Double (m_abVyJ a_abVyK)) ->
                   case ds_dbW6U
                        `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <m_abVyJ a_abVyK>_N
                                :: (URec GHC.Types.Double (m_abVyJ a_abVyK) :: *)
                                   ~R# (GHC.Generics.R:UReckDoublep * (m_abVyJ a_abVyK) :: *))
                   of
                   { UDouble a1_abVnN [Occ=Once] ->
                   pure
                     @ m_abVyJ
                     $dApplicative_abVym
                     @ (URec GHC.Types.Double a_abVyK)
                     (GHC.Generics.$WUDouble @ * @ a_abVyK a1_abVnN)
                   }}]
Data.Traversable.$fTraversableURec2_$csequence
  = \ (@ (m_abVyJ :: * -> *))
      (@ a_abVyK)
      ($dMonad_abVyM :: Monad m_abVyJ)
      (eta_B1 :: URec GHC.Types.Double (m_abVyJ a_abVyK)) ->
      case eta_B1
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <m_abVyJ a_abVyK>_N
                   :: (URec GHC.Types.Double (m_abVyJ a_abVyK) :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * (m_abVyJ a_abVyK) :: *))
      of
      { UDouble a1_abVnN ->
      pure
        @ m_abVyJ
        (GHC.Base.$p1Monad @ m_abVyJ $dMonad_abVyM)
        @ (URec GHC.Types.Double a_abVyK)
        ((GHC.Generics.UDouble @ * @ a_abVyK a1_abVnN)
         `cast` (Sym (GHC.Generics.D:R:UReckDoublep0[0] <*>_N) <a_abVyK>_N
                 :: (GHC.Generics.R:UReckDoublep * a_abVyK :: *)
                    ~R# (URec GHC.Types.Double a_abVyK :: *)))
      }

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable (URec GHC.Types.Double)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: URec GHC.Types.Double
                                      GHC.Generics.$fFunctorURec2
                                      Data.Foldable.$fFoldableURec2
                                      Data.Traversable.$fTraversableURec2_$ctraverse
                                      Data.Traversable.$fTraversableURec2_$csequenceA
                                      Data.Traversable.$fTraversableURec2_$cmapM
                                      Data.Traversable.$fTraversableURec2_$csequence]
Data.Traversable.$fTraversableURec2
  = Data.Traversable.C:Traversable
      @ (URec GHC.Types.Double)
      GHC.Generics.$fFunctorURec2
      Data.Foldable.$fFoldableURec2
      Data.Traversable.$fTraversableURec2_$ctraverse
      Data.Traversable.$fTraversableURec2_$csequenceA
      Data.Traversable.$fTraversableURec2_$cmapM
      Data.Traversable.$fTraversableURec2_$csequence

-- RHS size: {terms: 11, types: 29, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec3_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     URec GHC.Types.Char (f a) -> f (URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVzm :: * -> *))
                 (@ a_abVzn)
                 ($dApplicative_abVzp [Occ=Once] :: Applicative f_abVzm)
                 (ds_dbW6X [Occ=Once] :: URec GHC.Types.Char (f_abVzm a_abVzn)) ->
                 case ds_dbW6X
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <f_abVzm a_abVzn>_N
                              :: (URec GHC.Types.Char (f_abVzm a_abVzn) :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * (f_abVzm a_abVzn) :: *))
                 of
                 { UChar a1_abVnP [Occ=Once] ->
                 pure
                   @ f_abVzm
                   $dApplicative_abVzp
                   @ (URec GHC.Types.Char a_abVzn)
                   (GHC.Generics.$WUChar @ * @ a_abVzn a1_abVnP)
                 }}]
Data.Traversable.$fTraversableURec3_$csequenceA
  = \ (@ (f_abVzm :: * -> *))
      (@ a_abVzn)
      ($dApplicative_abVzp :: Applicative f_abVzm)
      (ds_dbW6X :: URec GHC.Types.Char (f_abVzm a_abVzn)) ->
      case ds_dbW6X
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <f_abVzm a_abVzn>_N
                   :: (URec GHC.Types.Char (f_abVzm a_abVzn) :: *)
                      ~R# (GHC.Generics.R:UReckCharp * (f_abVzm a_abVzn) :: *))
      of
      { UChar a1_abVnP ->
      pure
        @ f_abVzm
        $dApplicative_abVzp
        @ (URec GHC.Types.Char a_abVzn)
        ((GHC.Generics.UChar @ * @ a_abVzn a1_abVnP)
         `cast` (Sym (GHC.Generics.D:R:UReckCharp0[0] <*>_N) <a_abVzn>_N
                 :: (GHC.Generics.R:UReckCharp * a_abVzn :: *)
                    ~R# (URec GHC.Types.Char a_abVzn :: *)))
      }

-- RHS size: {terms: 14, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec3_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> URec GHC.Types.Char a -> m (URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVzy :: * -> *))
                 (@ a_abVzz)
                 (@ b_abVzA)
                 ($dMonad_abVzC [Occ=OnceL] :: Monad m_abVzy) ->
                 let {
                   $dApplicative_abVz9 [Occ=OnceL] :: Applicative m_abVzy
                   [LclId]
                   $dApplicative_abVz9
                     = GHC.Base.$p1Monad @ m_abVzy $dMonad_abVzC } in
                 \ _ [Occ=Dead]
                   (ds_dbW6X [Occ=Once] :: URec GHC.Types.Char a_abVzz) ->
                   case ds_dbW6X
                        `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_abVzz>_N
                                :: (URec GHC.Types.Char a_abVzz :: *)
                                   ~R# (GHC.Generics.R:UReckCharp * a_abVzz :: *))
                   of
                   { UChar a1_abVnP [Occ=Once] ->
                   pure
                     @ m_abVzy
                     $dApplicative_abVz9
                     @ (URec GHC.Types.Char b_abVzA)
                     (GHC.Generics.$WUChar @ * @ b_abVzA a1_abVnP)
                   }}]
Data.Traversable.$fTraversableURec3_$cmapM
  = \ (@ (m_abVzy :: * -> *))
      (@ a_abVzz)
      (@ b_abVzA)
      ($dMonad_abVzC :: Monad m_abVzy)
      _ [Occ=Dead]
      (eta1_B1 :: URec GHC.Types.Char a_abVzz) ->
      case eta1_B1
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_abVzz>_N
                   :: (URec GHC.Types.Char a_abVzz :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_abVzz :: *))
      of
      { UChar a1_abVnP ->
      pure
        @ m_abVzy
        (GHC.Base.$p1Monad @ m_abVzy $dMonad_abVzC)
        @ (URec GHC.Types.Char b_abVzA)
        ((GHC.Generics.UChar @ * @ b_abVzA a1_abVnP)
         `cast` (Sym (GHC.Generics.D:R:UReckCharp0[0] <*>_N) <b_abVzA>_N
                 :: (GHC.Generics.R:UReckCharp * b_abVzA :: *)
                    ~R# (URec GHC.Types.Char b_abVzA :: *)))
      }

-- RHS size: {terms: 12, types: 30, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec3_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     URec GHC.Types.Char (m a) -> m (URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVzM :: * -> *))
                 (@ a_abVzN)
                 ($dMonad_abVzP [Occ=OnceL] :: Monad m_abVzM) ->
                 let {
                   $dApplicative_abVzp [Occ=OnceL] :: Applicative m_abVzM
                   [LclId]
                   $dApplicative_abVzp
                     = GHC.Base.$p1Monad @ m_abVzM $dMonad_abVzP } in
                 \ (ds_dbW6X [Occ=Once] :: URec GHC.Types.Char (m_abVzM a_abVzN)) ->
                   case ds_dbW6X
                        `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <m_abVzM a_abVzN>_N
                                :: (URec GHC.Types.Char (m_abVzM a_abVzN) :: *)
                                   ~R# (GHC.Generics.R:UReckCharp * (m_abVzM a_abVzN) :: *))
                   of
                   { UChar a1_abVnP [Occ=Once] ->
                   pure
                     @ m_abVzM
                     $dApplicative_abVzp
                     @ (URec GHC.Types.Char a_abVzN)
                     (GHC.Generics.$WUChar @ * @ a_abVzN a1_abVnP)
                   }}]
Data.Traversable.$fTraversableURec3_$csequence
  = \ (@ (m_abVzM :: * -> *))
      (@ a_abVzN)
      ($dMonad_abVzP :: Monad m_abVzM)
      (eta_B1 :: URec GHC.Types.Char (m_abVzM a_abVzN)) ->
      case eta_B1
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <m_abVzM a_abVzN>_N
                   :: (URec GHC.Types.Char (m_abVzM a_abVzN) :: *)
                      ~R# (GHC.Generics.R:UReckCharp * (m_abVzM a_abVzN) :: *))
      of
      { UChar a1_abVnP ->
      pure
        @ m_abVzM
        (GHC.Base.$p1Monad @ m_abVzM $dMonad_abVzP)
        @ (URec GHC.Types.Char a_abVzN)
        ((GHC.Generics.UChar @ * @ a_abVzN a1_abVnP)
         `cast` (Sym (GHC.Generics.D:R:UReckCharp0[0] <*>_N) <a_abVzN>_N
                 :: (GHC.Generics.R:UReckCharp * a_abVzN :: *)
                    ~R# (URec GHC.Types.Char a_abVzN :: *)))
      }

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable (URec GHC.Types.Char)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: URec GHC.Types.Char
                                      GHC.Generics.$fFunctorURec3
                                      Data.Foldable.$fFoldableURec3
                                      Data.Traversable.$fTraversableURec3_$ctraverse
                                      Data.Traversable.$fTraversableURec3_$csequenceA
                                      Data.Traversable.$fTraversableURec3_$cmapM
                                      Data.Traversable.$fTraversableURec3_$csequence]
Data.Traversable.$fTraversableURec3
  = Data.Traversable.C:Traversable
      @ (URec GHC.Types.Char)
      GHC.Generics.$fFunctorURec3
      Data.Foldable.$fFoldableURec3
      Data.Traversable.$fTraversableURec3_$ctraverse
      Data.Traversable.$fTraversableURec3_$csequenceA
      Data.Traversable.$fTraversableURec3_$cmapM
      Data.Traversable.$fTraversableURec3_$csequence

-- RHS size: {terms: 11, types: 31, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec4_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     URec (GHC.Ptr.Ptr ()) (f a) -> f (URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVAp :: * -> *))
                 (@ a_abVAq)
                 ($dApplicative_abVAs [Occ=Once] :: Applicative f_abVAp)
                 (ds_dbW70 [Occ=Once] :: URec (GHC.Ptr.Ptr ()) (f_abVAp a_abVAq)) ->
                 case ds_dbW70
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <f_abVAp a_abVAq>_N
                              :: (URec (GHC.Ptr.Ptr ()) (f_abVAp a_abVAq) :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * (f_abVAp a_abVAq) :: *))
                 of
                 { UAddr a1_abVnR [Occ=Once] ->
                 pure
                   @ f_abVAp
                   $dApplicative_abVAs
                   @ (URec (GHC.Ptr.Ptr ()) a_abVAq)
                   (GHC.Generics.$WUAddr @ * @ a_abVAq a1_abVnR)
                 }}]
Data.Traversable.$fTraversableURec4_$csequenceA
  = \ (@ (f_abVAp :: * -> *))
      (@ a_abVAq)
      ($dApplicative_abVAs :: Applicative f_abVAp)
      (ds_dbW70 :: URec (GHC.Ptr.Ptr ()) (f_abVAp a_abVAq)) ->
      case ds_dbW70
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <f_abVAp a_abVAq>_N
                   :: (URec (GHC.Ptr.Ptr ()) (f_abVAp a_abVAq) :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * (f_abVAp a_abVAq) :: *))
      of
      { UAddr a1_abVnR ->
      pure
        @ f_abVAp
        $dApplicative_abVAs
        @ (URec (GHC.Ptr.Ptr ()) a_abVAq)
        ((GHC.Generics.UAddr @ * @ a_abVAq a1_abVnR)
         `cast` (Sym (GHC.Generics.D:R:UReckPtrp0[0] <*>_N) <a_abVAq>_N
                 :: (GHC.Generics.R:UReckPtrp * a_abVAq :: *)
                    ~R# (URec (GHC.Ptr.Ptr ()) a_abVAq :: *)))
      }

-- RHS size: {terms: 14, types: 35, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableURec4_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b)
     -> URec (GHC.Ptr.Ptr ()) a -> m (URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVAB :: * -> *))
                 (@ a_abVAC)
                 (@ b_abVAD)
                 ($dMonad_abVAF [Occ=OnceL] :: Monad m_abVAB) ->
                 let {
                   $dApplicative_abVAc [Occ=OnceL] :: Applicative m_abVAB
                   [LclId]
                   $dApplicative_abVAc
                     = GHC.Base.$p1Monad @ m_abVAB $dMonad_abVAF } in
                 \ _ [Occ=Dead]
                   (ds_dbW70 [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_abVAC) ->
                   case ds_dbW70
                        `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_abVAC>_N
                                :: (URec (GHC.Ptr.Ptr ()) a_abVAC :: *)
                                   ~R# (GHC.Generics.R:UReckPtrp * a_abVAC :: *))
                   of
                   { UAddr a1_abVnR [Occ=Once] ->
                   pure
                     @ m_abVAB
                     $dApplicative_abVAc
                     @ (URec (GHC.Ptr.Ptr ()) b_abVAD)
                     (GHC.Generics.$WUAddr @ * @ b_abVAD a1_abVnR)
                   }}]
Data.Traversable.$fTraversableURec4_$cmapM
  = \ (@ (m_abVAB :: * -> *))
      (@ a_abVAC)
      (@ b_abVAD)
      ($dMonad_abVAF :: Monad m_abVAB)
      _ [Occ=Dead]
      (eta1_B1 :: URec (GHC.Ptr.Ptr ()) a_abVAC) ->
      case eta1_B1
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_abVAC>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_abVAC :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_abVAC :: *))
      of
      { UAddr a1_abVnR ->
      pure
        @ m_abVAB
        (GHC.Base.$p1Monad @ m_abVAB $dMonad_abVAF)
        @ (URec (GHC.Ptr.Ptr ()) b_abVAD)
        ((GHC.Generics.UAddr @ * @ b_abVAD a1_abVnR)
         `cast` (Sym (GHC.Generics.D:R:UReckPtrp0[0] <*>_N) <b_abVAD>_N
                 :: (GHC.Generics.R:UReckPtrp * b_abVAD :: *)
                    ~R# (URec (GHC.Ptr.Ptr ()) b_abVAD :: *)))
      }

-- RHS size: {terms: 12, types: 32, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableURec4_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     URec (GHC.Ptr.Ptr ()) (m a) -> m (URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVAP :: * -> *))
                 (@ a_abVAQ)
                 ($dMonad_abVAS [Occ=OnceL] :: Monad m_abVAP) ->
                 let {
                   $dApplicative_abVAs [Occ=OnceL] :: Applicative m_abVAP
                   [LclId]
                   $dApplicative_abVAs
                     = GHC.Base.$p1Monad @ m_abVAP $dMonad_abVAS } in
                 \ (ds_dbW70 [Occ=Once]
                      :: URec (GHC.Ptr.Ptr ()) (m_abVAP a_abVAQ)) ->
                   case ds_dbW70
                        `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <m_abVAP a_abVAQ>_N
                                :: (URec (GHC.Ptr.Ptr ()) (m_abVAP a_abVAQ) :: *)
                                   ~R# (GHC.Generics.R:UReckPtrp * (m_abVAP a_abVAQ) :: *))
                   of
                   { UAddr a1_abVnR [Occ=Once] ->
                   pure
                     @ m_abVAP
                     $dApplicative_abVAs
                     @ (URec (GHC.Ptr.Ptr ()) a_abVAQ)
                     (GHC.Generics.$WUAddr @ * @ a_abVAQ a1_abVnR)
                   }}]
Data.Traversable.$fTraversableURec4_$csequence
  = \ (@ (m_abVAP :: * -> *))
      (@ a_abVAQ)
      ($dMonad_abVAS :: Monad m_abVAP)
      (eta_B1 :: URec (GHC.Ptr.Ptr ()) (m_abVAP a_abVAQ)) ->
      case eta_B1
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <m_abVAP a_abVAQ>_N
                   :: (URec (GHC.Ptr.Ptr ()) (m_abVAP a_abVAQ) :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * (m_abVAP a_abVAQ) :: *))
      of
      { UAddr a1_abVnR ->
      pure
        @ m_abVAP
        (GHC.Base.$p1Monad @ m_abVAP $dMonad_abVAS)
        @ (URec (GHC.Ptr.Ptr ()) a_abVAQ)
        ((GHC.Generics.UAddr @ * @ a_abVAQ a1_abVnR)
         `cast` (Sym (GHC.Generics.D:R:UReckPtrp0[0] <*>_N) <a_abVAQ>_N
                 :: (GHC.Generics.R:UReckPtrp * a_abVAQ :: *)
                    ~R# (URec (GHC.Ptr.Ptr ()) a_abVAQ :: *)))
      }

-- RHS size: {terms: 7, types: 5, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable (URec (GHC.Ptr.Ptr ()))
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: URec (GHC.Ptr.Ptr ())
                                      GHC.Generics.$fFunctorURec4
                                      Data.Foldable.$fFoldableURec4
                                      Data.Traversable.$fTraversableURec4_$ctraverse
                                      Data.Traversable.$fTraversableURec4_$csequenceA
                                      Data.Traversable.$fTraversableURec4_$cmapM
                                      Data.Traversable.$fTraversableURec4_$csequence]
Data.Traversable.$fTraversableURec4
  = Data.Traversable.C:Traversable
      @ (URec (GHC.Ptr.Ptr ()))
      GHC.Generics.$fFunctorURec4
      Data.Foldable.$fFoldableURec4
      Data.Traversable.$fTraversableURec4_$ctraverse
      Data.Traversable.$fTraversableURec4_$csequenceA
      Data.Traversable.$fTraversableURec4_$cmapM
      Data.Traversable.$fTraversableURec4_$csequence

-- RHS size: {terms: 12, types: 28, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a.
     Applicative f1 =>
     (:.:) f g (f1 a) -> f1 ((:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVB0 :: * -> *))
                 (@ (g_abVB1 :: * -> *))
                 ($dTraversable_abVB2 [Occ=Once] :: Traversable f_abVB0)
                 ($dTraversable1_abVB3 [Occ=Once] :: Traversable g_abVB1)
                 (@ (f1_abVBJ :: * -> *))
                 (@ a_abVBK)
                 ($dApplicative_abVBM [Occ=Once] :: Applicative f1_abVBJ) ->
                 Data.Traversable.$fTraversable:.:_$ctraverse
                   @ f_abVB0
                   @ g_abVB1
                   $dTraversable_abVB2
                   $dTraversable1_abVB3
                   @ f1_abVBJ
                   @ (f1_abVBJ a_abVBK)
                   @ a_abVBK
                   $dApplicative_abVBM
                   (id @ (f1_abVBJ a_abVBK))}]
Data.Traversable.$fTraversable:.:_$csequenceA
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1)
      (@ (f1_abVBJ :: * -> *))
      (@ a_abVBK)
      ($dApplicative_abVBM :: Applicative f1_abVBJ) ->
      Data.Traversable.$fTraversable:.:_$ctraverse
        @ f_abVB0
        @ g_abVB1
        $dTraversable_abVB2
        $dTraversable1_abVB3
        @ f1_abVBJ
        @ (f1_abVBJ a_abVBK)
        @ a_abVBK
        $dApplicative_abVBM
        (id @ (f1_abVBJ a_abVBK))

-- RHS size: {terms: 17, types: 39, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> (:.:) f g a -> m ((:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVB0 :: * -> *))
                 (@ (g_abVB1 :: * -> *))
                 ($dTraversable_abVB2 [Occ=Once] :: Traversable f_abVB0)
                 ($dTraversable1_abVB3 [Occ=Once] :: Traversable g_abVB1)
                 (@ (m_abVBV :: * -> *))
                 (@ a_abVBW)
                 (@ b_abVBX)
                 ($dMonad_abVBZ [Occ=Once] :: Monad m_abVBV) ->
                 Data.Traversable.$fTraversable:.:_$ctraverse
                   @ f_abVB0
                   @ g_abVB1
                   $dTraversable_abVB2
                   $dTraversable1_abVB3
                   @ m_abVBV
                   @ a_abVBW
                   @ b_abVBX
                   (GHC.Base.$p1Monad @ m_abVBV $dMonad_abVBZ)}]
Data.Traversable.$fTraversable:.:_$cmapM
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1)
      (@ (m_abVBV :: * -> *))
      (@ a_abVBW)
      (@ b_abVBX)
      ($dMonad_abVBZ :: Monad m_abVBV)
      (eta_B2 :: a_abVBW -> m_abVBV b_abVBX)
      (eta1_B1 :: (:.:) f_abVB0 g_abVB1 a_abVBW) ->
      Data.Traversable.$fTraversable:.:_$ctraverse
        @ f_abVB0
        @ g_abVB1
        $dTraversable_abVB2
        $dTraversable1_abVB3
        @ m_abVBV
        @ a_abVBW
        @ b_abVBX
        (GHC.Base.$p1Monad @ m_abVBV $dMonad_abVBZ)
        eta_B2
        eta1_B1

-- RHS size: {terms: 15, types: 38, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a.
     Monad m =>
     (:.:) f g (m a) -> m ((:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVB0 :: * -> *))
                 (@ (g_abVB1 :: * -> *))
                 ($dTraversable_abVB2 [Occ=Once] :: Traversable f_abVB0)
                 ($dTraversable1_abVB3 [Occ=Once] :: Traversable g_abVB1)
                 (@ (m_abVC9 :: * -> *))
                 (@ a_abVCa)
                 ($dMonad_abVCc [Occ=Once] :: Monad m_abVC9) ->
                 Data.Traversable.$fTraversable:.:_$ctraverse
                   @ f_abVB0
                   @ g_abVB1
                   $dTraversable_abVB2
                   $dTraversable1_abVB3
                   @ m_abVC9
                   @ (m_abVC9 a_abVCa)
                   @ a_abVCa
                   (GHC.Base.$p1Monad @ m_abVC9 $dMonad_abVCc)
                   (id @ (m_abVC9 a_abVCa))}]
Data.Traversable.$fTraversable:.:_$csequence
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1)
      (@ (m_abVC9 :: * -> *))
      (@ a_abVCa)
      ($dMonad_abVCc :: Monad m_abVC9)
      (eta_B1 :: (:.:) f_abVB0 g_abVB1 (m_abVC9 a_abVCa)) ->
      Data.Traversable.$fTraversable:.:_$ctraverse
        @ f_abVB0
        @ g_abVB1
        $dTraversable_abVB2
        $dTraversable1_abVB3
        @ m_abVC9
        @ (m_abVC9 a_abVCa)
        @ a_abVCa
        (GHC.Base.$p1Monad @ m_abVC9 $dMonad_abVCc)
        (id @ (m_abVC9 a_abVCa))
        eta_B1

-- RHS size: {terms: 23, types: 31, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Traversable (f :.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),C(U)),1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),C(C1(U)),A,A,A)>m,
 Unf=DFun: \ (@ (f_abVgI :: * -> *))
             (@ (g_abVgJ :: * -> *))
             (v_B1 :: Traversable f_abVgI)
             (v1_B2 :: Traversable g_abVgJ) ->
       Data.Traversable.C:Traversable TYPE: f_abVgI :.: g_abVgJ
                                      Data.Traversable.$fTraversable:.:_$cp1Traversable
                                        @ f_abVgI @ g_abVgJ v_B1 v1_B2
                                      Data.Traversable.$fTraversable:.:_$cp2Traversable
                                        @ f_abVgI @ g_abVgJ v_B1 v1_B2
                                      Data.Traversable.$fTraversable:.:_$ctraverse
                                        @ f_abVgI @ g_abVgJ v_B1 v1_B2
                                      Data.Traversable.$fTraversable:.:_$csequenceA
                                        @ f_abVgI @ g_abVgJ v_B1 v1_B2
                                      Data.Traversable.$fTraversable:.:_$cmapM
                                        @ f_abVgI @ g_abVgJ v_B1 v1_B2
                                      Data.Traversable.$fTraversable:.:_$csequence
                                        @ f_abVgI @ g_abVgJ v_B1 v1_B2]
Data.Traversable.$fTraversable:.:
  = \ (@ (f_abVB0 :: * -> *))
      (@ (g_abVB1 :: * -> *))
      ($dTraversable_abVB2 :: Traversable f_abVB0)
      ($dTraversable1_abVB3 :: Traversable g_abVB1) ->
      Data.Traversable.C:Traversable
        @ (f_abVB0 :.: g_abVB1)
        (Data.Traversable.$fTraversable:.:_$cp1Traversable
           @ f_abVB0 @ g_abVB1 $dTraversable_abVB2 $dTraversable1_abVB3)
        (Data.Traversable.$fTraversable:.:_$cp2Traversable
           @ f_abVB0 @ g_abVB1 $dTraversable_abVB2 $dTraversable1_abVB3)
        (Data.Traversable.$fTraversable:.:_$ctraverse
           @ f_abVB0 @ g_abVB1 $dTraversable_abVB2 $dTraversable1_abVB3)
        (Data.Traversable.$fTraversable:.:_$csequenceA
           @ f_abVB0 @ g_abVB1 $dTraversable_abVB2 $dTraversable1_abVB3)
        (Data.Traversable.$fTraversable:.:_$cmapM
           @ f_abVB0 @ g_abVB1 $dTraversable_abVB2 $dTraversable1_abVB3)
        (Data.Traversable.$fTraversable:.:_$csequence
           @ f_abVB0 @ g_abVB1 $dTraversable_abVB2 $dTraversable1_abVB3)

-- RHS size: {terms: 18, types: 48, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a.
     Applicative f1 =>
     (:*:) f g (f1 a) -> f1 ((:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVCk :: * -> *))
                 (@ (g_abVCl :: * -> *))
                 ($dTraversable_abVCm [Occ=Once] :: Traversable f_abVCk)
                 ($dTraversable1_abVCn [Occ=Once] :: Traversable g_abVCl)
                 (@ (f1_abVD3 :: * -> *))
                 (@ a_abVD4)
                 ($dApplicative_abVD6 [Occ=Once] :: Applicative f1_abVD3) ->
                 Data.Traversable.$fTraversable:*:_$ctraverse
                   @ f_abVCk
                   @ g_abVCl
                   $dTraversable_abVCm
                   $dTraversable1_abVCn
                   @ f1_abVD3
                   @ (f1_abVD3 a_abVD4)
                   @ a_abVD4
                   $dApplicative_abVD6
                   (id @ (f1_abVD3 a_abVD4))}]
Data.Traversable.$fTraversable:*:_$csequenceA
  = \ (@ (f_abVCk :: * -> *))
      (@ (g_abVCl :: * -> *))
      ($dTraversable_abVCm :: Traversable f_abVCk)
      ($dTraversable1_abVCn :: Traversable g_abVCl)
      (@ (f1_abVD3 :: * -> *))
      (@ a_abVD4)
      ($dApplicative_abVD6 :: Applicative f1_abVD3)
      (w_sbWKG :: (:*:) f_abVCk g_abVCl (f1_abVD3 a_abVD4)) ->
      case w_sbWKG of { :*: ww1_sbWKJ ww2_sbWKK ->
      Data.Traversable.$w$ctraverse
        @ f_abVCk
        @ g_abVCl
        $dTraversable_abVCm
        $dTraversable1_abVCn
        @ f1_abVD3
        @ (f1_abVD3 a_abVD4)
        @ a_abVD4
        $dApplicative_abVD6
        (id @ (f1_abVD3 a_abVD4))
        ww1_sbWKJ
        ww2_sbWKK
      }

-- RHS size: {terms: 21, types: 47, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> (:*:) f g a -> m ((:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVCk :: * -> *))
                 (@ (g_abVCl :: * -> *))
                 ($dTraversable_abVCm [Occ=Once] :: Traversable f_abVCk)
                 ($dTraversable1_abVCn [Occ=Once] :: Traversable g_abVCl)
                 (@ (m_abVDf :: * -> *))
                 (@ a_abVDg)
                 (@ b_abVDh)
                 ($dMonad_abVDj [Occ=Once] :: Monad m_abVDf) ->
                 Data.Traversable.$fTraversable:*:_$ctraverse
                   @ f_abVCk
                   @ g_abVCl
                   $dTraversable_abVCm
                   $dTraversable1_abVCn
                   @ m_abVDf
                   @ a_abVDg
                   @ b_abVDh
                   (GHC.Base.$p1Monad @ m_abVDf $dMonad_abVDj)}]
Data.Traversable.$fTraversable:*:_$cmapM
  = \ (@ (f_abVCk :: * -> *))
      (@ (g_abVCl :: * -> *))
      ($dTraversable_abVCm :: Traversable f_abVCk)
      ($dTraversable1_abVCn :: Traversable g_abVCl)
      (@ (m_abVDf :: * -> *))
      (@ a_abVDg)
      (@ b_abVDh)
      ($dMonad_abVDj :: Monad m_abVDf)
      (eta_B2 :: a_abVDg -> m_abVDf b_abVDh)
      (eta1_B1 :: (:*:) f_abVCk g_abVCl a_abVDg) ->
      case eta1_B1 of { :*: ww1_sbWKJ ww2_sbWKK ->
      Data.Traversable.$w$ctraverse
        @ f_abVCk
        @ g_abVCl
        $dTraversable_abVCm
        $dTraversable1_abVCn
        @ m_abVDf
        @ a_abVDg
        @ b_abVDh
        (GHC.Base.$p1Monad @ m_abVDf $dMonad_abVDj)
        eta_B2
        ww1_sbWKJ
        ww2_sbWKK
      }

-- RHS size: {terms: 19, types: 49, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a.
     Monad m =>
     (:*:) f g (m a) -> m ((:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVCk :: * -> *))
                 (@ (g_abVCl :: * -> *))
                 ($dTraversable_abVCm [Occ=Once] :: Traversable f_abVCk)
                 ($dTraversable1_abVCn [Occ=Once] :: Traversable g_abVCl)
                 (@ (m_abVDt :: * -> *))
                 (@ a_abVDu)
                 ($dMonad_abVDw [Occ=Once] :: Monad m_abVDt) ->
                 Data.Traversable.$fTraversable:*:_$ctraverse
                   @ f_abVCk
                   @ g_abVCl
                   $dTraversable_abVCm
                   $dTraversable1_abVCn
                   @ m_abVDt
                   @ (m_abVDt a_abVDu)
                   @ a_abVDu
                   (GHC.Base.$p1Monad @ m_abVDt $dMonad_abVDw)
                   (id @ (m_abVDt a_abVDu))}]
Data.Traversable.$fTraversable:*:_$csequence
  = \ (@ (f_abVCk :: * -> *))
      (@ (g_abVCl :: * -> *))
      ($dTraversable_abVCm :: Traversable f_abVCk)
      ($dTraversable1_abVCn :: Traversable g_abVCl)
      (@ (m_abVDt :: * -> *))
      (@ a_abVDu)
      ($dMonad_abVDw :: Monad m_abVDt)
      (eta_B1 :: (:*:) f_abVCk g_abVCl (m_abVDt a_abVDu)) ->
      case eta_B1 of { :*: ww1_sbWKJ ww2_sbWKK ->
      Data.Traversable.$w$ctraverse
        @ f_abVCk
        @ g_abVCl
        $dTraversable_abVCm
        $dTraversable1_abVCn
        @ m_abVDt
        @ (m_abVDt a_abVDu)
        @ a_abVDu
        (GHC.Base.$p1Monad @ m_abVDt $dMonad_abVDw)
        (id @ (m_abVDt a_abVDu))
        ww1_sbWKJ
        ww2_sbWKK
      }

-- RHS size: {terms: 23, types: 29, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Traversable (f :*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m,
 Unf=DFun: \ (@ (f_abVgK :: * -> *))
             (@ (g_abVgL :: * -> *))
             (v_B1 :: Traversable f_abVgK)
             (v1_B2 :: Traversable g_abVgL) ->
       Data.Traversable.C:Traversable TYPE: f_abVgK :*: g_abVgL
                                      Data.Traversable.$fTraversable:*:_$cp1Traversable
                                        @ f_abVgK @ g_abVgL v_B1 v1_B2
                                      Data.Traversable.$fTraversable:*:_$cp2Traversable
                                        @ f_abVgK @ g_abVgL v_B1 v1_B2
                                      Data.Traversable.$fTraversable:*:_$ctraverse
                                        @ f_abVgK @ g_abVgL v_B1 v1_B2
                                      Data.Traversable.$fTraversable:*:_$csequenceA
                                        @ f_abVgK @ g_abVgL v_B1 v1_B2
                                      Data.Traversable.$fTraversable:*:_$cmapM
                                        @ f_abVgK @ g_abVgL v_B1 v1_B2
                                      Data.Traversable.$fTraversable:*:_$csequence
                                        @ f_abVgK @ g_abVgL v_B1 v1_B2]
Data.Traversable.$fTraversable:*:
  = \ (@ (f_abVCk :: * -> *))
      (@ (g_abVCl :: * -> *))
      ($dTraversable_abVCm :: Traversable f_abVCk)
      ($dTraversable1_abVCn :: Traversable g_abVCl) ->
      Data.Traversable.C:Traversable
        @ (f_abVCk :*: g_abVCl)
        (Data.Traversable.$fTraversable:*:_$cp1Traversable
           @ f_abVCk @ g_abVCl $dTraversable_abVCm $dTraversable1_abVCn)
        (Data.Traversable.$fTraversable:*:_$cp2Traversable
           @ f_abVCk @ g_abVCl $dTraversable_abVCm $dTraversable1_abVCn)
        (Data.Traversable.$fTraversable:*:_$ctraverse
           @ f_abVCk @ g_abVCl $dTraversable_abVCm $dTraversable1_abVCn)
        (Data.Traversable.$fTraversable:*:_$csequenceA
           @ f_abVCk @ g_abVCl $dTraversable_abVCm $dTraversable1_abVCn)
        (Data.Traversable.$fTraversable:*:_$cmapM
           @ f_abVCk @ g_abVCl $dTraversable_abVCm $dTraversable1_abVCn)
        (Data.Traversable.$fTraversable:*:_$csequence
           @ f_abVCk @ g_abVCl $dTraversable_abVCm $dTraversable1_abVCn)

-- RHS size: {terms: 12, types: 28, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (f1 :: * -> *) a.
     Applicative f1 =>
     (:+:) f g (f1 a) -> f1 ((:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVDE :: * -> *))
                 (@ (g_abVDF :: * -> *))
                 ($dTraversable_abVDG [Occ=Once] :: Traversable f_abVDE)
                 ($dTraversable1_abVDH [Occ=Once] :: Traversable g_abVDF)
                 (@ (f1_abVEu :: * -> *))
                 (@ a_abVEv)
                 ($dApplicative_abVEx [Occ=Once] :: Applicative f1_abVEu) ->
                 Data.Traversable.$fTraversable:+:_$ctraverse
                   @ f_abVDE
                   @ g_abVDF
                   $dTraversable_abVDG
                   $dTraversable1_abVDH
                   @ f1_abVEu
                   @ (f1_abVEu a_abVEv)
                   @ a_abVEv
                   $dApplicative_abVEx
                   (id @ (f1_abVEu a_abVEv))}]
Data.Traversable.$fTraversable:+:_$csequenceA
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF)
      (@ (f1_abVEu :: * -> *))
      (@ a_abVEv)
      ($dApplicative_abVEx :: Applicative f1_abVEu) ->
      Data.Traversable.$fTraversable:+:_$ctraverse
        @ f_abVDE
        @ g_abVDF
        $dTraversable_abVDG
        $dTraversable1_abVDH
        @ f1_abVEu
        @ (f1_abVEu a_abVEv)
        @ a_abVEv
        $dApplicative_abVEx
        (id @ (f1_abVEu a_abVEv))

-- RHS size: {terms: 17, types: 37, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> (:+:) f g a -> m ((:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVDE :: * -> *))
                 (@ (g_abVDF :: * -> *))
                 ($dTraversable_abVDG [Occ=Once] :: Traversable f_abVDE)
                 ($dTraversable1_abVDH [Occ=Once] :: Traversable g_abVDF)
                 (@ (m_abVEG :: * -> *))
                 (@ a_abVEH)
                 (@ b_abVEI)
                 ($dMonad_abVEK [Occ=Once] :: Monad m_abVEG) ->
                 Data.Traversable.$fTraversable:+:_$ctraverse
                   @ f_abVDE
                   @ g_abVDF
                   $dTraversable_abVDG
                   $dTraversable1_abVDH
                   @ m_abVEG
                   @ a_abVEH
                   @ b_abVEI
                   (GHC.Base.$p1Monad @ m_abVEG $dMonad_abVEK)}]
Data.Traversable.$fTraversable:+:_$cmapM
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF)
      (@ (m_abVEG :: * -> *))
      (@ a_abVEH)
      (@ b_abVEI)
      ($dMonad_abVEK :: Monad m_abVEG)
      (eta_B2 :: a_abVEH -> m_abVEG b_abVEI)
      (eta1_B1 :: (:+:) f_abVDE g_abVDF a_abVEH) ->
      Data.Traversable.$fTraversable:+:_$ctraverse
        @ f_abVDE
        @ g_abVDF
        $dTraversable_abVDG
        $dTraversable1_abVDH
        @ m_abVEG
        @ a_abVEH
        @ b_abVEI
        (GHC.Base.$p1Monad @ m_abVEG $dMonad_abVEK)
        eta_B2
        eta1_B1

-- RHS size: {terms: 15, types: 36, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     forall (m :: * -> *) a.
     Monad m =>
     (:+:) f g (m a) -> m ((:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVDE :: * -> *))
                 (@ (g_abVDF :: * -> *))
                 ($dTraversable_abVDG [Occ=Once] :: Traversable f_abVDE)
                 ($dTraversable1_abVDH [Occ=Once] :: Traversable g_abVDF)
                 (@ (m_abVEU :: * -> *))
                 (@ a_abVEV)
                 ($dMonad_abVEX [Occ=Once] :: Monad m_abVEU) ->
                 Data.Traversable.$fTraversable:+:_$ctraverse
                   @ f_abVDE
                   @ g_abVDF
                   $dTraversable_abVDG
                   $dTraversable1_abVDH
                   @ m_abVEU
                   @ (m_abVEU a_abVEV)
                   @ a_abVEV
                   (GHC.Base.$p1Monad @ m_abVEU $dMonad_abVEX)
                   (id @ (m_abVEU a_abVEV))}]
Data.Traversable.$fTraversable:+:_$csequence
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF)
      (@ (m_abVEU :: * -> *))
      (@ a_abVEV)
      ($dMonad_abVEX :: Monad m_abVEU)
      (eta_B1 :: (:+:) f_abVDE g_abVDF (m_abVEU a_abVEV)) ->
      Data.Traversable.$fTraversable:+:_$ctraverse
        @ f_abVDE
        @ g_abVDF
        $dTraversable_abVDG
        $dTraversable1_abVDH
        @ m_abVEU
        @ (m_abVEU a_abVEV)
        @ a_abVEV
        (GHC.Base.$p1Monad @ m_abVEU $dMonad_abVEX)
        (id @ (m_abVEU a_abVEV))
        eta_B1

-- RHS size: {terms: 23, types: 29, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Traversable (f :+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m,
 Unf=DFun: \ (@ (f_abVgM :: * -> *))
             (@ (g_abVgN :: * -> *))
             (v_B1 :: Traversable f_abVgM)
             (v1_B2 :: Traversable g_abVgN) ->
       Data.Traversable.C:Traversable TYPE: f_abVgM :+: g_abVgN
                                      Data.Traversable.$fTraversable:+:_$cp1Traversable
                                        @ f_abVgM @ g_abVgN v_B1 v1_B2
                                      Data.Traversable.$fTraversable:+:_$cp2Traversable
                                        @ f_abVgM @ g_abVgN v_B1 v1_B2
                                      Data.Traversable.$fTraversable:+:_$ctraverse
                                        @ f_abVgM @ g_abVgN v_B1 v1_B2
                                      Data.Traversable.$fTraversable:+:_$csequenceA
                                        @ f_abVgM @ g_abVgN v_B1 v1_B2
                                      Data.Traversable.$fTraversable:+:_$cmapM
                                        @ f_abVgM @ g_abVgN v_B1 v1_B2
                                      Data.Traversable.$fTraversable:+:_$csequence
                                        @ f_abVgM @ g_abVgN v_B1 v1_B2]
Data.Traversable.$fTraversable:+:
  = \ (@ (f_abVDE :: * -> *))
      (@ (g_abVDF :: * -> *))
      ($dTraversable_abVDG :: Traversable f_abVDE)
      ($dTraversable1_abVDH :: Traversable g_abVDF) ->
      Data.Traversable.C:Traversable
        @ (f_abVDE :+: g_abVDF)
        (Data.Traversable.$fTraversable:+:_$cp1Traversable
           @ f_abVDE @ g_abVDF $dTraversable_abVDG $dTraversable1_abVDH)
        (Data.Traversable.$fTraversable:+:_$cp2Traversable
           @ f_abVDE @ g_abVDF $dTraversable_abVDG $dTraversable1_abVDH)
        (Data.Traversable.$fTraversable:+:_$ctraverse
           @ f_abVDE @ g_abVDF $dTraversable_abVDG $dTraversable1_abVDH)
        (Data.Traversable.$fTraversable:+:_$csequenceA
           @ f_abVDE @ g_abVDF $dTraversable_abVDG $dTraversable1_abVDH)
        (Data.Traversable.$fTraversable:+:_$cmapM
           @ f_abVDE @ g_abVDF $dTraversable_abVDG $dTraversable1_abVDH)
        (Data.Traversable.$fTraversable:+:_$csequence
           @ f_abVDE @ g_abVDF $dTraversable_abVDG $dTraversable1_abVDH)

-- RHS size: {terms: 17, types: 44, coercions: 19, joins: 0/0}
Data.Traversable.$fTraversableM1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     forall (f1 :: * -> *) a.
     Applicative f1 =>
     M1 i c f (f1 a) -> f1 (M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVF5 :: * -> *))
                 (@ i_abVF6)
                 (@ (c_abVF7 :: Meta))
                 ($dTraversable_abVF8 [Occ=Once] :: Traversable f_abVF5)
                 (@ (f1_abVFI :: * -> *))
                 (@ a_abVFJ)
                 ($dApplicative_abVFL :: Applicative f1_abVFI)
                 (eta_B1 [Occ=Once]
                    :: M1 i_abVF6 c_abVF7 f_abVF5 (f1_abVFI a_abVFJ)) ->
                 fmap
                   @ f1_abVFI
                   (GHC.Base.$p1Applicative @ f1_abVFI $dApplicative_abVFL)
                   @ (f_abVF5 a_abVFJ)
                   @ (M1 i_abVF6 c_abVF7 f_abVF5 a_abVFJ)
                   ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ a_abVFJ)
                    `cast` (<f_abVF5 a_abVFJ>_R
                            ->_R Sym (GHC.Generics.N:M1[0]
                                          <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <a_abVFJ>_N
                            :: (f_abVF5 a_abVFJ -> f_abVF5 a_abVFJ :: *)
                               ~R# (f_abVF5 a_abVFJ -> M1 i_abVF6 c_abVF7 f_abVF5 a_abVFJ :: *)))
                   (traverse
                      @ f_abVF5
                      $dTraversable_abVF8
                      @ f1_abVFI
                      @ (f1_abVFI a_abVFJ)
                      @ a_abVFJ
                      $dApplicative_abVFL
                      (id @ (f1_abVFI a_abVFJ))
                      (eta_B1
                       `cast` (GHC.Generics.N:M1[0]
                                   <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <f1_abVFI a_abVFJ>_N
                               :: (M1 i_abVF6 c_abVF7 f_abVF5 (f1_abVFI a_abVFJ) :: *)
                                  ~R# (f_abVF5 (f1_abVFI a_abVFJ) :: *))))}]
Data.Traversable.$fTraversableM1_$csequenceA
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5)
      (@ (f1_abVFI :: * -> *))
      (@ a_abVFJ)
      ($dApplicative_abVFL :: Applicative f1_abVFI)
      (eta_B1 :: M1 i_abVF6 c_abVF7 f_abVF5 (f1_abVFI a_abVFJ)) ->
      fmap
        @ f1_abVFI
        (GHC.Base.$p1Applicative @ f1_abVFI $dApplicative_abVFL)
        @ (f_abVF5 a_abVFJ)
        @ (M1 i_abVF6 c_abVF7 f_abVF5 a_abVFJ)
        ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ a_abVFJ)
         `cast` (<f_abVF5 a_abVFJ>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <a_abVFJ>_N
                 :: (f_abVF5 a_abVFJ -> f_abVF5 a_abVFJ :: *)
                    ~R# (f_abVF5 a_abVFJ -> M1 i_abVF6 c_abVF7 f_abVF5 a_abVFJ :: *)))
        (traverse
           @ f_abVF5
           $dTraversable_abVF8
           @ f1_abVFI
           @ (f1_abVFI a_abVFJ)
           @ a_abVFJ
           $dApplicative_abVFL
           (id @ (f1_abVFI a_abVFJ))
           (eta_B1
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <f1_abVFI a_abVFJ>_N
                    :: (M1 i_abVF6 c_abVF7 f_abVF5 (f1_abVFI a_abVFJ) :: *)
                       ~R# (f_abVF5 (f1_abVFI a_abVFJ) :: *))))

-- RHS size: {terms: 22, types: 48, coercions: 18, joins: 0/1}
Data.Traversable.$fTraversableM1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> M1 i c f a -> m (M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVF5 :: * -> *))
                 (@ i_abVF6)
                 (@ (c_abVF7 :: Meta))
                 ($dTraversable_abVF8 [Occ=OnceL] :: Traversable f_abVF5)
                 (@ (m_abVFU :: * -> *))
                 (@ a_abVFV)
                 (@ b_abVFW)
                 ($dMonad_abVFY [Occ=OnceL] :: Monad m_abVFU) ->
                 let {
                   $dApplicative_abVFo :: Applicative m_abVFU
                   [LclId]
                   $dApplicative_abVFo
                     = GHC.Base.$p1Monad @ m_abVFU $dMonad_abVFY } in
                 \ (eta_B2 [Occ=Once] :: a_abVFV -> m_abVFU b_abVFW)
                   (eta1_B1 [Occ=Once] :: M1 i_abVF6 c_abVF7 f_abVF5 a_abVFV) ->
                   fmap
                     @ m_abVFU
                     (GHC.Base.$p1Applicative @ m_abVFU $dApplicative_abVFo)
                     @ (f_abVF5 b_abVFW)
                     @ (M1 i_abVF6 c_abVF7 f_abVF5 b_abVFW)
                     ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ b_abVFW)
                      `cast` (<f_abVF5 b_abVFW>_R
                              ->_R Sym (GHC.Generics.N:M1[0]
                                            <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <b_abVFW>_N
                              :: (f_abVF5 b_abVFW -> f_abVF5 b_abVFW :: *)
                                 ~R# (f_abVF5 b_abVFW -> M1 i_abVF6 c_abVF7 f_abVF5 b_abVFW :: *)))
                     (traverse
                        @ f_abVF5
                        $dTraversable_abVF8
                        @ m_abVFU
                        @ a_abVFV
                        @ b_abVFW
                        $dApplicative_abVFo
                        eta_B2
                        (eta1_B1
                         `cast` (GHC.Generics.N:M1[0]
                                     <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <a_abVFV>_N
                                 :: (M1 i_abVF6 c_abVF7 f_abVF5 a_abVFV :: *)
                                    ~R# (f_abVF5 a_abVFV :: *))))}]
Data.Traversable.$fTraversableM1_$cmapM
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5)
      (@ (m_abVFU :: * -> *))
      (@ a_abVFV)
      (@ b_abVFW)
      ($dMonad_abVFY :: Monad m_abVFU)
      (eta_B2 :: a_abVFV -> m_abVFU b_abVFW)
      (eta1_B1 :: M1 i_abVF6 c_abVF7 f_abVF5 a_abVFV) ->
      let {
        $dApplicative_sbWCk [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
          :: Applicative m_abVFU
        [LclId]
        $dApplicative_sbWCk
          = GHC.Base.$p1Monad @ m_abVFU $dMonad_abVFY } in
      fmap
        @ m_abVFU
        (GHC.Base.$p1Applicative @ m_abVFU $dApplicative_sbWCk)
        @ (f_abVF5 b_abVFW)
        @ (M1 i_abVF6 c_abVF7 f_abVF5 b_abVFW)
        ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ b_abVFW)
         `cast` (<f_abVF5 b_abVFW>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <b_abVFW>_N
                 :: (f_abVF5 b_abVFW -> f_abVF5 b_abVFW :: *)
                    ~R# (f_abVF5 b_abVFW -> M1 i_abVF6 c_abVF7 f_abVF5 b_abVFW :: *)))
        (traverse
           @ f_abVF5
           $dTraversable_abVF8
           @ m_abVFU
           @ a_abVFV
           @ b_abVFW
           $dApplicative_sbWCk
           eta_B2
           (eta1_B1
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <a_abVFV>_N
                    :: (M1 i_abVF6 c_abVF7 f_abVF5 a_abVFV :: *)
                       ~R# (f_abVF5 a_abVFV :: *))))

-- RHS size: {terms: 20, types: 47, coercions: 19, joins: 0/1}
Data.Traversable.$fTraversableM1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     forall (m :: * -> *) a. Monad m => M1 i c f (m a) -> m (M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVF5 :: * -> *))
                 (@ i_abVF6)
                 (@ (c_abVF7 :: Meta))
                 ($dTraversable_abVF8 [Occ=OnceL] :: Traversable f_abVF5)
                 (@ (m_abVG8 :: * -> *))
                 (@ a_abVG9)
                 ($dMonad_abVGb [Occ=OnceL] :: Monad m_abVG8) ->
                 let {
                   $dApplicative_abVFo :: Applicative m_abVG8
                   [LclId]
                   $dApplicative_abVFo
                     = GHC.Base.$p1Monad @ m_abVG8 $dMonad_abVGb } in
                 \ (eta_B1 [Occ=Once]
                      :: M1 i_abVF6 c_abVF7 f_abVF5 (m_abVG8 a_abVG9)) ->
                   fmap
                     @ m_abVG8
                     (GHC.Base.$p1Applicative @ m_abVG8 $dApplicative_abVFo)
                     @ (f_abVF5 a_abVG9)
                     @ (M1 i_abVF6 c_abVF7 f_abVF5 a_abVG9)
                     ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ a_abVG9)
                      `cast` (<f_abVF5 a_abVG9>_R
                              ->_R Sym (GHC.Generics.N:M1[0]
                                            <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <a_abVG9>_N
                              :: (f_abVF5 a_abVG9 -> f_abVF5 a_abVG9 :: *)
                                 ~R# (f_abVF5 a_abVG9 -> M1 i_abVF6 c_abVF7 f_abVF5 a_abVG9 :: *)))
                     (traverse
                        @ f_abVF5
                        $dTraversable_abVF8
                        @ m_abVG8
                        @ (m_abVG8 a_abVG9)
                        @ a_abVG9
                        $dApplicative_abVFo
                        (id @ (m_abVG8 a_abVG9))
                        (eta_B1
                         `cast` (GHC.Generics.N:M1[0]
                                     <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <m_abVG8 a_abVG9>_N
                                 :: (M1 i_abVF6 c_abVF7 f_abVF5 (m_abVG8 a_abVG9) :: *)
                                    ~R# (f_abVF5 (m_abVG8 a_abVG9) :: *))))}]
Data.Traversable.$fTraversableM1_$csequence
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5)
      (@ (m_abVG8 :: * -> *))
      (@ a_abVG9)
      ($dMonad_abVGb :: Monad m_abVG8)
      (eta_B1 :: M1 i_abVF6 c_abVF7 f_abVF5 (m_abVG8 a_abVG9)) ->
      let {
        $dApplicative_sbWCi [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
          :: Applicative m_abVG8
        [LclId]
        $dApplicative_sbWCi
          = GHC.Base.$p1Monad @ m_abVG8 $dMonad_abVGb } in
      fmap
        @ m_abVG8
        (GHC.Base.$p1Applicative @ m_abVG8 $dApplicative_sbWCi)
        @ (f_abVF5 a_abVG9)
        @ (M1 i_abVF6 c_abVF7 f_abVF5 a_abVG9)
        ((Data.Traversable.$fTraversableM2 @ f_abVF5 @ a_abVG9)
         `cast` (<f_abVF5 a_abVG9>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R) <a_abVG9>_N
                 :: (f_abVF5 a_abVG9 -> f_abVF5 a_abVG9 :: *)
                    ~R# (f_abVF5 a_abVG9 -> M1 i_abVF6 c_abVF7 f_abVF5 a_abVG9 :: *)))
        (traverse
           @ f_abVF5
           $dTraversable_abVF8
           @ m_abVG8
           @ (m_abVG8 a_abVG9)
           @ a_abVG9
           $dApplicative_sbWCi
           (id @ (m_abVG8 a_abVG9))
           (eta_B1
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_abVF6>_P <c_abVF7>_P <f_abVF5>_R <m_abVG8 a_abVG9>_N
                    :: (M1 i_abVF6 c_abVF7 f_abVF5 (m_abVG8 a_abVG9) :: *)
                       ~R# (f_abVF5 (m_abVG8 a_abVG9) :: *))))

-- RHS size: {terms: 17, types: 32, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: Meta).
     Traversable f =>
     Traversable (M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m,
 Unf=DFun: \ (@ (f_abVgO :: * -> *))
             (@ i_abVgP)
             (@ (c_abVgQ :: Meta))
             (v_B1 :: Traversable f_abVgO) ->
       Data.Traversable.C:Traversable TYPE: M1 i_abVgP c_abVgQ f_abVgO
                                      Data.Traversable.$fTraversableM1_$cp1Traversable
                                        @ f_abVgO @ i_abVgP @ c_abVgQ v_B1
                                      Data.Traversable.$fTraversableM1_$cp2Traversable
                                        @ f_abVgO @ i_abVgP @ c_abVgQ v_B1
                                      Data.Traversable.$fTraversableM1_$ctraverse
                                        @ f_abVgO @ i_abVgP @ c_abVgQ v_B1
                                      Data.Traversable.$fTraversableM1_$csequenceA
                                        @ f_abVgO @ i_abVgP @ c_abVgQ v_B1
                                      Data.Traversable.$fTraversableM1_$cmapM
                                        @ f_abVgO @ i_abVgP @ c_abVgQ v_B1
                                      Data.Traversable.$fTraversableM1_$csequence
                                        @ f_abVgO @ i_abVgP @ c_abVgQ v_B1]
Data.Traversable.$fTraversableM1
  = \ (@ (f_abVF5 :: * -> *))
      (@ i_abVF6)
      (@ (c_abVF7 :: Meta))
      ($dTraversable_abVF8 :: Traversable f_abVF5) ->
      Data.Traversable.C:Traversable
        @ (M1 i_abVF6 c_abVF7 f_abVF5)
        (Data.Traversable.$fTraversableM1_$cp1Traversable
           @ f_abVF5 @ i_abVF6 @ c_abVF7 $dTraversable_abVF8)
        (Data.Traversable.$fTraversableM1_$cp2Traversable
           @ f_abVF5 @ i_abVF6 @ c_abVF7 $dTraversable_abVF8)
        (Data.Traversable.$fTraversableM1_$ctraverse
           @ f_abVF5 @ i_abVF6 @ c_abVF7 $dTraversable_abVF8)
        (Data.Traversable.$fTraversableM1_$csequenceA
           @ f_abVF5 @ i_abVF6 @ c_abVF7 $dTraversable_abVF8)
        (Data.Traversable.$fTraversableM1_$cmapM
           @ f_abVF5 @ i_abVF6 @ c_abVF7 $dTraversable_abVF8)
        (Data.Traversable.$fTraversableM1_$csequence
           @ f_abVF5 @ i_abVF6 @ c_abVF7 $dTraversable_abVF8)

-- RHS size: {terms: 12, types: 30, coercions: 14, joins: 0/0}
Data.Traversable.$fTraversableK1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> K1 i c a -> m (K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_abVGj)
                 (@ c_abVGk)
                 (@ (m_abVGX :: * -> *))
                 (@ a_abVGY)
                 (@ b_abVGZ)
                 ($dMonad_abVH1 [Occ=OnceL] :: Monad m_abVGX) ->
                 let {
                   $dApplicative_abVGA [Occ=OnceL] :: Applicative m_abVGX
                   [LclId]
                   $dApplicative_abVGA
                     = GHC.Base.$p1Monad @ m_abVGX $dMonad_abVH1 } in
                 \ _ [Occ=Dead]
                   (z_abVo9 [Occ=Once] :: K1 i_abVGj c_abVGk a_abVGY) ->
                   pure
                     @ m_abVGX
                     $dApplicative_abVGA
                     @ (K1 i_abVGj c_abVGk b_abVGZ)
                     (z_abVo9
                      `cast` (GHC.Generics.N:K1[0]
                                  <*>_N
                                  <i_abVGj>_P
                                  <c_abVGk>_R
                                  <a_abVGY>_P ; Sym (GHC.Generics.N:K1[0]
                                                         <*>_N <i_abVGj>_P <c_abVGk>_R <b_abVGZ>_P)
                              :: (K1 i_abVGj c_abVGk a_abVGY :: *)
                                 ~R# (K1 i_abVGj c_abVGk b_abVGZ :: *)))}]
Data.Traversable.$fTraversableK1_$cmapM
  = \ (@ i_abVGj)
      (@ c_abVGk)
      (@ (m_abVGX :: * -> *))
      (@ a_abVGY)
      (@ b_abVGZ)
      ($dMonad_abVH1 :: Monad m_abVGX)
      _ [Occ=Dead]
      (eta1_B1 :: K1 i_abVGj c_abVGk a_abVGY) ->
      pure
        @ m_abVGX
        (GHC.Base.$p1Monad @ m_abVGX $dMonad_abVH1)
        @ (K1 i_abVGj c_abVGk b_abVGZ)
        (eta1_B1
         `cast` (GHC.Generics.N:K1[0]
                     <*>_N
                     <i_abVGj>_P
                     <c_abVGk>_R
                     <a_abVGY>_P ; Sym (GHC.Generics.N:K1[0]
                                            <*>_N <i_abVGj>_P <c_abVGk>_R <b_abVGZ>_P)
                 :: (K1 i_abVGj c_abVGk a_abVGY :: *)
                    ~R# (K1 i_abVGj c_abVGk b_abVGZ :: *)))

-- RHS size: {terms: 10, types: 26, coercions: 15, joins: 0/0}
Data.Traversable.$fTraversableK1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a.
     Monad m =>
     K1 i c (m a) -> m (K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_abVGj)
                 (@ c_abVGk)
                 (@ (m_abVHb :: * -> *))
                 (@ a_abVHc)
                 ($dMonad_abVHe [Occ=OnceL] :: Monad m_abVHb) ->
                 let {
                   $dApplicative_abVGO [Occ=OnceL] :: Applicative m_abVHb
                   [LclId]
                   $dApplicative_abVGO
                     = GHC.Base.$p1Monad @ m_abVHb $dMonad_abVHe } in
                 \ (z_abVo9 [Occ=Once] :: K1 i_abVGj c_abVGk (m_abVHb a_abVHc)) ->
                   pure
                     @ m_abVHb
                     $dApplicative_abVGO
                     @ (K1 i_abVGj c_abVGk a_abVHc)
                     (z_abVo9
                      `cast` (GHC.Generics.N:K1[0]
                                  <*>_N
                                  <i_abVGj>_P
                                  <c_abVGk>_R
                                  <m_abVHb a_abVHc>_P ; Sym (GHC.Generics.N:K1[0]
                                                                 <*>_N
                                                                 <i_abVGj>_P
                                                                 <c_abVGk>_R
                                                                 <a_abVHc>_P)
                              :: (K1 i_abVGj c_abVGk (m_abVHb a_abVHc) :: *)
                                 ~R# (K1 i_abVGj c_abVGk a_abVHc :: *)))}]
Data.Traversable.$fTraversableK1_$csequence
  = \ (@ i_abVGj)
      (@ c_abVGk)
      (@ (m_abVHb :: * -> *))
      (@ a_abVHc)
      ($dMonad_abVHe :: Monad m_abVHb)
      (eta_B1 :: K1 i_abVGj c_abVGk (m_abVHb a_abVHc)) ->
      pure
        @ m_abVHb
        (GHC.Base.$p1Monad @ m_abVHb $dMonad_abVHe)
        @ (K1 i_abVGj c_abVGk a_abVHc)
        (eta_B1
         `cast` (GHC.Generics.N:K1[0]
                     <*>_N
                     <i_abVGj>_P
                     <c_abVGk>_R
                     <m_abVHb a_abVHc>_P ; Sym (GHC.Generics.N:K1[0]
                                                    <*>_N <i_abVGj>_P <c_abVGk>_R <a_abVHc>_P)
                 :: (K1 i_abVGj c_abVGk (m_abVHb a_abVHc) :: *)
                    ~R# (K1 i_abVGj c_abVGk a_abVHc :: *)))

-- RHS size: {terms: 9, types: 25, coercions: 15, joins: 0/0}
$fTraversableK2_rbWTS
  :: forall c i (f :: * -> *) a.
     Applicative f =>
     K1 i c (f a) -> f (K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []]
$fTraversableK2_rbWTS
  = \ (@ c_abVGk)
      (@ i_abVGj)
      (@ (f_abVGL :: * -> *))
      (@ a_abVGM)
      ($dApplicative_abVGO :: Applicative f_abVGL)
      (z_abVo9 :: K1 i_abVGj c_abVGk (f_abVGL a_abVGM)) ->
      pure
        @ f_abVGL
        $dApplicative_abVGO
        @ (K1 i_abVGj c_abVGk a_abVGM)
        (z_abVo9
         `cast` (GHC.Generics.N:K1[0]
                     <*>_N
                     <i_abVGj>_P
                     <c_abVGk>_R
                     <f_abVGL a_abVGM>_P ; Sym (GHC.Generics.N:K1[0]
                                                    <*>_N <i_abVGj>_P <c_abVGk>_R <a_abVGM>_P)
                 :: (K1 i_abVGj c_abVGk (f_abVGL a_abVGM) :: *)
                    ~R# (K1 i_abVGj c_abVGk a_abVGM :: *)))

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Traversable (K1 i c)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ i_abVgR) (@ c_abVgS) ->
       Data.Traversable.C:Traversable TYPE: K1 i_abVgR c_abVgS
                                      GHC.Generics.$fFunctorK1 @ i_abVgR @ c_abVgS
                                      Data.Foldable.$fFoldableK1 @ i_abVgR @ c_abVgS
                                      Data.Traversable.$fTraversableK1_$ctraverse
                                        @ i_abVgR @ c_abVgS
                                      \ (@ (f_abVGL :: * -> *))
                                        (@ a_abVGM)
                                        ($dApplicative_abVGO [Occ=Once] :: Applicative f_abVGL)
                                        (z_abVo9 [Occ=Once]
                                           :: K1 i_abVgR c_abVgS (f_abVGL a_abVGM)) ->
                                        pure
                                          @ f_abVGL
                                          $dApplicative_abVGO
                                          @ (K1 i_abVgR c_abVgS a_abVGM)
                                          (z_abVo9
                                           `cast` (GHC.Generics.N:K1[0]
                                                       <*>_N
                                                       <i_abVgR>_P
                                                       <c_abVgS>_R
                                                       <f_abVGL a_abVGM>_P ; Sym (GHC.Generics.N:K1[0]
                                                                                      <*>_N
                                                                                      <i_abVgR>_P
                                                                                      <c_abVgS>_R
                                                                                      <a_abVGM>_P)
                                                   :: (K1 i_abVgR c_abVgS (f_abVGL a_abVGM) :: *)
                                                      ~R# (K1 i_abVgR c_abVgS a_abVGM :: *)))
                                      Data.Traversable.$fTraversableK1_$cmapM @ i_abVgR @ c_abVgS
                                      Data.Traversable.$fTraversableK1_$csequence
                                        @ i_abVgR @ c_abVgS]
Data.Traversable.$fTraversableK1
  = \ (@ i_abVGj) (@ c_abVGk) ->
      Data.Traversable.C:Traversable
        @ (K1 i_abVGj c_abVGk)
        (GHC.Generics.$fFunctorK1 @ i_abVGj @ c_abVGk)
        (Data.Foldable.$fFoldableK1 @ i_abVGj @ c_abVGk)
        (Data.Traversable.$fTraversableK1_$ctraverse @ i_abVGj @ c_abVGk)
        ($fTraversableK2_rbWTS @ c_abVGk @ i_abVGj)
        (Data.Traversable.$fTraversableK1_$cmapM @ i_abVGj @ c_abVGk)
        (Data.Traversable.$fTraversableK1_$csequence @ i_abVGj @ c_abVGk)

-- RHS size: {terms: 15, types: 38, coercions: 15, joins: 0/0}
Data.Traversable.$fTraversableRec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Traversable f =>
     forall (f1 :: * -> *) a.
     Applicative f1 =>
     Rec1 f (f1 a) -> f1 (Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 ($dTraversable_abVHn [Occ=Once] :: Traversable f_abVHm)
                 (@ (f1_abVHV :: * -> *))
                 (@ a_abVHW)
                 ($dApplicative_abVHY :: Applicative f1_abVHV)
                 (eta_B1 [Occ=Once] :: Rec1 f_abVHm (f1_abVHV a_abVHW)) ->
                 fmap
                   @ f1_abVHV
                   (GHC.Base.$p1Applicative @ f1_abVHV $dApplicative_abVHY)
                   @ (f_abVHm a_abVHW)
                   @ (Rec1 f_abVHm a_abVHW)
                   ((Data.Traversable.$fTraversableM2 @ f_abVHm @ a_abVHW)
                    `cast` (<f_abVHm a_abVHW>_R
                            ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <a_abVHW>_N
                            :: (f_abVHm a_abVHW -> f_abVHm a_abVHW :: *)
                               ~R# (f_abVHm a_abVHW -> Rec1 f_abVHm a_abVHW :: *)))
                   (traverse
                      @ f_abVHm
                      $dTraversable_abVHn
                      @ f1_abVHV
                      @ (f1_abVHV a_abVHW)
                      @ a_abVHW
                      $dApplicative_abVHY
                      (id @ (f1_abVHV a_abVHW))
                      (eta_B1
                       `cast` (GHC.Generics.N:Rec1[0]
                                   <*>_N <f_abVHm>_R <f1_abVHV a_abVHW>_N
                               :: (Rec1 f_abVHm (f1_abVHV a_abVHW) :: *)
                                  ~R# (f_abVHm (f1_abVHV a_abVHW) :: *))))}]
Data.Traversable.$fTraversableRec1_$csequenceA
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm)
      (@ (f1_abVHV :: * -> *))
      (@ a_abVHW)
      ($dApplicative_abVHY :: Applicative f1_abVHV)
      (eta_B1 :: Rec1 f_abVHm (f1_abVHV a_abVHW)) ->
      fmap
        @ f1_abVHV
        (GHC.Base.$p1Applicative @ f1_abVHV $dApplicative_abVHY)
        @ (f_abVHm a_abVHW)
        @ (Rec1 f_abVHm a_abVHW)
        ((Data.Traversable.$fTraversableM2 @ f_abVHm @ a_abVHW)
         `cast` (<f_abVHm a_abVHW>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <a_abVHW>_N
                 :: (f_abVHm a_abVHW -> f_abVHm a_abVHW :: *)
                    ~R# (f_abVHm a_abVHW -> Rec1 f_abVHm a_abVHW :: *)))
        (traverse
           @ f_abVHm
           $dTraversable_abVHn
           @ f1_abVHV
           @ (f1_abVHV a_abVHW)
           @ a_abVHW
           $dApplicative_abVHY
           (id @ (f1_abVHV a_abVHW))
           (eta_B1
            `cast` (GHC.Generics.N:Rec1[0]
                        <*>_N <f_abVHm>_R <f1_abVHV a_abVHW>_N
                    :: (Rec1 f_abVHm (f1_abVHV a_abVHW) :: *)
                       ~R# (f_abVHm (f1_abVHV a_abVHW) :: *))))

-- RHS size: {terms: 20, types: 42, coercions: 14, joins: 0/1}
Data.Traversable.$fTraversableRec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Traversable f =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Rec1 f a -> m (Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 ($dTraversable_abVHn [Occ=OnceL] :: Traversable f_abVHm)
                 (@ (m_abVI7 :: * -> *))
                 (@ a_abVI8)
                 (@ b_abVI9)
                 ($dMonad_abVIb [Occ=OnceL] :: Monad m_abVI7) ->
                 let {
                   $dApplicative_abVHD :: Applicative m_abVI7
                   [LclId]
                   $dApplicative_abVHD
                     = GHC.Base.$p1Monad @ m_abVI7 $dMonad_abVIb } in
                 \ (eta_B2 [Occ=Once] :: a_abVI8 -> m_abVI7 b_abVI9)
                   (eta1_B1 [Occ=Once] :: Rec1 f_abVHm a_abVI8) ->
                   fmap
                     @ m_abVI7
                     (GHC.Base.$p1Applicative @ m_abVI7 $dApplicative_abVHD)
                     @ (f_abVHm b_abVI9)
                     @ (Rec1 f_abVHm b_abVI9)
                     ((Data.Traversable.$fTraversableM2 @ f_abVHm @ b_abVI9)
                      `cast` (<f_abVHm b_abVI9>_R
                              ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <b_abVI9>_N
                              :: (f_abVHm b_abVI9 -> f_abVHm b_abVI9 :: *)
                                 ~R# (f_abVHm b_abVI9 -> Rec1 f_abVHm b_abVI9 :: *)))
                     (traverse
                        @ f_abVHm
                        $dTraversable_abVHn
                        @ m_abVI7
                        @ a_abVI8
                        @ b_abVI9
                        $dApplicative_abVHD
                        eta_B2
                        (eta1_B1
                         `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R <a_abVI8>_N
                                 :: (Rec1 f_abVHm a_abVI8 :: *) ~R# (f_abVHm a_abVI8 :: *))))}]
Data.Traversable.$fTraversableRec1_$cmapM
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm)
      (@ (m_abVI7 :: * -> *))
      (@ a_abVI8)
      (@ b_abVI9)
      ($dMonad_abVIb :: Monad m_abVI7)
      (eta_B2 :: a_abVI8 -> m_abVI7 b_abVI9)
      (eta1_B1 :: Rec1 f_abVHm a_abVI8) ->
      let {
        $dApplicative_sbWCg [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
          :: Applicative m_abVI7
        [LclId]
        $dApplicative_sbWCg
          = GHC.Base.$p1Monad @ m_abVI7 $dMonad_abVIb } in
      fmap
        @ m_abVI7
        (GHC.Base.$p1Applicative @ m_abVI7 $dApplicative_sbWCg)
        @ (f_abVHm b_abVI9)
        @ (Rec1 f_abVHm b_abVI9)
        ((Data.Traversable.$fTraversableM2 @ f_abVHm @ b_abVI9)
         `cast` (<f_abVHm b_abVI9>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <b_abVI9>_N
                 :: (f_abVHm b_abVI9 -> f_abVHm b_abVI9 :: *)
                    ~R# (f_abVHm b_abVI9 -> Rec1 f_abVHm b_abVI9 :: *)))
        (traverse
           @ f_abVHm
           $dTraversable_abVHn
           @ m_abVI7
           @ a_abVI8
           @ b_abVI9
           $dApplicative_sbWCg
           eta_B2
           (eta1_B1
            `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R <a_abVI8>_N
                    :: (Rec1 f_abVHm a_abVI8 :: *) ~R# (f_abVHm a_abVI8 :: *))))

-- RHS size: {terms: 18, types: 41, coercions: 15, joins: 0/1}
Data.Traversable.$fTraversableRec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Traversable f =>
     forall (m :: * -> *) a. Monad m => Rec1 f (m a) -> m (Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVHm :: * -> *))
                 ($dTraversable_abVHn [Occ=OnceL] :: Traversable f_abVHm)
                 (@ (m_abVIl :: * -> *))
                 (@ a_abVIm)
                 ($dMonad_abVIo [Occ=OnceL] :: Monad m_abVIl) ->
                 let {
                   $dApplicative_abVHD :: Applicative m_abVIl
                   [LclId]
                   $dApplicative_abVHD
                     = GHC.Base.$p1Monad @ m_abVIl $dMonad_abVIo } in
                 \ (eta_B1 [Occ=Once] :: Rec1 f_abVHm (m_abVIl a_abVIm)) ->
                   fmap
                     @ m_abVIl
                     (GHC.Base.$p1Applicative @ m_abVIl $dApplicative_abVHD)
                     @ (f_abVHm a_abVIm)
                     @ (Rec1 f_abVHm a_abVIm)
                     ((Data.Traversable.$fTraversableM2 @ f_abVHm @ a_abVIm)
                      `cast` (<f_abVHm a_abVIm>_R
                              ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <a_abVIm>_N
                              :: (f_abVHm a_abVIm -> f_abVHm a_abVIm :: *)
                                 ~R# (f_abVHm a_abVIm -> Rec1 f_abVHm a_abVIm :: *)))
                     (traverse
                        @ f_abVHm
                        $dTraversable_abVHn
                        @ m_abVIl
                        @ (m_abVIl a_abVIm)
                        @ a_abVIm
                        $dApplicative_abVHD
                        (id @ (m_abVIl a_abVIm))
                        (eta_B1
                         `cast` (GHC.Generics.N:Rec1[0]
                                     <*>_N <f_abVHm>_R <m_abVIl a_abVIm>_N
                                 :: (Rec1 f_abVHm (m_abVIl a_abVIm) :: *)
                                    ~R# (f_abVHm (m_abVIl a_abVIm) :: *))))}]
Data.Traversable.$fTraversableRec1_$csequence
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm)
      (@ (m_abVIl :: * -> *))
      (@ a_abVIm)
      ($dMonad_abVIo :: Monad m_abVIl)
      (eta_B1 :: Rec1 f_abVHm (m_abVIl a_abVIm)) ->
      let {
        $dApplicative_sbWCe [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
          :: Applicative m_abVIl
        [LclId]
        $dApplicative_sbWCe
          = GHC.Base.$p1Monad @ m_abVIl $dMonad_abVIo } in
      fmap
        @ m_abVIl
        (GHC.Base.$p1Applicative @ m_abVIl $dApplicative_sbWCe)
        @ (f_abVHm a_abVIm)
        @ (Rec1 f_abVHm a_abVIm)
        ((Data.Traversable.$fTraversableM2 @ f_abVHm @ a_abVIm)
         `cast` (<f_abVHm a_abVIm>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_abVHm>_R) <a_abVIm>_N
                 :: (f_abVHm a_abVIm -> f_abVHm a_abVIm :: *)
                    ~R# (f_abVHm a_abVIm -> Rec1 f_abVHm a_abVIm :: *)))
        (traverse
           @ f_abVHm
           $dTraversable_abVHn
           @ m_abVIl
           @ (m_abVIl a_abVIm)
           @ a_abVIm
           $dApplicative_sbWCe
           (id @ (m_abVIl a_abVIm))
           (eta_B1
            `cast` (GHC.Generics.N:Rec1[0]
                        <*>_N <f_abVHm>_R <m_abVIl a_abVIm>_N
                    :: (Rec1 f_abVHm (m_abVIl a_abVIm) :: *)
                       ~R# (f_abVHm (m_abVIl a_abVIm) :: *))))

-- RHS size: {terms: 15, types: 16, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *). Traversable f => Traversable (Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m,
 Unf=DFun: \ (@ (f_abVgT :: * -> *))
             (v_B1 :: Traversable f_abVgT) ->
       Data.Traversable.C:Traversable TYPE: Rec1 f_abVgT
                                      Data.Traversable.$fTraversableRec1_$cp1Traversable
                                        @ f_abVgT v_B1
                                      Data.Traversable.$fTraversableRec1_$cp2Traversable
                                        @ f_abVgT v_B1
                                      Data.Traversable.$fTraversableRec1_$ctraverse @ f_abVgT v_B1
                                      Data.Traversable.$fTraversableRec1_$csequenceA @ f_abVgT v_B1
                                      Data.Traversable.$fTraversableRec1_$cmapM @ f_abVgT v_B1
                                      Data.Traversable.$fTraversableRec1_$csequence @ f_abVgT v_B1]
Data.Traversable.$fTraversableRec1
  = \ (@ (f_abVHm :: * -> *))
      ($dTraversable_abVHn :: Traversable f_abVHm) ->
      Data.Traversable.C:Traversable
        @ (Rec1 f_abVHm)
        (Data.Traversable.$fTraversableRec1_$cp1Traversable
           @ f_abVHm $dTraversable_abVHn)
        (Data.Traversable.$fTraversableRec1_$cp2Traversable
           @ f_abVHm $dTraversable_abVHn)
        (Data.Traversable.$fTraversableRec1_$ctraverse
           @ f_abVHm $dTraversable_abVHn)
        (Data.Traversable.$fTraversableRec1_$csequenceA
           @ f_abVHm $dTraversable_abVHn)
        (Data.Traversable.$fTraversableRec1_$cmapM
           @ f_abVHm $dTraversable_abVHn)
        (Data.Traversable.$fTraversableRec1_$csequence
           @ f_abVHm $dTraversable_abVHn)

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversablePar1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Par1 (f a) -> f (Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVIV :: * -> *))
                 (@ a_abVIW)
                 ($dApplicative_abVIY [Occ=Once] :: Applicative f_abVIV)
                 (eta_B1 [Occ=Once] :: Par1 (f_abVIV a_abVIW)) ->
                 fmap
                   @ f_abVIV
                   (GHC.Base.$p1Applicative @ f_abVIV $dApplicative_abVIY)
                   @ a_abVIW
                   @ (Par1 a_abVIW)
                   ((\ (b1_abVof [Occ=Once] :: a_abVIW) -> b1_abVof)
                    `cast` (<a_abVIW>_R ->_R Sym (GHC.Generics.N:Par1[0] <a_abVIW>_R)
                            :: (a_abVIW -> a_abVIW :: *) ~R# (a_abVIW -> Par1 a_abVIW :: *)))
                   (eta_B1
                    `cast` (GHC.Generics.N:Par1[0] <f_abVIV a_abVIW>_R
                            :: (Par1 (f_abVIV a_abVIW) :: *) ~R# (f_abVIV a_abVIW :: *)))}]
Data.Traversable.$fTraversablePar1_$csequenceA
  = \ (@ (f_abVIV :: * -> *))
      (@ a_abVIW)
      ($dApplicative_abVIY :: Applicative f_abVIV)
      (eta_B1 :: Par1 (f_abVIV a_abVIW)) ->
      fmap
        @ f_abVIV
        (GHC.Base.$p1Applicative @ f_abVIV $dApplicative_abVIY)
        @ a_abVIW
        @ (Par1 a_abVIW)
        ((Data.Traversable.$fTraversableDual1 @ a_abVIW)
         `cast` (<a_abVIW>_R ->_R Sym (GHC.Generics.N:Par1[0] <a_abVIW>_R)
                 :: (a_abVIW -> a_abVIW :: *) ~R# (a_abVIW -> Par1 a_abVIW :: *)))
        (eta_B1
         `cast` (GHC.Generics.N:Par1[0] <f_abVIV a_abVIW>_R
                 :: (Par1 (f_abVIV a_abVIW) :: *) ~R# (f_abVIV a_abVIW :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversablePar1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Par1 a -> m (Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVJ7 :: * -> *))
                 (@ a_abVJ8)
                 (@ b_abVJ9)
                 ($dMonad_abVJb [Occ=OnceL] :: Monad m_abVJ7) ->
                 let {
                   $dApplicative_abVIL [Occ=OnceL] :: Applicative m_abVJ7
                   [LclId]
                   $dApplicative_abVIL
                     = GHC.Base.$p1Monad @ m_abVJ7 $dMonad_abVJb } in
                 \ (eta_B2 [Occ=Once!] :: a_abVJ8 -> m_abVJ7 b_abVJ9)
                   (eta1_B1 [Occ=Once] :: Par1 a_abVJ8) ->
                   fmap
                     @ m_abVJ7
                     (GHC.Base.$p1Applicative @ m_abVJ7 $dApplicative_abVIL)
                     @ b_abVJ9
                     @ (Par1 b_abVJ9)
                     ((\ (b1_abVof [Occ=Once] :: b_abVJ9) -> b1_abVof)
                      `cast` (<b_abVJ9>_R ->_R Sym (GHC.Generics.N:Par1[0] <b_abVJ9>_R)
                              :: (b_abVJ9 -> b_abVJ9 :: *) ~R# (b_abVJ9 -> Par1 b_abVJ9 :: *)))
                     (eta_B2
                        (eta1_B1
                         `cast` (GHC.Generics.N:Par1[0] <a_abVJ8>_R
                                 :: (Par1 a_abVJ8 :: *) ~R# (a_abVJ8 :: *))))}]
Data.Traversable.$fTraversablePar1_$cmapM
  = \ (@ (m_abVJ7 :: * -> *))
      (@ a_abVJ8)
      (@ b_abVJ9)
      ($dMonad_abVJb :: Monad m_abVJ7)
      (eta_B2 :: a_abVJ8 -> m_abVJ7 b_abVJ9)
      (eta1_B1 :: Par1 a_abVJ8) ->
      fmap
        @ m_abVJ7
        (GHC.Base.$p1Applicative
           @ m_abVJ7 (GHC.Base.$p1Monad @ m_abVJ7 $dMonad_abVJb))
        @ b_abVJ9
        @ (Par1 b_abVJ9)
        ((Data.Traversable.$fTraversableDual1 @ b_abVJ9)
         `cast` (<b_abVJ9>_R ->_R Sym (GHC.Generics.N:Par1[0] <b_abVJ9>_R)
                 :: (b_abVJ9 -> b_abVJ9 :: *) ~R# (b_abVJ9 -> Par1 b_abVJ9 :: *)))
        (eta_B2
           (eta1_B1
            `cast` (GHC.Generics.N:Par1[0] <a_abVJ8>_R
                    :: (Par1 a_abVJ8 :: *) ~R# (a_abVJ8 :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversablePar1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Par1 (m a) -> m (Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVJl :: * -> *))
                 (@ a_abVJm)
                 ($dMonad_abVJo [Occ=OnceL] :: Monad m_abVJl) ->
                 let {
                   $dApplicative_abVIY [Occ=OnceL] :: Applicative m_abVJl
                   [LclId]
                   $dApplicative_abVIY
                     = GHC.Base.$p1Monad @ m_abVJl $dMonad_abVJo } in
                 \ (eta_B1 [Occ=Once] :: Par1 (m_abVJl a_abVJm)) ->
                   fmap
                     @ m_abVJl
                     (GHC.Base.$p1Applicative @ m_abVJl $dApplicative_abVIY)
                     @ a_abVJm
                     @ (Par1 a_abVJm)
                     ((\ (b1_abVof [Occ=Once] :: a_abVJm) -> b1_abVof)
                      `cast` (<a_abVJm>_R ->_R Sym (GHC.Generics.N:Par1[0] <a_abVJm>_R)
                              :: (a_abVJm -> a_abVJm :: *) ~R# (a_abVJm -> Par1 a_abVJm :: *)))
                     (eta_B1
                      `cast` (GHC.Generics.N:Par1[0] <m_abVJl a_abVJm>_R
                              :: (Par1 (m_abVJl a_abVJm) :: *) ~R# (m_abVJl a_abVJm :: *)))}]
Data.Traversable.$fTraversablePar1_$csequence
  = \ (@ (m_abVJl :: * -> *))
      (@ a_abVJm)
      ($dMonad_abVJo :: Monad m_abVJl)
      (eta_B1 :: Par1 (m_abVJl a_abVJm)) ->
      fmap
        @ m_abVJl
        (GHC.Base.$p1Applicative
           @ m_abVJl (GHC.Base.$p1Monad @ m_abVJl $dMonad_abVJo))
        @ a_abVJm
        @ (Par1 a_abVJm)
        ((Data.Traversable.$fTraversableDual1 @ a_abVJm)
         `cast` (<a_abVJm>_R ->_R Sym (GHC.Generics.N:Par1[0] <a_abVJm>_R)
                 :: (a_abVJm -> a_abVJm :: *) ~R# (a_abVJm -> Par1 a_abVJm :: *)))
        (eta_B1
         `cast` (GHC.Generics.N:Par1[0] <m_abVJl a_abVJm>_R
                 :: (Par1 (m_abVJl a_abVJm) :: *) ~R# (m_abVJl a_abVJm :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Par1
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Par1
                                      GHC.Generics.$fFunctorPar1
                                      Data.Foldable.$fFoldablePar1
                                      Data.Traversable.$fTraversablePar1_$ctraverse
                                      Data.Traversable.$fTraversablePar1_$csequenceA
                                      Data.Traversable.$fTraversablePar1_$cmapM
                                      Data.Traversable.$fTraversablePar1_$csequence]
Data.Traversable.$fTraversablePar1
  = Data.Traversable.C:Traversable
      @ Par1
      GHC.Generics.$fFunctorPar1
      Data.Foldable.$fFoldablePar1
      Data.Traversable.$fTraversablePar1_$ctraverse
      Data.Traversable.$fTraversablePar1_$csequenceA
      Data.Traversable.$fTraversablePar1_$cmapM
      Data.Traversable.$fTraversablePar1_$csequence

-- RHS size: {terms: 10, types: 23, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableV1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> V1 a -> m (V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVK8 :: * -> *))
                 (@ a_abVK9)
                 (@ b_abVKa)
                 ($dMonad_abVKc [Occ=OnceL] :: Monad m_abVK8) ->
                 let {
                   $dApplicative_abVJL [Occ=OnceL] :: Applicative m_abVK8
                   [LclId]
                   $dApplicative_abVJL
                     = GHC.Base.$p1Monad @ m_abVK8 $dMonad_abVKc } in
                 \ _ [Occ=Dead] (z_abVog [Occ=Once] :: V1 a_abVK9) ->
                   pure
                     @ m_abVK8
                     $dApplicative_abVJL
                     @ (V1 b_abVKa)
                     (z_abVog
                      `cast` ((V1
                                 <*>_N Univ(phantom phantom <*>_N :: a_abVK9, b_abVKa))_R
                              :: (V1 a_abVK9 :: *) ~R# (V1 b_abVKa :: *)))}]
Data.Traversable.$fTraversableV1_$cmapM
  = \ (@ (m_abVK8 :: * -> *))
      (@ a_abVK9)
      (@ b_abVKa)
      ($dMonad_abVKc :: Monad m_abVK8)
      _ [Occ=Dead]
      (eta1_B1 :: V1 a_abVK9) ->
      pure
        @ m_abVK8
        (GHC.Base.$p1Monad @ m_abVK8 $dMonad_abVKc)
        @ (V1 b_abVKa)
        (eta1_B1
         `cast` ((V1
                    <*>_N Univ(phantom phantom <*>_N :: a_abVK9, b_abVKa))_R
                 :: (V1 a_abVK9 :: *) ~R# (V1 b_abVKa :: *)))

-- RHS size: {terms: 8, types: 19, coercions: 10, joins: 0/0}
Data.Traversable.$fTraversableV1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => V1 (m a) -> m (V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVKm :: * -> *))
                 (@ a_abVKn)
                 ($dMonad_abVKp [Occ=OnceL] :: Monad m_abVKm) ->
                 let {
                   $dApplicative_abVJZ [Occ=OnceL] :: Applicative m_abVKm
                   [LclId]
                   $dApplicative_abVJZ
                     = GHC.Base.$p1Monad @ m_abVKm $dMonad_abVKp } in
                 \ (z_abVog [Occ=Once] :: V1 (m_abVKm a_abVKn)) ->
                   pure
                     @ m_abVKm
                     $dApplicative_abVJZ
                     @ (V1 a_abVKn)
                     (z_abVog
                      `cast` ((V1
                                 <*>_N Univ(phantom phantom <*>_N :: m_abVKm a_abVKn, a_abVKn))_R
                              :: (V1 (m_abVKm a_abVKn) :: *) ~R# (V1 a_abVKn :: *)))}]
Data.Traversable.$fTraversableV1_$csequence
  = \ (@ (m_abVKm :: * -> *))
      (@ a_abVKn)
      ($dMonad_abVKp :: Monad m_abVKm)
      (eta_B1 :: V1 (m_abVKm a_abVKn)) ->
      pure
        @ m_abVKm
        (GHC.Base.$p1Monad @ m_abVKm $dMonad_abVKp)
        @ (V1 a_abVKn)
        (eta_B1
         `cast` ((V1
                    <*>_N Univ(phantom phantom <*>_N :: m_abVKm a_abVKn, a_abVKn))_R
                 :: (V1 (m_abVKm a_abVKn) :: *) ~R# (V1 a_abVKn :: *)))

-- RHS size: {terms: 7, types: 18, coercions: 10, joins: 0/0}
$fTraversableV2_rbWTT
  :: forall (f :: * -> *) a. Applicative f => V1 (f a) -> f (V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []]
$fTraversableV2_rbWTT
  = \ (@ (f_abVJW :: * -> *))
      (@ a_abVJX)
      ($dApplicative_abVJZ :: Applicative f_abVJW)
      (z_abVog :: V1 (f_abVJW a_abVJX)) ->
      pure
        @ f_abVJW
        $dApplicative_abVJZ
        @ (V1 a_abVJX)
        (z_abVog
         `cast` ((V1
                    <*>_N Univ(phantom phantom <*>_N :: f_abVJW a_abVJX, a_abVJX))_R
                 :: (V1 (f_abVJW a_abVJX) :: *) ~R# (V1 a_abVJX :: *)))

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable V1
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: V1
                                      GHC.Generics.$fFunctorV1
                                      Data.Foldable.$fFoldableV1
                                      Data.Traversable.$fTraversableV1_$ctraverse
                                      \ (@ (f_abVJW :: * -> *))
                                        (@ a_abVJX)
                                        ($dApplicative_abVJZ [Occ=Once] :: Applicative f_abVJW)
                                        (z_abVog [Occ=Once] :: V1 (f_abVJW a_abVJX)) ->
                                        pure
                                          @ f_abVJW
                                          $dApplicative_abVJZ
                                          @ (V1 a_abVJX)
                                          (z_abVog
                                           `cast` ((V1
                                                      <*>_N
                                                      Univ(phantom phantom <*>_N
                                                           :: f_abVJW a_abVJX, a_abVJX))_R
                                                   :: (V1 (f_abVJW a_abVJX) :: *)
                                                      ~R# (V1 a_abVJX :: *)))
                                      Data.Traversable.$fTraversableV1_$cmapM
                                      Data.Traversable.$fTraversableV1_$csequence]
Data.Traversable.$fTraversableV1
  = Data.Traversable.C:Traversable
      @ V1
      GHC.Generics.$fFunctorV1
      Data.Foldable.$fFoldableV1
      Data.Traversable.$fTraversableV1_$ctraverse
      $fTraversableV2_rbWTT
      Data.Traversable.$fTraversableV1_$cmapM
      Data.Traversable.$fTraversableV1_$csequence

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableIdentity_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Identity (f a) -> f (Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVKW :: * -> *))
                 (@ a_abVKX)
                 ($dApplicative_abVKZ [Occ=Once] :: Applicative f_abVKW)
                 (eta_B1 [Occ=Once] :: Identity (f_abVKW a_abVKX)) ->
                 fmap
                   @ f_abVKW
                   (GHC.Base.$p1Applicative @ f_abVKW $dApplicative_abVKZ)
                   @ a_abVKX
                   @ (Identity a_abVKX)
                   ((\ (b1_abVoj [Occ=Once] :: a_abVKX) -> b1_abVoj)
                    `cast` (<a_abVKX>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abVKX>_R)
                            :: (a_abVKX -> a_abVKX :: *)
                               ~R# (a_abVKX -> Identity a_abVKX :: *)))
                   (eta_B1
                    `cast` (Data.Functor.Identity.N:Identity[0] <f_abVKW a_abVKX>_R
                            :: (Identity (f_abVKW a_abVKX) :: *) ~R# (f_abVKW a_abVKX :: *)))}]
Data.Traversable.$fTraversableIdentity_$csequenceA
  = \ (@ (f_abVKW :: * -> *))
      (@ a_abVKX)
      ($dApplicative_abVKZ :: Applicative f_abVKW)
      (eta_B1 :: Identity (f_abVKW a_abVKX)) ->
      fmap
        @ f_abVKW
        (GHC.Base.$p1Applicative @ f_abVKW $dApplicative_abVKZ)
        @ a_abVKX
        @ (Identity a_abVKX)
        ((Data.Traversable.$fTraversableDual1 @ a_abVKX)
         `cast` (<a_abVKX>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abVKX>_R)
                 :: (a_abVKX -> a_abVKX :: *)
                    ~R# (a_abVKX -> Identity a_abVKX :: *)))
        (eta_B1
         `cast` (Data.Functor.Identity.N:Identity[0] <f_abVKW a_abVKX>_R
                 :: (Identity (f_abVKW a_abVKX) :: *) ~R# (f_abVKW a_abVKX :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableIdentity_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Identity a -> m (Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVL8 :: * -> *))
                 (@ a_abVL9)
                 (@ b_abVLa)
                 ($dMonad_abVLc [Occ=OnceL] :: Monad m_abVL8) ->
                 let {
                   $dApplicative_abVKM [Occ=OnceL] :: Applicative m_abVL8
                   [LclId]
                   $dApplicative_abVKM
                     = GHC.Base.$p1Monad @ m_abVL8 $dMonad_abVLc } in
                 \ (eta_B2 [Occ=Once!] :: a_abVL9 -> m_abVL8 b_abVLa)
                   (eta1_B1 [Occ=Once] :: Identity a_abVL9) ->
                   fmap
                     @ m_abVL8
                     (GHC.Base.$p1Applicative @ m_abVL8 $dApplicative_abVKM)
                     @ b_abVLa
                     @ (Identity b_abVLa)
                     ((\ (b1_abVoj [Occ=Once] :: b_abVLa) -> b1_abVoj)
                      `cast` (<b_abVLa>_R
                              ->_R Sym (Data.Functor.Identity.N:Identity[0] <b_abVLa>_R)
                              :: (b_abVLa -> b_abVLa :: *)
                                 ~R# (b_abVLa -> Identity b_abVLa :: *)))
                     (eta_B2
                        (eta1_B1
                         `cast` (Data.Functor.Identity.N:Identity[0] <a_abVL9>_R
                                 :: (Identity a_abVL9 :: *) ~R# (a_abVL9 :: *))))}]
Data.Traversable.$fTraversableIdentity_$cmapM
  = \ (@ (m_abVL8 :: * -> *))
      (@ a_abVL9)
      (@ b_abVLa)
      ($dMonad_abVLc :: Monad m_abVL8)
      (eta_B2 :: a_abVL9 -> m_abVL8 b_abVLa)
      (eta1_B1 :: Identity a_abVL9) ->
      fmap
        @ m_abVL8
        (GHC.Base.$p1Applicative
           @ m_abVL8 (GHC.Base.$p1Monad @ m_abVL8 $dMonad_abVLc))
        @ b_abVLa
        @ (Identity b_abVLa)
        ((Data.Traversable.$fTraversableDual1 @ b_abVLa)
         `cast` (<b_abVLa>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <b_abVLa>_R)
                 :: (b_abVLa -> b_abVLa :: *)
                    ~R# (b_abVLa -> Identity b_abVLa :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Functor.Identity.N:Identity[0] <a_abVL9>_R
                    :: (Identity a_abVL9 :: *) ~R# (a_abVL9 :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableIdentity_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     Identity (m a) -> m (Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVLm :: * -> *))
                 (@ a_abVLn)
                 ($dMonad_abVLp [Occ=OnceL] :: Monad m_abVLm) ->
                 let {
                   $dApplicative_abVKZ [Occ=OnceL] :: Applicative m_abVLm
                   [LclId]
                   $dApplicative_abVKZ
                     = GHC.Base.$p1Monad @ m_abVLm $dMonad_abVLp } in
                 \ (eta_B1 [Occ=Once] :: Identity (m_abVLm a_abVLn)) ->
                   fmap
                     @ m_abVLm
                     (GHC.Base.$p1Applicative @ m_abVLm $dApplicative_abVKZ)
                     @ a_abVLn
                     @ (Identity a_abVLn)
                     ((\ (b1_abVoj [Occ=Once] :: a_abVLn) -> b1_abVoj)
                      `cast` (<a_abVLn>_R
                              ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abVLn>_R)
                              :: (a_abVLn -> a_abVLn :: *)
                                 ~R# (a_abVLn -> Identity a_abVLn :: *)))
                     (eta_B1
                      `cast` (Data.Functor.Identity.N:Identity[0] <m_abVLm a_abVLn>_R
                              :: (Identity (m_abVLm a_abVLn) :: *) ~R# (m_abVLm a_abVLn :: *)))}]
Data.Traversable.$fTraversableIdentity_$csequence
  = \ (@ (m_abVLm :: * -> *))
      (@ a_abVLn)
      ($dMonad_abVLp :: Monad m_abVLm)
      (eta_B1 :: Identity (m_abVLm a_abVLn)) ->
      fmap
        @ m_abVLm
        (GHC.Base.$p1Applicative
           @ m_abVLm (GHC.Base.$p1Monad @ m_abVLm $dMonad_abVLp))
        @ a_abVLn
        @ (Identity a_abVLn)
        ((Data.Traversable.$fTraversableDual1 @ a_abVLn)
         `cast` (<a_abVLn>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_abVLn>_R)
                 :: (a_abVLn -> a_abVLn :: *)
                    ~R# (a_abVLn -> Identity a_abVLn :: *)))
        (eta_B1
         `cast` (Data.Functor.Identity.N:Identity[0] <m_abVLm a_abVLn>_R
                 :: (Identity (m_abVLm a_abVLn) :: *) ~R# (m_abVLm a_abVLn :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Identity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Identity
                                      Data.Functor.Identity.$fFunctorIdentity
                                      Data.Functor.Identity.$fFoldableIdentity
                                      Data.Traversable.$fTraversableIdentity_$ctraverse
                                      Data.Traversable.$fTraversableIdentity_$csequenceA
                                      Data.Traversable.$fTraversableIdentity_$cmapM
                                      Data.Traversable.$fTraversableIdentity_$csequence]
Data.Traversable.$fTraversableIdentity
  = Data.Traversable.C:Traversable
      @ Identity
      Data.Functor.Identity.$fFunctorIdentity
      Data.Functor.Identity.$fFoldableIdentity
      Data.Traversable.$fTraversableIdentity_$ctraverse
      Data.Traversable.$fTraversableIdentity_$csequenceA
      Data.Traversable.$fTraversableIdentity_$cmapM
      Data.Traversable.$fTraversableIdentity_$csequence

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Product (f a) -> f (Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVQg :: * -> *))
                 (@ a_abVQh)
                 ($dApplicative_abVQj [Occ=Once] :: Applicative f_abVQg)
                 (eta_B1 [Occ=Once] :: Product (f_abVQg a_abVQh)) ->
                 fmap
                   @ f_abVQg
                   (GHC.Base.$p1Applicative @ f_abVQg $dApplicative_abVQj)
                   @ a_abVQh
                   @ (Product a_abVQh)
                   ((\ (v_X5 [Occ=Once] :: a_abVQh) -> v_X5)
                    `cast` (<a_abVQh>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_abVQh>_R)
                            :: (a_abVQh -> a_abVQh :: *)
                               ~R# (a_abVQh -> Product a_abVQh :: *)))
                   (eta_B1
                    `cast` (Data.Semigroup.Internal.N:Product[0] <f_abVQg a_abVQh>_R
                            :: (Product (f_abVQg a_abVQh) :: *) ~R# (f_abVQg a_abVQh :: *)))}]
Data.Traversable.$fTraversableProduct_$csequenceA
  = \ (@ (f_abVQg :: * -> *))
      (@ a_abVQh)
      ($dApplicative_abVQj :: Applicative f_abVQg)
      (eta_B1 :: Product (f_abVQg a_abVQh)) ->
      fmap
        @ f_abVQg
        (GHC.Base.$p1Applicative @ f_abVQg $dApplicative_abVQj)
        @ a_abVQh
        @ (Product a_abVQh)
        ((Data.Traversable.$fTraversableDual1 @ a_abVQh)
         `cast` (<a_abVQh>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_abVQh>_R)
                 :: (a_abVQh -> a_abVQh :: *)
                    ~R# (a_abVQh -> Product a_abVQh :: *)))
        (eta_B1
         `cast` (Data.Semigroup.Internal.N:Product[0] <f_abVQg a_abVQh>_R
                 :: (Product (f_abVQg a_abVQh) :: *) ~R# (f_abVQg a_abVQh :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Product a -> m (Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVQs :: * -> *))
                 (@ a_abVQt)
                 (@ b_abVQu)
                 ($dMonad_abVQw [Occ=OnceL] :: Monad m_abVQs) ->
                 let {
                   $dApplicative_abVQ6 [Occ=OnceL] :: Applicative m_abVQs
                   [LclId]
                   $dApplicative_abVQ6
                     = GHC.Base.$p1Monad @ m_abVQs $dMonad_abVQw } in
                 \ (eta_B2 [Occ=Once!] :: a_abVQt -> m_abVQs b_abVQu)
                   (eta1_B1 [Occ=Once] :: Product a_abVQt) ->
                   fmap
                     @ m_abVQs
                     (GHC.Base.$p1Applicative @ m_abVQs $dApplicative_abVQ6)
                     @ b_abVQu
                     @ (Product b_abVQu)
                     ((\ (v_X5 [Occ=Once] :: b_abVQu) -> v_X5)
                      `cast` (<b_abVQu>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Product[0] <b_abVQu>_R)
                              :: (b_abVQu -> b_abVQu :: *)
                                 ~R# (b_abVQu -> Product b_abVQu :: *)))
                     (eta_B2
                        (eta1_B1
                         `cast` (Data.Semigroup.Internal.N:Product[0] <a_abVQt>_R
                                 :: (Product a_abVQt :: *) ~R# (a_abVQt :: *))))}]
Data.Traversable.$fTraversableProduct_$cmapM
  = \ (@ (m_abVQs :: * -> *))
      (@ a_abVQt)
      (@ b_abVQu)
      ($dMonad_abVQw :: Monad m_abVQs)
      (eta_B2 :: a_abVQt -> m_abVQs b_abVQu)
      (eta1_B1 :: Product a_abVQt) ->
      fmap
        @ m_abVQs
        (GHC.Base.$p1Applicative
           @ m_abVQs (GHC.Base.$p1Monad @ m_abVQs $dMonad_abVQw))
        @ b_abVQu
        @ (Product b_abVQu)
        ((Data.Traversable.$fTraversableDual1 @ b_abVQu)
         `cast` (<b_abVQu>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Product[0] <b_abVQu>_R)
                 :: (b_abVQu -> b_abVQu :: *)
                    ~R# (b_abVQu -> Product b_abVQu :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Semigroup.Internal.N:Product[0] <a_abVQt>_R
                    :: (Product a_abVQt :: *) ~R# (a_abVQt :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     Product (m a) -> m (Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVQG :: * -> *))
                 (@ a_abVQH)
                 ($dMonad_abVQJ [Occ=OnceL] :: Monad m_abVQG) ->
                 let {
                   $dApplicative_abVQj [Occ=OnceL] :: Applicative m_abVQG
                   [LclId]
                   $dApplicative_abVQj
                     = GHC.Base.$p1Monad @ m_abVQG $dMonad_abVQJ } in
                 \ (eta_B1 [Occ=Once] :: Product (m_abVQG a_abVQH)) ->
                   fmap
                     @ m_abVQG
                     (GHC.Base.$p1Applicative @ m_abVQG $dApplicative_abVQj)
                     @ a_abVQH
                     @ (Product a_abVQH)
                     ((\ (v_X5 [Occ=Once] :: a_abVQH) -> v_X5)
                      `cast` (<a_abVQH>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_abVQH>_R)
                              :: (a_abVQH -> a_abVQH :: *)
                                 ~R# (a_abVQH -> Product a_abVQH :: *)))
                     (eta_B1
                      `cast` (Data.Semigroup.Internal.N:Product[0] <m_abVQG a_abVQH>_R
                              :: (Product (m_abVQG a_abVQH) :: *) ~R# (m_abVQG a_abVQH :: *)))}]
Data.Traversable.$fTraversableProduct_$csequence
  = \ (@ (m_abVQG :: * -> *))
      (@ a_abVQH)
      ($dMonad_abVQJ :: Monad m_abVQG)
      (eta_B1 :: Product (m_abVQG a_abVQH)) ->
      fmap
        @ m_abVQG
        (GHC.Base.$p1Applicative
           @ m_abVQG (GHC.Base.$p1Monad @ m_abVQG $dMonad_abVQJ))
        @ a_abVQH
        @ (Product a_abVQH)
        ((Data.Traversable.$fTraversableDual1 @ a_abVQH)
         `cast` (<a_abVQH>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_abVQH>_R)
                 :: (a_abVQH -> a_abVQH :: *)
                    ~R# (a_abVQH -> Product a_abVQH :: *)))
        (eta_B1
         `cast` (Data.Semigroup.Internal.N:Product[0] <m_abVQG a_abVQH>_R
                 :: (Product (m_abVQG a_abVQH) :: *) ~R# (m_abVQG a_abVQH :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Product
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Product
                                      Data.Semigroup.Internal.$fFunctorProduct
                                      Data.Foldable.$fFoldableProduct
                                      Data.Traversable.$fTraversableProduct_$ctraverse
                                      Data.Traversable.$fTraversableProduct_$csequenceA
                                      Data.Traversable.$fTraversableProduct_$cmapM
                                      Data.Traversable.$fTraversableProduct_$csequence]
Data.Traversable.$fTraversableProduct
  = Data.Traversable.C:Traversable
      @ Product
      Data.Semigroup.Internal.$fFunctorProduct
      Data.Foldable.$fFoldableProduct
      Data.Traversable.$fTraversableProduct_$ctraverse
      Data.Traversable.$fTraversableProduct_$csequenceA
      Data.Traversable.$fTraversableProduct_$cmapM
      Data.Traversable.$fTraversableProduct_$csequence

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. Applicative f => Sum (f a) -> f (Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVRg :: * -> *))
                 (@ a_abVRh)
                 ($dApplicative_abVRj [Occ=Once] :: Applicative f_abVRg)
                 (eta_B1 [Occ=Once] :: Sum (f_abVRg a_abVRh)) ->
                 fmap
                   @ f_abVRg
                   (GHC.Base.$p1Applicative @ f_abVRg $dApplicative_abVRj)
                   @ a_abVRh
                   @ (Sum a_abVRh)
                   ((\ (v_X5 [Occ=Once] :: a_abVRh) -> v_X5)
                    `cast` (<a_abVRh>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_abVRh>_R)
                            :: (a_abVRh -> a_abVRh :: *) ~R# (a_abVRh -> Sum a_abVRh :: *)))
                   (eta_B1
                    `cast` (Data.Semigroup.Internal.N:Sum[0] <f_abVRg a_abVRh>_R
                            :: (Sum (f_abVRg a_abVRh) :: *) ~R# (f_abVRg a_abVRh :: *)))}]
Data.Traversable.$fTraversableSum_$csequenceA
  = \ (@ (f_abVRg :: * -> *))
      (@ a_abVRh)
      ($dApplicative_abVRj :: Applicative f_abVRg)
      (eta_B1 :: Sum (f_abVRg a_abVRh)) ->
      fmap
        @ f_abVRg
        (GHC.Base.$p1Applicative @ f_abVRg $dApplicative_abVRj)
        @ a_abVRh
        @ (Sum a_abVRh)
        ((Data.Traversable.$fTraversableDual1 @ a_abVRh)
         `cast` (<a_abVRh>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_abVRh>_R)
                 :: (a_abVRh -> a_abVRh :: *) ~R# (a_abVRh -> Sum a_abVRh :: *)))
        (eta_B1
         `cast` (Data.Semigroup.Internal.N:Sum[0] <f_abVRg a_abVRh>_R
                 :: (Sum (f_abVRg a_abVRh) :: *) ~R# (f_abVRg a_abVRh :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Sum a -> m (Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVRs :: * -> *))
                 (@ a_abVRt)
                 (@ b_abVRu)
                 ($dMonad_abVRw [Occ=OnceL] :: Monad m_abVRs) ->
                 let {
                   $dApplicative_abVR6 [Occ=OnceL] :: Applicative m_abVRs
                   [LclId]
                   $dApplicative_abVR6
                     = GHC.Base.$p1Monad @ m_abVRs $dMonad_abVRw } in
                 \ (eta_B2 [Occ=Once!] :: a_abVRt -> m_abVRs b_abVRu)
                   (eta1_B1 [Occ=Once] :: Sum a_abVRt) ->
                   fmap
                     @ m_abVRs
                     (GHC.Base.$p1Applicative @ m_abVRs $dApplicative_abVR6)
                     @ b_abVRu
                     @ (Sum b_abVRu)
                     ((\ (v_X5 [Occ=Once] :: b_abVRu) -> v_X5)
                      `cast` (<b_abVRu>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <b_abVRu>_R)
                              :: (b_abVRu -> b_abVRu :: *) ~R# (b_abVRu -> Sum b_abVRu :: *)))
                     (eta_B2
                        (eta1_B1
                         `cast` (Data.Semigroup.Internal.N:Sum[0] <a_abVRt>_R
                                 :: (Sum a_abVRt :: *) ~R# (a_abVRt :: *))))}]
Data.Traversable.$fTraversableSum_$cmapM
  = \ (@ (m_abVRs :: * -> *))
      (@ a_abVRt)
      (@ b_abVRu)
      ($dMonad_abVRw :: Monad m_abVRs)
      (eta_B2 :: a_abVRt -> m_abVRs b_abVRu)
      (eta1_B1 :: Sum a_abVRt) ->
      fmap
        @ m_abVRs
        (GHC.Base.$p1Applicative
           @ m_abVRs (GHC.Base.$p1Monad @ m_abVRs $dMonad_abVRw))
        @ b_abVRu
        @ (Sum b_abVRu)
        ((Data.Traversable.$fTraversableDual1 @ b_abVRu)
         `cast` (<b_abVRu>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <b_abVRu>_R)
                 :: (b_abVRu -> b_abVRu :: *) ~R# (b_abVRu -> Sum b_abVRu :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Semigroup.Internal.N:Sum[0] <a_abVRt>_R
                    :: (Sum a_abVRt :: *) ~R# (a_abVRt :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Sum (m a) -> m (Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVRG :: * -> *))
                 (@ a_abVRH)
                 ($dMonad_abVRJ [Occ=OnceL] :: Monad m_abVRG) ->
                 let {
                   $dApplicative_abVRj [Occ=OnceL] :: Applicative m_abVRG
                   [LclId]
                   $dApplicative_abVRj
                     = GHC.Base.$p1Monad @ m_abVRG $dMonad_abVRJ } in
                 \ (eta_B1 [Occ=Once] :: Sum (m_abVRG a_abVRH)) ->
                   fmap
                     @ m_abVRG
                     (GHC.Base.$p1Applicative @ m_abVRG $dApplicative_abVRj)
                     @ a_abVRH
                     @ (Sum a_abVRH)
                     ((\ (v_X5 [Occ=Once] :: a_abVRH) -> v_X5)
                      `cast` (<a_abVRH>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_abVRH>_R)
                              :: (a_abVRH -> a_abVRH :: *) ~R# (a_abVRH -> Sum a_abVRH :: *)))
                     (eta_B1
                      `cast` (Data.Semigroup.Internal.N:Sum[0] <m_abVRG a_abVRH>_R
                              :: (Sum (m_abVRG a_abVRH) :: *) ~R# (m_abVRG a_abVRH :: *)))}]
Data.Traversable.$fTraversableSum_$csequence
  = \ (@ (m_abVRG :: * -> *))
      (@ a_abVRH)
      ($dMonad_abVRJ :: Monad m_abVRG)
      (eta_B1 :: Sum (m_abVRG a_abVRH)) ->
      fmap
        @ m_abVRG
        (GHC.Base.$p1Applicative
           @ m_abVRG (GHC.Base.$p1Monad @ m_abVRG $dMonad_abVRJ))
        @ a_abVRH
        @ (Sum a_abVRH)
        ((Data.Traversable.$fTraversableDual1 @ a_abVRH)
         `cast` (<a_abVRH>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_abVRH>_R)
                 :: (a_abVRH -> a_abVRH :: *) ~R# (a_abVRH -> Sum a_abVRH :: *)))
        (eta_B1
         `cast` (Data.Semigroup.Internal.N:Sum[0] <m_abVRG a_abVRH>_R
                 :: (Sum (m_abVRG a_abVRH) :: *) ~R# (m_abVRG a_abVRH :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Sum
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Sum
                                      Data.Semigroup.Internal.$fFunctorSum
                                      Data.Foldable.$fFoldableSum
                                      Data.Traversable.$fTraversableSum_$ctraverse
                                      Data.Traversable.$fTraversableSum_$csequenceA
                                      Data.Traversable.$fTraversableSum_$cmapM
                                      Data.Traversable.$fTraversableSum_$csequence]
Data.Traversable.$fTraversableSum
  = Data.Traversable.C:Traversable
      @ Sum
      Data.Semigroup.Internal.$fFunctorSum
      Data.Foldable.$fFoldableSum
      Data.Traversable.$fTraversableSum_$ctraverse
      Data.Traversable.$fTraversableSum_$csequenceA
      Data.Traversable.$fTraversableSum_$cmapM
      Data.Traversable.$fTraversableSum_$csequence

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableDual_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Dual (f a) -> f (Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVSg :: * -> *))
                 (@ a_abVSh)
                 ($dApplicative_abVSj [Occ=Once] :: Applicative f_abVSg)
                 (eta_B1 [Occ=Once] :: Dual (f_abVSg a_abVSh)) ->
                 fmap
                   @ f_abVSg
                   (GHC.Base.$p1Applicative @ f_abVSg $dApplicative_abVSj)
                   @ a_abVSh
                   @ (Dual a_abVSh)
                   ((\ (v_X5 [Occ=Once] :: a_abVSh) -> v_X5)
                    `cast` (<a_abVSh>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_abVSh>_R)
                            :: (a_abVSh -> a_abVSh :: *) ~R# (a_abVSh -> Dual a_abVSh :: *)))
                   (eta_B1
                    `cast` (Data.Semigroup.Internal.N:Dual[0] <f_abVSg a_abVSh>_R
                            :: (Dual (f_abVSg a_abVSh) :: *) ~R# (f_abVSg a_abVSh :: *)))}]
Data.Traversable.$fTraversableDual_$csequenceA
  = \ (@ (f_abVSg :: * -> *))
      (@ a_abVSh)
      ($dApplicative_abVSj :: Applicative f_abVSg)
      (eta_B1 :: Dual (f_abVSg a_abVSh)) ->
      fmap
        @ f_abVSg
        (GHC.Base.$p1Applicative @ f_abVSg $dApplicative_abVSj)
        @ a_abVSh
        @ (Dual a_abVSh)
        ((Data.Traversable.$fTraversableDual1 @ a_abVSh)
         `cast` (<a_abVSh>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_abVSh>_R)
                 :: (a_abVSh -> a_abVSh :: *) ~R# (a_abVSh -> Dual a_abVSh :: *)))
        (eta_B1
         `cast` (Data.Semigroup.Internal.N:Dual[0] <f_abVSg a_abVSh>_R
                 :: (Dual (f_abVSg a_abVSh) :: *) ~R# (f_abVSg a_abVSh :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Traversable.$fTraversableDual_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Dual a -> m (Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVSs :: * -> *))
                 (@ a_abVSt)
                 (@ b_abVSu)
                 ($dMonad_abVSw [Occ=OnceL] :: Monad m_abVSs) ->
                 let {
                   $dApplicative_abVS6 [Occ=OnceL] :: Applicative m_abVSs
                   [LclId]
                   $dApplicative_abVS6
                     = GHC.Base.$p1Monad @ m_abVSs $dMonad_abVSw } in
                 \ (eta_B2 [Occ=Once!] :: a_abVSt -> m_abVSs b_abVSu)
                   (eta1_B1 [Occ=Once] :: Dual a_abVSt) ->
                   fmap
                     @ m_abVSs
                     (GHC.Base.$p1Applicative @ m_abVSs $dApplicative_abVS6)
                     @ b_abVSu
                     @ (Dual b_abVSu)
                     ((\ (v_X5 [Occ=Once] :: b_abVSu) -> v_X5)
                      `cast` (<b_abVSu>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <b_abVSu>_R)
                              :: (b_abVSu -> b_abVSu :: *) ~R# (b_abVSu -> Dual b_abVSu :: *)))
                     (eta_B2
                        (eta1_B1
                         `cast` (Data.Semigroup.Internal.N:Dual[0] <a_abVSt>_R
                                 :: (Dual a_abVSt :: *) ~R# (a_abVSt :: *))))}]
Data.Traversable.$fTraversableDual_$cmapM
  = \ (@ (m_abVSs :: * -> *))
      (@ a_abVSt)
      (@ b_abVSu)
      ($dMonad_abVSw :: Monad m_abVSs)
      (eta_B2 :: a_abVSt -> m_abVSs b_abVSu)
      (eta1_B1 :: Dual a_abVSt) ->
      fmap
        @ m_abVSs
        (GHC.Base.$p1Applicative
           @ m_abVSs (GHC.Base.$p1Monad @ m_abVSs $dMonad_abVSw))
        @ b_abVSu
        @ (Dual b_abVSu)
        ((Data.Traversable.$fTraversableDual1 @ b_abVSu)
         `cast` (<b_abVSu>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <b_abVSu>_R)
                 :: (b_abVSu -> b_abVSu :: *) ~R# (b_abVSu -> Dual b_abVSu :: *)))
        (eta_B2
           (eta1_B1
            `cast` (Data.Semigroup.Internal.N:Dual[0] <a_abVSt>_R
                    :: (Dual a_abVSt :: *) ~R# (a_abVSt :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableDual_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Dual (m a) -> m (Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVSG :: * -> *))
                 (@ a_abVSH)
                 ($dMonad_abVSJ [Occ=OnceL] :: Monad m_abVSG) ->
                 let {
                   $dApplicative_abVSj [Occ=OnceL] :: Applicative m_abVSG
                   [LclId]
                   $dApplicative_abVSj
                     = GHC.Base.$p1Monad @ m_abVSG $dMonad_abVSJ } in
                 \ (eta_B1 [Occ=Once] :: Dual (m_abVSG a_abVSH)) ->
                   fmap
                     @ m_abVSG
                     (GHC.Base.$p1Applicative @ m_abVSG $dApplicative_abVSj)
                     @ a_abVSH
                     @ (Dual a_abVSH)
                     ((\ (v_X5 [Occ=Once] :: a_abVSH) -> v_X5)
                      `cast` (<a_abVSH>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_abVSH>_R)
                              :: (a_abVSH -> a_abVSH :: *) ~R# (a_abVSH -> Dual a_abVSH :: *)))
                     (eta_B1
                      `cast` (Data.Semigroup.Internal.N:Dual[0] <m_abVSG a_abVSH>_R
                              :: (Dual (m_abVSG a_abVSH) :: *) ~R# (m_abVSG a_abVSH :: *)))}]
Data.Traversable.$fTraversableDual_$csequence
  = \ (@ (m_abVSG :: * -> *))
      (@ a_abVSH)
      ($dMonad_abVSJ :: Monad m_abVSG)
      (eta_B1 :: Dual (m_abVSG a_abVSH)) ->
      fmap
        @ m_abVSG
        (GHC.Base.$p1Applicative
           @ m_abVSG (GHC.Base.$p1Monad @ m_abVSG $dMonad_abVSJ))
        @ a_abVSH
        @ (Dual a_abVSH)
        ((Data.Traversable.$fTraversableDual1 @ a_abVSH)
         `cast` (<a_abVSH>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_abVSH>_R)
                 :: (a_abVSH -> a_abVSH :: *) ~R# (a_abVSH -> Dual a_abVSH :: *)))
        (eta_B1
         `cast` (Data.Semigroup.Internal.N:Dual[0] <m_abVSG a_abVSH>_R
                 :: (Dual (m_abVSG a_abVSH) :: *) ~R# (m_abVSG a_abVSH :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Dual
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Dual
                                      Data.Semigroup.Internal.$fFunctorDual
                                      Data.Foldable.$fFoldableDual
                                      Data.Traversable.$fTraversableDual_$ctraverse
                                      Data.Traversable.$fTraversableDual_$csequenceA
                                      Data.Traversable.$fTraversableDual_$cmapM
                                      Data.Traversable.$fTraversableDual_$csequence]
Data.Traversable.$fTraversableDual
  = Data.Traversable.C:Traversable
      @ Dual
      Data.Semigroup.Internal.$fFunctorDual
      Data.Foldable.$fFoldableDual
      Data.Traversable.$fTraversableDual_$ctraverse
      Data.Traversable.$fTraversableDual_$csequenceA
      Data.Traversable.$fTraversableDual_$cmapM
      Data.Traversable.$fTraversableDual_$csequence

-- RHS size: {terms: 11, types: 27, coercions: 12, joins: 0/0}
Data.Traversable.$fTraversableConst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a b.
     Monad m2 =>
     (a -> m2 b) -> Const m1 a -> m2 (Const m1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ m_abVSR)
                 (@ (m1_abVTx :: * -> *))
                 (@ a_abVTy)
                 (@ b_abVTz)
                 ($dMonad_abVTB [Occ=OnceL] :: Monad m1_abVTx) ->
                 let {
                   $dApplicative_abVT7 [Occ=OnceL] :: Applicative m1_abVTx
                   [LclId]
                   $dApplicative_abVT7
                     = GHC.Base.$p1Monad @ m1_abVTx $dMonad_abVTB } in
                 \ _ [Occ=Dead] (ds1_dbW83 [Occ=Once] :: Const m_abVSR a_abVTy) ->
                   pure
                     @ m1_abVTx
                     $dApplicative_abVT7
                     @ (Const m_abVSR b_abVTz)
                     (ds1_dbW83
                      `cast` (Data.Functor.Const.N:Const[0]
                                  <*>_N <m_abVSR>_R <a_abVTy>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                                           <*>_N
                                                                           <m_abVSR>_R
                                                                           <b_abVTz>_P)
                              :: (Const m_abVSR a_abVTy :: *)
                                 ~R# (Const m_abVSR b_abVTz :: *)))}]
Data.Traversable.$fTraversableConst_$cmapM
  = \ (@ m_abVSR)
      (@ (m1_abVTx :: * -> *))
      (@ a_abVTy)
      (@ b_abVTz)
      ($dMonad_abVTB :: Monad m1_abVTx)
      _ [Occ=Dead]
      (eta1_B1 :: Const m_abVSR a_abVTy) ->
      pure
        @ m1_abVTx
        (GHC.Base.$p1Monad @ m1_abVTx $dMonad_abVTB)
        @ (Const m_abVSR b_abVTz)
        (eta1_B1
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N <m_abVSR>_R <a_abVTy>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <m_abVSR>_R <b_abVTz>_P)
                 :: (Const m_abVSR a_abVTy :: *) ~R# (Const m_abVSR b_abVTz :: *)))

-- RHS size: {terms: 9, types: 23, coercions: 13, joins: 0/0}
Data.Traversable.$fTraversableConst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a.
     Monad m2 =>
     Const m1 (m2 a) -> m2 (Const m1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ m_abVSR)
                 (@ (m1_abVTL :: * -> *))
                 (@ a_abVTM)
                 ($dMonad_abVTO [Occ=OnceL] :: Monad m1_abVTL) ->
                 let {
                   $dApplicative_abVTo [Occ=OnceL] :: Applicative m1_abVTL
                   [LclId]
                   $dApplicative_abVTo
                     = GHC.Base.$p1Monad @ m1_abVTL $dMonad_abVTO } in
                 \ (ds_dbW83 [Occ=Once] :: Const m_abVSR (m1_abVTL a_abVTM)) ->
                   pure
                     @ m1_abVTL
                     $dApplicative_abVTo
                     @ (Const m_abVSR a_abVTM)
                     (ds_dbW83
                      `cast` (Data.Functor.Const.N:Const[0]
                                  <*>_N
                                  <m_abVSR>_R
                                  <m1_abVTL a_abVTM>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                                  <*>_N <m_abVSR>_R <a_abVTM>_P)
                              :: (Const m_abVSR (m1_abVTL a_abVTM) :: *)
                                 ~R# (Const m_abVSR a_abVTM :: *)))}]
Data.Traversable.$fTraversableConst_$csequence
  = \ (@ m_abVSR)
      (@ (m1_abVTL :: * -> *))
      (@ a_abVTM)
      ($dMonad_abVTO :: Monad m1_abVTL)
      (eta_B1 :: Const m_abVSR (m1_abVTL a_abVTM)) ->
      pure
        @ m1_abVTL
        (GHC.Base.$p1Monad @ m1_abVTL $dMonad_abVTO)
        @ (Const m_abVSR a_abVTM)
        (eta_B1
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N
                     <m_abVSR>_R
                     <m1_abVTL a_abVTM>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                     <*>_N <m_abVSR>_R <a_abVTM>_P)
                 :: (Const m_abVSR (m1_abVTL a_abVTM) :: *)
                    ~R# (Const m_abVSR a_abVTM :: *)))

-- RHS size: {terms: 8, types: 22, coercions: 13, joins: 0/0}
$fTraversableConst1_rbWTU
  :: forall m (f :: * -> *) a.
     Applicative f =>
     Const m (f a) -> f (Const m a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []]
$fTraversableConst1_rbWTU
  = \ (@ m_abVSR)
      (@ (f_abVTl :: * -> *))
      (@ a_abVTm)
      ($dApplicative_abVTo :: Applicative f_abVTl)
      (ds_dbW83 :: Const m_abVSR (f_abVTl a_abVTm)) ->
      pure
        @ f_abVTl
        $dApplicative_abVTo
        @ (Const m_abVSR a_abVTm)
        (ds_dbW83
         `cast` (Data.Functor.Const.N:Const[0]
                     <*>_N
                     <m_abVSR>_R
                     <f_abVTl a_abVTm>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                    <*>_N <m_abVSR>_R <a_abVTm>_P)
                 :: (Const m_abVSR (f_abVTl a_abVTm) :: *)
                    ~R# (Const m_abVSR a_abVTm :: *)))

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Traversable (Const m)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ m_abVfU) ->
       Data.Traversable.C:Traversable TYPE: Const m_abVfU
                                      Data.Functor.Const.$fFunctorConst @ m_abVfU
                                      Data.Functor.Const.$fFoldableConst @ m_abVfU
                                      Data.Traversable.$fTraversableConst_$ctraverse @ m_abVfU
                                      \ (@ (f_abVTl :: * -> *))
                                        (@ a_abVTm)
                                        ($dApplicative_abVTo [Occ=Once] :: Applicative f_abVTl)
                                        (ds_dbW83 [Occ=Once] :: Const m_abVfU (f_abVTl a_abVTm)) ->
                                        pure
                                          @ f_abVTl
                                          $dApplicative_abVTo
                                          @ (Const m_abVfU a_abVTm)
                                          (ds_dbW83
                                           `cast` (Data.Functor.Const.N:Const[0]
                                                       <*>_N
                                                       <m_abVfU>_R
                                                       <f_abVTl a_abVTm>_P ; Sym (Data.Functor.Const.N:Const[0]
                                                                                      <*>_N
                                                                                      <m_abVfU>_R
                                                                                      <a_abVTm>_P)
                                                   :: (Const m_abVfU (f_abVTl a_abVTm) :: *)
                                                      ~R# (Const m_abVfU a_abVTm :: *)))
                                      Data.Traversable.$fTraversableConst_$cmapM @ m_abVfU
                                      Data.Traversable.$fTraversableConst_$csequence @ m_abVfU]
Data.Traversable.$fTraversableConst
  = \ (@ m_abVSR) ->
      Data.Traversable.C:Traversable
        @ (Const m_abVSR)
        (Data.Functor.Const.$fFunctorConst @ m_abVSR)
        (Data.Functor.Const.$fFoldableConst @ m_abVSR)
        (Data.Traversable.$fTraversableConst_$ctraverse @ m_abVSR)
        ($fTraversableConst1_rbWTU @ m_abVSR)
        (Data.Traversable.$fTraversableConst_$cmapM @ m_abVSR)
        (Data.Traversable.$fTraversableConst_$csequence @ m_abVSR)

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable(,)_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     Applicative f =>
     (a1, f a2) -> f (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_abVWj)
                 (@ (f_abVWK :: * -> *))
                 (@ a1_abVWL)
                 ($dApplicative_abVWN [Occ=Once] :: Applicative f_abVWK)
                 (eta_B1 [Occ=Once!] :: (a_abVWj, f_abVWK a1_abVWL)) ->
                 case eta_B1 of { (x_abVg1 [Occ=Once], y_abVg2 [Occ=Once]) ->
                 fmap
                   @ f_abVWK
                   (GHC.Base.$p1Applicative @ f_abVWK $dApplicative_abVWN)
                   @ a1_abVWL
                   @ (a_abVWj, a1_abVWL)
                   (GHC.Tuple.(,) @ a_abVWj @ a1_abVWL x_abVg1)
                   y_abVg2
                 }}]
Data.Traversable.$fTraversable(,)_$csequenceA
  = \ (@ a_abVWj)
      (@ (f_abVWK :: * -> *))
      (@ a1_abVWL)
      ($dApplicative_abVWN :: Applicative f_abVWK)
      (eta_B1 :: (a_abVWj, f_abVWK a1_abVWL)) ->
      case eta_B1 of { (x_abVg1, y_abVg2) ->
      fmap
        @ f_abVWK
        (GHC.Base.$p1Applicative @ f_abVWK $dApplicative_abVWN)
        @ a1_abVWL
        @ (a_abVWj, a1_abVWL)
        (GHC.Tuple.(,) @ a_abVWj @ a1_abVWL x_abVg1)
        y_abVg2
      }

-- RHS size: {terms: 18, types: 32, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable(,)_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     Monad m =>
     (a2 -> m b) -> (a1, a2) -> m (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_abVWj)
                 (@ (m_abVWW :: * -> *))
                 (@ a1_abVWX)
                 (@ b_abVWY)
                 ($dMonad_abVX0 [Occ=OnceL] :: Monad m_abVWW) ->
                 let {
                   $dApplicative_abVWz [Occ=OnceL] :: Applicative m_abVWW
                   [LclId]
                   $dApplicative_abVWz
                     = GHC.Base.$p1Monad @ m_abVWW $dMonad_abVX0 } in
                 \ (eta_B2 [Occ=Once!] :: a1_abVWX -> m_abVWW b_abVWY)
                   (eta1_B1 [Occ=Once!] :: (a_abVWj, a1_abVWX)) ->
                   case eta1_B1 of { (x_abVg1 [Occ=Once], y_abVg2 [Occ=Once]) ->
                   fmap
                     @ m_abVWW
                     (GHC.Base.$p1Applicative @ m_abVWW $dApplicative_abVWz)
                     @ b_abVWY
                     @ (a_abVWj, b_abVWY)
                     (GHC.Tuple.(,) @ a_abVWj @ b_abVWY x_abVg1)
                     (eta_B2 y_abVg2)
                   }}]
Data.Traversable.$fTraversable(,)_$cmapM
  = \ (@ a_abVWj)
      (@ (m_abVWW :: * -> *))
      (@ a1_abVWX)
      (@ b_abVWY)
      ($dMonad_abVX0 :: Monad m_abVWW)
      (eta_B2 :: a1_abVWX -> m_abVWW b_abVWY)
      (eta1_B1 :: (a_abVWj, a1_abVWX)) ->
      case eta1_B1 of { (x_abVg1, y_abVg2) ->
      fmap
        @ m_abVWW
        (GHC.Base.$p1Applicative
           @ m_abVWW (GHC.Base.$p1Monad @ m_abVWW $dMonad_abVX0))
        @ b_abVWY
        @ (a_abVWj, b_abVWY)
        (GHC.Tuple.(,) @ a_abVWj @ b_abVWY x_abVg1)
        (eta_B2 y_abVg2)
      }

-- RHS size: {terms: 15, types: 30, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable(,)_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2. Monad m => (a1, m a2) -> m (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_abVWj)
                 (@ (m_abVXa :: * -> *))
                 (@ a1_abVXb)
                 ($dMonad_abVXd [Occ=OnceL] :: Monad m_abVXa) ->
                 let {
                   $dApplicative_abVWN [Occ=OnceL] :: Applicative m_abVXa
                   [LclId]
                   $dApplicative_abVWN
                     = GHC.Base.$p1Monad @ m_abVXa $dMonad_abVXd } in
                 \ (eta_B1 [Occ=Once!] :: (a_abVWj, m_abVXa a1_abVXb)) ->
                   case eta_B1 of { (x_abVg1 [Occ=Once], y_abVg2 [Occ=Once]) ->
                   fmap
                     @ m_abVXa
                     (GHC.Base.$p1Applicative @ m_abVXa $dApplicative_abVWN)
                     @ a1_abVXb
                     @ (a_abVWj, a1_abVXb)
                     (GHC.Tuple.(,) @ a_abVWj @ a1_abVXb x_abVg1)
                     y_abVg2
                   }}]
Data.Traversable.$fTraversable(,)_$csequence
  = \ (@ a_abVWj)
      (@ (m_abVXa :: * -> *))
      (@ a1_abVXb)
      ($dMonad_abVXd :: Monad m_abVXa)
      (eta_B1 :: (a_abVWj, m_abVXa a1_abVXb)) ->
      case eta_B1 of { (x_abVg1, y_abVg2) ->
      fmap
        @ m_abVXa
        (GHC.Base.$p1Applicative
           @ m_abVXa (GHC.Base.$p1Monad @ m_abVXa $dMonad_abVXd))
        @ a1_abVXb
        @ (a_abVWj, a1_abVXb)
        (GHC.Tuple.(,) @ a_abVWj @ a1_abVXb x_abVg1)
        y_abVg2
      }

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Traversable ((,) a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_abVfZ) ->
       Data.Traversable.C:Traversable TYPE: (,) a_abVfZ
                                      GHC.Base.$fFunctor(,) @ a_abVfZ
                                      Data.Foldable.$fFoldable(,) @ a_abVfZ
                                      Data.Traversable.$fTraversable(,)_$ctraverse @ a_abVfZ
                                      Data.Traversable.$fTraversable(,)_$csequenceA @ a_abVfZ
                                      Data.Traversable.$fTraversable(,)_$cmapM @ a_abVfZ
                                      Data.Traversable.$fTraversable(,)_$csequence @ a_abVfZ]
Data.Traversable.$fTraversable(,)
  = \ (@ a_abVWj) ->
      Data.Traversable.C:Traversable
        @ ((,) a_abVWj)
        (GHC.Base.$fFunctor(,) @ a_abVWj)
        (Data.Foldable.$fFoldable(,) @ a_abVWj)
        (Data.Traversable.$fTraversable(,)_$ctraverse @ a_abVWj)
        (Data.Traversable.$fTraversable(,)_$csequenceA @ a_abVWj)
        (Data.Traversable.$fTraversable(,)_$cmapM @ a_abVWj)
        (Data.Traversable.$fTraversable(,)_$csequence @ a_abVWj)

-- RHS size: {terms: 18, types: 35, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableEither_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     Applicative f =>
     Either a1 (f a2) -> f (Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_abVXl)
                 (@ (f_abVXR :: * -> *))
                 (@ a1_abVXS)
                 ($dApplicative_abVXU [Occ=Once*] :: Applicative f_abVXR)
                 (eta_B1 [Occ=Once!] :: Either a_abVXl (f_abVXR a1_abVXS)) ->
                 case eta_B1 of {
                   Left x_abVg4 [Occ=Once] ->
                     pure
                       @ f_abVXR
                       $dApplicative_abVXU
                       @ (Either a_abVXl a1_abVXS)
                       (Data.Either.Left @ a_abVXl @ a1_abVXS x_abVg4);
                   Right y_abVg6 [Occ=Once] ->
                     fmap
                       @ f_abVXR
                       (GHC.Base.$p1Applicative @ f_abVXR $dApplicative_abVXU)
                       @ a1_abVXS
                       @ (Either a_abVXl a1_abVXS)
                       (Data.Either.Right @ a_abVXl @ a1_abVXS)
                       y_abVg6
                 }}]
Data.Traversable.$fTraversableEither_$csequenceA
  = \ (@ a_abVXl)
      (@ (f_abVXR :: * -> *))
      (@ a1_abVXS)
      ($dApplicative_abVXU :: Applicative f_abVXR)
      (eta_B1 :: Either a_abVXl (f_abVXR a1_abVXS)) ->
      case eta_B1 of {
        Left x_abVg4 ->
          pure
            @ f_abVXR
            $dApplicative_abVXU
            @ (Either a_abVXl a1_abVXS)
            (Data.Either.Left @ a_abVXl @ a1_abVXS x_abVg4);
        Right y_abVg6 ->
          fmap
            @ f_abVXR
            (GHC.Base.$p1Applicative @ f_abVXR $dApplicative_abVXU)
            @ a1_abVXS
            @ (Either a_abVXl a1_abVXS)
            (Data.Either.Right @ a_abVXl @ a1_abVXS)
            y_abVg6
      }

-- RHS size: {terms: 12, types: 23, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableEither_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     Monad m =>
     (a2 -> m b) -> Either a1 a2 -> m (Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_abVXl)
                 (@ (m_abVY3 :: * -> *))
                 (@ a1_abVY4)
                 (@ b_abVY5)
                 ($dMonad_abVY7 [Occ=Once] :: Monad m_abVY3) ->
                 Data.Traversable.$fTraversableEither_$ctraverse
                   @ a_abVXl
                   @ m_abVY3
                   @ a1_abVY4
                   @ b_abVY5
                   (GHC.Base.$p1Monad @ m_abVY3 $dMonad_abVY7)}]
Data.Traversable.$fTraversableEither_$cmapM
  = \ (@ a_abVXl)
      (@ (m_abVY3 :: * -> *))
      (@ a1_abVY4)
      (@ b_abVY5)
      ($dMonad_abVY7 :: Monad m_abVY3)
      (eta_B2 :: a1_abVY4 -> m_abVY3 b_abVY5)
      (eta1_B1 :: Either a_abVXl a1_abVY4) ->
      Data.Traversable.$fTraversableEither_$ctraverse
        @ a_abVXl
        @ m_abVY3
        @ a1_abVY4
        @ b_abVY5
        (GHC.Base.$p1Monad @ m_abVY3 $dMonad_abVY7)
        eta_B2
        eta1_B1

-- RHS size: {terms: 20, types: 37, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableEither_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     Monad m =>
     Either a1 (m a2) -> m (Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_abVXl)
                 (@ (m_abVYh :: * -> *))
                 (@ a1_abVYi)
                 ($dMonad_abVYk [Occ=OnceL] :: Monad m_abVYh) ->
                 let {
                   $dApplicative_abVXU [Occ=OnceL*] :: Applicative m_abVYh
                   [LclId]
                   $dApplicative_abVXU
                     = GHC.Base.$p1Monad @ m_abVYh $dMonad_abVYk } in
                 \ (eta_B1 [Occ=Once!] :: Either a_abVXl (m_abVYh a1_abVYi)) ->
                   case eta_B1 of {
                     Left x_abVg4 [Occ=Once] ->
                       pure
                         @ m_abVYh
                         $dApplicative_abVXU
                         @ (Either a_abVXl a1_abVYi)
                         (Data.Either.Left @ a_abVXl @ a1_abVYi x_abVg4);
                     Right y_abVg6 [Occ=Once] ->
                       fmap
                         @ m_abVYh
                         (GHC.Base.$p1Applicative @ m_abVYh $dApplicative_abVXU)
                         @ a1_abVYi
                         @ (Either a_abVXl a1_abVYi)
                         (Data.Either.Right @ a_abVXl @ a1_abVYi)
                         y_abVg6
                   }}]
Data.Traversable.$fTraversableEither_$csequence
  = \ (@ a_abVXl)
      (@ (m_abVYh :: * -> *))
      (@ a1_abVYi)
      ($dMonad_abVYk :: Monad m_abVYh)
      (eta_B1 :: Either a_abVXl (m_abVYh a1_abVYi)) ->
      case eta_B1 of {
        Left x_abVg4 ->
          pure
            @ m_abVYh
            (GHC.Base.$p1Monad @ m_abVYh $dMonad_abVYk)
            @ (Either a_abVXl a1_abVYi)
            (Data.Either.Left @ a_abVXl @ a1_abVYi x_abVg4);
        Right y_abVg6 ->
          fmap
            @ m_abVYh
            (GHC.Base.$p1Applicative
               @ m_abVYh (GHC.Base.$p1Monad @ m_abVYh $dMonad_abVYk))
            @ a1_abVYi
            @ (Either a_abVXl a1_abVYi)
            (Data.Either.Right @ a_abVXl @ a1_abVYi)
            y_abVg6
      }

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Traversable (Either a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_abVg3) ->
       Data.Traversable.C:Traversable TYPE: Either a_abVg3
                                      Data.Either.$fFunctorEither @ a_abVg3
                                      Data.Foldable.$fFoldableEither @ a_abVg3
                                      Data.Traversable.$fTraversableEither_$ctraverse @ a_abVg3
                                      Data.Traversable.$fTraversableEither_$csequenceA @ a_abVg3
                                      Data.Traversable.$fTraversableEither_$cmapM @ a_abVg3
                                      Data.Traversable.$fTraversableEither_$csequence @ a_abVg3]
Data.Traversable.$fTraversableEither
  = \ (@ a_abVXl) ->
      Data.Traversable.C:Traversable
        @ (Either a_abVXl)
        (Data.Either.$fFunctorEither @ a_abVXl)
        (Data.Foldable.$fFoldableEither @ a_abVXl)
        (Data.Traversable.$fTraversableEither_$ctraverse @ a_abVXl)
        (Data.Traversable.$fTraversableEither_$csequenceA @ a_abVXl)
        (Data.Traversable.$fTraversableEither_$cmapM @ a_abVXl)
        (Data.Traversable.$fTraversableEither_$csequence @ a_abVXl)

-- RHS size: {terms: 21, types: 39, coercions: 0, joins: 0/2}
Data.Traversable.$fTraversable[]_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. Applicative f => [f a] -> f [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abW0j :: * -> *))
                 (@ a_abW0k)
                 ($dApplicative_abW0m :: Applicative f_abW0j) ->
                 List.foldr
                   @ (f_abW0j a_abW0k)
                   @ (f_abW0j [a_abW0k])
                   (\ (x_abVgc [Occ=Once] :: f_abW0j a_abW0k)
                      (ys_abVgd [Occ=Once] :: f_abW0j [a_abW0k]) ->
                      liftA2
                        @ f_abW0j
                        $dApplicative_abW0m
                        @ a_abW0k
                        @ [a_abW0k]
                        @ [a_abW0k]
                        (GHC.Types.: @ a_abW0k)
                        x_abVgc
                        ys_abVgd)
                   (pure
                      @ f_abW0j
                      $dApplicative_abW0m
                      @ [a_abW0k]
                      (GHC.Types.[] @ a_abW0k))}]
Data.Traversable.$fTraversable[]_$csequenceA
  = \ (@ (f_abW0j :: * -> *))
      (@ a_abW0k)
      ($dApplicative_abW0m :: Applicative f_abW0j) ->
      let {
        z_i7Jci :: f_abW0j [a_abW0k]
        [LclId]
        z_i7Jci
          = pure
              @ f_abW0j
              $dApplicative_abW0m
              @ [a_abW0k]
              (GHC.Types.[] @ a_abW0k) } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker]
          :: [f_abW0j a_abW0k] -> f_abW0j [a_abW0k]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [f_abW0j a_abW0k]) ->
              case ds_i7Jck of {
                [] -> z_i7Jci;
                : y_i7Jcp ys_i7Jcq ->
                  liftA2
                    @ f_abW0j
                    $dApplicative_abW0m
                    @ a_abW0k
                    @ [a_abW0k]
                    @ [a_abW0k]
                    (GHC.Types.: @ a_abW0k)
                    y_i7Jcp
                    (go_i7Jcj ys_i7Jcq)
              }; } in
      go_i7Jcj

-- RHS size: {terms: 27, types: 42, coercions: 0, joins: 0/3}
Data.Traversable.$fTraversable[]_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abW0v :: * -> *))
                 (@ a_abW0w)
                 (@ b_abW0x)
                 ($dMonad_abW0z [Occ=OnceL] :: Monad m_abW0v) ->
                 let {
                   $dApplicative_abVZO :: Applicative m_abW0v
                   [LclId]
                   $dApplicative_abVZO
                     = GHC.Base.$p1Monad @ m_abW0v $dMonad_abW0z } in
                 \ (f_abVga [Occ=OnceL!] :: a_abW0w -> m_abW0v b_abW0x) ->
                   List.foldr
                     @ a_abW0w
                     @ (m_abW0v [b_abW0x])
                     (\ (x_abVgc [Occ=Once] :: a_abW0w)
                        (ys_abVgd [Occ=Once] :: m_abW0v [b_abW0x]) ->
                        liftA2
                          @ m_abW0v
                          $dApplicative_abVZO
                          @ b_abW0x
                          @ [b_abW0x]
                          @ [b_abW0x]
                          (GHC.Types.: @ b_abW0x)
                          (f_abVga x_abVgc)
                          ys_abVgd)
                     (pure
                        @ m_abW0v
                        $dApplicative_abVZO
                        @ [b_abW0x]
                        (GHC.Types.[] @ b_abW0x))}]
Data.Traversable.$fTraversable[]_$cmapM
  = \ (@ (m_abW0v :: * -> *))
      (@ a_abW0w)
      (@ b_abW0x)
      ($dMonad_abW0z :: Monad m_abW0v)
      (eta_B1 :: a_abW0w -> m_abW0v b_abW0x) ->
      let {
        $dApplicative_sbWCc [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
          :: Applicative m_abW0v
        [LclId]
        $dApplicative_sbWCc
          = GHC.Base.$p1Monad @ m_abW0v $dMonad_abW0z } in
      let {
        z_i7Jci :: m_abW0v [b_abW0x]
        [LclId]
        z_i7Jci
          = pure
              @ m_abW0v
              $dApplicative_sbWCc
              @ [b_abW0x]
              (GHC.Types.[] @ b_abW0x) } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker] :: [a_abW0w] -> m_abW0v [b_abW0x]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [a_abW0w]) ->
              case ds_i7Jck of {
                [] -> z_i7Jci;
                : y_i7Jcp ys_i7Jcq ->
                  liftA2
                    @ m_abW0v
                    $dApplicative_sbWCc
                    @ b_abW0x
                    @ [b_abW0x]
                    @ [b_abW0x]
                    (GHC.Types.: @ b_abW0x)
                    (eta_B1 y_i7Jcp)
                    (go_i7Jcj ys_i7Jcq)
              }; } in
      go_i7Jcj

-- RHS size: {terms: 24, types: 42, coercions: 0, joins: 0/3}
Data.Traversable.$fTraversable[]_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => [m a] -> m [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abW0J :: * -> *))
                 (@ a_abW0K)
                 ($dMonad_abW0M [Occ=OnceL] :: Monad m_abW0J) ->
                 let {
                   $dApplicative_abW0m :: Applicative m_abW0J
                   [LclId]
                   $dApplicative_abW0m
                     = GHC.Base.$p1Monad @ m_abW0J $dMonad_abW0M } in
                 List.foldr
                   @ (m_abW0J a_abW0K)
                   @ (m_abW0J [a_abW0K])
                   (\ (x_abVgc [Occ=Once] :: m_abW0J a_abW0K)
                      (ys_abVgd [Occ=Once] :: m_abW0J [a_abW0K]) ->
                      liftA2
                        @ m_abW0J
                        $dApplicative_abW0m
                        @ a_abW0K
                        @ [a_abW0K]
                        @ [a_abW0K]
                        (GHC.Types.: @ a_abW0K)
                        x_abVgc
                        ys_abVgd)
                   (pure
                      @ m_abW0J
                      $dApplicative_abW0m
                      @ [a_abW0K]
                      (GHC.Types.[] @ a_abW0K))}]
Data.Traversable.$fTraversable[]_$csequence
  = \ (@ (m_abW0J :: * -> *))
      (@ a_abW0K)
      ($dMonad_abW0M :: Monad m_abW0J) ->
      let {
        $dApplicative_sbWCa [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
          :: Applicative m_abW0J
        [LclId]
        $dApplicative_sbWCa
          = GHC.Base.$p1Monad @ m_abW0J $dMonad_abW0M } in
      let {
        z_i7Jci :: m_abW0J [a_abW0K]
        [LclId]
        z_i7Jci
          = pure
              @ m_abW0J
              $dApplicative_sbWCa
              @ [a_abW0K]
              (GHC.Types.[] @ a_abW0K) } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker]
          :: [m_abW0J a_abW0K] -> m_abW0J [a_abW0K]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [m_abW0J a_abW0K]) ->
              case ds_i7Jck of {
                [] -> z_i7Jci;
                : y_i7Jcp ys_i7Jcq ->
                  liftA2
                    @ m_abW0J
                    $dApplicative_sbWCa
                    @ a_abW0K
                    @ [a_abW0K]
                    @ [a_abW0K]
                    (GHC.Types.: @ a_abW0K)
                    y_i7Jcp
                    (go_i7Jcj ys_i7Jcq)
              }; } in
      go_i7Jcj

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable []
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: []
                                      GHC.Base.$fFunctor[]
                                      Data.Foldable.$fFoldable[]
                                      Data.Traversable.$fTraversable[]_$ctraverse
                                      Data.Traversable.$fTraversable[]_$csequenceA
                                      Data.Traversable.$fTraversable[]_$cmapM
                                      Data.Traversable.$fTraversable[]_$csequence]
Data.Traversable.$fTraversable[]
  = Data.Traversable.C:Traversable
      @ []
      GHC.Base.$fFunctor[]
      Data.Foldable.$fFoldable[]
      Data.Traversable.$fTraversable[]_$ctraverse
      Data.Traversable.$fTraversable[]_$csequenceA
      Data.Traversable.$fTraversable[]_$cmapM
      Data.Traversable.$fTraversable[]_$csequence

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableZipList1 :: forall b. [b] -> [b]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abVMM) (v_X5 [Occ=Once] :: [b_abVMM]) -> v_X5}]
Data.Traversable.$fTraversableZipList1
  = \ (@ b_abVMM) (v_X5 :: [b_abVMM]) -> v_X5

-- RHS size: {terms: 30, types: 48, coercions: 8, joins: 0/2}
Data.Traversable.$fTraversableZipList_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> ZipList a -> f (ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 250 0}]
Data.Traversable.$fTraversableZipList_$ctraverse
  = \ (@ (f_abVMK :: * -> *))
      (@ a_abVML)
      (@ b_abVMM)
      ($dApplicative_abVMO :: Applicative f_abVMK)
      (eta_B2 :: a_abVML -> f_abVMK b_abVMM)
      (eta1_B1 :: ZipList a_abVML) ->
      fmap
        @ f_abVMK
        (GHC.Base.$p1Applicative @ f_abVMK $dApplicative_abVMO)
        @ [b_abVMM]
        @ (ZipList b_abVMM)
        ((Data.Traversable.$fTraversableZipList1 @ b_abVMM)
         `cast` (<[b_abVMM]>_R
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <b_abVMM>_N
                 :: ([b_abVMM] -> [b_abVMM] :: *)
                    ~R# ([b_abVMM] -> ZipList b_abVMM :: *)))
        (let {
           z_i7Jci :: f_abVMK [b_abVMM]
           [LclId]
           z_i7Jci
             = pure
                 @ f_abVMK
                 $dApplicative_abVMO
                 @ [b_abVMM]
                 (GHC.Types.[] @ b_abVMM) } in
         letrec {
           go_i7Jcj [Occ=LoopBreaker] :: [a_abVML] -> f_abVMK [b_abVMM]
           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
           go_i7Jcj
             = \ (ds_i7Jck :: [a_abVML]) ->
                 case ds_i7Jck of {
                   [] -> z_i7Jci;
                   : y_i7Jcp ys_i7Jcq ->
                     liftA2
                       @ f_abVMK
                       $dApplicative_abVMO
                       @ b_abVMM
                       @ [b_abVMM]
                       @ [b_abVMM]
                       (GHC.Types.: @ b_abVMM)
                       (eta_B2 y_i7Jcp)
                       (go_i7Jcj ys_i7Jcq)
                 }; } in
         go_i7Jcj
           (eta1_B1
            `cast` (Control.Applicative.N:ZipList[0] <a_abVML>_N
                    :: (ZipList a_abVML :: *) ~R# ([a_abVML] :: *))))

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableZipList_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     ZipList (f a) -> f (ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVN4 :: * -> *))
                 (@ a_abVN5)
                 ($dApplicative_abVN7 [Occ=Once] :: Applicative f_abVN4) ->
                 Data.Traversable.$fTraversableZipList_$ctraverse
                   @ f_abVN4
                   @ (f_abVN4 a_abVN5)
                   @ a_abVN5
                   $dApplicative_abVN7
                   (id @ (f_abVN4 a_abVN5))}]
Data.Traversable.$fTraversableZipList_$csequenceA
  = \ (@ (f_abVN4 :: * -> *))
      (@ a_abVN5)
      ($dApplicative_abVN7 :: Applicative f_abVN4) ->
      Data.Traversable.$fTraversableZipList_$ctraverse
        @ f_abVN4
        @ (f_abVN4 a_abVN5)
        @ a_abVN5
        $dApplicative_abVN7
        (id @ (f_abVN4 a_abVN5))

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableZipList_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> ZipList a -> m (ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVNg :: * -> *))
                 (@ a_abVNh)
                 (@ b_abVNi)
                 ($dMonad_abVNk [Occ=Once] :: Monad m_abVNg) ->
                 Data.Traversable.$fTraversableZipList_$ctraverse
                   @ m_abVNg
                   @ a_abVNh
                   @ b_abVNi
                   (GHC.Base.$p1Monad @ m_abVNg $dMonad_abVNk)}]
Data.Traversable.$fTraversableZipList_$cmapM
  = \ (@ (m_abVNg :: * -> *))
      (@ a_abVNh)
      (@ b_abVNi)
      ($dMonad_abVNk :: Monad m_abVNg)
      (eta_B2 :: a_abVNh -> m_abVNg b_abVNi)
      (eta1_B1 :: ZipList a_abVNh) ->
      Data.Traversable.$fTraversableZipList_$ctraverse
        @ m_abVNg
        @ a_abVNh
        @ b_abVNi
        (GHC.Base.$p1Monad @ m_abVNg $dMonad_abVNk)
        eta_B2
        eta1_B1

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableZipList_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     ZipList (m a) -> m (ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVNu :: * -> *))
                 (@ a_abVNv)
                 ($dMonad_abVNx [Occ=Once] :: Monad m_abVNu) ->
                 Data.Traversable.$fTraversableZipList_$ctraverse
                   @ m_abVNu
                   @ (m_abVNu a_abVNv)
                   @ a_abVNv
                   (GHC.Base.$p1Monad @ m_abVNu $dMonad_abVNx)
                   (id @ (m_abVNu a_abVNv))}]
Data.Traversable.$fTraversableZipList_$csequence
  = \ (@ (m_abVNu :: * -> *))
      (@ a_abVNv)
      ($dMonad_abVNx :: Monad m_abVNu)
      (eta_B1 :: ZipList (m_abVNu a_abVNv)) ->
      Data.Traversable.$fTraversableZipList_$ctraverse
        @ m_abVNu
        @ (m_abVNu a_abVNv)
        @ a_abVNv
        (GHC.Base.$p1Monad @ m_abVNu $dMonad_abVNx)
        (id @ (m_abVNu a_abVNv))
        eta_B1

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable ZipList
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: ZipList
                                      Control.Applicative.$fFunctorZipList
                                      Control.Applicative.$fFoldableZipList
                                      Data.Traversable.$fTraversableZipList_$ctraverse
                                      Data.Traversable.$fTraversableZipList_$csequenceA
                                      Data.Traversable.$fTraversableZipList_$cmapM
                                      Data.Traversable.$fTraversableZipList_$csequence]
Data.Traversable.$fTraversableZipList
  = Data.Traversable.C:Traversable
      @ ZipList
      Control.Applicative.$fFunctorZipList
      Control.Applicative.$fFoldableZipList
      Data.Traversable.$fTraversableZipList_$ctraverse
      Data.Traversable.$fTraversableZipList_$csequenceA
      Data.Traversable.$fTraversableZipList_$cmapM
      Data.Traversable.$fTraversableZipList_$csequence

-- RHS size: {terms: 58, types: 66, coercions: 0, joins: 0/3}
Data.Traversable.$fTraversableArray_$ctraverse
  :: forall i.
     Ix i =>
     forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Array i a -> f (Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 20] 335 0}]
Data.Traversable.$fTraversableArray_$ctraverse
  = \ (@ i_abVUZ)
      ($dIx_abVV0 :: Ix i_abVUZ)
      (@ (f_abVVc :: * -> *))
      (@ a_abVVd)
      (@ b_abVVe)
      ($dApplicative_abVVg :: Applicative f_abVVc)
      (eta_B2 :: a_abVVd -> f_abVVc b_abVVe)
      (eta1_B1 :: Array i_abVUZ a_abVVd) ->
      fmap
        @ f_abVVc
        (GHC.Base.$p1Applicative @ f_abVVc $dApplicative_abVVg)
        @ [b_abVVe]
        @ (Array i_abVUZ b_abVVe)
        (listArray
           @ i_abVUZ
           @ b_abVVe
           $dIx_abVV0
           (bounds @ i_abVUZ @ a_abVVd eta1_B1))
        (case eta1_B1 of { Array ds_ibW8P ds1_ibW8Q dt_ibW8R ds2_ibW8S ->
         let {
           y_i819M [Dmd=<S,U>] :: GHC.Prim.Int#
           [LclId]
           y_i819M = GHC.Prim.-# dt_ibW8R 1# } in
         let {
           n_i819K :: f_abVVc [b_abVVe]
           [LclId]
           n_i819K
             = pure
                 @ f_abVVc
                 $dApplicative_abVVg
                 @ [b_abVVe]
                 (GHC.Types.[] @ b_abVVe) } in
         case GHC.Prim.># 0# y_i819M of {
           __DEFAULT ->
             letrec {
               go_i819O [Occ=LoopBreaker] :: GHC.Prim.Int# -> f_abVVc [b_abVVe]
               [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
               go_i819O
                 = \ (x_i819P :: GHC.Prim.Int#) ->
                     liftA2
                       @ f_abVVc
                       $dApplicative_abVVg
                       @ b_abVVe
                       @ [b_abVVe]
                       @ [b_abVVe]
                       (GHC.Types.: @ b_abVVe)
                       (eta_B2
                          (case GHC.Prim.indexArray# @ a_abVVd ds2_ibW8S x_i819P of
                           { (# ipv_ibW90 #) ->
                           ipv_ibW90
                           }))
                       (case GHC.Prim.==# x_i819P y_i819M of {
                          __DEFAULT -> go_i819O (GHC.Prim.+# x_i819P 1#);
                          1# -> n_i819K
                        }); } in
             go_i819O 0#;
           1# -> n_i819K
         }
         })

-- RHS size: {terms: 9, types: 19, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableArray_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     Ix i =>
     forall (f :: * -> *) a.
     Applicative f =>
     Array i (f a) -> f (Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_abVUZ)
                 ($dIx_abVV0 [Occ=Once] :: Ix i_abVUZ)
                 (@ (f_abVVI :: * -> *))
                 (@ a_abVVJ)
                 ($dApplicative_abVVL [Occ=Once] :: Applicative f_abVVI) ->
                 Data.Traversable.$fTraversableArray_$ctraverse
                   @ i_abVUZ
                   $dIx_abVV0
                   @ f_abVVI
                   @ (f_abVVI a_abVVJ)
                   @ a_abVVJ
                   $dApplicative_abVVL
                   (id @ (f_abVVI a_abVVJ))}]
Data.Traversable.$fTraversableArray_$csequenceA
  = \ (@ i_abVUZ)
      ($dIx_abVV0 :: Ix i_abVUZ)
      (@ (f_abVVI :: * -> *))
      (@ a_abVVJ)
      ($dApplicative_abVVL :: Applicative f_abVVI) ->
      Data.Traversable.$fTraversableArray_$ctraverse
        @ i_abVUZ
        $dIx_abVV0
        @ f_abVVI
        @ (f_abVVI a_abVVJ)
        @ a_abVVJ
        $dApplicative_abVVL
        (id @ (f_abVVI a_abVVJ))

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableArray_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     Ix i =>
     forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Array i a -> m (Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_abVUZ)
                 ($dIx_abVV0 [Occ=Once] :: Ix i_abVUZ)
                 (@ (m_abVVU :: * -> *))
                 (@ a_abVVV)
                 (@ b_abVVW)
                 ($dMonad_abVVY [Occ=Once] :: Monad m_abVVU) ->
                 Data.Traversable.$fTraversableArray_$ctraverse
                   @ i_abVUZ
                   $dIx_abVV0
                   @ m_abVVU
                   @ a_abVVV
                   @ b_abVVW
                   (GHC.Base.$p1Monad @ m_abVVU $dMonad_abVVY)}]
Data.Traversable.$fTraversableArray_$cmapM
  = \ (@ i_abVUZ)
      ($dIx_abVV0 :: Ix i_abVUZ)
      (@ (m_abVVU :: * -> *))
      (@ a_abVVV)
      (@ b_abVVW)
      ($dMonad_abVVY :: Monad m_abVVU)
      (eta_B2 :: a_abVVV -> m_abVVU b_abVVW)
      (eta1_B1 :: Array i_abVUZ a_abVVV) ->
      Data.Traversable.$fTraversableArray_$ctraverse
        @ i_abVUZ
        $dIx_abVV0
        @ m_abVVU
        @ a_abVVV
        @ b_abVVW
        (GHC.Base.$p1Monad @ m_abVVU $dMonad_abVVY)
        eta_B2
        eta1_B1

-- RHS size: {terms: 12, types: 24, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableArray_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     Ix i =>
     forall (m :: * -> *) a. Monad m => Array i (m a) -> m (Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_abVUZ)
                 ($dIx_abVV0 [Occ=Once] :: Ix i_abVUZ)
                 (@ (m_abVW8 :: * -> *))
                 (@ a_abVW9)
                 ($dMonad_abVWb [Occ=Once] :: Monad m_abVW8) ->
                 Data.Traversable.$fTraversableArray_$ctraverse
                   @ i_abVUZ
                   $dIx_abVV0
                   @ m_abVW8
                   @ (m_abVW8 a_abVW9)
                   @ a_abVW9
                   (GHC.Base.$p1Monad @ m_abVW8 $dMonad_abVWb)
                   (id @ (m_abVW8 a_abVW9))}]
Data.Traversable.$fTraversableArray_$csequence
  = \ (@ i_abVUZ)
      ($dIx_abVV0 :: Ix i_abVUZ)
      (@ (m_abVW8 :: * -> *))
      (@ a_abVW9)
      ($dMonad_abVWb :: Monad m_abVW8)
      (eta_B1 :: Array i_abVUZ (m_abVW8 a_abVW9)) ->
      Data.Traversable.$fTraversableArray_$ctraverse
        @ i_abVUZ
        $dIx_abVV0
        @ m_abVW8
        @ (m_abVW8 a_abVW9)
        @ a_abVW9
        (GHC.Base.$p1Monad @ m_abVW8 $dMonad_abVWb)
        (id @ (m_abVW8 a_abVW9))
        eta_B1

-- RHS size: {terms: 13, types: 12, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Ix i => Traversable (Array i)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)>m,
 Unf=DFun: \ (@ i_abVfW) (v_B1 :: Ix i_abVfW) ->
       Data.Traversable.C:Traversable TYPE: Array i_abVfW
                                      GHC.Arr.$fFunctorArray @ i_abVfW
                                      Data.Foldable.$fFoldableArray @ i_abVfW
                                      Data.Traversable.$fTraversableArray_$ctraverse @ i_abVfW v_B1
                                      Data.Traversable.$fTraversableArray_$csequenceA @ i_abVfW v_B1
                                      Data.Traversable.$fTraversableArray_$cmapM @ i_abVfW v_B1
                                      Data.Traversable.$fTraversableArray_$csequence @ i_abVfW v_B1]
Data.Traversable.$fTraversableArray
  = \ (@ i_abVUZ) ($dIx_abVV0 :: Ix i_abVUZ) ->
      Data.Traversable.C:Traversable
        @ (Array i_abVUZ)
        (GHC.Arr.$fFunctorArray @ i_abVUZ)
        (Data.Foldable.$fFoldableArray @ i_abVUZ)
        (Data.Traversable.$fTraversableArray_$ctraverse
           @ i_abVUZ $dIx_abVV0)
        (Data.Traversable.$fTraversableArray_$csequenceA
           @ i_abVUZ $dIx_abVV0)
        (Data.Traversable.$fTraversableArray_$cmapM @ i_abVUZ $dIx_abVV0)
        (Data.Traversable.$fTraversableArray_$csequence
           @ i_abVUZ $dIx_abVV0)

-- RHS size: {terms: 37, types: 58, coercions: 0, joins: 0/2}
Data.Traversable.$fTraversableNonEmpty_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> NonEmpty a -> f (NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 40] 280 0}]
Data.Traversable.$fTraversableNonEmpty_$ctraverse
  = \ (@ (f_abVYD :: * -> *))
      (@ a_abVYE)
      (@ b_abVYF)
      ($dApplicative_abVYH :: Applicative f_abVYD)
      (f1_abVg7 :: a_abVYE -> f_abVYD b_abVYF)
      (ds_dbW9l :: NonEmpty a_abVYE) ->
      liftA2
        @ f_abVYD
        $dApplicative_abVYH
        @ b_abVYF
        @ [b_abVYF]
        @ (NonEmpty b_abVYF)
        (GHC.Base.:| @ b_abVYF)
        (f1_abVg7 (case ds_dbW9l of { :| a1_abVg8 as_abVg9 -> a1_abVg8 }))
        (case ds_dbW9l of { :| a1_abVg8 as_abVg9 ->
         let {
           z_i7Jci :: f_abVYD [b_abVYF]
           [LclId]
           z_i7Jci
             = pure
                 @ f_abVYD
                 $dApplicative_abVYH
                 @ [b_abVYF]
                 (GHC.Types.[] @ b_abVYF) } in
         letrec {
           go_i7Jcj [Occ=LoopBreaker] :: [a_abVYE] -> f_abVYD [b_abVYF]
           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
           go_i7Jcj
             = \ (ds1_i7Jck :: [a_abVYE]) ->
                 case ds1_i7Jck of {
                   [] -> z_i7Jci;
                   : y_i7Jcp ys_i7Jcq ->
                     liftA2
                       @ f_abVYD
                       $dApplicative_abVYH
                       @ b_abVYF
                       @ [b_abVYF]
                       @ [b_abVYF]
                       (GHC.Types.: @ b_abVYF)
                       (f1_abVg7 y_i7Jcp)
                       (go_i7Jcj ys_i7Jcq)
                 }; } in
         go_i7Jcj as_abVg9
         })

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableNonEmpty_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     NonEmpty (f a) -> f (NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(U),A,C(C1(C1(U))),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVYY :: * -> *))
                 (@ a_abVYZ)
                 ($dApplicative_abVZ1 [Occ=Once] :: Applicative f_abVYY) ->
                 Data.Traversable.$fTraversableNonEmpty_$ctraverse
                   @ f_abVYY
                   @ (f_abVYY a_abVYZ)
                   @ a_abVYZ
                   $dApplicative_abVZ1
                   (id @ (f_abVYY a_abVYZ))}]
Data.Traversable.$fTraversableNonEmpty_$csequenceA
  = \ (@ (f_abVYY :: * -> *))
      (@ a_abVYZ)
      ($dApplicative_abVZ1 :: Applicative f_abVYY) ->
      Data.Traversable.$fTraversableNonEmpty_$ctraverse
        @ f_abVYY
        @ (f_abVYY a_abVYZ)
        @ a_abVYZ
        $dApplicative_abVZ1
        (id @ (f_abVYY a_abVYZ))

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableNonEmpty_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> NonEmpty a -> m (NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVZa :: * -> *))
                 (@ a_abVZb)
                 (@ b_abVZc)
                 ($dMonad_abVZe [Occ=Once] :: Monad m_abVZa) ->
                 Data.Traversable.$fTraversableNonEmpty_$ctraverse
                   @ m_abVZa
                   @ a_abVZb
                   @ b_abVZc
                   (GHC.Base.$p1Monad @ m_abVZa $dMonad_abVZe)}]
Data.Traversable.$fTraversableNonEmpty_$cmapM
  = \ (@ (m_abVZa :: * -> *))
      (@ a_abVZb)
      (@ b_abVZc)
      ($dMonad_abVZe :: Monad m_abVZa)
      (eta_B2 :: a_abVZb -> m_abVZa b_abVZc)
      (eta1_B1 :: NonEmpty a_abVZb) ->
      Data.Traversable.$fTraversableNonEmpty_$ctraverse
        @ m_abVZa
        @ a_abVZb
        @ b_abVZc
        (GHC.Base.$p1Monad @ m_abVZa $dMonad_abVZe)
        eta_B2
        eta1_B1

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableNonEmpty_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     NonEmpty (m a) -> m (NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVZo :: * -> *))
                 (@ a_abVZp)
                 ($dMonad_abVZr [Occ=Once] :: Monad m_abVZo) ->
                 Data.Traversable.$fTraversableNonEmpty_$ctraverse
                   @ m_abVZo
                   @ (m_abVZo a_abVZp)
                   @ a_abVZp
                   (GHC.Base.$p1Monad @ m_abVZo $dMonad_abVZr)
                   (id @ (m_abVZo a_abVZp))}]
Data.Traversable.$fTraversableNonEmpty_$csequence
  = \ (@ (m_abVZo :: * -> *))
      (@ a_abVZp)
      ($dMonad_abVZr :: Monad m_abVZo)
      (eta_B1 :: NonEmpty (m_abVZo a_abVZp)) ->
      Data.Traversable.$fTraversableNonEmpty_$ctraverse
        @ m_abVZo
        @ (m_abVZo a_abVZp)
        @ a_abVZp
        (GHC.Base.$p1Monad @ m_abVZo $dMonad_abVZr)
        (id @ (m_abVZo a_abVZp))
        eta_B1

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable NonEmpty
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: NonEmpty
                                      GHC.Base.$fFunctorNonEmpty
                                      Data.Foldable.$fFoldableNonEmpty
                                      Data.Traversable.$fTraversableNonEmpty_$ctraverse
                                      Data.Traversable.$fTraversableNonEmpty_$csequenceA
                                      Data.Traversable.$fTraversableNonEmpty_$cmapM
                                      Data.Traversable.$fTraversableNonEmpty_$csequence]
Data.Traversable.$fTraversableNonEmpty
  = Data.Traversable.C:Traversable
      @ NonEmpty
      GHC.Base.$fFunctorNonEmpty
      Data.Foldable.$fFoldableNonEmpty
      Data.Traversable.$fTraversableNonEmpty_$ctraverse
      Data.Traversable.$fTraversableNonEmpty_$csequenceA
      Data.Traversable.$fTraversableNonEmpty_$cmapM
      Data.Traversable.$fTraversableNonEmpty_$csequence

-- RHS size: {terms: 16, types: 26, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableMaybe_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Maybe (f a) -> f (Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abW1n :: * -> *))
                 (@ a_abW1o)
                 ($dApplicative_abW1q [Occ=Once*] :: Applicative f_abW1n)
                 (eta_B1 [Occ=Once!] :: Maybe (f_abW1n a_abW1o)) ->
                 case eta_B1 of {
                   Nothing ->
                     pure
                       @ f_abW1n
                       $dApplicative_abW1q
                       @ (Maybe a_abW1o)
                       (GHC.Base.Nothing @ a_abW1o);
                   Just x_abVgf [Occ=Once] ->
                     fmap
                       @ f_abW1n
                       (GHC.Base.$p1Applicative @ f_abW1n $dApplicative_abW1q)
                       @ a_abW1o
                       @ (Maybe a_abW1o)
                       (GHC.Base.Just @ a_abW1o)
                       x_abVgf
                 }}]
Data.Traversable.$fTraversableMaybe_$csequenceA
  = \ (@ (f_abW1n :: * -> *))
      (@ a_abW1o)
      ($dApplicative_abW1q :: Applicative f_abW1n)
      (eta_B1 :: Maybe (f_abW1n a_abW1o)) ->
      case eta_B1 of {
        Nothing ->
          pure
            @ f_abW1n
            $dApplicative_abW1q
            @ (Maybe a_abW1o)
            (GHC.Base.Nothing @ a_abW1o);
        Just x_abVgf ->
          fmap
            @ f_abW1n
            (GHC.Base.$p1Applicative @ f_abW1n $dApplicative_abW1q)
            @ a_abW1o
            @ (Maybe a_abW1o)
            (GHC.Base.Just @ a_abW1o)
            x_abVgf
      }

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableMaybe_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Maybe a -> m (Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abW1z :: * -> *))
                 (@ a_abW1A)
                 (@ b_abW1B)
                 ($dMonad_abW1D [Occ=Once] :: Monad m_abW1z) ->
                 Data.Traversable.$fTraversableFirst_$ctraverse
                   @ m_abW1z
                   @ a_abW1A
                   @ b_abW1B
                   (GHC.Base.$p1Monad @ m_abW1z $dMonad_abW1D)}]
Data.Traversable.$fTraversableMaybe_$cmapM
  = \ (@ (m_abW1z :: * -> *))
      (@ a_abW1A)
      (@ b_abW1B)
      ($dMonad_abW1D :: Monad m_abW1z)
      (eta_B2 :: a_abW1A -> m_abW1z b_abW1B)
      (eta1_B1 :: Maybe a_abW1A) ->
      Data.Traversable.$fTraversableFirst_$ctraverse
        @ m_abW1z
        @ a_abW1A
        @ b_abW1B
        (GHC.Base.$p1Monad @ m_abW1z $dMonad_abW1D)
        eta_B2
        eta1_B1

-- RHS size: {terms: 18, types: 28, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableMaybe_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Maybe (m a) -> m (Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abW1N :: * -> *))
                 (@ a_abW1O)
                 ($dMonad_abW1Q [Occ=OnceL] :: Monad m_abW1N) ->
                 let {
                   $dApplicative_abW1q [Occ=OnceL*] :: Applicative m_abW1N
                   [LclId]
                   $dApplicative_abW1q
                     = GHC.Base.$p1Monad @ m_abW1N $dMonad_abW1Q } in
                 \ (eta_B1 [Occ=Once!] :: Maybe (m_abW1N a_abW1O)) ->
                   case eta_B1 of {
                     Nothing ->
                       pure
                         @ m_abW1N
                         $dApplicative_abW1q
                         @ (Maybe a_abW1O)
                         (GHC.Base.Nothing @ a_abW1O);
                     Just x_abVgf [Occ=Once] ->
                       fmap
                         @ m_abW1N
                         (GHC.Base.$p1Applicative @ m_abW1N $dApplicative_abW1q)
                         @ a_abW1O
                         @ (Maybe a_abW1O)
                         (GHC.Base.Just @ a_abW1O)
                         x_abVgf
                   }}]
Data.Traversable.$fTraversableMaybe_$csequence
  = \ (@ (m_abW1N :: * -> *))
      (@ a_abW1O)
      ($dMonad_abW1Q :: Monad m_abW1N)
      (eta_B1 :: Maybe (m_abW1N a_abW1O)) ->
      case eta_B1 of {
        Nothing ->
          pure
            @ m_abW1N
            (GHC.Base.$p1Monad @ m_abW1N $dMonad_abW1Q)
            @ (Maybe a_abW1O)
            (GHC.Base.Nothing @ a_abW1O);
        Just x_abVgf ->
          fmap
            @ m_abW1N
            (GHC.Base.$p1Applicative
               @ m_abW1N (GHC.Base.$p1Monad @ m_abW1N $dMonad_abW1Q))
            @ a_abW1O
            @ (Maybe a_abW1O)
            (GHC.Base.Just @ a_abW1O)
            x_abVgf
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Maybe
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Maybe
                                      GHC.Base.$fFunctorMaybe
                                      Data.Foldable.$fFoldableMaybe
                                      Data.Traversable.$fTraversableFirst_$ctraverse
                                      Data.Traversable.$fTraversableMaybe_$csequenceA
                                      Data.Traversable.$fTraversableMaybe_$cmapM
                                      Data.Traversable.$fTraversableMaybe_$csequence]
Data.Traversable.$fTraversableMaybe
  = Data.Traversable.C:Traversable
      @ Maybe
      GHC.Base.$fFunctorMaybe
      Data.Foldable.$fFoldableMaybe
      Data.Traversable.$fTraversableFirst_$ctraverse
      Data.Traversable.$fTraversableMaybe_$csequenceA
      Data.Traversable.$fTraversableMaybe_$cmapM
      Data.Traversable.$fTraversableMaybe_$csequence

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableFirst1
  :: forall b. Maybe b -> Maybe b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abVNS) (v_X5 [Occ=Once] :: Maybe b_abVNS) -> v_X5}]
Data.Traversable.$fTraversableFirst1
  = \ (@ b_abVNS) (v_X5 :: Maybe b_abVNS) -> v_X5

-- RHS size: {terms: 14, types: 25, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Last a -> f (Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVNQ :: * -> *))
                 (@ a_abVNR)
                 (@ b_abVNS)
                 ($dApplicative_abVNU :: Applicative f_abVNQ)
                 (eta_B2 [Occ=Once] :: a_abVNR -> f_abVNQ b_abVNS)
                 (eta1_B1 [Occ=Once] :: Last a_abVNR) ->
                 fmap
                   @ f_abVNQ
                   (GHC.Base.$p1Applicative @ f_abVNQ $dApplicative_abVNU)
                   @ (Maybe b_abVNS)
                   @ (Last b_abVNS)
                   ((Data.Traversable.$fTraversableFirst1 @ b_abVNS)
                    `cast` (<Maybe b_abVNS>_R
                            ->_R Sym (Data.Monoid.N:Last[0]) <b_abVNS>_N
                            :: (Maybe b_abVNS -> Maybe b_abVNS :: *)
                               ~R# (Maybe b_abVNS -> Last b_abVNS :: *)))
                   (Data.Traversable.$fTraversableFirst_$ctraverse
                      @ f_abVNQ
                      @ a_abVNR
                      @ b_abVNS
                      $dApplicative_abVNU
                      eta_B2
                      (eta1_B1
                       `cast` (Data.Monoid.N:Last[0] <a_abVNR>_N
                               :: (Last a_abVNR :: *) ~R# (Maybe a_abVNR :: *))))}]
Data.Traversable.$fTraversableLast_$ctraverse
  = \ (@ (f_abVNQ :: * -> *))
      (@ a_abVNR)
      (@ b_abVNS)
      ($dApplicative_abVNU :: Applicative f_abVNQ)
      (eta_B2 :: a_abVNR -> f_abVNQ b_abVNS)
      (eta1_B1 :: Last a_abVNR) ->
      fmap
        @ f_abVNQ
        (GHC.Base.$p1Applicative @ f_abVNQ $dApplicative_abVNU)
        @ (Maybe b_abVNS)
        @ (Last b_abVNS)
        ((Data.Traversable.$fTraversableFirst1 @ b_abVNS)
         `cast` (<Maybe b_abVNS>_R
                 ->_R Sym (Data.Monoid.N:Last[0]) <b_abVNS>_N
                 :: (Maybe b_abVNS -> Maybe b_abVNS :: *)
                    ~R# (Maybe b_abVNS -> Last b_abVNS :: *)))
        (Data.Traversable.$fTraversableFirst_$ctraverse
           @ f_abVNQ
           @ a_abVNR
           @ b_abVNS
           $dApplicative_abVNU
           eta_B2
           (eta1_B1
            `cast` (Data.Monoid.N:Last[0] <a_abVNR>_N
                    :: (Last a_abVNR :: *) ~R# (Maybe a_abVNR :: *))))

-- RHS size: {terms: 20, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Last (f a) -> f (Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVOa :: * -> *))
                 (@ a_abVOb)
                 ($dApplicative_abVOd :: Applicative f_abVOa)
                 (eta_B1 [Occ=Once] :: Last (f_abVOa a_abVOb)) ->
                 fmap
                   @ f_abVOa
                   (GHC.Base.$p1Applicative @ f_abVOa $dApplicative_abVOd)
                   @ (Maybe a_abVOb)
                   @ (Last a_abVOb)
                   ((Data.Traversable.$fTraversableFirst1 @ a_abVOb)
                    `cast` (<Maybe a_abVOb>_R
                            ->_R Sym (Data.Monoid.N:Last[0]) <a_abVOb>_N
                            :: (Maybe a_abVOb -> Maybe a_abVOb :: *)
                               ~R# (Maybe a_abVOb -> Last a_abVOb :: *)))
                   (case eta_B1
                         `cast` (Data.Monoid.N:Last[0] <f_abVOa a_abVOb>_N
                                 :: (Last (f_abVOa a_abVOb) :: *)
                                    ~R# (Maybe (f_abVOa a_abVOb) :: *))
                    of {
                      Nothing ->
                        pure
                          @ f_abVOa
                          $dApplicative_abVOd
                          @ (Maybe a_abVOb)
                          (GHC.Base.Nothing @ a_abVOb);
                      Just x_abVgf [Occ=Once] ->
                        fmap
                          @ f_abVOa
                          (GHC.Base.$p1Applicative @ f_abVOa $dApplicative_abVOd)
                          @ a_abVOb
                          @ (Maybe a_abVOb)
                          (GHC.Base.Just @ a_abVOb)
                          x_abVgf
                    })}]
Data.Traversable.$fTraversableLast_$csequenceA
  = \ (@ (f_abVOa :: * -> *))
      (@ a_abVOb)
      ($dApplicative_abVOd :: Applicative f_abVOa)
      (eta_B1 :: Last (f_abVOa a_abVOb)) ->
      fmap
        @ f_abVOa
        (GHC.Base.$p1Applicative @ f_abVOa $dApplicative_abVOd)
        @ (Maybe a_abVOb)
        @ (Last a_abVOb)
        ((Data.Traversable.$fTraversableFirst1 @ a_abVOb)
         `cast` (<Maybe a_abVOb>_R
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_abVOb>_N
                 :: (Maybe a_abVOb -> Maybe a_abVOb :: *)
                    ~R# (Maybe a_abVOb -> Last a_abVOb :: *)))
        (case eta_B1
              `cast` (Data.Monoid.N:Last[0] <f_abVOa a_abVOb>_N
                      :: (Last (f_abVOa a_abVOb) :: *)
                         ~R# (Maybe (f_abVOa a_abVOb) :: *))
         of {
           Nothing ->
             pure
               @ f_abVOa
               $dApplicative_abVOd
               @ (Maybe a_abVOb)
               (GHC.Base.Nothing @ a_abVOb);
           Just x_abVgf ->
             fmap
               @ f_abVOa
               (GHC.Base.$p1Applicative @ f_abVOa $dApplicative_abVOd)
               @ a_abVOb
               @ (Maybe a_abVOb)
               (GHC.Base.Just @ a_abVOb)
               x_abVgf
         })

-- RHS size: {terms: 17, types: 28, coercions: 8, joins: 0/1}
Data.Traversable.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Last a -> m (Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVOm :: * -> *))
                 (@ a_abVOn)
                 (@ b_abVOo)
                 ($dMonad_abVOq [Occ=OnceL] :: Monad m_abVOm) ->
                 let {
                   $dApplicative_abVNU :: Applicative m_abVOm
                   [LclId]
                   $dApplicative_abVNU
                     = GHC.Base.$p1Monad @ m_abVOm $dMonad_abVOq } in
                 \ (eta_B2 [Occ=Once] :: a_abVOn -> m_abVOm b_abVOo)
                   (eta1_B1 [Occ=Once] :: Last a_abVOn) ->
                   fmap
                     @ m_abVOm
                     (GHC.Base.$p1Applicative @ m_abVOm $dApplicative_abVNU)
                     @ (Maybe b_abVOo)
                     @ (Last b_abVOo)
                     ((Data.Traversable.$fTraversableFirst1 @ b_abVOo)
                      `cast` (<Maybe b_abVOo>_R
                              ->_R Sym (Data.Monoid.N:Last[0]) <b_abVOo>_N
                              :: (Maybe b_abVOo -> Maybe b_abVOo :: *)
                                 ~R# (Maybe b_abVOo -> Last b_abVOo :: *)))
                     (Data.Traversable.$fTraversableFirst_$ctraverse
                        @ m_abVOm
                        @ a_abVOn
                        @ b_abVOo
                        $dApplicative_abVNU
                        eta_B2
                        (eta1_B1
                         `cast` (Data.Monoid.N:Last[0] <a_abVOn>_N
                                 :: (Last a_abVOn :: *) ~R# (Maybe a_abVOn :: *))))}]
Data.Traversable.$fTraversableLast_$cmapM
  = \ (@ (m_abVOm :: * -> *))
      (@ a_abVOn)
      (@ b_abVOo)
      ($dMonad_abVOq :: Monad m_abVOm)
      (eta_B2 :: a_abVOn -> m_abVOm b_abVOo)
      (eta1_B1 :: Last a_abVOn) ->
      let {
        $dApplicative_sbWC8 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
          :: Applicative m_abVOm
        [LclId]
        $dApplicative_sbWC8
          = GHC.Base.$p1Monad @ m_abVOm $dMonad_abVOq } in
      fmap
        @ m_abVOm
        (GHC.Base.$p1Applicative @ m_abVOm $dApplicative_sbWC8)
        @ (Maybe b_abVOo)
        @ (Last b_abVOo)
        ((Data.Traversable.$fTraversableFirst1 @ b_abVOo)
         `cast` (<Maybe b_abVOo>_R
                 ->_R Sym (Data.Monoid.N:Last[0]) <b_abVOo>_N
                 :: (Maybe b_abVOo -> Maybe b_abVOo :: *)
                    ~R# (Maybe b_abVOo -> Last b_abVOo :: *)))
        (Data.Traversable.$fTraversableFirst_$ctraverse
           @ m_abVOm
           @ a_abVOn
           @ b_abVOo
           $dApplicative_sbWC8
           eta_B2
           (eta1_B1
            `cast` (Data.Monoid.N:Last[0] <a_abVOn>_N
                    :: (Last a_abVOn :: *) ~R# (Maybe a_abVOn :: *))))

-- RHS size: {terms: 23, types: 36, coercions: 9, joins: 0/1}
Data.Traversable.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Last (m a) -> m (Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVOA :: * -> *))
                 (@ a_abVOB)
                 ($dMonad_abVOD [Occ=OnceL] :: Monad m_abVOA) ->
                 let {
                   $dApplicative_abVNU :: Applicative m_abVOA
                   [LclId]
                   $dApplicative_abVNU
                     = GHC.Base.$p1Monad @ m_abVOA $dMonad_abVOD } in
                 \ (eta_B1 [Occ=Once] :: Last (m_abVOA a_abVOB)) ->
                   fmap
                     @ m_abVOA
                     (GHC.Base.$p1Applicative @ m_abVOA $dApplicative_abVNU)
                     @ (Maybe a_abVOB)
                     @ (Last a_abVOB)
                     ((Data.Traversable.$fTraversableFirst1 @ a_abVOB)
                      `cast` (<Maybe a_abVOB>_R
                              ->_R Sym (Data.Monoid.N:Last[0]) <a_abVOB>_N
                              :: (Maybe a_abVOB -> Maybe a_abVOB :: *)
                                 ~R# (Maybe a_abVOB -> Last a_abVOB :: *)))
                     (case eta_B1
                           `cast` (Data.Monoid.N:Last[0] <m_abVOA a_abVOB>_N
                                   :: (Last (m_abVOA a_abVOB) :: *)
                                      ~R# (Maybe (m_abVOA a_abVOB) :: *))
                      of {
                        Nothing ->
                          pure
                            @ m_abVOA
                            $dApplicative_abVNU
                            @ (Maybe a_abVOB)
                            (GHC.Base.Nothing @ a_abVOB);
                        Just x_abVgf [Occ=Once] ->
                          fmap
                            @ m_abVOA
                            (GHC.Base.$p1Applicative @ m_abVOA $dApplicative_abVNU)
                            @ a_abVOB
                            @ (Maybe a_abVOB)
                            (GHC.Base.Just @ a_abVOB)
                            x_abVgf
                      })}]
Data.Traversable.$fTraversableLast_$csequence
  = \ (@ (m_abVOA :: * -> *))
      (@ a_abVOB)
      ($dMonad_abVOD :: Monad m_abVOA)
      (eta_B1 :: Last (m_abVOA a_abVOB)) ->
      let {
        $dApplicative_sbWC6 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
          :: Applicative m_abVOA
        [LclId]
        $dApplicative_sbWC6
          = GHC.Base.$p1Monad @ m_abVOA $dMonad_abVOD } in
      fmap
        @ m_abVOA
        (GHC.Base.$p1Applicative @ m_abVOA $dApplicative_sbWC6)
        @ (Maybe a_abVOB)
        @ (Last a_abVOB)
        ((Data.Traversable.$fTraversableFirst1 @ a_abVOB)
         `cast` (<Maybe a_abVOB>_R
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_abVOB>_N
                 :: (Maybe a_abVOB -> Maybe a_abVOB :: *)
                    ~R# (Maybe a_abVOB -> Last a_abVOB :: *)))
        (case eta_B1
              `cast` (Data.Monoid.N:Last[0] <m_abVOA a_abVOB>_N
                      :: (Last (m_abVOA a_abVOB) :: *)
                         ~R# (Maybe (m_abVOA a_abVOB) :: *))
         of {
           Nothing ->
             pure
               @ m_abVOA
               $dApplicative_sbWC6
               @ (Maybe a_abVOB)
               (GHC.Base.Nothing @ a_abVOB);
           Just x_abVgf ->
             fmap
               @ m_abVOA
               (GHC.Base.$p1Applicative @ m_abVOA $dApplicative_sbWC6)
               @ a_abVOB
               @ (Maybe a_abVOB)
               (GHC.Base.Just @ a_abVOB)
               x_abVgf
         })

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Last
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Last
                                      Data.Monoid.$fFunctorLast
                                      Data.Foldable.$fFoldableLast
                                      Data.Traversable.$fTraversableLast_$ctraverse
                                      Data.Traversable.$fTraversableLast_$csequenceA
                                      Data.Traversable.$fTraversableLast_$cmapM
                                      Data.Traversable.$fTraversableLast_$csequence]
Data.Traversable.$fTraversableLast
  = Data.Traversable.C:Traversable
      @ Last
      Data.Monoid.$fFunctorLast
      Data.Foldable.$fFoldableLast
      Data.Traversable.$fTraversableLast_$ctraverse
      Data.Traversable.$fTraversableLast_$csequenceA
      Data.Traversable.$fTraversableLast_$cmapM
      Data.Traversable.$fTraversableLast_$csequence

-- RHS size: {terms: 14, types: 25, coercions: 8, joins: 0/0}
Data.Traversable.$fTraversableFirst_$ctraverse1
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> First a -> f (First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_abVOW :: * -> *))
                 (@ a_abVOX)
                 (@ b_abVOY)
                 ($dApplicative_abVP0 :: Applicative f_abVOW)
                 (eta_B2 [Occ=Once] :: a_abVOX -> f_abVOW b_abVOY)
                 (eta1_B1 [Occ=Once] :: First a_abVOX) ->
                 fmap
                   @ f_abVOW
                   (GHC.Base.$p1Applicative @ f_abVOW $dApplicative_abVP0)
                   @ (Maybe b_abVOY)
                   @ (First b_abVOY)
                   ((Data.Traversable.$fTraversableFirst1 @ b_abVOY)
                    `cast` (<Maybe b_abVOY>_R
                            ->_R Sym (Data.Monoid.N:First[0]) <b_abVOY>_N
                            :: (Maybe b_abVOY -> Maybe b_abVOY :: *)
                               ~R# (Maybe b_abVOY -> First b_abVOY :: *)))
                   (Data.Traversable.$fTraversableFirst_$ctraverse
                      @ f_abVOW
                      @ a_abVOX
                      @ b_abVOY
                      $dApplicative_abVP0
                      eta_B2
                      (eta1_B1
                       `cast` (Data.Monoid.N:First[0] <a_abVOX>_N
                               :: (First a_abVOX :: *) ~R# (Maybe a_abVOX :: *))))}]
Data.Traversable.$fTraversableFirst_$ctraverse1
  = \ (@ (f_abVOW :: * -> *))
      (@ a_abVOX)
      (@ b_abVOY)
      ($dApplicative_abVP0 :: Applicative f_abVOW)
      (eta_B2 :: a_abVOX -> f_abVOW b_abVOY)
      (eta1_B1 :: First a_abVOX) ->
      fmap
        @ f_abVOW
        (GHC.Base.$p1Applicative @ f_abVOW $dApplicative_abVP0)
        @ (Maybe b_abVOY)
        @ (First b_abVOY)
        ((Data.Traversable.$fTraversableFirst1 @ b_abVOY)
         `cast` (<Maybe b_abVOY>_R
                 ->_R Sym (Data.Monoid.N:First[0]) <b_abVOY>_N
                 :: (Maybe b_abVOY -> Maybe b_abVOY :: *)
                    ~R# (Maybe b_abVOY -> First b_abVOY :: *)))
        (Data.Traversable.$fTraversableFirst_$ctraverse
           @ f_abVOW
           @ a_abVOX
           @ b_abVOY
           $dApplicative_abVP0
           eta_B2
           (eta1_B1
            `cast` (Data.Monoid.N:First[0] <a_abVOX>_N
                    :: (First a_abVOX :: *) ~R# (Maybe a_abVOX :: *))))

-- RHS size: {terms: 20, types: 33, coercions: 9, joins: 0/0}
Data.Traversable.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     First (f a) -> f (First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_abVPg :: * -> *))
                 (@ a_abVPh)
                 ($dApplicative_abVPj :: Applicative f_abVPg)
                 (eta_B1 [Occ=Once] :: First (f_abVPg a_abVPh)) ->
                 fmap
                   @ f_abVPg
                   (GHC.Base.$p1Applicative @ f_abVPg $dApplicative_abVPj)
                   @ (Maybe a_abVPh)
                   @ (First a_abVPh)
                   ((Data.Traversable.$fTraversableFirst1 @ a_abVPh)
                    `cast` (<Maybe a_abVPh>_R
                            ->_R Sym (Data.Monoid.N:First[0]) <a_abVPh>_N
                            :: (Maybe a_abVPh -> Maybe a_abVPh :: *)
                               ~R# (Maybe a_abVPh -> First a_abVPh :: *)))
                   (case eta_B1
                         `cast` (Data.Monoid.N:First[0] <f_abVPg a_abVPh>_N
                                 :: (First (f_abVPg a_abVPh) :: *)
                                    ~R# (Maybe (f_abVPg a_abVPh) :: *))
                    of {
                      Nothing ->
                        pure
                          @ f_abVPg
                          $dApplicative_abVPj
                          @ (Maybe a_abVPh)
                          (GHC.Base.Nothing @ a_abVPh);
                      Just x_abVgf [Occ=Once] ->
                        fmap
                          @ f_abVPg
                          (GHC.Base.$p1Applicative @ f_abVPg $dApplicative_abVPj)
                          @ a_abVPh
                          @ (Maybe a_abVPh)
                          (GHC.Base.Just @ a_abVPh)
                          x_abVgf
                    })}]
Data.Traversable.$fTraversableFirst_$csequenceA
  = \ (@ (f_abVPg :: * -> *))
      (@ a_abVPh)
      ($dApplicative_abVPj :: Applicative f_abVPg)
      (eta_B1 :: First (f_abVPg a_abVPh)) ->
      fmap
        @ f_abVPg
        (GHC.Base.$p1Applicative @ f_abVPg $dApplicative_abVPj)
        @ (Maybe a_abVPh)
        @ (First a_abVPh)
        ((Data.Traversable.$fTraversableFirst1 @ a_abVPh)
         `cast` (<Maybe a_abVPh>_R
                 ->_R Sym (Data.Monoid.N:First[0]) <a_abVPh>_N
                 :: (Maybe a_abVPh -> Maybe a_abVPh :: *)
                    ~R# (Maybe a_abVPh -> First a_abVPh :: *)))
        (case eta_B1
              `cast` (Data.Monoid.N:First[0] <f_abVPg a_abVPh>_N
                      :: (First (f_abVPg a_abVPh) :: *)
                         ~R# (Maybe (f_abVPg a_abVPh) :: *))
         of {
           Nothing ->
             pure
               @ f_abVPg
               $dApplicative_abVPj
               @ (Maybe a_abVPh)
               (GHC.Base.Nothing @ a_abVPh);
           Just x_abVgf ->
             fmap
               @ f_abVPg
               (GHC.Base.$p1Applicative @ f_abVPg $dApplicative_abVPj)
               @ a_abVPh
               @ (Maybe a_abVPh)
               (GHC.Base.Just @ a_abVPh)
               x_abVgf
         })

-- RHS size: {terms: 17, types: 28, coercions: 8, joins: 0/1}
Data.Traversable.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> First a -> m (First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVPs :: * -> *))
                 (@ a_abVPt)
                 (@ b_abVPu)
                 ($dMonad_abVPw [Occ=OnceL] :: Monad m_abVPs) ->
                 let {
                   $dApplicative_abVP0 :: Applicative m_abVPs
                   [LclId]
                   $dApplicative_abVP0
                     = GHC.Base.$p1Monad @ m_abVPs $dMonad_abVPw } in
                 \ (eta_B2 [Occ=Once] :: a_abVPt -> m_abVPs b_abVPu)
                   (eta1_B1 [Occ=Once] :: First a_abVPt) ->
                   fmap
                     @ m_abVPs
                     (GHC.Base.$p1Applicative @ m_abVPs $dApplicative_abVP0)
                     @ (Maybe b_abVPu)
                     @ (First b_abVPu)
                     ((Data.Traversable.$fTraversableFirst1 @ b_abVPu)
                      `cast` (<Maybe b_abVPu>_R
                              ->_R Sym (Data.Monoid.N:First[0]) <b_abVPu>_N
                              :: (Maybe b_abVPu -> Maybe b_abVPu :: *)
                                 ~R# (Maybe b_abVPu -> First b_abVPu :: *)))
                     (Data.Traversable.$fTraversableFirst_$ctraverse
                        @ m_abVPs
                        @ a_abVPt
                        @ b_abVPu
                        $dApplicative_abVP0
                        eta_B2
                        (eta1_B1
                         `cast` (Data.Monoid.N:First[0] <a_abVPt>_N
                                 :: (First a_abVPt :: *) ~R# (Maybe a_abVPt :: *))))}]
Data.Traversable.$fTraversableFirst_$cmapM
  = \ (@ (m_abVPs :: * -> *))
      (@ a_abVPt)
      (@ b_abVPu)
      ($dMonad_abVPw :: Monad m_abVPs)
      (eta_B2 :: a_abVPt -> m_abVPs b_abVPu)
      (eta1_B1 :: First a_abVPt) ->
      let {
        $dApplicative_sbWC4 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
          :: Applicative m_abVPs
        [LclId]
        $dApplicative_sbWC4
          = GHC.Base.$p1Monad @ m_abVPs $dMonad_abVPw } in
      fmap
        @ m_abVPs
        (GHC.Base.$p1Applicative @ m_abVPs $dApplicative_sbWC4)
        @ (Maybe b_abVPu)
        @ (First b_abVPu)
        ((Data.Traversable.$fTraversableFirst1 @ b_abVPu)
         `cast` (<Maybe b_abVPu>_R
                 ->_R Sym (Data.Monoid.N:First[0]) <b_abVPu>_N
                 :: (Maybe b_abVPu -> Maybe b_abVPu :: *)
                    ~R# (Maybe b_abVPu -> First b_abVPu :: *)))
        (Data.Traversable.$fTraversableFirst_$ctraverse
           @ m_abVPs
           @ a_abVPt
           @ b_abVPu
           $dApplicative_sbWC4
           eta_B2
           (eta1_B1
            `cast` (Data.Monoid.N:First[0] <a_abVPt>_N
                    :: (First a_abVPt :: *) ~R# (Maybe a_abVPt :: *))))

-- RHS size: {terms: 23, types: 36, coercions: 9, joins: 0/1}
Data.Traversable.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => First (m a) -> m (First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_abVPG :: * -> *))
                 (@ a_abVPH)
                 ($dMonad_abVPJ [Occ=OnceL] :: Monad m_abVPG) ->
                 let {
                   $dApplicative_abVP0 :: Applicative m_abVPG
                   [LclId]
                   $dApplicative_abVP0
                     = GHC.Base.$p1Monad @ m_abVPG $dMonad_abVPJ } in
                 \ (eta_B1 [Occ=Once] :: First (m_abVPG a_abVPH)) ->
                   fmap
                     @ m_abVPG
                     (GHC.Base.$p1Applicative @ m_abVPG $dApplicative_abVP0)
                     @ (Maybe a_abVPH)
                     @ (First a_abVPH)
                     ((Data.Traversable.$fTraversableFirst1 @ a_abVPH)
                      `cast` (<Maybe a_abVPH>_R
                              ->_R Sym (Data.Monoid.N:First[0]) <a_abVPH>_N
                              :: (Maybe a_abVPH -> Maybe a_abVPH :: *)
                                 ~R# (Maybe a_abVPH -> First a_abVPH :: *)))
                     (case eta_B1
                           `cast` (Data.Monoid.N:First[0] <m_abVPG a_abVPH>_N
                                   :: (First (m_abVPG a_abVPH) :: *)
                                      ~R# (Maybe (m_abVPG a_abVPH) :: *))
                      of {
                        Nothing ->
                          pure
                            @ m_abVPG
                            $dApplicative_abVP0
                            @ (Maybe a_abVPH)
                            (GHC.Base.Nothing @ a_abVPH);
                        Just x_abVgf [Occ=Once] ->
                          fmap
                            @ m_abVPG
                            (GHC.Base.$p1Applicative @ m_abVPG $dApplicative_abVP0)
                            @ a_abVPH
                            @ (Maybe a_abVPH)
                            (GHC.Base.Just @ a_abVPH)
                            x_abVgf
                      })}]
Data.Traversable.$fTraversableFirst_$csequence
  = \ (@ (m_abVPG :: * -> *))
      (@ a_abVPH)
      ($dMonad_abVPJ :: Monad m_abVPG)
      (eta_B1 :: First (m_abVPG a_abVPH)) ->
      let {
        $dApplicative_sbWC2 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
          :: Applicative m_abVPG
        [LclId]
        $dApplicative_sbWC2
          = GHC.Base.$p1Monad @ m_abVPG $dMonad_abVPJ } in
      fmap
        @ m_abVPG
        (GHC.Base.$p1Applicative @ m_abVPG $dApplicative_sbWC2)
        @ (Maybe a_abVPH)
        @ (First a_abVPH)
        ((Data.Traversable.$fTraversableFirst1 @ a_abVPH)
         `cast` (<Maybe a_abVPH>_R
                 ->_R Sym (Data.Monoid.N:First[0]) <a_abVPH>_N
                 :: (Maybe a_abVPH -> Maybe a_abVPH :: *)
                    ~R# (Maybe a_abVPH -> First a_abVPH :: *)))
        (case eta_B1
              `cast` (Data.Monoid.N:First[0] <m_abVPG a_abVPH>_N
                      :: (First (m_abVPG a_abVPH) :: *)
                         ~R# (Maybe (m_abVPG a_abVPH) :: *))
         of {
           Nothing ->
             pure
               @ m_abVPG
               $dApplicative_sbWC2
               @ (Maybe a_abVPH)
               (GHC.Base.Nothing @ a_abVPH);
           Just x_abVgf ->
             fmap
               @ m_abVPG
               (GHC.Base.$p1Applicative @ m_abVPG $dApplicative_sbWC2)
               @ a_abVPH
               @ (Maybe a_abVPH)
               (GHC.Base.Just @ a_abVPH)
               x_abVgf
         })

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Traversable.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable First
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: First
                                      Data.Monoid.$fFunctorFirst
                                      Data.Foldable.$fFoldableFirst
                                      Data.Traversable.$fTraversableFirst_$ctraverse1
                                      Data.Traversable.$fTraversableFirst_$csequenceA
                                      Data.Traversable.$fTraversableFirst_$cmapM
                                      Data.Traversable.$fTraversableFirst_$csequence]
Data.Traversable.$fTraversableFirst
  = Data.Traversable.C:Traversable
      @ First
      Data.Monoid.$fFunctorFirst
      Data.Foldable.$fFoldableFirst
      Data.Traversable.$fTraversableFirst_$ctraverse1
      Data.Traversable.$fTraversableFirst_$csequenceA
      Data.Traversable.$fTraversableFirst_$cmapM
      Data.Traversable.$fTraversableFirst_$csequence

-- RHS size: {terms: 20, types: 40, coercions: 0, joins: 0/2}
Data.Traversable.$dmtraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Traversable t =>
     forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C(U)),A),A,A,1*C1(C(U)),A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_abVfw :: * -> *))
                 ($dTraversable_abVtJ :: Traversable t_abVfw) ->
                 let {
                   $dFunctor_abW2p [Occ=OnceL] :: Functor t_abVfw
                   [LclId]
                   $dFunctor_abW2p
                     = Data.Traversable.$p1Traversable
                         @ t_abVfw $dTraversable_abVtJ } in
                 \ (@ (f_abVtL :: * -> *))
                   (@ a_abVtM)
                   (@ b_abVtN)
                   ($dApplicative_abVtP [Occ=Once] :: Applicative f_abVtL)
                   (f1_abVfH [Occ=Once] :: a_abVtM -> f_abVtL b_abVtN) ->
                   let {
                     f2_i7Rxg [Occ=OnceL!]
                       :: t_abVfw (f_abVtL b_abVtN) -> f_abVtL (t_abVfw b_abVtN)
                     [LclId]
                     f2_i7Rxg
                       = sequenceA
                           @ t_abVfw
                           $dTraversable_abVtJ
                           @ f_abVtL
                           @ b_abVtN
                           $dApplicative_abVtP } in
                   let {
                     g_i7Rxh [Occ=OnceL!]
                       :: t_abVfw a_abVtM -> t_abVfw (f_abVtL b_abVtN)
                     [LclId]
                     g_i7Rxh
                       = fmap
                           @ t_abVfw
                           $dFunctor_abW2p
                           @ a_abVtM
                           @ (f_abVtL b_abVtN)
                           f1_abVfH } in
                   \ (x_i7Rxi [Occ=Once] :: t_abVfw a_abVtM) ->
                     f2_i7Rxg (g_i7Rxh x_i7Rxi)}]
Data.Traversable.$dmtraverse
  = \ (@ (t_abVfw :: * -> *))
      ($dTraversable_abVtJ :: Traversable t_abVfw)
      (@ (f_abVtL :: * -> *))
      (@ a_abVtM)
      (@ b_abVtN)
      (eta_B2 :: Applicative f_abVtL)
      (eta1_B1 :: a_abVtM -> f_abVtL b_abVtN) ->
      let {
        f1_sbWC0 [Dmd=<L,C(U)>]
          :: t_abVfw (f_abVtL b_abVtN) -> f_abVtL (t_abVfw b_abVtN)
        [LclId]
        f1_sbWC0
          = sequenceA
              @ t_abVfw $dTraversable_abVtJ @ f_abVtL @ b_abVtN eta_B2 } in
      let {
        g_sbWBZ [Dmd=<L,C(U)>]
          :: t_abVfw a_abVtM -> t_abVfw (f_abVtL b_abVtN)
        [LclId]
        g_sbWBZ
          = fmap
              @ t_abVfw
              (Data.Traversable.$p1Traversable @ t_abVfw $dTraversable_abVtJ)
              @ a_abVtM
              @ (f_abVtL b_abVtN)
              eta1_B1 } in
      \ (x_i7Rxi :: t_abVfw a_abVtM) -> f1_sbWC0 (g_sbWBZ x_i7Rxi)

-- RHS size: {terms: 15, types: 33, coercions: 0, joins: 0/1}
for [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Traversable t, Applicative f) =>
     t a -> (a -> f b) -> f (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(C1(U))),A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (t_abVts :: * -> *))
                 (@ (f_abVtt :: * -> *))
                 (@ a_abVtu)
                 (@ b_abVtv)
                 ($dTraversable_abVtx [Occ=Once] :: Traversable t_abVts)
                 ($dApplicative_abVty [Occ=Once] :: Applicative f_abVtt) ->
                 let {
                   f1_i8X9W [Occ=OnceL!]
                     :: (a_abVtu -> f_abVtt b_abVtv)
                        -> t_abVts a_abVtu -> f_abVtt (t_abVts b_abVtv)
                   [LclId]
                   f1_i8X9W
                     = traverse
                         @ t_abVts
                         $dTraversable_abVtx
                         @ f_abVtt
                         @ a_abVtu
                         @ b_abVtv
                         $dApplicative_abVty } in
                 \ (x_i8X9X [Occ=Once] :: t_abVts a_abVtu)
                   (y_i8X9Y [Occ=Once] :: a_abVtu -> f_abVtt b_abVtv) ->
                   f1_i8X9W y_i8X9Y x_i8X9X}]
for
  = \ (@ (t_abVts :: * -> *))
      (@ (f_abVtt :: * -> *))
      (@ a_abVtu)
      (@ b_abVtv)
      ($dTraversable_abVtx :: Traversable t_abVts)
      ($dApplicative_abVty :: Applicative f_abVtt) ->
      let {
        f1_sbWBW [Dmd=<L,C(C1(U))>]
          :: (a_abVtu -> f_abVtt b_abVtv)
             -> t_abVts a_abVtu -> f_abVtt (t_abVts b_abVtv)
        [LclId]
        f1_sbWBW
          = traverse
              @ t_abVts
              $dTraversable_abVtx
              @ f_abVtt
              @ a_abVtu
              @ b_abVtv
              $dApplicative_abVty } in
      \ (x_i8X9X :: t_abVts a_abVtu)
        (y_i8X9Y :: a_abVtu -> f_abVtt b_abVtv) ->
        f1_sbWBW y_i8X9Y x_i8X9X

-- RHS size: {terms: 15, types: 33, coercions: 0, joins: 0/1}
forM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Traversable t, Monad m) =>
     t a -> (a -> m b) -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,1*C1(C(C1(U))),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (t_abVtb :: * -> *))
                 (@ (m_abVtc :: * -> *))
                 (@ a_abVtd)
                 (@ b_abVte)
                 ($dTraversable_abVtg [Occ=Once] :: Traversable t_abVtb)
                 ($dMonad_abVth [Occ=Once] :: Monad m_abVtc) ->
                 let {
                   f_i8X9W [Occ=OnceL!]
                     :: (a_abVtd -> m_abVtc b_abVte)
                        -> t_abVtb a_abVtd -> m_abVtc (t_abVtb b_abVte)
                   [LclId]
                   f_i8X9W
                     = mapM
                         @ t_abVtb
                         $dTraversable_abVtg
                         @ m_abVtc
                         @ a_abVtd
                         @ b_abVte
                         $dMonad_abVth } in
                 \ (x_i8X9X [Occ=Once] :: t_abVtb a_abVtd)
                   (y_i8X9Y [Occ=Once] :: a_abVtd -> m_abVtc b_abVte) ->
                   f_i8X9W y_i8X9Y x_i8X9X}]
forM
  = \ (@ (t_abVtb :: * -> *))
      (@ (m_abVtc :: * -> *))
      (@ a_abVtd)
      (@ b_abVte)
      ($dTraversable_abVtg :: Traversable t_abVtb)
      ($dMonad_abVth :: Monad m_abVtc) ->
      let {
        f_sbWBU [Dmd=<L,C(C1(U))>]
          :: (a_abVtd -> m_abVtc b_abVte)
             -> t_abVtb a_abVtd -> m_abVtc (t_abVtb b_abVte)
        [LclId]
        f_sbWBU
          = mapM
              @ t_abVtb
              $dTraversable_abVtg
              @ m_abVtc
              @ a_abVtd
              @ b_abVte
              $dMonad_abVth } in
      \ (x_i8X9X :: t_abVtb a_abVtd)
        (y_i8X9Y :: a_abVtd -> m_abVtc b_abVte) ->
        f_sbWBU y_i8X9Y x_i8X9X

-- RHS size: {terms: 18, types: 28, coercions: 10, joins: 0/0}
mapAccumL
  :: forall (t :: * -> *) a b c.
     Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_abVsK :: * -> *))
                 (@ a_abVsL)
                 (@ b_abVsM)
                 (@ c_abVsN)
                 ($dTraversable_abVsP [Occ=Once] :: Traversable t_abVsK)
                 (f_abVgC [Occ=OnceL!] :: a_abVsL -> b_abVsM -> (a_abVsL, c_abVsN))
                 (s_abVgD [Occ=Once] :: a_abVsL)
                 (t1_abVgE [Occ=Once] :: t_abVsK b_abVsM) ->
                 ((traverse
                     @ t_abVsK
                     $dTraversable_abVsP
                     @ (StateL a_abVsL)
                     @ b_abVsM
                     @ c_abVsN
                     (Data.Functor.Utils.$fApplicativeStateL @ a_abVsL)
                     ((\ (x_i7Rxi [Occ=Once] :: b_abVsM)
                         (y_i8X9Y [Occ=Once] :: a_abVsL) ->
                         f_abVgC y_i8X9Y x_i7Rxi)
                      `cast` (<b_abVsM>_R
                              ->_R Sym (Data.Functor.Utils.N:StateL[0] <a_abVsL>_R <c_abVsN>_R)
                              :: (b_abVsM -> a_abVsL -> (a_abVsL, c_abVsN) :: *)
                                 ~R# (b_abVsM -> StateL a_abVsL c_abVsN :: *)))
                     t1_abVgE)
                  `cast` (Data.Functor.Utils.N:StateL[0]
                              <a_abVsL>_R <t_abVsK c_abVsN>_R
                          :: (StateL a_abVsL (t_abVsK c_abVsN) :: *)
                             ~R# (a_abVsL -> (a_abVsL, t_abVsK c_abVsN) :: *)))
                   s_abVgD}]
mapAccumL
  = \ (@ (t_abVsK :: * -> *))
      (@ a_abVsL)
      (@ b_abVsM)
      (@ c_abVsN)
      ($dTraversable_abVsP :: Traversable t_abVsK)
      (f_abVgC :: a_abVsL -> b_abVsM -> (a_abVsL, c_abVsN))
      (s_abVgD :: a_abVsL)
      (t1_abVgE :: t_abVsK b_abVsM) ->
      ((traverse
          @ t_abVsK
          $dTraversable_abVsP
          @ (StateL a_abVsL)
          @ b_abVsM
          @ c_abVsN
          (Data.Functor.Utils.$fApplicativeStateL @ a_abVsL)
          ((\ (x_i7Rxi :: b_abVsM) (y_i8X9Y :: a_abVsL) ->
              f_abVgC y_i8X9Y x_i7Rxi)
           `cast` (<b_abVsM>_R
                   ->_R Sym (Data.Functor.Utils.N:StateL[0] <a_abVsL>_R <c_abVsN>_R)
                   :: (b_abVsM -> a_abVsL -> (a_abVsL, c_abVsN) :: *)
                      ~R# (b_abVsM -> StateL a_abVsL c_abVsN :: *)))
          t1_abVgE)
       `cast` (Data.Functor.Utils.N:StateL[0]
                   <a_abVsL>_R <t_abVsK c_abVsN>_R
               :: (StateL a_abVsL (t_abVsK c_abVsN) :: *)
                  ~R# (a_abVsL -> (a_abVsL, t_abVsK c_abVsN) :: *)))
        s_abVgD

-- RHS size: {terms: 18, types: 28, coercions: 10, joins: 0/0}
mapAccumR
  :: forall (t :: * -> *) a b c.
     Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_abVsj :: * -> *))
                 (@ a_abVsk)
                 (@ b_abVsl)
                 (@ c_abVsm)
                 ($dTraversable_abVso [Occ=Once] :: Traversable t_abVsj)
                 (f_abVgF [Occ=OnceL!] :: a_abVsk -> b_abVsl -> (a_abVsk, c_abVsm))
                 (s_abVgG [Occ=Once] :: a_abVsk)
                 (t1_abVgH [Occ=Once] :: t_abVsj b_abVsl) ->
                 ((traverse
                     @ t_abVsj
                     $dTraversable_abVso
                     @ (StateR a_abVsk)
                     @ b_abVsl
                     @ c_abVsm
                     (Data.Functor.Utils.$fApplicativeStateR @ a_abVsk)
                     ((\ (x_i7Rxi [Occ=Once] :: b_abVsl)
                         (y_i8X9Y [Occ=Once] :: a_abVsk) ->
                         f_abVgF y_i8X9Y x_i7Rxi)
                      `cast` (<b_abVsl>_R
                              ->_R Sym (Data.Functor.Utils.N:StateR[0] <a_abVsk>_R <c_abVsm>_R)
                              :: (b_abVsl -> a_abVsk -> (a_abVsk, c_abVsm) :: *)
                                 ~R# (b_abVsl -> StateR a_abVsk c_abVsm :: *)))
                     t1_abVgH)
                  `cast` (Data.Functor.Utils.N:StateR[0]
                              <a_abVsk>_R <t_abVsj c_abVsm>_R
                          :: (StateR a_abVsk (t_abVsj c_abVsm) :: *)
                             ~R# (a_abVsk -> (a_abVsk, t_abVsj c_abVsm) :: *)))
                   s_abVgG}]
mapAccumR
  = \ (@ (t_abVsj :: * -> *))
      (@ a_abVsk)
      (@ b_abVsl)
      (@ c_abVsm)
      ($dTraversable_abVso :: Traversable t_abVsj)
      (f_abVgF :: a_abVsk -> b_abVsl -> (a_abVsk, c_abVsm))
      (s_abVgG :: a_abVsk)
      (t1_abVgH :: t_abVsj b_abVsl) ->
      ((traverse
          @ t_abVsj
          $dTraversable_abVso
          @ (StateR a_abVsk)
          @ b_abVsl
          @ c_abVsm
          (Data.Functor.Utils.$fApplicativeStateR @ a_abVsk)
          ((\ (x_i7Rxi :: b_abVsl) (y_i8X9Y :: a_abVsk) ->
              f_abVgF y_i8X9Y x_i7Rxi)
           `cast` (<b_abVsl>_R
                   ->_R Sym (Data.Functor.Utils.N:StateR[0] <a_abVsk>_R <c_abVsm>_R)
                   :: (b_abVsl -> a_abVsk -> (a_abVsk, c_abVsm) :: *)
                      ~R# (b_abVsl -> StateR a_abVsk c_abVsm :: *)))
          t1_abVgH)
       `cast` (Data.Functor.Utils.N:StateR[0]
                   <a_abVsk>_R <t_abVsj c_abVsm>_R
               :: (StateR a_abVsk (t_abVsj c_abVsm) :: *)
                  ~R# (a_abVsk -> (a_abVsk, t_abVsj c_abVsm) :: *)))
        s_abVgG

-- RHS size: {terms: 7, types: 14, coercions: 0, joins: 0/0}
fmapDefault1_rbWTV
  :: forall (t :: * -> *) a b.
     Traversable t =>
     (a -> Identity b) -> t a -> Identity (t b)
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []]
fmapDefault1_rbWTV
  = \ (@ (t_abVrT :: * -> *))
      (@ a_abVrU)
      (@ b_abVrV)
      ($dTraversable_abVrX :: Traversable t_abVrT) ->
      traverse
        @ t_abVrT
        $dTraversable_abVrX
        @ Identity
        @ a_abVrU
        @ b_abVrV
        Data.Functor.Identity.$fApplicativeIdentity

-- RHS size: {terms: 1, types: 0, coercions: 25, joins: 0/0}
fmapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) a b.
     Traversable t =>
     (a -> b) -> t a -> t b
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= (\ (@ (t_XbVxz :: * -> *))
                  (@ a_XbVxB)
                  (@ b_XbVxD)
                  ($dTraversable_XbVxG [Occ=Once] :: Traversable t_XbVxz) ->
                  traverse
                    @ t_XbVxz
                    $dTraversable_XbVxG
                    @ Identity
                    @ a_XbVxB
                    @ b_XbVxD
                    Data.Functor.Identity.$fApplicativeIdentity)
               `cast` (forall (t :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                       <Traversable t>_R
                       ->_R (<a>_R ->_R Data.Functor.Identity.N:Identity[0] <b>_R)
                       ->_R <t a>_R
                       ->_R Data.Functor.Identity.N:Identity[0] <t b>_R
                       :: (forall (t :: * -> *) a b.
                           Traversable t =>
                           (a -> Identity b) -> t a -> Identity (t b) :: *)
                          ~R# (forall (t :: * -> *) a b.
                               Traversable t =>
                               (a -> b) -> t a -> t b :: *))}]
fmapDefault
  = fmapDefault1_rbWTV
    `cast` (forall (t :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
            <Traversable t>_R
            ->_R (<a>_R ->_R Data.Functor.Identity.N:Identity[0] <b>_R)
            ->_R <t a>_R
            ->_R Data.Functor.Identity.N:Identity[0] <t b>_R
            :: (forall (t :: * -> *) a b.
                Traversable t =>
                (a -> Identity b) -> t a -> Identity (t b) :: *)
               ~R# (forall (t :: * -> *) a b.
                    Traversable t =>
                    (a -> b) -> t a -> t b :: *))

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
foldMapDefault1_rbWTW
  :: forall (t :: * -> *) m a.
     (Traversable t, Monoid m) =>
     (a -> Const m ()) -> t a -> Const m (t ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []]
foldMapDefault1_rbWTW
  = \ (@ (t_abVrq :: * -> *))
      (@ m_abVrr)
      (@ a_abVrs)
      ($dTraversable_abVru :: Traversable t_abVrq)
      ($dMonoid_abVrv :: Monoid m_abVrr) ->
      traverse
        @ t_abVrq
        $dTraversable_abVru
        @ (Const m_abVrr)
        @ a_abVrs
        @ ()
        (Data.Functor.Const.$fApplicativeConst @ m_abVrr $dMonoid_abVrv)

-- RHS size: {terms: 1, types: 0, coercions: 34, joins: 0/0}
foldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) m a.
     (Traversable t, Monoid m) =>
     (a -> m) -> t a -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= (\ (@ (t_XbVxd :: * -> *))
                  (@ m_XbVxf)
                  (@ a_XbVxh)
                  ($dTraversable_XbVxk [Occ=Once] :: Traversable t_XbVxd)
                  ($dMonoid_XbVxm [Occ=Once] :: Monoid m_XbVxf) ->
                  traverse
                    @ t_XbVxd
                    $dTraversable_XbVxk
                    @ (Const m_XbVxf)
                    @ a_XbVxh
                    @ ()
                    (Data.Functor.Const.$fApplicativeConst @ m_XbVxf $dMonoid_XbVxm))
               `cast` (forall (t :: <* -> *>_N) (m :: <*>_N) (a :: <*>_N).
                       <Traversable t>_R
                       ->_R <Monoid m>_R
                       ->_R (<a>_R ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <()>_P)
                       ->_R <t a>_R
                       ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <t ()>_P
                       :: (forall (t :: * -> *) m a.
                           (Traversable t, Monoid m) =>
                           (a -> Const m ()) -> t a -> Const m (t ()) :: *)
                          ~R# (forall (t :: * -> *) m a.
                               (Traversable t, Monoid m) =>
                               (a -> m) -> t a -> m :: *))}]
foldMapDefault
  = foldMapDefault1_rbWTW
    `cast` (forall (t :: <* -> *>_N) (m :: <*>_N) (a :: <*>_N).
            <Traversable t>_R
            ->_R <Monoid m>_R
            ->_R (<a>_R ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <()>_P)
            ->_R <t a>_R
            ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <t ()>_P
            :: (forall (t :: * -> *) m a.
                (Traversable t, Monoid m) =>
                (a -> Const m ()) -> t a -> Const m (t ()) :: *)
               ~R# (forall (t :: * -> *) m a.
                    (Traversable t, Monoid m) =>
                    (a -> m) -> t a -> m :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Traversable.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Traversable.$trModule3
  = GHC.Types.TrNameS Data.Traversable.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Traversable.$trModule2 = "Data.Traversable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Traversable.$trModule1
  = GHC.Types.TrNameS Data.Traversable.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Traversable.$trModule
  = GHC.Types.Module
      Data.Traversable.$trModule3 Data.Traversable.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rbWTX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rbWTX
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$tcTraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Traversable.$tcTraversable1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* $krep_rbWTX

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$tcTraversable3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Traversable.$tcTraversable3 = "Traversable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$tcTraversable2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Traversable.$tcTraversable2
  = GHC.Types.TrNameS Data.Traversable.$tcTraversable3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Traversable.$tcTraversable :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Traversable.$tcTraversable
  = GHC.Types.TyCon
      9002450311536760373##
      4172295783860716183##
      Data.Traversable.$trModule
      Data.Traversable.$tcTraversable2
      0#
      Data.Traversable.$tcTraversable1


